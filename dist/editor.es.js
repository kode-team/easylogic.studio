var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj2, key, value) => key in obj2 ? __defProp(obj2, key, { enumerable: true, configurable: true, writable: true, value }) : obj2[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var index = "";
var layout$1 = "";
const MAGIC_METHOD = "@magic:";
const makeEventChecker = (value, split = CHECK_SAPARATOR) => {
  return ` ${split} ${value}`;
};
const CHECK_DOM_EVENT_PATTERN = /domevent (.*)/gi;
const CHECK_CALLBACK_PATTERN = /callback (.*)/gi;
const CHECK_LOAD_PATTERN = /load (.*)/gi;
const CHECK_BIND_PATTERN = /bind (.*)/gi;
const CHECK_SUBSCRIBE_PATTERN = /subscribe (.*)/gi;
const MULTI_PREFIX$1 = "ME@";
const SPLITTER = "|";
const PIPE = (...args2) => {
  return args2.join(SPLITTER);
};
const EVENT = (...args2) => {
  return MULTI_PREFIX$1 + PIPE(...args2);
};
const COMMAND = EVENT;
const ON = EVENT;
const NAME_SAPARATOR = ":";
const CHECK_SAPARATOR = "|";
const DOM_EVENT_SAPARATOR = `${MAGIC_METHOD}domevent `;
const CALLBACK_SAPARATOR = `${MAGIC_METHOD}callback `;
const LOAD_SAPARATOR = `${MAGIC_METHOD}load `;
const BIND_SAPARATOR = `${MAGIC_METHOD}bind `;
const SUBSCRIBE_SAPARATOR = `${MAGIC_METHOD}subscribe `;
const SAPARATOR = " ";
const refManager = {};
const DOM_EVENT_MAKE = (...keys2) => {
  var key = keys2.join(NAME_SAPARATOR);
  return (...args2) => {
    return DOM_EVENT_SAPARATOR + [key, ...args2].join(SAPARATOR);
  };
};
const SUBSCRIBE_EVENT_MAKE = (...args2) => {
  return SUBSCRIBE_SAPARATOR + args2.join(CHECK_SAPARATOR);
};
const CALLBACK_EVENT_MAKE = (...args2) => {
  return CALLBACK_SAPARATOR + args2.join(CHECK_SAPARATOR);
};
const CHECKER = (value, split = CHECK_SAPARATOR) => {
  return makeEventChecker(value, split);
};
const AFTER = (value, split = CHECK_SAPARATOR) => {
  return CHECKER(`after(${value})`, split);
};
const BEFORE = (value, split = CHECK_SAPARATOR) => {
  return CHECKER(`before(${value})`, split);
};
const IF = CHECKER;
const KEY = CHECKER;
const ARROW_UP = CHECKER("ArrowUp");
const ARROW_DOWN = CHECKER("ArrowDown");
const ARROW_LEFT = CHECKER("ArrowLeft");
const ARROW_RIGHT = CHECKER("ArrowRight");
const ENTER = CHECKER("Enter");
const SPACE = CHECKER("Space");
const ESCAPE = CHECKER("Escape");
const ALT = CHECKER("isAltKey");
const SHIFT = CHECKER("isShiftKey");
const META = CHECKER("isMetaKey");
const CONTROL = CHECKER("isCtrlKey");
const MOUSE = CHECKER("hasMouse");
const TOUCH = CHECKER("hasTouch");
const PEN = CHECKER("hasPen");
const SELF = CHECKER("self");
const LEFT_BUTTON = CHECKER("isMouseLeftButton");
const RIGHT_BUTTON = CHECKER("isMouseRightButton");
const FIT = CHECKER("fit");
const PASSIVE = CHECKER("passive");
const DOMDIFF = CHECKER("domdiff");
const DEBOUNCE = (t = 100) => {
  return CHECKER(`debounce(${t})`);
};
const DELAY = (t = 300) => {
  return CHECKER(`delay(${t})`);
};
const D1000 = DEBOUNCE(1e3);
const THROTTLE = (t = 100) => {
  return CHECKER(`throttle(${t})`);
};
const ALL_TRIGGER = CHECKER("allTrigger()");
const SELF_TRIGGER = CHECKER("selfTrigger()");
const CAPTURE = CHECKER("capture()");
const PREVENT = AFTER(`preventDefault`);
const STOP = AFTER(`stopPropagation`);
const SUBSCRIBE = SUBSCRIBE_EVENT_MAKE;
const SUBSCRIBE_ALL = (...args2) => SUBSCRIBE_EVENT_MAKE(...args2, ALL_TRIGGER);
const SUBSCRIBE_SELF = (...args2) => SUBSCRIBE_EVENT_MAKE(...args2, SELF_TRIGGER);
const CONFIG = (config, ...args2) => SUBSCRIBE_EVENT_MAKE(`config:${config}`, ...args2);
const CALLBACK = CALLBACK_EVENT_MAKE;
const RAF = CALLBACK("requestAnimationFrame");
const CUSTOM = DOM_EVENT_MAKE;
const CLICK = DOM_EVENT_MAKE("click");
const DOUBLECLICK = DOM_EVENT_MAKE("dblclick");
const MOUSEDOWN = DOM_EVENT_MAKE("mousedown");
const MOUSEUP = DOM_EVENT_MAKE("mouseup");
const MOUSEMOVE = DOM_EVENT_MAKE("mousemove");
const MOUSEOVER = DOM_EVENT_MAKE("mouseover");
const MOUSEOUT = DOM_EVENT_MAKE("mouseout");
const MOUSEENTER = DOM_EVENT_MAKE("mouseenter");
const MOUSELEAVE = DOM_EVENT_MAKE("mouseleave");
const TOUCHSTART = DOM_EVENT_MAKE("touchstart");
const TOUCHMOVE = DOM_EVENT_MAKE("touchmove");
const TOUCHEND = DOM_EVENT_MAKE("touchend");
const KEYDOWN = DOM_EVENT_MAKE("keydown");
const KEYUP = DOM_EVENT_MAKE("keyup");
const KEYPRESS = DOM_EVENT_MAKE("keypress");
const DRAG = DOM_EVENT_MAKE("drag");
const DRAGSTART = DOM_EVENT_MAKE("dragstart");
const DROP = DOM_EVENT_MAKE("drop");
const DRAGOVER = DOM_EVENT_MAKE("dragover");
const DRAGENTER = DOM_EVENT_MAKE("dragenter");
const DRAGLEAVE = DOM_EVENT_MAKE("dragleave");
const DRAGEXIT = DOM_EVENT_MAKE("dragexit");
const DRAGOUT = DOM_EVENT_MAKE("dragout");
const DRAGEND = DOM_EVENT_MAKE("dragend");
const CONTEXTMENU = DOM_EVENT_MAKE("contextmenu");
const CHANGE = DOM_EVENT_MAKE("change");
const INPUT = DOM_EVENT_MAKE("input");
const FOCUS = DOM_EVENT_MAKE("focus");
const FOCUSIN = DOM_EVENT_MAKE("focusin");
const FOCUSOUT = DOM_EVENT_MAKE("focusout");
const BLUR = DOM_EVENT_MAKE("blur");
const PASTE = DOM_EVENT_MAKE("paste");
const RESIZE = DOM_EVENT_MAKE("resize");
const SCROLL = DOM_EVENT_MAKE("scroll");
const SUBMIT = DOM_EVENT_MAKE("submit");
const POINTERSTART = (...args2) => {
  return CUSTOM("pointerdown")(...args2) + LEFT_BUTTON;
};
const POINTEROVER = CUSTOM("pointerover");
const POINTERENTER = CUSTOM("pointerenter");
const POINTEROUT = CUSTOM("pointerout");
const POINTERMOVE = CUSTOM("pointermove");
const POINTEREND = CUSTOM("pointerup");
const CHANGEINPUT = CUSTOM("change", "input");
const WHEEL = CUSTOM("wheel", "mousewheel", "DOMMouseScroll");
const ANIMATIONSTART = DOM_EVENT_MAKE("animationstart");
const ANIMATIONEND = DOM_EVENT_MAKE("animationend");
const ANIMATIONITERATION = DOM_EVENT_MAKE("animationiteration");
const TRANSITIONSTART = DOM_EVENT_MAKE("transitionstart");
const TRANSITIONEND = DOM_EVENT_MAKE("transitionend");
const TRANSITIONRUN = DOM_EVENT_MAKE("transitionrun");
const TRANSITIONCANCEL = DOM_EVENT_MAKE("transitioncancel");
const DOUBLETAB = CUSTOM("doubletab");
const LOAD = (value = "$el") => {
  return LOAD_SAPARATOR + value;
};
const getRef = (id) => {
  return refManager[id] || "";
};
const BIND_CHECK_FUNCTION = (field) => {
  return function() {
    return this.prevState[field] != this.state[field];
  };
};
const BIND_CHECK_DEFAULT_FUNCTION = () => {
  return true;
};
const BIND = (value = "$el") => {
  return BIND_SAPARATOR + value;
};
function normalizeWheelEvent(e2) {
  let dx = e2.deltaX;
  let dy = e2.deltaY;
  if (dx === 0 && e2.shiftKey) {
    [dy, dx] = [dx, dy];
  }
  if (e2.deltaMode === WheelEvent.DOM_DELTA_LINE) {
    dy *= 8;
  } else if (e2.deltaMode === WheelEvent.DOM_DELTA_PAGE) {
    dy *= 24;
  }
  return [
    limit(dx, 24),
    limit(dy, 24),
    0
  ];
}
function limit(delta, maxDelta) {
  return Math.sign(delta) * Math.min(maxDelta, Math.abs(delta));
}
var Event = {
  addDomEvent(dom, eventName, callback, useCapture = false) {
    if (dom) {
      dom.addEventListener(eventName, callback, useCapture);
    }
  },
  removeDomEvent(dom, eventName, callback) {
    if (dom) {
      dom.removeEventListener(eventName, callback);
    }
  },
  pos(e2) {
    if (e2.touches && e2.touches[0]) {
      return e2.touches[0];
    }
    return e2;
  },
  posXY(e2) {
    var pos = this.pos(e2);
    return {
      x: pos.pageX,
      y: pos.pageY
    };
  }
};
var Event$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  MAGIC_METHOD,
  makeEventChecker,
  CHECK_DOM_EVENT_PATTERN,
  CHECK_CALLBACK_PATTERN,
  CHECK_LOAD_PATTERN,
  CHECK_BIND_PATTERN,
  CHECK_SUBSCRIBE_PATTERN,
  PIPE,
  EVENT,
  COMMAND,
  ON,
  NAME_SAPARATOR,
  CHECK_SAPARATOR,
  DOM_EVENT_SAPARATOR,
  CALLBACK_SAPARATOR,
  LOAD_SAPARATOR,
  BIND_SAPARATOR,
  SUBSCRIBE_SAPARATOR,
  SAPARATOR,
  CHECKER,
  AFTER,
  BEFORE,
  IF,
  KEY,
  ARROW_UP,
  ARROW_DOWN,
  ARROW_LEFT,
  ARROW_RIGHT,
  ENTER,
  SPACE,
  ESCAPE,
  ALT,
  SHIFT,
  META,
  CONTROL,
  MOUSE,
  TOUCH,
  PEN,
  SELF,
  LEFT_BUTTON,
  RIGHT_BUTTON,
  FIT,
  PASSIVE,
  DOMDIFF,
  DEBOUNCE,
  DELAY,
  D1000,
  THROTTLE,
  ALL_TRIGGER,
  SELF_TRIGGER,
  CAPTURE,
  PREVENT,
  STOP,
  SUBSCRIBE,
  SUBSCRIBE_ALL,
  SUBSCRIBE_SELF,
  CONFIG,
  CALLBACK,
  RAF,
  CUSTOM,
  CLICK,
  DOUBLECLICK,
  MOUSEDOWN,
  MOUSEUP,
  MOUSEMOVE,
  MOUSEOVER,
  MOUSEOUT,
  MOUSEENTER,
  MOUSELEAVE,
  TOUCHSTART,
  TOUCHMOVE,
  TOUCHEND,
  KEYDOWN,
  KEYUP,
  KEYPRESS,
  DRAG,
  DRAGSTART,
  DROP,
  DRAGOVER,
  DRAGENTER,
  DRAGLEAVE,
  DRAGEXIT,
  DRAGOUT,
  DRAGEND,
  CONTEXTMENU,
  CHANGE,
  INPUT,
  FOCUS,
  FOCUSIN,
  FOCUSOUT,
  BLUR,
  PASTE,
  RESIZE,
  SCROLL,
  SUBMIT,
  POINTERSTART,
  POINTEROVER,
  POINTERENTER,
  POINTEROUT,
  POINTERMOVE,
  POINTEREND,
  CHANGEINPUT,
  WHEEL,
  ANIMATIONSTART,
  ANIMATIONEND,
  ANIMATIONITERATION,
  TRANSITIONSTART,
  TRANSITIONEND,
  TRANSITIONRUN,
  TRANSITIONCANCEL,
  DOUBLETAB,
  LOAD,
  getRef,
  BIND_CHECK_FUNCTION,
  BIND_CHECK_DEFAULT_FUNCTION,
  BIND,
  normalizeWheelEvent,
  "default": Event
});
function collectProps(root, filterFunction = () => true) {
  let p = root;
  let results = [];
  do {
    const isObject2 = p instanceof Object;
    if (isObject2 === false) {
      break;
    }
    const names2 = Object.getOwnPropertyNames(p).filter(filterFunction);
    results.push.apply(results, names2);
  } while (p = Object.getPrototypeOf(p));
  return results;
}
function debounce(callback, delay = 0) {
  if (delay === 0) {
    return callback;
  }
  var t = void 0;
  return function($1, $2, $3, $4, $5) {
    if (t) {
      clearTimeout(t);
    }
    t = setTimeout(function() {
      callback($1, $2, $3, $4, $5);
    }, delay || 300);
  };
}
function throttle(callback, delay) {
  var t = void 0;
  return function($1, $2, $3, $4, $5) {
    if (!t) {
      t = setTimeout(function() {
        callback($1, $2, $3, $4, $5);
        t = null;
      }, delay || 300);
    }
  };
}
function ifCheck(callback, context, checkMethods) {
  return (...args2) => {
    const ifResult = checkMethods.every((check2) => {
      return context[check2.target].apply(context, args2);
    });
    if (ifResult) {
      callback.apply(context, args2);
    }
  };
}
function makeRequestAnimationFrame(callback, context) {
  return (...args2) => {
    requestAnimationFrame(() => {
      callback.apply(context, args2);
    });
  };
}
function keyEach(obj2, callback) {
  Object.keys(obj2).forEach((key, index2) => {
    callback(key, obj2[key], index2);
  });
}
function keyMap(obj2, callback) {
  return Object.keys(obj2).map((key, index2) => {
    return callback(key, obj2[key], index2);
  });
}
function keyMapJoin(obj2, callback, joinString = "") {
  return keyMap(obj2, callback).join(joinString);
}
function isUndefined(value) {
  return typeof value == "undefined" || value === null;
}
function isNotUndefined(value) {
  return isUndefined(value) === false;
}
function isBoolean(value) {
  return typeof value == "boolean";
}
function isString(value) {
  return typeof value == "string";
}
function isArray(value) {
  return Array.isArray(value);
}
function isObject(value) {
  return typeof value == "object" && !Array.isArray(value) && !isNumber(value) && !isString(value) && value !== null;
}
function isFunction(value) {
  return typeof value == "function";
}
function isNumber(value) {
  return typeof value == "number";
}
function isZero(num) {
  return num === 0;
}
function isNotZero(num) {
  return !isZero(num);
}
function clone$1(obj2) {
  if (isUndefined(obj2))
    return void 0;
  return JSON.parse(JSON.stringify(obj2));
}
function combineKeyArray(obj2) {
  Object.keys(obj2).forEach((key) => {
    if (Array.isArray(obj2[key])) {
      obj2[key] = obj2[key].join(", ");
    }
  });
  return obj2;
}
const short_tag_regexp = /\<(\w*)([^\>]*)\/\>/gim;
const HTML_TAG = {
  "image": true,
  "input": true,
  "br": true,
  "path": true,
  "line": true,
  "circle": true,
  "rect": true,
  "path": true,
  "polygon": true,
  "polyline": true,
  "use": true
};
const html = (strings, ...args2) => {
  var results = strings.map((it, index2) => {
    var results2 = args2[index2] || "";
    if (!Array.isArray(results2)) {
      results2 = [results2];
    }
    results2 = results2.join("");
    return it + results2;
  }).join("");
  results = results.replace(short_tag_regexp, function(match, p1) {
    if (HTML_TAG[p1.toLowerCase()]) {
      return match;
    } else {
      return match.replace("/>", `></${p1}>`);
    }
  });
  return results;
};
const splitMethodByKeyword = (arr, keyword) => {
  const filterKeys = arr.filter((code2) => code2.indexOf(`${keyword}(`) > -1);
  const filterMaps = filterKeys.map((code2) => {
    const [target, param] = code2.split(`${keyword}(`)[1].split(")")[0].trim().split(" ");
    return { target, param };
  });
  return [filterKeys, filterMaps];
};
var EPSILON = 1e-6;
var ARRAY_TYPE = typeof Float32Array !== "undefined" ? Float32Array : Array;
if (!Math.hypot)
  Math.hypot = function() {
    var y2 = 0, i = arguments.length;
    while (i--) {
      y2 += arguments[i] * arguments[i];
    }
    return Math.sqrt(y2);
  };
function create$6() {
  var out = new ARRAY_TYPE(9);
  if (ARRAY_TYPE != Float32Array) {
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
  }
  out[0] = 1;
  out[4] = 1;
  out[8] = 1;
  return out;
}
function create$5() {
  var out = new ARRAY_TYPE(16);
  if (ARRAY_TYPE != Float32Array) {
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
  }
  out[0] = 1;
  out[5] = 1;
  out[10] = 1;
  out[15] = 1;
  return out;
}
function fromValues$1(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
  var out = new ARRAY_TYPE(16);
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m03;
  out[4] = m10;
  out[5] = m11;
  out[6] = m12;
  out[7] = m13;
  out[8] = m20;
  out[9] = m21;
  out[10] = m22;
  out[11] = m23;
  out[12] = m30;
  out[13] = m31;
  out[14] = m32;
  out[15] = m33;
  return out;
}
function transpose(out, a) {
  if (out === a) {
    var a01 = a[1], a02 = a[2], a03 = a[3];
    var a12 = a[6], a13 = a[7];
    var a23 = a[11];
    out[1] = a[4];
    out[2] = a[8];
    out[3] = a[12];
    out[4] = a01;
    out[6] = a[9];
    out[7] = a[13];
    out[8] = a02;
    out[9] = a12;
    out[11] = a[14];
    out[12] = a03;
    out[13] = a13;
    out[14] = a23;
  } else {
    out[0] = a[0];
    out[1] = a[4];
    out[2] = a[8];
    out[3] = a[12];
    out[4] = a[1];
    out[5] = a[5];
    out[6] = a[9];
    out[7] = a[13];
    out[8] = a[2];
    out[9] = a[6];
    out[10] = a[10];
    out[11] = a[14];
    out[12] = a[3];
    out[13] = a[7];
    out[14] = a[11];
    out[15] = a[15];
  }
  return out;
}
function invert(out, a) {
  var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
  var a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
  var a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
  var a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];
  var b00 = a00 * a11 - a01 * a10;
  var b01 = a00 * a12 - a02 * a10;
  var b02 = a00 * a13 - a03 * a10;
  var b03 = a01 * a12 - a02 * a11;
  var b04 = a01 * a13 - a03 * a11;
  var b05 = a02 * a13 - a03 * a12;
  var b06 = a20 * a31 - a21 * a30;
  var b07 = a20 * a32 - a22 * a30;
  var b08 = a20 * a33 - a23 * a30;
  var b09 = a21 * a32 - a22 * a31;
  var b10 = a21 * a33 - a23 * a31;
  var b11 = a22 * a33 - a23 * a32;
  var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
  if (!det) {
    return null;
  }
  det = 1 / det;
  out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
  out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
  out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
  out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
  out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
  out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
  out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
  out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
  out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
  out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
  out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
  out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
  out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
  out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
  out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
  out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;
  return out;
}
function multiply$1(out, a, b) {
  var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
  var a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
  var a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
  var a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];
  var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
  out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  b0 = b[4];
  b1 = b[5];
  b2 = b[6];
  b3 = b[7];
  out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  b0 = b[8];
  b1 = b[9];
  b2 = b[10];
  b3 = b[11];
  out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  b0 = b[12];
  b1 = b[13];
  b2 = b[14];
  b3 = b[15];
  out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  return out;
}
function translate(out, a, v) {
  var x2 = v[0], y2 = v[1], z = v[2];
  var a00, a01, a02, a03;
  var a10, a11, a12, a13;
  var a20, a21, a22, a23;
  if (a === out) {
    out[12] = a[0] * x2 + a[4] * y2 + a[8] * z + a[12];
    out[13] = a[1] * x2 + a[5] * y2 + a[9] * z + a[13];
    out[14] = a[2] * x2 + a[6] * y2 + a[10] * z + a[14];
    out[15] = a[3] * x2 + a[7] * y2 + a[11] * z + a[15];
  } else {
    a00 = a[0];
    a01 = a[1];
    a02 = a[2];
    a03 = a[3];
    a10 = a[4];
    a11 = a[5];
    a12 = a[6];
    a13 = a[7];
    a20 = a[8];
    a21 = a[9];
    a22 = a[10];
    a23 = a[11];
    out[0] = a00;
    out[1] = a01;
    out[2] = a02;
    out[3] = a03;
    out[4] = a10;
    out[5] = a11;
    out[6] = a12;
    out[7] = a13;
    out[8] = a20;
    out[9] = a21;
    out[10] = a22;
    out[11] = a23;
    out[12] = a00 * x2 + a10 * y2 + a20 * z + a[12];
    out[13] = a01 * x2 + a11 * y2 + a21 * z + a[13];
    out[14] = a02 * x2 + a12 * y2 + a22 * z + a[14];
    out[15] = a03 * x2 + a13 * y2 + a23 * z + a[15];
  }
  return out;
}
function scale$1(out, a, v) {
  var x2 = v[0], y2 = v[1], z = v[2];
  out[0] = a[0] * x2;
  out[1] = a[1] * x2;
  out[2] = a[2] * x2;
  out[3] = a[3] * x2;
  out[4] = a[4] * y2;
  out[5] = a[5] * y2;
  out[6] = a[6] * y2;
  out[7] = a[7] * y2;
  out[8] = a[8] * z;
  out[9] = a[9] * z;
  out[10] = a[10] * z;
  out[11] = a[11] * z;
  out[12] = a[12];
  out[13] = a[13];
  out[14] = a[14];
  out[15] = a[15];
  return out;
}
function rotate$1(out, a, rad, axis) {
  var x2 = axis[0], y2 = axis[1], z = axis[2];
  var len2 = Math.hypot(x2, y2, z);
  var s, c2, t;
  var a00, a01, a02, a03;
  var a10, a11, a12, a13;
  var a20, a21, a22, a23;
  var b00, b01, b02;
  var b10, b11, b12;
  var b20, b21, b22;
  if (len2 < EPSILON) {
    return null;
  }
  len2 = 1 / len2;
  x2 *= len2;
  y2 *= len2;
  z *= len2;
  s = Math.sin(rad);
  c2 = Math.cos(rad);
  t = 1 - c2;
  a00 = a[0];
  a01 = a[1];
  a02 = a[2];
  a03 = a[3];
  a10 = a[4];
  a11 = a[5];
  a12 = a[6];
  a13 = a[7];
  a20 = a[8];
  a21 = a[9];
  a22 = a[10];
  a23 = a[11];
  b00 = x2 * x2 * t + c2;
  b01 = y2 * x2 * t + z * s;
  b02 = z * x2 * t - y2 * s;
  b10 = x2 * y2 * t - z * s;
  b11 = y2 * y2 * t + c2;
  b12 = z * y2 * t + x2 * s;
  b20 = x2 * z * t + y2 * s;
  b21 = y2 * z * t - x2 * s;
  b22 = z * z * t + c2;
  out[0] = a00 * b00 + a10 * b01 + a20 * b02;
  out[1] = a01 * b00 + a11 * b01 + a21 * b02;
  out[2] = a02 * b00 + a12 * b01 + a22 * b02;
  out[3] = a03 * b00 + a13 * b01 + a23 * b02;
  out[4] = a00 * b10 + a10 * b11 + a20 * b12;
  out[5] = a01 * b10 + a11 * b11 + a21 * b12;
  out[6] = a02 * b10 + a12 * b11 + a22 * b12;
  out[7] = a03 * b10 + a13 * b11 + a23 * b12;
  out[8] = a00 * b20 + a10 * b21 + a20 * b22;
  out[9] = a01 * b20 + a11 * b21 + a21 * b22;
  out[10] = a02 * b20 + a12 * b21 + a22 * b22;
  out[11] = a03 * b20 + a13 * b21 + a23 * b22;
  if (a !== out) {
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  }
  return out;
}
function rotateX(out, a, rad) {
  var s = Math.sin(rad);
  var c2 = Math.cos(rad);
  var a10 = a[4];
  var a11 = a[5];
  var a12 = a[6];
  var a13 = a[7];
  var a20 = a[8];
  var a21 = a[9];
  var a22 = a[10];
  var a23 = a[11];
  if (a !== out) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  }
  out[4] = a10 * c2 + a20 * s;
  out[5] = a11 * c2 + a21 * s;
  out[6] = a12 * c2 + a22 * s;
  out[7] = a13 * c2 + a23 * s;
  out[8] = a20 * c2 - a10 * s;
  out[9] = a21 * c2 - a11 * s;
  out[10] = a22 * c2 - a12 * s;
  out[11] = a23 * c2 - a13 * s;
  return out;
}
function rotateY(out, a, rad) {
  var s = Math.sin(rad);
  var c2 = Math.cos(rad);
  var a00 = a[0];
  var a01 = a[1];
  var a02 = a[2];
  var a03 = a[3];
  var a20 = a[8];
  var a21 = a[9];
  var a22 = a[10];
  var a23 = a[11];
  if (a !== out) {
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  }
  out[0] = a00 * c2 - a20 * s;
  out[1] = a01 * c2 - a21 * s;
  out[2] = a02 * c2 - a22 * s;
  out[3] = a03 * c2 - a23 * s;
  out[8] = a00 * s + a20 * c2;
  out[9] = a01 * s + a21 * c2;
  out[10] = a02 * s + a22 * c2;
  out[11] = a03 * s + a23 * c2;
  return out;
}
function rotateZ(out, a, rad) {
  var s = Math.sin(rad);
  var c2 = Math.cos(rad);
  var a00 = a[0];
  var a01 = a[1];
  var a02 = a[2];
  var a03 = a[3];
  var a10 = a[4];
  var a11 = a[5];
  var a12 = a[6];
  var a13 = a[7];
  if (a !== out) {
    out[8] = a[8];
    out[9] = a[9];
    out[10] = a[10];
    out[11] = a[11];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  }
  out[0] = a00 * c2 + a10 * s;
  out[1] = a01 * c2 + a11 * s;
  out[2] = a02 * c2 + a12 * s;
  out[3] = a03 * c2 + a13 * s;
  out[4] = a10 * c2 - a00 * s;
  out[5] = a11 * c2 - a01 * s;
  out[6] = a12 * c2 - a02 * s;
  out[7] = a13 * c2 - a03 * s;
  return out;
}
function fromTranslation(out, v) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = v[0];
  out[13] = v[1];
  out[14] = v[2];
  out[15] = 1;
  return out;
}
function fromScaling(out, v) {
  out[0] = v[0];
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = v[1];
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = v[2];
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
function fromRotation(out, rad, axis) {
  var x2 = axis[0], y2 = axis[1], z = axis[2];
  var len2 = Math.hypot(x2, y2, z);
  var s, c2, t;
  if (len2 < EPSILON) {
    return null;
  }
  len2 = 1 / len2;
  x2 *= len2;
  y2 *= len2;
  z *= len2;
  s = Math.sin(rad);
  c2 = Math.cos(rad);
  t = 1 - c2;
  out[0] = x2 * x2 * t + c2;
  out[1] = y2 * x2 * t + z * s;
  out[2] = z * x2 * t - y2 * s;
  out[3] = 0;
  out[4] = x2 * y2 * t - z * s;
  out[5] = y2 * y2 * t + c2;
  out[6] = z * y2 * t + x2 * s;
  out[7] = 0;
  out[8] = x2 * z * t + y2 * s;
  out[9] = y2 * z * t - x2 * s;
  out[10] = z * z * t + c2;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
function fromZRotation(out, rad) {
  var s = Math.sin(rad);
  var c2 = Math.cos(rad);
  out[0] = c2;
  out[1] = s;
  out[2] = 0;
  out[3] = 0;
  out[4] = -s;
  out[5] = c2;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
function getTranslation(out, mat) {
  out[0] = mat[12];
  out[1] = mat[13];
  out[2] = mat[14];
  return out;
}
function getScaling(out, mat) {
  var m11 = mat[0];
  var m12 = mat[1];
  var m13 = mat[2];
  var m21 = mat[4];
  var m22 = mat[5];
  var m23 = mat[6];
  var m31 = mat[8];
  var m32 = mat[9];
  var m33 = mat[10];
  out[0] = Math.hypot(m11, m12, m13);
  out[1] = Math.hypot(m21, m22, m23);
  out[2] = Math.hypot(m31, m32, m33);
  return out;
}
function getRotation(out, mat) {
  var scaling = new ARRAY_TYPE(3);
  getScaling(scaling, mat);
  var is1 = 1 / scaling[0];
  var is2 = 1 / scaling[1];
  var is3 = 1 / scaling[2];
  var sm11 = mat[0] * is1;
  var sm12 = mat[1] * is2;
  var sm13 = mat[2] * is3;
  var sm21 = mat[4] * is1;
  var sm22 = mat[5] * is2;
  var sm23 = mat[6] * is3;
  var sm31 = mat[8] * is1;
  var sm32 = mat[9] * is2;
  var sm33 = mat[10] * is3;
  var trace = sm11 + sm22 + sm33;
  var S = 0;
  if (trace > 0) {
    S = Math.sqrt(trace + 1) * 2;
    out[3] = 0.25 * S;
    out[0] = (sm23 - sm32) / S;
    out[1] = (sm31 - sm13) / S;
    out[2] = (sm12 - sm21) / S;
  } else if (sm11 > sm22 && sm11 > sm33) {
    S = Math.sqrt(1 + sm11 - sm22 - sm33) * 2;
    out[3] = (sm23 - sm32) / S;
    out[0] = 0.25 * S;
    out[1] = (sm12 + sm21) / S;
    out[2] = (sm31 + sm13) / S;
  } else if (sm22 > sm33) {
    S = Math.sqrt(1 + sm22 - sm11 - sm33) * 2;
    out[3] = (sm31 - sm13) / S;
    out[0] = (sm12 + sm21) / S;
    out[1] = 0.25 * S;
    out[2] = (sm23 + sm32) / S;
  } else {
    S = Math.sqrt(1 + sm33 - sm11 - sm22) * 2;
    out[3] = (sm12 - sm21) / S;
    out[0] = (sm31 + sm13) / S;
    out[1] = (sm23 + sm32) / S;
    out[2] = 0.25 * S;
  }
  return out;
}
function perspectiveNO(out, fovy, aspect, near, far) {
  var f = 1 / Math.tan(fovy / 2), nf;
  out[0] = f / aspect;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = f;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[15] = 0;
  if (far != null && far !== Infinity) {
    nf = 1 / (near - far);
    out[10] = (far + near) * nf;
    out[14] = 2 * far * near * nf;
  } else {
    out[10] = -1;
    out[14] = -2 * near;
  }
  return out;
}
var perspective$1 = perspectiveNO;
function create$4() {
  var out = new ARRAY_TYPE(3);
  if (ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
  }
  return out;
}
function clone(a) {
  var out = new ARRAY_TYPE(3);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  return out;
}
function length(a) {
  var x2 = a[0];
  var y2 = a[1];
  var z = a[2];
  return Math.hypot(x2, y2, z);
}
function fromValues(x2, y2, z) {
  var out = new ARRAY_TYPE(3);
  out[0] = x2;
  out[1] = y2;
  out[2] = z;
  return out;
}
function add$1(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  return out;
}
function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  return out;
}
function multiply(out, a, b) {
  out[0] = a[0] * b[0];
  out[1] = a[1] * b[1];
  out[2] = a[2] * b[2];
  return out;
}
function divide(out, a, b) {
  out[0] = a[0] / b[0];
  out[1] = a[1] / b[1];
  out[2] = a[2] / b[2];
  return out;
}
function floor(out, a) {
  out[0] = Math.floor(a[0]);
  out[1] = Math.floor(a[1]);
  out[2] = Math.floor(a[2]);
  return out;
}
function distance$1(a, b) {
  var x2 = b[0] - a[0];
  var y2 = b[1] - a[1];
  var z = b[2] - a[2];
  return Math.hypot(x2, y2, z);
}
function negate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  out[2] = -a[2];
  return out;
}
function normalize$3(out, a) {
  var x2 = a[0];
  var y2 = a[1];
  var z = a[2];
  var len2 = x2 * x2 + y2 * y2 + z * z;
  if (len2 > 0) {
    len2 = 1 / Math.sqrt(len2);
  }
  out[0] = a[0] * len2;
  out[1] = a[1] * len2;
  out[2] = a[2] * len2;
  return out;
}
function dot$1(a, b) {
  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
}
function cross(out, a, b) {
  var ax = a[0], ay = a[1], az = a[2];
  var bx = b[0], by = b[1], bz = b[2];
  out[0] = ay * bz - az * by;
  out[1] = az * bx - ax * bz;
  out[2] = ax * by - ay * bx;
  return out;
}
function lerp(out, a, b, t) {
  var ax = a[0];
  var ay = a[1];
  var az = a[2];
  out[0] = ax + t * (b[0] - ax);
  out[1] = ay + t * (b[1] - ay);
  out[2] = az + t * (b[2] - az);
  return out;
}
function transformMat4(out, a, m) {
  var x2 = a[0], y2 = a[1], z = a[2];
  var w = m[3] * x2 + m[7] * y2 + m[11] * z + m[15];
  w = w || 1;
  out[0] = (m[0] * x2 + m[4] * y2 + m[8] * z + m[12]) / w;
  out[1] = (m[1] * x2 + m[5] * y2 + m[9] * z + m[13]) / w;
  out[2] = (m[2] * x2 + m[6] * y2 + m[10] * z + m[14]) / w;
  return out;
}
function equals$1(a, b) {
  var a0 = a[0], a1 = a[1], a2 = a[2];
  var b0 = b[0], b1 = b[1], b2 = b[2];
  return Math.abs(a0 - b0) <= EPSILON * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= EPSILON * Math.max(1, Math.abs(a2), Math.abs(b2));
}
var div$1 = divide;
var dist = distance$1;
var len = length;
(function() {
  var vec = create$4();
  return function(a, stride, offset, count, fn, arg) {
    var i, l;
    if (!stride) {
      stride = 3;
    }
    if (!offset) {
      offset = 0;
    }
    if (count) {
      l = Math.min(count * stride + offset, a.length);
    } else {
      l = a.length;
    }
    for (i = offset; i < l; i += stride) {
      vec[0] = a[i];
      vec[1] = a[i + 1];
      vec[2] = a[i + 2];
      fn(vec, vec, arg);
      a[i] = vec[0];
      a[i + 1] = vec[1];
      a[i + 2] = vec[2];
    }
    return a;
  };
})();
function create$3() {
  var out = new ARRAY_TYPE(4);
  if (ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
  }
  return out;
}
function normalize$2(out, a) {
  var x2 = a[0];
  var y2 = a[1];
  var z = a[2];
  var w = a[3];
  var len2 = x2 * x2 + y2 * y2 + z * z + w * w;
  if (len2 > 0) {
    len2 = 1 / Math.sqrt(len2);
  }
  out[0] = x2 * len2;
  out[1] = y2 * len2;
  out[2] = z * len2;
  out[3] = w * len2;
  return out;
}
(function() {
  var vec = create$3();
  return function(a, stride, offset, count, fn, arg) {
    var i, l;
    if (!stride) {
      stride = 4;
    }
    if (!offset) {
      offset = 0;
    }
    if (count) {
      l = Math.min(count * stride + offset, a.length);
    } else {
      l = a.length;
    }
    for (i = offset; i < l; i += stride) {
      vec[0] = a[i];
      vec[1] = a[i + 1];
      vec[2] = a[i + 2];
      vec[3] = a[i + 3];
      fn(vec, vec, arg);
      a[i] = vec[0];
      a[i + 1] = vec[1];
      a[i + 2] = vec[2];
      a[i + 3] = vec[3];
    }
    return a;
  };
})();
function create$2() {
  var out = new ARRAY_TYPE(4);
  if (ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
  }
  out[3] = 1;
  return out;
}
function setAxisAngle(out, axis, rad) {
  rad = rad * 0.5;
  var s = Math.sin(rad);
  out[0] = s * axis[0];
  out[1] = s * axis[1];
  out[2] = s * axis[2];
  out[3] = Math.cos(rad);
  return out;
}
function getAxisAngle(out_axis, q) {
  var rad = Math.acos(q[3]) * 2;
  var s = Math.sin(rad / 2);
  if (s > EPSILON) {
    out_axis[0] = q[0] / s;
    out_axis[1] = q[1] / s;
    out_axis[2] = q[2] / s;
  } else {
    out_axis[0] = 1;
    out_axis[1] = 0;
    out_axis[2] = 0;
  }
  return rad;
}
function slerp(out, a, b, t) {
  var ax = a[0], ay = a[1], az = a[2], aw = a[3];
  var bx = b[0], by = b[1], bz = b[2], bw = b[3];
  var omega, cosom, sinom, scale0, scale1;
  cosom = ax * bx + ay * by + az * bz + aw * bw;
  if (cosom < 0) {
    cosom = -cosom;
    bx = -bx;
    by = -by;
    bz = -bz;
    bw = -bw;
  }
  if (1 - cosom > EPSILON) {
    omega = Math.acos(cosom);
    sinom = Math.sin(omega);
    scale0 = Math.sin((1 - t) * omega) / sinom;
    scale1 = Math.sin(t * omega) / sinom;
  } else {
    scale0 = 1 - t;
    scale1 = t;
  }
  out[0] = scale0 * ax + scale1 * bx;
  out[1] = scale0 * ay + scale1 * by;
  out[2] = scale0 * az + scale1 * bz;
  out[3] = scale0 * aw + scale1 * bw;
  return out;
}
function fromMat3(out, m) {
  var fTrace = m[0] + m[4] + m[8];
  var fRoot;
  if (fTrace > 0) {
    fRoot = Math.sqrt(fTrace + 1);
    out[3] = 0.5 * fRoot;
    fRoot = 0.5 / fRoot;
    out[0] = (m[5] - m[7]) * fRoot;
    out[1] = (m[6] - m[2]) * fRoot;
    out[2] = (m[1] - m[3]) * fRoot;
  } else {
    var i = 0;
    if (m[4] > m[0])
      i = 1;
    if (m[8] > m[i * 3 + i])
      i = 2;
    var j = (i + 1) % 3;
    var k = (i + 2) % 3;
    fRoot = Math.sqrt(m[i * 3 + i] - m[j * 3 + j] - m[k * 3 + k] + 1);
    out[i] = 0.5 * fRoot;
    fRoot = 0.5 / fRoot;
    out[3] = (m[j * 3 + k] - m[k * 3 + j]) * fRoot;
    out[j] = (m[j * 3 + i] + m[i * 3 + j]) * fRoot;
    out[k] = (m[k * 3 + i] + m[i * 3 + k]) * fRoot;
  }
  return out;
}
function fromEuler(out, x2, y2, z) {
  var halfToRad = 0.5 * Math.PI / 180;
  x2 *= halfToRad;
  y2 *= halfToRad;
  z *= halfToRad;
  var sx = Math.sin(x2);
  var cx = Math.cos(x2);
  var sy = Math.sin(y2);
  var cy = Math.cos(y2);
  var sz = Math.sin(z);
  var cz = Math.cos(z);
  out[0] = sx * cy * cz - cx * sy * sz;
  out[1] = cx * sy * cz + sx * cy * sz;
  out[2] = cx * cy * sz - sx * sy * cz;
  out[3] = cx * cy * cz + sx * sy * sz;
  return out;
}
var normalize$1 = normalize$2;
(function() {
  var tmpvec3 = create$4();
  var xUnitVec3 = fromValues(1, 0, 0);
  var yUnitVec3 = fromValues(0, 1, 0);
  return function(out, a, b) {
    var dot2 = dot$1(a, b);
    if (dot2 < -0.999999) {
      cross(tmpvec3, xUnitVec3, a);
      if (len(tmpvec3) < 1e-6)
        cross(tmpvec3, yUnitVec3, a);
      normalize$3(tmpvec3, tmpvec3);
      setAxisAngle(out, tmpvec3, Math.PI);
      return out;
    } else if (dot2 > 0.999999) {
      out[0] = 0;
      out[1] = 0;
      out[2] = 0;
      out[3] = 1;
      return out;
    } else {
      cross(tmpvec3, a, b);
      out[0] = tmpvec3[0];
      out[1] = tmpvec3[1];
      out[2] = tmpvec3[2];
      out[3] = 1 + dot2;
      return normalize$1(out, out);
    }
  };
})();
(function() {
  var temp1 = create$2();
  var temp2 = create$2();
  return function(out, a, b, c2, d, t) {
    slerp(temp1, a, d, t);
    slerp(temp2, b, c2, t);
    slerp(out, temp1, temp2, 2 * t * (1 - t));
    return out;
  };
})();
(function() {
  var matr = create$6();
  return function(out, view, right2, up) {
    matr[0] = right2[0];
    matr[3] = right2[1];
    matr[6] = right2[2];
    matr[1] = up[0];
    matr[4] = up[1];
    matr[7] = up[2];
    matr[2] = -view[0];
    matr[5] = -view[1];
    matr[8] = -view[2];
    return normalize$1(out, fromMat3(out, matr));
  };
})();
function create$1() {
  var out = new ARRAY_TYPE(2);
  if (ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
  }
  return out;
}
function distance(a, b) {
  var x2 = b[0] - a[0], y2 = b[1] - a[1];
  return Math.hypot(x2, y2);
}
function equals(a, b) {
  var a0 = a[0], a1 = a[1];
  var b0 = b[0], b1 = b[1];
  return Math.abs(a0 - b0) <= EPSILON * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1, Math.abs(a1), Math.abs(b1));
}
(function() {
  var vec = create$1();
  return function(a, stride, offset, count, fn, arg) {
    var i, l;
    if (!stride) {
      stride = 2;
    }
    if (!offset) {
      offset = 0;
    }
    if (count) {
      l = Math.min(count * stride + offset, a.length);
    } else {
      l = a.length;
    }
    for (i = offset; i < l; i += stride) {
      vec[0] = a[i];
      vec[1] = a[i + 1];
      fn(vec, vec, arg);
      a[i] = vec[0];
      a[i + 1] = vec[1];
    }
    return a;
  };
})();
function round$1(n, k) {
  k = typeof k === "undefined" ? 1 : k;
  return Math.round(n * k) / k;
}
function area(x2, y2, areaWidth = 100) {
  const column = x2 < 0 ? Math.floor(x2 / areaWidth) : Math.ceil(x2 / areaWidth);
  const row = y2 < 0 ? Math.floor(y2 / areaWidth) : Math.ceil(y2 / areaWidth);
  return [row, column];
}
function degreeToRadian$1(degrees) {
  return degrees * (Math.PI / 180);
}
function div(num, divNum = 1) {
  return num === 0 ? 0 : num / divNum;
}
function radianToDegree(radian) {
  var angle2 = radian * (180 / Math.PI);
  if (angle2 < 0) {
    angle2 = 360 + angle2;
  }
  return angle2;
}
function getXInCircle(angle2, radius, centerX = 0) {
  return centerX + radius * Math.cos(degreeToRadian$1(angle2));
}
function getYInCircle(angle2, radius, centerY = 0) {
  return centerY + radius * Math.sin(degreeToRadian$1(angle2));
}
function getXYInCircle(angle2, radius, centerX = 0, centerY = 0) {
  return {
    x: getXInCircle(angle2, radius, centerX),
    y: getYInCircle(angle2, radius, centerY)
  };
}
function getDist(x2, y2, centerX = 0, centerY = 0) {
  return distance([x2, y2], [centerX, centerY]);
}
function getPointBetweenVerties(start2, end2, pointDist = 0) {
  return lerp([], start2, end2, 1 + pointDist / dist(start2, end2));
}
function vertiesMap(verties, transformView) {
  if (verties.length === 1) {
    return [
      transformMat4([], verties[0], transformView)
    ];
  } else if (verties.length === 2) {
    return [
      transformMat4([], verties[0], transformView),
      transformMat4([], verties[1], transformView)
    ];
  } else if (verties.length === 3) {
    return [
      transformMat4([], verties[0], transformView),
      transformMat4([], verties[1], transformView),
      transformMat4([], verties[2], transformView)
    ];
  } else if (verties.length === 4) {
    return [
      transformMat4([], verties[0], transformView),
      transformMat4([], verties[1], transformView),
      transformMat4([], verties[2], transformView),
      transformMat4([], verties[3], transformView)
    ];
  } else if (verties.length === 5) {
    return [
      transformMat4([], verties[0], transformView),
      transformMat4([], verties[1], transformView),
      transformMat4([], verties[2], transformView),
      transformMat4([], verties[3], transformView),
      transformMat4([], verties[4], transformView)
    ];
  }
  return verties.map((v) => {
    return transformMat4([], v, transformView);
  });
}
function getTargetPointX(source2, target, axis, nextTarget) {
  return [
    source2,
    [target[0], source2[1], target[2]],
    axis,
    Math.abs(source2[0] - target[0]),
    nextTarget
  ];
}
function getTargetPointY(source2, target, axis, nextTarget) {
  return [
    [target[0], source2[1], source2[2]],
    target,
    axis,
    Math.abs(source2[1] - target[1]),
    nextTarget
  ];
}
function invertTargetPoint(arr, isInvert = false) {
  if (isInvert === false)
    return arr;
  const [source2, target, axis, dist2, newTarget, sourceVerties, targetVerties] = arr;
  if (newTarget) {
    return [
      [target[0], newTarget[1], target[2]],
      [source2[0], newTarget[1], source2[2]],
      axis,
      dist2,
      [source2[0], source2[1], newTarget[2]],
      sourceVerties,
      targetVerties,
      isInvert
    ];
  } else {
    return [
      target,
      source2,
      axis,
      dist2,
      newTarget,
      sourceVerties,
      targetVerties,
      isInvert
    ];
  }
}
function makeGuidePoint(sourceVerties, targetVerties) {
  let leftVerties = sourceVerties;
  let rightVerties = targetVerties;
  let hasInvert = false;
  if (sourceVerties[4][0] - targetVerties[4][0] > 0) {
    leftVerties = targetVerties;
    rightVerties = sourceVerties;
    hasInvert = true;
  }
  const leftCenter = lerp([], leftVerties[1], leftVerties[2], 0.5);
  const rightCenter = lerp([], rightVerties[0], rightVerties[3], 0.5);
  let pointList = [];
  if (rightVerties[0][1] <= leftCenter[1] && leftCenter[1] <= rightVerties[3][1]) {
    pointList.push(getTargetPointX(leftCenter, rightCenter, "x", null));
  } else if (rightVerties[0][1] <= leftVerties[1][1]) {
    if (rightVerties[3][0] <= leftVerties[1][0] && leftVerties[1][0] <= rightVerties[2][0]) {
      pointList.push(getTargetPointY(rightVerties[3], [rightVerties[3][0], leftVerties[1][1], leftVerties[1][2]], "y", null));
    } else {
      pointList.push(getTargetPointX(leftVerties[1], rightCenter, "x", rightVerties[3]));
    }
  } else if (leftVerties[3][0] <= rightVerties[0][0] && rightVerties[0][0] <= leftVerties[2][0]) {
    pointList.push(getTargetPointY(leftVerties[3], rightVerties[0], "y"));
  } else if (rightVerties[3][0] <= leftVerties[0][0] && leftVerties[0][0] <= rightVerties[2][0]) {
    pointList.push(getTargetPointY([rightVerties[0][0], leftVerties[3][1], leftVerties[3][2]], rightVerties[0], "y"));
  } else if (rightVerties[3][0] <= leftVerties[1][0] && leftVerties[1][0] <= rightVerties[2][0]) {
    pointList.push(getTargetPointY(rightVerties[3], [rightVerties[3][0], leftVerties[1][1], leftVerties[1][2]], "y"));
  } else {
    pointList.push(getTargetPointX(leftVerties[2], rightCenter, "x", rightVerties[0]));
  }
  pointList.sort((a, b) => {
    return a[3] - b[3];
  });
  return invertTargetPoint([
    ...pointList[0],
    sourceVerties,
    targetVerties
  ], hasInvert);
}
function getVertiesMaxX(verties) {
  let maxValue = Number.MIN_SAFE_INTEGER;
  verties.forEach((v) => {
    maxValue = Math.max(v[0], maxValue);
  });
  return maxValue;
}
function getVertiesMaxY(verties) {
  let maxValue = Number.MIN_SAFE_INTEGER;
  verties.forEach((v) => {
    maxValue = Math.max(v[1], maxValue);
  });
  return maxValue;
}
function getVertiesMinX(verties) {
  let maxValue = Number.MAX_SAFE_INTEGER;
  verties.forEach((v) => {
    maxValue = Math.min(v[0], maxValue);
  });
  return maxValue;
}
function getVertiesCenterX(verties) {
  let minX = Number.MAX_SAFE_INTEGER;
  let maxX = Number.MIN_SAFE_INTEGER;
  verties.forEach((v) => {
    minX = Math.min(v[0], minX);
    maxX = Math.max(v[0], maxX);
  });
  return Math.round((minX + maxX) / 2);
}
function getVertiesMinY(verties) {
  let maxValue = Number.MAX_SAFE_INTEGER;
  verties.forEach((v) => {
    maxValue = Math.min(v[1], maxValue);
  });
  return maxValue;
}
function getVertiesCenterY(verties) {
  let minY = Number.MAX_SAFE_INTEGER;
  let maxY = Number.MIN_SAFE_INTEGER;
  verties.forEach((v) => {
    minY = Math.min(v[1], minY);
    maxY = Math.max(v[1], maxY);
  });
  return Math.round((minY + maxY) / 2);
}
function calculateAngle(rx, ry) {
  return radianToDegree(Math.atan2(ry, rx));
}
function calculateAngleForVec3(point2, center2, dist2) {
  return calculateAnglePointDistance({ x: point2[0], y: point2[1] }, { x: center2[0], y: center2[1] }, { dx: dist2[0], dy: dist2[1] });
}
function calculateRotationOriginMat4(angle2, origin2) {
  const view = create$5();
  translate(view, view, origin2);
  rotateZ(view, view, degreeToRadian$1(angle2));
  translate(view, view, negate([], origin2));
  return view;
}
function calculateMatrix(...args2) {
  const view = create$5();
  args2.forEach((v) => {
    multiply$1(view, view, v);
  });
  return view;
}
function calculateMatrixInverse(...args2) {
  return invert([], calculateMatrix(...args2));
}
function calculateAnglePointDistance(point2, center2, dist2) {
  var x2 = point2.x - center2.x;
  var y2 = point2.y - center2.y;
  var angle1 = calculateAngle(x2, y2);
  var x22 = point2.x + dist2.dx - center2.x;
  var y22 = point2.y + dist2.dy - center2.y;
  var angle2 = calculateAngle(x22, y22) - angle1;
  return angle2;
}
function calculateAngle360(rx, ry) {
  return (calculateAngle(rx, ry) + 180) % 360;
}
const UUID_REG$1 = /[xy]/g;
function uuid$1() {
  var dt = new Date().getTime();
  var uuid2 = "xxx12-xx-34xx".replace(UUID_REG$1, function(c2) {
    var r = (dt + Math.random() * 16) % 16 | 0;
    dt = Math.floor(dt / 16);
    return (c2 == "x" ? r : r & 3 | 8).toString(16);
  });
  return uuid2;
}
function uuidShort$1() {
  var dt = new Date().getTime();
  var uuid2 = "idxxxxxxx".replace(UUID_REG$1, function(c2) {
    var r = (dt + Math.random() * 16) % 16 | 0;
    dt = Math.floor(dt / 16);
    return (c2 == "x" ? r : r & 3 | 8).toString(16);
  });
  return uuid2;
}
const bezierCalc = {
  B1: function(t) {
    return t * t * t;
  },
  B2: function(t) {
    return 3 * t * t * (1 - t);
  },
  B3: function(t) {
    return 3 * t * (1 - t) * (1 - t);
  },
  B4: function(t) {
    return (1 - t) * (1 - t) * (1 - t);
  }
};
function cubicBezier(x1, y1, x2, y2) {
  var C2 = { x: x1, y: y1 };
  var C3 = { x: x2, y: y2 };
  return function(progress) {
    var y3 = C2.y * bezierCalc.B2(progress) + C3.y * bezierCalc.B3(progress) + bezierCalc.B4(progress);
    return 1 - y3;
  };
}
function getGradientLine(angle2, box) {
  let length2 = Math.abs(box.width * Math.sin(angle2)) + Math.abs(box.height * Math.cos(angle2));
  let center2 = {
    x: box.x + box.width / 2,
    y: box.y + box.height / 2
  };
  let yDiff = Math.sin(angle2 - Math.PI / 2) * length2 / 2;
  let xDiff = Math.cos(angle2 - Math.PI / 2) * length2 / 2;
  return {
    length: length2,
    center: center2,
    start: {
      x: center2.x - xDiff,
      y: center2.y - yDiff
    },
    end: {
      x: center2.x + xDiff,
      y: center2.y + yDiff
    }
  };
}
function getCenterInTriangle(a, b, c2) {
  return {
    x: (a.x + b.x + c2.x) / 3,
    y: (a.y + b.y + c2.y) / 3
  };
}
const splitReg$1 = /[\b\t \,\n]/g;
function normalize(str) {
  return str.trim().split(splitReg$1).filter((it) => it).map((it) => +it);
}
var math = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  round: round$1,
  area,
  degreeToRadian: degreeToRadian$1,
  div,
  radianToDegree,
  getXInCircle,
  getYInCircle,
  getXYInCircle,
  getDist,
  getPointBetweenVerties,
  vertiesMap,
  makeGuidePoint,
  getVertiesMaxX,
  getVertiesMaxY,
  getVertiesMinX,
  getVertiesCenterX,
  getVertiesMinY,
  getVertiesCenterY,
  calculateAngle,
  calculateAngleForVec3,
  calculateRotationOriginMat4,
  calculateMatrix,
  calculateMatrixInverse,
  calculateAnglePointDistance,
  calculateAngle360,
  uuid: uuid$1,
  uuidShort: uuidShort$1,
  cubicBezier,
  getGradientLine,
  getCenterInTriangle,
  normalize
});
const stringToPercent = {
  center: 50,
  top: 0,
  left: 0,
  right: 100,
  bottom: 100
};
class Position {
}
Position.CENTER = "center";
Position.TOP = "top";
Position.RIGHT = "right";
Position.LEFT = "left";
Position.BOTTOM = "bottom";
const REG_CSS_UNIT$1 = /([\d.]+)(px|pt|fr|r?em|deg|vh|vw|m?s|%|g?rad|turn)/gi;
class Length {
  constructor(value = "", unit = "") {
    this.value = value;
    if (isNumber(this.value) && isNaN(this.value)) {
      throw new Error("NaN is not able to set");
    }
    this.unit = unit;
  }
  [Symbol.toPrimitive](hint) {
    if (hint == "number") {
      return this.value;
    }
    return this.toString();
  }
  static min(...args2) {
    var min = args2.shift();
    for (var i = 0, len2 = args2.length; i < len2; i++) {
      if (min.value > args2[i].value) {
        min = args2[i];
      }
    }
    return min;
  }
  static max(...args2) {
    var max = args2.shift();
    for (var i = 0, len2 = args2.length; i < len2; i++) {
      if (max.value < args2[i].value) {
        max = args2[i];
      }
    }
    return max;
  }
  static string(value) {
    return new Length(value + "", "");
  }
  static number(value) {
    return new Length(+value, "number");
  }
  static px(value) {
    return new Length(+value, "px");
  }
  static em(value) {
    return new Length(+value, "em");
  }
  static percent(value) {
    return new Length(+value, "%");
  }
  static deg(value) {
    return new Length(+value, "deg");
  }
  static rad(value) {
    return new Length(+value, "rad");
  }
  static turn(value) {
    return new Length(+value, "turn");
  }
  static fr(value) {
    return new Length(+value, "fr");
  }
  static second(value) {
    return new Length(+value, "s");
  }
  static ms(value) {
    return new Length(+value, "ms");
  }
  static var(value) {
    return new Length(value + "", "--");
  }
  static z() {
    return 0;
  }
  static calc(str) {
    return new Length(str, "calc");
  }
  static parse(obj2) {
    obj2 = obj2 || Length.number(0);
    if (isString(obj2)) {
      obj2 = obj2.trim();
      var arr = obj2.replace(REG_CSS_UNIT$1, "$1 $2").split(" ");
      var isNumberString = +arr[0] == arr[0];
      if (isNumberString) {
        return new Length(+arr[0], arr[1]);
      } else {
        return new Length(arr[0]);
      }
    }
    if (obj2 instanceof Length) {
      return obj2;
    } else if (obj2.unit) {
      if (obj2.unit == "%" || obj2.unit == "percent") {
        var value = 0;
        if (isNotUndefined(obj2.percent)) {
          value = obj2.percent;
        } else if (isNotUndefined(obj2.value)) {
          value = obj2.value;
        }
        return Length.percent(value);
      } else if (obj2.unit == "px") {
        var value = 0;
        if (isNotUndefined(obj2.px)) {
          value = obj2.px;
        } else if (isNotUndefined(obj2.value)) {
          value = obj2.value;
        }
        return value;
      } else if (obj2.unit == "em") {
        var value = 0;
        if (isNotUndefined(obj2.em)) {
          value = obj2.em;
        } else if (isNotUndefined(obj2.value)) {
          value = obj2.value;
        }
        return Length.em(value);
      } else if (obj2.unit == "deg") {
        var value = 0;
        if (isNotUndefined(obj2.deg)) {
          value = obj2.deg;
        } else if (isNotUndefined(obj2.value)) {
          value = obj2.value;
        }
        return Length.deg(value);
      } else if (obj2.unit == "turn") {
        var value = 0;
        if (isNotUndefined(obj2.deg)) {
          value = obj2.turn;
        } else if (isNotUndefined(obj2.value)) {
          value = obj2.value;
        }
        return Length.turn(value);
      } else if (obj2.unit == "s") {
        var value = 0;
        if (isNotUndefined(obj2.second)) {
          value = obj2.second;
        } else if (isNotUndefined(obj2.value)) {
          value = obj2.value;
        }
        return Length.second(value);
      } else if (obj2.unit == "ms") {
        var value = 0;
        if (isNotUndefined(obj2.ms)) {
          value = obj2.ms;
        } else if (isNotUndefined(obj2.value)) {
          value = obj2.value;
        }
        return Length.ms(value);
      } else if (obj2.unit == "number") {
        var value = 0;
        if (isNotUndefined(obj2.value)) {
          value = obj2.value;
        }
        return Length.number(value);
      } else if (obj2.unit == "--") {
        var value = 0;
        if (isNotUndefined(obj2.value)) {
          value = obj2.value;
        }
        return Length.var(value);
      } else if (obj2.unit === "" || obj2.unit === "string") {
        var value = "";
        if (isNotUndefined(obj2.str)) {
          value = obj2.str;
        } else if (isNotUndefined(obj2.value)) {
          value = obj2.value;
        }
        return Length.string(value);
      }
    }
    return Length.string(obj2);
  }
  toString() {
    return this.getUnitText();
  }
  getUnitText() {
    switch (this.unit) {
      case "string":
      case "number":
        return this.value + "";
      case "var":
        return `var(--${this.value})`;
      case "calc":
        return `calc(${this.value})`;
      default:
        return this.value + this.unit;
    }
  }
  isUnitType(unit) {
    return this.unit === unit;
  }
  isCalc() {
    return this.isUnitType("calc");
  }
  isFr() {
    return this.isUnitType("fr");
  }
  isPercent() {
    return this.isUnitType("%");
  }
  isPx() {
    return this.isUnitType("px");
  }
  isEm() {
    return this.isUnitType("em");
  }
  isDeg() {
    return this.isUnitType("deg");
  }
  isRad() {
    return this.isUnitType("rad");
  }
  isTurn() {
    return this.isUnitType("turn");
  }
  isSecond() {
    return this.isUnitType("s");
  }
  isMs() {
    return this.isUnitType("ms");
  }
  isNumber() {
    return this.isUnitType("number");
  }
  isString() {
    return this.isUnitType("");
  }
  isVar() {
    return this.isUnitType("--");
  }
  isNaN() {
    return isNumber(this.value) && isNaN(this.value);
  }
  set(value) {
    this.value = value;
    return this;
  }
  add(obj2) {
    this.value += +obj2;
    return this;
  }
  sub(obj2) {
    return this.add(-1 * obj2);
  }
  mul(obj2) {
    this.value *= +obj2;
    return this;
  }
  div(obj2) {
    this.value /= +obj2;
    return this;
  }
  mod(obj2) {
    this.value %= +obj2;
    return this;
  }
  clone() {
    return new Length(this.value, this.unit);
  }
  getUnitName() {
    return this.unit === "%" ? "percent" : this.unit;
  }
  get isAuto() {
    return this.value === "auto" || this.unit === "auto";
  }
  get isNotAuto() {
    return !this.isAuto;
  }
  toJSON() {
    return this.toString();
  }
  rate(maxValue = 100) {
    return this.value / maxValue;
  }
  stringToPercent() {
    if (isNotUndefined(stringToPercent[this.value])) {
      return Length.percent(stringToPercent[this.value]);
    }
    return Length.percent(0);
  }
  stringToEm(maxValue) {
    return this.stringToPercent().toEm(maxValue);
  }
  stringToPx(maxValue) {
    return this.stringToPercent().toPx(maxValue);
  }
  toPercent(maxValue, fontSize = 16) {
    if (this.isPercent()) {
      return this.clone();
    } else if (this.isPx()) {
      return Length.percent(this.value * 100 / maxValue);
    } else if (this.isEm()) {
      return Length.percent(this.value * fontSize * 100 / maxValue);
    } else if (this.isString()) {
      return this.stringToPercent(maxValue);
    } else if (this.isDeg()) {
      return Length.percent(this.value / 360 * 100);
    }
  }
  toEm(maxValue, fontSize = 16) {
    if (this.isPercent()) {
      return Length.em(this.value / 100 * maxValue / fontSize);
    } else if (this.isPx()) {
      return Length.em(this.value / fontSize);
    } else if (this.isEm()) {
      return this.clone();
    } else if (this.isString()) {
      return this.stringToEm(maxValue);
    }
  }
  toPx(maxValue, fontSize = 16) {
    if (this.isPercent()) {
      if (isUndefined(maxValue)) {
        return this;
      }
      return Length.px(this.value / 100 * maxValue);
    } else if (this.isPx()) {
      return this.clone();
    } else if (this.isEm()) {
      return Length.px(this.value / 100 * maxValue / 16);
    } else if (this.isString()) {
      return this.stringToPx(maxValue);
    } else if (this.isNumber()) {
      return Length.px(this.value).toPx(maxValue);
    }
  }
  toDeg() {
    if (this.isDeg()) {
      return this.clone();
    } else if (this.isTurn()) {
      return Length.deg(this.value * 360);
    } else if (this.isRad()) {
      return Length.deg(radianToDegree(this.value));
    }
  }
  toRad() {
    if (this.isRad()) {
      return this.clone();
    } else if (this.isTurn()) {
      const deg = this.toDeg();
      return Length.rad(degreeToRadian$1(deg.value));
    } else if (this.isDeg()) {
      return Length.rad(degreeToRadian$1(this.value));
    }
  }
  toTurn() {
    if (this.isTurn()) {
      return this.clone();
    } else if (this.isDeg()) {
      return Length.turn(this.value / 360);
    }
  }
  toSecond() {
    if (this.isSecond()) {
      return this;
    } else if (this.isMs()) {
      return Length.second(this.value / 1e3);
    }
  }
  toMs() {
    if (this.isSecond()) {
      return Length.ms(this.value * 1e3);
    } else if (this.isMs()) {
      return this;
    }
  }
  to(unit, maxValue, fontSize = 16) {
    if (unit === "px") {
      return this.toPx(maxValue, fontSize);
    } else if (unit === "%" || unit === "percent") {
      return this.toPercent(maxValue, fontSize);
    } else if (unit === "em") {
      return this.toEm(maxValue, fontSize);
    } else if (unit === "deg") {
      return this.toDeg();
    } else if (unit === "turn") {
      return this.toTurn();
    }
  }
  toUnit(unit) {
    return new Length(this.value, unit);
  }
  calculate(type, dist2) {
    var func2 = this[type];
    if (func2) {
      return func2.call(this, dist2);
    }
    return this;
  }
  includes(...arr) {
    return arr.includes(this.value);
  }
  round(k) {
    return new Length(round$1(this.value, k), this.unit);
  }
  floor() {
    return new Length(Math.floor(this.value), this.unit);
  }
  equals(t) {
    return this.is(t.value) && this.isUnitType(t.unit);
  }
  is(value) {
    return this.value === value;
  }
  clamp(min, max) {
    return new Length(Math.max(min, Math.min(max, this.value)), this.unit);
  }
  isZero() {
    return this.value === 0;
  }
  changeUnitValue(px, maxValue) {
    const unit = this.unit;
    return Length.px(px).to(unit, maxValue);
  }
}
Length.auto = Length.string("auto");
const identity$2 = () => true;
function _traverse(obj2, filterCallback = identity$2) {
  var results = [];
  let len2 = obj2.layers.length;
  for (let start2 = len2; start2--; ) {
    let it = obj2.layers[start2];
    results.push(..._traverse(it.ref, filterCallback));
  }
  if (filterCallback(obj2)) {
    results.push(obj2);
  }
  return results;
}
class Item {
  constructor(json = {}) {
    this.ref = new Proxy(this, {
      get: (target, key) => {
        var originMethod = target[key];
        if (isFunction(originMethod)) {
          return (...args2) => {
            return originMethod.apply(target, args2);
          };
        } else {
          return originMethod || target.json[key];
        }
      },
      set: (target, key, value) => {
        const isDiff = target.json[key] != value;
        if (isDiff) {
          target.json[key] = value;
          this.changed();
        }
        return true;
      }
    });
    if (json instanceof Item) {
      json = json.toJSON();
    }
    this.json = this.convert(Object.assign(this.getDefaultObject(), json));
    this.lastChangedField = {};
    this.lastChangedFieldKeys = [];
    this.cachedValue = {};
    return this.ref;
  }
  getDefaultTitle() {
    return "Item";
  }
  getIcon() {
    return "";
  }
  isAttribute() {
    return false;
  }
  isChanged(timestamp) {
    return this.json.timestamp != Number(timestamp);
  }
  changed() {
    this.json.timestamp = this.json._timestamp + performance.now();
  }
  get title() {
    return this.json.name || this.getDefaultTitle();
  }
  renameWithCount() {
    let arr = this.json.name.split(" ");
    if (arr.length < 2) {
      return;
    }
    let last2 = arr.pop();
    let lastNumber = +last2;
    if (isNumber(lastNumber) && isNaN(lastNumber) === false) {
      lastNumber++;
    } else {
      lastNumber = last2;
    }
    const nextName = [...arr, lastNumber].join(" ");
    this.reset({
      name: nextName
    });
  }
  get allLayers() {
    return _traverse(this.ref);
  }
  filteredAllLayers(filterCallback) {
    return _traverse(this.ref, filterCallback);
  }
  get id() {
    return this.json.id;
  }
  get layers() {
    return this.json.layers;
  }
  get parent() {
    return this.json.parent;
  }
  setParent(otherParent) {
    this.json.parent = otherParent;
  }
  get depth() {
    if (!this.parent)
      return 1;
    return this.parent.depth + 1;
  }
  get top() {
    if (!this.parent)
      return this.ref;
    let localParent = this.parent;
    do {
      if (!localParent.parent) {
        return localParent;
      }
      localParent = localParent.parent;
    } while (localParent);
  }
  get project() {
    return this.path.find((it) => it.is("project"));
  }
  get artboard() {
    return this.path.find((it) => it.is("artboard"));
  }
  get path() {
    if (!this.parent)
      return [this.ref];
    const list2 = this.parent.path;
    list2.push(this.ref);
    return list2;
  }
  getInnerId(postfix = "") {
    return this.json.id + postfix;
  }
  is(checkItemType) {
    if (!this.json)
      return false;
    return checkItemType === this.json.itemType;
  }
  isNot(checkItemType) {
    return this.is(checkItemType) === false;
  }
  isSVG() {
    return false;
  }
  addCache(key, value) {
    this.cachedValue[key] = value;
  }
  getCache(key) {
    return this.cachedValue[key];
  }
  computed(key, newValueCallback) {
    const cachedKey = `__cachedKey_${key}`;
    const parsedKey = `${cachedKey}__parseValue`;
    const value = this.json[key];
    if (this.getCache(key) === value && this.getCache(parsedKey)) {
      return this.getCache(parsedKey);
    }
    this.addCache(key, value);
    this.addCache(parsedKey, newValueCallback(value, this.ref));
    return this.getCache(parsedKey);
  }
  editable(editablePropertyName) {
    return true;
  }
  generateListNumber() {
    this.layers.forEach((it, index2) => {
      it.no = index2;
      it.generateListNumber();
    });
  }
  convert(json) {
    if (json.layers) {
      json.layers.forEach((layer2) => {
        layer2.parent = this.ref;
      });
    }
    return json;
  }
  setCache() {
  }
  toCloneObject(isDeep = true) {
    var json = this.attrs("itemType", "name", "elementType", "type", "visible", "lock", "selected");
    if (isDeep) {
      json.layers = this.json.layers.map((layer2) => layer2.clone(isDeep));
    }
    return json;
  }
  clone(isDeep = true) {
    var ItemClass = this.constructor;
    var item2 = new ItemClass(this.toCloneObject(isDeep));
    item2.setParent(this.json.parent);
    return item2;
  }
  reset(obj2) {
    if (!obj2.__changedId)
      obj2.__changedId = uuid$1();
    if (this.lastChangedField.__changedId !== obj2.__changedId) {
      this.json = this.convert(Object.assign(this.json, obj2));
      this.lastChangedField = obj2;
      this.lastChangedFieldKeys = Object.keys(obj2);
      this.changed();
    }
    return true;
  }
  hasChangedField(...args2) {
    return args2.some((it) => this.lastChangedFieldKeys.includes(it));
  }
  getDefaultObject(obj2 = {}) {
    var id = uuidShort$1();
    return __spreadValues({
      id,
      _timestamp: Date.now(),
      _time: performance.now(),
      visible: true,
      lock: false,
      selected: false,
      layers: []
    }, obj2);
  }
  attrs(...args2) {
    const result = {};
    args2.forEach((field) => {
      result[field] = clone$1(this.json[field]);
    });
    return result;
  }
  hasChildren() {
    return this.layers.length > 0;
  }
  appendChild(layer2) {
    if (layer2.parent === this.ref) {
      return layer2;
    }
    this.resetMatrix(layer2);
    if (layer2.parent) {
      layer2.remove();
    }
    layer2.setParent(this.ref);
    this.json.layers.push(layer2);
    this.project.addIndexItem(layer2);
    return layer2;
  }
  prependChildItem(layer2) {
    this.resetMatrix(layer2);
    if (layer2.parent) {
      layer2.remove();
    }
    layer2.setParent(this.ref);
    this.json.layers.unshift(layer2);
    this.project.addIndexItem(layer2);
    return layer2;
  }
  resetMatrix(item2) {
  }
  refreshMatrixCache() {
  }
  insertChild(layer2, index2 = 0) {
    this.resetMatrix(layer2);
    if (layer2.parent) {
      layer2.remove();
    }
    layer2.setParent(this.ref);
    this.json.layers.splice(index2, 0, layer2);
    this.project.addIndexItem(layer2);
    return layer2;
  }
  appendAfter(layer2) {
    const index2 = this.parent.findIndex(this);
    this.parent.insertChild(layer2, index2);
    this.project.addIndexItem(layer2);
    return layer2;
  }
  appendBefore(layer2) {
    const index2 = this.parent.findIndex(this);
    this.parent.insertChild(layer2, index2 - 1);
    this.project.addIndexItem(layer2);
    return layer2;
  }
  setPositionInPlace(position2, item2) {
    this.layers.splice(position2, 0, item2);
  }
  toggle(field, toggleValue) {
    if (isUndefined(toggleValue)) {
      this.json[field] = !this.json[field];
    } else {
      this.json[field] = !!toggleValue;
    }
  }
  isTreeItemHide() {
    let currentParent = this.parent;
    let collapsedList = [];
    do {
      if (currentParent.is("project"))
        break;
      collapsedList.push(Boolean(currentParent.collapsed));
      currentParent = currentParent.parent;
    } while (currentParent);
    return Boolean(collapsedList.filter(Boolean).length);
  }
  expectJSON(key) {
    if (key === "parent")
      return false;
    if (isUndefined(this.json[key]))
      return false;
    return true;
  }
  toJSON() {
    const json = this.json;
    let newJSON = {};
    Object.keys(json).filter((key) => this.expectJSON(key)).forEach((key) => {
      newJSON[key] = json[key];
    });
    return newJSON;
  }
  resize() {
  }
  copy(dist2 = 0) {
    return this.json.parent.copyItem(this.ref, dist2);
  }
  findIndex(item2) {
    return this.json.layers.indexOf(item2.ref);
  }
  copyItem(childItem, dist2 = 10) {
    var child = childItem.clone();
    child.renameWithCount();
    child.move([dist2, dist2, 0]);
    var childIndex = this.findIndex(childItem);
    if (childIndex > -1) {
      this.json.layers.push(child);
      this.project.addIndexItem(child);
    }
    return child;
  }
  remove() {
    this.json.parent.removeChild(this.ref);
    this.project.removeIndexItem(this.ref);
  }
  removeChild(childItem) {
    const index2 = this.findIndex(childItem);
    if (index2 > -1) {
      this.json.layers.splice(index2, 1);
    }
  }
  hasParent(parentId) {
    var isParent = this.json.parent.id === parentId;
    if (!isParent && this.json.parent.is("project") === false)
      return this.json.parent.hasParent(parentId);
    return isParent;
  }
}
const setBooleanProp = (el, name2, value) => {
  if (value) {
    el.setAttribute(name2, name2);
    el[name2] = value;
  } else {
    el.removeAttribute(name2);
    el[name2] = value;
  }
};
const setProp = (el, name2, value) => {
  if (typeof value === "boolean") {
    setBooleanProp(el, name2, value);
  } else {
    el.setAttribute(name2, value);
  }
};
const removeBooleanProp = (node, name2) => {
  node.removeAttribute(name2);
  node[name2] = false;
};
const removeUndefinedProp = (node, name2) => {
  node.removeAttribute(name2);
};
const removeProp = (node, name2, value) => {
  if (typeof value === "boolean") {
    removeBooleanProp(node, name2);
  } else if (name2) {
    removeUndefinedProp(node, name2);
  }
};
const updateProp = (node, name2, newValue, oldValue) => {
  if (!newValue) {
    removeProp(node, name2, oldValue);
  } else if (!oldValue || newValue !== oldValue) {
    setProp(node, name2, newValue);
  }
};
const updateProps = (node, newProps = {}, oldProps = {}) => {
  const keyList2 = [];
  keyList2.push.apply(keyList2, Object.keys(newProps));
  keyList2.push.apply(keyList2, Object.keys(oldProps));
  const props2 = new Set(keyList2);
  props2.forEach((key) => {
    updateProp(node, key, newProps[key], oldProps[key]);
  });
};
function changed(node1, node2) {
  return node1.nodeType === Node.TEXT_NODE && node1.textContent !== node2.textContent || node1.nodeName !== node2.nodeName;
}
function hasPassed(node1) {
  if ((node1 == null ? void 0 : node1.nodeType) === 8) {
    return true;
  }
  return node1.nodeType !== Node.TEXT_NODE && node1.getAttribute("data-domdiff-pass") === "true";
}
function hasRefClass(node1) {
  return node1.nodeType !== Node.TEXT_NODE && node1.getAttribute("refClass");
}
function getProps(attributes) {
  var results = {};
  const len2 = attributes.length;
  for (let i = 0; i < len2; i++) {
    const t = attributes[i];
    results[t.name] = t.value;
  }
  return results;
}
function updateElement(parentElement, oldEl, newEl, i, options2 = {}) {
  if (!oldEl) {
    parentElement.appendChild(newEl.cloneNode(true));
  } else if (!newEl) {
    parentElement.removeChild(oldEl);
  } else if (hasPassed(oldEl) || hasPassed(newEl))
    ;
  else if (changed(newEl, oldEl) || hasRefClass(newEl)) {
    parentElement.replaceChild(newEl.cloneNode(true), oldEl);
  } else if (newEl.nodeType !== Node.TEXT_NODE && newEl.nodeType !== Node.COMMENT_NODE && newEl.toString() !== "[object HTMLUnknownElement]") {
    if (options2.checkPassed && options2.checkPassed(oldEl, newEl))
      ;
    else {
      updateProps(oldEl, getProps(newEl.attributes), getProps(oldEl.attributes));
    }
    var oldChildren = children(oldEl);
    var newChildren = children(newEl);
    var max = Math.max(oldChildren.length, newChildren.length);
    for (var i = 0; i < max; i++) {
      updateElement(oldEl, oldChildren[i], newChildren[i], i);
    }
  }
}
const children = (el) => {
  var element = el.firstChild;
  if (!element) {
    return [];
  }
  var results = [];
  do {
    results.push(element);
    element = element.nextSibling;
  } while (element);
  return results;
};
function DomDiff(A, B, options2 = {}) {
  options2.checkPassed = isFunction(options2.checkPassed) ? options2.checkPassed : void 0;
  A = A.el || A;
  B = B.el || B;
  var childrenA = children(A);
  var childrenB = children(B);
  var len2 = Math.max(childrenA.length, childrenB.length);
  for (var i = 0; i < len2; i++) {
    updateElement(A, childrenA[i], childrenB[i], i, options2);
  }
}
const UUID_REG = /[xy]/g;
function uuid() {
  var dt = new Date().getTime();
  var uuid2 = "xxx12-xx-34xx".replace(UUID_REG, function(c2) {
    var r = (dt + Math.random() * 16) % 16 | 0;
    dt = Math.floor(dt / 16);
    return (c2 == "x" ? r : r & 3 | 8).toString(16);
  });
  return uuid2;
}
function uuidShort() {
  var dt = new Date().getTime();
  var uuid2 = "idxxxxxxx".replace(UUID_REG, function(c2) {
    var r = (dt + Math.random() * 16) % 16 | 0;
    dt = Math.floor(dt / 16);
    return (c2 == "x" ? r : r & 3 | 8).toString(16);
  });
  return uuid2;
}
const map = {};
const aliasMap = {};
const __tempVariables = new Map();
const __tempVariablesGroup = new Map();
window.__tempVariables = __tempVariables;
const VARIABLE_SAPARATOR = "v:";
function variable$4(value, groupId = "") {
  const id = `${VARIABLE_SAPARATOR}${uuidShort()}`;
  __tempVariables.set(id, value);
  if (groupId) {
    __tempVariablesGroup.has(groupId) || __tempVariablesGroup.set(groupId, new Set());
    __tempVariablesGroup.get(groupId).add(id);
  }
  return id;
}
function initializeGroupVariables(groupId) {
  if (__tempVariablesGroup.has(groupId)) {
    __tempVariablesGroup.get(groupId).forEach((id) => {
      __tempVariables.delete(id);
    });
    __tempVariablesGroup.delete(groupId);
  }
}
function recoverVariable(id, removeVariable = true) {
  if (isString(id) === false) {
    return id;
  }
  let value = id;
  if (__tempVariables.has(id)) {
    value = __tempVariables.get(id);
    if (removeVariable) {
      __tempVariables.delete(id);
    }
  }
  return value;
}
function getVariable(idOrValue) {
  if (__tempVariables.has(idOrValue)) {
    return __tempVariables.get(idOrValue);
  }
  return idOrValue;
}
function hasVariable(id) {
  return __tempVariables.has(id);
}
function spreadVariable(obj2) {
  return Object.entries(obj2).map(([key, value]) => {
    return `${key}=${variable$4(value)}`;
  }).join(" ");
}
function registElement(classes = {}) {
  Object.keys(classes).forEach((key) => {
    if (map[key]) {
      return;
    }
    map[key] = classes[key];
  });
}
function registAlias(a, b) {
  aliasMap[a] = b;
}
function retriveAlias(key) {
  return aliasMap[key];
}
function retriveElement(className) {
  return map[retriveAlias(className) || className];
}
class Dom {
  constructor(tag, className, attr) {
    if (typeof tag !== "string") {
      this.el = tag;
    } else {
      var el = document.createElement(tag);
      if (className) {
        el.className = className;
      }
      attr = attr || {};
      Object.assign(el, attr);
      this.el = el;
    }
  }
  static create(tag, className, attr) {
    return new Dom(tag, className, attr);
  }
  static createByHTML(htmlString) {
    var div2 = Dom.create("div");
    var list2 = div2.html(htmlString).children();
    if (list2.length) {
      return Dom.create(list2[0].el);
    }
    return null;
  }
  static getScrollTop() {
    return Math.max(window.pageYOffset, document.documentElement.scrollTop, document.body.scrollTop);
  }
  static getScrollLeft() {
    return Math.max(window.pageXOffset, document.documentElement.scrollLeft, document.body.scrollLeft);
  }
  static parse(html2) {
    var parser2 = DOMParser();
    return parser2.parseFromString(html2, "text/htmll");
  }
  static body() {
    return Dom.create(document.body);
  }
  setAttr(obj2) {
    Object.keys(obj2).forEach((key) => {
      this.attr(key, obj2[key]);
    });
    return this;
  }
  setAttrNS(obj2, namespace = "http://www.w3.org/2000/svg") {
    Object.keys(obj2).forEach((key) => {
      this.attr(key, obj2[key], namespace);
    });
    return this;
  }
  setProp(obj2) {
    Object.keys(obj2).forEach((key) => {
      if (this.el[key] != obj2[key]) {
        this.el[key] = obj2[key];
      }
    });
    return this;
  }
  data(key, value) {
    if (arguments.length === 1) {
      const value2 = this.attr("data-" + key);
      return recoverVariable(value2, false);
    } else if (arguments.length === 2) {
      return this.attr("data-" + key, value);
    }
    return this;
  }
  attr(key, value) {
    if (arguments.length == 1) {
      return this.el.getAttribute && this.el.getAttribute(key);
    }
    if (this.el.getAttribute(key) != value) {
      this.el.setAttribute(key, value);
    }
    return this;
  }
  attrNS(key, value, namespace = "http://www.w3.org/2000/svg") {
    if (arguments.length == 1) {
      return this.el.getAttributeNS(namespace, key);
    }
    if (this.el.getAttributeNS(namespace, key) != value) {
      this.el.setAttributeNS(namespace, key, value);
    }
    return this;
  }
  attrKeyValue(keyField) {
    return {
      [this.el.getAttribute(keyField)]: this.val()
    };
  }
  attrs(...args2) {
    return args2.map((key) => {
      return this.el.getAttribute(key);
    });
  }
  styles(...args2) {
    return args2.map((key) => {
      return this.el.style[key];
    });
  }
  removeAttr(key) {
    this.el.removeAttribute(key);
    return this;
  }
  removeStyle(key) {
    this.el.style.removeProperty(key);
    return this;
  }
  is(checkElement) {
    return this.el === (checkElement.el || checkElement);
  }
  isTag(tag) {
    return this.el.tagName.toLowerCase() === tag.toLowerCase();
  }
  closest(cls) {
    var temp = this;
    var checkCls = false;
    while (!(checkCls = temp.hasClass(cls))) {
      if (temp.el.parentNode) {
        temp = Dom.create(temp.el.parentNode);
      } else {
        return null;
      }
    }
    if (checkCls) {
      return temp;
    }
    return null;
  }
  path() {
    if (!this.el)
      return [];
    let pathList = [this];
    let $parentNode = this.parent();
    if (!$parentNode.el)
      return pathList;
    while ($parentNode) {
      pathList.unshift($parentNode);
      $parentNode = $parentNode.parent();
      if (!$parentNode.el)
        break;
    }
    return pathList;
  }
  get $parent() {
    return this.parent();
  }
  parent() {
    return Dom.create(this.el.parentNode);
  }
  hasParent() {
    return !!this.el.parentNode;
  }
  removeClass(...args2) {
    this.el.classList.remove(...args2);
    return this;
  }
  replaceClass(oldClass, newClass) {
    this.el.classList.replace(oldClass, newClass);
    return this;
  }
  hasClass(cls) {
    if (!this.el.classList)
      return false;
    return this.el.classList.contains(cls);
  }
  addClass(...args2) {
    this.el.classList.add(...args2);
    return this;
  }
  onlyOneClass(cls) {
    var parent = this.parent();
    parent.children().forEach((it) => {
      it.removeClass(cls);
    });
    this.addClass(cls);
  }
  toggleClass(cls, isForce) {
    this.el.classList.toggle(cls, isForce);
    return this;
  }
  html(html2) {
    try {
      if (typeof html2 === "undefined") {
        return this.el.innerHTML;
      }
      if (typeof html2 === "string") {
        Object.assign(this.el, { innerHTML: html2 });
      } else {
        this.empty().append(html2);
      }
      return this;
    } catch (e2) {
      console.log(e2, html2);
      return this;
    }
  }
  htmlDiff(fragment) {
    DomDiff(this, fragment);
  }
  updateDiff(html2, rootElement = "div", options2 = {}) {
    DomDiff(this, Dom.create(rootElement).html(html2), options2);
  }
  updateSVGDiff(html2, rootElement = "div") {
    DomDiff(this, Dom.create(rootElement).html(`<svg>${html2}</svg>`).firstChild.firstChild);
  }
  find(selector2) {
    return this.el.querySelector(selector2);
  }
  $(selector2) {
    var node = this.find(selector2);
    return node ? Dom.create(node) : null;
  }
  findAll(selector2) {
    return Array.from(this.el.querySelectorAll(selector2));
  }
  $$(selector2) {
    var arr = this.findAll(selector2);
    return arr.map((node) => Dom.create(node));
  }
  empty() {
    while (this.el.firstChild)
      this.el.removeChild(this.el.firstChild);
    return this;
  }
  append(el) {
    if (typeof el === "string") {
      this.el.appendChild(document.createTextNode(el));
    } else {
      this.el.appendChild(el.el || el);
    }
    return this;
  }
  prepend(el) {
    if (typeof el === "string") {
      this.el.prepend(document.createTextNode(el));
    } else {
      this.el.prepend(el.el || el);
    }
    return this;
  }
  prependHTML(html2) {
    var $dom = Dom.create("div").html(html2);
    this.prepend($dom.createChildrenFragment());
    return $dom;
  }
  appendHTML(html2) {
    var $dom = Dom.create("div").html(html2);
    this.append($dom.createChildrenFragment());
    return $dom;
  }
  createChildrenFragment() {
    const list2 = this.children();
    var fragment = document.createDocumentFragment();
    list2.forEach(($el) => fragment.appendChild($el.el));
    return fragment;
  }
  appendTo(target) {
    var t = target.el ? target.el : target;
    t.appendChild(this.el);
    return this;
  }
  remove() {
    if (this.el.parentNode) {
      this.el.parentNode.removeChild(this.el);
    }
    return this;
  }
  removeChild(el) {
    this.el.removeChild(el.el || el);
    return this;
  }
  text(value) {
    if (typeof value === "undefined") {
      return this.el.textContent;
    } else {
      var tempText = value;
      if (value instanceof Dom) {
        tempText = value.text();
      }
      if (this.el.textContent !== tempText) {
        this.el.textContent = tempText;
      }
      return this;
    }
  }
  css(key, value) {
    if (typeof key !== "undefined" && typeof value !== "undefined") {
      if (key.indexOf("--") === 0 && typeof value !== "undefined") {
        this.el.style.setProperty(key, value);
      } else {
        this.el.style[key] = value;
      }
    } else if (typeof key !== "undefined") {
      if (typeof key === "string") {
        return getComputedStyle(this.el)[key];
      } else {
        Object.entries(key).forEach(([localKey, value2]) => {
          if (localKey.indexOf("--") === 0 && typeof value2 !== "undefined") {
            this.el.style.setProperty(localKey, value2);
          } else {
            this.el.style[localKey] = value2;
          }
        });
      }
    }
    return this;
  }
  getComputedStyle(...list2) {
    var css = getComputedStyle(this.el);
    var obj2 = {};
    list2.forEach((it) => {
      obj2[it] = css[it];
    });
    return obj2;
  }
  getStyleList(...list2) {
    var style = {};
    var len2 = this.el.style.length;
    for (var i = 0; i < len2; i++) {
      var key = this.el.style[i];
      style[key] = this.el.style[key];
    }
    list2.forEach((key2) => {
      style[key2] = this.css(key2);
    });
    return style;
  }
  cssText(value) {
    if (typeof value === "undefined") {
      return this.el.style.cssText;
    }
    if (value != this.el.tempCssText) {
      this.el.style.cssText = value;
      this.el.tempCssText = value;
    }
    return this;
  }
  cssArray(arr) {
    if (arr[0])
      this.el.style[arr[0]] = arr[1];
    if (arr[2])
      this.el.style[arr[2]] = arr[3];
    if (arr[4])
      this.el.style[arr[4]] = arr[5];
    if (arr[6])
      this.el.style[arr[6]] = arr[7];
    if (arr[8])
      this.el.style[arr[8]] = arr[9];
    return this;
  }
  cssFloat(key) {
    return parseFloat(this.css(key));
  }
  cssInt(key) {
    return parseInt(this.css(key));
  }
  px(key, value) {
    return this.css(key, `${value}px`);
  }
  rect() {
    return this.el.getBoundingClientRect();
  }
  bbox() {
    return this.el.getBBox();
  }
  isSVG() {
    return this.el.tagName.toUpperCase() === "SVG";
  }
  offsetRect() {
    if (this.isSVG()) {
      const parentBox = this.parent().rect();
      const box = this.rect();
      return {
        x: box.x - parentBox.x,
        y: box.y - parentBox.y,
        width: box.width,
        height: box.height
      };
    }
    return {
      x: this.el.offsetLeft,
      y: this.el.offsetTop,
      width: this.el.offsetWidth,
      height: this.el.offsetHeight
    };
  }
  offset() {
    var rect2 = this.rect();
    var scrollTop = Dom.getScrollTop();
    var scrollLeft = Dom.getScrollLeft();
    return {
      top: rect2.top + scrollTop,
      left: rect2.left + scrollLeft
    };
  }
  offsetLeft() {
    return this.offset().left;
  }
  offsetTop() {
    return this.offset().top;
  }
  position() {
    if (this.el.style.top) {
      return {
        top: parseFloat(this.css("top")),
        left: parseFloat(this.css("left"))
      };
    } else {
      return this.rect();
    }
  }
  size() {
    return [this.width(), this.height()];
  }
  width() {
    return this.el.offsetWidth || this.rect().width;
  }
  contentWidth() {
    return this.width() - this.cssFloat("padding-left") - this.cssFloat("padding-right");
  }
  height() {
    return this.el.offsetHeight || this.rect().height;
  }
  contentHeight() {
    return this.height() - this.cssFloat("padding-top") - this.cssFloat("padding-bottom");
  }
  val(value) {
    if (typeof value === "undefined") {
      return this.el.value;
    } else if (typeof value !== "undefined") {
      var tempValue = value;
      if (value instanceof Dom) {
        tempValue = value.val();
      }
      this.el.value = tempValue;
    }
    return this;
  }
  matches(selector2) {
    if (this.el) {
      if (!this.el.matches)
        return null;
      if (this.el.matches(selector2)) {
        return this;
      }
      return this.parent().matches(selector2);
    }
    return null;
  }
  get value() {
    return this.el.value;
  }
  get naturalWidth() {
    return this.el.naturalWidth;
  }
  get naturalHeight() {
    return this.el.naturalHeight;
  }
  get files() {
    return this.el.files ? [...this.el.files] : [];
  }
  realVal() {
    switch (this.el.nodeType) {
      case "INPUT":
        var type = this.attr("type");
        if (type == "checkbox" || type == "radio") {
          return this.checked();
        }
      case "SELECT":
      case "TEXTAREA":
        return this.el.value;
    }
    return "";
  }
  int() {
    return parseInt(this.val(), 10);
  }
  float() {
    return parseFloat(this.val());
  }
  show(displayType = "block") {
    this.el.style.display = displayType != "none" ? displayType : "block";
    return this;
  }
  hide() {
    this.el.style.display = "none";
    return this;
  }
  isHide() {
    return this.el.style.display === "none";
  }
  isShow() {
    return !this.isHide();
  }
  toggle(isForce) {
    var currentHide = this.isHide();
    if (arguments.length == 1) {
      if (isForce) {
        return this.show();
      } else {
        return this.hide();
      }
    } else {
      if (currentHide) {
        return this.show();
      } else {
        return this.hide();
      }
    }
  }
  get totalLength() {
    return this.el.getTotalLength();
  }
  scrollIntoView() {
    this.el.scrollIntoView();
  }
  addScrollLeft(dt) {
    this.el.scrollLeft += dt;
    return this;
  }
  addScrollTop(dt) {
    this.el.scrollTop += dt;
    return this;
  }
  setScrollTop(scrollTop) {
    this.el.scrollTop = scrollTop;
    return this;
  }
  setScrollLeft(scrollLeft) {
    this.el.scrollLeft = scrollLeft;
    return this;
  }
  scrollTop() {
    if (this.el === document.body) {
      return Dom.getScrollTop();
    }
    return this.el.scrollTop;
  }
  scrollLeft() {
    if (this.el === document.body) {
      return Dom.getScrollLeft();
    }
    return this.el.scrollLeft;
  }
  scrollHeight() {
    return this.el.scrollHeight;
  }
  scrollWidth() {
    return this.el.scrollWidth;
  }
  on(eventName, callback, opt1, opt2) {
    this.el.addEventListener(eventName, callback, opt1, opt2);
    return this;
  }
  off(eventName, callback) {
    this.el.removeEventListener(eventName, callback);
    return this;
  }
  getElement() {
    return this.el;
  }
  createChild(tag, className = "", attrs = {}, css = {}) {
    let $element = Dom.create(tag, className, attrs);
    $element.css(css);
    this.append($element);
    return $element;
  }
  get firstChild() {
    return Dom.create(this.el.firstElementChild);
  }
  children() {
    var element = this.el.firstElementChild;
    if (!element) {
      return [];
    }
    var results = [];
    do {
      results.push(Dom.create(element));
      element = element.nextElementSibling;
    } while (element);
    return results;
  }
  childLength() {
    return this.el.children.length;
  }
  replace(newElement) {
    if (this.el.parentNode) {
      this.el.parentNode.replaceChild(newElement.el || newElement, this.el);
    }
    return this;
  }
  replaceChild(oldElement, newElement) {
    this.el.replaceChild(newElement.el || newElement, oldElement.el || oldElement);
    return this;
  }
  checked(isChecked = false) {
    if (arguments.length == 0) {
      return !!this.el.checked;
    }
    this.el.checked = !!isChecked;
    return this;
  }
  click() {
    this.el.click();
    return this;
  }
  focus() {
    this.el.focus();
    return this;
  }
  select() {
    if (this.attr("contenteditable") === "true") {
      var range = document.createRange();
      range.selectNodeContents(this.el);
      var sel = window.getSelection();
      sel.removeAllRanges();
      sel.addRange(range);
    } else {
      this.el.select();
    }
    return this;
  }
  blur() {
    this.el.blur();
    return this;
  }
  context(contextType = "2d") {
    if (!this._initContext) {
      this._initContext = this.el.getContext(contextType);
    }
    return this._initContext;
  }
  resize({ width: width2, height: height2 }) {
    this._initContext = null;
    var ctx = this.context();
    var scale2 = window.devicePixelRatio || 1;
    this.px("width", +width2);
    this.px("height", +height2);
    this.el.width = width2 * scale2;
    this.el.height = height2 * scale2;
    ctx.scale(scale2, scale2);
  }
  toDataURL(type = "image/png", quality = 1) {
    return this.el.toDataURL(type, quality);
  }
  clear() {
    this.context().clearRect(0, 0, this.el.width, this.el.height);
  }
  update(callback) {
    this.clear();
    callback.call(this, this);
  }
  drawImage(img, dx = 0, dy = 0) {
    var ctx = this.context();
    var scale2 = window.devicePixelRatio || 1;
    ctx.drawImage(img, dx, dy, img.width, img.height, 0, 0, this.el.width / scale2, this.el.height / scale2);
  }
  drawOption(option = {}) {
    var ctx = this.context();
    Object.assign(ctx, option);
  }
  drawLine(x1, y1, x2, y2) {
    var ctx = this.context();
    ctx.beginPath();
    ctx.moveTo(x1, y1);
    ctx.lineTo(x2, y2);
    ctx.stroke();
    ctx.closePath();
  }
  drawPath(...path) {
    var ctx = this.context();
    ctx.beginPath();
    path.forEach((p, index2) => {
      if (index2 == 0) {
        ctx.moveTo(p[0], p[1]);
      } else {
        ctx.lineTo(p[0], p[1]);
      }
    });
    ctx.stroke();
    ctx.fill();
    ctx.closePath();
  }
  drawCircle(cx, cy, r) {
    var ctx = this.context();
    ctx.beginPath();
    ctx.arc(cx, cy, r, 0, 2 * Math.PI);
    ctx.stroke();
    ctx.fill();
  }
  drawText(x2, y2, text2) {
    this.context().fillText(text2, x2, y2);
  }
  fullscreen() {
    var element = this.el;
    if (element.requestFullscreen) {
      element.requestFullscreen();
    } else if (element.wekitRequestFullscreen) {
      element.wekitRequestFullscreen();
    }
  }
  toggleFullscreen() {
    if (this.el === document.fullscreenElement) {
      document.exitFullscreen();
    } else {
      this.fullscreen();
    }
  }
}
class BaseHandler {
  constructor(context, options2 = {}) {
    this.context = context;
    this.options = options2;
  }
  initialize() {
  }
  load() {
  }
  refresh() {
  }
  render() {
  }
  getRef(id) {
    return this.context.getRef(id);
  }
  run() {
  }
  destroy() {
  }
}
const scrollBlockingEvents = {
  "touchstart": true,
  "touchmove": true,
  "mousedown": true,
  "mouseup": true,
  "mousemove": true
};
const eventConverts = {
  "doubletab": "touchend"
};
const customEventNames = {
  "doubletab": true
};
class DomEventHandler extends BaseHandler {
  initialize() {
    this.destroy();
    if (this._domEvents && this.context.notEventRedefine) {
      return;
    }
    if (!this._domEvents) {
      this._domEvents = this.context.filterProps(CHECK_DOM_EVENT_PATTERN);
    }
    this._domEvents.forEach((key) => this.parseDomEvent(key));
  }
  destroy() {
    if (this.context.notEventRedefine)
      ;
    else {
      this.removeEventAll();
    }
  }
  removeEventAll() {
    this.getBindings().forEach((obj2) => {
      this.removeDomEvent(obj2);
    });
    this.initBindings();
  }
  removeDomEvent({ eventName, dom, callback }) {
    Event.removeDomEvent(dom, eventName, callback);
  }
  getBindings() {
    if (!this._bindings) {
      this.initBindings();
    }
    return this._bindings;
  }
  addBinding(obj2) {
    this.getBindings().push(obj2);
  }
  initBindings() {
    this._bindings = [];
  }
  matchPath(el, selector2) {
    if (el) {
      if (el.matches(selector2)) {
        return el;
      }
      return this.matchPath(el.parentElement, selector2);
    }
    return null;
  }
  hasDelegate(e2, eventObject) {
    return this.matchPath(e2.target || e2.srcElement, eventObject.delegate);
  }
  makeCallback(eventObject, callback) {
    if (eventObject.delegate) {
      return this.makeDelegateCallback(eventObject, callback);
    } else {
      return this.makeDefaultCallback(eventObject, callback);
    }
  }
  makeDefaultCallback(eventObject, callback) {
    return (e2) => {
      var returnValue = this.runEventCallback(e2, eventObject, callback);
      if (isNotUndefined(returnValue)) {
        return returnValue;
      }
    };
  }
  makeDelegateCallback(eventObject, callback) {
    return (e2) => {
      const delegateTarget = this.hasDelegate(e2, eventObject);
      if (delegateTarget) {
        e2.$dt = Dom.create(delegateTarget);
        var returnValue = this.runEventCallback(e2, eventObject, callback);
        if (isNotUndefined(returnValue)) {
          return returnValue;
        }
      }
    };
  }
  runEventCallback(e2, eventObject, callback) {
    const context = this.context;
    e2.xy = Event.posXY(e2);
    if (eventObject.beforeMethods.length) {
      eventObject.beforeMethods.every((before) => {
        return context[before.target].call(context, e2, before.param);
      });
    }
    if (this.checkEventType(e2, eventObject)) {
      var returnValue = callback(e2, e2.$dt, e2.xy);
      if (returnValue !== false && eventObject.afterMethods.length) {
        eventObject.afterMethods.forEach((after) => {
          return context[after.target].call(context, e2, after.param);
        });
      }
      return returnValue;
    }
  }
  checkEventType(e2, eventObject) {
    const context = this.context;
    var hasKeyCode = true;
    if (eventObject.codes.length) {
      hasKeyCode = (e2.code ? eventObject.codes.indexOf(e2.code.toLowerCase()) > -1 : false) || (e2.key ? eventObject.codes.indexOf(e2.key.toLowerCase()) > -1 : false);
    }
    var isAllCheck = true;
    if (eventObject.checkMethodList.length) {
      isAllCheck = eventObject.checkMethodList.every((field) => {
        var fieldValue = context[field];
        if (isFunction(fieldValue) && fieldValue) {
          return fieldValue.call(context, e2);
        } else if (isNotUndefined(fieldValue)) {
          return !!fieldValue;
        }
        return true;
      });
    }
    return hasKeyCode && isAllCheck;
  }
  getDefaultDomElement(dom) {
    const context = this.context;
    let el;
    if (dom) {
      el = context.refs[dom] || context[dom] || window[dom];
    } else {
      el = context.el || context.$el || context.$root;
    }
    if (el instanceof Dom) {
      return el.getElement();
    }
    return el;
  }
  getRealEventName(eventName) {
    return eventConverts[eventName] || eventName;
  }
  getCustomEventName(eventName) {
    return customEventNames[eventName] ? eventName : "";
  }
  getDefaultEventObject(eventName, checkMethodFilters) {
    const context = this.context;
    let arr = checkMethodFilters;
    const checkMethodList = arr.filter((code2) => !!context[code2]);
    const [afters, afterMethods] = splitMethodByKeyword(arr, "after");
    const [befores, beforeMethods] = splitMethodByKeyword(arr, "before");
    const [debounces, debounceMethods] = splitMethodByKeyword(arr, "debounce");
    const [delays, delayMethods] = splitMethodByKeyword(arr, "delay");
    const [throttles, throttleMethods] = splitMethodByKeyword(arr, "throttle");
    const [captures] = splitMethodByKeyword(arr, "capture");
    const filteredList = [
      ...checkMethodList,
      ...afters,
      ...befores,
      ...delays,
      ...debounces,
      ...throttles,
      ...captures
    ];
    var codes = arr.filter((code2) => filteredList.indexOf(code2) === -1).map((code2) => code2.toLowerCase());
    return {
      eventName: this.getRealEventName(eventName),
      customEventName: this.getCustomEventName(eventName),
      codes,
      captures,
      afterMethods,
      beforeMethods,
      delayMethods,
      debounceMethods,
      throttleMethods,
      checkMethodList
    };
  }
  addDomEvent(eventObject, callback) {
    eventObject.callback = this.makeCallback(eventObject, callback);
    this.addBinding(eventObject);
    var options2 = !!eventObject.captures.length;
    if (scrollBlockingEvents[eventObject.eventName]) {
      options2 = {
        passive: true,
        capture: options2
      };
    }
    Event.addDomEvent(eventObject.dom, eventObject.eventName, eventObject.callback, options2);
  }
  makeCustomEventCallback(eventObject, callback) {
    if (eventObject.customEventName === "doubletab") {
      var delay = 300;
      if (eventObject.delayMethods.length) {
        delay = +eventObject.delayMethods[0].target;
      }
      return (...args2) => {
        if (!this.doubleTab) {
          this.doubleTab = {
            time: performance.now()
          };
        } else {
          if (performance.now() - this.doubleTab.time < delay) {
            callback(...args2);
          }
          this.doubleTab = null;
        }
      };
    }
    return callback;
  }
  bindingDomEvent([eventName, dom, ...delegate], checkMethodFilters, callback) {
    let eventObject = this.getDefaultEventObject(eventName, checkMethodFilters);
    eventObject.dom = this.getDefaultDomElement(dom);
    eventObject.delegate = delegate.join(SAPARATOR);
    if (eventObject.debounceMethods.length) {
      var debounceTime = +eventObject.debounceMethods[0].target;
      callback = debounce(callback, debounceTime);
    } else if (eventObject.throttleMethods.length) {
      var throttleTime = +eventObject.throttleMethods[0].target;
      callback = throttle(callback, throttleTime);
    }
    callback = this.makeCustomEventCallback(eventObject, callback);
    this.addDomEvent(eventObject, callback);
  }
  getEventNames(eventName) {
    let results = [];
    eventName.split(NAME_SAPARATOR).forEach((e2) => {
      var arr = e2.split(NAME_SAPARATOR);
      results.push.apply(results, arr);
    });
    return results;
  }
  parseDomEvent(key) {
    const context = this.context;
    let checkMethodFilters = key.split(CHECK_SAPARATOR).map((it) => it.trim()).filter(Boolean);
    var prefix = checkMethodFilters.shift();
    var eventSelectorAndBehave = prefix.split(DOM_EVENT_SAPARATOR)[1];
    var arr = eventSelectorAndBehave.split(SAPARATOR);
    var eventNames = this.getEventNames(arr[0]);
    var callback = context[key].bind(context);
    for (let i = 0, len2 = eventNames.length; i < len2; i++) {
      arr[0] = eventNames[i];
      this.bindingDomEvent(arr, checkMethodFilters, callback);
    }
  }
}
const convertToPx = (key, value) => {
  if (isNumber(value)) {
    switch (key) {
      case "width":
      case "height":
      case "top":
      case "left":
      case "right":
      case "bottom":
        return value + "px";
    }
  }
  return value;
};
const applyElementAttribute = ($element, key, value) => {
  if (key === "cssText") {
    $element.cssText(value);
    return;
  } else if (key === "style") {
    if (typeof value !== "string") {
      const css = {};
      Object.entries(value).forEach(([key2, value2]) => {
        css[key2] = convertToPx(key2, value2);
      });
      $element.css(css);
    }
    return;
  } else if (key === "class") {
    if (Array.isArray(value)) {
      $element.addClass(...value.filter(Boolean));
    } else if (isObject(value)) {
      const keys2 = Object.keys(value);
      for (var i = 0, len2 = keys2.length; i < len2; i++) {
        const className = keys2[i];
        const hasClass = value[className];
        $element.toggleClass(className, hasClass);
      }
    } else {
      $element.el.className = value;
    }
    return;
  } else if (key === "callback") {
    if (typeof value === "function") {
      value();
      return;
    }
  }
  if (typeof value === "undefined") {
    $element.removeAttr(key);
  } else {
    if ($element.el.nodeName === "TEXTAREA" && key === "value") {
      $element.text(value);
    } else if (key === "text" || key === "textContent") {
      $element.text(value);
    } else if (key === "innerHTML" || key === "html") {
      $element.html(value);
    } else if (key === "htmlDiff") {
      $element.updateDiff(value);
    } else if (key === "svgDiff") {
      $element.updateSVGDiff(value);
    } else if (key === "value") {
      $element.val(value);
    } else {
      $element.attr(key, value);
    }
  }
};
class BindHandler extends BaseHandler {
  load(...args2) {
    this.bindData(...args2);
  }
  bindData(...args2) {
    if (!this._bindMethods) {
      this._bindMethods = this.context.filterProps(CHECK_BIND_PATTERN);
    }
    const bindList = this._bindMethods.filter((originalCallbackName) => {
      if (!args2.length)
        return true;
      var [callbackName, id] = originalCallbackName.split(CHECK_SAPARATOR);
      var [_, $bind] = callbackName.split(" ");
      return args2.indexOf($bind) > -1;
    });
    bindList.forEach(async (callbackName) => {
      const bindMethod = this.context[callbackName];
      var [callbackName, id] = callbackName.split(CHECK_SAPARATOR);
      const refObject = this.getRef(id);
      let refCallback = BIND_CHECK_DEFAULT_FUNCTION;
      if (refObject != "" && typeof refObject === "string") {
        refCallback = BIND_CHECK_FUNCTION(refObject);
      } else if (typeof refObject === "function") {
        refCallback = refObject;
      }
      const elName = callbackName.split(BIND_SAPARATOR)[1];
      let $element = this.context.refs[elName];
      const isBindCheck = typeof refCallback === "function" && refCallback.call(this.context);
      if ($element && isBindCheck) {
        const results = await bindMethod.call(this.context, ...args2);
        if (!results)
          return;
        const keys2 = Object.keys(results);
        for (var elementKeyIndex = 0, len2 = keys2.length; elementKeyIndex < len2; elementKeyIndex++) {
          const key = keys2[elementKeyIndex];
          const value = results[key];
          applyElementAttribute($element, key, value);
        }
      }
    });
  }
  destroy() {
    this._bindMethods = void 0;
  }
}
class CallbackHandler extends BaseHandler {
  initialize() {
    this.destroy();
    if (!this._callbacks) {
      this._callbacks = this.context.filterProps(CHECK_CALLBACK_PATTERN);
    }
    this._callbacks.forEach((key) => this.parseCallback(key));
  }
  destroy() {
    if (this.context.notEventRedefine)
      ;
    else {
      this.removeCallbackAll();
    }
  }
  removeCallbackAll() {
    this.getBindings().forEach((obj2) => {
      this.removeCallback(obj2);
    });
    this.initBindings();
  }
  removeCallback({ animationFrameId }) {
    cancelAnimationFrame(animationFrameId);
  }
  getBindings() {
    if (!this._bindings) {
      this.initBindings();
    }
    return this._bindings;
  }
  addBinding(obj2) {
    this.getBindings().push(obj2);
  }
  initBindings() {
    this._bindings = [];
  }
  matchPath(el, selector2) {
    if (el) {
      if (el.matches(selector2)) {
        return el;
      }
      return this.matchPath(el.parentElement, selector2);
    }
    return null;
  }
  makeCallback(callbackObject, callback) {
    const run = (time) => {
      callback(time);
      callbackObject.requestId = requestAnimationFrame(run);
    };
    return () => {
      callbackObject.requestId = requestAnimationFrame(run);
    };
  }
  getDefaultCallbackObject(callbackName, checkMethodFilters) {
    const context = this.context;
    let arr = checkMethodFilters;
    const checkMethodList = arr.filter((code2) => !!context[code2]);
    const [afters, afterMethods] = splitMethodByKeyword(arr, "after");
    const [befores, beforeMethods] = splitMethodByKeyword(arr, "before");
    const [debounces, debounceMethods] = splitMethodByKeyword(arr, "debounce");
    const [delays, delayMethods] = splitMethodByKeyword(arr, "delay");
    const [throttles, throttleMethods] = splitMethodByKeyword(arr, "throttle");
    const [captures] = splitMethodByKeyword(arr, "capture");
    [
      ...checkMethodList,
      ...afters,
      ...befores,
      ...delays,
      ...debounces,
      ...throttles,
      ...captures
    ];
    return {
      callbackName,
      captures,
      afterMethods,
      beforeMethods,
      delayMethods,
      debounceMethods,
      throttleMethods,
      checkMethodList
    };
  }
  addCallback(callbackObject, callback) {
    callbackObject.callback = this.makeCallback(callbackObject, callback);
    this.addBinding(callbackObject);
    callbackObject.callback();
  }
  bindingCallback(callbackName, checkMethodFilters, originalCallback) {
    let callbackObject = this.getDefaultCallbackObject(callbackName, checkMethodFilters);
    if (callbackObject.debounceMethods.length) {
      var debounceTime = +callbackObject.debounceMethods[0].target;
      originalCallback = debounce(originalCallback, debounceTime);
    } else if (callbackObject.throttleMethods.length) {
      var throttleTime = +callbackObject.throttleMethods[0].target;
      originalCallback = throttle(originalCallback, throttleTime);
    }
    this.addCallback(callbackObject, originalCallback);
  }
  parseCallback(key) {
    const context = this.context;
    let checkMethodFilters = key.split(CHECK_SAPARATOR).map((it) => it.trim()).filter(Boolean);
    var prefix = checkMethodFilters.shift();
    var callbackName = prefix.split(CALLBACK_SAPARATOR)[1];
    var originalCallback = context[key].bind(context);
    this.bindingCallback(callbackName, checkMethodFilters, originalCallback);
  }
}
const REFERENCE_PROPERTY = "ref";
const TEMP_DIV$1 = Dom.create("div");
const QUERY_PROPERTY = `[${REFERENCE_PROPERTY}]`;
const REF_CLASS = "refclass";
const REF_CLASS_PROPERTY = `[${REF_CLASS}]`;
class EventMachine {
  constructor(opt, props2) {
    this.state = {};
    this.prevState = {};
    this.refs = {};
    this.children = {};
    this._bindings = [];
    this.id = uuid();
    this.handlers = this.initializeHandler();
    this._localTimestamp = 0;
    this.initializeProperty(opt, props2);
    this.initComponents();
  }
  get _timestamp() {
    return this._localTimestamp++;
  }
  get target() {
    return this.$el.el;
  }
  initializeProperty(opt, props2 = {}) {
    this.opt = opt || {};
    this.parent = this.opt;
    this.props = props2;
    this.source = uuid();
    this.sourceName = this.constructor.name;
  }
  initComponents() {
    this.childComponents = this.components();
  }
  initializeHandler() {
    return [
      new BindHandler(this),
      new DomEventHandler(this),
      new CallbackHandler(this)
    ];
  }
  initState() {
    return {};
  }
  setState(state = {}, isLoad = true) {
    this.prevState = this.state;
    this.state = Object.assign({}, this.state, state);
    if (isLoad) {
      this.load();
    }
  }
  toggleState(key, isLoad = true) {
    this.setState({
      [key]: !this.state[key]
    }, isLoad);
  }
  apply(obj2) {
    return spreadVariable(obj2);
  }
  _reload(props2, $container = null) {
    if ($container) {
      this.render($container);
    }
    this.props = props2;
    this.state = {};
    this.setState(this.initState(), false);
    this.refresh(true);
  }
  render($container) {
    this.$el = this.parseTemplate(html`
        ${this.template()}
      `);
    this.refs.$el = this.$el;
    if ($container) {
      $container.append(this.$el);
    }
    this.load();
    this.afterRender();
  }
  initialize() {
    this.state = this.initState();
  }
  afterRender() {
  }
  components() {
    return {};
  }
  getRef(...args2) {
    const key = args2.join("");
    return this.refs[key];
  }
  parseTemplate(html2, isLoad) {
    if (Array.isArray(html2)) {
      html2 = html2.join("");
    }
    html2 = html2.trim();
    const list2 = TEMP_DIV$1.html(html2).children();
    for (var i = 0, len2 = list2.length; i < len2; i++) {
      const $el = list2[i];
      var ref = $el.attr(REFERENCE_PROPERTY);
      if (ref) {
        this.refs[ref] = $el;
      }
      var refs = $el.$$(QUERY_PROPERTY);
      var temp = {};
      for (var refsIndex = 0, refsLen = refs.length; refsIndex < refsLen; refsIndex++) {
        const $dom = refs[refsIndex];
        const name2 = $dom.attr(REFERENCE_PROPERTY);
        if (temp[name2]) {
          console.warn(`${ref} is duplicated. - ${this.sourceName}`, this);
        } else {
          temp[name2] = true;
        }
        this.refs[name2] = $dom;
      }
    }
    if (!isLoad) {
      return list2[0];
    }
    return TEMP_DIV$1.createChildrenFragment();
  }
  parsePropertyInfo($dom) {
    let props2 = {};
    for (var t of $dom.el.attributes) {
      if (hasVariable(t.nodeName)) {
        const recoveredValue = getVariable(t.nodeName);
        if (isObject(recoveredValue)) {
          props2 = Object.assign(props2, recoveredValue);
        } else {
          props2[t.nodeName] = getVariable(t.nodeValue);
        }
      } else {
        props2[t.nodeName] = getVariable(t.nodeValue);
      }
    }
    const content2 = $dom.html();
    if (content2) {
      props2.content = content2;
      props2.contentChildren = this.parseContent(props2.content);
    }
    return props2;
  }
  parseSourceName(obj2) {
    if (obj2.parent) {
      return [obj2.sourceName, ...this.parseSourceName(obj2.parent)];
    }
    return [obj2.sourceName];
  }
  getEventMachineComponent(refClassName) {
    var EventMachineComponent = retriveElement(refClassName) || this.childComponents[refClassName];
    return EventMachineComponent;
  }
  createInstanceForComponent(EventMachineComponent, targetElement, props2) {
    if (EventMachineComponent.__proto__.name === "ProxyComponent") {
      return new EventMachineComponent({ target: targetElement, props: props2 });
    }
    return new EventMachineComponent(this, props2);
  }
  renderComponent({ $dom, refName, component: component2, props: props2 }) {
    var _a;
    var instance = null;
    if (this.children[refName]) {
      instance = this.children[refName];
      instance.__timestamp = this._localTimestamp;
      instance._reload(props2);
    } else {
      instance = this.createInstanceForComponent(component2, $dom.$parent.el, props2);
      instance.__timestamp = this._localTimestamp;
      this.children[refName || instance.id] = instance;
      if (isFunction(instance.render)) {
        instance.render();
      }
    }
    if (instance.renderTarget) {
      (_a = instance.$el) == null ? void 0 : _a.appendTo(instance.renderTarget);
      $dom.remove();
    } else if (instance.$el) {
      $dom.replace(instance.$el);
    } else {
      $dom.remove();
    }
  }
  parseContent(html2, filteredRefClass = []) {
    return Dom.create("div").html(html2).children().map(($dom) => {
      return this._getComponentInfo($dom);
    }).filter((it) => filteredRefClass.length === 0 ? true : filteredRefClass.includes(it.refClass));
  }
  _getComponentInfo($dom) {
    const refClass = $dom.attr(REF_CLASS);
    const EventMachineComponent = this.getEventMachineComponent(refClass);
    if (EventMachineComponent) {
      let props2 = this.parsePropertyInfo($dom);
      let refName = $dom.attr(REFERENCE_PROPERTY);
      return {
        $dom,
        refClass,
        props: props2,
        refName: refName || props2.ref,
        component: EventMachineComponent
      };
    } else {
      return {
        notUsed: true,
        $dom
      };
    }
  }
  getComponentInfoList($el) {
    if (!$el)
      return [];
    const children2 = [];
    let targets = $el.$$(REF_CLASS_PROPERTY).filter((it) => {
      return it.path().filter((a) => {
        return a.attr(REF_CLASS);
      }).length === 1;
    });
    targets.forEach(($dom) => {
      children2.push(this._getComponentInfo($dom));
    });
    return children2;
  }
  parseComponent() {
    const $el = this.$el;
    const componentList = this.getComponentInfoList($el);
    componentList.forEach((comp) => {
      if (comp.notUsed) {
        comp.$dom.remove();
      } else {
        this.renderComponent(comp);
      }
    });
    keyEach(this.children, (key, child) => {
      if (child.__timestamp !== this._localTimestamp) {
        child.clean();
      }
    });
  }
  clean() {
    if (this.$el && !this.$el.hasParent()) {
      keyEach(this.children, (key, child) => {
        if (isFunction(child == null ? void 0 : child.clean)) {
          child.clean();
        }
      });
      this.destroy();
      this.$el = null;
      return true;
    }
  }
  refresh() {
    this.load();
  }
  _afterLoad() {
    this._timestamp;
    this.runHandlers("initialize");
    this.bindData();
    this.parseComponent();
  }
  async load(...args2) {
    if (!this._loadMethods) {
      this._loadMethods = this.filterProps(CHECK_LOAD_PATTERN);
    }
    const localLoadMethods = this._loadMethods.filter((callbackName) => {
      const elName = callbackName.split(LOAD_SAPARATOR)[1].split(CHECK_SAPARATOR).map((it) => it.trim())[0];
      if (!args2.length)
        return true;
      return args2.indexOf(elName) > -1;
    });
    await localLoadMethods.forEach(async (callbackName) => {
      let methodName = callbackName.split(LOAD_SAPARATOR)[1];
      var [elName, ...checker] = methodName.split(CHECK_SAPARATOR).map((it) => it.trim());
      checker = checker.map((it) => it.trim());
      const isDomDiff = Boolean(checker.filter((it) => DOMDIFF.includes(it)).length);
      const refTarget = this.refs[elName];
      if (refTarget) {
        var newTemplate = await this[callbackName].apply(this, args2);
        if (Array.isArray(newTemplate)) {
          newTemplate = newTemplate.join("");
        }
        const fragment = this.parseTemplate(html`${newTemplate}`, true);
        if (isDomDiff) {
          refTarget.htmlDiff(fragment);
        } else {
          if (refTarget) {
            refTarget.html(fragment);
          }
        }
      }
    });
    this._afterLoad();
  }
  runHandlers(func2 = "run", ...args2) {
    this.handlers.forEach((h) => h[func2](...args2));
  }
  bindData(...args2) {
    this.runHandlers("load", ...args2);
  }
  template() {
    return `<div></div>`;
  }
  eachChildren(callback) {
    if (!isFunction(callback))
      return;
    keyEach(this.children, (_, Component2) => {
      callback(Component2);
    });
  }
  rerender() {
    var $parent = this.$el.parent();
    this.destroy();
    this.render($parent);
  }
  destroy() {
    this.eachChildren((childComponent) => {
      childComponent.destroy();
    });
    this.runHandlers("destroy");
    if (this.$el) {
      this.$el.remove();
    }
    this.$el = null;
    this.refs = {};
    this.children = {};
  }
  collectProps() {
    if (!this.__cachedMethodList) {
      this.__cachedMethodList = collectProps(this, (name2) => {
        return name2.indexOf(MAGIC_METHOD) === 0;
      });
    }
    return this.__cachedMethodList;
  }
  filterProps(pattern) {
    return this.collectProps().filter((key) => {
      return key.match(pattern);
    });
  }
  self(e2) {
    return e2 && e2.$dt && e2.$dt.is(e2.target);
  }
  isAltKey(e2) {
    return e2.altKey;
  }
  isCtrlKey(e2) {
    return e2.ctrlKey;
  }
  isShiftKey(e2) {
    return e2.shiftKey;
  }
  isMetaKey(e2) {
    return e2.metaKey || e2.key == "Meta" || e2.code.indexOf("Meta") > -1;
  }
  isMouseLeftButton(e2) {
    return e2.buttons === 1;
  }
  isMouseRightButton(e2) {
    return e2.buttons === 2;
  }
  hasMouse(e2) {
    return e2.pointerType === "mouse";
  }
  hasTouch(e2) {
    return e2.pointerType === "touch";
  }
  hasPen(e2) {
    return e2.pointerType === "pen";
  }
  preventDefault(e2) {
    e2.preventDefault();
    return true;
  }
  stopPropagation(e2) {
    e2.stopPropagation();
    return true;
  }
}
class BaseStore {
  constructor(editor) {
    this.id = uuidShort$1();
    this.cachedCallback = {};
    this.callbacks = {};
    this.editor = editor;
    this.promiseProxy = new Proxy(this, {
      get: (target, key) => {
        return this.makePromiseEvent(key);
      }
    });
  }
  getCallbacks(event) {
    if (!this.callbacks[event]) {
      this.callbacks[event] = [];
    }
    return this.callbacks[event];
  }
  setCallbacks(event, list2 = []) {
    this.callbacks[event] = list2;
  }
  debug(...args2) {
  }
  on(event, originalCallback, context, debounceDelay = 0, throttleDelay = 0, enableAllTrigger = false, enableSelfTrigger = false, beforeMethods = []) {
    var callback = originalCallback;
    if (debounceDelay > 0)
      callback = debounce(originalCallback, debounceDelay);
    else if (throttleDelay > 0)
      callback = throttle(originalCallback, throttleDelay);
    if (beforeMethods.length) {
      callback = ifCheck(callback, context, beforeMethods);
    }
    callback = makeRequestAnimationFrame(callback, context);
    this.getCallbacks(event).push({ event, callback, context, originalCallback, enableAllTrigger, enableSelfTrigger });
    this.debug("add message event", event, context.sourceName);
    return () => {
      this.off(event, originalCallback);
    };
  }
  off(event, originalCallback) {
    this.debug("off message event", event);
    if (arguments.length == 1) {
      this.setCallbacks(event);
    } else if (arguments.length == 2) {
      this.setCallbacks(event, this.getCallbacks(event).filter((f) => {
        return f.originalCallback !== originalCallback;
      }));
    }
  }
  offAll(context) {
    Object.keys(this.callbacks).forEach((event) => {
      this.setCallbacks(event, this.getCallbacks(event).filter((f) => {
        return f.context !== context;
      }));
    });
    this.debug("off all message", context.sourceName);
  }
  getCachedCallbacks(event) {
    return this.getCallbacks(event);
  }
  get promise() {
    return this.promiseProxy;
  }
  get p() {
    return this.promise;
  }
  makePromiseEvent(event) {
    var list2 = this.getCachedCallbacks(event);
    const source2 = this.source;
    return (...args2) => Promise.all(list2.filter((f) => {
      return !f.enableSelfTrigger;
    }).filter((f) => {
      return f.enableAllTrigger || f.originalCallback.source !== source2;
    }).map((f) => {
      return new Promise((resolve, reject) => {
        resolve(f.callback.apply(f.context, args2));
      });
    }));
  }
  sendMessage(source2, event, ...args2) {
    this.sendMessageList(source2, [
      [event, ...args2]
    ]);
  }
  sendMessageList(source2, messages = []) {
    Promise.resolve().then(() => {
      messages.forEach(([event, ...args2]) => {
        var list2 = this.getCachedCallbacks(event);
        if (list2 && list2.length) {
          const runnableFunctions = list2.filter((f) => !f.enableSelfTrigger).filter((f) => f.enableAllTrigger || f.originalCallback.source !== source2);
          for (const f of runnableFunctions) {
            const result = f.callback.apply(f.context, args2);
            if (isNotUndefined(result)) {
              if (result === false) {
                return;
              } else if (isFunction(result)) {
                result();
                return;
              }
            }
          }
        } else {
          console.warn(`message event ${event} is not exist.`);
        }
      });
    });
  }
  nextSendMessage(source2, callback, ...args2) {
    Promise.resolve().then(() => {
      callback(...args2);
    });
  }
  triggerMessage(source2, event, ...args2) {
    Promise.resolve().then(() => {
      var list2 = this.getCachedCallbacks(event);
      if (list2) {
        const runnableFunctions = list2.filter((f) => f.originalCallback.source === source2);
        runnableFunctions.forEach((f) => {
          f.callback.apply(f.context, args2);
        });
      } else {
        console.warn(event, " is not valid event");
      }
    });
  }
  emit(event, ...args2) {
    if (isFunction(event)) {
      event(...args2);
    } else if (isArray(event)) {
      this.sendMessageList(this.source, event);
    } else {
      this.sendMessage(this.source, event, ...args2);
    }
  }
  nextTick(callback) {
    this.nextSendMessage(this.source, callback);
  }
  trigger(event, ...args2) {
    if (isFunction(event)) {
      event(...args2);
    } else {
      this.triggerMessage(this.source, event, ...args2);
    }
  }
}
var dark$1 = {
  left_size: 250,
  left_max_size: 400,
  bottom_size: 150,
  bottom_max_size: 500,
  timeline_grid_font_color: "#ececec",
  timeline_line_color: "red",
  timeline_timeview_bottom_color: "black"
};
var light$1 = {
  left_size: 250,
  left_max_size: 400,
  bottom_size: 150,
  bottom_max_size: 500,
  timeline_grid_font_color: "black",
  timeline_line_color: "#4778d4",
  timeline_timeview_bottom_color: "#ececec"
};
var theme = {
  dark: dark$1,
  light: light$1
};
class TimelineSelectionManager {
  constructor(editor) {
    this.$editor = editor;
    this.items = [];
    this.itemKeys = {};
  }
  initialize() {
    this.items = [];
    this.itemKeys = {};
  }
  currentProject(callback) {
    var project2 = this.$editor.selection.currentProject;
    if (project2) {
      callback && callback(project2);
    }
  }
  empty() {
    this.select();
  }
  each(callback) {
    this.items.forEach((item2, index2) => {
      callback && callback(item2, index2);
    });
  }
  refreshCache(list2) {
    this.items = list2;
    this.itemKeys = {};
    this.items.forEach((it) => {
      this.itemKeys[it.id] = it;
    });
  }
  cachedList() {
    return this.items.map((it) => {
      return __spreadValues({}, it);
    });
  }
  checked(id) {
    return !!this.itemKeys[id];
  }
  selectLayer(layerId) {
    this.currentProject((project2) => {
      var list2 = project2.getKeyframeListReturnArray().filter((it) => {
        return it.layerId === layerId;
      });
      this.refreshCache(list2);
    });
  }
  toggleLayerContainer(animationId) {
    this.currentProject((project2) => {
      project2.getSelectedTimeline().animations.filter((it) => {
        return it.id === animationId;
      }).forEach((it) => {
        it.collapsed = !it.collapsed;
      });
    });
  }
  selectProperty(layerId, property) {
    this.currentProject((project2) => {
      var list2 = project2.getKeyframeListReturnArray().filter((it) => {
        return it.layerId === layerId && it.property === property;
      });
      this.refreshCache(list2);
    });
  }
  select(...args2) {
    this.refreshCache(args2);
  }
  selectBySearch(list2, startTime, endTime) {
    this.currentProject((project2) => {
      var totalList = [];
      list2.forEach((it) => {
        var results = [];
        if (it.property) {
          var p = project2.getTimelineProperty(it.layerId, it.property);
          results = p.keyframes.filter((keyframe2) => {
            return startTime <= keyframe2.time && keyframe2.time <= endTime;
          });
        } else {
          var p = project2.getTimelineObject(it.layerId);
          p.properties.filter((property) => {
            return property.property === it.property;
          }).forEach((property) => {
            results.push.apply(results, property.keyframes.filter((keyframe2) => {
              return startTime <= keyframe2.time && keyframe2.time <= endTime;
            }));
          });
        }
        totalList.push.apply(totalList, results);
      });
      var uniqueOffset = {};
      totalList.forEach((it) => {
        uniqueOffset[it.id] = it;
      });
      this.select(...Object.values(uniqueOffset));
    });
  }
  checkLayer(layerId) {
    return Object.keys(this.itemKeys).some((key) => {
      return this.itemKeys[key].layerId === layerId;
    });
  }
  checkProperty(layerId, property) {
    return Object.keys(this.itemKeys).some((key) => {
      return this.itemKeys[key].layerId === layerId && this.itemKeys[key].property === property;
    });
  }
}
const MAX_CACHE_COUNT$2 = 1e3;
const cachedTransformOriginMap = new Map();
class TransformOriginCache {
  static has(key) {
    return cachedTransformOriginMap.has(key);
  }
  static get(key) {
    return cachedTransformOriginMap.get(key);
  }
  static set(key, parsedValue) {
    if (cachedTransformOriginMap.size > MAX_CACHE_COUNT$2) {
      cachedTransformOriginMap.clear();
    }
    cachedTransformOriginMap.set(key, parsedValue);
  }
}
class TransformOrigin {
  static parseStyle(transformOrigin = "50% 50% 0%") {
    if (TransformOriginCache.has(transformOrigin)) {
      return TransformOriginCache.get(transformOrigin);
    }
    const origins = transformOrigin.trim().split(" ").filter((it) => it.trim());
    let parsedTransformOrigin = null;
    if (origins.length === 1) {
      parsedTransformOrigin = [origins[0], origins[0]].map((it) => Length.parse(it));
    } else {
      parsedTransformOrigin = origins.map((it) => Length.parse(it));
    }
    TransformOriginCache.set(transformOrigin, parsedTransformOrigin);
    return parsedTransformOrigin;
  }
  static scale(transformOrigin, width2, height2) {
    let parsedTransformOrigin = TransformOrigin.parseStyle(transformOrigin);
    if (isNaN(width2) || isNaN(height2)) {
      throw new Error(width2);
    }
    const originX = parsedTransformOrigin[0].toPx(width2).value;
    const originY = parsedTransformOrigin[1].toPx(height2).value;
    const originZ = parsedTransformOrigin[2].value;
    return [originX, originY, originZ];
  }
  static toPx(transformOrigin, width2, height2, distance2 = 0) {
    let [
      transformOriginX,
      transformOriginY,
      transformOriginZ
    ] = TransformOrigin.parseStyle(transformOrigin);
    transformOriginX = transformOriginX.toPx(width2);
    transformOriginY = transformOriginY.toPx(height2);
    transformOriginZ = transformOriginZ.toPx(distance2);
    return `${transformOriginX} ${transformOriginY} ${transformOriginZ}`;
  }
}
function linePoint(x1, y1, x2, y2, px, py, buffer = 0.1) {
  const dist1 = Math.hypot(px - x1, py - y1);
  const dist2 = Math.hypot(px - x2, py - y2);
  const lineLength = Math.hypot(x1 - x2, y1 - y2);
  const calcDist = dist1 + dist2;
  return calcDist >= lineLength - buffer && calcDist <= lineLength + buffer;
}
function lineLine(x1, y1, x2, y2, x3, y3, x4, y4, epsilon = 0.1) {
  if (linePoint(x1, y1, x2, y2, x3, y3))
    return true;
  else if (linePoint(x1, y1, x2, y2, x4, y4))
    return true;
  else if (linePoint(x3, y3, x4, y4, x1, y1))
    return [x1, y1];
  else if (linePoint(x3, y3, x4, y4, x2, y2))
    return [x2, y2];
  let A = ((x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3)) / ((y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1));
  let B = ((x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3)) / ((y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1));
  return 0 <= A && A <= 1 && 0 <= B && B <= 1;
}
function polyPoint(verties = [], px, py) {
  let isCollision = false;
  const len2 = verties.length;
  for (let i = 0; i < len2; i++) {
    const v1 = verties[i];
    const v2 = verties[(i + 1) % len2];
    if (linePoint(v1[0], v1[1], v2[0], v2[1], px, py)) {
      isCollision = true;
      break;
    }
  }
  if (isCollision)
    return true;
  verties.forEach((vector, index2) => {
    const [cx, cy] = vector;
    const [nx, ny] = verties[(index2 + 1) % len2];
    if ((cy >= py && ny < py || cy < py && ny >= py) && px < (nx - cx) * (py - cy) / (ny - cy) + cx) {
      isCollision = !isCollision;
    }
  });
  return isCollision;
}
function polyLine(verties = [], x1, y1, x2, y2) {
  const len2 = verties.length;
  return verties.some((vector, index2) => {
    const [x3, y3] = vector;
    const [x4, y4] = verties[(index2 + 1) % len2];
    return lineLine(x1, y1, x2, y2, x3, y3, x4, y4);
  });
}
function polyPoly(verties = [], targetVerties = []) {
  const len2 = verties.length;
  return verties.some((vector, index2) => {
    const [x1, y1] = vector;
    const [x2, y2] = verties[(index2 + 1) % len2];
    let collision = polyLine(targetVerties, x1, y1, x2, y2);
    if (collision)
      return true;
    collision = polyPoint(verties, targetVerties[0][0], targetVerties[0][1]);
    if (collision)
      return true;
    return false;
  });
}
function rectToVerties(x2, y2, width2, height2, origin2 = "50% 50% 0px") {
  const center2 = TransformOrigin.scale(origin2, width2, height2);
  return [
    [x2, y2, 0],
    [x2 + width2, y2, 0],
    [x2 + width2, y2 + height2, 0],
    [x2, y2 + height2, 0],
    [x2 + center2[0], y2 + center2[1], 0]
  ];
}
function getRotatePointer(verties, dist2 = 0) {
  const topPointer = lerp([], verties[0], verties[1], 0.5);
  const bottomPointer = lerp([], verties[2], verties[3], 0.5);
  const rotatePointer = getPointBetweenVerties(bottomPointer, topPointer, dist2);
  return rotatePointer;
}
function rectToVertiesForArea(x2, y2, width2, height2) {
  return rectToVerties(x2, y2, width2, height2);
}
function itemsToRectVerties(items = []) {
  let minX = Number.MAX_SAFE_INTEGER;
  let minY = Number.MAX_SAFE_INTEGER;
  let maxX = Number.MIN_SAFE_INTEGER;
  let maxY = Number.MIN_SAFE_INTEGER;
  const xList = [];
  const yList = [];
  items.forEach((item2) => {
    item2.originVerties.forEach((vector) => {
      xList.push(vector[0]);
      yList.push(vector[1]);
    });
  });
  minX = Math.min.apply(Math, xList);
  maxX = Math.max.apply(Math, xList);
  minY = Math.min.apply(Math, yList);
  maxY = Math.max.apply(Math, yList);
  if (minX === Number.MAX_SAFE_INTEGER)
    minX = 0;
  if (minY === Number.MAX_SAFE_INTEGER)
    minY = 0;
  if (maxX === Number.MIN_SAFE_INTEGER)
    maxX = 0;
  if (maxY === Number.MIN_SAFE_INTEGER)
    maxY = 0;
  return rectToVerties(minX, minY, maxX - minX, maxY - minY);
}
function targetItemsToRectVerties(items = []) {
  let minX = Number.MAX_SAFE_INTEGER;
  let minY = Number.MAX_SAFE_INTEGER;
  let maxX = Number.MIN_SAFE_INTEGER;
  let maxY = Number.MIN_SAFE_INTEGER;
  const xList = [];
  const yList = [];
  items.forEach((item2) => {
    item2.targetVerties.forEach((vector) => {
      xList.push(vector[0]);
      yList.push(vector[1]);
    });
  });
  minX = Math.min.apply(Math, xList);
  maxX = Math.max.apply(Math, xList);
  minY = Math.min.apply(Math, yList);
  maxY = Math.max.apply(Math, yList);
  if (minX === Number.MAX_SAFE_INTEGER)
    minX = 0;
  if (minY === Number.MAX_SAFE_INTEGER)
    minY = 0;
  if (maxX === Number.MIN_SAFE_INTEGER)
    maxX = 0;
  if (maxY === Number.MIN_SAFE_INTEGER)
    maxY = 0;
  return rectToVerties(minX, minY, maxX - minX, maxY - minY);
}
function vertiesToRectangle(verties) {
  const x2 = verties[0][0];
  const y2 = verties[0][1];
  const width2 = dist(verties[0], verties[1]);
  const height2 = dist(verties[0], verties[3]);
  return { x: x2, left: x2, y: y2, top: y2, width: width2, height: height2 };
}
function toRectVertiesWithoutTransformOrigin(verties) {
  return toRectVerties(verties).filter((it, index2) => {
    return index2 < 4;
  });
}
function toRectVerties(verties) {
  let minX = Number.MAX_SAFE_INTEGER;
  let minY = Number.MAX_SAFE_INTEGER;
  let maxX = Number.MIN_SAFE_INTEGER;
  let maxY = Number.MIN_SAFE_INTEGER;
  const xList = [];
  const yList = [];
  verties.forEach((vector) => {
    xList.push(vector[0]);
    yList.push(vector[1]);
  });
  minX = Math.min.apply(Math, xList);
  maxX = Math.max.apply(Math, xList);
  minY = Math.min.apply(Math, yList);
  maxY = Math.max.apply(Math, yList);
  if (minX === Number.MAX_SAFE_INTEGER)
    minX = 0;
  if (minY === Number.MAX_SAFE_INTEGER)
    minY = 0;
  if (maxX === Number.MIN_SAFE_INTEGER)
    maxX = 0;
  if (maxY === Number.MIN_SAFE_INTEGER)
    maxY = 0;
  return rectToVerties(minX, minY, maxX - minX, maxY - minY);
}
function second(fps, timecode2) {
  if (isString(timecode2)) {
    var [hour, minute, second2, frame] = timecode2.split(":");
    hour = parseInt(hour, 10);
    minute = parseInt(minute, 10);
    second2 = parseInt(second2, 10);
    frame = parseInt(frame, 10);
    return hour * 3600 + minute * 60 + second2 + frame * (1 / fps);
  } else if (isNumber(timecode2)) {
    return timecode2 / fps;
  }
  return 0;
}
function timecode(fps, seconds) {
  var h = Math.floor(seconds / 3600);
  var m = Math.floor(seconds / 60 % 60);
  var s = Math.floor(seconds % 60);
  var f = Math.round((seconds - Math.floor(seconds)) * fps);
  if (f === fps) {
    f = 0;
    s += 1;
    if (s === 60) {
      m += 1;
      if (m === 60) {
        h += 1;
      }
    }
  }
  return [h, m, s, f].map((t) => {
    return (t + "").padStart(2, "0");
  }).join(":");
}
function framesToTimecode(fps, frames, start2 = null) {
  return timecode(fps, second(fps, frames) - second(fps, start2));
}
function makeTimer(opt) {
  var timer2 = {
    id: 0,
    start: 0,
    speed: opt.speed || 1,
    elapsed: opt.elapsed || 0,
    duration: opt.duration || 0,
    iterationStartCount: 1,
    iterationCount: opt.iterationCount || Number.MAX_SAFE_INTEGER,
    direction: opt.direction || "normal",
    log: [],
    logIndex: 0,
    tick: opt.tick || (() => {
    }),
    startCallback: opt.start || (() => {
    }),
    endCallback: opt.end || (() => {
    }),
    firstCallback: opt.first || (() => {
    }),
    lastCallback: opt.last || (() => {
    })
  };
  const isForward = () => {
    if (timer2.direction === "normal") {
      return true;
    } else if (timer2.direction === "reverse") {
      return false;
    } else if (timer2.direction === "alternate") {
      return timer2.iterationStartCount % 2 === 1;
    } else if (timer2.direction === "alternate-reverse") {
      return timer2.iterationStartCount % 2 === 0;
    }
  };
  const calculateForDirection = (rate) => {
    return isForward() ? rate : 1 - rate;
  };
  const tick = (now) => {
    var isStart = false;
    if (timer2.start === null) {
      timer2.start = now;
      isStart = true;
    }
    const dt = now - timer2.start;
    timer2.elapsed += dt * timer2.speed;
    timer2.start = now;
    if (timer2.elapsed > timer2.duration) {
      timer2.elapsed = timer2.duration;
    }
    var elapsed = calculateForDirection(timer2.elapsed / timer2.duration) * timer2.duration;
    if (isStart)
      timer2.startCallback(elapsed, timer2);
    timer2.log[timer2.logIndex++] = { elapsed, dt: timer2.lastTime - elapsed };
    timer2.lastTime = elapsed;
    timer2.tick(elapsed, timer2);
    if (timer2.elapsed === timer2.duration) {
      end2();
    } else {
      frameStart();
    }
  };
  const frameStart = () => {
    timer2.id = requestAnimationFrame(tick);
  };
  const end2 = () => {
    timer2.endCallback(timer2.elapsed, timer2);
    timer2.iterationStartCount++;
    if (timer2.iterationStartCount > timer2.iterationCount) {
      timer2.lastCallback(timer2.elapsed, timer2);
      cancelAnimationFrame(timer2.id);
    } else {
      timer2.start = null;
      timer2.elapsed = 0;
      frameStart();
    }
  };
  const play2 = (opt2 = {}) => {
    timer2.start = null;
    timer2.iterationStartCount = 1;
    timer2.log = [];
    timer2.lastTime = 0;
    timer2.logIndex = 0;
    if (isNumber(opt2.elapsed))
      timer2.elapsed = opt2.elapsed;
    if (isNumber(opt2.speed))
      timer2.speed = opt2.speed;
    if (isNumber(opt2.duration))
      timer2.duration = opt2.duration;
    if (isNumber(opt2.iterationCount))
      timer2.iterationCount = opt2.iterationCount || Number.MAX_SAFE_INTEGER;
    if (isString(opt2.direction))
      timer2.direction = opt2.direction;
    if (isFunction(opt2.tick))
      timer2.tick = opt2.tick;
    if (isFunction(opt2.start))
      timer2.startCallback = opt2.start;
    if (isFunction(opt2.end))
      timer2.endCallback = opt2.end;
    if (isFunction(opt2.first))
      timer2.firstCallback = opt2.first;
    if (isFunction(opt2.last))
      timer2.lastCallback = opt2.last;
    if (isFunction(opt2.stop))
      timer2.stopCallback = opt2.stop;
    timer2.firstCallback(timer2.elapsed, timer2);
    frameStart();
  };
  const stop = () => {
    timer2.stopCallback(timer2.elapsed, timer2);
    cancelAnimationFrame(timer2.id);
  };
  const seek = (t) => {
    timer2.elapsed = t;
    timer2.tick(timer2.elapsed, timer2);
  };
  const first = (t) => {
    seek(0);
  };
  const last2 = (t) => {
    seek(timer2.duration);
  };
  return {
    play: play2,
    stop,
    tick,
    first,
    last: last2,
    seek,
    timer: timer2
  };
}
const predefinedBezier = {
  "linear": true,
  "ease": true,
  "ease-in": true,
  "ease-out": true,
  "ease-in-out": true
};
const bezierObj = {
  "ease": "cubic-bezier(0.25, 0.1, 0.25, 1)",
  "ease-in": "cubic-bezier(0.42, 0, 1, 1)",
  "ease-out": "cubic-bezier(0, 0, 0.58, 1)"
};
const bezierList = [
  [0, 0, 1, 1, "linear", true],
  [0.25, 0.1, 0.25, 1, "ease", true],
  [0.42, 0, 1, 1, "ease-in", true],
  [0, 0, 0.58, 1, "ease-out", true],
  [0.47, 0, 0.745, 0.715, "ease-in-sine"],
  [0.39, 0.575, 0.565, 1, "ease-out-sine"],
  [0.445, 0.05, 0.55, 0.95, "ease-in-out-sine"],
  [0.55, 0.085, 0.68, 0.53, "ease-in-quad"],
  [0.25, 0.46, 0.45, 0.94, "ease-out-quad"],
  [0.455, 0.03, 0.515, 0.955, "ease-in-out-quad"],
  [0.55, 0.055, 0.675, 0.19, "ease-in-cubic"],
  [0.215, 0.61, 0.355, 1, "ease-out-cubic"],
  [0.645, 0.045, 0.355, 1, "ease-in-out-cubic"],
  [0.895, 0.03, 0.685, 0.22, "ease-in-quart"],
  [0.165, 0.84, 0.44, 1, "ease-out-quart"],
  [0.77, 0, 0.175, 1, "ease-in-out-quart"],
  [0.6, 0.04, 0.98, 0.335, "ease-in-circ"],
  [0.075, 0.82, 0.165, 1, "ease-out-circ"],
  [0.785, 0.135, 0.15, 0.86, "ease-in-out-circ"],
  [0.95, 0.05, 0.795, 0.035, "ease-in-expo"],
  [0.19, 1, 0.22, 1, "ease-out-expo"],
  [1, 0, 0, 1, "ease-in-out-expo"],
  [0.755, 0.05, 0.855, 0.06, "ease-in-quint"],
  [0.23, 1, 0.32, 1, "ease-out-quint"],
  [0.86, 0, 0.07, 1, "ease-in-out-quint"],
  [0.6, -0.28, 0.735, 0.045, "ease-in-back"],
  [0.175, 0.885, 0.32, 1.275, "ease-out-back"],
  [0.68, -0.55, 0.265, 1.55, "ease-in-out-back"]
];
const getPredefinedCubicBezier = (str) => {
  return [...parseCubicBezier(bezierObj[str] || str)];
};
const formatCubicBezier = (arr) => {
  arr = arr.map((it) => Math.floor(it * 100) / 100);
  for (var i = 0, len2 = bezierList.length; i < len2; i++) {
    var bezier = bezierList[i];
    if (bezier[0] == arr[0] && bezier[1] == arr[1] && bezier[2] == arr[2] && bezier[3] == arr[3] && bezier[5]) {
      return bezier[4];
    }
  }
  return `cubic-bezier( ${arr.filter((_, index2) => index2 < 4).join(",")} )`;
};
const parseCubicBezier = (str) => {
  if (typeof str == "string") {
    if (predefinedBezier[str]) {
      return bezierList.filter((it) => it[4] === str)[0];
    } else {
      var arr = str.replace("cubic-bezier", "").replace("(", "").replace(")", "").split(",");
      arr = arr.map((it) => parseFloat(it.trim()));
      return arr;
    }
  }
  return str;
};
const createBezier = (C1, C2, C3, C4) => {
  var points2 = [C1, C2, C3, C4];
  return function(t) {
    return getBezierPointOne(points2, t);
  };
};
const createBezierQuard = (C1, C2, C3) => {
  var points2 = [C1, C2, C3];
  return function(t) {
    return getBezierPointOneQuard(points2, t);
  };
};
const createBezierLine = (C1, C2) => {
  var points2 = [C1, C2];
  return function(t) {
    return getBezierPointOneLine(points2, t);
  };
};
const checkDist = (obj2, curve, t, x2, y2) => {
  var p = curve(t);
  var dist2 = getDist(x2, y2, p.x, p.y);
  if (dist2 < obj2.minDist) {
    obj2.minDist = dist2;
    obj2.minT = t;
  }
};
const getPolygonalDist = (points2 = []) => {
  let total = 0;
  points2.length;
  points2.forEach((point2, index2) => {
    var next = points2[index2 + 1];
    if (!next) {
      return;
    }
    var dist$1 = dist(fromValues(point2.x, point2.y, 0), fromValues(next.x, next.y, 0));
    total += dist$1;
  });
  return total;
};
const getCurveDist = (sx, sy, cx1, cy1, cx2, cy2, ex, ey, count = 1e3) => {
  var curve = createBezier({ x: sx, y: sy }, { x: cx1, y: cy1 }, { x: cx2, y: cy2 }, { x: ex, y: ey });
  var total = 0;
  var startPoint = curve(0);
  for (var i = 0; i <= count; i++) {
    var t = i / count;
    var xy2 = curve(t);
    total += getDist(startPoint.x, startPoint.y, xy2.x, xy2.y);
    startPoint = xy2;
  }
  return total;
};
const getQuardDist = (sx, sy, cx1, cy1, ex, ey, count = 1e3) => {
  var curve = createBezierQuard({ x: sx, y: sy }, { x: cx1, y: cy1 }, { x: ex, y: ey });
  var total = 0;
  var startPoint = curve(0);
  for (var i = 0; i <= count; i++) {
    var t = i / count;
    var xy2 = curve(t);
    total += getDist(startPoint.x, startPoint.y, xy2.x, xy2.y);
    startPoint = xy2;
  }
  return total;
};
const makeCurveFunction = (curve, count = 10) => {
  var obj2 = {
    minDist: Infinity,
    minT: 0
  };
  return function(x2, y2) {
    for (var i = 0; i <= count; i++) {
      checkDist(obj2, curve, i / count, x2, y2);
    }
    var step2 = 1 / (count * 2);
    var t = obj2.minT;
    for (var i = 0; i < count; i++) {
      checkDist(obj2, curve, Math.max(0, t - step2), x2, y2);
      checkDist(obj2, curve, Math.min(1, t + step2), x2, y2);
      step2 /= 2;
    }
    return obj2.minT;
  };
};
const recoverBezier = (C1, C2, C3, C4, count = 20) => {
  return makeCurveFunction(createBezier(C1, C2, C3, C4), count);
};
const recoverBezierQuard = (C1, C2, C3, count = 20) => {
  return makeCurveFunction(createBezierQuard(C1, C2, C3), count);
};
const recoverBezierLine = (C1, C2, count = 20) => {
  return makeCurveFunction(createBezierLine(C1, C2), count);
};
const createBezierForPattern = (bezierString) => {
  if (bezierString === "linear") {
    var C1 = { x: 0, y: 0 };
    var C2 = { x: 1, y: 1 };
    return createBezierLine(C1, C2);
  }
  var bezierList2 = parseCubicBezier(bezierString);
  var C1 = { x: 0, y: 0 };
  var C2 = { x: bezierList2[0], y: bezierList2[1] };
  var C3 = { x: bezierList2[2], y: bezierList2[3] };
  var C4 = { x: 1, y: 1 };
  return createBezier(C1, C2, C3, C4);
};
const interpolate = (p1, p2, t) => {
  return {
    x: p1.x + (p2.x - p1.x) * t,
    y: p1.y + (p2.y - p1.y) * t
  };
};
const getBezierPointOne = (points2, t) => {
  var p0 = interpolate(points2[0], points2[1], t);
  var p1 = interpolate(points2[1], points2[2], t);
  var p2 = interpolate(points2[2], points2[3], t);
  var p3 = interpolate(p0, p1, t);
  var p4 = interpolate(p1, p2, t);
  return interpolate(p3, p4, t);
};
const getBezierPointOneQuard = (points2, t) => {
  var p0 = interpolate(points2[0], points2[1], t);
  var p1 = interpolate(points2[1], points2[2], t);
  return interpolate(p0, p1, t);
};
const getBezierPointOneLine = (points2, t) => {
  return interpolate(points2[0], points2[1], t);
};
const getBezierPoints = (points2, t) => {
  var p0 = interpolate(points2[0], points2[1], t);
  var p1 = interpolate(points2[1], points2[2], t);
  var p2 = interpolate(points2[2], points2[3], t);
  var p3 = interpolate(p0, p1, t);
  var p4 = interpolate(p1, p2, t);
  var p5 = interpolate(p3, p4, t);
  return {
    first: [points2[0], p0, p3, p5],
    second: [p5, p4, p2, points2[3]]
  };
};
const getBezierPointsQuard = (points2, t) => {
  var p0 = interpolate(points2[0], points2[1], t);
  var p1 = interpolate(points2[1], points2[2], t);
  var p2 = interpolate(p0, p1, t);
  return {
    first: [points2[0], p0, p2],
    second: [p2, p1, points2[2]]
  };
};
const splitBezierPointsByCount = (points2, count = 1) => {
  var result = [];
  while (count > 0) {
    const curve = getBezierPoints(points2, 1 / count);
    result.push(curve.first);
    points2 = curve.second;
    count--;
  }
  return result;
};
const splitBezierPointsQuardByCount = (points2, count = 1) => {
  var result = [];
  while (count > 0) {
    const curve = getBezierPointsQuard(points2, 1 / count);
    result.push(curve.first);
    points2 = curve.second;
    count--;
  }
  return result;
};
const splitBezierPointsLineByCount = (points2, count = 1) => {
  var result = [];
  const unit = 1 / count;
  while (count > 0) {
    const curve = getBezierPointsLine(points2, unit);
    result.push(curve.first);
    points2 = curve.second;
    count--;
  }
  return result;
};
const getBezierPointsLine = (points2, t) => {
  var p0 = interpolate(points2[0], points2[1], t);
  return {
    first: [points2[0], p0],
    second: [p0, points2[1]]
  };
};
const normalizeCurveForLine = (points2) => {
  return [
    clone(points2[0]),
    [
      points2[0][0] + (points2[1][0] - points2[0][0]) * 0.33,
      points2[0][1] + (points2[1][1] - points2[0][1]) * 0.33,
      0
    ],
    [
      points2[0][0] + (points2[1][0] - points2[0][0]) * 0.66,
      points2[0][1] + (points2[1][1] - points2[0][1]) * 0.66,
      0
    ],
    clone(points2[1])
  ];
};
const normalizeCurveForQuard = (points2) => {
  const twoOfThree = 2 / 3;
  return [
    clone(points2[0]),
    fromValues(points2[0][0] + twoOfThree * (points2[1][0] - points2[0][0]), points2[0][1] + twoOfThree * (points2[1][1] - points2[0][1]), 0),
    fromValues(points2[2][0] + twoOfThree * (points2[1][0] - points2[2][0]), points2[2][1] + twoOfThree * (points2[1][1] - points2[2][1]), 0),
    clone(points2[2])
  ];
};
const polygonalForCurve = (c1, c2, c3, c4, count = 1e3) => {
  const totalLength = getCurveDist(c1[0], c1[1], c2[0], c2[1], c3[0], c3[1], c4[0], c4[1], count);
  let samplingCount = 10;
  let samplingStep = totalLength / samplingCount;
  let lastLength = 0;
  let points2 = [];
  const bezierPoints = [c1, c2, c3, c4].map((point2) => ({ x: point2[0], y: point2[1] }));
  do {
    points2 = [];
    let currentLength = 0;
    for (let i = 0; i <= samplingCount; i++) {
      const nextPoint = getBezierPointOne(bezierPoints, currentLength / totalLength);
      points2.push(nextPoint);
      currentLength += samplingStep;
    }
    lastLength = getPolygonalDist(points2);
    samplingCount += samplingCount * (totalLength - lastLength) / totalLength;
    samplingStep = totalLength / samplingCount;
  } while (totalLength - lastLength > 0.25);
  return points2.map((point2) => fromValues(point2.x, point2.y, 0));
};
const calculateA = (points2) => {
  const a1 = negate([], points2[0]);
  const a2 = multiply([], [3, 3, 3], points2[1]);
  const a3 = multiply([], [-3, -3, -3], points2[2]);
  const a4 = points2[3];
  const newP = add$1([], add$1([], a1, a2), add$1([], a3, a4));
  return multiply([], [3, 3, 3], newP);
};
const calculateB = (points2) => {
  const b1 = points2[0];
  const b2 = multiply([], [-2, -2, -2], points2[1]);
  const b3 = points2[2];
  const newP = add$1([], add$1([], b1, b2), b3);
  return multiply([], [6, 6, 6], newP);
};
const calculateC = (points2) => {
  const newP = add$1([], points2[1], negate([], points2[0]));
  return multiply([], [3, 3, 3], newP);
};
const findRootForCurve = (points2) => {
  const a = calculateA(points2);
  const b = calculateB(points2);
  const c2 = calculateC(points2);
  const roots = [];
  const distX = b[0] * b[0] - 4 * a[0] * c2[0];
  if (distX < 0)
    ;
  else if (distX === 0) {
    let rootX = -b[0] / (2 * a[0]);
    if (isNaN(rootX))
      rootX = 0;
    if (0 <= rootX && rootX <= 1) {
      roots.push(rootX);
    }
  } else if (distX > 0) {
    const rootX1 = (-b[0] + Math.sqrt(distX)) / (2 * a[0]);
    const rootX2 = (-b[0] - Math.sqrt(distX)) / (2 * a[0]);
    if (0 <= rootX1 && rootX1 <= 1) {
      roots.push(rootX1);
    }
    if (0 <= rootX2 && rootX2 <= 1) {
      roots.push(rootX2);
    }
  }
  const distY = b[1] * b[1] - 4 * a[1] * c2[1];
  if (distY < 0)
    ;
  else if (distY === 0) {
    let rootY = -b[1] / (2 * a[1]);
    if (isNaN(rootY))
      rootY = 0;
    if (0 <= rootY && rootY <= 1) {
      roots.push(rootY);
    }
  } else if (distY > 0) {
    const rootY1 = (-b[1] + Math.sqrt(distY)) / (2 * a[1]);
    const rootY2 = (-b[1] - Math.sqrt(distY)) / (2 * a[1]);
    if (0 <= rootY1 && rootY1 <= 1) {
      roots.push(rootY1);
    }
    if (0 <= rootY2 && rootY2 <= 1) {
      roots.push(rootY2);
    }
  }
  return roots;
};
const getCurveBBox = (points2) => {
  const roots = findRootForCurve(points2);
  const xyPoints = points2.map((p) => {
    return { x: p[0], y: p[1] };
  });
  roots.push(0, 1);
  return roots.map((t) => {
    const { x: x2, y: y2 } = getBezierPointOne(xyPoints, t);
    return [x2, y2, 0];
  });
};
function makeInterpolateNumber$1(layer2, property, startNumber, endNumber, unit = void 0) {
  return (rate, t) => {
    var result = 0;
    if (t === 0) {
      result = startNumber;
    } else if (t === 1) {
      result = endNumber;
    } else {
      result = startNumber + (endNumber - startNumber) * rate;
    }
    if (unit) {
      return result + unit;
    }
    return result;
  };
}
function makeInterpolateIdentity(layer2, property, value) {
  return (ratio, t) => {
    return value;
  };
}
function getRealAttributeValue(layer2, property, value, refType = "width", refElement = "parent") {
  var refObject = null;
  if (refElement === "parent") {
    refObject = layer2[refElement][refType];
  } else if (refElement === "self") {
    refObject = layer2[refType];
  }
  if (refObject) {
    return value.toPx(refObject.value);
  }
  return value;
}
function rollbackRealAttributeValue(layer2, property, value, unit, refType = "width", refElement = "parent") {
  var refObject = null;
  if (refElement === "parent") {
    refObject = layer2[refElement][refType];
  } else if (refElement === "self") {
    refObject = layer2[refType];
  }
  if (refObject) {
    return value.to(unit, refObject.value);
  }
  return value;
}
function makeInterpolateLength(layer2, property, startNumber, endNumber, refType = "width", refElement = "parent") {
  var s = Length.parse(startNumber);
  var e2 = Length.parse(endNumber);
  if (s.unit === e2.unit) {
    return makeInterpolateNumber$1(layer2, property, s.value, e2.value, s.unit);
  } else if (s.equals(e2)) {
    return makeInterpolateIdentity(layer2, property, s);
  }
  return (rate, t) => {
    var realStartValue = getRealAttributeValue(layer2, property, s, refType, refElement);
    var realEndValue = getRealAttributeValue(layer2, property, e2, refType, refElement);
    if (t === 0) {
      return realStartValue;
    } else if (t === 1) {
      return realEndValue;
    }
    return rollbackRealAttributeValue(layer2, property, realStartValue.value + (realEndValue.value - realStartValue.value) * rate, s.unit, refType, refElement);
  };
}
class BorderRadius {
  static parseStyle(str = "") {
    var obj2 = {
      isAll: true,
      "border-radius": 0,
      "border-top-left-radius": 0,
      "border-top-right-radius": 0,
      "border-bottom-right-radius": 0,
      "border-bottom-left-radius": 0
    };
    var arr = str.split(" ").filter((it) => Length.parse(it));
    if (arr.length === 1) {
      obj2.isAll = true;
      obj2["border-radius"] = arr[0];
    } else {
      obj2.isAll = false;
      obj2["border-top-left-radius"] = arr[0];
      obj2["border-top-right-radius"] = arr[1];
      obj2["border-bottom-right-radius"] = arr[2];
      obj2["border-bottom-left-radius"] = arr[3];
    }
    return obj2;
  }
}
const getBorderRadiusList = (radiusValue) => {
  var startObject = [];
  if (radiusValue.isAll) {
    startObject = [
      radiusValue["border-radius"] || "0px",
      radiusValue["border-radius"] || "0px",
      radiusValue["border-radius"] || "0px",
      radiusValue["border-radius"] || "0px"
    ];
  } else {
    startObject = [
      radiusValue["border-top-left-radius"] || "0px",
      radiusValue["border-top-right-radius"] || "0px",
      radiusValue["border-bottom-right-radius"] || "0px",
      radiusValue["border-bottom-left-radius"] || "0px"
    ];
  }
  return startObject;
};
function makeInterpolateBorderRadius(layer2, property, startValue, endValue) {
  var s = getBorderRadiusList(BorderRadius.parseStyle(startValue));
  var e2 = getBorderRadiusList(BorderRadius.parseStyle(endValue));
  var max = Math.max(s.length, e2.length);
  var list2 = [];
  for (var i = 0; i < max; i++) {
    list2[i] = makeInterpolateLength(layer2, property, s[i], e2[i]);
  }
  return (rate, t) => {
    return list2.map((it) => it(rate, t)).join(" ");
  };
}
function format(obj2, type, defaultColor = "rgba(0, 0, 0, 0)") {
  if (Array.isArray(obj2)) {
    obj2 = { r: obj2[0], g: obj2[1], b: obj2[2], a: obj2[3] };
  }
  if (type == "hex") {
    return hex(obj2);
  } else if (type == "rgb") {
    return rgb(obj2, defaultColor);
  } else if (type == "hsl") {
    return hsl(obj2);
  }
  return obj2;
}
function formatWithoutAlpha(obj2, type, defaultColor = "rgba(0, 0, 0, 0)") {
  const newColorObj = clone$1(obj2);
  newColorObj.a = 1;
  return format(newColorObj, type, defaultColor);
}
function hex(obj2) {
  if (Array.isArray(obj2)) {
    obj2 = { r: obj2[0], g: obj2[1], b: obj2[2], a: obj2[3] };
  }
  var r = obj2.r.toString(16);
  if (obj2.r < 16)
    r = "0" + r;
  var g = obj2.g.toString(16);
  if (obj2.g < 16)
    g = "0" + g;
  var b = obj2.b.toString(16);
  if (obj2.b < 16)
    b = "0" + b;
  if (obj2.a == 1 || typeof obj2.a === "undefined") {
    return `#${r}${g}${b}`;
  } else {
    const alpha2 = Math.ceil(obj2.a * 255);
    var a = alpha2.toString(16);
    if (alpha2 < 16)
      a = "0" + a;
    return `#${r}${g}${b}${a}`;
  }
}
function rgb(obj2, defaultColor = "rgba(0, 0, 0, 0)") {
  if (Array.isArray(obj2)) {
    obj2 = { r: obj2[0], g: obj2[1], b: obj2[2], a: obj2[3] };
  }
  if (typeof obj2 === "undefined") {
    return void 0;
  }
  if (obj2.a == 1 || typeof obj2.a === "undefined") {
    if (isNaN(obj2.r)) {
      return defaultColor;
    }
    return `rgb(${obj2.r},${obj2.g},${obj2.b})`;
  } else {
    return `rgba(${obj2.r},${obj2.g},${obj2.b},${obj2.a})`;
  }
}
function hsl(obj2) {
  if (Array.isArray(obj2)) {
    obj2 = { r: obj2[0], g: obj2[1], b: obj2[2], a: obj2[3] };
  }
  if (obj2.a == 1 || typeof obj2.a === "undefined") {
    return `hsl(${obj2.h},${obj2.s}%,${obj2.l}%)`;
  } else {
    return `hsla(${obj2.h},${obj2.s}%,${obj2.l}%,${obj2.a})`;
  }
}
var formatter = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  format,
  formatWithoutAlpha,
  hex,
  rgb,
  hsl
});
function randomNumber(min, max) {
  return Math.floor(Math.random() * (max - min + 1)) + min;
}
function randomByCount(count = 1) {
  let arr = [];
  for (var i = 0; i < count; i++) {
    arr[arr.length] = random$1();
  }
  return arr;
}
function random$1() {
  return rgb({
    r: randomNumber(0, 255),
    g: randomNumber(0, 255),
    b: randomNumber(0, 255)
  });
}
function randomRGBA() {
  return rgb({
    r: randomNumber(0, 255),
    g: randomNumber(0, 255),
    b: randomNumber(0, 255),
    a: randomNumber(0, 1e3) / 1e3
  });
}
var create = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  randomNumber,
  randomByCount,
  random: random$1,
  randomRGBA
});
function randomItem(...args2) {
  return args2[randomNumber(0, args2.length - 1)];
}
function repeat$1(count) {
  return [...Array(count)];
}
function CSS_TO_STRING$1(style, postfix = "") {
  var newStyle = style || {};
  return Object.keys(newStyle).filter((key) => isNotUndefined(newStyle[key])).map((key) => `${key}: ${newStyle[key]}`).join(";" + postfix);
}
function STRING_TO_CSS(str = "", splitChar = ";", keySplitChar = ":") {
  str = str + "";
  var style = {};
  if (str === "")
    return style;
  str.split(splitChar).forEach((it) => {
    var [key, ...value] = it.split(keySplitChar).map((it2) => it2.trim());
    if (key != "") {
      style[key] = value.join(keySplitChar);
    }
  });
  return style;
}
function OBJECT_TO_PROPERTY$1(obj2) {
  const target = obj2 || {};
  return Object.keys(target).map((key) => {
    if (key === "class") {
      if (isObject(obj2[key])) {
        return `${key}="${OBJECT_TO_CLASS$1(obj2[key])}"`;
      }
    }
    if (key === "style") {
      if (isObject(obj2[key])) {
        return `${key}="${CSS_TO_STRING$1(obj2[key])}"`;
      }
    }
    if (isBoolean(obj2[key]) || isUndefined(obj2[key]) || obj2[key] === "undefined") {
      if (obj2[key]) {
        return key;
      } else {
        return "";
      }
    }
    return `${key}="${obj2[key]}"`;
  }).join(" ");
}
function OBJECT_TO_CLASS$1(obj2) {
  return Object.keys(obj2).filter((k) => obj2[k]).map((key) => {
    return key;
  }).join(" ");
}
function TAG_TO_STRING(str) {
  return str.replace(/\</g, "&lt;").replace(/\>/g, "&gt;");
}
function mapjoin(arr, callback, joinString = "") {
  return arr.map(callback).join(joinString);
}
function isArrayEquals$1(A, B) {
  const s = new Set([...A, ...B]);
  return s.size === A.length && s.size === B.length;
}
const curveToPath = (timingFunction, width2 = 30, height2 = 30) => {
  const currentBezier = getPredefinedCubicBezier(timingFunction);
  return `
        M0 ${width2} 
        C 
        ${currentBezier[0] * width2} ${currentBezier[1] == 0 ? height2 : (1 - currentBezier[1]) * height2},
        ${currentBezier[2] * width2} ${currentBezier[3] == 1 ? 0 : (1 - currentBezier[3]) * height2},
        ${width2} 0
    `;
};
const curveToPointLine = (timingFunction, width2 = 30, height2 = 30) => {
  const currentBezier = getPredefinedCubicBezier(timingFunction);
  return `
        M 0 ${width2} 
        L ${currentBezier[0] * width2} ${currentBezier[1] == 0 ? height2 : (1 - currentBezier[1]) * height2}
        M ${width2} 0
        L ${currentBezier[2] * width2} ${currentBezier[3] == 1 ? 0 : (1 - currentBezier[3]) * height2}
    `;
};
const valueFunctionIdentity = (v) => v;
const valueMap = (obj2, valueFunction = valueFunctionIdentity) => {
  const newObj = clone$1(obj2);
  Object.keys(newObj).forEach((key) => {
    newObj[key] = valueFunction(newObj[key]);
  });
  return newObj;
};
const objectFloor = (obj2) => valueMap(obj2, Math.floor);
const objectCeil = (obj2) => valueMap(obj2, Math.ceil);
const objectRound = (obj2) => valueMap(obj2, Math.round);
const objectRoundTo = (obj2, to) => valueMap(obj2, (v) => Math.round(v / to) * to);
var func = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  randomItem,
  repeat: repeat$1,
  CSS_TO_STRING: CSS_TO_STRING$1,
  STRING_TO_CSS,
  OBJECT_TO_PROPERTY: OBJECT_TO_PROPERTY$1,
  OBJECT_TO_CLASS: OBJECT_TO_CLASS$1,
  TAG_TO_STRING,
  mapjoin,
  isArrayEquals: isArrayEquals$1,
  curveToPath,
  curveToPointLine,
  valueMap,
  objectFloor,
  objectCeil,
  objectRound,
  objectRoundTo
});
class PropertyItem extends Item {
  getDefaultObject(obj2 = {}) {
    return __spreadValues({
      selected: false,
      layers: []
    }, obj2);
  }
  isAttribute() {
    return true;
  }
  toCSS() {
    return {};
  }
  toString() {
    return CSS_TO_STRING$1(this.toCSS());
  }
}
const color_names = { aliceblue: "rgb(240, 248, 255)", antiquewhite: "rgb(250, 235, 215)", aqua: "rgb(0, 255, 255)", aquamarine: "rgb(127, 255, 212)", azure: "rgb(240, 255, 255)", beige: "rgb(245, 245, 220)", bisque: "rgb(255, 228, 196)", black: "rgb(0, 0, 0)", blanchedalmond: "rgb(255, 235, 205)", blue: "rgb(0, 0, 255)", blueviolet: "rgb(138, 43, 226)", brown: "rgb(165, 42, 42)", burlywood: "rgb(222, 184, 135)", cadetblue: "rgb(95, 158, 160)", chartreuse: "rgb(127, 255, 0)", chocolate: "rgb(210, 105, 30)", coral: "rgb(255, 127, 80)", cornflowerblue: "rgb(100, 149, 237)", cornsilk: "rgb(255, 248, 220)", crimson: "rgb(237, 20, 61)", cyan: "rgb(0, 255, 255)", darkblue: "rgb(0, 0, 139)", darkcyan: "rgb(0, 139, 139)", darkgoldenrod: "rgb(184, 134, 11)", darkgray: "rgb(169, 169, 169)", darkgrey: "rgb(169, 169, 169)", darkgreen: "rgb(0, 100, 0)", darkkhaki: "rgb(189, 183, 107)", darkmagenta: "rgb(139, 0, 139)", darkolivegreen: "rgb(85, 107, 47)", darkorange: "rgb(255, 140, 0)", darkorchid: "rgb(153, 50, 204)", darkred: "rgb(139, 0, 0)", darksalmon: "rgb(233, 150, 122)", darkseagreen: "rgb(143, 188, 143)", darkslateblue: "rgb(72, 61, 139)", darkslategray: "rgb(47, 79, 79)", darkslategrey: "rgb(47, 79, 79)", darkturquoise: "rgb(0, 206, 209)", darkviolet: "rgb(148, 0, 211)", deeppink: "rgb(255, 20, 147)", deepskyblue: "rgb(0, 191, 255)", dimgray: "rgb(105, 105, 105)", dimgrey: "rgb(105, 105, 105)", dodgerblue: "rgb(30, 144, 255)", firebrick: "rgb(178, 34, 34)", floralwhite: "rgb(255, 250, 240)", forestgreen: "rgb(34, 139, 34)", fuchsia: "rgb(255, 0, 255)", gainsboro: "rgb(220, 220, 220)", ghostwhite: "rgb(248, 248, 255)", gold: "rgb(255, 215, 0)", goldenrod: "rgb(218, 165, 32)", gray: "rgb(128, 128, 128)", grey: "rgb(128, 128, 128)", green: "rgb(0, 128, 0)", greenyellow: "rgb(173, 255, 47)", honeydew: "rgb(240, 255, 240)", hotpink: "rgb(255, 105, 180)", indianred: "rgb(205, 92, 92)", indigo: "rgb(75, 0, 130)", ivory: "rgb(255, 255, 240)", khaki: "rgb(240, 230, 140)", lavender: "rgb(230, 230, 250)", lavenderblush: "rgb(255, 240, 245)", lawngreen: "rgb(124, 252, 0)", lemonchiffon: "rgb(255, 250, 205)", lightblue: "rgb(173, 216, 230)", lightcoral: "rgb(240, 128, 128)", lightcyan: "rgb(224, 255, 255)", lightgoldenrodyellow: "rgb(250, 250, 210)", lightgreen: "rgb(144, 238, 144)", lightgray: "rgb(211, 211, 211)", lightgrey: "rgb(211, 211, 211)", lightpink: "rgb(255, 182, 193)", lightsalmon: "rgb(255, 160, 122)", lightseagreen: "rgb(32, 178, 170)", lightskyblue: "rgb(135, 206, 250)", lightslategray: "rgb(119, 136, 153)", lightslategrey: "rgb(119, 136, 153)", lightsteelblue: "rgb(176, 196, 222)", lightyellow: "rgb(255, 255, 224)", lime: "rgb(0, 255, 0)", limegreen: "rgb(50, 205, 50)", linen: "rgb(250, 240, 230)", magenta: "rgb(255, 0, 255)", maroon: "rgb(128, 0, 0)", mediumaquamarine: "rgb(102, 205, 170)", mediumblue: "rgb(0, 0, 205)", mediumorchid: "rgb(186, 85, 211)", mediumpurple: "rgb(147, 112, 219)", mediumseagreen: "rgb(60, 179, 113)", mediumslateblue: "rgb(123, 104, 238)", mediumspringgreen: "rgb(0, 250, 154)", mediumturquoise: "rgb(72, 209, 204)", mediumvioletred: "rgb(199, 21, 133)", midnightblue: "rgb(25, 25, 112)", mintcream: "rgb(245, 255, 250)", mistyrose: "rgb(255, 228, 225)", moccasin: "rgb(255, 228, 181)", navajowhite: "rgb(255, 222, 173)", navy: "rgb(0, 0, 128)", oldlace: "rgb(253, 245, 230)", olive: "rgb(128, 128, 0)", olivedrab: "rgb(107, 142, 35)", orange: "rgb(255, 165, 0)", orangered: "rgb(255, 69, 0)", orchid: "rgb(218, 112, 214)", palegoldenrod: "rgb(238, 232, 170)", palegreen: "rgb(152, 251, 152)", paleturquoise: "rgb(175, 238, 238)", palevioletred: "rgb(219, 112, 147)", papayawhip: "rgb(255, 239, 213)", peachpuff: "rgb(255, 218, 185)", peru: "rgb(205, 133, 63)", pink: "rgb(255, 192, 203)", plum: "rgb(221, 160, 221)", powderblue: "rgb(176, 224, 230)", purple: "rgb(128, 0, 128)", rebeccapurple: "rgb(102, 51, 153)", red: "rgb(255, 0, 0)", rosybrown: "rgb(188, 143, 143)", royalblue: "rgb(65, 105, 225)", saddlebrown: "rgb(139, 69, 19)", salmon: "rgb(250, 128, 114)", sandybrown: "rgb(244, 164, 96)", seagreen: "rgb(46, 139, 87)", seashell: "rgb(255, 245, 238)", sienna: "rgb(160, 82, 45)", silver: "rgb(192, 192, 192)", skyblue: "rgb(135, 206, 235)", slateblue: "rgb(106, 90, 205)", slategray: "rgb(112, 128, 144)", slategrey: "rgb(112, 128, 144)", snow: "rgb(255, 250, 250)", springgreen: "rgb(0, 255, 127)", steelblue: "rgb(70, 130, 180)", tan: "rgb(210, 180, 140)", teal: "rgb(0, 128, 128)", thistle: "rgb(216, 191, 216)", tomato: "rgb(255, 99, 71)", turquoise: "rgb(64, 224, 208)", violet: "rgb(238, 130, 238)", wheat: "rgb(245, 222, 179)", white: "rgb(255, 255, 255)", whitesmoke: "rgb(245, 245, 245)", yellow: "rgb(255, 255, 0)", yellowgreen: "rgb(154, 205, 50)", transparent: "rgba(0, 0, 0, 0)", currentColor: "currentColor" };
function isColorName(name2) {
  return !!color_names[name2];
}
function getColorByName(name2) {
  return color_names[name2];
}
var ColorNames = {
  isColorName,
  getColorByName
};
function ReverseXyz(n) {
  return Math.pow(n, 3) > 8856e-6 ? Math.pow(n, 3) : (n - 16 / 116) / 7.787;
}
function ReverseRGB(n) {
  return n > 31308e-7 ? 1.055 * Math.pow(n, 1 / 2.4) - 0.055 : 12.92 * n;
}
function XYZtoRGB(x2, y2, z) {
  if (arguments.length == 1) {
    var { x: x2, y: y2, z } = arguments[0];
  }
  let X = x2 / 100;
  let Y = y2 / 100;
  let Z = z / 100;
  let R = X * 3.2406 + Y * -1.5372 + Z * -0.4986;
  let G = X * -0.9689 + Y * 1.8758 + Z * 0.0415;
  let B = X * 0.0557 + Y * -0.204 + Z * 1.057;
  R = ReverseRGB(R);
  G = ReverseRGB(G);
  B = ReverseRGB(B);
  const r = round$1(R * 255);
  const g = round$1(G * 255);
  const b = round$1(B * 255);
  return { r, g, b };
}
function LABtoXYZ(l, a, b) {
  if (arguments.length == 1) {
    var { l, a, b } = arguments[0];
  }
  let Y = (l + 16) / 116;
  let X = a / 500 + Y;
  let Z = Y - b / 200;
  Y = ReverseXyz(Y);
  X = ReverseXyz(X);
  Z = ReverseXyz(Z);
  const x2 = X * 95.047;
  const y2 = Y * 100;
  const z = Z * 108.883;
  return { x: x2, y: y2, z };
}
function PivotXyz(n) {
  return n > 8856e-6 ? Math.pow(n, 1 / 3) : (7.787 * n + 16) / 116;
}
function XYZtoLAB(x2, y2, z) {
  if (arguments.length == 1) {
    var { x: x2, y: y2, z } = arguments[0];
  }
  let X = x2 / 95.047;
  let Y = y2 / 100;
  let Z = z / 108.883;
  X = PivotXyz(X);
  Y = PivotXyz(Y);
  Z = PivotXyz(Z);
  const l = 116 * Y - 16;
  const a = 500 * (X - Y);
  const b = 200 * (Y - Z);
  return { l, a, b };
}
function LABtoRGB(l, a, b) {
  if (arguments.length == 1) {
    var { l, a, b } = arguments[0];
  }
  return XYZtoRGB(LABtoXYZ(l, a, b));
}
var fromLAB = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  ReverseXyz,
  ReverseRGB,
  XYZtoRGB,
  LABtoXYZ,
  PivotXyz,
  XYZtoLAB,
  LABtoRGB
});
function RGBtoHSV(r, g, b) {
  if (arguments.length == 1) {
    var { r, g, b } = arguments[0];
  }
  const R1 = r / 255;
  const G1 = g / 255;
  const B1 = b / 255;
  const MaxC = Math.max(R1, G1, B1);
  const MinC = Math.min(R1, G1, B1);
  const DeltaC = MaxC - MinC;
  var H = 0;
  if (DeltaC == 0) {
    H = 0;
  } else if (MaxC == R1) {
    H = 60 * ((G1 - B1) / DeltaC % 6);
  } else if (MaxC == G1) {
    H = 60 * ((B1 - R1) / DeltaC + 2);
  } else if (MaxC == B1) {
    H = 60 * ((R1 - G1) / DeltaC + 4);
  }
  if (H < 0) {
    H = 360 + H;
  }
  var S = 0;
  if (MaxC == 0)
    S = 0;
  else
    S = DeltaC / MaxC;
  var V = MaxC;
  return { h: H, s: S, v: V };
}
function RGBtoCMYK(r, g, b) {
  if (arguments.length == 1) {
    var { r, g, b } = arguments[0];
  }
  const R1 = r / 255;
  const G1 = g / 255;
  const B1 = b / 255;
  const K = 1 - Math.max(R1, G1, B1);
  const C = (1 - R1 - K) / (1 - K);
  const M = (1 - G1 - K) / (1 - K);
  const Y = (1 - B1 - K) / (1 - K);
  return { c: C, m: M, y: Y, k: K };
}
function RGBtoHSL(r, g, b) {
  if (arguments.length == 1) {
    var { r, g, b } = arguments[0];
  }
  r /= 255, g /= 255, b /= 255;
  var max = Math.max(r, g, b), min = Math.min(r, g, b);
  var h, s, l = (max + min) / 2;
  if (max == min) {
    h = s = 0;
  } else {
    var d = max - min;
    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
    switch (max) {
      case r:
        h = (g - b) / d + (g < b ? 6 : 0);
        break;
      case g:
        h = (b - r) / d + 2;
        break;
      case b:
        h = (r - g) / d + 4;
        break;
    }
    h /= 6;
  }
  return { h: round$1(h * 360), s: round$1(s * 100), l: round$1(l * 100) };
}
function c(r, g, b) {
  if (arguments.length == 1) {
    var { r, g, b } = arguments[0];
  }
  return gray((r + g + b) / 3 > 90 ? 0 : 255);
}
function gray(gray2) {
  return { r: gray2, g: gray2, b: gray2 };
}
function RGBtoSimpleGray(r, g, b) {
  if (arguments.length == 1) {
    var { r, g, b } = arguments[0];
  }
  return gray(Math.ceil((r + g + b) / 3));
}
function RGBtoGray(r, g, b) {
  if (arguments.length == 1) {
    var { r, g, b } = arguments[0];
  }
  return gray(RGBtoYCrCb(r, g, b).y);
}
function brightness(r, g, b) {
  return Math.ceil(r * 0.2126 + g * 0.7152 + b * 0.0722);
}
function RGBtoYCrCb(r, g, b) {
  if (arguments.length == 1) {
    var { r, g, b } = arguments[0];
  }
  const Y = brightness(r, g, b);
  const Cb = 0.564 * (b - Y);
  const Cr = 0.713 * (r - Y);
  return { y: Y, cr: Cr, cb: Cb };
}
function PivotRGB(n) {
  return (n > 0.04045 ? Math.pow((n + 0.055) / 1.055, 2.4) : n / 12.92) * 100;
}
function RGBtoXYZ(r, g, b) {
  if (arguments.length == 1) {
    var { r, g, b } = arguments[0];
  }
  let R = r / 255;
  let G = g / 255;
  let B = b / 255;
  R = PivotRGB(R);
  G = PivotRGB(G);
  B = PivotRGB(B);
  const x2 = R * 0.4124 + G * 0.3576 + B * 0.1805;
  const y2 = R * 0.2126 + G * 0.7152 + B * 0.0722;
  const z = R * 0.0193 + G * 0.1192 + B * 0.9505;
  return { x: x2, y: y2, z };
}
function RGBtoLAB(r, g, b) {
  if (arguments.length == 1) {
    var { r, g, b } = arguments[0];
  }
  return XYZtoLAB(RGBtoXYZ(r, g, b));
}
var fromRGB = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  RGBtoHSV,
  RGBtoCMYK,
  RGBtoHSL,
  c,
  gray,
  RGBtoSimpleGray,
  RGBtoGray,
  brightness,
  RGBtoYCrCb,
  PivotRGB,
  RGBtoXYZ,
  RGBtoLAB
});
function HUEtoRGB(p, q, t) {
  if (t < 0)
    t += 1;
  if (t > 1)
    t -= 1;
  if (t < 1 / 6)
    return p + (q - p) * 6 * t;
  if (t < 1 / 2)
    return q;
  if (t < 2 / 3)
    return p + (q - p) * (2 / 3 - t) * 6;
  return p;
}
function HSLtoHSV(h, s, l) {
  if (arguments.length == 1) {
    var { h, s, l } = arguments[0];
  }
  const rgb2 = HSLtoRGB(h, s, l);
  return RGBtoHSV(rgb2.r, rgb2.g, rgb2.b);
}
function HSLtoRGB(h, s, l) {
  if (arguments.length == 1) {
    var { h, s, l } = arguments[0];
  }
  var r, g, b;
  h /= 360;
  s /= 100;
  l /= 100;
  if (s == 0) {
    r = g = b = l;
  } else {
    var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
    var p = 2 * l - q;
    r = HUEtoRGB(p, q, h + 1 / 3);
    g = HUEtoRGB(p, q, h);
    b = HUEtoRGB(p, q, h - 1 / 3);
  }
  return { r: round$1(r * 255), g: round$1(g * 255), b: round$1(b * 255) };
}
var fromHSL = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  HUEtoRGB,
  HSLtoHSV,
  HSLtoRGB
});
const color_regexp = /(#(?:[\da-f]{3}){1,2}|#(?:[\da-f]{8})|rgb\((?:\s*\d{1,3},\s*){2}\d{1,3}\s*\)|rgba\((?:\s*\d{1,3},\s*){3}\d*\.?\d+\s*\)|hsl\(\s*\d{1,3}(?:,\s*\d{1,3}%){2}\s*\)|hsla\(\s*\d{1,3}(?:,\s*\d{1,3}%){2},\s*\d*\.?\d+\s*\)|([\w_\-]+))/gi;
function getColorIndexString(it, prefix = "@") {
  return `${prefix}${it.startIndex}`.padEnd(10, "0");
}
function isColor(str) {
  const results = matches(str);
  return !!results.length;
}
function matches(str) {
  const matches2 = str.match(color_regexp);
  let result = [];
  if (!matches2) {
    return result;
  }
  for (var i = 0, len2 = matches2.length; i < len2; i++) {
    if (matches2[i].indexOf("#") > -1 || matches2[i].indexOf("rgb") > -1 || matches2[i].indexOf("hsl") > -1) {
      result.push({ color: matches2[i] });
    } else {
      var nameColor = ColorNames.getColorByName(matches2[i]);
      if (nameColor) {
        result.push({ color: matches2[i], nameColor });
      }
    }
  }
  var pos = { next: 0 };
  result.forEach((item2) => {
    const startIndex = str.indexOf(item2.color, pos.next);
    item2.startIndex = startIndex;
    item2.endIndex = startIndex + item2.color.length;
    pos.next = item2.endIndex;
  });
  return result;
}
function convertMatches(str) {
  const m = matches(str);
  m.forEach((it) => {
    str = str.replace(it.color, getColorIndexString(it));
  });
  return { str, matches: m };
}
function convertMatchesArray(str, splitStr = ",") {
  const ret = convertMatches(str);
  return ret.str.split(splitStr).map((it, index2) => {
    it = trim(it);
    if (ret.matches[index2]) {
      it = it.replace(getColorIndexString(ret.matches[index2]), ret.matches[index2].color);
    }
    return it;
  });
}
function reverseMatches(str, matches2) {
  matches2.forEach((it) => {
    str = str.replace(getColorIndexString(it), it.color);
  });
  return str;
}
const REG_TRIM = /^\s+|\s+$/g;
function trim(str) {
  return str.replace(REG_TRIM, "");
}
function parse(str) {
  if (isString(str)) {
    if (ColorNames.isColorName(str)) {
      str = ColorNames.getColorByName(str);
    }
    if (str.indexOf("rgb(") > -1) {
      var arr = str.replace("rgb(", "").replace(")", "").split(",");
      for (var i = 0, len2 = arr.length; i < len2; i++) {
        arr[i] = parseInt(trim(arr[i]), 10);
      }
      var obj2 = { type: "rgb", r: arr[0], g: arr[1], b: arr[2], a: 1 };
      obj2 = __spreadValues(__spreadValues({}, obj2), RGBtoHSL(obj2));
      return obj2;
    } else if (str.indexOf("rgba(") > -1) {
      var arr = str.replace("rgba(", "").replace(")", "").split(",");
      for (var i = 0, len2 = arr.length; i < len2; i++) {
        if (len2 - 1 == i) {
          arr[i] = parseFloat(trim(arr[i]));
        } else {
          arr[i] = parseInt(trim(arr[i]), 10);
        }
      }
      var obj2 = { type: "rgb", r: arr[0], g: arr[1], b: arr[2], a: arr[3] };
      obj2 = __spreadValues(__spreadValues({}, obj2), RGBtoHSL(obj2));
      return obj2;
    } else if (str.indexOf("hsl(") > -1) {
      var arr = str.replace("hsl(", "").replace(")", "").split(",");
      for (var i = 0, len2 = arr.length; i < len2; i++) {
        arr[i] = parseFloat(trim(arr[i]));
      }
      var obj2 = { type: "hsl", h: arr[0], s: arr[1], l: arr[2], a: 1 };
      obj2 = __spreadValues(__spreadValues({}, obj2), HSLtoRGB(obj2));
      return obj2;
    } else if (str.indexOf("hsla(") > -1) {
      var arr = str.replace("hsla(", "").replace(")", "").split(",");
      for (var i = 0, len2 = arr.length; i < len2; i++) {
        if (len2 - 1 == i) {
          arr[i] = parseFloat(trim(arr[i]));
        } else {
          arr[i] = parseInt(trim(arr[i]), 10);
        }
      }
      var obj2 = { type: "hsl", h: arr[0], s: arr[1], l: arr[2], a: arr[3] };
      obj2 = __spreadValues(__spreadValues({}, obj2), HSLtoRGB(obj2));
      return obj2;
    } else if (str.indexOf("#") == 0) {
      str = str.replace("#", "");
      var arr = [];
      var a = 1;
      if (str.length == 3) {
        for (var i = 0, len2 = str.length; i < len2; i++) {
          var char = str.substr(i, 1);
          arr.push(parseInt(char + char, 16));
        }
      } else if (str.length === 8) {
        for (var i = 0, len2 = str.length; i < len2; i += 2) {
          arr.push(parseInt(str.substr(i, 2), 16));
        }
        a = arr.pop() / 255;
      } else {
        for (var i = 0, len2 = str.length; i < len2; i += 2) {
          arr.push(parseInt(str.substr(i, 2), 16));
        }
      }
      var obj2 = { type: "hex", r: arr[0], g: arr[1], b: arr[2], a };
      obj2 = __spreadValues(__spreadValues({}, obj2), RGBtoHSL(obj2));
      return obj2;
    }
  } else if (isNumber(str)) {
    if (0 <= str && str <= 16777215) {
      const r = (str & 16711680) >> 16;
      const g = (str & 65280) >> 8;
      const b = (str & 255) >> 0;
      var obj2 = { type: "hex", r, g, b, a: 1 };
      obj2 = __spreadValues(__spreadValues({}, obj2), RGBtoHSL(obj2));
      return obj2;
    } else if (0 <= str && str <= 4294967295) {
      const r = (str & 4278190080) >> 24;
      const g = (str & 16711680) >> 16;
      const b = (str & 65280) >> 8;
      const a2 = (str & 255) / 255;
      var obj2 = { type: "hex", r, g, b, a: a2 };
      obj2 = __spreadValues(__spreadValues({}, obj2), RGBtoHSL(obj2));
      return obj2;
    }
  }
  return str;
}
function parseGradient(colors2) {
  if (isString(colors2)) {
    colors2 = convertMatchesArray(colors2);
  }
  colors2 = colors2.map((it) => {
    if (isString(it)) {
      const ret = convertMatches(it);
      let arr = trim(ret.str).split(" ");
      if (arr[1]) {
        if (arr[1].indexOf("%") > -1) {
          arr[1] = parseFloat(arr[1].replace(/%/, "")) / 100;
        } else {
          arr[1] = parseFloat(arr[1]);
        }
      } else {
        arr[1] = "*";
      }
      arr[0] = reverseMatches(arr[0], ret.matches);
      return arr;
    } else if (Array.isArray(it)) {
      if (!it[1]) {
        it[1] = "*";
      } else if (isString(it[1])) {
        if (it[1].indexOf("%") > -1) {
          it[1] = parseFloat(it[1].replace(/%/, "")) / 100;
        } else {
          it[1] = +it[1];
        }
      }
      return [...it];
    }
  });
  const count = colors2.filter((it) => {
    return it[1] === "*";
  }).length;
  if (count > 0) {
    const sum = colors2.filter((it) => {
      return it[1] != "*" && it[1] != 1;
    }).map((it) => it[1]).reduce((total, cur) => {
      return total + cur;
    }, 0);
    const dist2 = (1 - sum) / count;
    colors2.forEach((it, index2) => {
      if (it[1] == "*" && index2 > 0) {
        if (colors2.length - 1 == index2)
          ;
        else {
          it[1] = dist2;
        }
      }
    });
  }
  return colors2;
}
var parser = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  getColorIndexString,
  isColor,
  matches,
  convertMatches,
  convertMatchesArray,
  reverseMatches,
  trim,
  parse,
  parseGradient
});
const ConstraintsDirection = {
  HORIZONTAL: "constraints-horizontal",
  VERTICAL: "constraints-vertical"
};
const Constraints = {
  NONE: "none",
  MIN: "min",
  MAX: "max",
  STRETCH: "stretch",
  SCALE: "scale",
  CENTER: "center"
};
const BooleanOperation = {
  DIFFERENCE: "difference",
  INTERSECTION: "intersection",
  UNION: "union",
  REVERSE_DIFFERENCE: "reverse-difference",
  XOR: "xor"
};
const StrokeLineCap = {
  BUTT: "butt",
  ROUND: "round",
  SQUARE: "square"
};
const StrokeLineJoin = {
  MITER: "miter",
  ROUND: "round",
  BEVEL: "bevel"
};
const BlendMode = {
  NORMAL: "normal",
  MULTIPLY: "multiply",
  SCREEN: "screen",
  OVERLAY: "overlay",
  DARKEN: "darken",
  LIGHTEN: "lighten",
  COLOR_DODGE: "color-dodge",
  COLOR_BURN: "color-burn",
  HARD_LIGHT: "hard-light",
  SOFT_LIGHT: "soft-light",
  DIFFERENCE: "difference",
  EXCLUSION: "exclusion",
  HUE: "hue",
  SATURATION: "saturation",
  COLOR: "color",
  LUMINOSITY: "luminosity"
};
const TextDecoration = {
  NONE: "none",
  UNDERLINE: "underline",
  OVERLINE: "overline",
  LINE_THROUGH: "line-through",
  BLINK: "blink"
};
const TextTransform = {
  NONE: "none",
  CAPITALIZE: "capitalize",
  UPPERCASE: "uppercase",
  LOWERCASE: "lowercase"
};
const Overflow = {
  VISIBLE: "visible",
  HIDDEN: "hidden",
  SCROLL: "scroll",
  AUTO: "auto"
};
const BorderStyle = {
  NONE: "none",
  HIDDEN: "hidden",
  DOTTED: "dotted",
  DASHED: "dashed",
  SOLID: "solid",
  DOUBLE: "double",
  GROOVE: "groove",
  RIDGE: "ridge",
  INSET: "inset",
  OUTSET: "outset"
};
const Layout = {
  DEFAULT: "default",
  FLEX: "flex",
  GRID: "grid"
};
const FlexDirection = {
  ROW: "row",
  ROW_REVERSE: "row-reverse",
  COLUMN: "column",
  COLUMN_REVERSE: "column-reverse"
};
const JustifyContent = {
  FLEX_START: "flex-start",
  FLEX_END: "flex-end",
  CENTER: "center",
  SPACE_BETWEEN: "space-between",
  SPACE_AROUND: "space-around",
  SPACE_EVENLY: "space-evenly"
};
const AlignItems = {
  FLEX_START: "flex-start",
  FLEX_END: "flex-end",
  CENTER: "center",
  BASELINE: "baseline",
  STRETCH: "stretch"
};
const AlignContent = {
  FLEX_START: "flex-start",
  FLEX_END: "flex-end",
  CENTER: "center",
  SPACE_BETWEEN: "space-between",
  SPACE_AROUND: "space-around",
  SPACE_EVENLY: "space-evenly"
};
const FlexWrap = {
  NOWRAP: "nowrap",
  WRAP: "wrap",
  WRAP_REVERSE: "wrap-reverse"
};
const ResizingMode = {
  FIXED: "fixed",
  HUG_CONTENT: "hug-content",
  FILL_CONTAINER: "fill-container"
};
const TextClip = {
  NONE: "none",
  TEXT: "text"
};
const BoxShadowStyle = {
  OUTSET: "outset",
  INSET: "inset"
};
class BoxShadow extends PropertyItem {
  static parse(obj2) {
    return new BoxShadow(obj2);
  }
  static parseStyle(str) {
    var boxShadows = [];
    str = str.trim();
    if (!str)
      return boxShadows;
    var results = convertMatches(str);
    boxShadows = results.str.split(",").filter((it) => it.trim()).map((shadow2) => {
      var values = shadow2.trim().split(" ");
      var insets = values.filter((it) => it === BoxShadowStyle.INSET);
      var colors2 = values.filter((it) => it.includes("@")).map((it) => {
        return reverseMatches(it, results.matches);
      });
      var numbers = values.filter((it) => {
        return it !== BoxShadowStyle.INSET && !it.includes("@");
      });
      return BoxShadow.parse({
        inset: !!insets.length ? BoxShadowStyle.INSET : BoxShadowStyle.OUTSET,
        color: colors2[0] || "rgba(0, 0, 0, 1)",
        offsetX: Length.parse(numbers[0] || "0px"),
        offsetY: Length.parse(numbers[1] || "0px"),
        blurRadius: Length.parse(numbers[2] || "0px"),
        spreadRadius: Length.parse(numbers[3] || "0px")
      });
    });
    return boxShadows;
  }
  static join(list2) {
    return list2.map((it) => BoxShadow.parse(it)).join(", ");
  }
  getDefaultObject() {
    return super.getDefaultObject({
      itemType: "box-shadow",
      inset: false,
      offsetX: 0,
      offsetY: 0,
      blurRadius: 0,
      spreadRadius: 0,
      color: "rgba(0, 0, 0, 1)"
    });
  }
  toCloneObject() {
    this.json;
    return __spreadValues(__spreadValues({}, super.toCloneObject()), this.attrs("inset", "offsetX", "offsetY", "blurRadius", "spreadRadius", "color"));
  }
  convert(json) {
    json = super.convert(json);
    if (isNumber(json.offsetX))
      json.offsetX = Length.px(json.offsetX);
    else if (json.offsetX)
      json.offsetX = Length.parse(json.offsetX);
    if (isNumber(json.offsetY))
      json.offsetY = Length.px(json.offsetY);
    else if (json.offsetY)
      json.offsetY = Length.parse(json.offsetY);
    if (isNumber(json.blurRadius))
      json.blurRadius = Length.px(json.blurRadius);
    else if (json.blurRadius)
      json.blurRadius = Length.parse(json.blurRadius);
    if (isNumber(json.spreadRadius))
      json.spreadRadius = Length.px(json.spreadRadius);
    else if (json.spreadRadius)
      json.spreadRadius = Length.parse(json.spreadRadius);
    return json;
  }
  toCSS() {
    return {
      "box-shadow": this.toString()
    };
  }
  toString() {
    var json = this.json;
    return `${json.inset === BoxShadowStyle.INSET ? "inset " : ""}${json.offsetX} ${json.offsetY} ${json.blurRadius} ${json.spreadRadius} ${json.color}`;
  }
}
function makeInterpolateBoolean(layer2, property, s, e2) {
  return (ratio, t) => {
    if (t === 1) {
      return e2;
    }
    return s;
  };
}
function CMYKtoRGB(c2, m, y2, k) {
  if (arguments.length == 1) {
    var { c: c2, m, y: y2, k } = arguments[0];
  }
  const R = 255 * (1 - c2) * (1 - k);
  const G = 255 * (1 - m) * (1 - k);
  const B = 255 * (1 - y2) * (1 - k);
  return { r: R, g: G, b: B };
}
var fromCMYK = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  CMYKtoRGB
});
function HSVtoRGB(h, s, v) {
  if (arguments.length == 1) {
    var { h, s, v } = arguments[0];
  }
  var H = h;
  var S = s;
  var V = v;
  if (H >= 360) {
    H = 0;
  }
  const C = S * V;
  const X = C * (1 - Math.abs(H / 60 % 2 - 1));
  const m = V - C;
  let temp = [];
  if (0 <= H && H < 60) {
    temp = [C, X, 0];
  } else if (60 <= H && H < 120) {
    temp = [X, C, 0];
  } else if (120 <= H && H < 180) {
    temp = [0, C, X];
  } else if (180 <= H && H < 240) {
    temp = [0, X, C];
  } else if (240 <= H && H < 300) {
    temp = [X, 0, C];
  } else if (300 <= H && H < 360) {
    temp = [C, 0, X];
  }
  return {
    r: round$1((temp[0] + m) * 255),
    g: round$1((temp[1] + m) * 255),
    b: round$1((temp[2] + m) * 255)
  };
}
function HSVtoHSL(h, s, v) {
  if (arguments.length == 1) {
    var { h, s, v } = arguments[0];
  }
  const rgb2 = HSVtoRGB(h, s, v);
  return RGBtoHSL(rgb2.r, rgb2.g, rgb2.b);
}
var fromHSV = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  HSVtoRGB,
  HSVtoHSL
});
function YCrCbtoRGB(y2, cr, cb, bit) {
  if (arguments.length == 1) {
    var { y: y2, cr, cb, bit } = arguments[0];
    bit = bit || 0;
  }
  const R = y2 + 1.402 * (cr - bit);
  const G = y2 - 0.344 * (cb - bit) - 0.714 * (cr - bit);
  const B = y2 + 1.772 * (cb - bit);
  return { r: Math.ceil(R), g: Math.ceil(G), b: Math.ceil(B) };
}
var fromYCrCb = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  YCrCbtoRGB
});
function interpolateRGB(startColor, endColor, t = 0.5, exportFormat = "hex") {
  var obj2 = interpolateRGBObject(startColor, endColor, t);
  return format(obj2, exportFormat);
}
function interpolateRGBObject(startColor, endColor, t = 0.5) {
  const startColorAlpha = typeof startColor.a === "undefined" ? 1 : startColor.a;
  const endColorAlpha = typeof endColor.a === "undefined" ? 1 : endColor.a;
  return {
    r: round$1(startColor.r + (endColor.r - startColor.r) * t),
    g: round$1(startColor.g + (endColor.g - startColor.g) * t),
    b: round$1(startColor.b + (endColor.b - startColor.b) * t),
    a: round$1(startColorAlpha + (endColorAlpha - startColorAlpha) * t, 100)
  };
}
function scale(scale2, count = 5) {
  if (!scale2)
    return [];
  if (typeof scale2 === "string") {
    scale2 = convertMatchesArray(scale2);
  }
  scale2 = scale2 || [];
  var len2 = scale2.length;
  var colors2 = [];
  for (var i = 0; i < len2 - 1; i++) {
    for (var index2 = 0; index2 < count; index2++) {
      colors2.push(blend(scale2[i], scale2[i + 1], index2 / count));
    }
  }
  return colors2;
}
function blend(startColor, endColor, ratio = 0.5, format2 = "hex") {
  var s = parse(startColor);
  var e2 = parse(endColor);
  return interpolateRGB(s, e2, ratio, format2);
}
function mix(startcolor, endColor, ratio = 0.5, format2 = "hex") {
  return blend(startcolor, endColor, ratio, format2);
}
function contrast(c2) {
  c2 = parse(c2);
  return (Math.round(c2.r * 299) + Math.round(c2.g * 587) + Math.round(c2.b * 114)) / 1e3;
}
function contrastColor(c2) {
  return contrast(c2) >= 128 ? "black" : "white";
}
function gradient$2(colors2, count = 10) {
  colors2 = parseGradient(colors2);
  let newColors = [];
  let maxCount = count - (colors2.length - 1);
  let allCount = maxCount;
  for (var i = 1, len2 = colors2.length; i < len2; i++) {
    var startColor = colors2[i - 1][0];
    var endColor = colors2[i][0];
    var rate = i == 1 ? colors2[i][1] : colors2[i][1] - colors2[i - 1][1];
    var colorCount = i == colors2.length - 1 ? allCount : Math.floor(rate * maxCount);
    newColors = newColors.concat(scale([startColor, endColor], colorCount), [endColor]);
    allCount -= colorCount;
  }
  return newColors;
}
function scaleHSV(color2, target = "h", count = 9, exportFormat = "rgb", min = 0, max = 1, dist2 = 100) {
  var colorObj = parse(color2);
  var hsv = RGBtoHSV(colorObj);
  var unit = (max - min) * dist2 / count;
  var results = [];
  for (var i = 1; i <= count; i++) {
    hsv[target] = Math.abs((dist2 - unit * i) / dist2);
    results.push(format(HSVtoRGB(hsv), exportFormat));
  }
  return results;
}
function scaleH(color2, count = 9, exportFormat = "rgb", min = 0, max = 360) {
  return scaleHSV(color2, "h", count, exportFormat, min, max, 1);
}
function scaleS(color2, count = 9, exportFormat = "rgb", min = 0, max = 1) {
  return scaleHSV(color2, "s", count, exportFormat, min, max, 100);
}
function scaleV(color2, count = 9, exportFormat = "rgb", min = 0, max = 1) {
  return scaleHSV(color2, "v", count, exportFormat, min, max, 100);
}
scale.parula = function(count) {
  return scale(["#352a87", "#0f5cdd", "#00b5a6", "#ffc337", "#fdff00"], count);
};
scale.jet = function(count) {
  return scale(["#00008f", "#0020ff", "#00ffff", "#51ff77", "#fdff00", "#ff0000", "#800000"], count);
};
scale.hsv = function(count) {
  return scale(["#ff0000", "#ffff00", "#00ff00", "#00ffff", "#0000ff", "#ff00ff", "#ff0000"], count);
};
scale.hot = function(count) {
  return scale(["#0b0000", "#ff0000", "#ffff00", "#ffffff"], count);
};
scale.pink = function(count) {
  return scale(["#1e0000", "#bd7b7b", "#e7e5b2", "#ffffff"], count);
};
scale.bone = function(count) {
  return scale(["#000000", "#4a4a68", "#a6c6c6", "#ffffff"], count);
};
scale.copper = function(count) {
  return scale(["#000000", "#3d2618", "#9d623e", "#ffa167", "#ffc77f"], count);
};
var mixin = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  interpolateRGB,
  interpolateRGBObject,
  scale,
  blend,
  mix,
  contrast,
  contrastColor,
  gradient: gradient$2,
  scaleHSV,
  scaleH,
  scaleS,
  scaleV
});
var Color = __spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues({}, create), formatter), math), mixin), parser), fromYCrCb), fromRGB), fromCMYK), fromHSV), fromHSL), fromLAB), func);
function makeInterpolateColor(layer2, property, startColor, endColor) {
  var s = Color.parse(startColor || "rgba(0, 0, 0, 1)");
  var e2 = Color.parse(endColor || "rgba(0, 0, 0, 1)");
  return (rate, t) => {
    if (t === 0) {
      return startColor;
    } else if (t === 1) {
      return endColor;
    }
    return interpolateRGB(s, e2, rate, "rgb");
  };
}
function makeInterpolateBoxShadow(layer2, property, startValue, endValue) {
  var s = BoxShadow.parseStyle(startValue);
  var e2 = BoxShadow.parseStyle(endValue);
  var totalLength = Math.max(s.length, e2.length);
  var list2 = [];
  for (var i = 0, len2 = totalLength; i < len2; i++) {
    var startObject = s[i] || BoxShadow.parseStyle("0px 0px 0px 0px rgba(0, 0, 0, 0)")[0];
    var endObject = e2[i] || BoxShadow.parseStyle("0px 0px 0px 0px rgba(0, 0, 0, 0)")[0];
    list2.push({
      inset: makeInterpolateBoolean(layer2, property, startObject.inset, endObject.inset),
      offsetX: makeInterpolateLength(layer2, property, startObject.offsetX, endObject.offsetX),
      offsetY: makeInterpolateLength(layer2, property, startObject.offsetY, endObject.offsetY),
      blurRadius: makeInterpolateLength(layer2, property, startObject.blurRadius, endObject.blurRadius),
      spreadRadius: makeInterpolateLength(layer2, property, startObject.spreadRadius, endObject.spreadRadius),
      color: makeInterpolateColor(layer2, property, startObject.color, endObject.color)
    });
  }
  return (rate, t) => {
    return BoxShadow.join(list2.map((it) => {
      return {
        inset: it.inset(rate, t),
        offsetX: it.offsetX(rate, t),
        offsetY: it.offsetY(rate, t),
        blurRadius: it.blurRadius(rate, t),
        spreadRadius: it.spreadRadius(rate, t),
        color: it.color(rate, t)
      };
    }));
  };
}
function makeInterpolateString(layer2, property, startString, endString) {
  return makeInterpolateBoolean(layer2, property, startString, endString);
}
const stepTimingFunction = (step2 = 1, direction = "end") => {
  step2 = +step2;
  return function(rate) {
    var stepDist = 1 / step2;
    if (direction == "start") {
      return stepDist * Math.ceil(rate / stepDist);
    } else if (direction == "end") {
      return stepDist * Math.floor(rate / stepDist);
    }
  };
};
function step(step2 = 1, direction = "end") {
  return stepTimingFunction(step2, direction);
}
function stepStart() {
  return stepTimingFunction(1, "start");
}
function stepEnd() {
  return stepTimingFunction(1, "end");
}
function easeOutElastic() {
  return (rate) => {
    return Math.pow(2, -10 * rate) * Math.sin((rate - 0.1) * 5 * Math.PI) + 1;
  };
}
var timingFunctions = {
  step,
  "step-start": stepStart,
  "step-end": stepEnd,
  stepStart,
  stepEnd,
  "ease-out-elastic": easeOutElastic,
  easeOutElastic
};
function makeInterpolateRotate(layer2, property, startNumber, endNumber) {
  var startValue = Length.parse(startNumber);
  var endValue = Length.parse(endNumber);
  return (rate, t) => {
    var realStartValue = startValue.value;
    var realEndValue = endValue.value;
    if (t === 0) {
      return Length.deg(realStartValue);
    } else if (t === 1) {
      return Length.deg(realEndValue);
    }
    return Length.deg(realStartValue + (realEndValue - realStartValue) * rate).to(startValue.unit);
  };
}
class TextShadow extends PropertyItem {
  static parse(obj2) {
    return new TextShadow(obj2);
  }
  static parseStyle(str = "") {
    var results = convertMatches(str);
    str = str.trim();
    var textShadows = results.str.split(",").filter((it) => it.trim()).map((shadow2) => {
      var values = shadow2.trim().split(" ");
      var colors2 = values.filter((it) => it.includes("@")).map((it) => {
        return reverseMatches(it, results.matches) || "black";
      });
      var numbers = values.filter((it) => {
        return !it.includes("@");
      });
      return TextShadow.parse({
        color: colors2[0] || "rgba(0, 0, 0, 1)",
        offsetX: Length.parse(numbers[0] || "0px"),
        offsetY: Length.parse(numbers[1] || "0px"),
        blurRadius: Length.parse(numbers[2] || "0px")
      });
    });
    return textShadows;
  }
  static join(list2) {
    return list2.map((it) => TextShadow.parse(it)).join(", ");
  }
  getDefaultObject() {
    return super.getDefaultObject({
      itemType: "text-shadow",
      offsetX: "0px",
      offsetY: "0px",
      blurRadius: "0px",
      color: "rgba(0, 0, 0, 1)"
    });
  }
  toCloneObject() {
    return __spreadValues(__spreadValues({}, super.toCloneObject()), this.attrs("offsetX", "offsetY", "blurRadius", "color"));
  }
  convert(json) {
    json = super.convert(json);
    if (isNumber(json.offsetX))
      json.offsetX = Length.px(json.offsetX);
    else if (json.offsetX)
      json.offsetX = Length.parse(json.offsetX);
    if (isNumber(json.offsetY))
      json.offsetY = Length.px(json.offsetY);
    else if (json.offsetY)
      json.offsetY = Length.parse(json.offsetY);
    if (isNumber(json.blurRadius))
      json.blurRadius = Length.px(json.blurRadius);
    else if (json.blurRadius)
      json.blurRadius = Length.parse(json.blurRadius);
    return json;
  }
  toCSS() {
    return {
      "text-shadow": this.toString()
    };
  }
  toString() {
    var { offsetX, offsetY, blurRadius, color: color2 } = this.json;
    if (isNumber(offsetX))
      offsetX = Length.px(offsetX);
    if (isNumber(offsetY))
      offsetY = Length.px(offsetY);
    if (isNumber(blurRadius))
      blurRadius = Length.px(blurRadius);
    return `${offsetX} ${offsetY} ${blurRadius} ${color2}`;
  }
}
function makeInterpolateTextShadow(layer2, property, startValue, endValue) {
  var s = TextShadow.parseStyle(startValue);
  var e2 = TextShadow.parseStyle(endValue);
  var totalLength = Math.max(s.length, e2.length);
  var list2 = [];
  for (var i = 0, len2 = totalLength; i < len2; i++) {
    var startObject = s[i] || TextShadow.parseStyle("0px 0px 0px rgba(0, 0, 0, 0)")[0];
    var endObject = e2[i] || TextShadow.parseStyle("0px 0px 0px rgba(0, 0, 0, 0)")[0];
    list2.push({
      offsetX: makeInterpolateLength(layer2, property, startObject.offsetX, endObject.offsetX, "width", "self"),
      offsetY: makeInterpolateLength(layer2, property, startObject.offsetY, endObject.offsetY, "height", "self"),
      blurRadius: makeInterpolateLength(layer2, property, startObject.blurRadius, endObject.blurRadius, "radius"),
      color: makeInterpolateColor(layer2, property, startObject.color, endObject.color)
    });
  }
  return (rate, t) => {
    return TextShadow.join(list2.map((it) => {
      return {
        offsetX: it.offsetX(rate, t),
        offsetY: it.offsetY(rate, t),
        blurRadius: it.blurRadius(rate, t),
        color: it.color(rate, t)
      };
    }));
  };
}
class ImageResource extends PropertyItem {
  getDefaultObject(obj2 = {}) {
    return __spreadValues({
      itemType: "image-resource",
      type: "image"
    }, obj2);
  }
  isGradient() {
    return false;
  }
  isLinear() {
    return false;
  }
  isRadial() {
    return false;
  }
  isConic() {
    return false;
  }
  isStatic() {
    return false;
  }
  isImage() {
    return false;
  }
  hasAngle() {
    return false;
  }
  isUrl() {
    return false;
  }
  isFile() {
    return false;
  }
  isAttribute() {
    return true;
  }
  toString() {
    return "none";
  }
}
class ColorStep extends Item {
  getDefaultObject() {
    return {
      id: uuidShort$1(),
      cut: false,
      percent: 0,
      unit: "%",
      px: 0,
      em: 0,
      color: "rgba(0, 0, 0, 0)",
      prevColorStep: null
    };
  }
  toCloneObject() {
    return __spreadValues(__spreadValues({}, super.toCloneObject()), this.attrs("cut", "percent", "unit", "px", "em", "color"));
  }
  on() {
    this.json.cut = true;
  }
  off() {
    this.json.cut = false;
  }
  toggle() {
    this.json.cut = !this.json.cut;
  }
  getUnit() {
    return this.json.unit == "%" ? "percent" : this.json.unit;
  }
  add(num) {
    var unit = this.getUnit();
    this.json[unit] += +num;
    return this;
  }
  sub(num) {
    var unit = this.getUnit();
    this.json[unit] -= +num;
    return this;
  }
  mul(num) {
    var unit = this.getUnit();
    this.json[unit] *= +num;
    return this;
  }
  div(num) {
    var unit = this.getUnit();
    this.json[unit] /= +num;
    return this;
  }
  mod(num) {
    var unit = this.getUnit();
    this.json[unit] %= +num;
    return this;
  }
  get isPx() {
    return this.json.unit == "px";
  }
  get isPercent() {
    return this.json.unit == "%" || this.json.unit === "percent";
  }
  get isEm() {
    return this.json.unit == "em";
  }
  toLength(maxValue) {
    if (this.isPx) {
      return Length.px(this.json.px);
    } else if (this.isPercent) {
      return Length.percent(this.json.percent);
    } else if (this.isEm) {
      return Length.em(this.json.em);
    }
  }
  getPrevLength() {
    if (!this.json.prevColorStep)
      return "";
    return this.json.prevColorStep.toLength();
  }
  toString() {
    var prev = this.json.cut ? this.getPrevLength() : "";
    var color2 = this.json.color || "transparent";
    return `${color2} ${prev} ${this.toLength()}`;
  }
  reset(json) {
    super.reset(json);
    if (this.parent) {
      this.parent.sortColorStep();
    }
  }
  setValue(percent, maxValue) {
    if (this.isPx) {
      this.reset({ px: maxValue * percent / 100 });
    } else if (this.isPercent) {
      this.reset({ percent });
    } else if (this.isEm) {
      this.reset({ em: maxValue * percent / 100 / 16 });
    }
  }
  static parse(colorStepString) {
    let colorsteps = [];
    const results = convertMatches(colorStepString);
    var arr = results.str.split(" ").filter((it) => it.trim());
    const colorIndex = +arr[0].replace("@", "");
    const color2 = results.matches[colorIndex].color;
    if (arr.length === 1) {
      colorsteps.push(new ColorStep({
        color: color2,
        unit: "%",
        percent: 0,
        hasNotUnit: true
      }));
    } else if (arr.length === 2) {
      const len2 = Length.parse(arr[1]);
      let data = { unit: len2.unit };
      if (len2.isPercent()) {
        data.percent = len2.value;
      } else if (len2.isPx()) {
        data.px = len2.value;
      } else if (len2.isEm()) {
        data.em = len2.value;
      }
      colorsteps.push(new ColorStep(__spreadValues({ color: color2 }, data)));
    } else if (arr.length === 3) {
      const len2 = Length.parse(arr[2]);
      let data = { unit: len2.unit };
      if (len2.isPercent()) {
        data.percent = len2.value;
      } else if (len2.isPx()) {
        data.px = len2.value;
      } else if (len2.isEm()) {
        data.em = len2.value;
      }
      colorsteps.push(new ColorStep(__spreadValues({ color: color2, cut: true }, data)));
    }
    return colorsteps;
  }
  static createColorStep(maxCount = 2, maxValue = 100, unitType = "%") {
    var colorStepCount = randomNumber(2, maxCount);
    var unitValue = maxValue / colorStepCount;
    var colorsteps = repeat$1(colorStepCount).map((_, index2) => {
      return `${Color.random()} ${index2 * unitValue}${unitType}`;
    }).join(",");
    return colorsteps;
  }
  static createRepeatColorStep(maxCount = 2, unitValue = 1) {
    var colorStepCount = randomNumber(2, maxCount);
    var colorsteps = repeat$1(colorStepCount).map((_, index2) => {
      return `${Color.random()} ${Length.parse(unitValue).mul(index2 + 1)}`;
    }).join(",");
    return colorsteps;
  }
}
const DEFINED_ANGLES$2 = {
  "to top": 0,
  "to top right": 45,
  "to right": 90,
  "to bottom right": 135,
  "to bottom": 180,
  "to bottom left": 225,
  "to left": 270,
  "to top left": 315
};
class Gradient extends ImageResource {
  isGradient() {
    return true;
  }
  toString() {
    return "none";
  }
  getDefaultObject(obj2 = {}) {
    return __spreadValues({
      itemType: "image-resource",
      type: "gradient",
      colorsteps: []
    }, obj2);
  }
  toCloneObject() {
    return __spreadProps(__spreadValues({}, super.toCloneObject()), {
      colorsteps: this.json.colorsteps.map((color2) => color2.clone())
    });
  }
  convert(json) {
    if (json.colorsteps[0] instanceof ColorStep)
      ;
    else {
      json.colorsteps = json.colorsteps.map((c2) => new ColorStep(c2));
    }
    return json;
  }
  calculateAngle() {
    var angle2 = this.json.angle;
    return isUndefined(DEFINED_ANGLES$2[angle2]) ? angle2 : DEFINED_ANGLES$2[angle2] || 0;
  }
  addColorStep(colorstep, isSort = true) {
    this.json.colorsteps.push(colorstep);
    if (isSort)
      this.sortColorStep();
    return colorstep;
  }
  insertColorStep(percent, startColor = "rgba(216,216,216,0)", endColor = "rgba(216,216,216,1)") {
    var colorsteps = this.colorsteps;
    if (!colorsteps.length) {
      this.addColorStepList([
        new ColorStep({ color: startColor, percent, index: 0 }),
        new ColorStep({ color: endColor, percent: 100, index: 100 })
      ]);
      return;
    }
    if (percent < colorsteps[0].percent) {
      colorsteps[0].index = 1;
      this.addColorStep(new ColorStep({ index: 0, color: colorsteps[0].color, percent }));
      return;
    }
    var lastIndex = colorsteps.length - 1;
    if (colorsteps[lastIndex].percent < percent) {
      var color2 = colorsteps[lastIndex].color;
      var index2 = colorsteps[lastIndex].index + 1;
      this.addColorStep(new ColorStep({ index: index2, color: color2, percent }));
      return;
    }
    for (var i = 0, len2 = colorsteps.length - 1; i < len2; i++) {
      var step2 = colorsteps[i];
      var nextStep = colorsteps[i + 1];
      if (step2.percent <= percent && percent <= nextStep.percent) {
        var color2 = Color.mix(step2.color, nextStep.color, (percent - step2.percent) / (nextStep.percent - step2.percent), "rgb");
        this.addColorStep(new ColorStep({ index: step2.index + 1, color: color2, percent }));
        return;
      }
    }
  }
  sortColorStep() {
    var children2 = this.colorsteps;
    children2.sort((a, b) => {
      if (a.percent > b.percent)
        return 1;
      if (a.percent < b.percent)
        return -1;
      if (a.percent == b.percent) {
        if (a.index === b.index)
          return 0;
        return a.index > b.index ? 1 : -1;
      }
    });
    children2.forEach((it, index2) => {
      it.index = index2 * 100;
    });
  }
  addColorStepList(colorstepList = []) {
    colorstepList.forEach((c2) => {
      this.addColorStep(c2, false);
    });
    this.sortColorStep();
  }
  getColorStep(id) {
    return this.json.colorsteps.filter((c2) => c2.id == id)[0];
  }
  clear(...args2) {
    if (args2.length) {
      this.json.colorsteps.splice(+args2[0], 1);
    } else {
      this.json.colorsteps = [];
    }
  }
  removeColorStep(id) {
    this.json.colorsteps = this.json.colorsteps.filter((it) => it.id != id);
  }
  get colorsteps() {
    return this.json.colorsteps;
  }
  getColorString() {
    var colorsteps = this.colorsteps;
    return Gradient.toColorString(colorsteps);
  }
  static toColorString(colorsteps = []) {
    if (!colorsteps.length)
      return "";
    var newColors = colorsteps.map((c2, index2) => {
      c2.prevColorStep = c2.cut && index2 > 0 ? colorsteps[index2 - 1] : null;
      return c2;
    });
    if (newColors.length === 1) {
      newColors.push(new ColorStep({
        color: newColors[0].color || "transparent",
        percent: 100
      }));
    }
    return newColors.map((f) => `${f}`).join(",");
  }
}
class StaticGradient extends Gradient {
  getDefaultObject() {
    return super.getDefaultObject({
      type: "static-gradient",
      static: true,
      colorsteps: [
        new ColorStep({ color: "red", percent: 0, index: 0 }),
        new ColorStep({ color: "red", percent: 100, index: 0 })
      ]
    });
  }
  toCloneObject() {
    return __spreadProps(__spreadValues({}, super.toCloneObject()), {
      static: true
    });
  }
  static create(color2 = "transparent") {
    return new StaticGradient({
      colorsteps: [
        new ColorStep({ color: color2, percent: 0, index: 0 }),
        new ColorStep({ color: color2, percent: 100, index: 1 })
      ]
    });
  }
  toString() {
    var color2 = this.json.colorsteps[0].color;
    return `linear-gradient(to right, ${color2} 0%, ${color2} 100%)`;
  }
  isStatic() {
    return true;
  }
}
const IMAGE_LIST$1 = ["jpg", "jpeg", "png", "gif", "svg"];
class URLImageResource extends ImageResource {
  getDefaultObject(obj2 = {}) {
    return super.getDefaultObject(__spreadValues({
      type: "url",
      url: "",
      datauri: ""
    }, obj2));
  }
  toCloneObject() {
    return __spreadValues(__spreadValues({}, super.toCloneObject()), this.attrs("url", "datauri"));
  }
  static parse(str) {
    var url = str.split("(")[1].split(")")[0];
    return new URLImageResource({ url });
  }
  isUrl() {
    return true;
  }
  toString() {
    var json = this.json;
    return `url(${json.url})`;
  }
  static isImageFile(fileExt) {
    return IMAGE_LIST$1.includes(fileExt);
  }
}
const DEFINED_DIRECTIONS = {
  "0": "to top",
  "45": "to top right",
  "90": "to right",
  "135": "to bottom right",
  "180": "to bottom",
  "225": "to bottom left",
  "270": "to left",
  "315": "to top left"
};
const DEFINED_ANGLES$1 = {
  "to top": "0",
  "to top right": "45",
  "to right": "90",
  "to bottom right": "135",
  "to bottom": "180",
  "to bottom left": "225",
  "to left": "270",
  "to top left": "315"
};
class LinearGradient$1 extends Gradient {
  getDefaultObject(obj2) {
    return super.getDefaultObject(__spreadValues({
      type: "linear-gradient",
      angle: 0
    }, obj2));
  }
  toCloneObject() {
    return __spreadProps(__spreadValues({}, super.toCloneObject()), {
      angle: this.json.angle
    });
  }
  isLinear() {
    return true;
  }
  hasAngle() {
    return true;
  }
  toString() {
    if (this.colorsteps.length === 0)
      return "";
    var colorString = this.getColorString();
    var opt = "";
    var angle2 = this.json.angle || 0;
    opt = angle2;
    if (isNumber(opt)) {
      opt = DEFINED_DIRECTIONS[`${opt}`] || opt;
    }
    if (isNumber(opt)) {
      opt = opt > 360 ? opt % 360 : opt;
      opt = `${opt}deg`;
    }
    var result = `${this.json.type}(${opt}, ${colorString})`;
    return result;
  }
  static toLinearGradient(colorsteps) {
    if (colorsteps.length === 0) {
      return "none";
    }
    var gradient2 = new LinearGradient$1({
      angle: "to right",
      colorsteps
    });
    return gradient2 + "";
  }
  static parse(str) {
    var results = convertMatches(str);
    var angle2 = 0;
    var colorsteps = [];
    results.str.split("(")[1].split(")")[0].split(",").map((it) => it.trim()).forEach((newValue, index2) => {
      if (newValue.includes("@")) {
        newValue = reverseMatches(newValue, results.matches);
        colorsteps.push.apply(colorsteps, ColorStep.parse(newValue));
      } else {
        angle2 = isUndefined(DEFINED_ANGLES$1[newValue]) ? Length.parse(newValue) : Length.deg(+DEFINED_ANGLES$1[newValue]);
      }
    });
    return new LinearGradient$1({ angle: angle2.value, colorsteps });
  }
}
class RepeatingLinearGradient extends LinearGradient$1 {
  getDefaultObject() {
    return super.getDefaultObject({
      type: "repeating-linear-gradient",
      angle: 0
    });
  }
  static parse(str) {
    var linear2 = LinearGradient$1.parse(str);
    return new RepeatingLinearGradient({
      angle: linear2.angle,
      colorsteps: linear2.colorsteps
    });
  }
}
const DEFINED_POSITIONS$1 = {
  ["center"]: true,
  ["top"]: true,
  ["left"]: true,
  ["right"]: true,
  ["bottom"]: true
};
class RadialGradient extends Gradient {
  getDefaultObject(obj2 = {}) {
    return super.getDefaultObject(__spreadValues({
      type: "radial-gradient",
      radialType: "ellipse",
      radialPosition: [Position.CENTER, Position.CENTER]
    }, obj2));
  }
  toCloneObject() {
    return __spreadValues(__spreadValues({}, super.toCloneObject()), this.attrs("radialType", "radialPosition"));
  }
  isRadial() {
    return true;
  }
  toString() {
    if (this.colorsteps.length === 0)
      return "";
    var colorString = this.getColorString();
    var json = this.json;
    var opt = "";
    var radialType = json.radialType;
    var radialPosition = json.radialPosition || ["center", "center"];
    radialPosition = DEFINED_POSITIONS$1[radialPosition] ? radialPosition : radialPosition.join(" ");
    opt = radialPosition ? `${radialType} at ${radialPosition}` : radialType;
    return `${json.type || "radial-gradient"}(${opt}, ${colorString})`;
  }
  static parse(str) {
    var results = convertMatches(str);
    var radialType = "ellipse";
    var radialPosition = [Position.CENTER, Position.CENTER];
    var colorsteps = [];
    results.str.split("(")[1].split(")")[0].split(",").map((it) => it.trim()).forEach((newValue, index2) => {
      if (newValue.includes("@")) {
        newValue = reverseMatches(newValue, results.matches);
        colorsteps.push.apply(colorsteps, ColorStep.parse(newValue));
      } else {
        if (newValue.includes("at")) {
          [radialType, radialPosition] = newValue.split("at").map((it) => it.trim());
        } else {
          radialType = newValue;
        }
        if (typeof radialPosition === "string") {
          var arr = radialPosition.split(" ");
          if (arr.length === 1) {
            var len2 = Length.parse(arr[0]);
            if (len2.isString()) {
              radialPosition = [len2.value, len2.value];
            } else {
              radialPosition = [len2.clone(), len2.clone()];
            }
          } else if (arr.length === 2) {
            radialPosition = arr.map((it) => {
              var len3 = Length.parse(it);
              return len3.isString() ? len3.value : len3.clone();
            });
          }
        }
      }
    });
    return new RadialGradient({ radialType, radialPosition, colorsteps });
  }
}
class RepeatingRadialGradient extends RadialGradient {
  getDefaultObject() {
    return super.getDefaultObject({
      type: "repeating-radial-gradient"
    });
  }
  static parse(str) {
    var radial2 = RadialGradient.parse(str);
    return new RepeatingRadialGradient({
      radialType: radial2.radialType,
      radialPosition: radial2.radialPosition,
      colorsteps: radial2.colorsteps
    });
  }
}
const DEFINED_POSITIONS = {
  ["center"]: true,
  ["top"]: true,
  ["left"]: true,
  ["right"]: true,
  ["bottom"]: true
};
const DEFINED_ANGLES = {
  "to top": 0,
  "to top right": 45,
  "to right": 90,
  "to bottom right": 135,
  "to bottom": 180,
  "to bottom left": 225,
  "to left": 270,
  "to top left": 315
};
class ConicGradient extends Gradient {
  getDefaultObject(obj2 = {}) {
    return super.getDefaultObject(__spreadValues({
      type: "conic-gradient",
      angle: 0,
      radialPosition: [Position.CENTER, Position.CENTER]
    }, obj2));
  }
  toCloneObject() {
    return __spreadProps(__spreadValues({}, super.toCloneObject()), {
      angle: this.json.angle,
      radialPosition: clone$1(this.json.radialPosition)
    });
  }
  isConic() {
    return true;
  }
  hasAngle() {
    return true;
  }
  getColorString() {
    if (this.colorsteps.length === 0)
      return "";
    var colorsteps = this.colorsteps;
    if (!colorsteps)
      return "";
    colorsteps.sort((a, b) => {
      if (a.percent == b.percent)
        return 0;
      return a.percent > b.percent ? 1 : -1;
    });
    var newColors = colorsteps.map((c2, index2) => {
      c2.prevColorStep = c2.cut && index2 > 0 ? colorsteps[index2 - 1] : null;
      return c2;
    });
    return newColors.map((f) => {
      var deg = Math.floor(f.percent * 3.6);
      var prev = "";
      if (f.cut && f.prevColorStep) {
        var prevDeg = Math.floor(f.prevColorStep.percent * 3.6);
        prev = `${prevDeg}deg`;
      }
      return `${f.color} ${prev} ${deg}deg`;
    }).join(",");
  }
  toString() {
    var colorString = this.getColorString();
    var opt = [];
    var json = this.json;
    var conicAngle = json.angle;
    var conicPosition = json.radialPosition || Position.CENTER;
    conicPosition = DEFINED_POSITIONS[conicPosition] ? conicPosition : conicPosition.join(" ");
    if (isNotUndefined(conicAngle)) {
      conicAngle = +(DEFINED_ANGLES[conicAngle] || conicAngle);
      opt.push(`from ${conicAngle}deg`);
    }
    if (conicPosition) {
      opt.push(`at ${conicPosition}`);
    }
    var optString = opt.length ? opt.join(" ") + "," : "";
    return `${json.type}(${optString} ${colorString})`;
  }
  static parse(str) {
    var results = convertMatches(str);
    var angle2 = "0deg";
    var radialPosition = [Position.CENTER, Position.CENTER];
    var colorsteps = [];
    results.str.split("(")[1].split(")")[0].split(",").map((it) => it.trim()).forEach((newValue, index2) => {
      if (newValue.includes("@")) {
        newValue = newValue.split(" ").map((it) => it.trim()).map((it) => {
          if (it.includes("deg")) {
            return Length.parse(it).toPercent();
          } else {
            return it;
          }
        }).join(" ");
        newValue = reverseMatches(newValue, results.matches);
        colorsteps.push.apply(colorsteps, ColorStep.parse(newValue));
      } else {
        if (newValue.includes("at")) {
          [angle2, radialPosition] = newValue.split("at").map((it) => it.trim());
        } else {
          angle2 = newValue;
        }
        if (isString(radialPosition)) {
          var arr = radialPosition.split(" ");
          if (arr.length === 1) {
            var len2 = Length.parse(arr[0]);
            if (len2.isString()) {
              radialPosition = [len2.value, len2.value];
            } else {
              radialPosition = [len2.clone(), len2.clone()];
            }
          } else if (arr.length === 2) {
            radialPosition = arr.map((it) => {
              var len3 = Length.parse(it);
              return len3.isString() ? len3.value : len3;
            });
          }
        }
        if (isString(angle2)) {
          if (angle2.includes("from")) {
            angle2 = angle2.split("from")[1];
            angle2 = isUndefined(DEFINED_ANGLES[angle2]) ? Length.parse(angle2) : Length.deg(+DEFINED_ANGLES[angle2]);
          }
        }
      }
    });
    return new ConicGradient({ angle: angle2.value, radialPosition, colorsteps });
  }
}
class RepeatingConicGradient extends ConicGradient {
  getDefaultObject() {
    return super.getDefaultObject({
      type: "repeating-conic-gradient",
      angle: 0,
      radialPosition: [Position.CENTER, Position.CENTER]
    });
  }
  static parse(str) {
    var conic2 = ConicGradient.parse(str);
    return new RepeatingConicGradient({
      angle: conic2.angle,
      radialPosition: conic2.radialPosition,
      colorsteps: conic2.colorsteps
    });
  }
}
const RepeatList = ["repeat", "no-repeat", "repeat-x", "repeat-y", "round", "space"];
const reg$1 = /((linear\-gradient|repeating\-linear\-gradient|radial\-gradient|repeating\-radial\-gradient|conic\-gradient|repeating\-conic\-gradient|url)\(([^\)]*)\))/gi;
class BackgroundImage extends PropertyItem {
  addImageResource(imageResource) {
    this.clear("image-resource");
    return this.addItem("image-resource", imageResource);
  }
  addGradient(gradient2) {
    return this.addImageResource(gradient2);
  }
  setImageUrl(data) {
    if (!data.images)
      return;
    if (!data.images.length)
      return;
    this.reset({
      type: "image",
      image: BackgroundImage.createImage(data.images[0])
    });
  }
  static createImage(url) {
    return new URLImageResource({ url });
  }
  setGradient(data) {
    this.reset({
      type: data.type,
      image: BackgroundImage.createGradient(data, this.json.image)
    });
  }
  static createGradient(data, gradient2) {
    const colorsteps = data.colorsteps || gradient2.colorsteps;
    const angle2 = data.angle || gradient2.angle;
    const radialType = data.radialType || gradient2.radialType;
    const radialPosition = data.radialPosition || gradient2.radialPosition;
    let json = gradient2.toJSON();
    delete json.itemType;
    delete json.type;
    switch (data.type) {
      case "static-gradient":
        return new StaticGradient(__spreadProps(__spreadValues({}, json), { colorsteps }));
      case "linear-gradient":
        return new LinearGradient$1(__spreadProps(__spreadValues({}, json), { colorsteps, angle: angle2 }));
      case "repeating-linear-gradient":
        return new RepeatingLinearGradient(__spreadProps(__spreadValues({}, json), { colorsteps, angle: angle2 }));
      case "radial-gradient":
        return new RadialGradient(__spreadProps(__spreadValues({}, json), {
          colorsteps,
          radialType,
          radialPosition
        }));
      case "repeating-radial-gradient":
        return new RepeatingRadialGradient(__spreadProps(__spreadValues({}, json), {
          colorsteps,
          radialType,
          radialPosition
        }));
      case "conic-gradient":
        return new ConicGradient(__spreadProps(__spreadValues({}, json), {
          colorsteps,
          angle: angle2,
          radialPosition
        }));
      case "repeating-conic-gradient":
        return new RepeatingConicGradient(__spreadProps(__spreadValues({}, json), {
          colorsteps,
          angle: angle2,
          radialPosition
        }));
    }
    return new Gradient();
  }
  getDefaultObject() {
    return super.getDefaultObject({
      itemType: "background-image",
      checked: false,
      blendMode: "normal",
      size: "auto",
      repeat: "repeat",
      width: Length.percent(100),
      height: Length.percent(100),
      x: Length.percent(0),
      y: Length.percent(0)
    });
  }
  toCloneObject() {
    var json = this.json;
    return __spreadProps(__spreadValues(__spreadValues({}, super.toCloneObject()), this.attrs("checked", "blendMode", "size", "repeat", "width", "height", "x", "y")), {
      image: json.image.clone()
    });
  }
  convert(json) {
    json.x = Length.parse(json.x);
    json.y = Length.parse(json.y);
    if (json.width)
      json.width = Length.parse(json.width);
    if (json.height)
      json.height = Length.parse(json.height);
    if (isString(json.image)) {
      json.image = BackgroundImage.parseImage(json.image);
    }
    return json;
  }
  get image() {
    return this.json.image;
  }
  set image(image2) {
    this.json.image = image2;
  }
  checkField(key, value) {
    if (key === "repeat") {
      return RepeatList.includes(value);
    }
    return super.checkField(key, value);
  }
  toBackgroundImageCSS() {
    if (!this.json.image)
      return {};
    return {
      "background-image": this.json.image.toString()
    };
  }
  toBackgroundPositionCSS() {
    var json = this.json;
    return {
      "background-position": `${json.x} ${json.y}`
    };
  }
  toBackgroundSizeCSS() {
    var json = this.json;
    var backgroundSize = "auto";
    if (json.size == "contain" || json.size == "cover") {
      backgroundSize = json.size;
    } else if (json.width.isPercent() && json.width.isPercent()) {
      if (+json.width !== 100 || +json.height !== 100) {
        backgroundSize = `${json.width} ${json.height}`;
      }
    } else {
      backgroundSize = `${json.width} ${json.height}`;
    }
    return {
      "background-size": backgroundSize
    };
  }
  toBackgroundRepeatCSS() {
    var json = this.json;
    return {
      "background-repeat": json.repeat
    };
  }
  toBackgroundBlendCSS() {
    var json = this.json;
    return {
      "background-blend-mode": json.blendMode
    };
  }
  toCSS() {
    var results = __spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues({}, this.toBackgroundImageCSS()), this.toBackgroundPositionCSS()), this.toBackgroundSizeCSS()), this.toBackgroundRepeatCSS()), this.toBackgroundBlendCSS());
    return results;
  }
  toString() {
    return keyMap(this.toCSS(), (key, value) => {
      return `${key}: ${value}`;
    }).join(";");
  }
  toBackgroundCSS() {
    var obj2 = this.toCSS();
    return {
      "background": `${obj2["background-image"]} `
    };
  }
  static parse(obj2) {
    return new BackgroundImage(obj2);
  }
  static parseImage(str) {
    var results = convertMatches(str);
    let image2 = null;
    var matchResult = results.str.match(reg$1);
    if (!matchResult)
      return image2;
    matchResult.forEach((value, index2) => {
      value = reverseMatches(value, results.matches);
      if (value.includes("repeating-linear-gradient")) {
        image2 = RepeatingLinearGradient.parse(value);
      } else if (value.includes("linear-gradient")) {
        image2 = LinearGradient$1.parse(value);
      } else if (value.includes("repeating-radial-gradient")) {
        image2 = RepeatingRadialGradient.parse(value);
      } else if (value.includes("radial-gradient")) {
        image2 = RadialGradient.parse(value);
      } else if (value.includes("repeating-conic-gradient")) {
        image2 = RepeatingConicGradient.parse(value);
      } else if (value.includes("conic-gradient")) {
        image2 = ConicGradient.parse(value);
      } else if (value.includes("url")) {
        image2 = URLImageResource.parse(value);
      }
    });
    return image2;
  }
  static changeImageType(options2) {
    switch (options2.type) {
      case "static-gradient":
        return new StaticGradient(options2);
      case "linear-gradient":
        return new LinearGradient$1(options2);
      case "repeating-linear-gradient":
        return new RepeatingLinearGradient(options2);
      case "radial-gradient":
        return new RadialGradient(options2);
      case "repeating-radial-gradient":
        return new RepeatingRadialGradient(options2);
      case "conic-gradient":
        return new ConicGradient(options2);
      case "repeating-conic-gradient":
        return new RepeatingConicGradient(options2);
      case "image-resource":
      case "url":
        return new URLImageResource(options2);
    }
  }
  static parseStyle(style) {
    var backgroundImages = [];
    JSON.stringify(style);
    if (style["background-image"]) {
      var results = convertMatches(style["background-image"]);
      results.str.match(reg$1).forEach((value, index2) => {
        let image2 = null;
        value = reverseMatches(value, results.matches);
        if (value.includes("repeating-linear-gradient")) {
          image2 = RepeatingLinearGradient.parse(value);
        } else if (value.includes("linear-gradient")) {
          image2 = LinearGradient$1.parse(value);
        } else if (value.includes("repeating-radial-gradient")) {
          image2 = RepeatingRadialGradient.parse(value);
        } else if (value.includes("radial-gradient")) {
          image2 = RadialGradient.parse(value);
        } else if (value.includes("repeating-conic-gradient")) {
          image2 = RepeatingConicGradient.parse(value);
        } else if (value.includes("conic-gradient")) {
          image2 = ConicGradient.parse(value);
        } else if (value.includes("url")) {
          image2 = URLImageResource.parse(value);
        }
        backgroundImages[index2] = new BackgroundImage({
          type: image2.type,
          image: image2
        });
      });
    }
    if (style["background-repeat"]) {
      style["background-repeat"].split(",").map((it) => it.trim()).forEach((it, index2) => {
        if (backgroundImages[index2]) {
          backgroundImages[index2].repeat = it;
        }
      });
    }
    if (style["background-blend-mode"]) {
      style["background-blend-mode"].split(",").map((it) => it.trim()).forEach((it, index2) => {
        if (backgroundImages[index2]) {
          backgroundImages[index2].blendMode = it;
        }
      });
    }
    if (style["background-size"]) {
      style["background-size"].split(",").map((it) => it.trim()).forEach((it, index2) => {
        if (backgroundImages[index2]) {
          if (it == "cover" || it === "contain" || it === "auto") {
            backgroundImages[index2].size = it;
          } else {
            backgroundImages[index2].size = "auto";
            let [width2, height2] = it.split(" ");
            backgroundImages[index2].width = Length.parse(width2);
            backgroundImages[index2].height = Length.parse(height2);
          }
        }
      });
    }
    if (style["background-position"]) {
      style["background-position"].split(",").map((it) => it.trim()).forEach((it, index2) => {
        if (backgroundImages[index2]) {
          let [x2, y2] = it.split(" ");
          backgroundImages[index2].x = Length.parse(x2);
          backgroundImages[index2].y = Length.parse(y2);
        }
      });
    }
    return backgroundImages;
  }
  static toPropertyCSS(list2) {
    var results = {};
    list2.forEach((item2) => {
      keyEach(item2.toCSS(), (key, value) => {
        if (!results[key])
          results[key] = [];
        results[key].push(value);
      });
    });
    return combineKeyArray(results);
  }
  static join(list2) {
    return CSS_TO_STRING$1(BackgroundImage.toPropertyCSS(list2.map((it) => BackgroundImage.parse(it))));
  }
  static joinCSS(list2) {
    return BackgroundImage.toPropertyCSS(list2.map((it) => BackgroundImage.parse(it)));
  }
}
function makeInterpolateColorStep(layer2, property, startColorStep, endColorStep) {
  var obj2 = {
    cut: makeInterpolateBoolean(layer2, property, startColorStep.cut, endColorStep.cut),
    percent: makeInterpolateNumber$1(layer2, property, startColorStep.percent, endColorStep.percent),
    px: makeInterpolateNumber$1(layer2, property, startColorStep.px, endColorStep.px),
    em: makeInterpolateNumber$1(layer2, property, startColorStep.em, endColorStep.em),
    unit: makeInterpolateString(layer2, property, startColorStep.unit, endColorStep.unit),
    color: makeInterpolateColor(layer2, property, startColorStep.color, endColorStep.color)
  };
  return (rate, t) => {
    return new ColorStep({
      cut: obj2.cut(rate, t),
      percent: obj2.percent(rate, t),
      px: obj2.px(rate, t),
      em: obj2.em(rate, t),
      unit: obj2.unit(rate, t),
      color: obj2.color(rate, t)
    });
  };
}
function makeInterpolateColorStepList(layer2, property, startColorsteps = [], endColorsteps = []) {
  var max = Math.max(startColorsteps.length, endColorsteps.length);
  var list2 = [];
  for (var i = 0; i < max; i++) {
    var s = startColorsteps[i];
    var e2 = endColorsteps[i];
    if (s && e2) {
      list2[i] = makeInterpolateColorStep(layer2, property, s, e2);
    } else {
      list2[i] = makeInterpolateBoolean(layer2, property, s, e2);
    }
  }
  return (rate, t) => {
    return list2.map((it) => it(rate, t));
  };
}
function makeInterpolateLinearGradient(layer2, property, s, e2) {
  var obj2 = {
    angle: makeInterpolateNumber$1(layer2, property, s.angle, e2.angle),
    colorsteps: makeInterpolateColorStepList(layer2, property, s.colorsteps, e2.colorsteps)
  };
  return (rate, t) => {
    var colorsteps = obj2.colorsteps(rate, t);
    return new LinearGradient$1({
      angle: obj2.angle(rate, t),
      colorsteps
    });
  };
}
function makeInterpolateRepeatingLinearGradient(layer2, property, s, e2) {
  var func2 = makeInterpolateLinearGradient(layer2, property, s, e2);
  return (rate, t) => {
    var obj2 = func2(rate, t);
    var results = new RepeatingLinearGradient({
      angle: obj2.angle,
      colorsteps: obj2.colorsteps
    });
    return results;
  };
}
function convertPercent(value, type) {
  switch (type) {
    case "width":
      if (value === "center") {
        return "50%";
      } else if (value === "left") {
        return "0%";
      } else if (value === "right") {
        return "100%";
      }
      break;
    case "height":
      if (value === "center") {
        return "50%";
      } else if (value === "top") {
        return "0%";
      } else if (value === "bottom") {
        return "100%";
      }
      break;
  }
  return value;
}
function makeInterpolateRadialGradient(layer2, property, s, e2) {
  s.radialPosition[0] = convertPercent(s.radialPosition[0], "width");
  s.radialPosition[1] = convertPercent(s.radialPosition[1], "height");
  e2.radialPosition[0] = convertPercent(e2.radialPosition[0], "width");
  e2.radialPosition[1] = convertPercent(e2.radialPosition[1], "height");
  var obj2 = {
    radialType: makeInterpolateString(layer2, property, s.radialType, e2.radialType),
    radialPositionX: makeInterpolateLength(layer2, property, s.radialPosition[0], e2.radialPosition[0], "width", "self"),
    radialPositionY: makeInterpolateLength(layer2, property, s.radialPosition[1], e2.radialPosition[1], "height", "self"),
    colorsteps: makeInterpolateColorStepList(layer2, property, s.colorsteps, e2.colorsteps)
  };
  return (rate, t) => {
    var results = new RadialGradient({
      radialType: obj2.radialType(rate, t),
      radialPosition: [
        obj2.radialPositionX(rate, t),
        obj2.radialPositionY(rate, t)
      ],
      colorsteps: obj2.colorsteps(rate, t)
    });
    return results;
  };
}
function makeInterpolateRepeatingRadialGradient(layer2, property, s, e2) {
  var func2 = makeInterpolateRadialGradient(layer2, property, s, e2);
  return (rate, t) => {
    var obj2 = func2(rate, t);
    return new RepeatingRadialGradient({
      radialType: obj2.radialType,
      radialPosition: obj2.radialPosition,
      colorsteps: obj2.colorsteps
    });
  };
}
function makeInterpolateConicGradient(layer2, property, s, e2) {
  var obj2 = {
    angle: makeInterpolateNumber$1(layer2, property, s.angle, e2.angle),
    radialPositionX: makeInterpolateLength(layer2, property, s.radialPosition[0], e2.radialPosition[0], "width", "self"),
    radialPositionY: makeInterpolateLength(layer2, property, s.radialPosition[1], e2.radialPosition[1], "height", "self"),
    colorsteps: makeInterpolateColorStepList(layer2, property, s.colorsteps, e2.colorsteps)
  };
  return (rate, t) => {
    return new ConicGradient({
      angle: obj2.angle(rate, t),
      radialPosition: [obj2.radialPositionX(rate, t), obj2.radialPositionY(rate, t)],
      colorsteps: obj2.colorsteps(rate, t)
    });
  };
}
function makeInterpolateRepeatingConicGradient(layer2, property, s, e2) {
  var func2 = makeInterpolateConicGradient(layer2, property, s, e2);
  return (rate, t) => {
    var obj2 = func2(rate, t);
    return new RepeatingConicGradient({
      angle: obj2.angle,
      radialPosition: obj2.radialPosition,
      colorsteps: obj2.colorsteps
    });
  };
}
function makeInterpolateImageResource(layer2, property, s, e2) {
  var obj2 = {
    image: (rate, t) => {
      return t;
    }
  };
  if (s.type === "url" || e2.type === "url") {
    obj2.image = makeInterpolateBoolean(layer2, property, s, e2);
  } else {
    if (s.type != e2.type) {
      obj2.image = makeInterpolateBoolean(layer2, property, s, e2);
    } else {
      switch (s.type) {
        case "linear-gradient":
          obj2.image = makeInterpolateLinearGradient(layer2, property, s, e2);
          break;
        case "repeating-linear-gradient":
          obj2.image = makeInterpolateRepeatingLinearGradient(layer2, property, s, e2);
          break;
        case "radial-gradient":
          obj2.image = makeInterpolateRadialGradient(layer2, property, s, e2);
          break;
        case "repeating-radial-gradient":
          obj2.image = makeInterpolateRepeatingRadialGradient(layer2, property, s, e2);
          break;
        case "conic-gradient":
          obj2.image = makeInterpolateConicGradient(layer2, property, s, e2);
          break;
        case "repeating-conic-gradient":
          obj2.image = makeInterpolateRepeatingConicGradient(layer2, property, s, e2);
          break;
      }
    }
  }
  return (rate, t) => {
    return obj2.image(rate, t);
  };
}
function makeInterpolateBackgroundImage(layer2, property, startValue, endValue) {
  var s = BackgroundImage.parseStyle(STRING_TO_CSS(startValue));
  var e2 = BackgroundImage.parseStyle(STRING_TO_CSS(endValue));
  var totalLength = Math.max(s.length, e2.length);
  var list2 = [];
  for (var i = 0, len2 = totalLength; i < len2; i++) {
    var startObject = s[i] || null;
    var endObject = e2[i] || null;
    if (startObject && !endObject) {
      list2.push({
        image: makeInterpolateIdentity(layer2, property, startObject.image),
        size: makeInterpolateIdentity(layer2, property, startObject.size),
        width: makeInterpolateIdentity(layer2, property, startObject.width),
        height: makeInterpolateIdentity(layer2, property, startObject.height),
        x: makeInterpolateIdentity(layer2, property, startObject.x),
        y: makeInterpolateIdentity(layer2, property, startObject.y),
        blendMode: makeInterpolateIdentity(layer2, property, startObject.blendMode),
        repeat: makeInterpolateIdentity(layer2, property, startObject.repeat)
      });
    } else if (!startObject && endObject) {
      list2.push({
        image: makeInterpolateIdentity(layer2, property, endObject.image),
        size: makeInterpolateIdentity(layer2, property, endObject.size),
        width: makeInterpolateIdentity(layer2, property, endObject.width),
        height: makeInterpolateIdentity(layer2, property, endObject.height),
        x: makeInterpolateIdentity(layer2, property, endObject.x),
        y: makeInterpolateIdentity(layer2, property, endObject.y),
        blendMode: makeInterpolateIdentity(layer2, property, endObject.blendMode),
        repeat: makeInterpolateIdentity(layer2, property, endObject.repeat)
      });
    } else if (startObject && endObject) {
      list2.push({
        image: makeInterpolateImageResource(layer2, property, startObject.image, endObject.image),
        size: makeInterpolateString(layer2, property, startObject.size, endObject.size),
        width: makeInterpolateLength(layer2, property, startObject.width, endObject.width, "width", "self"),
        height: makeInterpolateLength(layer2, property, startObject.height, endObject.height, "height", "self"),
        x: makeInterpolateLength(layer2, property, startObject.x, endObject.x, "width", "self"),
        y: makeInterpolateLength(layer2, property, startObject.y, endObject.y, "height", "self"),
        blendMode: makeInterpolateString(layer2, property, startObject.blendMode, endObject.blendMode),
        repeat: makeInterpolateString(layer2, property, startObject.repeat, endObject.repeat)
      });
    }
  }
  return (rate, t) => {
    return BackgroundImage.join(list2.map((it) => {
      var data = {
        image: it.image(rate, t),
        size: it.size(rate, t),
        x: it.x(rate, t),
        y: it.y(rate, t),
        width: it.width(rate, t),
        height: it.height(rate, t),
        blendMode: it.blendMode(rate, t),
        repeat: it.repeat(rate, t)
      };
      return data;
    }));
  };
}
const FILTER_REG = /((blur|drop\-shadow|hue\-rotate|invert|brightness|contrast|opacity|saturate|sepia|url)\(([^\)]*)\))/gi;
class Filter extends PropertyItem {
  getDefaultObject(obj2 = {}) {
    return super.getDefaultObject(__spreadValues({
      itemType: "filter"
    }, obj2));
  }
  toString() {
    return `${this.json.type}(${this.json.value || ""})`;
  }
  static parse(obj2) {
    var FilterClass = FilterClassName[obj2.type];
    if (FilterClass) {
      return new FilterClass(obj2);
    } else {
      return new URLSvgFilter({
        value: obj2.value
      });
    }
  }
  static parseStyle(filter2) {
    var filters = [];
    if (!filter2)
      return filters;
    var results = convertMatches(filter2);
    var matches2 = results.str.match(FILTER_REG) || [];
    matches2.forEach((value, index2) => {
      var [filterName, filterValue] = value.split("(");
      filterValue = filterValue.split(")")[0];
      if (filterName === "drop-shadow") {
        var arr = filterValue.split(" ");
        var colors2 = arr.filter((it) => it.includes("@")).map((it) => {
          return reverseMatches(it, results.matches);
        });
        var values = arr.filter((it) => !it.includes("@"));
        filters[index2] = Filter.parse({
          type: filterName,
          offsetX: Length.parse(values[0]),
          offsetY: Length.parse(values[1]),
          blurRadius: Length.parse(values[2]),
          color: colors2[0] || "rgba(0, 0, 0, 1)"
        });
      } else {
        filters[index2] = Filter.parse({
          type: filterName,
          value: Length.parse(filterValue)
        });
      }
    });
    return filters;
  }
  static join(list2) {
    return list2.map((it) => Filter.parse(it)).join(" ");
  }
}
class BlurFilter extends Filter {
  getDefaultObject() {
    return super.getDefaultObject({
      type: "blur",
      value: BlurFilter.spec.defaultValue
    });
  }
  toCloneObject() {
    return __spreadValues(__spreadValues({}, super.toCloneObject()), this.attrs("value"));
  }
}
BlurFilter.spec = {
  inputType: "range",
  min: 0,
  max: 100,
  step: 1,
  unit: "px",
  units: ["px", "em"],
  defaultValue: "0px"
};
class URLSvgFilter extends Filter {
  getDefaultObject() {
    return super.getDefaultObject({
      type: "svg",
      value: URLSvgFilter.spec.defaultValue
    });
  }
  toCloneObject() {
    return __spreadValues(__spreadValues({}, super.toCloneObject()), this.attrs("value"));
  }
  toString() {
    return `url(#${this.json.value || ""})`;
  }
}
URLSvgFilter.spec = {
  inputType: "select",
  defaultValue: ""
};
class GrayscaleFilter extends Filter {
  getDefaultObject() {
    return super.getDefaultObject({
      type: "grayscale",
      value: GrayscaleFilter.spec.defaultValue
    });
  }
  toCloneObject() {
    return __spreadValues(__spreadValues({}, super.toCloneObject()), this.attrs("value"));
  }
}
GrayscaleFilter.spec = {
  inputType: "range",
  min: 0,
  max: 100,
  step: 1,
  unit: "%",
  units: ["%"],
  defaultValue: Length.percent(0)
};
class HueRotateFilter extends Filter {
  getDefaultObject() {
    return super.getDefaultObject({
      type: "hue-rotate",
      value: HueRotateFilter.spec.defaultValue
    });
  }
}
HueRotateFilter.spec = {
  inputType: "range",
  min: 0,
  max: 360,
  step: 1,
  unit: "deg",
  units: ["deg"],
  defaultValue: Length.deg(0)
};
class InvertFilter extends Filter {
  getDefaultObject() {
    return super.getDefaultObject({
      type: "invert",
      value: InvertFilter.spec.defaultValue
    });
  }
}
InvertFilter.spec = {
  inputType: "range",
  min: 0,
  max: 100,
  step: 1,
  unit: "%",
  units: ["%"],
  defaultValue: Length.percent(0)
};
class BrightnessFilter extends Filter {
  getDefaultObject() {
    return super.getDefaultObject({
      type: "brightness",
      value: BrightnessFilter.spec.defaultValue
    });
  }
}
BrightnessFilter.spec = {
  inputType: "range",
  min: 0,
  max: 200,
  step: 1,
  unit: "%",
  units: ["%"],
  defaultValue: Length.percent(100)
};
class ContrastFilter extends Filter {
  getDefaultObject() {
    return super.getDefaultObject({
      type: "contrast",
      value: ContrastFilter.spec.defaultValue
    });
  }
}
ContrastFilter.spec = {
  inputType: "range",
  min: 0,
  max: 200,
  step: 1,
  unit: "%",
  units: ["%"],
  defaultValue: Length.percent(100)
};
class OpacityFilter extends Filter {
  getDefaultObject() {
    return super.getDefaultObject({
      type: "opacity",
      value: OpacityFilter.spec.defaultValue
    });
  }
}
OpacityFilter.spec = {
  inputType: "range",
  min: 0,
  max: 100,
  step: 1,
  unit: "%",
  units: ["%"],
  defaultValue: Length.percent(100)
};
class SaturateFilter extends Filter {
  getDefaultObject() {
    return super.getDefaultObject({
      type: "saturate",
      value: SaturateFilter.spec.defaultValue
    });
  }
}
SaturateFilter.spec = {
  inputType: "range",
  min: 0,
  max: 100,
  step: 1,
  unit: "%",
  units: ["%"],
  defaultValue: Length.percent(100)
};
class SepiaFilter extends Filter {
  getDefaultObject() {
    return super.getDefaultObject({
      type: "sepia",
      value: SepiaFilter.spec.defaultValue
    });
  }
}
SepiaFilter.spec = {
  inputType: "range",
  min: 0,
  max: 100,
  step: 1,
  unit: "%",
  units: ["%"],
  defaultValue: Length.percent(0)
};
class DropshadowFilter extends Filter {
  getDefaultObject() {
    return super.getDefaultObject({
      type: "drop-shadow",
      multi: true,
      offsetX: DropshadowFilter.spec.offsetX.defaultValue,
      offsetY: DropshadowFilter.spec.offsetY.defaultValue,
      blurRadius: DropshadowFilter.spec.blurRadius.defaultValue,
      color: DropshadowFilter.spec.color.defaultValue
    });
  }
  toString() {
    var json = this.json;
    return `drop-shadow(${json.offsetX} ${json.offsetY} ${json.blurRadius} ${json.color})`;
  }
}
DropshadowFilter.spec = {
  offsetX: {
    title: "Offset X",
    inputType: "range",
    min: -100,
    max: 100,
    step: 1,
    defaultValue: "0px",
    unit: "px",
    units: ["px", "em"]
  },
  offsetY: {
    title: "Offset Y",
    inputType: "range",
    min: -100,
    max: 100,
    step: 1,
    defaultValue: "0px",
    unit: "px",
    units: ["px", "em"]
  },
  blurRadius: {
    title: "Blur Radius",
    inputType: "range",
    min: 0,
    max: 100,
    step: 1,
    defaultValue: "0px",
    unit: "px",
    units: ["px", "em", "%"]
  },
  color: {
    title: "Color",
    inputType: "color",
    defaultValue: "rgba(0, 0, 0, 1)",
    unit: "color"
  }
};
const FilterClassName = {
  blur: BlurFilter,
  grayscale: GrayscaleFilter,
  "hue-rotate": HueRotateFilter,
  invert: InvertFilter,
  brightness: BrightnessFilter,
  contrast: ContrastFilter,
  opacity: OpacityFilter,
  saturate: SaturateFilter,
  sepia: SepiaFilter,
  "drop-shadow": DropshadowFilter,
  svg: URLSvgFilter
};
function makeInterpolateFilterItem(layer2, property, startValue, endValue) {
  var obj2 = {
    type: makeInterpolateString(layer2, property, startValue.type, endValue.type),
    value: makeInterpolateBoolean(layer2, property, startValue.value, endValue.value)
  };
  switch (startValue.type) {
    case "blur":
      obj2.value = makeInterpolateLength(layer2, property, startValue.value, endValue.value);
      break;
    case "grayscale":
    case "invert":
    case "brightness":
    case "contrast":
    case "opacity":
    case "saturate":
    case "sepia":
    case "hue-rotate":
      obj2.value = makeInterpolateNumber$1(layer2, property, startValue.value.value, endValue.value.value, startValue.value.unit);
      break;
    case "drop-shadow":
      obj2.offsetX = makeInterpolateLength(layer2, property, startValue.offsetX, endValue.offsetX, "width", "self");
      obj2.offsetY = makeInterpolateLength(layer2, property, startValue.offsetY, endValue.offsetY, "height", "self");
      obj2.blurRadius = makeInterpolateLength(layer2, property, startValue.blurRadius, endValue.blurRadius, "width", "self");
      obj2.spreadRadius = makeInterpolateLength(layer2, property, startValue.spreadRadius, endValue.spreadRadius, "width", "self");
      obj2.color = makeInterpolateColor(layer2, property, startValue.color, endValue.color);
      break;
  }
  return (rate, t) => {
    var type = obj2.type(rate, t);
    if (type === "drop-shadow") {
      return {
        type: obj2.type(rate, t),
        offsetX: obj2.offsetX(rate, t),
        offsetY: obj2.offsetY(rate, t),
        blurRadius: obj2.blurRadius(rate, t),
        spreadRadius: obj2.spreadRadius(rate, t),
        color: obj2.color(rate, t)
      };
    } else {
      return {
        type: obj2.type(rate, t),
        value: obj2.value(rate, t)
      };
    }
  };
}
function makeInterpolateFilter(layer2, property, startValue, endValue) {
  var s = Filter.parseStyle(startValue);
  var e2 = Filter.parseStyle(endValue);
  var totalLength = Math.max(s.length, e2.length);
  var list2 = [];
  for (var i = 0, len2 = totalLength; i < len2; i++) {
    var startObject = s[i];
    var endObject = e2[i];
    if (startObject && !endObject) {
      list2.push(makeInterpolateIdentity(layer2, property, startObject));
    } else if (!startObject && endObject) {
      list2.push(makeInterpolateIdentity(layer2, property, endObject));
    } else {
      if (startObject.type != endObject.type || startObject.type === "svg" || endObject.type === "svg") {
        list2.push(makeInterpolateBoolean(layer2, property, startObject, endObject));
      } else {
        list2.push(makeInterpolateFilterItem(layer2, property, startObject, endObject));
      }
    }
  }
  return (rate, t) => {
    return Filter.join(list2.map((it) => it(rate, t)));
  };
}
class DirectionLength {
  static parse(str) {
    var temp = str.split(" ").filter((it) => it.trim()).map((it) => Length.parse(it));
    var top2 = Length.percent(0), right2 = Length.percent(0), bottom2 = Length.percent(0), left2 = Length.percent(0);
    if (temp.length === 1) {
      top2 = temp[0].clone();
      right2 = temp[0].clone();
      bottom2 = temp[0].clone();
      left2 = temp[0].clone();
    } else if (temp.length === 2) {
      top2 = temp[0].clone();
      right2 = temp[1].clone();
      bottom2 = temp[0].clone();
      left2 = temp[1].clone();
    } else if (temp.length === 3) {
      top2 = temp[0].clone();
      right2 = temp[1].clone();
      bottom2 = temp[2].clone();
      left2 = temp[1].clone();
    } else if (temp.length === 4) {
      top2 = temp[0].clone();
      right2 = temp[1].clone();
      bottom2 = temp[2].clone();
      left2 = temp[3].clone();
    }
    return [temp.length, top2, right2, bottom2, left2];
  }
}
const CLIPPATH_REG = /(content\-box|padding\-box|border\-box|margin\-box|view\-box|stroke\-box|fill\-box|none|(inset|circle|ellipse|polygon|path|svg|url)(\(([^\)]*)\))?)/gi;
class ClipPath extends PropertyItem {
  getDefaultObject(obj2 = {}) {
    return super.getDefaultObject(__spreadValues({
      itemType: "clip-path",
      type: "none",
      value: ""
    }, obj2));
  }
  toCloneObject() {
    return __spreadValues(__spreadValues({}, super.toCloneObject()), this.attrs("value"));
  }
  toString() {
    var type = this.json.type;
    var value = this.json.value;
    var box = this.json.box;
    var results = "";
    switch (type) {
      case "circle":
      case "inset":
      case "ellipse":
      case "polygon":
      case "path":
        results = `${type}(${value})`;
        break;
      case "svg":
        results = `url(#${value})`;
        break;
      default:
        results = "none";
        break;
    }
    return box ? `${box} ${results}` : results;
  }
  toCSS() {
    return {
      "clip-path": this.toString()
    };
  }
  static toCSS(obj2) {
    return new ClipPath(obj2).toCSS();
  }
  static toString(obj2) {
    return ClipPath.toCSS(obj2)["clip-path"];
  }
  static parse(obj2) {
    return new ClipPath(obj2);
  }
  static parseStyle(str) {
    var clippath = {};
    if (!str)
      return {};
    var matches2 = str.match(CLIPPATH_REG) || [];
    matches2.forEach((value, index2) => {
      if (value.includes("-box")) {
        clippath.box = value;
      } else {
        var [clipPathName, clipPathValue] = value.split("(");
        clipPathValue = clipPathValue || "";
        if (clipPathName === "none") {
          clipPathValue = "";
        } else {
          clipPathValue = clipPathValue.split(")")[0];
        }
        clippath.type = clipPathName;
        clippath.value = clipPathValue;
      }
    });
    return clippath;
  }
  static parseStyleForCircle(str) {
    var radius = new Length("", "closest-side"), position2 = "";
    str = str || "50%";
    if (str.includes("at")) {
      [radius, position2] = str.split("at").map((it) => it.trim());
    } else {
      position2 = str.trim();
    }
    var [x2, y2] = position2.split(" ");
    if (isUndefined(y2)) {
      y2 = x2;
    }
    x2 = Length.parse(x2);
    y2 = Length.parse(y2);
    return {
      radius,
      x: x2,
      y: y2
    };
  }
  static parseStyleForEllipse(str = "50% 50%") {
    var radius = `50% 50%`, position2 = "";
    str = str || "50%";
    if (str.includes("at")) {
      [radius, position2] = str.split("at").map((it) => it.trim());
    } else {
      position2 = str.trim();
    }
    var [x2, y2] = position2.split(" ");
    if (isUndefined(y2)) {
      y2 = x2;
    }
    x2 = Length.parse(x2);
    y2 = Length.parse(y2);
    var [radiusX, radiusY] = radius.split(" ");
    if (isUndefined(radiusY)) {
      radiusY = radiusX;
    }
    radiusX = Length.parse(radiusX);
    radiusY = Length.parse(radiusY);
    return {
      radiusX,
      radiusY,
      x: x2,
      y: y2
    };
  }
  static parseStyleForInset(str = "") {
    var [inset, round2] = str.split("round");
    var [_count, top2, right2, bottom2, left2] = DirectionLength.parse(inset);
    if (round2) {
      var [_roundCount, topRadius, rightRadius, bottomRadius, leftRadius] = DirectionLength.parse(round2);
    }
    return {
      isAll: _count === 1,
      top: top2,
      right: right2,
      bottom: bottom2,
      left: left2,
      round: round2,
      isAllRadius: _roundCount === 1,
      topRadius,
      rightRadius,
      bottomRadius,
      leftRadius
    };
  }
  static parseStyleForPolygon(str = "") {
    return str.split(",").filter((it) => it.trim()).map((it) => {
      var [x2, y2] = it.trim().split(" ");
      return {
        x: Length.parse(x2),
        y: Length.parse(y2)
      };
    });
  }
}
function makeInterpolateClipPathCircle(layer2, property, s, e2) {
  var obj2 = {};
  if (s.radius === "closest-side" || s.radius === "farthest-side" || e2.radius === "closest-side" || e2.radius === "farthest-side") {
    obj2.radius = makeInterpolateBoolean(layer2, property, s.radius, e2.radius);
  } else {
    if (s.radius.unit === e2.radius.unit) {
      obj2.radius = makeInterpolateNumber(layer2, property, s.radius.value, e2.radius.value, s.radius.unit);
    } else {
      obj2.radius = makeInterpolateLength(layer2, property, s.radius, e2.radius, "width", "self");
    }
  }
  obj2.x = makeInterpolateLength(layer2, property, s.x, e2.x, "width", "self");
  obj2.y = makeInterpolateLength(layer2, property, s.y, e2.y, "height", "self");
  return (rate, t) => {
    var radius = obj2.radius(rate, t);
    var x2 = obj2.x(rate, t);
    var y2 = obj2.y(rate, t);
    var results = `${x2} ${y2}`;
    var radiusString = radius + "";
    if (radiusString.includes("closest-side")) {
      radiusString = "closest-side";
    } else if (radiusString.includes("farthest-side")) {
      radiusString = "farthest-side";
    }
    return radius ? `${radiusString} at ${results}` : `${results}`;
  };
}
function makeInterpolateClipPathEllipse(layer2, property, s, e2) {
  var obj2 = {
    radiusX: makeInterpolateLength(layer2, property, s.radiusX, e2.radiusX, "width", "self"),
    radiusY: makeInterpolateLength(layer2, property, s.radiusY, e2.radiusY, "height", "self"),
    x: makeInterpolateLength(layer2, property, s.x, e2.x, "width", "self"),
    y: makeInterpolateLength(layer2, property, s.y, e2.y, "height", "self")
  };
  return (rate, t) => {
    var radiusX = obj2.radiusX(rate, t);
    var radiusY = obj2.radiusY(rate, t);
    var x2 = obj2.x(rate, t);
    var y2 = obj2.y(rate, t);
    return `${radiusX} ${radiusY} at ${x2} ${y2}`;
  };
}
function makeInterpolateClipPathPolygon(layer2, property, s, e2) {
  var max = Math.max(s.length, e2.length);
  var list2 = [];
  for (var i = 0; i < max; i++) {
    var startPos = s[i];
    var endPos = e2[i];
    if (startPos && !endPos) {
      list2.push({
        x: makeInterpolateIdentity(layer2, property, startPos.x),
        y: makeInterpolateIdentity(layer2, property, startPos.y)
      });
    } else if (!startPos && endPos) {
      list2.push({
        x: makeInterpolateIdentity(layer2, property, endPos.x),
        y: makeInterpolateIdentity(layer2, property, endPos.y)
      });
    } else {
      list2.push({
        x: makeInterpolateLength(layer2, property, startPos.x, endPos.x, "width", "self"),
        y: makeInterpolateLength(layer2, property, startPos.y, endPos.y, "height", "self")
      });
    }
  }
  return (rate, t) => {
    return list2.map((it) => {
      return `${it.x(rate, t)} ${it.y(rate, t)}`;
    }).join(",");
  };
}
function makeInterpolateClipPathInset(layer2, property, s, e2) {
  var obj2 = {
    top: makeInterpolateNumber$1(layer2, property, s.top.value, e2.top.value, s.top.unit),
    left: makeInterpolateNumber$1(layer2, property, s.left.value, e2.left.value, s.left.unit),
    right: makeInterpolateNumber$1(layer2, property, s.right.value, e2.right.value, s.right.unit),
    bottom: makeInterpolateNumber$1(layer2, property, s.bottom.value, e2.bottom.value, s.bottom.unit),
    round: makeInterpolateBoolean(layer2, property, s.round, e2.round),
    topRadius: makeInterpolateNumber$1(layer2, property, s.topRadius.value, e2.topRadius.value, s.topRadius.unit),
    leftRadius: makeInterpolateNumber$1(layer2, property, s.leftRadius.value, e2.leftRadius.value, s.leftRadius.unit),
    rightRadius: makeInterpolateNumber$1(layer2, property, s.rightRadius.value, e2.rightRadius.value, s.rightRadius.unit),
    bottomRadius: makeInterpolateNumber$1(layer2, property, s.bottomRadius.value, e2.bottomRadius.value, s.bottomRadius.unit)
  };
  return (rate, t) => {
    var top2 = obj2.top(rate, t);
    var right2 = obj2.right(rate, t);
    var bottom2 = obj2.bottom(rate, t);
    var left2 = obj2.left(rate, t);
    var round2 = obj2.round(rate, t);
    var topRadius = obj2.topRadius(rate, t);
    var leftRadius = obj2.leftRadius(rate, t);
    var bottomRadius = obj2.bottomRadius(rate, t);
    var rightRadius = obj2.rightRadius(rate, t);
    var position2 = [top2, right2, bottom2, left2].join(" ");
    var radius = [topRadius, rightRadius, bottomRadius, leftRadius].join(" ");
    var results = `${position2} ${round2 && radius.trim() ? `round ${radius}` : ""}`;
    return results;
  };
}
function makeInterpolateClipPath(layer2, property, startValue, endValue) {
  var startObject = ClipPath.parseStyle(startValue);
  var endObject = ClipPath.parseStyle(endValue);
  var obj2 = {
    type: makeInterpolateBoolean(layer2, property, startObject.type, startObject.type),
    value: makeInterpolateBoolean(layer2, property, startValue, endValue)
  };
  if (startObject.type == endObject.type && startObject != "none") {
    switch (startObject.type) {
      case "circle":
        startObject.value = ClipPath.parseStyleForCircle(startObject.value);
        endObject.value = ClipPath.parseStyleForCircle(endObject.value);
        obj2.value = makeInterpolateClipPathCircle(layer2, property, startObject.value, endObject.value);
        break;
      case "ellipse":
        startObject.value = ClipPath.parseStyleForEllipse(startObject.value);
        endObject.value = ClipPath.parseStyleForEllipse(endObject.value);
        obj2.value = makeInterpolateClipPathEllipse(layer2, property, startObject.value, endObject.value);
        break;
      case "inset":
        startObject.value = ClipPath.parseStyleForInset(startObject.value);
        endObject.value = ClipPath.parseStyleForInset(endObject.value);
        obj2.value = makeInterpolateClipPathInset(layer2, property, startObject.value, endObject.value);
        break;
      case "polygon":
        startObject.value = ClipPath.parseStyleForPolygon(startObject.value);
        endObject.value = ClipPath.parseStyleForPolygon(endObject.value);
        obj2.value = makeInterpolateClipPathPolygon(layer2, property, startObject.value, endObject.value);
        break;
      case "path":
        startObject.value = ClipPath.parseStyleForPath(startObject.value);
        endObject.value = ClipPath.parseStyleForPath(endObject.value);
        obj2.value = makeInterpolateClipPathPath(layer2, property, startObject.value, endObject.value);
        break;
    }
  }
  return (rate, t) => {
    var type = obj2.type(rate, t);
    var value = obj2.value(rate, t);
    if (type === "none") {
      return type;
    }
    return `${type}(${value})`;
  };
}
const MAX_CACHE_COUNT$1 = 1e3;
const cachedTransformMap = new Map();
class TransformCache {
  static has(key) {
    return cachedTransformMap.has(key);
  }
  static get(key) {
    return cachedTransformMap.get(key);
  }
  static set(key, parsedValue) {
    if (cachedTransformMap.size > MAX_CACHE_COUNT$1) {
      cachedTransformMap.clear();
    }
    cachedTransformMap.set(key, parsedValue);
  }
}
const TRANSFORM_REG = /((matrix|translate(X|Y|Z|3d)?|scale(X|Y|Z|3d)?|rotate(X|Y|Z|3d)?|skew(X|Y)?|matrix(3d)?|perspective)\(([^\)]*)\))/gi;
class Transform extends PropertyItem {
  getDefaultObject() {
    return {
      itemType: "transform",
      value: []
    };
  }
  toCloneObject() {
    return __spreadValues({}, this.attrs("itemType", "type", "value"));
  }
  toString() {
    return `${this.json.type}(${this.json.value.join(", ") || ""})`;
  }
  static join(list2) {
    var firstType = "perspective";
    var lastType = "matrix3d";
    var arr = list2.filter((it) => it.type === firstType);
    var last2 = list2.filter((it) => it.type === lastType);
    var arr2 = list2.filter((it) => it.type !== firstType && it.type !== lastType);
    return [...arr, ...arr2, ...last2].map((it) => new Transform(it).toString()).join(" ");
  }
  hasNumberValue() {
    var type = this.json.type;
    return type.includes("matrix") || type.includes("scale");
  }
  static parse(transform2) {
    return new Transform(transform2);
  }
  static remove(transform2, type = []) {
    if (typeof type === "string") {
      type = [type];
    }
    return Transform.filter(transform2, (it) => {
      return type.includes(it.type) === false;
    });
  }
  static filter(transform2, filterFunction) {
    return Transform.join(Transform.parseStyle(transform2, false).filter((it) => filterFunction(it)));
  }
  static replace(transform2, valueObject) {
    var obj2 = Transform.parseStyle(transform2, false);
    var tObject = obj2.find((t) => t.type === valueObject.type);
    if (tObject) {
      tObject.value = valueObject.value;
    } else {
      obj2.push(valueObject);
    }
    return Transform.join(obj2);
  }
  static replaceAll(oldTransform, newTransform) {
    var oldT = Transform.parseStyle(oldTransform, false);
    var newT = Transform.parseStyle(newTransform);
    for (var i = 0, len2 = newT.length; i < len2; i++) {
      var newObject = newT[i];
      var oldObject = oldT.find((t) => t.type === newObject.type);
      if (oldObject) {
        oldObject.value = newObject.value;
      } else {
        oldT.push(newObject);
      }
    }
    return Transform.join(oldT);
  }
  static addTransform(oldTransform, newTransform) {
    var oldT = Transform.parseStyle(oldTransform, false);
    var newT = Transform.parseStyle(newTransform);
    for (var i = 0, len2 = newT.length; i < len2; i++) {
      var newObject = newT[i];
      var oldObject = oldT.find((t) => t.type === newObject.type);
      if (oldObject) {
        newObject.value.forEach((v, i2) => {
          oldObject.value[i2].value += v.value;
        });
      } else {
        oldT.push(newObject);
      }
    }
    return Transform.join(oldT);
  }
  static get(transform2, type) {
    var arr = Transform.parseStyle(transform2, true);
    if (typeof type === "function") {
      arr = arr.find(type);
    } else {
      arr = arr.find((it) => it.type === type);
    }
    if (arr) {
      return arr.value;
    }
    return void 0;
  }
  static createRotateKey(transform2, angle2, field) {
    return `${transform2}:::${field}(${angle2})`;
  }
  static rotate(transform2, angle2, field = "rotate") {
    const key = Transform.createRotateKey(transform2, angle2, field);
    if (TransformCache.has(key))
      return TransformCache.get(key);
    TransformCache.set(key, Transform.replace(transform2, { type: field, value: [angle2] }));
    return TransformCache.get(key);
  }
  static rotateZ(transform2, angle2) {
    return Transform.rotate(transform2, angle2, "rotateZ");
  }
  static rotateX(transform2, angle2) {
    return Transform.rotate(transform2, angle2, "rotateX");
  }
  static rotateY(transform2, angle2) {
    return Transform.rotate(transform2, angle2, "rotateY");
  }
  static parseStyle(transform2, doCache = true) {
    var transforms = [];
    if (!transform2)
      return transforms;
    if (doCache && TransformCache.has(transform2)) {
      return TransformCache.get(transform2);
    }
    var matches2 = transform2.match(TRANSFORM_REG) || [];
    matches2.forEach((value, index2) => {
      var [transformName, transformValue] = value.split("(");
      transformValue = transformValue.split(")")[0];
      var arr = transformValue.split(",");
      if (transformValue.includes("matrix") || transformValue.includes("scale")) {
        arr = arr.map((it) => Length.number(it.trim()));
      } else {
        arr = arr.map((it) => Length.parse(it.trim()));
      }
      transforms[index2] = Transform.parse({
        type: transformName,
        value: arr
      });
    });
    if (doCache) {
      TransformCache.set(transform2, transforms);
    }
    return transforms;
  }
  static createTransformMatrix(parsedTransformList, width2, height2) {
    const view = create$5();
    for (let i = 0, len2 = parsedTransformList.length; i < len2; i++) {
      const it = parsedTransformList[i];
      switch (it.type) {
        case "translate":
        case "translateX":
        case "translateY":
        case "translateZ":
          var values = it.value;
          if (it.type === "translate") {
            values = [values[0].toPx(width2).value, values[1].toPx(height2).value, 0];
          } else if (it.type === "translateX") {
            values = [values[0].toPx(width2).value, 0, 0];
          } else if (it.type === "translateY") {
            values = [0, values[0].toPx(height2).value, 0];
          } else if (it.type === "translateZ") {
            values = [0, 0, values[0].toPx().value];
          }
          translate(view, view, values);
          break;
        case "rotate":
        case "rotateZ":
          rotateZ(view, view, degreeToRadian$1(it.value[0].value));
          break;
        case "rotateX":
          rotateX(view, view, degreeToRadian$1(it.value[0].value));
          break;
        case "rotateY":
          rotateY(view, view, degreeToRadian$1(it.value[0].value));
          break;
        case "rotate3d":
          var values = it.value;
          rotate$1(view, view, degreeToRadian$1(it.value[3].value), [
            values[0].value,
            values[1].value,
            values[2].value
          ]);
          break;
        case "scale":
          scale$1(view, view, [it.value[0].value, it.value[1].value, 1]);
          break;
        case "scaleX":
          scale$1(view, view, [it.value[0].value, 1, 1]);
          break;
        case "scaleY":
          scale$1(view, view, [1, it.value[0].value, 1]);
          break;
        case "scaleZ":
          scale$1(view, view, [1, 1, it.value[0].value]);
          break;
        case "skewX":
          var rad = it.value[0].toDeg().toRad();
          multiply$1(view, view, fromValues$1(1, 0, 0, 0, Math.tan(rad.value), 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1));
          break;
        case "skewY":
          var rad = it.value[0].toDeg().toRad();
          multiply$1(view, view, fromValues$1(1, Math.tan(rad.value), 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1));
          break;
        case "skew":
          const skewX = it.value[0].toDeg().toRad();
          const skewY = it.value.length > 1 ? it.value[1].toDeg().toRad() : skewX;
          multiply$1(view, view, fromValues$1(1, Math.tan(skewY.value), 0, 0, Math.tan(skewX.value), 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1));
          break;
        case "matrix":
          var values = it.value;
          values = [
            values[0].value,
            values[1].value,
            0,
            0,
            values[2].value,
            values[3].value,
            0,
            0,
            0,
            0,
            1,
            0,
            values[4].value,
            values[5].value,
            0,
            1
          ];
          multiply$1(view, view, values);
          break;
        case "matrix3d":
          var values = it.value.map((it2) => it2.value);
          multiply$1(view, view, values);
          break;
        case "perspective":
          var values = it.value;
          perspective$1(view, Math.PI * 0.5, width2 / height2, 1, values[0].value);
          break;
      }
    }
    return view;
  }
  static fromScale(scale2) {
    if (scale2[0] === 1 && scale2[1] === 1) {
      return "";
    }
    const list2 = [];
    if (scale2[0] != 1)
      list2.push(`scaleX(${scale2[0]})`);
    if (scale2[1] != 1)
      list2.push(`scaleY(${scale2[1]})`);
    if (scale2[2] != 1)
      list2.push(`scaleZ(${scale2[2]})`);
    return list2.join(" ");
  }
}
function makeInterpolateTransformLength(layer2, property, startValue, endValue) {
  var obj2 = {
    type: makeInterpolateBoolean(layer2, property, startValue.type, endValue.type)
  };
  var value = [];
  var max = Math.max(startValue.value.length, endValue.value.length);
  for (var i = 0; i < max; i++) {
    var s = startValue.value[i];
    var e2 = endValue.value[i];
    if (s && e2) {
      value.push(makeInterpolateLength(layer2, property, s, e2, startValue.type));
    } else {
      value.push(makeInterpolateLength(layer2, property, startValue.value[i] || startValue.value[i - 1] || startValue.value[i - 2], endValue.value[i] || endValue.value[i - 1] || endValue.value[i - 2], startValue.type));
    }
  }
  obj2.value = value;
  return (rate, t) => {
    return {
      type: obj2.type(rate, t),
      value: obj2.value.map((it) => it(rate, t))
    };
  };
}
function makeInterpolateTransformNumber(layer2, property, startValue, endValue) {
  var obj2 = {
    type: makeInterpolateBoolean(layer2, property, startValue.type, endValue.type)
  };
  var value = [];
  var max = Math.max(startValue.value.length, endValue.value.length);
  for (var i = 0; i < max; i++) {
    var s = startValue.value[i];
    var e2 = endValue.value[i];
    if (s && e2) {
      value.push(makeInterpolateNumber$1(layer2, property, s.value, e2.value));
    } else {
      var ss = startValue.value[i].value || startValue.value[i - 1].value || startValue.value[i - 2].value;
      var ee = endValue.value[i].value || endValue.value[i - 1].value || startValue.value[i - 2].value;
      value.push(makeInterpolateNumber$1(layer2, property, ss, ee));
    }
  }
  obj2.value = value;
  return (rate, t) => {
    var value2 = obj2.value.map((it) => it(rate, t));
    var type = obj2.type(rate, t);
    if (type.includes("matrix") || type.includes("scale")) {
      value2 = value2.map((it) => {
        return Length.number(it);
      });
    }
    return { type, value: value2 };
  };
}
function makeInterpolateTransformRotate(layer2, property, startValue, endValue) {
  var obj2 = {
    type: makeInterpolateBoolean(layer2, property, startValue.type, endValue.type)
  };
  var value = [];
  var max = Math.max(startValue.value.length, endValue.value.length);
  for (var i = 0; i < max; i++) {
    var tempStartValue = startValue.value[i];
    var tempEndValue = endValue.value[i];
    if (tempStartValue && tempEndValue) {
      value.push(makeInterpolateRotate(layer2, property, tempStartValue, tempEndValue));
    } else {
      value.push(makeInterpolateRotate(layer2, property, startValue.value[i] || startValue.value[i - 1] || startValue.value[i - 2], endValue.value[i] || endValue.value[i - 1] || startValue.value[i - 2]));
    }
  }
  obj2.value = value;
  return (rate, t) => {
    var results = {
      type: obj2.type(rate, t),
      value: obj2.value.map((it) => it(rate, t))
    };
    return results;
  };
}
function makeInterpolateTransform(layer2, property, startValue, endValue) {
  var startObject = Transform.parseStyle(startValue.trim());
  var endObject = Transform.parseStyle(endValue.trim());
  var max = Math.max(startObject.length, endObject.length);
  var list2 = [];
  for (var i = 0; i < max; i++) {
    var s = startObject[i];
    var e2 = endObject[i];
    if (s && !e2) {
      list2.push(makeInterpolateIdentity(layer2, property, s));
    } else if (!s && e2) {
      list2.push(makeInterpolateIdentity(layer2, property, e2));
    } else if (s.type != e2.type) {
      list2.push(makeInterpolateBoolean(layer2, property, s, e2));
    } else {
      switch (s.type) {
        case "translate":
        case "translateX":
        case "translateY":
        case "translateZ":
        case "translate3d":
        case "perspective":
          list2.push(makeInterpolateTransformLength(layer2, property, s, e2));
          break;
        case "rotate":
        case "rotateX":
        case "rotateY":
        case "rotateZ":
        case "rotate3d":
          list2.push(makeInterpolateTransformRotate(layer2, property, s, e2));
          break;
        case "scale":
        case "scaleX":
        case "scaleY":
        case "scaleZ":
        case "scale3d":
        case "matrix":
        case "matrix3d":
          list2.push(makeInterpolateTransformNumber(layer2, property, s, e2));
          break;
      }
    }
  }
  return (rate, t) => {
    var results = Transform.join(list2.map((it) => {
      return it(rate, t);
    }));
    return results;
  };
}
function makeInterpolateTransformOrigin(layer2, property, startValue, endValue) {
  var s = startValue.split(" ").map((it) => Length.parse(it));
  var e2 = endValue.split(" ").map((it) => Length.parse(it));
  var max = Math.max(s.length, e2.length);
  var list2 = [];
  for (var i = 0; i < max; i++) {
    var startPos = s[i];
    var endPos = e2[i];
    list2.push(makeInterpolateLength(layer2, property, startPos, endPos, "transform-origin"));
  }
  return (rate, t) => {
    var results = list2.map((it) => it(rate, t)).join(" ");
    return results;
  };
}
function makeInterpolatePerspectiveOrigin(layer2, property, startValue, endValue) {
  var s = startValue.split(" ").map((it) => Length.parse(it));
  var e2 = endValue.split(" ").map((it) => Length.parse(it));
  var max = Math.max(s.length, e2.length);
  var list2 = [];
  for (var i = 0; i < max; i++) {
    var startPos = s[i];
    var endPos = e2[i];
    list2.push(makeInterpolateLength(layer2, property, startPos, endPos, "perspective-origin"));
  }
  return (rate, t) => {
    var results = list2.map((it) => it(rate, t)).join(" ");
    return results;
  };
}
function makeInterpolateStrokeDashArrray(layer2, property, startValue, endValue) {
  var s = startValue.split(" ").map((it) => +it);
  var e2 = endValue.split(" ").map((it) => +it);
  var max = Math.max(s.length, e2.length);
  var list2 = [];
  for (var i = 0; i < max; i++) {
    var startPos = s[i];
    var endPos = e2[i];
    list2.push(makeInterpolateNumber$1(layer2, property, startPos, endPos));
  }
  return (rate, t) => {
    var results = list2.map((it) => it(rate, t)).join(" ");
    return results;
  };
}
class Point {
  static isEqual(a, b, c2) {
    if (arguments.length === 2) {
      return a.x === b.x && a.y === b.y;
    } else if (arguments.length === 3) {
      return Point.isEqual(a, b) && Point.isEqual(b, c2);
    }
  }
  static isFirst(point2) {
    return point2 && point2.command == "M";
  }
  static DouglasPeuker(tolerance, points2, start2, last2) {
    if (last2 <= start2 + 1)
      return;
    let maxdist2 = 0;
    let breakIndex = start2;
    const tol2 = tolerance * tolerance;
    const startPoint = points2[start2];
    const lastPoint = points2[last2];
    for (var i = start2 + 1; i < last2; i++) {
      const dist2 = Point.segmentDistance2(points2[i].x, points2[i].y, startPoint, lastPoint);
      if (dist2 <= maxdist2)
        continue;
      breakIndex = i;
      maxdist2 = dist2;
    }
    if (maxdist2 > tol2) {
      points2[breakIndex].mark = true;
      Point.DouglasPeuker(tolerance, points2, start2, breakIndex);
      Point.DouglasPeuker(tolerance, points2, breakIndex, last2);
    }
  }
  static simply(points2, tolerance = 10) {
    if (points2.length <= 2) {
      return points2;
    }
    points2 = clone$1(points2);
    points2[0].mark = true;
    points2[points2.length - 1].mark = true;
    Point.DouglasPeuker(tolerance, points2, 0, points2.length - 1);
    return points2.filter((it) => Boolean(it.mark));
  }
  static segmentDistance2(x2, y2, A, B) {
    let dx = B.x - A.x;
    let dy = B.y - A.y;
    let lenAB = dx * dx + dy * dy;
    let du = x2 - A.x;
    let dv = y2 - A.y;
    let dot2 = dx * du + dy * dv;
    if (lenAB === 0)
      return du * du + dv * dv;
    if (dot2 <= 0)
      return du * du + dv * dv;
    else if (dot2 >= lenAB) {
      du = x2 - B.x;
      dv = y2 - B.y;
      return du * du + dv * dv;
    } else {
      const slash = du * dy - dv * dx;
      return slash * slash / lenAB;
    }
  }
  static isInLine(A, B, C) {
    if (A.x === C.x)
      return B.x === C.x;
    if (A.y === C.y)
      return B.y === C.y;
    return (A.x - C.x) * (A.y - C.y) === (C.x - B.x) * (C.y - B.y);
  }
  static isLine(point2) {
    return Point.isInLine(point2.endPoint, point2.startPoint, point2, reversePoint);
  }
  static getReversePoint(start2, end2) {
    const [x2, y2, z] = lerp([], [end2.x, end2.y, 0], [start2.x, start2.y, 0], 2);
    return { x: x2, y: y2 };
  }
  static getIndexPoint(points2, index2) {
    return points2[index2];
  }
  static getPoint(points2, p0) {
    return points2.filter((p) => {
      return Point.isEqual(p.startPoint, p0);
    })[0];
  }
  static getIndex(points2, p0) {
    var firstIndex = -1;
    for (var i = 0, len2 = points2.length; i < len2; i++) {
      var p = points2[i];
      if (Point.isEqual(p.startPoint, p0)) {
        firstIndex = i;
        break;
      }
    }
    return firstIndex;
  }
  static getGroupList(points2) {
    const groupList = [];
    let groupIndex = 0;
    points2.forEach((point2, index2) => {
      if (point2.command === "M") {
        groupList.push({ point: point2, index: index2, groupIndex: groupIndex++ });
      }
    });
    return groupList;
  }
  static getSplitedGroupList(points2) {
    const localPoints = clone$1(points2);
    const splitedGroupList = [];
    for (var i = 0, groupIndex = -1, len2 = localPoints.length; i < len2; i++) {
      const point2 = localPoints[i];
      if (point2.command === "M") {
        groupIndex++;
        splitedGroupList[groupIndex] = {
          startPointIndex: i,
          point: point2,
          points: []
        };
      }
      splitedGroupList[groupIndex].points.push(point2);
    }
    return splitedGroupList;
  }
  static getGroup(groupList, pointIndex) {
    const list2 = groupList.filter((group2) => group2.point.index <= pointIndex);
    return list2.pop();
  }
  static getGroupIndex(points2, index2) {
    var groupIndex = -1;
    for (var i = 0, len2 = points2.length; i < len2; i++) {
      if (points2[i].command === "M") {
        groupIndex++;
      }
      if (points2[i].index === index2) {
        return groupIndex;
      }
    }
  }
  static getLastPoint(points2, index2) {
    if (!points2.length)
      return null;
    var lastIndex = -1;
    for (var i = index2 + 1, len2 = points2.length; i < len2; i++) {
      if (points2[i].command === "M") {
        lastIndex = i - 1;
        break;
      }
    }
    if (lastIndex == -1) {
      lastIndex = points2.length - 1;
    }
    if (points2[lastIndex] && points2[lastIndex].command === "Z") {
      lastIndex -= 1;
    }
    var point2 = points2[lastIndex];
    if (point2) {
      point2.index = lastIndex;
    }
    return point2;
  }
  static getFirstPoint(points2, index2) {
    var firstIndex = -1;
    for (var i = index2 - 1; i > 0; i--) {
      if (points2[i].command === "M") {
        firstIndex = i;
        break;
      }
    }
    if (firstIndex === -1) {
      firstIndex = 0;
    }
    var point2 = points2[firstIndex];
    if (point2) {
      point2.index = firstIndex;
    }
    return point2;
  }
  static getConnectedPointList(points2, index2) {
    const current = points2[index2];
    return points2.filter((p, i) => i !== index2 && Point.isEqual(p.startPoint, current.startPoint));
  }
  static getPrevPoint(points2, index2) {
    var prevIndex = index2 - 1;
    if (prevIndex < 0) {
      return Point.getLastPoint(points2, index2);
    }
    var point2 = points2[prevIndex];
    if (point2) {
      point2.index = prevIndex;
    }
    return point2;
  }
  static getNextPoint(points2, index2) {
    var currentPoint = points2[index2];
    var nextPoint = points2[index2 + 1];
    if (nextPoint) {
      nextPoint.index = index2 + 1;
    }
    if (currentPoint.connected || currentPoint.close) {
      nextPoint = Point.getFirstPoint(points2, index2);
    }
    return nextPoint;
  }
  static removePoint(points2, pIndex, segment) {
    if (segment === "startPoint") {
      return points2.filter((_, index2) => index2 !== pIndex);
    }
  }
  static splitPoints(points2) {
    let splitedPointGroup = [];
    let lastPoints = [];
    points2.forEach((p) => {
      if (Point.isFirst(p)) {
        lastPoints = [p];
        splitedPointGroup.push(lastPoints);
      } else {
        lastPoints.push(p);
      }
    });
    return splitedPointGroup;
  }
  static recoverPoints(pointGroup) {
    const newPoints = [];
    pointGroup.forEach((points2) => {
      points2.forEach((p, index2) => {
        if (index2 === 0) {
          p.command = "M";
          p.originalCommand = "M";
        }
      });
      newPoints.push.apply(newPoints, points2);
    });
    newPoints.forEach((p, index2) => {
      p.index = index2;
    });
    return newPoints;
  }
}
class Segment {
  static M(x2, y2) {
    return {
      command: "M",
      values: [x2, y2]
    };
  }
  static L(x2, y2) {
    return {
      command: "L",
      values: [x2, y2]
    };
  }
  static Q(x1, y1, x2, y2) {
    return {
      command: "Q",
      values: [x1, y1, x2, y2]
    };
  }
  static C(x1, y1, x2, y2, x3, y3) {
    return {
      command: "C",
      values: [x1, y1, x2, y2, x3, y3]
    };
  }
  static A(rx, ry, xrot, laf, sf, x2, y2) {
    return {
      command: "A",
      values: [rx, ry, xrot, laf, sf, x2, y2]
    };
  }
  static Z() {
    return {
      command: "Z",
      values: []
    };
  }
}
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getAugmentedNamespace(n) {
  if (n.__esModule)
    return n;
  var a = Object.defineProperty({}, "__esModule", { value: true });
  Object.keys(n).forEach(function(k) {
    var d = Object.getOwnPropertyDescriptor(n, k);
    Object.defineProperty(a, k, d.get ? d : {
      enumerable: true,
      get: function() {
        return n[k];
      }
    });
  });
  return a;
}
var fitCurve$1 = { exports: {} };
(function(module, exports) {
  (function(global2, factory) {
    {
      factory(module);
    }
  })(commonjsGlobal, function(module2) {
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    /**
     *  @preserve  JavaScript implementation of
     *  Algorithm for Automatically Fitting Digitized Curves
     *  by Philip J. Schneider
     *  "Graphics Gems", Academic Press, 1990
     *
     *  The MIT License (MIT)
     *
     *  https://github.com/soswow/fit-curves
     */
    function fitCurve2(points2, maxError, progressCallback) {
      if (!Array.isArray(points2)) {
        throw new TypeError("First argument should be an array");
      }
      points2.forEach(function(point2) {
        if (!Array.isArray(point2) || point2.some(function(item2) {
          return typeof item2 !== "number";
        }) || point2.length !== points2[0].length) {
          throw Error("Each point should be an array of numbers. Each point should have the same amount of numbers.");
        }
      });
      points2 = points2.filter(function(point2, i) {
        return i === 0 || !point2.every(function(val, j) {
          return val === points2[i - 1][j];
        });
      });
      if (points2.length < 2) {
        return [];
      }
      var len2 = points2.length;
      var leftTangent = createTangent(points2[1], points2[0]);
      var rightTangent = createTangent(points2[len2 - 2], points2[len2 - 1]);
      return fitCubic(points2, leftTangent, rightTangent, maxError, progressCallback);
    }
    function fitCubic(points2, leftTangent, rightTangent, error, progressCallback) {
      var MaxIterations = 20;
      var bezCurve, u, uPrime, maxError, prevErr, splitPoint, prevSplit, centerVector, toCenterTangent, fromCenterTangent, beziers, dist2, i;
      if (points2.length === 2) {
        dist2 = maths.vectorLen(maths.subtract(points2[0], points2[1])) / 3;
        bezCurve = [points2[0], maths.addArrays(points2[0], maths.mulItems(leftTangent, dist2)), maths.addArrays(points2[1], maths.mulItems(rightTangent, dist2)), points2[1]];
        return [bezCurve];
      }
      u = chordLengthParameterize(points2);
      var _generateAndReport = generateAndReport(points2, u, u, leftTangent, rightTangent, progressCallback);
      bezCurve = _generateAndReport[0];
      maxError = _generateAndReport[1];
      splitPoint = _generateAndReport[2];
      if (maxError === 0 || maxError < error) {
        return [bezCurve];
      }
      if (maxError < error * error) {
        uPrime = u;
        prevErr = maxError;
        prevSplit = splitPoint;
        for (i = 0; i < MaxIterations; i++) {
          uPrime = reparameterize(bezCurve, points2, uPrime);
          var _generateAndReport2 = generateAndReport(points2, u, uPrime, leftTangent, rightTangent, progressCallback);
          bezCurve = _generateAndReport2[0];
          maxError = _generateAndReport2[1];
          splitPoint = _generateAndReport2[2];
          if (maxError < error) {
            return [bezCurve];
          } else if (splitPoint === prevSplit) {
            var errChange = maxError / prevErr;
            if (errChange > 0.9999 && errChange < 1.0001) {
              break;
            }
          }
          prevErr = maxError;
          prevSplit = splitPoint;
        }
      }
      beziers = [];
      centerVector = maths.subtract(points2[splitPoint - 1], points2[splitPoint + 1]);
      if (centerVector.every(function(val) {
        return val === 0;
      })) {
        centerVector = maths.subtract(points2[splitPoint - 1], points2[splitPoint]);
        var _ref = [-centerVector[1], centerVector[0]];
        centerVector[0] = _ref[0];
        centerVector[1] = _ref[1];
      }
      toCenterTangent = maths.normalize(centerVector);
      fromCenterTangent = maths.mulItems(toCenterTangent, -1);
      beziers = beziers.concat(fitCubic(points2.slice(0, splitPoint + 1), leftTangent, toCenterTangent, error, progressCallback));
      beziers = beziers.concat(fitCubic(points2.slice(splitPoint), fromCenterTangent, rightTangent, error, progressCallback));
      return beziers;
    }
    function generateAndReport(points2, paramsOrig, paramsPrime, leftTangent, rightTangent, progressCallback) {
      var bezCurve, maxError, splitPoint;
      bezCurve = generateBezier(points2, paramsPrime, leftTangent, rightTangent);
      var _computeMaxError = computeMaxError(points2, bezCurve, paramsOrig);
      maxError = _computeMaxError[0];
      splitPoint = _computeMaxError[1];
      if (progressCallback) {
        progressCallback({
          bez: bezCurve,
          points: points2,
          params: paramsOrig,
          maxErr: maxError,
          maxPoint: splitPoint
        });
      }
      return [bezCurve, maxError, splitPoint];
    }
    function generateBezier(points2, parameters, leftTangent, rightTangent) {
      var bezCurve, A, a, C, X, det_C0_C1, det_C0_X, det_X_C1, alpha_l, alpha_r, epsilon, segLength, i, len2, tmp2, u, ux, firstPoint = points2[0], lastPoint = points2[points2.length - 1];
      bezCurve = [firstPoint, null, null, lastPoint];
      A = maths.zeros_Xx2x2(parameters.length);
      for (i = 0, len2 = parameters.length; i < len2; i++) {
        u = parameters[i];
        ux = 1 - u;
        a = A[i];
        a[0] = maths.mulItems(leftTangent, 3 * u * (ux * ux));
        a[1] = maths.mulItems(rightTangent, 3 * ux * (u * u));
      }
      C = [[0, 0], [0, 0]];
      X = [0, 0];
      for (i = 0, len2 = points2.length; i < len2; i++) {
        u = parameters[i];
        a = A[i];
        C[0][0] += maths.dot(a[0], a[0]);
        C[0][1] += maths.dot(a[0], a[1]);
        C[1][0] += maths.dot(a[0], a[1]);
        C[1][1] += maths.dot(a[1], a[1]);
        tmp2 = maths.subtract(points2[i], bezier.q([firstPoint, firstPoint, lastPoint, lastPoint], u));
        X[0] += maths.dot(a[0], tmp2);
        X[1] += maths.dot(a[1], tmp2);
      }
      det_C0_C1 = C[0][0] * C[1][1] - C[1][0] * C[0][1];
      det_C0_X = C[0][0] * X[1] - C[1][0] * X[0];
      det_X_C1 = X[0] * C[1][1] - X[1] * C[0][1];
      alpha_l = det_C0_C1 === 0 ? 0 : det_X_C1 / det_C0_C1;
      alpha_r = det_C0_C1 === 0 ? 0 : det_C0_X / det_C0_C1;
      segLength = maths.vectorLen(maths.subtract(firstPoint, lastPoint));
      epsilon = 1e-6 * segLength;
      if (alpha_l < epsilon || alpha_r < epsilon) {
        bezCurve[1] = maths.addArrays(firstPoint, maths.mulItems(leftTangent, segLength / 3));
        bezCurve[2] = maths.addArrays(lastPoint, maths.mulItems(rightTangent, segLength / 3));
      } else {
        bezCurve[1] = maths.addArrays(firstPoint, maths.mulItems(leftTangent, alpha_l));
        bezCurve[2] = maths.addArrays(lastPoint, maths.mulItems(rightTangent, alpha_r));
      }
      return bezCurve;
    }
    function reparameterize(bezier2, points2, parameters) {
      return parameters.map(function(p, i) {
        return newtonRaphsonRootFind(bezier2, points2[i], p);
      });
    }
    function newtonRaphsonRootFind(bez, point2, u) {
      var d = maths.subtract(bezier.q(bez, u), point2), qprime = bezier.qprime(bez, u), numerator = maths.mulMatrix(d, qprime), denominator = maths.sum(maths.squareItems(qprime)) + 2 * maths.mulMatrix(d, bezier.qprimeprime(bez, u));
      if (denominator === 0) {
        return u;
      } else {
        return u - numerator / denominator;
      }
    }
    function chordLengthParameterize(points2) {
      var u = [], currU, prevU, prevP;
      points2.forEach(function(p, i) {
        currU = i ? prevU + maths.vectorLen(maths.subtract(p, prevP)) : 0;
        u.push(currU);
        prevU = currU;
        prevP = p;
      });
      u = u.map(function(x2) {
        return x2 / prevU;
      });
      return u;
    }
    function computeMaxError(points2, bez, parameters) {
      var dist2, maxDist, splitPoint, v, i, count, point2, t;
      maxDist = 0;
      splitPoint = Math.floor(points2.length / 2);
      var t_distMap = mapTtoRelativeDistances(bez, 10);
      for (i = 0, count = points2.length; i < count; i++) {
        point2 = points2[i];
        t = find_t(bez, parameters[i], t_distMap, 10);
        v = maths.subtract(bezier.q(bez, t), point2);
        dist2 = v[0] * v[0] + v[1] * v[1];
        if (dist2 > maxDist) {
          maxDist = dist2;
          splitPoint = i;
        }
      }
      return [maxDist, splitPoint];
    }
    var mapTtoRelativeDistances = function mapTtoRelativeDistances2(bez, B_parts) {
      var B_t_curr;
      var B_t_dist = [0];
      var B_t_prev = bez[0];
      var sumLen = 0;
      for (var i = 1; i <= B_parts; i++) {
        B_t_curr = bezier.q(bez, i / B_parts);
        sumLen += maths.vectorLen(maths.subtract(B_t_curr, B_t_prev));
        B_t_dist.push(sumLen);
        B_t_prev = B_t_curr;
      }
      B_t_dist = B_t_dist.map(function(x2) {
        return x2 / sumLen;
      });
      return B_t_dist;
    };
    function find_t(bez, param, t_distMap, B_parts) {
      if (param < 0) {
        return 0;
      }
      if (param > 1) {
        return 1;
      }
      var lenMax, lenMin, tMax, tMin, t;
      for (var i = 1; i <= B_parts; i++) {
        if (param <= t_distMap[i]) {
          tMin = (i - 1) / B_parts;
          tMax = i / B_parts;
          lenMin = t_distMap[i - 1];
          lenMax = t_distMap[i];
          t = (param - lenMin) / (lenMax - lenMin) * (tMax - tMin) + tMin;
          break;
        }
      }
      return t;
    }
    function createTangent(pointA, pointB) {
      return maths.normalize(maths.subtract(pointA, pointB));
    }
    var maths = function() {
      function maths2() {
        _classCallCheck(this, maths2);
      }
      maths2.zeros_Xx2x2 = function zeros_Xx2x2(x2) {
        var zs = [];
        while (x2--) {
          zs.push([0, 0]);
        }
        return zs;
      };
      maths2.mulItems = function mulItems(items, multiplier) {
        return items.map(function(x2) {
          return x2 * multiplier;
        });
      };
      maths2.mulMatrix = function mulMatrix(m1, m2) {
        return m1.reduce(function(sum, x1, i) {
          return sum + x1 * m2[i];
        }, 0);
      };
      maths2.subtract = function subtract2(arr1, arr2) {
        return arr1.map(function(x1, i) {
          return x1 - arr2[i];
        });
      };
      maths2.addArrays = function addArrays(arr1, arr2) {
        return arr1.map(function(x1, i) {
          return x1 + arr2[i];
        });
      };
      maths2.addItems = function addItems(items, addition) {
        return items.map(function(x2) {
          return x2 + addition;
        });
      };
      maths2.sum = function sum(items) {
        return items.reduce(function(sum2, x2) {
          return sum2 + x2;
        });
      };
      maths2.dot = function dot2(m1, m2) {
        return maths2.mulMatrix(m1, m2);
      };
      maths2.vectorLen = function vectorLen(v) {
        return Math.hypot.apply(Math, v);
      };
      maths2.divItems = function divItems(items, divisor) {
        return items.map(function(x2) {
          return x2 / divisor;
        });
      };
      maths2.squareItems = function squareItems(items) {
        return items.map(function(x2) {
          return x2 * x2;
        });
      };
      maths2.normalize = function normalize2(v) {
        return this.divItems(v, this.vectorLen(v));
      };
      return maths2;
    }();
    var bezier = function() {
      function bezier2() {
        _classCallCheck(this, bezier2);
      }
      bezier2.q = function q(ctrlPoly, t) {
        var tx = 1 - t;
        var pA = maths.mulItems(ctrlPoly[0], tx * tx * tx), pB = maths.mulItems(ctrlPoly[1], 3 * tx * tx * t), pC = maths.mulItems(ctrlPoly[2], 3 * tx * t * t), pD = maths.mulItems(ctrlPoly[3], t * t * t);
        return maths.addArrays(maths.addArrays(pA, pB), maths.addArrays(pC, pD));
      };
      bezier2.qprime = function qprime(ctrlPoly, t) {
        var tx = 1 - t;
        var pA = maths.mulItems(maths.subtract(ctrlPoly[1], ctrlPoly[0]), 3 * tx * tx), pB = maths.mulItems(maths.subtract(ctrlPoly[2], ctrlPoly[1]), 6 * tx * t), pC = maths.mulItems(maths.subtract(ctrlPoly[3], ctrlPoly[2]), 3 * t * t);
        return maths.addArrays(maths.addArrays(pA, pB), pC);
      };
      bezier2.qprimeprime = function qprimeprime(ctrlPoly, t) {
        return maths.addArrays(maths.mulItems(maths.addArrays(maths.subtract(ctrlPoly[2], maths.mulItems(ctrlPoly[1], 2)), ctrlPoly[0]), 6 * (1 - t)), maths.mulItems(maths.addArrays(maths.subtract(ctrlPoly[3], maths.mulItems(ctrlPoly[2], 2)), ctrlPoly[1]), 6 * t));
      };
      return bezier2;
    }();
    module2.exports = fitCurve2;
    module2.exports.fitCubic = fitCubic;
    module2.exports.createTangent = createTangent;
  });
})(fitCurve$1);
var fitCurve = fitCurve$1.exports;
var _slicedToArray = function() {
  function sliceIterator(arr, i) {
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = void 0;
    try {
      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);
        if (i && _arr.length === i)
          break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"])
          _i["return"]();
      } finally {
        if (_d)
          throw _e;
      }
    }
    return _arr;
  }
  return function(arr, i) {
    if (Array.isArray(arr)) {
      return arr;
    } else if (Symbol.iterator in Object(arr)) {
      return sliceIterator(arr, i);
    } else {
      throw new TypeError("Invalid attempt to destructure non-iterable instance");
    }
  };
}();
var TAU = Math.PI * 2;
var mapToEllipse = function mapToEllipse2(_ref, rx, ry, cosphi, sinphi, centerx, centery) {
  var x2 = _ref.x, y2 = _ref.y;
  x2 *= rx;
  y2 *= ry;
  var xp = cosphi * x2 - sinphi * y2;
  var yp = sinphi * x2 + cosphi * y2;
  return {
    x: xp + centerx,
    y: yp + centery
  };
};
var approxUnitArc = function approxUnitArc2(ang1, ang2) {
  var a = ang2 === 1.5707963267948966 ? 0.551915024494 : ang2 === -1.5707963267948966 ? -0.551915024494 : 4 / 3 * Math.tan(ang2 / 4);
  var x1 = Math.cos(ang1);
  var y1 = Math.sin(ang1);
  var x2 = Math.cos(ang1 + ang2);
  var y2 = Math.sin(ang1 + ang2);
  return [{
    x: x1 - y1 * a,
    y: y1 + x1 * a
  }, {
    x: x2 + y2 * a,
    y: y2 - x2 * a
  }, {
    x: x2,
    y: y2
  }];
};
var vectorAngle = function vectorAngle2(ux, uy, vx, vy) {
  var sign = ux * vy - uy * vx < 0 ? -1 : 1;
  var dot2 = ux * vx + uy * vy;
  if (dot2 > 1) {
    dot2 = 1;
  }
  if (dot2 < -1) {
    dot2 = -1;
  }
  return sign * Math.acos(dot2);
};
var getArcCenter = function getArcCenter2(px, py, cx, cy, rx, ry, largeArcFlag, sweepFlag, sinphi, cosphi, pxp, pyp) {
  var rxsq = Math.pow(rx, 2);
  var rysq = Math.pow(ry, 2);
  var pxpsq = Math.pow(pxp, 2);
  var pypsq = Math.pow(pyp, 2);
  var radicant = rxsq * rysq - rxsq * pypsq - rysq * pxpsq;
  if (radicant < 0) {
    radicant = 0;
  }
  radicant /= rxsq * pypsq + rysq * pxpsq;
  radicant = Math.sqrt(radicant) * (largeArcFlag === sweepFlag ? -1 : 1);
  var centerxp = radicant * rx / ry * pyp;
  var centeryp = radicant * -ry / rx * pxp;
  var centerx = cosphi * centerxp - sinphi * centeryp + (px + cx) / 2;
  var centery = sinphi * centerxp + cosphi * centeryp + (py + cy) / 2;
  var vx1 = (pxp - centerxp) / rx;
  var vy1 = (pyp - centeryp) / ry;
  var vx2 = (-pxp - centerxp) / rx;
  var vy2 = (-pyp - centeryp) / ry;
  var ang1 = vectorAngle(1, 0, vx1, vy1);
  var ang2 = vectorAngle(vx1, vy1, vx2, vy2);
  if (sweepFlag === 0 && ang2 > 0) {
    ang2 -= TAU;
  }
  if (sweepFlag === 1 && ang2 < 0) {
    ang2 += TAU;
  }
  return [centerx, centery, ang1, ang2];
};
var arcToBezier = function arcToBezier2(_ref2) {
  var px = _ref2.px, py = _ref2.py, cx = _ref2.cx, cy = _ref2.cy, rx = _ref2.rx, ry = _ref2.ry, _ref2$xAxisRotation = _ref2.xAxisRotation, xAxisRotation = _ref2$xAxisRotation === void 0 ? 0 : _ref2$xAxisRotation, _ref2$largeArcFlag = _ref2.largeArcFlag, largeArcFlag = _ref2$largeArcFlag === void 0 ? 0 : _ref2$largeArcFlag, _ref2$sweepFlag = _ref2.sweepFlag, sweepFlag = _ref2$sweepFlag === void 0 ? 0 : _ref2$sweepFlag;
  var curves = [];
  if (rx === 0 || ry === 0) {
    return [];
  }
  var sinphi = Math.sin(xAxisRotation * TAU / 360);
  var cosphi = Math.cos(xAxisRotation * TAU / 360);
  var pxp = cosphi * (px - cx) / 2 + sinphi * (py - cy) / 2;
  var pyp = -sinphi * (px - cx) / 2 + cosphi * (py - cy) / 2;
  if (pxp === 0 && pyp === 0) {
    return [];
  }
  rx = Math.abs(rx);
  ry = Math.abs(ry);
  var lambda = Math.pow(pxp, 2) / Math.pow(rx, 2) + Math.pow(pyp, 2) / Math.pow(ry, 2);
  if (lambda > 1) {
    rx *= Math.sqrt(lambda);
    ry *= Math.sqrt(lambda);
  }
  var _getArcCenter = getArcCenter(px, py, cx, cy, rx, ry, largeArcFlag, sweepFlag, sinphi, cosphi, pxp, pyp), _getArcCenter2 = _slicedToArray(_getArcCenter, 4), centerx = _getArcCenter2[0], centery = _getArcCenter2[1], ang1 = _getArcCenter2[2], ang2 = _getArcCenter2[3];
  var ratio = Math.abs(ang2) / (TAU / 4);
  if (Math.abs(1 - ratio) < 1e-7) {
    ratio = 1;
  }
  var segments2 = Math.max(Math.ceil(ratio), 1);
  ang2 /= segments2;
  for (var i = 0; i < segments2; i++) {
    curves.push(approxUnitArc(ang1, ang2));
    ang1 += ang2;
  }
  return curves.map(function(curve) {
    var _mapToEllipse = mapToEllipse(curve[0], rx, ry, cosphi, sinphi, centerx, centery), x1 = _mapToEllipse.x, y1 = _mapToEllipse.y;
    var _mapToEllipse2 = mapToEllipse(curve[1], rx, ry, cosphi, sinphi, centerx, centery), x2 = _mapToEllipse2.x, y2 = _mapToEllipse2.y;
    var _mapToEllipse3 = mapToEllipse(curve[2], rx, ry, cosphi, sinphi, centerx, centery), x3 = _mapToEllipse3.x, y3 = _mapToEllipse3.y;
    return { x1, y1, x2, y2, x: x3, y: y3 };
  });
};
const REG_PARSE_NUMBER_FOR_PATH = /([mMlLvVhHcCsSqQtTaAzZ]([^mMlLvVhHcCsSqQtTaAzZ]*))/g;
var numberReg = /-?[0-9]*\.?[0-9]+(?:e[-+]?\d+)?/ig;
class PathParser {
  constructor(pathString2 = "") {
    this.reset(pathString2);
  }
  reset(pathString2 = "") {
    this.segments = [];
    this.pathString = pathString2.trim();
    this.parse();
  }
  resetSegments(segments2) {
    this.segments = segments2 || [];
    this.pathString = this.joinPath();
    return this;
  }
  addSegments(segments2, transform2) {
    return this.resetSegments([...this.segments, ...segments2]);
  }
  addPath(otherPath, transform2 = create$5()) {
    const newPath = otherPath.clone();
    newPath.transformMat4(transform2);
    return this.addSegments(newPath.segments);
  }
  trim(str = "") {
    var arr = str.match(numberReg) || [];
    return arr.filter((it) => it != "");
  }
  parse() {
    var arr = this.pathString.match(REG_PARSE_NUMBER_FOR_PATH) || [];
    this.segments = arr.map((s) => {
      var command = s[0];
      var values = this.trim(s.replace(command, "")).map((it) => +it);
      return { command, values };
    });
    this.segments = this.segments.map((s, index2) => {
      switch (s.command) {
        case "m":
          var prev = this.segments[index2 - 1];
          if (prev && (prev.command == "z" || prev.command == "Z")) {
            prev = this.segments[index2 - 2];
          }
          var x2 = (prev == null ? void 0 : prev.values[prev.values.length - 2]) || 0;
          var y2 = (prev == null ? void 0 : prev.values[prev.values.length - 1]) || 0;
          for (var i = 0, len2 = s.values.length; i < len2; i += 2) {
            s.values[i] += x2;
            s.values[i + 1] += y2;
          }
          return {
            command: s.command.toUpperCase(),
            values: [...s.values]
          };
        case "c":
        case "l":
        case "q":
        case "s":
        case "t":
        case "v":
        case "h":
          var prev = this.segments[index2 - 1];
          var x2 = (prev == null ? void 0 : prev.values[prev.values.length - 2]) || 0;
          var y2 = (prev == null ? void 0 : prev.values[prev.values.length - 1]) || 0;
          for (var i = 0, len2 = s.values.length; i < len2; i += 2) {
            s.values[i] += x2;
            s.values[i + 1] += y2;
          }
          return {
            command: s.command.toUpperCase(),
            values: [...s.values]
          };
        case "a":
          var prev = this.segments[index2 - 1];
          var x2 = (prev == null ? void 0 : prev.values[prev.values.length - 2]) || 0;
          var y2 = (prev == null ? void 0 : prev.values[prev.values.length - 1]) || 0;
          s.values[5] += x2;
          s.values[6] += y2;
          return {
            command: s.command.toUpperCase(),
            values: [...s.values]
          };
        case "z":
          return {
            command: s.command.toUpperCase(),
            values: []
          };
        default:
          return s;
      }
    });
    this.segments.forEach((it, index2) => {
      const prev = this.segments[index2 - 1];
      if (it.command == "A") {
        const x1 = (prev == null ? void 0 : prev.values[prev.values.length - 2]) || 0;
        const y1 = (prev == null ? void 0 : prev.values[prev.values.length - 1]) || 0;
        const [rx, ry, xrotate, largeArcFlag, sweepFlag, x2, y2] = it.values;
        const path = PathParser.arcToCurve(x1, y1, rx, ry, xrotate, largeArcFlag, sweepFlag, x2, y2);
        path.segments.forEach((seg) => {
          if (seg.command !== "M" || seg.command !== "Z")
            ;
        });
      }
    });
    return this;
  }
  convertGenerator() {
    var points2 = [];
    for (var index2 = 0, len2 = this.segments.length; index2 < len2; index2++) {
      var s = this.segments[index2];
      var nextSegment = this.segments[index2 + 1];
      const { command, values } = s;
      if (command === "M") {
        var [x2, y2] = values;
        points2.push({
          command,
          originalCommand: command,
          startPoint: { x: x2, y: y2 },
          endPoint: { x: x2, y: y2 },
          reversePoint: { x: x2, y: y2 },
          curve: false
        });
      } else if (command === "L") {
        var prevPoint = Point.getPrevPoint(points2, points2.length);
        if (prevPoint.curve) {
          var [x2, y2] = values;
          points2.push({
            command,
            originalCommand: command,
            startPoint: { x: x2, y: y2 },
            endPoint: { x: x2, y: y2 },
            reversePoint: clone$1(prevPoint.endPoint),
            curve: true
          });
        } else {
          var [x2, y2] = values;
          points2.push({
            command,
            originalCommand: command,
            startPoint: { x: x2, y: y2 },
            endPoint: { x: x2, y: y2 },
            reversePoint: { x: x2, y: y2 },
            curve: false
          });
        }
      } else if (command === "Q") {
        var [cx1, cy1, x2, y2] = values;
        var prevPoint = Point.getPrevPoint(points2, points2.length);
        if (prevPoint.curve) {
          var startPoint = { x: x2, y: y2 };
          var endPoint = { x: x2, y: y2 };
          var reversePoint2 = { x: x2, y: y2 };
          points2.push({
            command: "L",
            originalCommand: command,
            startPoint,
            endPoint,
            reversePoint: reversePoint2,
            curve: false
          });
          prevPoint.endPoint = { x: cx1, y: cy1 };
        } else {
          if (nextSegment && nextSegment.command === "L") {
            prevPoint.curve = true;
            prevPoint.endPoint = { x: cx1, y: cy1 };
            var startPoint = { x: x2, y: y2 };
            var reversePoint2 = { x: x2, y: y2 };
            var endPoint = { x: x2, y: y2 };
            points2.push({
              command: "L",
              originalCommand: command,
              curve: false,
              startPoint,
              endPoint,
              reversePoint: reversePoint2
            });
          } else {
            var startPoint = { x: x2, y: y2 };
            var reversePoint2 = { x: cx1, y: cy1 };
            var endPoint = { x: x2, y: y2 };
            points2.push({
              command,
              originalCommand: command,
              curve: true,
              startPoint,
              endPoint,
              reversePoint: reversePoint2
            });
          }
        }
      } else if (command === "T") {
        var [x2, y2] = values;
        var prevSegment = segments[index2 - 1];
        if (prevSegment && prevSegment.command === "Q") {
          var [cx1, cy1, sx, sy] = prevSegment.values;
          var prevPoint = Point.getPrevPoint(points2, points2.length);
          prevPoint.endPoint = Point.getReversePoint({ x: sx, y: sy }, { x: cx1, y: cy1 });
          var startPoint = { x: x2, y: y2 };
          var endPoint = { x: x2, y: y2 };
          var reversePoint2 = { x: x2, y: y2 };
          points2.push({
            command: "L",
            originalCommand: command,
            startPoint,
            endPoint,
            reversePoint: reversePoint2,
            curve: false
          });
        }
      } else if (command === "C") {
        var prevPoint = Point.getPrevPoint(points2, points2.length);
        var [cx1, cy1, cx2, cy2, x2, y2] = values;
        var startPoint = { x: x2, y: y2 };
        var reversePoint2 = { x: cx2, y: cy2 };
        var endPoint = { x: x2, y: y2 };
        points2.push({
          command,
          originalCommand: command,
          curve: true,
          startPoint,
          endPoint,
          reversePoint: reversePoint2
        });
        if (prevPoint) {
          prevPoint.curve = true;
          prevPoint.endPoint = { x: cx1, y: cy1 };
        }
      } else if (command === "S") {
        var [x2, y2] = values;
        var prevSegment = segments[index2 - 1];
        if (prevSegment && prevSegment.command === "C") {
          var [cx2, cy2, sx, sy] = prevSegment.values;
          var prevPoint = Point.getPrevPoint(points2, points2.length);
          prevPoint.endPoint = Point.getReversePoint(prevPoint.startPoint, prevPoint.reversePoint);
          var startPoint = { x: x2, y: y2 };
          var endPoint = { x: x2, y: y2 };
          var reversePoint2 = { x: cx2, y: cy2 };
          points2.push({
            command: "Q",
            originalCommand: command,
            startPoint,
            endPoint,
            reversePoint: reversePoint2,
            curve: false
          });
        }
      } else if (command === "Z") {
        var prevPoint = Point.getPrevPoint(points2, points2.length);
        var firstPoint = Point.getFirstPoint(points2, points2.length);
        if (Point.isEqual(prevPoint.startPoint, firstPoint.startPoint)) {
          prevPoint.connected = true;
          prevPoint.endPoint = clone$1(firstPoint.endPoint);
          firstPoint.reversePoint = clone$1(prevPoint.reversePoint);
        }
        prevPoint.close = true;
      }
    }
    points2 = points2.filter((p) => !!p);
    return points2;
  }
  setSegments(index2, seg) {
    this.segments[index2] = seg;
  }
  getSegments(index2) {
    if (isNotUndefined(index2)) {
      return this.segments[index2];
    }
    return this.segments;
  }
  joinPath(segments2, split = "") {
    var list2 = segments2 || this.segments;
    return list2.map((it) => {
      return `${it.command} ${it.values.length ? it.values.join(" ") : ""}`;
    }).join(split);
  }
  each(callback, isReturn = false) {
    var newSegments = this.segments.map((segment, index2) => {
      return callback.call(this, segment, index2);
    });
    if (isReturn) {
      return newSegments;
    } else {
      this.segments = newSegments;
    }
    return this;
  }
  _loop(m, isReturn = false) {
    return this.each(function(segment) {
      var v = segment.values;
      var c2 = segment.command;
      switch (c2) {
        case "M":
        case "L":
          var result = m(v, 0);
          segment.values = [result[0], result[1]];
          break;
        case "V":
          var result = m([+v[0], 0]);
          segment.values = [result[0]];
          break;
        case "H":
          var result = m([0, +v[0]]);
          segment.values = [result[1]];
          break;
        case "C":
        case "S":
        case "T":
        case "Q":
          for (var i = 0, len2 = v.length; i < len2; i += 2) {
            var result = m(v, i);
            segment.values[i] = result[0];
            segment.values[i + 1] = result[1];
          }
          break;
      }
      return segment;
    }, isReturn);
  }
  clone() {
    const path = new PathParser();
    path.resetSegments(this.segments.map((it) => {
      return {
        command: it.command,
        values: it.values.slice()
      };
    }));
    return path;
  }
  translate(tx, ty) {
    this.transformMat4(fromTranslation([], [tx, ty, 0]));
    return this;
  }
  translateTo(tx, ty) {
    return this.joinPath(this.transformMat4(fromTranslation([], [tx, ty, 0]), true));
  }
  scale(sx, sy) {
    this.transformMat4(fromScaling([], [sx, sy, 1]));
    return this;
  }
  scaleTo(sx, sy) {
    return this.joinPath(this.transformMat4(fromScaling([], [sx, sy, 1]), true));
  }
  scaleWith(width2, height2) {
    const newPath = this.clone();
    const rect2 = vertiesToRectangle(newPath.getBBox());
    newPath.translate(-rect2.x, -rect2.y);
    const scale2 = Math.min(width2 / rect2.width, height2 / rect2.height);
    return newPath.scale(scale2, scale2).translate(width2 / 2 - rect2.width / 2 * scale2, height2 / 2 - rect2.height / 2 * scale2);
  }
  rotate(angle2, centerX = 0, centerY = 0) {
    const view = create$5();
    multiply$1(view, view, fromTranslation([], [centerX, centerY, 0]));
    multiply$1(view, view, fromZRotation([], degreeToRadian$1(angle2)));
    multiply$1(view, view, fromTranslation([], negate([], [centerX, centerY, 0])));
    this.transformMat4(view);
    return this;
  }
  rotateTo(angle2, centerX = 0, centerY = 0) {
    const view = create$5();
    multiply$1(view, view, fromTranslation([], [centerX, centerY, 0]));
    multiply$1(view, view, fromZRotation([], degreeToRadian$1(angle2)));
    multiply$1(view, view, fromTranslation([], negate([], [centerX, centerY, 0])));
    return this.joinPath(this.transformMat4(view, true));
  }
  reflectionOrigin() {
    this.transformMat4(fromScaling([], [-1, -1, 0]));
    return this;
  }
  reflectionOriginTo() {
    return this.joinPath(this.transformMat4(fromScaling([], [-1, -1, 0]), true));
  }
  flipX() {
    this.transformMat4(fromScaling([], [1, -1, 0]));
    return this;
  }
  flipXTo() {
    return this.joinPath(this.transformMat4(fromScaling([], [1, -1, 0]), true));
  }
  flipY() {
    this.transformMat4(fromScaling([], [-1, 1, 0]));
    return this;
  }
  flipYTo() {
    return this.joinPath(this.transformMat4(fromScaling([], [-1, 1, 0]), true));
  }
  skewX(angle2) {
    this.transformMat4(fromValues$1(1, Math.tan(degreeToRadian$1(angle2)), 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1));
    return this;
  }
  skewXTo(angle2) {
    return this.joinPath(this.transformMat4(fromValues$1(1, Math.tan(degreeToRadian$1(angle2)), 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), true));
  }
  skewY(angle2) {
    this.transformMat4(fromValues$1(1, 0, 0, 0, Math.tan(degreeToRadian$1(angle2)), 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1));
    return this;
  }
  skewYTo(angle2) {
    return this.joinPath(this.transformMat4(fromValues$1(1, 0, 0, 0, Math.tan(degreeToRadian$1(angle2)), 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), true));
  }
  forEachGroup(callback) {
    const groupList = this.getGroup();
    for (let i = 0, len2 = groupList.length; i < len2; i++) {
      const group2 = groupList[i];
      callback(group2, i, groupList);
    }
  }
  forEach(callback) {
    this.forEachGroup((segments2, index2, groupList) => {
      for (let i = 0, len2 = segments2.length; i < len2; i++) {
        const segment = segments2[i];
        callback(segment, i, segments2, groupList, index2);
      }
    });
  }
  normalize() {
    const allSegments = [];
    const groupList = this.getGroup();
    groupList.forEach((group2) => {
      const newSegments = [];
      group2.segments.forEach(({ segment }, index2) => {
        var _a;
        const prevSegment = (_a = group2.segments[index2 - 1]) == null ? void 0 : _a.segment;
        if (segment.command === "M") {
          newSegments.push(segment);
          return;
        } else if (segment.command === "L") {
          const localCurve = normalizeCurveForLine([
            [prevSegment.values[prevSegment.values.length - 2], prevSegment.values[prevSegment.values.length - 1], 0],
            [segment.values[0], segment.values[1], 0]
          ]);
          newSegments.push({
            command: "C",
            values: [
              localCurve[1][0],
              localCurve[1][1],
              localCurve[2][0],
              localCurve[2][1],
              localCurve[3][0],
              localCurve[3][1]
            ]
          });
          return;
        } else if (segment.command === "C") {
          newSegments.push(segment);
        } else if (segment.command === "Q") {
          const localCurve = normalizeCurveForQuard([
            [prevSegment.values[prevSegment.values.length - 2], prevSegment.values[prevSegment.values.length - 1], 0],
            [segment.values[0], segment.values[1], 0],
            [segment.values[2], segment.values[3], 0]
          ]);
          newSegments.push({
            command: "C",
            values: [
              localCurve[1][0],
              localCurve[1][1],
              localCurve[2][0],
              localCurve[2][1],
              localCurve[3][0],
              localCurve[3][1]
            ]
          });
        } else if (segment.command === "Z") {
          newSegments.push(segment);
        }
      });
      allSegments.push(...newSegments);
    });
    return PathParser.fromSegments(allSegments);
  }
  polygonal() {
    const pathList = this.toPathList();
    pathList.forEach((path) => {
      const newSegments = [];
      path.segments.forEach((segment, index2) => {
        const prevSegment = path.segments[index2 - 1];
        if (segment.command === "M") {
          newSegments.push(segment);
        } else if (segment.command === "L") {
          newSegments.push(segment);
        } else if (segment.command === "C") {
          newSegments.push(...polygonalForCurve([prevSegment.values[prevSegment.values.length - 2], prevSegment.values[prevSegment.values.length - 1], 0], [segment.values[0], segment.values[1], 0], [segment.values[2], segment.values[3], 0], [segment.values[4], segment.values[5], 0]).map((point2) => ({
            command: "L",
            values: [point2[0], point2[1], 0]
          })));
        } else if (segment.command === "Q") {
          newSegments.push(...polygonalForCurve(...normalizeCurveForQuard([
            [prevSegment.values[prevSegment.values.length - 2], prevSegment.values[prevSegment.values.length - 1], 0],
            [segment.values[0], segment.values[1], 0],
            [segment.values[2], segment.values[3], 0]
          ])).map((point2) => ({
            command: "L",
            values: [point2[0], point2[1], 0]
          })));
        } else if (segment.command === "Z") {
          newSegments.push(segment);
        }
      });
      path.resetSegments(newSegments);
    });
    return PathParser.joinPathList(pathList);
  }
  divideSegmentByLength(length2 = 100) {
    const newPath = new PathParser();
    const groupList = this.getGroup();
    groupList.forEach((group2) => {
      const newSegments = [];
      group2.segments.forEach(({ segment }, index2) => {
        var _a;
        (_a = group2.segments[index2 - 1]) == null ? void 0 : _a.segment;
        if (segment.command === "M") {
          newSegments.push(segment);
          return;
        } else if (segment.command === "L") {
          const dividedSegments = divideLine(segment, length2);
          newSegments.push(...dividedSegments);
          return;
        } else if (segment.command === "C") {
          const dividedSegments = divideCurve(segment, length2);
          newSegments.push(...dividedSegments);
        } else if (segment.command === "Q") {
          const dividedSegments = divideQuad(segment, length2);
          newSegments.push(...dividedSegments);
        } else if (segment.command === "Z") {
          newSegments.push(segment);
        }
      });
      newPath.addGroup(newSegments);
    });
    return newPath;
  }
  divideSegmentByCount(count = 1) {
    let allSegments = [];
    const groupList = this.getGroup();
    groupList.forEach((group2) => {
      const newSegments = [];
      group2.segments.forEach(({ segment }, index2) => {
        var _a, _b;
        const prevSegment = (_a = group2.segments[index2 - 1]) == null ? void 0 : _a.segment;
        (_b = group2.segments[index2 + 1]) == null ? void 0 : _b.segment;
        if (segment.command === "M") {
          newSegments.push(segment);
        } else if (segment.command === "L") {
          const linePoints = splitBezierPointsLineByCount([
            {
              x: prevSegment.values[prevSegment.values.length - 2],
              y: prevSegment.values[prevSegment.values.length - 1]
            },
            {
              x: segment.values[0],
              y: segment.values[1]
            }
          ], count);
          linePoints.forEach(([start2, end2]) => {
            newSegments.push(Segment.L(end2.x, end2.y));
          });
        } else if (segment.command === "Q") {
          const quardPoints = splitBezierPointsQuardByCount([
            {
              x: prevSegment.values[prevSegment.values.length - 2],
              y: prevSegment.values[prevSegment.values.length - 1]
            },
            {
              x: segment.values[0],
              y: segment.values[1]
            },
            {
              x: segment.values[2],
              y: segment.values[3]
            }
          ], count);
          quardPoints.forEach(([start2, middle2, end2]) => {
            newSegments.push(Segment.Q(middle2.x, middle2.y, end2.x, end2.y));
          });
        } else if (segment.command === "C") {
          const curvePoints = splitBezierPointsByCount([
            {
              x: prevSegment.values[prevSegment.values.length - 2],
              y: prevSegment.values[prevSegment.values.length - 1]
            },
            {
              x: segment.values[0],
              y: segment.values[1]
            },
            {
              x: segment.values[2],
              y: segment.values[3]
            },
            {
              x: segment.values[4],
              y: segment.values[5]
            }
          ], count);
          curvePoints.forEach(([start2, c1, c2, end2]) => {
            newSegments.push(Segment.C(c1.x, c1.y, c2.x, c2.y, end2.x, end2.y));
          });
        } else if (segment.command === "Z") {
          newSegments.push(segment);
        }
      });
      allSegments = allSegments.concat(newSegments);
    });
    return PathParser.fromSegments(allSegments);
  }
  getBBox() {
    let minX = Number.MAX_SAFE_INTEGER, minY = Number.MAX_SAFE_INTEGER;
    let maxX = Number.MIN_SAFE_INTEGER, maxY = Number.MIN_SAFE_INTEGER;
    this.each(function(segment, index2) {
      var v = segment.values;
      var c2 = segment.command;
      const prevSegment = this.segments[index2 - 1];
      switch (c2) {
        case "M":
        case "L":
          minX = Math.min(minX, v[0]);
          maxX = Math.max(maxX, v[0]);
          minY = Math.min(minY, v[1]);
          maxY = Math.max(maxY, v[1]);
          break;
        case "C":
          getCurveBBox([
            [prevSegment.values[prevSegment.values.length - 2], prevSegment.values[prevSegment.values.length - 1], 0],
            [v[0], v[1], 0],
            [v[2], v[3], 0],
            [v[4], v[5], 0]
          ]).forEach((p) => {
            minX = Math.min(minX, p[0]);
            maxX = Math.max(maxX, p[0]);
            minY = Math.min(minY, p[1]);
            maxY = Math.max(maxY, p[1]);
          });
          break;
        case "Q":
          const curve = normalizeCurveForQuard([
            [prevSegment.values[prevSegment.values.length - 2], prevSegment.values[prevSegment.values.length - 1], 0],
            [v[0], v[1], 0],
            [v[2], v[3], 0]
          ]);
          getCurveBBox(curve).forEach((p) => {
            minX = Math.min(minX, p[0]);
            maxX = Math.max(maxX, p[0]);
            minY = Math.min(minY, p[1]);
            maxY = Math.max(maxY, p[1]);
          });
          break;
      }
      return segment;
    });
    return [
      [minX, minY, 0],
      [maxX, minY, 0],
      [maxX, maxY, 0],
      [minX, maxY, 0]
    ];
  }
  rect() {
    const bbox = this.getBBox();
    return {
      x: bbox[0][0],
      y: bbox[0][1],
      width: distance$1(bbox[0], bbox[1]),
      height: distance$1(bbox[0], bbox[3]),
      right: bbox[0][0] + distance$1(bbox[0], bbox[1]),
      bottom: bbox[0][1] + distance$1(bbox[0], bbox[3])
    };
  }
  getClosedPointInfo({ x: x2, y: y2 }, count = 20) {
    let minDist = Number.MAX_SAFE_INTEGER;
    let targetInfo = {};
    let info = {};
    for (var i = 1, len2 = this.segments.length; i < len2; i++) {
      const segment = this.segments[i];
      const prev = this.segments[i - 1].values;
      const current = segment.values;
      const command = segment.command;
      const lastPoint = { x: prev[prev.length - 2], y: prev[prev.length - 1] };
      if (command === "C") {
        var points2 = [
          lastPoint,
          { x: current[0], y: current[1] },
          { x: current[2], y: current[3] },
          { x: current[4], y: current[5] }
        ];
        var curve = recoverBezier(...points2, count);
        var t = curve(x2, y2);
        info = {
          segment,
          index: i,
          t,
          points: points2,
          targetPoint: getBezierPoints(points2, t).first[3]
        };
      } else if (command === "Q") {
        var points2 = [
          lastPoint,
          { x: current[0], y: current[1] },
          { x: current[2], y: current[3] }
        ];
        var curve = recoverBezierQuard(...points2, count);
        var t = curve(x2, y2);
        info = {
          segment,
          index: i,
          t,
          points: points2,
          targetPoint: getBezierPointsQuard(points2, t).first[2]
        };
      } else if (command === "L") {
        var points2 = [
          lastPoint,
          { x: current[0], y: current[1] }
        ];
        var curve = recoverBezierLine(...points2, count);
        var t = curve(x2, y2);
        info = {
          segment,
          index: i,
          t,
          points: points2,
          targetPoint: getBezierPointsLine(points2, t).first[1]
        };
      }
      if (info) {
        var dist2 = Math.sqrt(Math.pow(info.targetPoint.x - x2, 2) + Math.pow(info.targetPoint.y - y2, 2));
        if (dist2 < minDist) {
          minDist = dist2;
          targetInfo = info;
        }
      }
    }
    return targetInfo;
  }
  getClosedPoint({ x: x2, y: y2 }, count = 20) {
    const info = this.getClosedPointInfo({ x: x2, y: y2 }, count);
    if (info.targetPoint) {
      return info.targetPoint;
    }
    return { x: x2, y: y2 };
  }
  isPointInPath({ x: x2, y: y2 }, dist$1 = 1) {
    const info = this.getClosedPointInfo({ x: x2, y: y2 }, 20);
    if (info.targetPoint) {
      if (dist([info.targetPoint.x, info.targetPoint.y, 0], [x2, y2, 0]) <= dist$1) {
        return true;
      }
    }
    return false;
  }
  toString(split = "") {
    return this.joinPath(void 0, split);
  }
  toSVGString() {
    return this.d;
  }
  transformMat4(transformMatrix, isReturn = false) {
    return this.each(function(segment) {
      var v = segment.values;
      var c2 = segment.command;
      switch (c2) {
        case "M":
        case "L":
          var result = transformMat4([], [v[0], v[1], 0], transformMatrix);
          segment.values = [result[0], result[1]];
          break;
        case "C":
        case "Q":
          for (var i = 0, len2 = v.length; i < len2; i += 2) {
            var result = transformMat4([], [v[i], v[i + 1], 0], transformMatrix);
            segment.values[i] = result[0];
            segment.values[i + 1] = result[1];
          }
          break;
      }
      return segment;
    }, isReturn);
  }
  transform(customTransformFunction = ([x2, y2, z]) => [x2, y2, z]) {
    const bbox = vertiesToRectangle(this.getBBox());
    return this.each(function(segment) {
      var v = segment.values;
      var c2 = segment.command;
      switch (c2) {
        case "M":
        case "L":
        case "C":
        case "Q":
          for (var i = 0, len2 = v.length; i < len2; i += 2) {
            var result = customTransformFunction([v[i], v[i + 1], 0], { bbox });
            segment.values[i] = result[0];
            segment.values[i + 1] = result[1];
          }
          break;
      }
      return segment;
    });
  }
  invert(transformMatrix) {
    this.transformMat4(invert([], transformMatrix));
    return this;
  }
  round(k = 1) {
    this.each(function(segment) {
      segment.values = segment.values.map((it) => round$1(it, k));
      return segment;
    });
    return this;
  }
  reverseSegments(segments2) {
    const newSegments = [];
    let lastIndex = segments2.length - 1;
    for (var i = lastIndex; i > 0; i--) {
      const segment = segments2[i];
      const v = segment.values;
      const c2 = segment.command;
      const prevSegment = segments2[i - 1];
      const lastX = prevSegment.values[prevSegment.values.length - 2];
      const lastY = prevSegment.values[prevSegment.values.length - 1];
      switch (c2) {
        case "L":
          if (i === lastIndex) {
            newSegments.push(Segment.M(v[0], v[1]));
          }
          newSegments.push(Segment.L(lastX, lastY));
          break;
        case "C":
          if (i === lastIndex) {
            newSegments.push(Segment.M(v[4], v[5]));
          }
          newSegments.push(Segment.C(v[2], v[3], v[0], v[1], lastX, lastY));
          break;
        case "Q":
          if (i === lastIndex) {
            newSegments.push(Segment.M(v[2], v[3]));
          }
          newSegments.push(Segment.Q(v[0], v[1], lastX, lastY));
          break;
        case "Z":
          newSegments.push(segment);
          lastIndex = i - 1;
          break;
      }
    }
    if (newSegments[0].command === "Z") {
      newSegments.push(newSegments.shift());
    }
    return newSegments;
  }
  splitSegments() {
    const groupSegments = [];
    let newSegments = [];
    this.segments.forEach((s) => {
      if (s.command === "M") {
        newSegments = [s];
        groupSegments.push(newSegments);
      } else {
        newSegments.push(s);
      }
    });
    return groupSegments;
  }
  reverse(...groupIndexList) {
    const groupSegments = this.splitSegments();
    const newSegments = [];
    if (groupIndexList.length === 0) {
      groupSegments.forEach((segments2, index2) => {
        newSegments.push.apply(newSegments, this.reverseSegments(segments2));
      });
    } else {
      groupSegments.forEach((segments2, index2) => {
        if (groupIndexList.includes(index2)) {
          newSegments.push.apply(newSegments, this.reverseSegments(segments2));
        } else {
          newSegments.push.apply(newSegments, segments2);
        }
      });
    }
    return this.resetSegments(newSegments);
  }
  reversePathStringByFunc(func2) {
    const pathList = this.toPathList().map((p, index2) => {
      if (func2(p, index2)) {
        return p.reverse();
      }
      return p;
    });
    return PathParser.joinPathList(pathList).toSVGString();
  }
  getCenterPointers() {
    let arr = [];
    let lastValues = [];
    this.segments.forEach((segment, index2) => {
      var v = segment.values;
      var c2 = segment.command;
      switch (c2) {
        case "M":
        case "L":
          arr.push({
            index: index2,
            pointer: [...segment.values, 0]
          });
          break;
        case "V":
          arr.push({
            index: index2,
            pointer: [v[0], lastValues.pop(), 0]
          });
          break;
        case "H":
          lastValues.pop();
          arr.push({
            index: index2,
            pointer: [lastValues.pop(), v[0], 0]
          });
          break;
        case "C":
        case "S":
        case "T":
        case "Q":
          arr.push({
            index: index2,
            pointer: [v[v.length - 2], v[v.length - 1], 0]
          });
          break;
      }
      lastValues = clone$1(v);
    });
    return arr;
  }
  get points() {
    return this.getCenterPointers();
  }
  getSamePointers(pointer, dist2 = 0) {
    return this.getCenterPointers().filter((p) => {
      if (distance$1(p.pointer, pointer) <= dist2) {
        return true;
      }
    });
  }
  getGroup() {
    const groupSegments = [];
    let newSegments = [];
    this.segments.forEach((segment, index2) => {
      if (segment.command === "M") {
        newSegments = [{
          index: index2,
          segment
        }];
        groupSegments.push({ index: index2, groupIndex: groupSegments.length, segments: newSegments });
      } else {
        newSegments.push({
          index: index2,
          segment
        });
      }
    });
    return groupSegments;
  }
  createGroupPath(index2) {
    var _a, _b;
    const path = new PathParser();
    path.resetSegments(((_b = (_a = this.getGroup()[index2]) == null ? void 0 : _a.segments) == null ? void 0 : _b.map((it) => {
      return it.segment;
    })) || []);
    return path;
  }
  toPathList() {
    return this.getGroup().map((group2) => {
      return PathParser.fromSegments(group2.segments.map((it) => it.segment));
    });
  }
  replaceSegment(index2, ...segments2) {
    const newSegments = [...this.segments];
    newSegments.splice(index2, 1, ...segments2);
    this.resetSegments(newSegments);
  }
  splitSegmentByPoint(pos, dist2 = 0) {
    const closedPointInfo = this.getClosedPointInfo(pos, dist2);
    if (closedPointInfo && closedPointInfo.t > 0 && closedPointInfo.t < 1) {
      switch (closedPointInfo.segment.command) {
        case "C":
          var list2 = getBezierPoints(closedPointInfo.points, closedPointInfo.t);
          var first = list2.first;
          var firstSegment = Segment.C(first[1].x, first[1].y, first[2].x, first[2].y, first[3].x, first[3].y);
          var second2 = list2.second;
          var secondSegment = Segment.C(second2[1].x, second2[1].y, second2[2].x, second2[2].y, second2[3].x, second2[3].y);
          this.replaceSegment(closedPointInfo.index, firstSegment, secondSegment);
          break;
        case "Q":
          var list2 = getBezierPointsQuard(closedPointInfo.points, closedPointInfo.t);
          var first = list2.first;
          var firstSegment = Segment.Q(first[1].x, first[1].y, first[2].x, first[2].y);
          var second2 = list2.second;
          var secondSegment = Segment.Q(second2[1].x, second2[1].y, second2[2].x, second2[2].y);
          this.replaceSegment(closedPointInfo.index, firstSegment, secondSegment);
          break;
        case "L":
          var list2 = getBezierPointsLine(closedPointInfo.points, closedPointInfo.t);
          var first = list2.first;
          var firstSegment = Segment.L(first[1].x, first[1].y);
          var second2 = list2.second;
          var secondSegment = Segment.L(second2[1].x, second2[1].y);
          this.replaceSegment(closedPointInfo.index, firstSegment, secondSegment);
          break;
        default:
          return;
      }
      return closedPointInfo;
    }
  }
  toMultiSegmentPathList() {
    const paths = [];
    const group2 = this.getGroup();
    group2.forEach((group3, index2) => {
      group3.segments.forEach((s, index3) => {
        var _a;
        const prevSegment = group3.segments[index3 - 1];
        const lastValues = ((_a = prevSegment == null ? void 0 : prevSegment.segment) == null ? void 0 : _a.values) || [];
        const lastX = lastValues[lastValues.length - 2];
        const lastY = lastValues[lastValues.length - 1];
        const values = s.segment.values;
        if (s.segment.command === "M")
          ;
        else if (s.segment.command === "L") {
          paths.push(new PathParser(`M ${lastX} ${lastY}L ${values.join(" ")}`));
        } else if (s.segment.command === "C") {
          paths.push(new PathParser(`M ${lastX} ${lastY}C ${values.join(" ")}`));
        } else if (s.segment.command === "Q") {
          paths.push(new PathParser(`M ${lastX} ${lastY}Q ${values.join(" ")}`));
        } else
          ;
      });
    });
    return paths;
  }
  simplify(tolerance = 0.1) {
    const newGroupSegments = [];
    const groupList = this.getGroup();
    groupList.forEach((group2, groupIndex) => {
      const points2 = [
        ...group2.segments.filter((it) => it.segment.command.toLowerCase() !== "z").map((it) => {
          return {
            x: it.segment.values[0],
            y: it.segment.values[1]
          };
        })
      ];
      const newPoints = Point.simply(points2, tolerance);
      const newSegments = [];
      newPoints.forEach((p, index2) => {
        if (index2 === 0) {
          newSegments.push(Segment.M(p.x, p.y));
        } else {
          newSegments.push(Segment.L(p.x, p.y));
        }
      });
      newGroupSegments.push(...newSegments);
    });
    return PathParser.fromSegments(newGroupSegments);
  }
  smooth(error = 50) {
    let newGroupSegments = [];
    const groupList = this.getGroup();
    groupList.forEach((group2, groupIndex) => {
      const points2 = [
        ...group2.segments.filter((it) => it.segment.command.toLowerCase() !== "z").map((it) => {
          return [...it.segment.values, 0];
        })
      ];
      const bezierCurve = fitCurve(points2, error);
      const newSegments = [];
      bezierCurve.forEach((curve, index2) => {
        if (index2 === 0) {
          newSegments.push(Segment.M(...curve[0]));
        }
        newSegments.push(Segment.C(curve[1][0], curve[1][1], curve[2][0], curve[2][1], curve[3][0], curve[3][1]));
      });
      if (group2.segments[group2.segments.length - 1].segment.command.toLowerCase() === "z") {
        newSegments.push(Segment.Z());
      }
      newGroupSegments = newGroupSegments.concat(newSegments);
    });
    return PathParser.fromSegments(newGroupSegments);
  }
  cardinalSplines(tension = 0.5) {
    const newGroupSegments = [];
    const groupList = this.getGroup();
    groupList.forEach((group2, groupIndex) => {
      const points2 = [
        ...group2.segments.filter((it) => it.segment.command.toLowerCase() !== "z").map((it) => {
          return [...it.segment.values, 0];
        })
      ];
      const newPoints = [];
      points2.forEach((point2, index2) => {
        const prevPoint = points2[index2 - 1];
        const nextPoint = points2[index2 + 1];
        if (index2 === 0) {
          newPoints.push({ point: point2 });
        } else if (index2 === points2.length - 1) {
          const firstPoint = points2[0];
          if (equals$1(firstPoint, point2)) {
            const p0 = prevPoint;
            const p1 = point2;
            const p2 = points2[1];
            const V1 = div$1([], subtract([], p2, p0), [2, 2, 1]);
            const V3 = multiply([], V1, [1 - tension, 1 - tension, 1]);
            const V2 = negate([], V3);
            newPoints.push({ reversePoint: add$1([], p1, V2), point: p1, endPoint: add$1([], p1, V3) });
          } else {
            newPoints.push({ point: point2 });
          }
        } else {
          const p0 = prevPoint;
          const p1 = point2;
          const p2 = nextPoint;
          const V1 = div$1([], subtract([], p2, p0), [2, 2, 1]);
          const V3 = multiply([], V1, [1 - tension, 1 - tension, 1]);
          const V2 = negate([], V3);
          newPoints.push({ reversePoint: add$1([], p1, V2), point: p1, endPoint: add$1([], p1, V3) });
        }
      });
      const newSegments = [];
      newPoints.forEach((p, index2) => {
        if (index2 === 0) {
          newSegments.push(Segment.M(p.point[0], p.point[1]));
        } else {
          const prevPoint = newPoints[index2 - 1] || newPoints[newPoints.length - 1];
          if (!prevPoint.endPoint) {
            if (index2 === 1) {
              const lastPoint = newPoints[newPoints.length - 1];
              if (lastPoint.endPoint) {
                newSegments.push(Segment.C(lastPoint.endPoint[0], lastPoint.endPoint[1], p.reversePoint[0], p.reversePoint[1], p.point[0], p.point[1]));
              } else {
                newSegments.push(Segment.Q(p.reversePoint[0], p.reversePoint[1], p.point[0], p.point[1]));
              }
            } else {
              newSegments.push(Segment.Q(p.reversePoint[0], p.reversePoint[1], p.point[0], p.point[1]));
            }
          } else if (!p.reversePoint) {
            newSegments.push(Segment.Q(prevPoint.endPoint[0], prevPoint.endPoint[1], p.point[0], p.point[1]));
          } else {
            newSegments.push(Segment.C(prevPoint.endPoint[0], prevPoint.endPoint[1], p.reversePoint[0], p.reversePoint[1], p.point[0], p.point[1]));
          }
        }
      });
      newGroupSegments.push(...newSegments);
    });
    const newPath = new PathParser();
    newPath.resetSegments(newGroupSegments);
    return newPath;
  }
  Z() {
    this.segments.push(Segment.Z());
    return this;
  }
  M(x2, y2) {
    this.segments.push(Segment.M(x2, y2));
    return this;
  }
  L(x2, y2) {
    this.segments.push(Segment.L(x2, y2));
    return this;
  }
  C(x1, y1, x2, y2, x3, y3) {
    this.segments.push(Segment.C(x1, y1, x2, y2, x3, y3));
    return this;
  }
  Q(x1, y1, x2, y2) {
    this.segments.push(Segment.Q(x1, y1, x2, y2));
    return this;
  }
  drawRect(x2, y2, width2, height2) {
    this.segments.push(Segment.M(x2, y2), Segment.L(x2 + width2, y2), Segment.L(x2 + width2, y2 + height2), Segment.L(x2, y2 + height2), Segment.L(x2, y2), Segment.Z());
    return this;
  }
  drawLine(x1, y1, x2, y2) {
    this.segments.push(Segment.M(x1, y1), Segment.L(x2, y2));
    return this;
  }
  drawCircleWithRect(x2, y2, width2, height2 = width2) {
    var segmentSize = 0.552284749831;
    const path = new PathParser();
    path.resetSegments([
      Segment.M(0, -1),
      Segment.C(segmentSize, -1, 1, -segmentSize, 1, 0),
      Segment.C(1, segmentSize, segmentSize, 1, 0, 1),
      Segment.C(-segmentSize, 1, -1, segmentSize, -1, 0),
      Segment.C(-1, -segmentSize, -segmentSize, -1, 0, -1),
      Segment.Z()
    ]);
    path.translate(1, 1).scale(width2 / 2, height2 / 2).translate(x2, y2);
    this.addPath(path);
    return this;
  }
  drawCircle(cx, cy, radius) {
    return this.drawCircleWithRect(cx - radius, cy - radius, radius * 2, radius * 2);
  }
  drawArc(rx, ry, xAxisRotation, largeArcFlag, sweepFlag, x2, y2) {
    const [x1, y1] = this.lastPoint;
    return this.addPath(PathParser.arcToCurve(x1, y1, rx, ry, xAxisRotation, largeArcFlag, sweepFlag, x2, y2));
  }
  get verties() {
    let arr = [];
    let lastValues = [];
    this.each(function(segment) {
      var v = segment.values;
      var c2 = segment.command;
      switch (c2) {
        case "M":
        case "L":
          arr.push([...segment.values, 0]);
          break;
        case "V":
          arr.push([v[0], lastValues.pop(), 0]);
          break;
        case "H":
          lastValues.pop();
          arr.push([lastValues.pop(), v[0], 0]);
          break;
        case "C":
        case "S":
        case "T":
        case "Q":
          for (var i = 0, len2 = v.length; i < len2; i += 2) {
            arr.push([v[i], v[i + 1], 0]);
          }
          break;
      }
      lastValues = v;
    });
    return arr;
  }
  get pathVerties() {
    const pathVerties = [];
    this.segments.forEach((segment, segmentIndex) => {
      if (segment.values.length > 0) {
        const arr = segment.values;
        for (var i = 0, len2 = arr.length; i < len2; i += 2) {
          pathVerties.push({
            segmentIndex,
            valueIndex: i,
            x: arr[i],
            y: arr[i + 1]
          });
        }
      }
    });
    return pathVerties;
  }
  get d() {
    return this.toString().trim();
  }
  get closed() {
    return this.segments.some((segment) => segment.command === "Z") && equals(this.lastPoint, this.firstPoint);
  }
  get opened() {
    return !this.closed;
  }
  get length() {
    let totalLength = 0;
    const group2 = this.getGroup();
    group2.forEach((group3, index2) => {
      group3.segments.forEach((s, index3) => {
        var _a;
        const prevSegment = group3.segments[index3 - 1];
        const lastValues = ((_a = prevSegment == null ? void 0 : prevSegment.segment) == null ? void 0 : _a.values) || [];
        const lastX = lastValues[lastValues.length - 2];
        const lastY = lastValues[lastValues.length - 1];
        const values = s.segment.values;
        if (s.segment.command === "M")
          ;
        else if (s.segment.command === "L") {
          totalLength += getDist(lastX, lastY, values[0], values[1]);
        } else if (s.segment.command === "C") {
          totalLength += getCurveDist(lastX, lastY, values[0], values[1], values[2], values[3], values[4], values[5]);
        } else if (s.segment.command === "Q") {
          totalLength += getQuardDist(lastX, lastY, values[0], values[1], values[2], values[3]);
        } else
          ;
      });
    });
    return totalLength;
  }
  get lengthList() {
    let totalLengthList = [];
    const group2 = this.getGroup();
    group2.forEach((group3, groupIndex) => {
      group3.segments.forEach((s, index2) => {
        var _a;
        const prevSegment = group3.segments[index2 - 1];
        const lastValues = ((_a = prevSegment == null ? void 0 : prevSegment.segment) == null ? void 0 : _a.values) || [];
        const lastX = lastValues[lastValues.length - 2];
        const lastY = lastValues[lastValues.length - 1];
        const values = s.segment.values;
        if (s.segment.command === "M")
          ;
        else if (s.segment.command === "L") {
          totalLengthList.push({
            groupIndex,
            segmentIndex: index2,
            length: getDist(lastX, lastY, values[0], values[1])
          });
        } else if (s.segment.command === "C") {
          totalLengthList.push({
            groupIndex,
            segmentIndex: index2,
            length: getCurveDist(lastX, lastY, values[0], values[1], values[2], values[3], values[4], values[5])
          });
        } else if (s.segment.command === "Q") {
          totalLengthList.push({
            groupIndex,
            segmentIndex: index2,
            length: getQuardDist(lastX, lastY, values[0], values[1], values[2], values[3])
          });
        } else
          ;
      });
    });
    return totalLengthList;
  }
  get lastSegment() {
    const segment = this.segments[this.segments.length - 1];
    if (segment.command !== "Z") {
      return segment;
    }
    return this.segments[this.segments.length - 2];
  }
  get lastPoint() {
    const values = this.lastSegment.values;
    return [
      values[values.length - 2],
      values[values.length - 1]
    ];
  }
  get firstSegment() {
    const segment = this.segments[0];
    return segment;
  }
  get firstPoint() {
    const values = this.firstSegment.values;
    return [
      values[0],
      values[1]
    ];
  }
  static joinPathList(pathList = []) {
    const newPath = PathParser.fromSVGString();
    pathList.forEach((path) => {
      newPath.addPath(path);
    });
    return newPath;
  }
  static fromSegments(segments2) {
    const path = new PathParser();
    path.resetSegments(segments2);
    return path;
  }
  static fromSVGString(d = "") {
    return new PathParser(d);
  }
  static makeRect(x2, y2, width2, height2) {
    return PathParser.fromSVGString().drawRect(x2, y2, width2, height2);
  }
  static makeLine(x2, y2, x22, y22) {
    return PathParser.fromSVGString().drawLine(x2, y2, x22, y22);
  }
  static makeCircle(x2, y2, width2, height2) {
    return PathParser.fromSVGString().drawCircleWithRect(x2, y2, width2, height2);
  }
  static makePathByPoints(points2 = []) {
    const segments2 = points2.map((p, index2) => {
      if (index2 === 0) {
        return Segment.M(p.x, p.y);
      } else {
        return Segment.L(p.x, p.y);
      }
    });
    segments2.push(Segment.Z());
    return PathParser.fromSegments(segments2);
  }
  static makePathByVerties(verties = [], isClosed = true) {
    const segments2 = verties.map((v, index2) => {
      if (index2 === 0) {
        return Segment.M(v[0], v[1]);
      } else {
        return Segment.L(v[0], v[1]);
      }
    });
    if (isClosed) {
      segments2.push(Segment.Z());
    }
    return PathParser.fromSegments(segments2);
  }
  static makePolygon(width2, height2, count = 3) {
    const segments2 = [];
    const centerX = 1 / 2;
    const centerY = 1 / 2;
    for (var i = 0; i < count; i++) {
      var angle2 = i / count * Math.PI * 2 - Math.PI / 2;
      var x2 = Math.cos(angle2) * centerX + centerX;
      var y2 = Math.sin(angle2) * centerY + centerY;
      if (i === 0) {
        segments2.push(Segment.M(x2, y2));
      } else {
        segments2.push(Segment.L(x2, y2));
      }
    }
    segments2.push(Segment.L(segments2[0].values[0], segments2[0].values[1]));
    segments2.push(Segment.Z());
    return PathParser.fromSegments(segments2).scale(width2, height2);
  }
  static makeStar(width2, height2, count = 5, radius = 0.5) {
    const segments2 = [];
    const centerX = 1 / 2;
    const centerY = 1 / 2;
    const outerRadius = Math.min(centerX, centerY);
    const innerRadius = outerRadius * radius;
    const npoints = count * 2;
    let firstX, firstY = 0;
    for (var i = 0; i < npoints; i++) {
      var angle2 = i / npoints * Math.PI * 2 - Math.PI / 2;
      var radius = i % 2 === 0 ? outerRadius : innerRadius;
      var x2 = Math.cos(angle2) * radius + centerX;
      var y2 = Math.sin(angle2) * radius + centerY;
      if (i === 0) {
        segments2.push(Segment.M(x2, y2));
        firstX = x2;
        firstY = y2;
      } else {
        segments2.push(Segment.L(x2, y2));
      }
    }
    segments2.push(Segment.L(firstX, firstY));
    segments2.push(Segment.Z());
    return PathParser.fromSegments(segments2).scale(width2, height2);
  }
  static makeCurvedStar(width2, height2, count = 5, radius = 0.5, tension = 0.5) {
    const starPath = PathParser.makeStar(width2, height2, count, radius);
    return starPath.cardinalSplines(tension);
  }
  static arcToCurve(x1, y1, rx, ry, xAxisRotation, largeArcFlag, sweepFlag, x2, y2) {
    const bezierCurveList = arcToBezier({
      px: x1,
      py: y1,
      cx: x2,
      cy: y2,
      rx,
      ry,
      xAxisRotation,
      largeArcFlag,
      sweepFlag
    });
    const path = new PathParser();
    path.M(x1, y1);
    bezierCurveList.forEach((bezierCurve) => {
      path.C(bezierCurve.x1, bezierCurve.y1, bezierCurve.x2, bezierCurve.y2, bezierCurve.x, bezierCurve.y);
    });
    return path;
  }
}
function makeInterpolatePathValues(layer2, property, s, e2) {
  var max = Math.max(s.length, e2.length);
  var list2 = [];
  var startLastPos = s[s.length - 1];
  var endLastPos = e2[e2.length - 1];
  for (var i = 0; i < max; i++) {
    var startPos = s[i];
    var endPos = e2[i];
    if (startPos && !endPos) {
      list2.push(makeInterpolateNumber$1(layer2, property, startPos, endLastPos));
    } else if (!startPos && endPos) {
      list2.push(makeInterpolateNumber$1(layer2, property, startLastPos, endPos));
    } else {
      list2.push(makeInterpolateNumber$1(layer2, property, startPos, endPos));
    }
  }
  return (rate, t) => {
    return list2.map((it) => it(rate, t));
  };
}
function makeInterpolatePath(layer2, property, startValue, endValue) {
  var returnParser = new PathParser();
  var s = new PathParser(startValue);
  var e2 = new PathParser(endValue);
  var max = Math.max(s.segments.length, e2.segments.length);
  var list2 = [];
  for (var i = 0; i < max; i++) {
    var sc = s.segments[i];
    var ec = e2.segments[i];
    if (sc.command === ec.command) {
      if (sc.values.length === ec.values.length) {
        list2.push({
          command: makeInterpolateIdentity(layer2, property, sc.command),
          values: makeInterpolatePathValues(layer2, property, sc.values, ec.values)
        });
      } else {
        list2.push({
          command: makeInterpolateIdentity(layer2, property, sc.command),
          values: makeInterpolateIdentity(layer2, property, sc.values)
        });
      }
    } else {
      list2.push({
        command: makeInterpolateBoolean(layer2, property, sc.command, ec.command),
        values: makeInterpolateBoolean(layer2, property, sc.values, ec.values)
      });
    }
  }
  return (rate, t) => {
    var segments2 = list2.map((it) => {
      return {
        command: it.command(rate, t),
        values: it.values(rate, t)
      };
    });
    var results = returnParser.joinPath(segments2);
    return results;
  };
}
class PathStringManager {
  constructor() {
    this.pathArray = [];
  }
  reset() {
    this.pathArray = [];
  }
  getPointString(values) {
    return values.map((v) => `${v.x} ${v.y}`).join(" ");
  }
  makeString(command, values = []) {
    this.pathArray.push(`${command} ${this.getPointString(values)}`);
    return this;
  }
  M(...values) {
    return this.makeString("M", values);
  }
  L(...values) {
    return this.makeString("L", values);
  }
  X(...values) {
    const dist2 = 3;
    const point2 = values[0];
    const topLeft = { x: point2.x - dist2, y: point2.y - dist2 };
    const topRight = { x: point2.x + dist2, y: point2.y - dist2 };
    const bottomLeft = { x: point2.x - dist2, y: point2.y + dist2 };
    const bottomRight = { x: point2.x + dist2, y: point2.y + dist2 };
    return this.M(topLeft).L(bottomRight).M(topRight).L(bottomLeft);
  }
  Q(...values) {
    return this.makeString("Q", values);
  }
  C(...values) {
    return this.makeString("C", values);
  }
  Z() {
    return this.makeString("Z");
  }
  get d() {
    return this.pathArray.join(" ").trim();
  }
  toString(className = "object") {
    return `<path d="${this.d}" class='${className}'/>`;
  }
}
const splitReg = /[\b\t \,]/g;
class PolygonParser extends PathParser {
  constructor(points2 = "") {
    super(points2);
  }
  reset(points2 = "") {
    this.segments = [];
    this.points = points2;
    this.parse();
  }
  resetSegments(segments2 = []) {
    this.segments = segments2;
    this.points = this.joinPoints();
  }
  parse() {
    var points2 = this.points;
    if (Array.isArray(points2)) {
      points2 = points2.join(" ");
    }
    var arr = points2.trim().split(splitReg).filter((it) => it);
    var segments2 = [];
    for (var i = 0, len2 = arr.length; i < len2; i += 2) {
      segments2.push({ x: +arr[i], y: +arr[i + 1] });
    }
    this.segments = segments2;
  }
  convertGenerator() {
    return this.segments;
  }
  length() {
    return this.segments.length;
  }
  toPathString() {
    var path = new PathStringManager();
    for (var i = 0, len2 = this.segments.length; i < len2; i++) {
      var s = this.segments[i];
      if (i === 0) {
        path.M(s);
      } else if (i === len2 - 1) {
        path.L(s).L(this.segments[0]).Z();
      } else {
        path.L(s);
      }
    }
    return path.d;
  }
  joinPath(segments2) {
    return this.joinPoints(segments2);
  }
  joinPoints(segments2) {
    var list2 = segments2 || this.segments;
    return list2.map((it) => {
      return `${it.x},${it.y}`;
    }).join(" ");
  }
  each(callback, isReturn = false) {
    var newSegments = this.segments.map((segment) => {
      return callback.call(this, segment);
    });
    if (isReturn) {
      return newSegments;
    } else {
      this.segments = newSegments;
    }
  }
  _loop(m, isReturn = false) {
    return this.each(function(segment) {
      var [x2, y2] = m([segment.x, segment.y], 0);
      segment.x = x2;
      segment.y = y2;
      return segment;
    }, isReturn);
  }
  clone() {
    return new PolygonParser(this.joinPoints());
  }
  toString() {
    return this.joinPoints();
  }
}
function makeInterpolatePolygon(layer2, property, startValue, endValue) {
  var returnParser = new PolygonParser();
  var s = new PolygonParser(startValue);
  var e2 = new PolygonParser(endValue);
  var max = Math.max(s.segments.length, e2.segments.length);
  var list2 = [];
  var startLastX = s.segments[s.segments.length - 1].x;
  var startLastY = s.segments[s.segments.length - 1].y;
  var endLastX = e2.segments[e2.segments.length - 1].x;
  var endLastY = e2.segments[e2.segments.length - 1].y;
  for (var i = 0; i < max; i++) {
    var startPos = s.segments[i];
    var endPos = e2.segments[i];
    if (startPos && !endPos) {
      list2.push({
        x: makeInterpolateNumber$1(layer2, property, startPos.x, endLastX),
        y: makeInterpolateNumber$1(layer2, property, startPos.y, endLastY)
      });
    } else if (!startPos && endPos) {
      list2.push({
        x: makeInterpolateNumber$1(layer2, property, startLastX, endPos.x),
        y: makeInterpolateNumber$1(layer2, property, startLastY, endPos.y)
      });
    } else {
      list2.push({
        x: makeInterpolateNumber$1(layer2, property, startPos.x, endPos.x),
        y: makeInterpolateNumber$1(layer2, property, startPos.y, endPos.y)
      });
    }
  }
  return (rate, t) => {
    var points2 = returnParser.joinPoints(list2.map((it) => {
      return {
        x: it.x(rate, t),
        y: it.y(rate, t)
      };
    }));
    return points2;
  };
}
function makeInterpolateLine(x1, y1, x2, y2) {
  var obj2 = {
    x: makeInterpolateNumber$1("", "", x1, x2),
    y: makeInterpolateNumber$1("", "", y1, y2)
  };
  return (rate, t) => {
    var results = {
      x: obj2.x(rate, t),
      y: obj2.y(rate, t)
    };
    return results;
  };
}
function makeInterpolateQuard(sx, sy, cx1, cy1, ex, ey) {
  var points2 = [
    { x: sx, y: sy },
    { x: cx1, y: cy1 },
    { x: ex, y: ey }
  ];
  return (rate, t) => {
    return getBezierPointOneQuard(points2, t);
  };
}
function makeInterpolateCubic(sx, sy, cx1, cy1, cx2, cy2, ex, ey) {
  var points2 = [
    { x: sx, y: sy },
    { x: cx1, y: cy1 },
    { x: cx2, y: cy2 },
    { x: ex, y: ey }
  ];
  return (rate, t) => {
    return getBezierPointOne(points2, t);
  };
}
function makeInterpolateOffset(segments2) {
  var interpolateList = [];
  var startPoint = [];
  segments2.forEach((segment, index2) => {
    switch (segment.command) {
      case "M":
        var [ex, ey] = segment.values;
        startPoint = [ex, ey];
        break;
      case "m":
        var [sx, sy] = startPoint;
        var [ex, ey] = segment.values;
        ex += sx;
        ey += sy;
        startPoint = [ex, ey];
        break;
      case "L":
        var [sx, sy] = startPoint;
        var [ex, ey] = segment.values;
        interpolateList.push({
          command: segment.command,
          values: [sx, sy, ex, ey],
          length: getDist(sx, sy, ex, ey),
          interpolate: makeInterpolateLine(sx, sy, ex, ey)
        });
        startPoint = [ex, ey];
        break;
      case "l":
        var [sx, sy] = startPoint;
        var [ex, ey] = segment.values;
        ex += sx;
        ey += sy;
        interpolateList.push({
          command: segment.command,
          values: [sx, sy, ex, ey],
          length: getDist(sx, sy, ex, ey),
          interpolate: makeInterpolateLine(sx, sy, ex, ey)
        });
        startPoint = [ex, ey];
        break;
      case "C":
        var [sx, sy] = startPoint;
        var [cx1, cy1, cx2, cy2, ex, ey] = segment.values;
        interpolateList.push({
          command: segment.command,
          values: [sx, sy, cx1, cy1, cx2, cy2, ex, ey],
          length: getCurveDist(sx, sy, cx1, cy1, cx2, cy2, ex, ey),
          interpolate: makeInterpolateCubic(sx, sy, cx1, cy1, cx2, cy2, ex, ey)
        });
        startPoint = [ex, ey];
        break;
      case "c":
        var [sx, sy] = startPoint;
        var [cx1, cy1, cx2, cy2, ex, ey] = segment.values;
        cx1 += sx;
        cx2 += sx;
        ex += sx;
        cy1 += sy;
        cy2 += sy;
        ey += sy;
        interpolateList.push({
          command: segment.command,
          values: [sx, sy, cx1, cy1, cx2, cy2, ex, ey],
          length: getCurveDist(sx, sy, cx1, cy1, cx2, cy2, ex, ey),
          interpolate: makeInterpolateCubic(sx, sy, cx1, cy1, cx2, cy2, ex, ey)
        });
        startPoint = [ex, ey];
        break;
      case "Q":
        var [sx, sy] = startPoint;
        var [cx1, cy1, ex, ey] = segment.values;
        interpolateList.push({
          command: segment.command,
          values: [sx, sy, cx1, cy1, ex, ey],
          length: getQuardDist(sx, sy, cx1, cy1, ex, ey),
          interpolate: makeInterpolateQuard(sx, sy, cx1, cy1, ex, ey)
        });
        startPoint = [ex, ey];
        break;
      case "q":
        var [sx, sy] = startPoint;
        var [cx1, cy1, ex, ey] = segment.values;
        cx1 += sx;
        ex += sx;
        cy1 += sy;
        ey += sy;
        interpolateList.push({
          command: segment.command,
          values: [sx, sy, cx1, cy1, ex, ey],
          length: getQuardDist(sx, sy, cx1, cy1, ex, ey),
          interpolate: makeInterpolateQuard(sx, sy, cx1, cy1, ex, ey)
        });
        startPoint = [ex, ey];
        break;
      case "S":
        var [sx, sy] = startPoint;
        var [cx2, cy2, ex, ey] = segment.values;
        var prevSegment = interpolateList[interpolateList.length - 1];
        if (["C", "c", "S", "s"].includes(prevSegment.command)) {
          var [_, _, _, _, preC1x, preC1y, preEx, preEy] = prevSegment.values;
          var { x: cx1, y: cy1 } = Point.getReversePoint({ x: preEx, y: preEy }, { x: preC1x, preC1y });
          interpolateList.push({
            command: segment.command,
            values: [sx, sy, cx1, cy1, cx2, cy2, ex, ey],
            length: getCubicDist(sx, sy, cx1, cy1, cx2, cy2, ex, ey),
            interpolate: makeInterpolateCubic(sx, sy, cx1, cy1, cx2, cy2, ex, ey)
          });
          startPoint = [ex, ey];
          break;
        }
      case "s":
        var [sx, sy] = startPoint;
        var [cx2, cy2, ex, ey] = segment.values;
        cx2 += sx;
        ex += sx;
        cy2 += sy;
        ey += sy;
        var prevSegment = interpolateList[interpolateList.length - 1];
        if (["C", "c", "S", "s"].includes(prevSegment.command)) {
          var [_, _, _, _, preC1x, preC1y, preEx, preEy] = prevSegment.values;
          var { x: cx1, y: cy1 } = Point.getReversePoint({ x: preEx, y: preEy }, { x: preC1x, preC1y });
          interpolateList.push({
            command: segment.command,
            values: [sx, sy, cx1, cy1, cx2, cy2, ex, ey],
            length: getCubicDist(sx, sy, cx1, cy1, cx2, cy2, ex, ey),
            interpolate: makeInterpolateCubic(sx, sy, cx1, cy1, cx2, cy2, ex, ey)
          });
          startPoint = [ex, ey];
          break;
        }
      case "T":
        var [sx, sy] = startPoint;
        var [ex, ey] = segment.values;
        var prevSegment = interpolateList[interpolateList.length - 1];
        if (["Q", "q", "T", "t"].includes(prevSegment.command)) {
          var [_, _, preC1x, preC1y, preEx, preEy] = prevSegment.values;
          var { x: cx1, y: cy1 } = Point.getReversePoint({ x: preEx, y: preEy }, { x: preC1x, preC1y });
          interpolateList.push({
            command: segment.command,
            values: [sx, sy, cx1, cy1, ex, ey],
            length: getQuardDist(sx, sy, cx1, cy1, ex, ey),
            interpolate: makeInterpolateQuard(sx, sy, cx1, cy1, ex, ey)
          });
          startPoint = [ex, ey];
        }
        break;
      case "t":
        var [sx, sy] = startPoint;
        var [ex, ey] = segment.values;
        ex += sx;
        ey += sy;
        var prevSegment = interpolateList[interpolateList.length - 1];
        if (["Q", "q", "T", "t"].includes(prevSegment.command)) {
          var [_, _, preC1x, preC1y, preEx, preEy] = prevSegment.values;
          var { x: cx1, y: cy1 } = Point.getReversePoint({ x: preEx, y: preEy }, { x: preC1x, preC1y });
          interpolateList.push({
            command: segment.command,
            values: [sx, sy, cx1, cy1, ex, ey],
            length: getQuardDist(sx, sy, cx1, cy1, ex, ey),
            interpolate: makeInterpolateQuard(sx, sy, cx1, cy1, ex, ey)
          });
          startPoint = [ex, ey];
        }
        break;
    }
  });
  var totalLength = 0;
  interpolateList.forEach((it) => {
    totalLength += it.length;
  });
  var start2 = 0;
  interpolateList.forEach((it) => {
    it.startT = start2 / totalLength;
    it.endT = (start2 + it.length) / totalLength;
    it.totalLength = totalLength;
    start2 += it.length;
  });
  return { totalLength, interpolateList };
}
function makeInterpolateOffsetPath(layer2, property, startValue, endValue, artboard2) {
  var [id, distance2, rotateStatus, rotate2] = startValue.split(",").map((it) => it.trim());
  var startObject = { id, distance: Length.parse(distance2 || "0%"), rotateStatus: rotateStatus || "auto", rotate: Length.parse(rotate2 || "0deg") };
  var innerInterpolate = (rate, t) => {
    return { x, y };
  };
  var innerInterpolateAngle = (rotateStatus2, currentAngle) => {
    var resultAngle = 0;
    switch (rotateStatus2) {
      case "angle":
        resultAngle = startObject.rotate.value;
        break;
      case "auto angle":
        resultAngle = currentAngle + startObject.rotate.value;
        break;
      case "reverse":
        resultAngle = currentAngle + 180;
        break;
      case "auto":
        resultAngle = currentAngle;
        break;
    }
    return resultAngle;
  };
  var screenX = 0, screenY = 0;
  if (artboard2) {
    var pathLayer = artboard2.searchById(startObject.id);
    if (pathLayer) {
      screenX = pathLayer.screenX.value;
      screenY = pathLayer.screenY.value;
    }
    innerInterpolate = (rate, t, timing) => {
      var parser2 = new PathParser(pathLayer.d || "");
      var { totalLength, interpolateList } = makeInterpolateOffset(parser2.segments);
      var distance3 = startObject.distance.toPx(totalLength);
      var dt = distance3 / totalLength;
      t = t + dt;
      if (t > 1) {
        t -= 1;
      }
      var obj2 = interpolateList[0];
      if (t === 0) {
        obj2 = interpolateList[0];
      } else if (t === 1) {
        obj2 = interpolateList[interpolateList.length - 1];
      }
      var arr = interpolateList.find((it) => {
        return it.startT <= t && t < it.endT;
      });
      if (arr) {
        obj2 = arr;
      }
      var newT = (t - obj2.startT) / (obj2.endT - obj2.startT);
      var newRate = timing(newT);
      return __spreadProps(__spreadValues({}, obj2.interpolate(newRate, newT, timing)), {
        totalLength: obj2.totalLength
      });
    };
  }
  return (rate, t, timing) => {
    var arr = (layer2["transform-origin"] || "50% 50%").split(" ").map((it) => Length.parse(it));
    var tx = arr[0].toPx(layer2.width);
    var ty = arr[1].toPx(layer2.height);
    var obj2 = innerInterpolate(rate, t, timing);
    var results = {
      x: obj2.x + screenX - tx.value,
      y: obj2.y + screenY - ty.value
    };
    layer2.setScreenX(results.x);
    layer2.setScreenY(results.y);
    if (startObject.rotateStatus === "element")
      ;
    else {
      var current = obj2;
      var distValue = 0;
      if (t < 1) {
        distValue = 1 / obj2.totalLength;
      }
      var next = innerInterpolate(rate + distValue, t + distValue, timing);
      var angle2 = calculateAngle(next.x - current.x, next.y - current.y);
      var newAngle = Length.deg(innerInterpolateAngle(startObject.rotateStatus, angle2));
      layer2.reset({
        transform: Transform.rotate(layer2.transform, newAngle)
      });
    }
    return results;
  };
}
function makeInterpolateText(layer2, property, startText, endText, unit = void 0) {
  var max = endText.length - 1;
  var min = 0;
  return (rate, t) => {
    var result = 0;
    if (t === 0) {
      result = "";
    } else if (t === 1) {
      result = endText;
    } else {
      result = endText.substring(min, Math.floor((max - min) * t));
    }
    return result;
  };
}
function makeInterpolatePlayTime(layer2, property, startValue, endValue, artboard2, layerElement) {
  const mediaElement = layerElement.$("video").el;
  let [sTime, eTime, durationTime] = startValue.split(":");
  const duration = +(durationTime || 1);
  const startTime = +(sTime || 0) * duration;
  return (rate, t) => {
    if (t === 0) {
      mediaElement.currentTime = startTime;
      if (mediaElement.paused) {
        mediaElement.play();
      }
    } else if (t === 1) {
      layer2.reset({
        currentTime: mediaElement.currentTime
      });
      mediaElement.pause();
    } else {
      if (mediaElement.paused) {
        mediaElement.play();
      }
    }
  };
}
const DEFAULT_FUCTION = () => (rate, t) => {
};
function makeInterpolateCustom(property) {
  switch (property) {
    case "border-radius":
      return makeInterpolateBorderRadius;
    case "border":
      return makeInterpolateBorder;
    case "box-shadow":
      return makeInterpolateBoxShadow;
    case "text-shadow":
      return makeInterpolateTextShadow;
    case "background-image":
    case "BackgroundImageEditor":
      return makeInterpolateBackgroundImage;
    case "filter":
    case "backdrop-filter":
      return makeInterpolateFilter;
    case "clip-path":
      return makeInterpolateClipPath;
    case "transform":
      return makeInterpolateTransform;
    case "transform-origin":
      return makeInterpolateTransformOrigin;
    case "perspective-origin":
      return makeInterpolatePerspectiveOrigin;
    case "stroke-dasharray":
      return makeInterpolateStrokeDashArrray;
    case "d":
      return makeInterpolatePath;
    case "points":
      return makeInterpolatePolygon;
    case "offset-path":
      return makeInterpolateOffsetPath;
    case "text":
      return makeInterpolateText;
    case "playTime":
      return makeInterpolatePlayTime;
  }
}
function makeInterpolate(layer2, property, startValue, endValue, editorString, artboard2, layerElement) {
  var checkField = editorString || property;
  switch (checkField) {
    case "width":
    case "x":
      return makeInterpolateLength(layer2, property, startValue, endValue, "width");
    case "height":
    case "y":
      return makeInterpolateLength(layer2, property, startValue, endValue, "height");
    case "perspective":
    case "font-size":
    case "font-weight":
    case "text-stroke-width":
    case "RangeEditor":
    case "textLength":
    case "startOffset":
      return makeInterpolateLength(layer2, property, startValue, endValue, property);
    case "fill-opacity":
    case "opacity":
    case "stroke-dashoffset":
    case "currentTime":
    case "NumberRangeEditor":
      return makeInterpolateNumber$1(layer2, property, +startValue, +endValue);
    case "background-color":
    case "color":
    case "text-fill-color":
    case "text-stroke-color":
    case "fill":
    case "stroke":
    case "ColorViewEditor":
      return makeInterpolateColor(layer2, property, startValue, endValue);
    case "mix-blend-mode":
    case "fill-rule":
    case "stroke-linecap":
    case "stroke-linejoin":
    case "SelectEditor":
    case "lengthAdjust":
      return makeInterpolateString(layer2, property, startValue, endValue);
    case "rotate":
      return makeInterpolateRotate(layer2, property, startValue, endValue);
  }
  var func2 = makeInterpolateCustom(checkField);
  if (func2) {
    return func2(layer2, property, startValue, endValue, artboard2, layerElement);
  }
  return DEFAULT_FUCTION;
}
function createInterpolateFunction(layer2, property, startValue, endValue, editorString, artboard2, layerElement) {
  return makeInterpolate(layer2, property, startValue, endValue, editorString, artboard2, layerElement);
}
function createTimingFunction(timing = "linear") {
  var [funcName, params] = timing.split("(").map((it) => it.trim());
  params = (params || "").split(")")[0].trim();
  var func2 = timingFunctions[funcName];
  if (func2) {
    var args2 = timing.split("(")[1].split(")")[0].split(",").map((it) => it.trim());
    return func2(...args2);
  } else {
    return createCurveFunction(timing);
  }
}
function createCurveFunction(timing) {
  var func2 = createBezierForPattern(timing);
  return (rate) => {
    return func2(rate).y;
  };
}
class Offset extends PropertyItem {
  static parse(obj2) {
    return new Offset(obj2);
  }
  getDefaultObject() {
    return super.getDefaultObject({
      itemType: "offset",
      offset: Length.percent(0),
      color: "rgba(255, 255, 255, 1)",
      properties: []
    });
  }
  toCloneObject() {
    return __spreadValues(__spreadValues({}, super.toCloneObject()), this.attrs("offset", "color", "properties"));
  }
  convert(json) {
    json = super.convert(json);
    json.offset = Length.parse(json.offset);
    return json;
  }
  toCSSText() {
    return `${this.json.offset} ${CSS_TO_STRING$1(this.toCSS())}`;
  }
  createProperty(data = {}) {
    return this.addProperty(__spreadValues({
      checked: true,
      value: 0
    }, data));
  }
  addProperty(property) {
    this.json.properties.push(property);
  }
  removeProperty(removeIndex) {
    this.json.properties.splice(removeIndex, 1);
  }
  sortItem(arr, startIndex, targetIndex) {
    arr.splice(targetIndex + (startIndex < targetIndex ? -1 : 0), 0, ...arr.splice(startIndex, 1));
  }
  sortProperty(startIndex, targetIndex) {
    this.sortItem(this.json.properties, startIndex, targetIndex);
  }
  updateProperty(index2, data = {}) {
    Object.assign(this.json.properties[+index2], __spreadValues({}, data));
  }
  updatePropertyByKey(key, data = {}) {
    var arr = this.json.properties;
    var index2 = -1;
    for (var i = 0, len2 = arr.length; i < len2; i++) {
      if (this.json.properties[i].key === key) {
        index2 = i;
        break;
      }
    }
    Object.assign(this.json.properties[+index2], __spreadValues({}, data));
  }
  toCSS() {
    var obj2 = {};
    this.json.properties.forEach((it) => {
      obj2 = __spreadValues(__spreadValues({}, obj2), it.toCSS());
    });
    return obj2;
  }
  toString() {
    return this.toCSSText();
  }
}
class Keyframe extends PropertyItem {
  static parse(obj2) {
    return new Keyframe(obj2);
  }
  static parseStyle(style) {
    var keyframes = [];
    var keyframeKeys = {};
    if (style["keyframe"]) {
      var results = convertMatches(style["keyframe"]);
      results.str.split("|").map((it) => it.trim()).forEach((frameInfo, index2) => {
        var [name2, offset, property, ...values] = frameInfo.split(" ");
        var propertyValue = values.join(" ");
        if (!keyframeKeys[name2]) {
          keyframeKeys[name2] = new Keyframe({
            name: name2
          });
          keyframes[index2] = name2;
        }
        var filteredOffset = keyframeKeys[name2].offsets.filter((it) => {
          return it.offset.equals(Length.parse(offset));
        });
        var offsetObj = null;
        if (filteredOffset.length) {
          offsetObj = filteredOffset[0];
        } else {
          offsetObj = new Offset({
            offset: Length.parse(offset)
          });
          keyframeKeys[name2].offsets.push(offsetObj);
        }
        offsetObj.addProperty({
          key: property,
          value: reverseMatches(propertyValue, results.matches)
        });
      });
    }
    return keyframes.map((name2) => {
      keyframeKeys[name2].offsets.forEach((offset) => {
        var vars = [];
        var properties = [];
        offset.properties.forEach((p) => {
          if (p.key.includes("--")) {
            vars.push(p);
          } else {
            properties.push(p);
          }
        });
        let varValue = vars.map((it) => `${it.key}:${it.value}`).join(";");
        if (vars.length) {
          properties.push({ key: "var", value: varValue });
        }
        offset.properties = properties;
      });
      return keyframeKeys[name2];
    });
  }
  getDefaultObject() {
    return super.getDefaultObject({
      itemType: "keyframe",
      name: "sample",
      selectedType: "list",
      offsets: []
    });
  }
  toCloneObject() {
    var { name: name2, selectedType, offsets } = this.json;
    return __spreadProps(__spreadValues(__spreadValues({}, super.toCloneObject()), this.attrs("name", "selectedType")), {
      offsets: offsets.map((offset) => offset.clone())
    });
  }
  isMultiStyle(key) {
    switch (key) {
      case "background-image":
      case "var":
        return true;
    }
    return false;
  }
  getMultiStyleString(p) {
    switch (p.key) {
      case "background-image":
        return p.value.toString() + ";";
      case "var":
        var value = (p.value + "").split(";").map((str) => {
          return `--` + str;
        }).join(";");
        return value + ";";
    }
    return p.value.toString() + ";";
  }
  toOffsetString(it) {
    var tabString = "      ";
    return `${it.offset.toString()} {
${tabString}${it.properties.map((p) => {
      if (this.isMultiStyle(p.key)) {
        return this.getMultiStyleString(p);
      } else {
        var value = (p.value || "").toString();
        if (value) {
          var key = p.key;
          if (key === "x")
            key = "left";
          else if (key === "y")
            key = "top";
          return `${key}: ${value};`;
        } else {
          return "";
        }
      }
    }).join("").replace(/\;/g, ";\n" + tabString).trim()}
  }`;
  }
  toOffsetText() {
    var offsets = this.json.offsets.map((it) => {
      return it;
    });
    offsets.sort((a, b) => {
      return a.offset.value > b.offset.value ? 1 : -1;
    });
    return offsets.map((it) => {
      if (it.properties.length === 0)
        return "";
      return this.toOffsetString(it);
    }).join("\n");
  }
  toCSSText() {
    var offsets = this.json.offsets.map((it) => {
      return it;
    });
    offsets.sort((a, b) => {
      return a.offset.value > b.offset.value ? 1 : -1;
    });
    return `
@keyframes ${this.json.name} {

  ${this.toOffsetText()}

}
`;
  }
  createOffset(data = {}) {
    return this.addOffset(new Offset(__spreadValues({
      checked: true
    }, data)));
  }
  addOffset(offset) {
    this.json.offsets.push(offset);
  }
  removeOffset(removeIndex) {
    this.json.offsets.splice(removeIndex, 1);
  }
  sortItem(arr, startIndex, targetIndex) {
    arr.splice(targetIndex + (startIndex < targetIndex ? -1 : 0), 0, ...arr.splice(startIndex, 1));
  }
  sortOffset(startIndex, targetIndex) {
    this.sortItem(this.json.offsets, startIndex, targetIndex);
  }
  updateOffset(index2, data = {}) {
    this.json.offsets[+index2].reset(data);
  }
  toCSS() {
    return {};
  }
  toString() {
    return this.toCSSText();
  }
}
class ComponentManager {
  constructor(editor) {
    this.editor = editor;
    this.components = {};
    this.inspectors = {};
  }
  registerComponent(name2, componentProperty) {
    if (this.components[name2])
      throw new Error("It has duplicated item name. " + name2);
    this.components[name2] = componentProperty;
  }
  registerInspector(name2, inspectorCallback) {
    if (this.inspectors[name2])
      throw new Error("It has duplicated item name. " + name2);
    this.inspectors[name2] = inspectorCallback;
  }
  getComponentClass(name2) {
    return this.components[name2] || this.components["rect"];
  }
  getInspector(name2) {
    return this.inspectors[name2];
  }
  createComponent(itemType, obj2 = {}) {
    var ComponentClass = this.getComponentClass(itemType);
    if (!ComponentClass) {
      throw new Error(`${itemType} type is not valid.`);
    }
    return new ComponentClass(obj2);
  }
  createInspector(item2, name2 = "") {
    const inspector = this.getInspector(name2 || item2.itemType);
    if (isFunction(inspector)) {
      return inspector(item2) || [];
    }
    if (isFunction(item2.getProps)) {
      return item2.getProps() || [];
    }
    return [];
  }
}
const identity$1 = () => true;
class ModelManager {
  constructor(editor) {
    this.editor = editor;
    this.version = "0.0.0";
    this.name = "";
    this.description = "";
    this.items = new Map();
    this.projects = [];
  }
  load(doc2 = void 0, context = { origin: "*" }) {
    var _a;
    const newDoc = doc2 || this.editor.loadItem("model");
    this.items.clear();
    this.version = newDoc == null ? void 0 : newDoc.version;
    this.name = newDoc == null ? void 0 : newDoc.name;
    this.description = newDoc == null ? void 0 : newDoc.description;
    (_a = newDoc == null ? void 0 : newDoc.projects) == null ? void 0 : _a.forEach((project2) => {
      this.createModel(project2);
    });
    if (this.projects.length === 0) {
      this.createProject();
    }
  }
  createProject() {
    this.createModel({
      itemType: "project",
      name: "New Project"
    });
  }
  getProjectByIndex(index2 = 0) {
    return this.get(this.projects[index2]);
  }
  get(id) {
    return this.items.get(id);
  }
  set(id, item2) {
    this.items.set(id, item2);
    this.setChanged("set", id, item2);
  }
  remove(id) {
    const obj2 = this.items.get(id);
    const children2 = obj2.parent.children;
    const index2 = children2.indexOf(id);
    obj2.reset({
      removed: true,
      removedIndex: index2,
      removedLeftSibling: index2 > 0 ? children2[index2 - 1] : null,
      removedRightSibling: index2 < children2.length - 1 ? children2[index2 + 1] : null
    });
    this.setChanged("remove", id);
  }
  recover(id) {
    const obj2 = this.items.get(id);
    const parent = this.getParent(id);
    if (!obj2.removedLeftSibling && obj2.removedRightSibling) {
      parent.children.splice(parent.children.findIndex((it) => obj2.removedRightSibling) - 1, 0, id);
    } else if (obj2.removedLeftSibling && !obj2.removedRightSibling) {
      parent.children.splice(parent.children.findIndex((it) => obj2.removedLeftSibling) + 1, 0, id);
    } else {
      parent.children.splice(obj2.removedIndex, 0, id);
    }
    delete obj2.removed;
    delete obj2.removedLeftSibling;
    delete obj2.removedRightSibling;
    delete obj2.removedIndex;
    this.setChanged("recover", id);
  }
  clear() {
    this.items.clear();
  }
  toJSON() {
    return {
      version: this.version,
      name: this.name,
      description: this.description,
      projects: this.projects.map((id) => {
        return this.get(id).toJSON();
      })
    };
  }
  setChanged(type, id, obj2) {
    this.editor.emit("changed", type, id, obj2);
  }
  removeChild(rootId, childId) {
    const obj2 = this.get(rootId);
    obj2.children = obj2.children.filter((it) => it !== childId);
    this.setChanged("removeChild", rootId, { childId });
  }
  hasParent(rootId, parentId) {
    const obj2 = this.get(rootId);
    const isParent = obj2.parentId === parentId;
    if (!isParent && obj2.parent.is("project") === false)
      return this.hasParent(obj2.parentId, parentId);
    return isParent;
  }
  get components() {
    return this.editor.components;
  }
  searchItem(id) {
    return this.get(id);
  }
  searchLayers(rootId, childId) {
    const obj2 = this.get(rootId);
    return this.get(obj2.children.find((it) => it === childId));
  }
  searchItemsById(ids) {
    return ids.map((id) => this.get(id));
  }
  hasPathOf(targetItems, searchItem) {
    const path = this.getPath(searchItem.id, searchItem);
    return targetItems.filter((it) => it.id !== searchItem.id).some((target) => {
      return path.find((it) => it.id === target.id);
    });
  }
  findGroupItem(rootId) {
    const obj2 = this.get(rootId);
    if (obj2.hasChildren()) {
      return obj2;
    }
    if (obj2.parent && (obj2.parent.is("project") || obj2.parent.is("artboard") || obj2.isBooleanItem)) {
      return obj2;
    }
    return obj2.parent && this.findGroupItem(obj2.parentId);
  }
  convertGroupItems(items) {
    const objectList = {};
    items.forEach((item2) => {
      const groupItem = this.findGroupItem(item2.id) || item2;
      objectList[groupItem.id] = groupItem;
    });
    return Object.values(objectList).filter((it) => it.isNot("project"));
  }
  searchLiveItemsById(ids) {
    return ids.map((id) => this.get(id)).filter((it) => !it.removed);
  }
  markRemove(ids = []) {
    ids.forEach((id) => {
      this.remove(id);
    });
    this.setChanged("markRemove", ids, { isLayer: true });
  }
  markRemoveProject(id) {
    const index2 = this.projects.findIndex((it) => it === id);
    this.projects.splice(index2, 1);
    this.get(id).removed = true;
    this.setChanged("markRemoveProject", [id], { isProject: true });
    return index2;
  }
  unmarkRemove(ids = []) {
    ids.forEach((id) => {
      this.recover(id);
    });
    this.setChanged("unmarkRemove", ids, { isLayer: true });
  }
  unmarkRemoveProject(id, index2) {
    this.projects.splice(index2, 0, id);
    this.get(id).removed = false;
    this.setChanged("unmarkRemoveProject", [id], { removed: true, isProject: true });
  }
  createModel(itemObject, isRegister = true, context = { origin: "*" }) {
    const layers2 = itemObject.layers;
    delete itemObject.layers;
    let item2;
    if (this.get(itemObject.id)) {
      item2 = this.get(itemObject.id);
      item2.reset(itemObject);
    } else {
      item2 = this.components.createComponent(itemObject.itemType, __spreadValues({}, itemObject));
      item2.setModelManager(this);
    }
    if (isRegister) {
      this.set(item2.id, item2);
      if (item2.is("project")) {
        this.projects = [...new Set([...this.projects, item2.id])];
      }
    }
    const children2 = (layers2 || []).map((it) => {
      return this.createModel(__spreadProps(__spreadValues({}, it), { parentId: item2.id }), true, context);
    });
    item2.reset({
      children: children2.map((it) => {
        return it.id;
      })
    }, context);
    return item2;
  }
  getAllLayers(rootId, filterCallback = identity$1) {
    var results = [];
    const obj2 = this.get(rootId);
    let len2 = obj2.children.length;
    for (let start2 = len2; start2--; ) {
      let id = obj2.children[start2];
      results.push(...this.getAllLayers(id, filterCallback));
    }
    if (isFunction(filterCallback) && filterCallback(obj2)) {
      results.push(obj2);
    }
    return results;
  }
  getLayers(rootId, defaultRef = null) {
    var _a;
    const obj2 = this.get(rootId) || defaultRef;
    return (_a = obj2 == null ? void 0 : obj2.children) == null ? void 0 : _a.map((childId) => this.get(childId));
  }
  eachLayers(rootId, callback) {
    const obj2 = this.get(rootId);
    let len2 = obj2.children.length;
    for (let start2 = len2; start2--; ) {
      let id = obj2.children[start2];
      callback(this.get(id));
    }
  }
  mapLayers(rootId, callback) {
    const obj2 = this.get(rootId);
    return obj2.children.map((childId) => {
      return callback(this.get(childId));
    });
  }
  getParent(rootId) {
    var _a;
    return this.get((_a = this.get(rootId)) == null ? void 0 : _a.parentId);
  }
  getDepth(rootId) {
    const parent = this.getParent(rootId);
    if (!parent)
      return 1;
    return this.getDepth(parent.id) + 1;
  }
  getRoot(rootId) {
    const obj2 = this.get(rootId);
    const parent = this.getParent(rootId);
    if (!parent)
      return obj2;
    let localParent = parent;
    do {
      const nextParent = this.getParent(localParent.id);
      if (!nextParent) {
        return localParent;
      }
      localParent = nextParent;
    } while (localParent);
  }
  getPath(rootId, defaultRef = null) {
    const obj2 = this.get(rootId) || defaultRef;
    const parent = this.getParent(rootId);
    if (!parent)
      return [obj2];
    const list2 = this.getPath(parent.id);
    list2.push(obj2);
    return list2;
  }
  getModelTypeInPath(rootId, itemType) {
    return this.getPath(rootId).find((it) => it && it.is(itemType));
  }
  getItemInPath(rootId, targetId) {
    return this.getPath(rootId).find((it) => it && it.id === targetId);
  }
  getProject(rootId) {
    return this.getModelTypeInPath(rootId, "project");
  }
  getArtBoard(rootId) {
    return this.getModelTypeInPath(rootId, "artboard");
  }
  is(rootId, checkItemType) {
    const obj2 = this.get(rootId);
    return checkItemType === obj2.itemType;
  }
  isNot(rootId, checkItemType) {
    return this.is(rootId, checkItemType) === false;
  }
  attrs(rootId, ...args2) {
    const obj2 = this.get(rootId);
    const result = {};
    args2.forEach((field) => {
      result[field] = clone$1(obj2[field]);
    });
    return result;
  }
  hasChildren(rootId) {
    var _a;
    return ((_a = this.get(rootId)) == null ? void 0 : _a.children.length) > 0;
  }
  clone(rootId, isDeep = true) {
    const obj2 = this.get(rootId);
    const json = obj2.toCloneObject(isDeep);
    const item2 = this.createModel(json);
    item2.setParentId(obj2.parentId);
    return item2;
  }
  reset(rootId, obj2) {
    var _a;
    return (_a = this.get(rootId)) == null ? void 0 : _a.reset(obj2);
  }
  appendChild(rootId, childId) {
    this.get(rootId);
    this.get(childId);
    this.json.children.push(layer.id);
    layer.offsetInParent = this.json.children[last - 1].offset + 0.1;
  }
  replaceByType(rootId, itemType) {
    const item2 = this.get(rootId);
    if (item2) {
      const json = item2.toCloneObject(false);
      delete json.itemType;
      const newInstance = this.components.createComponent(itemType, json);
      newInstance.setModelManager(this);
      this.set(rootId, newInstance);
    }
  }
}
class BaseModel {
  constructor(json = {}, modelManager) {
    this.modelManager = modelManager;
    this.ref = new Proxy(this, {
      get: (target, key) => {
        if (this.getCache(key)) {
          return this.getCache(key);
        }
        var originMethod = target[key];
        if (isFunction(originMethod)) {
          if (!this.getCache(key)) {
            this.addCache(key, (...args2) => {
              return originMethod.apply(target, args2);
            });
          }
          return this.getCache(key);
        } else {
          return isNotUndefined(originMethod) ? originMethod : target.json[key];
        }
      },
      set: (target, key, value) => {
        const isDiff = target.json[key] != value;
        if (isDiff) {
          this.reset({ [key]: value });
        }
        return true;
      },
      deleteProperty: (target, key) => {
        this.reset({ [key]: void 0 });
      }
    });
    this.json = this.convert(Object.assign(this.getDefaultObject(), json));
    this.lastChangedField = {};
    this.lastChangedFieldKeys = [];
    this.cachedValue = {};
    this.timestamp = 0;
    return this.ref;
  }
  setModelManager(modelManager) {
    this.modelManager = modelManager;
  }
  getDefaultTitle() {
    return "Item";
  }
  getIcon() {
    return "";
  }
  isChanged(timestamp) {
    return this.timestamp != Number(timestamp);
  }
  changed() {
    this.timestamp += Date.now();
  }
  get title() {
    return this.json.name || this.getDefaultTitle();
  }
  renameWithCount() {
    let arr = this.json.name.split(" ");
    if (arr.length < 2) {
      return;
    }
    let last2 = arr.pop();
    let lastNumber = +last2;
    if (isNumber(lastNumber) && isNaN(lastNumber) === false) {
      lastNumber++;
    } else {
      lastNumber = last2;
    }
    const nextName = [...arr, lastNumber].join(" ");
    this.reset({
      name: nextName
    });
  }
  get allLayers() {
    return this.modelManager.getAllLayers(this.id);
  }
  filteredAllLayers(filterCallback) {
    return this.modelManager.getAllLayers(this.id, filterCallback);
  }
  get id() {
    return this.json.id;
  }
  get layers() {
    return this.modelManager.getLayers(this.id, this.ref);
  }
  get parentId() {
    return this.json.parentId;
  }
  get parent() {
    if (!this.parentId)
      return void 0;
    return this.modelManager.get(this.parentId);
  }
  setParentId(parentId) {
    this.reset({ parentId });
    this.modelManager.setChanged("setParentId", this.id, { parentId });
  }
  get depth() {
    return this.modelManager.getDepth(this.id);
  }
  get top() {
    return this.modelManager.getRoot(this.id);
  }
  get project() {
    return this.modelManager.getProject(this.id);
  }
  get artboard() {
    return this.modelManager.getArtBoard(this.id);
  }
  get path() {
    return this.modelManager.getPath(this.id, this.ref);
  }
  get pathIds() {
    return this.path.map((it) => it.id);
  }
  get childrenLength() {
    return this.json.children.length;
  }
  getInnerId(postfix = "") {
    return this.json.id + postfix;
  }
  is(checkItemType) {
    return this.json.itemType === checkItemType;
  }
  isNot(checkItemType) {
    return this.is(checkItemType) === false;
  }
  isSVG() {
    return false;
  }
  addCache(key, value) {
    this.cachedValue[key] = value;
  }
  getCache(key) {
    return this.cachedValue[key];
  }
  computed(key, newValueCallback, isForce = false) {
    const cachedKey = `__cachedKey_${key}`;
    const parsedKey = `${cachedKey}__parseValue`;
    const value = this.json[key];
    if (isForce)
      ;
    else {
      if (this.getCache(key) === value && this.getCache(parsedKey)) {
        return this.getCache(parsedKey);
      }
    }
    this.addCache(key, value);
    this.addCache(parsedKey, newValueCallback(value, this.ref));
    return this.getCache(parsedKey);
  }
  computedValue(key) {
    const cachedKey = `__cachedKey_${key}`;
    const parsedKey = `${cachedKey}__parseValue`;
    return this.getCache(parsedKey);
  }
  editable(editablePropertyName) {
    return true;
  }
  generateListNumber() {
    this.layers.forEach((it, index2) => {
      it.no = index2;
      it.generateListNumber();
    });
  }
  convert(json = {}) {
    return json;
  }
  setCache() {
  }
  toCloneObject(isDeep = true) {
    var json = this.attrs("itemType", "name", "elementType", "type", "selected", "parentId", "children");
    if (isDeep) {
      json.layers = this.json.children.map((childId) => {
        return this.modelManager.clone(childId, isDeep);
      });
    }
    return json;
  }
  clone(isDeep = true) {
    return this.modelManager.clone(this.id, isDeep);
  }
  isChangedValue(obj2) {
    return true;
  }
  reset(obj2, context = { origin: "*" }) {
    const isChanged = this.isChangedValue(obj2);
    if (isChanged) {
      this.json = this.convert(Object.assign(this.json, obj2));
      this.lastChangedField = obj2;
      this.lastChangedFieldKeys = Object.keys(obj2);
      if (context.origin === "*") {
        this.modelManager.setChanged("reset", this.id, obj2);
      }
      this.changed();
    }
    return true;
  }
  hasChangedField(...args2) {
    return args2.some((it) => this.lastChangedField[it] !== void 0);
  }
  getDefaultObject(obj2 = {}) {
    var id = uuid$1();
    return __spreadValues({
      id,
      children: [],
      offsetInParent: 1,
      parentId: ""
    }, obj2);
  }
  attrs(...args2) {
    const result = {};
    args2.forEach((field) => {
      if (isNotUndefined(this.ref[field])) {
        result[field] = clone$1(this.ref[field]);
      }
    });
    return result;
  }
  hasChildren() {
    return this.json.children.length > 0;
  }
  appendChild(layer2) {
    if (layer2.parentId === this.id) {
      const hasId = this.json.children.find((it) => it === layer2.id);
      if (Boolean(hasId) === false) {
        this.json.children.push(layer2.id);
        this.modelManager.setChanged("appendChild", this.id, { child: layer2.id, oldParentId: layer2.parentId });
      }
      return layer2;
    }
    this.resetMatrix(layer2);
    if (layer2.parent) {
      layer2.remove();
    }
    layer2.setParentId(this.id);
    this.json.children.push(layer2.id);
    return layer2;
  }
  resetMatrix(item2) {
  }
  refreshMatrixCache() {
  }
  insertChild(layer2, index2 = 0) {
    this.resetMatrix(layer2);
    if (layer2.parent) {
      layer2.remove();
    }
    layer2.setParentId(this.id);
    this.json.children.splice(index2, 0, layer2.id);
    this.modelManager.setChanged("insertChild", this.id, { childId: layer2.id, index: 0 });
    return layer2;
  }
  appendAfter(layer2) {
    const index2 = this.parent.findIndex(this);
    this.parent.insertChild(layer2, index2);
    return layer2;
  }
  appendBefore(layer2) {
    const index2 = this.parent.findIndex(this);
    this.parent.insertChild(layer2, index2 - 1);
    return layer2;
  }
  toggle(field, toggleValue) {
    if (isUndefined(toggleValue)) {
      this.reset({
        [field]: !this.json[field]
      });
    } else {
      this.reset({
        [field]: !!toggleValue
      });
    }
  }
  isTreeItemHide() {
    let currentParent = this.parent;
    let collapsedList = [];
    do {
      if (currentParent.is("project"))
        break;
      collapsedList.push(Boolean(currentParent.collapsed));
      currentParent = currentParent.parent;
    } while (currentParent);
    return Boolean(collapsedList.filter(Boolean).length);
  }
  expectJSON(key) {
    if (isUndefined(this.json[key]))
      return false;
    return true;
  }
  toJSON() {
    const json = this.json;
    let newJSON = {};
    Object.keys(json).filter((key) => this.expectJSON(key)).forEach((key) => {
      newJSON[key] = json[key];
    });
    if (this.hasChildren()) {
      newJSON.layers = this.json.children.map((childId) => {
        var _a;
        return (_a = this.modelManager.get(childId)) == null ? void 0 : _a.toJSON();
      });
    }
    return newJSON;
  }
  resize() {
  }
  copy(dist2 = 0) {
    return this.parent.copyItem(this.id, dist2);
  }
  findIndex(item2) {
    return this.json.children.indexOf(item2.id);
  }
  find(id) {
    return this.modelManager.get(id);
  }
  copyItem(childItemId, dist2 = 10) {
    const childItem = this.modelManager.get(childItemId);
    var child = childItem.clone();
    child.renameWithCount();
    child.move([dist2, dist2, 0]);
    var childIndex = this.findIndex(childItem);
    if (childIndex > -1) {
      this.json.children.push(child.id);
    }
    return child;
  }
  remove() {
    this.parent.removeChild(this.id);
  }
  removeChild(childItemId) {
    return this.modelManager.removeChild(this.id, childItemId);
  }
  hasParent(parentId) {
    return this.modelManager.hasParent(this.id, parentId);
  }
  to(itemType) {
  }
}
class AssetModel extends BaseModel {
  getDefaultObject(obj2 = {}) {
    return super.getDefaultObject(__spreadValues({
      comments: [],
      colors: [],
      gradients: [],
      svgfilters: [],
      svgimages: [],
      keyframes: [],
      images: [],
      imageKeys: [],
      videos: [],
      videoKeys: [],
      audios: []
    }, obj2));
  }
  addKeyframe(keyframe2) {
    this.json.keyframes.push(keyframe2);
    return keyframe2;
  }
  createKeyframe(data = {}) {
    return this.addKeyframe(new Keyframe(__spreadValues({
      checked: true
    }, data)));
  }
  removeKeyframe(removeIndex) {
    this.removePropertyList(this.json.keyframes, removeIndex);
  }
  sortItem(arr, startIndex, targetIndex) {
    arr.splice(targetIndex + (startIndex < targetIndex ? -1 : 0), 0, ...arr.splice(startIndex, 1));
  }
  sortKeyframe(startIndex, targetIndex) {
    this.sortItem(this.json.keyframes, startIndex, targetIndex);
  }
  updateKeyframe(index2, data = {}) {
    this.json.keyframes[+index2].reset(data);
  }
  toKeyframeString(isAnimate = false) {
    return this.json.keyframes.map((keyframe2) => keyframe2.toString(isAnimate)).join("\n\n");
  }
  copyPropertyList(arr, index2) {
    var copyObject = __spreadValues({}, arr[index2]);
    arr.splice(index2, 0, copyObject);
  }
  toCloneObject() {
    this.json;
    return __spreadValues(__spreadValues({}, super.toCloneObject()), this.attrs("colors", "gradients", "svgfilters", "svgimages", "images", "keyframes"));
  }
  removePropertyList(arr, removeIndex) {
    arr.splice(removeIndex, 1);
  }
  removeColor(removeIndex) {
    this.removePropertyList(this.json.colors, removeIndex);
  }
  copyColor(index2) {
    this.copyPropertyList(this.json.colors, index2);
  }
  sortColor(startIndex, targetIndex) {
    this.sortItem(this.json.colors, startIndex, targetIndex);
  }
  setColorValue(index2, value = {}) {
    this.json.colors[index2] = __spreadValues(__spreadValues({}, this.json.colors[index2]), value);
  }
  getColorIndex(index2) {
    return this.json.colors[index2];
  }
  getColor(name2) {
    return this.json.colors.filter((item2) => item2.name === name2)[0];
  }
  addColor(obj2) {
    this.json.colors.push(obj2);
    return obj2;
  }
  createColor(data = {}) {
    return this.addColor(data);
  }
  removeImage(removeIndex) {
    this.removePropertyList(this.json.images, removeIndex);
    this.refreshImageKeys();
  }
  copyImage(index2) {
    this.copyPropertyList(this.json.images, index2);
    this.refreshImageKeys();
  }
  sortImage(startIndex, targetIndex) {
    this.sortItem(this.json.images, startIndex, targetIndex);
  }
  setImageValue(index2, value = {}) {
    this.json.images[index2] = __spreadValues(__spreadValues({}, this.json.images[index2]), value);
    this.refreshImageKeys();
  }
  getImageValueById(id) {
    const image2 = this.json.imageKeys[id];
    if (!image2)
      return void 0;
    return image2.local;
  }
  getImageDataURIById(id) {
    const image2 = this.json.imageKeys[id];
    if (!image2)
      return void 0;
    return image2.original;
  }
  refreshImageKeys() {
    let imageKeys = {};
    this.json.images.forEach((it) => {
      imageKeys[it.id] = it;
    });
    this.reset({
      imageKeys
    });
  }
  addImage(obj2) {
    this.json.images.push(obj2);
    this.refreshImageKeys();
    return obj2;
  }
  createImage(data = {}) {
    return this.addImage(data);
  }
  removeVideo(removeIndex) {
    this.removePropertyList(this.json.videos, removeIndex);
    this.refreshVideoKeys();
  }
  copyVideo(index2) {
    this.copyPropertyList(this.json.videos, index2);
    this.refreshVideoKeys();
  }
  sortVideo(startIndex, targetIndex) {
    this.sortItem(this.json.videos, startIndex, targetIndex);
  }
  setVideoValue(index2, value = {}) {
    this.json.videos[index2] = __spreadValues(__spreadValues({}, this.json.videos[index2]), value);
  }
  getVideoValueById(id) {
    const video2 = this.json.videoKeys[id];
    if (!video2)
      return void 0;
    return video2.local;
  }
  refreshVideoKeys() {
    let videoKeys = {};
    this.json.videos.forEach((it) => {
      videoKeys[it.id] = it;
    });
    this.reset({
      videoKeys
    });
  }
  addVideo(obj2) {
    this.json.videos.push(obj2);
    this.refreshVideoKeys();
    return obj2;
  }
  createVideo(data = {}) {
    return this.addVideo(data);
  }
  removeGradient(removeIndex) {
    this.removePropertyList(this.json.gradients, removeIndex);
  }
  copyGradient(index2) {
    this.copyPropertyList(this.json.gradients, index2);
  }
  sortGradient(startIndex, targetIndex) {
    this.sortItem(this.json.gradients, startIndex, targetIndex);
  }
  setGradientValue(index2, value) {
    this.json.gradients[index2] = __spreadValues(__spreadValues({}, this.json.gradients[index2]), value);
  }
  getGradientIndex(index2) {
    return this.json.gradients[index2];
  }
  getGradient(name2) {
    return this.json.gradients.filter((item2) => item2.name === name2)[0];
  }
  addGradient(obj2 = {}) {
    this.json.gradients.push(obj2);
    return obj2;
  }
  createGradient(data = {}) {
    return this.addGradient(data);
  }
  getSVGFilterIndex(id) {
    var _a;
    var filter2 = this.json.svgfilters.map((it, index2) => {
      return { id: it.id, index: index2 };
    }).filter((it) => {
      return it.id === id;
    });
    return filter2.length ? (_a = filter2 == null ? void 0 : filter2[0]) == null ? void 0 : _a.index : -1;
  }
  removeSVGFilter(removeIndex) {
    this.removePropertyList(this.json.svgfilters, removeIndex);
  }
  copySVGFilter(index2) {
    this.copyPropertyList(this.json.svgfilters, index2);
  }
  sortSVGFilter(startIndex, targetIndex) {
    this.sortItem(this.json.svgfilters, startIndex, targetIndex);
  }
  setSVGFilterValue(index2, value) {
    this.json.svgfilters[index2] = __spreadValues(__spreadValues({}, this.json.svgfilters[index2]), value);
  }
  addSVGFilter(obj2 = {}) {
    this.json.svgfilters.push(obj2);
    var index2 = this.json.svgfilters.length - 1;
    return index2;
  }
  createSVGFilter(data = {}) {
    return this.addSVGFilter(data);
  }
  getSVGImageIndex(id) {
    var filter2 = this.json.svgimages.map((it, index2) => {
      return { id: it.id, index: index2 };
    }).filter((it) => {
      return it.id === id;
    })[0];
    return filter2 ? filter2.index : -1;
  }
  removeSVGImage(removeIndex) {
    this.removePropertyList(this.json.svgimages, removeIndex);
  }
  copySVGImage(index2) {
    this.copyPropertyList(this.json.svgimages, index2);
  }
  sortSVGImage(startIndex, targetIndex) {
    this.sortItem(this.json.svgimages, startIndex, targetIndex);
  }
  setSVGImageValue(index2, value) {
    this.json.svgimages[index2] = __spreadValues(__spreadValues({}, this.json.svgimages[index2]), value);
  }
  addSVGImage(obj2 = {}) {
    this.json.svgimages.push(obj2);
    var index2 = this.json.svgimages.length - 1;
    return index2;
  }
  createSVGImage(data = {}) {
    return this.addSVGImage(data);
  }
}
class TimelineModel extends AssetModel {
  getDefaultObject(obj2 = {}) {
    return super.getDefaultObject(__spreadValues({
      timeline: [],
      compiledTimeline: {}
    }, obj2));
  }
  expectJSON(key) {
    if (key === "compiledTimeline")
      return false;
    return super.expectJSON(key);
  }
  setTimelineInfo(obj2) {
    var timeline = this.getSelectedTimeline();
    if (!timeline)
      return;
    ["speed", "iterationCount", "direction"].forEach((key) => {
      if (isNotUndefined(obj2[key])) {
        timeline[key] = obj2[key];
      }
    });
  }
  compileAll() {
    var timeline = this.getSelectedTimeline();
    this.json.compiledTimeline = {};
    if (timeline) {
      timeline.animations.forEach((animation2) => {
        animation2.properties.forEach((property) => {
          this.compiledTimingFunction(animation2.id, property.property);
        });
      });
    }
  }
  searchTimelineOffset(time) {
    var timeline = this.getSelectedTimeline();
    var filteredTimeline = [];
    if (timeline) {
      timeline.animations.forEach((animation2) => {
        animation2.properties.forEach((p) => {
          var list2 = this.getCompiledTimingFunction(animation2.id, p.property);
          filteredTimeline.push(list2.find((keyframe2) => {
            if (keyframe2.isOnlyTime && keyframe2.startTime <= time)
              return true;
            return keyframe2.startTime <= time && time < keyframe2.endTime;
          }));
        });
      });
    }
    return filteredTimeline.filter((it) => it);
  }
  getCompiledTimingFunction(layerId, property) {
    return this.json.compiledTimeline[`${layerId}.${property}`];
  }
  compiledTimingFunction(layerId, property) {
    var artboard2 = this;
    var p = this.getTimelineProperty(layerId, property);
    var layer2 = this.modelManager.get(layerId);
    var key = `${layerId}.${property}`;
    if (p.keyframes.length === 1) {
      this.json.compiledTimeline[key] = [];
      return;
    }
    let layerElement = Dom.body().$(`[data-id="${layerId}"]`);
    let editorString = p.keyframes.map((it) => it.editor)[0];
    this.json.compiledTimeline[key] = p.keyframes.map((offset, index2) => {
      var currentOffset = offset;
      var nextOffset = p.keyframes[index2 + 1];
      offset.editor = editorString;
      if (!nextOffset) {
        nextOffset = { time: offset.time, value: offset.value };
      }
      var it = {
        layer: layer2,
        layerElement,
        property: p.property,
        isOnlyTime: currentOffset.time === nextOffset.time,
        startTime: offset.time,
        endTime: nextOffset.time,
        startValue: offset.value,
        endValue: nextOffset.value,
        timing: offset.timing,
        interpolateFunction: createInterpolateFunction(layer2, p.property, offset.value, nextOffset.value, offset.editor, artboard2, layerElement),
        timingFunction: createTimingFunction(offset.timing)
      };
      it.func = this.makeTimingFunction(it);
      return it;
    }).filter((it) => it);
  }
  makeTimingFunction(it) {
    return (time) => {
      var totalT = it.endTime - it.startTime;
      var t = 1;
      if (totalT !== 0) {
        t = (time - it.startTime) / totalT;
      }
      return it.interpolateFunction(it.timingFunction(t), t, totalT, it.timingFunction);
    };
  }
  stop(frameOrCode) {
    var timeline = this.getSelectedTimeline();
    if (timeline) {
      var time = timeline.currentTime;
      this.searchTimelineOffset(time).forEach((it) => {
        if (it.property === "playTime") {
          const $video = it.layerElement.$("video");
          if ($video) {
            $video.el.pause();
          }
        }
      });
    }
  }
  seek(frameOrCode, filterFunction = (it) => it) {
    var timeline = this.getSelectedTimeline();
    if (timeline) {
      if (isNotUndefined(frameOrCode)) {
        this.setTimelineCurrentTime(frameOrCode);
      }
      var time = timeline.currentTime;
      this.searchTimelineOffset(time).filter(filterFunction).forEach((it) => {
        if (it.property === "offset-path" || it.property === "playTime") {
          it.func(time);
        } else if (it.layer) {
          it.layer.reset({
            [it.property]: it.func(time)
          });
        }
      });
    }
  }
  getSelectedTimeline() {
    var timeline = this.json.timeline;
    var a = timeline.filter((it) => it.selected);
    var selectedTimeline = a.length ? a[0] : timeline[0];
    return selectedTimeline || null;
  }
  getKeyframeListReturnArray() {
    var timeline = this.getSelectedTimeline();
    var keyframes = [];
    if (timeline) {
      timeline.animations.forEach((a) => {
        a.properties.forEach((p) => {
          keyframes.push.apply(keyframes, p.keyframes);
        });
      });
    }
    return keyframes;
  }
  getKeyframeList(callback) {
    var timeline = this.getSelectedTimeline();
    if (timeline) {
      timeline.animations.forEach((a) => {
        a.properties.forEach((p) => {
          p.keyframes.forEach((k) => {
            callback && callback(timeline, k);
          });
        });
      });
    }
  }
  getSelectedTimelineLastTime() {
    var time = 0;
    this.getKeyframeList((timeline, keyframe2) => {
      time = Math.max(keyframe2.time, time);
    });
    return time;
  }
  getSelectedTimelineFirstTime() {
    var time = Number.MAX_SAFE_INTEGER;
    this.getKeyframeList((timeline, keyframe2) => {
      time = Math.min(keyframe2.time, time);
    });
    return time;
  }
  getSelectedTimelinePrevTime() {
    var time = this.getSelectedTimelineFirstTime();
    this.getKeyframeList((timeline, keyframe2) => {
      if (timecode(timeline.fps, keyframe2.time) < timeline.currentTimecode) {
        time = Math.max(keyframe2.time, time);
      }
    });
    return time;
  }
  getSelectedTimelineNextTime() {
    var time = this.getSelectedTimelineLastTime();
    this.getKeyframeList((timeline, keyframe2) => {
      if (timecode(timeline.fps, keyframe2.time) > timeline.currentTimecode) {
        time = Math.min(keyframe2.time, time);
      }
    });
    return time;
  }
  setTimelineTitle(id, text2) {
    var timeline = this.json.timeline.find((it) => {
      return it.id === id;
    });
    if (timeline) {
      timeline.title = text2;
    }
  }
  selectTimeline(id) {
    if (id) {
      this.json.timeline.forEach((it) => {
        it.selected = it.id === id;
      });
    } else {
      var selectedTimeline = this.json.timeline.filter((it) => it.selected);
      if (selectedTimeline.length)
        ;
      else {
        if (this.json.timeline.length) {
          this.json.timeline.selected = true;
        }
      }
    }
    this.compileAll();
  }
  removeAnimation(id) {
    this.json.timeline = this.json.timeline.filter((it) => {
      return it.id !== id;
    });
    if (this.json.timeline.length) {
      this.json.timeline[0].selected = true;
    }
    this.compileAll();
  }
  addTimeline(fps = 60, endTimecode = "00:00:10:00") {
    var id = uuidShort$1();
    var selectedTimeline = __spreadProps(__spreadValues({
      id,
      title: "sample"
    }, this.getTimelineLayerInfo(fps, endTimecode)), {
      animations: []
    });
    this.json.timeline.push(selectedTimeline);
    this.selectTimeline(id);
    return selectedTimeline;
  }
  addTimelineLayer(layerId, fps = 60, endTimecode = "00:00:10:00") {
    var selectedTimeline = this.getSelectedTimeline();
    if (!selectedTimeline) {
      selectedTimeline = this.addTimeline(fps, endTimecode);
    }
    selectedTimeline.selected = true;
    if (layerId) {
      var layer2 = selectedTimeline.animations.filter((it) => it.id === layerId);
      if (!layer2[0]) {
        selectedTimeline.animations.push({
          id: layerId,
          properties: []
        });
      }
    }
  }
  getTimelineLayerInfo(fps = 60, endTimecode = "00:00:10:00") {
    var endTime = second(fps, endTimecode);
    return {
      fps,
      speed: 1,
      direction: "normal",
      iterationCount: 1,
      currentTimecode: timecode(fps, 0),
      totalTimecode: timecode(fps, endTime),
      currentTime: 0,
      totalTime: endTime,
      displayStartTime: 0,
      displayEndTime: endTime
    };
  }
  setTimelineCurrentTime(frameOrCode) {
    var timeline = this.getSelectedTimeline();
    var { fps, totalTimecode } = timeline;
    if (timeline) {
      var frame = frameOrCode;
      var code2 = frameOrCode;
      if (+frame + "" === frame) {
        frame = +frame;
        code2 = framesToTimecode(fps, frame);
      }
      if (code2 > totalTimecode) {
        code2 = totalTimecode;
      }
      var currentTime = second(fps, code2);
      timeline.currentTime = currentTime;
      timeline.currentTimecode = timecode(fps, currentTime);
    }
  }
  setDisplayTimeDxRate(dxRate, initStartTime, initEndTime) {
    var timeline = this.getSelectedTimeline();
    if (timeline) {
      var dxTime = dxRate * timeline.totalTime;
      var startTime = initStartTime + dxTime;
      var endTime = initEndTime + dxTime;
      startTime = Math.max(startTime, 0);
      startTime = Math.min(startTime, endTime);
      if (startTime === 0) {
        endTime = initEndTime - initStartTime;
      }
      endTime = Math.max(endTime, startTime);
      endTime = Math.min(endTime, timeline.totalTime);
      if (endTime === timeline.totalTime) {
        startTime = timeline.totalTime - (initEndTime - initStartTime);
      }
      timeline.displayStartTime = startTime;
      timeline.displayEndTime = endTime;
    }
  }
  setDisplayStartTimeRate(rate) {
    var timeline = this.getSelectedTimeline();
    if (timeline) {
      timeline.displayStartTime = rate * timeline.totalTime;
    }
  }
  setDisplayEndTimeRate(rate) {
    var timeline = this.getSelectedTimeline();
    if (timeline) {
      timeline.displayEndTime = rate * timeline.totalTime;
    }
  }
  setTimelineCurrentTimeRate(rate) {
    var timeline = this.getSelectedTimeline();
    if (timeline) {
      var { displayStartTime, displayEndTime, fps } = timeline;
      var currentTime = displayStartTime + (displayEndTime - displayStartTime) * rate;
      this.setTimelineCurrentTime(timecode(fps, currentTime));
    }
  }
  setTimelineTotalTime(frameOrCode) {
    var timeline = this.getSelectedTimeline();
    if (timeline) {
      var frame = frameOrCode;
      var code2 = frameOrCode;
      if (+frame + "" === frame) {
        frame = +frame;
        code2 = framesToTimecode(timeline.fps, frame);
      }
      if (second(timeline.fps, code2) < timeline.displayEndTime) {
        timeline.displayEndTime = second(timeline.fps, code2);
        timeline.displayStartTime = 0;
      }
      timeline.totalTimecode = code2;
      timeline.totalTime = second(timeline.fps, code2);
    }
  }
  getTimelineObject(layerId) {
    var selectedTimeline = this.getSelectedTimeline();
    if (selectedTimeline) {
      return selectedTimeline.animations.find((it) => it.id === layerId);
    }
  }
  addTimelineProperty(layerId, property) {
    this.addTimelineLayer(layerId);
    var animation2 = this.getTimelineObject(layerId);
    if (animation2) {
      var p = animation2.properties.filter((it) => it.property === property);
      if (!p.length) {
        animation2.properties.push({
          property,
          keyframes: []
        });
        this.compiledTimingFunction(layerId, property);
      }
    }
  }
  getTimelineProperty(layerId, property) {
    var timeline = this.getSelectedTimeline();
    if (timeline) {
      layerId = layerId || timeline.selectedLayerId;
      property = property || timeline.selectedProperty;
      var timelineObject = this.getTimelineObject(layerId);
      if (timelineObject) {
        return timelineObject.properties.find((it) => it.property === property);
      }
    }
  }
  setSelectedOffset(layerId, property, time) {
    var timeline = this.getSelectedTimeline();
    if (timeline) {
      timeline.selectedLayerId = layerId;
      timeline.selectedProperty = property;
      timeline.selectedOffsetTime = time;
      var p = this.getTimelineProperty();
      p.keyframes.forEach((it) => {
        it.selected = it.time === time;
      });
    }
  }
  deleteTimelineKeyframe(layerId, property, offsetId) {
    var p = this.getTimelineProperty(layerId, property);
    if (p) {
      p.keyframes = p.keyframes.filter((it) => it.id != offsetId);
    }
  }
  removeTimelineProperty(layerId, property) {
    var layer2 = this.getTimelineObject(layerId);
    if (layer2) {
      layer2.properties = layer2.properties.filter((p) => p.property != property);
    }
  }
  removeTimeline(layerId) {
    var timeline = this.getSelectedTimeline();
    if (timeline) {
      timeline.animations = timeline.animations.filter((ani) => ani.id != layerId);
    }
  }
  setTimelineKeyframeOffsetTime(layerId, property, offsetId, changedTime) {
    var keyframe2 = this.getTimelineKeyframeById(layerId, property, offsetId);
    if (keyframe2) {
      keyframe2.time = changedTime;
      this.compiledTimingFunction(layerId, property);
    }
  }
  setTimelineKeyframeOffsetValue(layerId, property, offsetId, value = void 0, timing = void 0, time = void 0) {
    var keyframe2 = this.getTimelineKeyframeById(layerId, property, offsetId);
    if (keyframe2) {
      if (isNotUndefined(time)) {
        keyframe2.time = time;
      }
      if (isNotUndefined(value)) {
        keyframe2.value = value;
      }
      if (isNotUndefined(timing)) {
        keyframe2.timing = timing;
      }
      this.compiledTimingFunction(layerId, property);
    }
  }
  addTimelineKeyframe({ layerId, property, value, timing, time: newTime, editor }) {
    this.addTimelineProperty(layerId, property);
    var timeline = this.getSelectedTimeline();
    var p = this.getTimelineProperty(layerId, property);
    if (p) {
      var time = newTime || timeline.currentTime;
      var times = p.keyframes.filter((it) => it.time === time);
      if (!times.length) {
        value = isUndefined(value) || value === "" ? this.getDefaultPropertyValue(property) : value;
        var obj2 = { id: uuidShort$1(), layerId, property, time, value, timing: timing || "linear", editor };
        p.keyframes.push(obj2);
        p.keyframes.sort((a, b) => {
          return a.time > b.time ? 1 : -1;
        });
        this.compiledTimingFunction(layerId, property);
        return obj2;
      }
    }
  }
  getDefaultPropertyValue(property) {
    switch (property) {
      case "mix-blend-mode":
        return "normal";
      case "rotate":
        return "0deg";
      case "box-shadow":
        return "0px 0px 0px 0px rgba(0, 0, 0, 1)";
      case "text-shadow":
        return "0px 0px 0px rgba(0, 0, 0, 1)";
      case "opacity":
        return 1;
      default:
        return "";
    }
  }
  copyTimelineKeyframe(layerId, property, newTime = null) {
    var p = this.getTimelineProperty(layerId, property);
    if (p) {
      var timeline = this.getSelectedTimeline();
      var time = newTime || timeline.currentTime;
      var times = p.keyframes.filter((it) => it.time < time);
      var value = this.getDefaultPropertyValue(property);
      var timing = "linear";
      var editor = "";
      if (times.length) {
        times.sort((a, b) => {
          return a.time > b.time ? -1 : 1;
        });
        value = times[0].value + "";
        timing = times[0].timing + "";
        editor = times[0].editor;
      }
      this.addTimelineKeyframe({ layerId, property, value, timing, editor });
    }
  }
  getTimelineKeyframe(layerId, property, time) {
    var p = this.getTimelineProperty(layerId, property);
    if (p) {
      return p.keyframes.find((it) => it.time === time);
    }
  }
  getTimelineKeyframeById(layerId, property, id) {
    var p = this.getTimelineProperty(layerId, property);
    if (p) {
      return p.keyframes.find((it) => it.id === id);
    }
  }
  sortTimelineKeyframe(layerId, property) {
    var p = this.getTimelineProperty(layerId, property);
    if (p) {
      p.keyframes.sort((a, b) => {
        return a.time > b.time ? 1 : -1;
      });
      this.compiledTimingFunction(layerId, property);
    }
  }
  setFps(fps) {
    var timeline = this.getSelectedTimeline();
    if (timeline) {
      timeline.fps = fps;
      timeline.currentTimecode = timecode(fps, timeline.currentTime);
      timeline.totalTimecode = timecode(fps, timeline.totalTime);
    }
  }
  toCloneObject() {
    return __spreadProps(__spreadValues({}, super.toCloneObject()), {
      timeline: clone$1(this.json.timeline)
    });
  }
}
const identity = create$5();
class Project extends TimelineModel {
  getDefaultTitle() {
    return "New Project";
  }
  get isAbsolute() {
    return false;
  }
  get parent() {
    return null;
  }
  toRootVariableCSS() {
    var obj2 = {};
    this.json.rootVariable.split(";").filter((it) => it.trim()).forEach((it) => {
      var [key, value] = it.split(":");
      obj2[`--${key}`] = value;
    });
    return obj2;
  }
  getDefaultObject(obj2 = {}) {
    return super.getDefaultObject(__spreadValues({
      itemType: "project",
      name: "new Project",
      description: "",
      rootVariable: ""
    }, obj2));
  }
  toCloneObject() {
    return __spreadValues(__spreadValues({}, super.toCloneObject()), this.attrs("name", "description", "rootVariable"));
  }
  get artboards() {
    return (this.layers || []).filter((it) => it.is("artboard"));
  }
  get offsetX() {
    return 0;
  }
  get offsetY() {
    return 0;
  }
  get screenWidth() {
    return 0;
  }
  get screenHeight() {
    return 0;
  }
  hasLayout() {
    return false;
  }
  getAbsoluteMatrix() {
    return create$5();
  }
  getTransformMatrix() {
    return create$5();
  }
  resetMatrix(childItem) {
    const [x2, y2] = getTranslation([], calculateMatrix(childItem.absoluteMatrix, childItem.localMatrixInverse));
    childItem.reset({
      x: x2,
      y: y2
    });
  }
  get rectVerties() {
    var _a;
    return ((_a = this.layers) == null ? void 0 : _a.length) ? itemsToRectVerties(this.layers) : null;
  }
  get absoluteMatrix() {
    return identity;
  }
  get absoluteMatrixInverse() {
    return identity;
  }
  get contentBox() {
    return {
      left: 0,
      top: 0,
      width: 0,
      height: 0
    };
  }
}
class SelectionManager {
  constructor(editor) {
    this.$editor = editor;
    this.project = null;
    this.itemKeys = {};
    this.hoverId = "";
    this.hoverItems = [];
    this.ids = [];
    this.colorsteps = [];
    this.cachedItemMatrices = [];
    this.cachedArtBoardVerties = [];
    this.cachedVerties = rectToVerties(0, 0, 0, 0, "50% 50% 0px");
    this.$editor.on("config:bodyEvent", () => {
      this.refreshMousePosition();
    });
  }
  refreshMousePosition() {
    const areaWidth = this.$editor.config.get("area.width");
    const pos = this.$editor.viewport.getWorldPosition();
    this.pos = pos;
    const [row, column] = area(pos[0], pos[1], areaWidth);
    this.row = row;
    this.column = column;
  }
  get modelManager() {
    return this.$editor.modelManager;
  }
  get lockManager() {
    return this.$editor.lockManager;
  }
  get items() {
    return this.modelManager.searchLiveItemsById(this.ids);
  }
  get current() {
    return this.modelManager.searchItem(this.ids[0]);
  }
  get currentProject() {
    if (!this.project) {
      this.project = this.modelManager.getProjectByIndex();
    }
    return this.project;
  }
  get isEmpty() {
    return !this.length;
  }
  get isOne() {
    if (this.length === 1 && this.current.is("artboard"))
      return true;
    return this.length === 1;
  }
  get isMany() {
    return this.length > 1;
  }
  get length() {
    return this.ids.length;
  }
  get isLayoutItem() {
    var _a;
    return (_a = this.current) == null ? void 0 : _a.isLayoutItem();
  }
  get allLayers() {
    return this.currentProject.allLayers || [];
  }
  get filteredLayers() {
    const areaWidth = this.$editor.config.get("area.width");
    return this.currentProject.filteredAllLayers((item2) => {
      if (item2.is("project"))
        return false;
      const areaPosition = item2.getAreaPosition(areaWidth);
      if (!areaPosition) {
        return false;
      }
      const { column, row } = areaPosition;
      return column[0] <= this.column && this.column <= column[1] && (row[0] <= this.row && this.row <= row[1]);
    }).filter((item2) => {
      return item2.isPointInRect(this.pos[0], this.pos[1]);
    });
  }
  get snapTargetLayers() {
    if (!this.currentProject)
      return [];
    return this.currentProject.allLayers.filter((item2) => {
      if (item2.is("project"))
        return false;
      if (this.check(item2))
        return false;
      const inViewport = item2.verties.some((v) => {
        return this.$editor.viewport.checkInViewport(v);
      });
      return inViewport;
    });
  }
  get snapTargetLayersWithSelection() {
    if (!this.currentProject)
      return [];
    return this.currentProject.allLayers.filter((item2) => {
      if (item2.is("project"))
        return false;
      const inViewport = item2.verties.some((v) => {
        return this.$editor.viewport.checkInViewport(v);
      });
      return inViewport;
    });
  }
  get selectedArtboards() {
    return [...new Set(this.items.map((it) => it.artboard))];
  }
  hasChangedField(...args2) {
    if (this.current) {
      return this.current.hasChangedField(...args2);
    }
    return false;
  }
  getRootItem(current) {
    var rootItem = current;
    if (current && current.parentId) {
      rootItem = current.parent;
    }
    return rootItem;
  }
  selectColorStep(...args2) {
    this.colorsteps = args2;
  }
  isSelectedColorStep(id) {
    return this.colorsteps.includes(id);
  }
  selectProject(project2) {
    if (isString(project2)) {
      project2 = this.modelManager.get(project2);
    }
    this.project = project2;
    this.select();
  }
  get isRelative() {
    var item2 = this.current || {};
    return item2.position === "relative";
  }
  isSameIds(newIds) {
    if (this.ids.length != newIds.length) {
      return false;
    }
    if (this.ids.filter((id) => newIds.includes(id)).length === this.ids.length) {
      return true;
    }
    return false;
  }
  filterIds(ids = []) {
    return ids.map((it) => it.id || it).filter(Boolean);
  }
  selectByGroup(...ids) {
    var list2 = this.modelManager.searchItemsById(this.filterIds(ids || [])).filter((it) => {
      return !this.lockManager.get(it.id);
    });
    const newSelectedItems = this.modelManager.convertGroupItems(list2);
    return this.select(...newSelectedItems.map((it) => it.id));
  }
  select(...ids) {
    var list2 = this.modelManager.searchItemsById(this.filterIds(ids || [])).filter((it) => !it.lock && it.isAbsolute);
    const newSelectedItems = list2.filter((it) => {
      return it.path.filter((element) => list2.includes(element)).length < 2;
    });
    const newSelectedIds = newSelectedItems.map((it) => it.id);
    if (this.isSameIds(newSelectedIds)) {
      return false;
    }
    this.itemKeys = {};
    newSelectedItems.forEach((item2) => {
      this.itemKeys[item2.id] = item2;
    });
    this.ids = newSelectedIds;
    this.setRectCache();
    return true;
  }
  reload() {
    return this.select(...this.ids);
  }
  reselect() {
    this.setRectCache();
  }
  check(item2) {
    return !!this.itemKeys[item2.id];
  }
  hasPathOf(item2) {
    return this.modelManager.hasPathOf(this.items.filter((it) => it.isNot("artboard")), item2);
  }
  hasParent(parentId) {
    return this.items.some((it) => it.hasParent(parentId));
  }
  get(id) {
    return this.itemKeys[id];
  }
  empty() {
    this.select();
  }
  itemsByIds(ids = null) {
    let itemIdList = [];
    if (Array.isArray(ids)) {
      itemIdList = ids;
    } else if (isString(ids) || isObject(ids)) {
      itemIdList = [ids];
    }
    return this.modelManager.searchItemsById(itemIdList);
  }
  selectById(id) {
    this.select(id);
  }
  selectAfterCopy() {
    this.select(...this.items.map((it) => it.copy()));
  }
  addById(id) {
    if (this.itemKeys[id])
      return;
    this.select(...this.ids, id);
  }
  removeById(id) {
    let ids = id;
    if (isString(id)) {
      ids = [id];
    }
    const filteredItems = this.ids.filter((id2) => ids.includes(id2) === false);
    this.select(...filteredItems);
  }
  toggleById(id) {
    if (this.itemKeys[id]) {
      this.removeById(id);
    } else {
      this.addById(id);
    }
  }
  getArtboardByPoint(vec) {
    return this.currentProject.artboards.find((artboard2) => {
      return polyPoint(artboard2.originVerties, ...vec);
    });
  }
  changeArtBoard() {
    let checkedParentChange = false;
    this.each((instance) => {
      if (instance.is("artboard") === false) {
        const instanceVerties = instance.originVerties;
        if (instance.artboard) {
          const localArtboard = instance.artboard;
          const localArtboardVerties = localArtboard.originVerties;
          const isInArtboard = polyPoint(localArtboardVerties, ...instanceVerties[0]) || polyPoly(instanceVerties, localArtboardVerties);
          if (isInArtboard) {
            return false;
          }
        }
        const selectedArtBoard = this.cachedArtBoardVerties.find((artboard2) => {
          const artboardVerties = artboard2.matrix.originVerties;
          return polyPoint(artboardVerties, ...instanceVerties[0]) || polyPoly(instanceVerties, artboardVerties);
        });
        if (selectedArtBoard) {
          if (selectedArtBoard.item !== instance.artboard) {
            selectedArtBoard.item.appendChild(instance);
            checkedParentChange = true;
          }
        } else {
          if (instance.artboard) {
            this.currentProject.appendChild(instance);
            checkedParentChange = true;
          }
        }
      }
    });
    return checkedParentChange;
  }
  setRectCache() {
    if (this.isEmpty) {
      this.cachedVerties = [];
      this.cachedRectVerties = [];
      this.cachedItemMatrices = [];
      this.cachedArtBoardVerties = this.currentProject.artboards.map((item2) => {
        return { item: item2, matrix: item2.matrix };
      });
      return;
    }
    this.cachedVerties = this.verties;
    this.cachedRectVerties = toRectVerties(this.verties);
    this.cachedItemMatrices = [];
    this.cachedChildren = [];
    this.items.forEach((it) => {
      if (it.is("artboard")) {
        this.cachedItemMatrices.push(it.matrix);
      } else if (it.hasChildren()) {
        const list2 = this.modelManager.getAllLayers(it.id).map((it2) => it2.matrix);
        this.cachedChildren.push(...list2.map((it2) => it2.id));
        this.cachedItemMatrices.push(...list2);
      } else {
        this.cachedItemMatrices.push(it.matrix);
      }
    });
    this.cachedArtBoardVerties = this.currentProject.artboards.map((item2) => {
      return { item: item2, matrix: item2.matrix };
    });
    this.cachedCurrentItemMatrix = this.current.matrix;
    this.cachedCurrentChildrenItemMatrices = this.modelManager.getAllLayers(this.current.id).map((it) => it.matrix);
  }
  startToCacheChildren() {
    this.items.forEach((item2) => {
      item2.startToCacheChildren();
    });
  }
  recoverChildren() {
    this.items.forEach((item2) => {
      item2.recoverChildren();
    });
  }
  get verties() {
    if (this.isOne) {
      return this.current.verties;
    } else {
      return this.rectVerties;
    }
  }
  get targetVerties() {
    if (this.isOne) {
      return this.current.targetVerties;
    } else {
      return targetItemsToRectVerties(this.items);
    }
  }
  get originVerties() {
    return this.rectVerties.filter((_, index2) => index2 < 4);
  }
  get rectVerties() {
    if (this.isEmpty) {
      return [];
    }
    return itemsToRectVerties(this.items);
  }
  get itemRect() {
    const verties = this.verties;
    return {
      x: verties[0][0],
      y: verties[0][1],
      width: distance$1(verties[0], verties[1]),
      height: distance$1(verties[0], verties[3])
    };
  }
  toCloneObject() {
    let data = {};
    this.each((item2) => {
      data[item2.id] = item2.toCloneObject(false);
    });
    return data;
  }
  pack(...keys2) {
    let data = {};
    this.each((item2) => {
      data[item2.id] = {};
      keys2.forEach((key) => {
        data[item2.id][key] = item2[key];
      });
    });
    return data;
  }
  packByIds(ids, ...keys2) {
    let data = {};
    let localItems = [];
    if (ids === null) {
      localItems = this.items;
    } else if (isString(ids) || Array.isArray(ids)) {
      localItems = this.itemsByIds(ids);
    }
    const valueObject = {};
    keys2.forEach((it) => {
      valueObject[it] = true;
    });
    localItems.forEach((item2) => {
      data[item2.id] = item2.attrs(...keys2);
    });
    return data;
  }
  packByValue(valueObject, ids = null) {
    let data = {};
    let localItems = [];
    if (ids === null) {
      localItems = this.items;
    } else if (isString(ids) || Array.isArray(ids)) {
      localItems = this.itemsByIds(ids);
    }
    localItems.forEach((item2) => {
      data[item2.id] = {};
      Object.keys(valueObject).forEach((key) => {
        data[item2.id][key] = isFunction(valueObject[key]) ? valueObject[key].call(valueObject, item2) : valueObject[key];
      });
    });
    return data;
  }
  each(callback) {
    if (isFunction(callback)) {
      this.items.forEach((item2, index2) => {
        callback(item2);
      });
    }
  }
  map(callback) {
    if (isFunction(callback)) {
      return this.items.map((item2, index2) => {
        return callback(item2, index2);
      });
    }
    return this.items;
  }
  reset(obj2) {
    Object.entries(obj2).forEach(([id, attrs]) => {
      var _a;
      (_a = this.get(id)) == null ? void 0 : _a.reset(attrs);
    });
  }
  resetCallback(callback) {
    this.each((item2) => item2.reset(callback(item2)));
  }
  resize() {
    this.each((item2) => item2.resize());
  }
  remove() {
    this.each((item2) => item2.remove());
    this.empty();
  }
  copy() {
    console.warn("copy is deprecated");
    this.copyItems = this.items.map((item2) => item2);
  }
  paste() {
    console.warn("paste is deprecated. use copy and paste");
    this.select(...this.copyItems.map((item2) => item2.copy(10)));
    this.copy();
  }
  hasPoint(point2) {
    var _a;
    if (this.isMany) {
      return polyPoint(this.originVerties, point2[0], point2[1]);
    } else {
      return (_a = this.current) == null ? void 0 : _a.hasPoint(point2[0], point2[1]);
    }
  }
  hasChildrenPoint(point2) {
    return this.cachedChildren.some((it) => {
      var _a;
      return (_a = this.modelManager.get(it)) == null ? void 0 : _a.hasPoint(point2[0], point2[1]);
    });
  }
  checkChildren(childId) {
    return this.cachedChildren.includes(childId);
  }
  checkHover(itemOrId) {
    if (isString(itemOrId)) {
      return this.hoverId === itemOrId;
    } else {
      return this.hoverItems.findIndex((it) => it.id === itemOrId.id) > -1;
    }
  }
  hasHoverItem() {
    return this.hoverId !== "";
  }
  selectHoverItem() {
    this.select(this.hoverId);
  }
  setHoverId(id) {
    let isChanged = false;
    if (!id || this.itemKeys[id]) {
      if (this.hoverId != "") {
        isChanged = true;
      }
      this.hoverId = "";
      this.hoverItems = [];
    } else if (this.cachedArtBoardVerties.find((it) => it.item.id === id)) {
      if (this.hoverId != "") {
        isChanged = true;
      }
      this.hoverId = "";
      this.hoverItems = [];
    } else {
      if (this.hoverId != id) {
        isChanged = true;
      }
      this.hoverId = id;
      this.hoverItems = this.itemsByIds([id]).filter((it) => it.isNot("artboard"));
      if (this.hoverItems.length === 0) {
        this.hoverId = "";
        isChanged = true;
      }
    }
    if (isChanged) {
      this.$editor.emit("changeHoverItem");
    }
    return isChanged;
  }
  is(...args2) {
    var _a;
    return args2.includes((_a = this.current) == null ? void 0 : _a.itemType);
  }
  isAll(...args2) {
    return this.items.every((it) => args2.includes(it.itemType));
  }
}
function _currentProject(editor, callback) {
  var project2 = editor.selection.currentProject;
  if (project2) {
    var timeline = project2.getSelectedTimeline();
    callback && callback(project2, timeline);
  }
}
var __glob_0_0$4 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": _currentProject
});
function _doForceRefreshSelection(editor) {
  editor.emit("noneSelectMenu");
  editor.nextTick(() => {
    editor.emit("refreshAll");
    editor.emit("refreshSelectionTool");
  });
}
var __glob_0_1$4 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": _doForceRefreshSelection
});
function addArtBoard(editor, obj2 = {}, center2 = null) {
  var project2 = editor.selection.currentProject;
  if (!project2) {
    project2 = editor.add(editor.createModel({ itemType: "project" }));
    editor.selection.selectProject(project2);
  }
  var artboard2 = project2.appendChild(editor.createModel(__spreadValues({
    itemType: "artboard",
    x: 300,
    y: 200,
    width: 375,
    height: 667
  }, obj2)));
  if (center2) {
    artboard2.reset({
      x: 0,
      y: 0
    });
    artboard2.moveByCenter(center2);
  }
  editor.selection.select(artboard2);
  _doForceRefreshSelection(editor);
}
var __glob_0_2$4 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": addArtBoard
});
var addBackgroundColor = {
  command: "addBackgroundColor",
  execute: function(editor, color2, id = null) {
    editor.command("setAttributeForMulti", "add background color", editor.selection.packByValue({
      "background-color": color2
    }, id));
  }
};
var __glob_0_3$4 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": addBackgroundColor
});
var addBackgroundImageAsset = {
  command: "addBackgroundImageAsset",
  execute: function(editor, url, id = null) {
    var items = editor.selection.itemsByIds(id);
    let itemsMap = {};
    items.forEach((item2) => {
      let images = BackgroundImage.parseStyle(STRING_TO_CSS(item2["background-image"]));
      images.unshift(new BackgroundImage({
        image: new URLImageResource({ url })
      }));
      itemsMap[item2.id] = {
        "background-image": BackgroundImage.join(images)
      };
    });
    editor.emit("history.setAttributeForMulti", "add background image", itemsMap);
  }
};
var __glob_0_4$4 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": addBackgroundImageAsset
});
var addBackgroundImageGradient = {
  command: "addBackgroundImageGradient",
  execute: function(editor, gradient2, id = null) {
    var items = editor.selection.itemsByIds(id);
    let itemsMap = {};
    items.forEach((item2) => {
      let images = BackgroundImage.parseStyle(STRING_TO_CSS(item2["background-image"]));
      images.unshift(new BackgroundImage({
        image: BackgroundImage.parseImage(gradient2)
      }));
      itemsMap[item2.id] = {
        "background-image": BackgroundImage.join(images)
      };
    });
    editor.emit("history.setAttributeForMulti", "add gradient", itemsMap);
  }
};
var __glob_0_5$4 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": addBackgroundImageGradient
});
const MAX_CACHE_COUNT = 1e3;
const cachedPatternMap = new Map();
class PatternCache {
  static has(key) {
    return cachedPatternMap.has(key);
  }
  static get(key) {
    return cachedPatternMap.get(key);
  }
  static set(key, parsedValue) {
    if (cachedPatternMap.size > MAX_CACHE_COUNT) {
      cachedPatternMap.clear();
    }
    cachedPatternMap.set(key, parsedValue);
  }
}
const PATTERN_REG = /((check|grid|dot|cross\-dot|diagonal\-line|vertical\-line|horizontal\-line|)\(([^\)]*)\))/gi;
class Pattern extends PropertyItem {
  getDefaultObject(obj2 = {}) {
    return super.getDefaultObject(__spreadValues({
      itemType: "pattern"
    }, obj2));
  }
  toString() {
    return `${this.json.type}(${this.json.value || ""})`;
  }
  static parse(obj2) {
    var PatternClass = PatternClassName[obj2.type];
    if (PatternClass) {
      return new PatternClass(obj2);
    }
  }
  static parseStyle(pattern) {
    var patterns2 = [];
    if (!pattern)
      return patterns2;
    pattern = pattern.trim();
    if (PatternCache.has(pattern)) {
      return PatternCache.get(pattern);
    }
    var results = convertMatches(pattern);
    var matches2 = results.str.match(PATTERN_REG) || [];
    matches2.forEach((value, index2) => {
      var [patternName, patternValue] = value.split("(");
      patternValue = patternValue.split(")")[0].trim();
      var [size2, position2, foreColor, backColor, blendMode, lineSize] = patternValue.split(",").map((it) => it.trim());
      var [width2, height2] = size2.split(" ");
      var [x2, y2] = position2.split(" ");
      var [lineWidth, lineHeight] = (lineSize || "").split(" ");
      patterns2[index2] = Pattern.parse({
        type: patternName,
        x: Length.parse(x2),
        y: Length.parse(y2),
        width: Length.parse(width2),
        height: Length.parse(height2),
        foreColor: reverseMatches(foreColor, results.matches),
        backColor: reverseMatches(backColor, results.matches),
        blendMode: blendMode || "normal",
        lineWidth: Length.parse(lineWidth || "1px"),
        lineHeight: Length.parse(lineHeight || "1px")
      });
    });
    PatternCache.set(pattern, patterns2);
    return patterns2;
  }
  static join(list2) {
    return list2.map((it) => Pattern.parse(it)).join(" ");
  }
  static toCSS(str) {
    let list2 = [];
    Pattern.parseStyle(str).forEach((it) => {
      list2.push.apply(list2, BackgroundImage.parseStyle(STRING_TO_CSS(it.toCSS())));
    });
    return BackgroundImage.joinCSS(list2);
  }
}
class BasePattern extends Pattern {
  getDefaultObject() {
    return super.getDefaultObject({
      type: "base",
      x: 0,
      y: 0,
      width: 20,
      height: 20,
      lineWidth: 1,
      lineHeight: 1,
      foreColor: "black",
      backColor: "white",
      blendMode: "normal"
    });
  }
  convert(json) {
    json = super.convert(json);
    json.width = Length.parse(json.width);
    json.height = Length.parse(json.height);
    json.lineWidth = Length.parse(json.lineWidth);
    json.lineHeight = Length.parse(json.lineHeight);
    json.x = Length.parse(json.x);
    json.y = Length.parse(json.y);
    return json;
  }
  toString() {
    var {
      type,
      width: width2,
      height: height2,
      x: x2,
      y: y2,
      foreColor,
      backColor,
      blendMode,
      lineWidth,
      lineHeight
    } = this.json;
    return `${type}(${width2} ${height2}, ${x2} ${y2}, ${foreColor}, ${backColor}, ${blendMode}, ${lineWidth} ${lineHeight})`;
  }
}
class CheckPattern extends BasePattern {
  getDefaultObject() {
    return super.getDefaultObject({
      type: "check"
    });
  }
  toCSS() {
    let { width: width2, height: height2, x: x2, y: y2, backColor, foreColor, blendMode } = this.json;
    backColor = backColor || "transparent";
    foreColor = foreColor || "black";
    return `
      background-image: repeating-linear-gradient(45deg, ${foreColor} 25%, ${backColor} 25%, ${backColor} 75%, ${foreColor} 75%, ${foreColor} 100%),repeating-linear-gradient(45deg, ${foreColor} 25%, ${backColor} 25%, ${backColor} 75%, ${foreColor} 75%, ${foreColor} 100%);
      background-position: 0px 0px, ${x2} ${y2};
      background-size: ${width2} ${height2}, ${width2} ${height2};
      background-blend-mode: ${blendMode}, ${blendMode};
    `;
  }
}
class GridPattern extends BasePattern {
  getDefaultObject() {
    return super.getDefaultObject({
      type: "grid"
    });
  }
  toCSS() {
    let { width: width2, height: height2, lineWidth, lineHeight, backColor, foreColor, blendMode } = this.json;
    backColor = backColor || "transparent";
    foreColor = foreColor || "black";
    return `
      background-image: linear-gradient(to bottom,${foreColor} ${lineHeight}, ${backColor} ${lineHeight}),linear-gradient(to right, ${foreColor} ${lineWidth}, ${backColor} ${lineWidth});
      background-size: ${width2 / 2}px ${height2 / 2}px, ${width2 / 2}px ${height2 / 2}px;      
      background-blend-mode: ${blendMode}, ${blendMode};      
    `;
  }
}
class DotPattern extends BasePattern {
  getDefaultObject() {
    return super.getDefaultObject({
      type: "dot"
    });
  }
  toCSS() {
    let { width: width2, height: height2, lineWidth, lineHeight, backColor, foreColor, blendMode } = this.json;
    backColor = backColor || "transparent";
    foreColor = foreColor || "black";
    return `
      background-image: radial-gradient(${foreColor} ${lineWidth}, ${backColor} ${lineWidth});
      background-size: ${width2 / 2}px ${height2 / 2}px;          
      background-blend-mode: ${blendMode};      
    `;
  }
}
class CrossDotPattern extends BasePattern {
  getDefaultObject() {
    return super.getDefaultObject({
      type: "cross-dot"
    });
  }
  toCSS() {
    let { width: width2, height: height2, x: x2, y: y2, lineWidth, lineHeight, backColor, foreColor, blendMode } = this.json;
    backColor = backColor || "transparent";
    foreColor = foreColor || "black";
    return `
      background-image: radial-gradient(${foreColor} ${lineWidth}, ${backColor} ${lineWidth}),radial-gradient(${foreColor} ${lineWidth}, ${backColor} ${lineWidth});
      background-size: ${width2} ${height2},${width2} ${height2};
      background-position: 0px 0px, ${x2} ${y2};      
      background-blend-mode: multiply, ${blendMode};
    `;
  }
}
class DiagonalLinePattern extends BasePattern {
  getDefaultObject() {
    return super.getDefaultObject({
      type: "diagonal-line"
    });
  }
  toCSS() {
    let { width: width2, height: height2, x: x2, lineWidth, backColor, foreColor, blendMode } = this.json;
    backColor = backColor || "transparent";
    foreColor = foreColor || "black";
    return `
    background-image: repeating-linear-gradient(${x2}, ${foreColor} 0px, ${foreColor} ${lineWidth}, ${backColor} 0px, ${backColor} 50%);
    background-size: ${width2} ${height2};      
    background-blend-mode: ${blendMode};
  `;
  }
}
class VerticalLinePattern extends BasePattern {
  getDefaultObject() {
    return super.getDefaultObject({
      type: "vertical-line"
    });
  }
  toCSS() {
    let { width: width2, height: height2, x: x2, y: y2, lineWidth, backColor, foreColor, blendMode } = this.json;
    backColor = backColor || "transparent";
    foreColor = foreColor || "black";
    return `
      background-image: repeating-linear-gradient(to right, ${foreColor} 0px, ${foreColor} ${lineWidth}, ${backColor} ${lineWidth}, ${backColor} 100%);
      background-size: ${width2} ${height2}; 
      background-position: ${x2} ${y2};        
      background-blend-mode: ${blendMode};
    `;
  }
}
class HorizontalLinePattern extends BasePattern {
  getDefaultObject() {
    return super.getDefaultObject({
      type: "horizontal-line"
    });
  }
  toCSS() {
    let { width: width2, height: height2, x: x2, y: y2, lineWidth, backColor, foreColor, blendMode } = this.json;
    backColor = backColor || "transparent";
    foreColor = foreColor || "black";
    return `
      background-image: repeating-linear-gradient( to bottom, ${foreColor} 0px, ${foreColor} ${lineWidth}, ${backColor} ${lineWidth}, ${backColor} 100%);    
      background-position: ${x2} ${y2};
      background-size: ${width2} ${height2};   
      background-blend-mode: ${blendMode};
    `;
  }
}
const PatternClassName = {
  check: CheckPattern,
  grid: GridPattern,
  dot: DotPattern,
  "cross-dot": CrossDotPattern,
  "diagonal-line": DiagonalLinePattern,
  "vertical-line": VerticalLinePattern,
  "horizontal-line": HorizontalLinePattern
};
var addBackgroundImagePattern = {
  command: "addBackgroundImagePattern",
  execute: function(editor, pattern, id = null) {
    var items = editor.selection.itemsByIds(id);
    let itemsMap = {};
    items.forEach((item2) => {
      itemsMap[item2.id] = {
        pattern: Pattern.join([
          ...Pattern.parseStyle(pattern),
          ...Pattern.parseStyle(item2.pattern)
        ])
      };
    });
    editor.emit("history.setAttributeForMulti", "add pattern", itemsMap);
  }
};
var __glob_0_6$4 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": addBackgroundImagePattern
});
function addCustomComponent(editor, obj2 = {}, center2 = null) {
  var project2 = editor.selection.currentProject;
  var customComponent = project2.appendChild(editor.createModel(__spreadValues({
    x: 300,
    y: 200,
    width: 375,
    height: 667
  }, obj2)));
  if (center2) {
    customComponent.reset({
      x: 0,
      y: 0
    });
    customComponent.moveByCenter(center2);
  }
  editor.selection.select(customComponent);
  _doForceRefreshSelection(editor);
}
var __glob_0_7$4 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": addCustomComponent
});
function addImage(editor, rect2 = {}, containerItem = void 0) {
  editor.emit("newComponent", "image", rect2, true, containerItem);
}
var __glob_0_8$4 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": addImage
});
function loadOriginalImage(obj2, callback) {
  var img = new Image();
  img.onload = () => {
    var info = {
      id: obj2.id,
      local: obj2.local,
      naturalWidth: img.naturalWidth,
      naturalHeight: img.naturalHeight,
      width: img.naturalWidth,
      height: img.naturalHeight
    };
    callback && callback(info, img);
  };
  img.onerror = (e2) => {
    console.log(e2, e2.message);
  };
  img.src = obj2.local;
}
var addImageAssetItem = {
  command: "addImageAssetItem",
  execute: function(editor, imageObject, rect2 = {}, containerItem = void 0) {
    var project2 = editor.selection.currentProject;
    if (project2) {
      project2.createImage(imageObject);
      editor.emit("addImageAsset");
      loadOriginalImage(imageObject, (info) => {
        const rate = rect2.width / info.width;
        const width2 = rect2.width;
        const height2 = info.height * rate;
        editor.emit("addImage", __spreadProps(__spreadValues(__spreadValues({
          src: imageObject.id
        }, info), rect2), {
          width: width2,
          height: height2
        }), containerItem);
        editor.changeMode(EDIT_MODE_SELECTION);
      });
    }
  }
};
var __glob_0_9$4 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": addImageAssetItem
});
function addLayer(editor, layer2, isSelected = true, containerItem) {
  if (!containerItem) {
    containerItem = editor.selection.current || editor.selection.currentProject;
  }
  if (containerItem) {
    if (containerItem.isNot("project") && !containerItem.enableHasChildren()) {
      containerItem = containerItem.parent;
    }
    containerItem.appendChild(layer2);
    if (isSelected) {
      editor.selection.select(layer2);
    }
    _doForceRefreshSelection(editor);
  }
}
var __glob_0_10$4 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": addLayer
});
const Language = {
  EN: "en_US",
  FR: "fr_FR",
  KO: "ko_KR"
};
const EditingMode = {
  SELECT: "select",
  APPEND: "append",
  DRAW: "draw",
  PATH: "path"
};
const DesignMode = {
  EDIT: "edit",
  PREVIEW: "preview",
  DESIGN: "design",
  ITEM: "item"
};
async function addLayerView(editor, type, data = {}) {
  editor.selection.empty();
  await editor.emit("refreshSelectionTool");
  await editor.emit("hideAddViewLayer");
  await editor.emit("removeGuideLine");
  if (type === "select") {
    editor.config.set("editing.mode", EditingMode.SELECT);
  } else if (type === "brush") {
    editor.config.set("editing.mode", EditingMode.DRAW);
    await editor.emit("showPathDrawEditor");
  } else if (type === "path") {
    editor.config.set("editing.mode", EditingMode.PATH);
    await editor.emit("showPathEditor", "path");
  } else {
    editor.config.set("editing.mode", EditingMode.APPEND);
    editor.config.set("editing.mode.itemType", type);
    await editor.emit("showLayerAppendView", type, data);
  }
}
var __glob_0_11$4 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": addLayerView
});
function addProject(editor, obj2 = {}) {
  var project2 = editor.createModel(__spreadValues({
    itemType: "project"
  }, obj2));
  editor.selection.selectProject(project2);
  _doForceRefreshSelection(editor);
}
var __glob_0_12$4 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": addProject
});
var addSVGFilterAssetItem = {
  command: "addSVGFilterAssetItem",
  execute: function(editor, callback) {
    var project2 = editor.selection.currentProject;
    if (project2) {
      var id = uuidShort$1();
      var index2 = project2.createSVGFilter({ id, filters: [] });
      callback && callback(index2, id);
    }
  }
};
var __glob_0_13$4 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": addSVGFilterAssetItem
});
function addText(editor, rect2 = {}) {
  editor.emit("newComponent", "text", __spreadValues({
    content: "Insert a text",
    width: 300,
    height: 50,
    "font-size": 30
  }, rect2), rect2);
}
var __glob_0_14$4 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": addText
});
var addTimelineCurrentProperty = {
  command: "addTimelineCurrentProperty",
  execute: function(editor, options2 = { timing: "linear" }) {
    _currentProject(editor, (project2, timeline) => {
      var list2 = [];
      editor.selection.each((item2) => {
        var keyframeObj = {
          layerId: item2.id,
          property: options2.property,
          value: item2[options2.property] + "",
          timing: options2.timing,
          editor: options2.editor
        };
        var obj2 = project2.addTimelineKeyframe(keyframeObj);
        if (obj2) {
          list2.push(obj2);
        }
      });
      editor.timeline.select(...list2);
      editor.emit("refreshTimeline");
      editor.emit("refreshSelectedOffset");
    });
  }
};
var __glob_0_15$4 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": addTimelineCurrentProperty
});
var addTimelineItem = {
  command: "addTimelineItem",
  execute: function(editor, layerId) {
    _currentProject(editor, (project2, timeline) => {
      if (layerId) {
        project2.addTimelineLayer(layerId);
      } else {
        project2.addTimeline();
      }
      editor.emit("refreshTimeline");
      editor.emit("addTimeline");
    });
  }
};
var __glob_0_16$4 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": addTimelineItem
});
var addTimelineKeyframe = {
  command: "addTimelineKeyframe",
  execute: function(editor, options2 = { timing: "linear" }) {
    _currentProject(editor, (project2, timeline) => {
      var item2 = editor.modelManager.get(options2.layerId);
      var keyframeObj = {
        layerId: options2.layerId,
        property: options2.property,
        time: options2.time,
        value: item2[options2.property] + "",
        timing: options2.timing,
        editor: options2.editor
      };
      var obj2 = project2.addTimelineKeyframe(keyframeObj);
      editor.timeline.select(obj2);
      editor.emit("refreshTimeline");
      editor.emit("refreshSelectedOffset");
    });
  }
};
var __glob_0_17$4 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": addTimelineKeyframe
});
var addTimelineProperty = {
  command: "addTimelineProperty",
  execute: function(editor, layerList, options2 = { timing: "linear" }) {
    _currentProject(editor, (project2, timeline) => {
      if (Array.isArray(layerList) === false) {
        layerList = [layerList];
      }
      var list2 = [];
      layerList.forEach((layerId) => {
        var keyframeObj = {
          layerId,
          property: options2.property,
          value: options2.value + "",
          timing: options2.timing,
          editor: options2.editor
        };
        var obj2 = project2.addTimelineKeyframe(keyframeObj);
        if (obj2) {
          list2.push(obj2);
        }
      });
      editor.timeline.select(...list2);
      editor.emit("refreshTimeline");
      editor.emit("refreshSelectedOffset");
    });
  }
};
var __glob_0_18$4 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": addTimelineProperty
});
function addVideo(editor, rect2 = {}, containerItem = void 0) {
  editor.emit("newComponent", "video", rect2, true, containerItem);
}
var __glob_0_19$4 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": addVideo
});
function loadOriginalVideo(obj2, callback) {
  var video2 = document.createElement("video");
  video2.onloadeddata = () => {
    var info = {
      local: obj2.local,
      naturalWidth: video2.videoWidth,
      naturalHeight: video2.videoHeight,
      width: video2.videoWidth,
      height: video2.videoHeight,
      duration: video2.duration,
      playTime: `0:1:${video2.duration}`,
      volume: video2.volume,
      muted: video2.muted,
      placebackRate: video2.playbackRate
    };
    callback && callback(info, video2);
  };
  video2.src = obj2.local;
}
var addVideoAssetItem = {
  command: "addVideoAssetItem",
  execute: function(editor, videoObject, rect2 = {}, containerItem = void 0) {
    var project2 = editor.selection.currentProject;
    if (project2) {
      project2.createVideo(videoObject);
      editor.emit("addVideoAsset");
      loadOriginalVideo(videoObject, (info) => {
        editor.emit("addVideo", __spreadValues(__spreadValues({ src: videoObject.id }, info), rect2), containerItem);
        editor.changeMode(EDIT_MODE_SELECTION);
      });
    }
  }
};
var __glob_0_20$4 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": addVideoAssetItem
});
var clipboard_copy$1 = {
  command: "clipboard.copy",
  title: "Copy",
  description: "Copy",
  execute: function(editor) {
    editor.clipboard.push({
      type: "copy",
      data: editor.selection.ids
    });
  }
};
var __glob_0_21$3 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": clipboard_copy$1
});
var clipboard_paste$1 = {
  command: "clipboard.paste",
  execute: async function(editor, event) {
    if (!editor.clipboard.isEmpty) {
      const data = editor.clipboard.pop();
      if (data.type == "copy") {
        const ids = data.data;
        const items = await editor.json.renderAll(ids.map((it) => editor.get(it)));
        const newIds = [];
        const length2 = items.length;
        items.forEach((itemJSON) => {
          const referenceId = itemJSON.referenceId;
          const sourceItem = editor.get(referenceId);
          const model = editor.createModel(itemJSON);
          model.renameWithCount();
          model.move([10, 10, 0]);
          if (length2 === 1) {
            sourceItem.appendBefore(model);
          } else {
            sourceItem.appendAfter(model);
          }
          newIds.push(model.id);
        });
        editor.selection.select(...newIds);
        editor.emit("refreshAll");
      }
    } else {
      var text2 = await navigator.clipboard.readText();
      if (text2) {
        editor.emit("convertPasteText", text2);
      }
    }
  }
};
var __glob_0_22$3 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": clipboard_paste$1
});
var convert_flatten_path = {
  command: "convert.flatten.path",
  description: "flatten selected multi path",
  execute: (editor) => {
    const current = editor.selection.current;
    if (!current)
      return;
    let newPath;
    if (current.is("boolean-path") || current.isBooleanItem) {
      let parent = current;
      if (current.isBooleanItem) {
        parent = current.parent;
      }
      newPath = parent.absolutePath(parent["boolean-path"]);
      newPath = parent.invertPath(newPath.d);
      const newLayerAttrs = parent.layers[0].toCloneObject();
      delete newLayerAttrs.id;
      delete newLayerAttrs.parentId;
      delete newLayerAttrs.transform;
      delete newLayerAttrs["boolean-path"];
      delete newLayerAttrs["boolean-operation"];
      const parentParent = parent.parent;
      const newRectInfo = parent.updatePath(newPath.d);
      editor.command("removeLayer", "remove selected layers", [parent.id]);
      editor.nextTick(() => {
        editor.command("addLayer", `add layer - path`, editor.createModel(__spreadValues(__spreadValues({}, newLayerAttrs), newRectInfo)), true, parentParent);
      });
    } else {
      newPath = PathParser.fromSVGString();
      editor.selection.each((item2) => {
        newPath.addPath(item2.absolutePath());
      });
      newPath = current.invertPath(newPath.d);
      const parent = current.parent;
      const newPathInfo = current.updatePath(newPath.d);
      const newLayerAttrs = current.toCloneObject();
      delete newLayerAttrs.id;
      editor.command("removeLayer", "remove selected layers");
      editor.nextTick(() => {
        editor.command("addLayer", `add layer - path`, editor.createModel(__spreadValues(__spreadValues({}, newLayerAttrs), newPathInfo)), true, parent);
      });
    }
  }
};
var __glob_0_23$3 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": convert_flatten_path
});
var convert_no_transform_path = {
  command: "convert.no.transform.path",
  description: "remove transform(rotate, translate, scale) inforation in path layer",
  execute: (editor) => {
    const current = editor.selection.current;
    if (!current)
      return;
    const parent = current.parent;
    const childPath = current.absolutePath();
    if (parent.is("project")) {
      const verties = childPath.getBBox();
      const newRect = vertiesToRectangle(verties);
      editor.command("setAttributeForMulti", "remove transform for path", editor.selection.packByValue(__spreadProps(__spreadValues({}, newRect), {
        rotate: 0,
        d: childPath.d
      })));
    } else {
      childPath.transformMat4(parent.absoluteMatrixInverse);
      const newRect = parent.updatePath(childPath.d);
      editor.command("setAttributeForMulti", "remove transform for path", editor.selection.packByValue(__spreadProps(__spreadValues({}, newRect), {
        rotate: 0,
        d: childPath.d
      })));
    }
  }
};
var __glob_0_24$2 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": convert_no_transform_path
});
var convert_normalize_path = {
  command: "convert.normalize.path",
  description: "convert segments to bezier curve",
  execute: (editor) => {
    const current = editor.selection.current;
    if (!current)
      return;
    editor.command("setAttributeForMulti", "normalize path string", editor.selection.packByValue(current.updatePath(PathParser.fromSVGString(current.d).normalize().d)));
  }
};
var __glob_0_25$2 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": convert_normalize_path
});
var convert_path_operation = {
  command: "convert.path.operation",
  description: "apply path boolean operation",
  execute: (editor, booleanOperation) => {
    var _a;
    const current = editor.selection.current;
    if (!current)
      return;
    const changeBooleanOperation = (booleanOperation2) => {
      editor.command("setAttributeForMulti", "change boolean operation", editor.selection.packByValue({
        "boolean-operation": booleanOperation2
      }));
      recoverBooleanPath2();
    };
    const recoverBooleanPath2 = () => {
      editor.nextTick(() => {
        editor.emit("recoverBooleanPath");
        editor.nextTick(() => {
          editor.emit("refreshSelection");
          editor.emit("refreshSelectionTool");
        });
      });
    };
    if (current.is("boolean-path") || current.isBooleanItem) {
      let parent = current;
      if (current.isBooleanItem) {
        parent = current.parent;
      }
      editor.selection.select(parent);
      changeBooleanOperation(booleanOperation);
    } else {
      if ((_a = editor.selection.current) == null ? void 0 : _a.isNot("boolean-path")) {
        editor.emit("group.item", {
          itemType: "boolean-path",
          title: "Intersection"
        });
      }
      editor.nextTick(() => {
        var _a2;
        if ((_a2 = editor.selection.current) == null ? void 0 : _a2.is("boolean-path")) {
          changeBooleanOperation(booleanOperation);
        }
      }, 10);
    }
  }
};
var __glob_0_26$2 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": convert_path_operation
});
var convert_polygonal_path = {
  command: "convert.polygonal.path",
  description: "convert path to polygonal path",
  execute: (editor) => {
    const current = editor.selection.current;
    if (!current)
      return;
    editor.command("setAttributeForMulti", "polygonal path string", editor.selection.packByValue(current.updatePath(PathParser.fromSVGString(current.d).polygonal().d)));
  }
};
var __glob_0_27$2 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": convert_polygonal_path
});
var convert_simplify_path = {
  command: "convert.simplify.path",
  execute: (editor) => {
    const current = editor.selection.current;
    if (!current)
      return;
    editor.command("setAttributeForMulti", "change path string", editor.selection.packByValue(current.updatePath(editor.pathKitManager.simplify(current.d))));
  }
};
var __glob_0_28$2 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": convert_simplify_path
});
var convert_smooth_path = {
  command: "convert.smooth.path",
  description: "convert path to smooth",
  execute: (editor, divideCount = 5, tolerance = 0.1, tension = 0.5) => {
    const current = editor.selection.current;
    if (!current)
      return;
    const smoothedPath = PathParser.fromSVGString(current.d).divideSegmentByCount(divideCount).simplify(tolerance).cardinalSplines(tension).d;
    editor.command("setAttributeForMulti", "smooth path string", editor.selection.packByValue(current.updatePath(smoothedPath)));
  }
};
var __glob_0_29$2 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": convert_smooth_path
});
var convert_stroke_to_path = {
  command: "convert.stroke.to.path",
  execute: async (editor, text2) => {
    const current = editor.selection.current;
    if (!current)
      return;
    const attrs = current.attrs("d", "stroke-width", "stroke-dasharray", "stroke-dashoffset", "stroke-linejoin", "stroke-linecap");
    const pathAttrs = current.convertStrokeToPath();
    let newD = editor.pathKitManager.stroke(current.d || attrs.d, {
      "stroke-width": Length.parse(attrs["stroke-width"]).value,
      "stroke-linejoin": attrs["stroke-linejoin"],
      "stroke-linecap": attrs["stroke-linecap"],
      "stroke-dasharray": attrs["stroke-dasharray"],
      "stroke-dashoffset": attrs["stroke-dashoffset"],
      "fill-rule": "nonezero"
    });
    pathAttrs["fill-rule"] = "nonzero";
    newD = PathParser.fromSVGString(newD).reversePathStringByFunc((_, index2) => index2 % 2 === 0);
    editor.command("addLayer", `add layer - path`, editor.createModel(__spreadValues(__spreadValues({}, pathAttrs), current.updatePath(newD))), true, current.parent);
  }
};
var __glob_0_30$2 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": convert_stroke_to_path
});
var jsVideoUrlParser = { exports: {} };
(function(module, exports) {
  (function(global2, factory) {
    module.exports = factory();
  })(commonjsGlobal, function() {
    function _typeof(obj2) {
      "@babel/helpers - typeof";
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof = function(obj3) {
          return typeof obj3;
        };
      } else {
        _typeof = function(obj3) {
          return obj3 && typeof Symbol === "function" && obj3.constructor === Symbol && obj3 !== Symbol.prototype ? "symbol" : typeof obj3;
        };
      }
      return _typeof(obj2);
    }
    var getQueryParams = function getQueryParams2(qs) {
      if (typeof qs !== "string") {
        return {};
      }
      qs = qs.split("+").join(" ");
      var params = {};
      var match = qs.match(/(?:[?](?:[^=]+)=(?:[^&#]*)(?:[&](?:[^=]+)=(?:[^&#]*))*(?:[#].*)?)|(?:[#].*)/);
      var split;
      if (match === null) {
        return {};
      }
      split = match[0].substr(1).split(/[&#=]/);
      for (var i = 0; i < split.length; i += 2) {
        params[decodeURIComponent(split[i])] = decodeURIComponent(split[i + 1] || "");
      }
      return params;
    };
    var combineParams = function combineParams2(params, hasParams) {
      if (_typeof(params) !== "object") {
        return "";
      }
      var combined = "";
      var i = 0;
      var keys2 = Object.keys(params);
      if (keys2.length === 0) {
        return "";
      }
      keys2.sort();
      if (!hasParams) {
        combined += "?" + keys2[0] + "=" + params[keys2[0]];
        i += 1;
      }
      for (; i < keys2.length; i += 1) {
        combined += "&" + keys2[i] + "=" + params[keys2[i]];
      }
      return combined;
    };
    function getLetterTime(timeString) {
      var totalSeconds = 0;
      var timeValues = {
        "s": 1,
        "m": 1 * 60,
        "h": 1 * 60 * 60,
        "d": 1 * 60 * 60 * 24,
        "w": 1 * 60 * 60 * 24 * 7
      };
      var timePairs;
      timeString = timeString.replace(/([smhdw])/g, " $1 ").trim();
      timePairs = timeString.split(" ");
      for (var i = 0; i < timePairs.length; i += 2) {
        totalSeconds += parseInt(timePairs[i], 10) * timeValues[timePairs[i + 1] || "s"];
      }
      return totalSeconds;
    }
    function getColonTime(timeString) {
      var totalSeconds = 0;
      var timeValues = [1, 1 * 60, 1 * 60 * 60, 1 * 60 * 60 * 24, 1 * 60 * 60 * 24 * 7];
      var timePairs = timeString.split(":");
      for (var i = 0; i < timePairs.length; i++) {
        totalSeconds += parseInt(timePairs[i], 10) * timeValues[timePairs.length - i - 1];
      }
      return totalSeconds;
    }
    var getTime = function getTime2(timeString) {
      if (typeof timeString === "undefined") {
        return 0;
      }
      if (timeString.match(/^(\d+[smhdw]?)+$/)) {
        return getLetterTime(timeString);
      }
      if (timeString.match(/^(\d+:?)+$/)) {
        return getColonTime(timeString);
      }
      return 0;
    };
    var util = {
      getQueryParams,
      combineParams,
      getTime
    };
    var getQueryParams$1 = util.getQueryParams;
    function UrlParser() {
      for (var _i = 0, _arr = ["parseProvider", "parse", "bind", "create"]; _i < _arr.length; _i++) {
        var key = _arr[_i];
        this[key] = this[key].bind(this);
      }
      this.plugins = {};
    }
    var urlParser2 = UrlParser;
    UrlParser.prototype.parseProvider = function(url) {
      var match = url.match(/(?:(?:https?:)?\/\/)?(?:[^.]+\.)?(\w+)\./i);
      return match ? match[1] : void 0;
    };
    UrlParser.prototype.parse = function(url) {
      if (typeof url === "undefined") {
        return void 0;
      }
      var provider = this.parseProvider(url);
      var result;
      var plugin2 = this.plugins[provider];
      if (!provider || !plugin2 || !plugin2.parse) {
        return void 0;
      }
      result = plugin2.parse.call(plugin2, url, getQueryParams$1(url));
      if (result) {
        result = removeEmptyParameters(result);
        result.provider = plugin2.provider;
      }
      return result;
    };
    UrlParser.prototype.bind = function(plugin2) {
      this.plugins[plugin2.provider] = plugin2;
      if (plugin2.alternatives) {
        for (var i = 0; i < plugin2.alternatives.length; i += 1) {
          this.plugins[plugin2.alternatives[i]] = plugin2;
        }
      }
    };
    UrlParser.prototype.create = function(op) {
      if (_typeof(op) !== "object" || _typeof(op.videoInfo) !== "object") {
        return void 0;
      }
      var vi = op.videoInfo;
      var params = op.params;
      var plugin2 = this.plugins[vi.provider];
      params = params === "internal" ? vi.params : params || {};
      if (plugin2) {
        op.format = op.format || plugin2.defaultFormat;
        if (plugin2.formats.hasOwnProperty(op.format)) {
          return plugin2.formats[op.format].apply(plugin2, [vi, Object.assign({}, params)]);
        }
      }
      return void 0;
    };
    function removeEmptyParameters(result) {
      if (result.params && Object.keys(result.params).length === 0) {
        delete result.params;
      }
      return result;
    }
    var parser2 = new urlParser2();
    var base = parser2;
    var combineParams$1 = util.combineParams;
    function CanalPlus() {
      this.provider = "canalplus";
      this.defaultFormat = "embed";
      this.formats = {
        embed: this.createEmbedUrl
      };
      this.mediaTypes = {
        VIDEO: "video"
      };
    }
    CanalPlus.prototype.parseParameters = function(params) {
      delete params.vid;
      return params;
    };
    CanalPlus.prototype.parse = function(url, params) {
      var _this = this;
      var result = {
        mediaType: this.mediaTypes.VIDEO,
        id: params.vid
      };
      result.params = _this.parseParameters(params);
      if (!result.id) {
        return void 0;
      }
      return result;
    };
    CanalPlus.prototype.createEmbedUrl = function(vi, params) {
      if (!vi.id || vi.mediaType !== this.mediaTypes.VIDEO) {
        return void 0;
      }
      var url = "http://player.canalplus.fr/embed/";
      params.vid = vi.id;
      url += combineParams$1(params);
      return url;
    };
    base.bind(new CanalPlus());
    var combineParams$2 = util.combineParams;
    function Coub() {
      this.provider = "coub";
      this.defaultFormat = "long";
      this.formats = {
        "long": this.createLongUrl,
        embed: this.createEmbedUrl
      };
      this.mediaTypes = {
        VIDEO: "video"
      };
    }
    Coub.prototype.parseUrl = function(url) {
      var match = url.match(/(?:embed|view)\/([a-zA-Z\d]+)/i);
      return match ? match[1] : void 0;
    };
    Coub.prototype.parse = function(url, params) {
      var result = {
        mediaType: this.mediaTypes.VIDEO,
        params,
        id: this.parseUrl(url)
      };
      if (!result.id) {
        return void 0;
      }
      return result;
    };
    Coub.prototype.createUrl = function(baseUrl, vi, params) {
      if (!vi.id || vi.mediaType !== this.mediaTypes.VIDEO) {
        return void 0;
      }
      var url = baseUrl + vi.id;
      url += combineParams$2(params);
      return url;
    };
    Coub.prototype.createLongUrl = function(vi, params) {
      return this.createUrl("https://coub.com/view/", vi, params);
    };
    Coub.prototype.createEmbedUrl = function(vi, params) {
      return this.createUrl("//coub.com/embed/", vi, params);
    };
    base.bind(new Coub());
    var combineParams$3 = util.combineParams, getTime$1 = util.getTime;
    function Dailymotion() {
      this.provider = "dailymotion";
      this.alternatives = ["dai"];
      this.defaultFormat = "long";
      this.formats = {
        "short": this.createShortUrl,
        "long": this.createLongUrl,
        embed: this.createEmbedUrl,
        image: this.createImageUrl
      };
      this.mediaTypes = {
        VIDEO: "video"
      };
    }
    Dailymotion.prototype.parseParameters = function(params) {
      return this.parseTime(params);
    };
    Dailymotion.prototype.parseTime = function(params) {
      if (params.start) {
        params.start = getTime$1(params.start);
      }
      return params;
    };
    Dailymotion.prototype.parseUrl = function(url) {
      var match = url.match(/(?:\/video|ly)\/([A-Za-z0-9]+)/i);
      return match ? match[1] : void 0;
    };
    Dailymotion.prototype.parse = function(url, params) {
      var _this = this;
      var result = {
        mediaType: this.mediaTypes.VIDEO,
        params: _this.parseParameters(params),
        id: _this.parseUrl(url)
      };
      return result.id ? result : void 0;
    };
    Dailymotion.prototype.createUrl = function(base2, vi, params) {
      if (!vi.id || vi.mediaType !== this.mediaTypes.VIDEO) {
        return void 0;
      }
      return base2 + vi.id + combineParams$3(params);
    };
    Dailymotion.prototype.createShortUrl = function(vi, params) {
      return this.createUrl("https://dai.ly/", vi, params);
    };
    Dailymotion.prototype.createLongUrl = function(vi, params) {
      return this.createUrl("https://dailymotion.com/video/", vi, params);
    };
    Dailymotion.prototype.createEmbedUrl = function(vi, params) {
      return this.createUrl("https://www.dailymotion.com/embed/video/", vi, params);
    };
    Dailymotion.prototype.createImageUrl = function(vi, params) {
      delete params.start;
      return this.createUrl("https://www.dailymotion.com/thumbnail/video/", vi, params);
    };
    base.bind(new Dailymotion());
    var combineParams$4 = util.combineParams, getTime$2 = util.getTime;
    function Twitch() {
      this.provider = "twitch";
      this.defaultFormat = "long";
      this.formats = {
        "long": this.createLongUrl,
        embed: this.createEmbedUrl
      };
      this.mediaTypes = {
        VIDEO: "video",
        STREAM: "stream",
        CLIP: "clip"
      };
    }
    Twitch.prototype.seperateId = function(id) {
      return {
        pre: id[0],
        id: id.substr(1)
      };
    };
    Twitch.prototype.parseChannel = function(result, params) {
      var channel = params.channel || params.utm_content || result.channel;
      delete params.utm_content;
      delete params.channel;
      return channel;
    };
    Twitch.prototype.parseUrl = function(url, result, params) {
      var match;
      match = url.match(/(clips\.)?twitch\.tv\/(?:(?:videos\/(\d+))|(\w+)(?:\/clip\/(\w+))?)/i);
      if (match && match[2]) {
        result.id = "v" + match[2];
      } else if (params.video) {
        result.id = params.video;
        delete params.video;
      } else if (params.clip) {
        result.id = params.clip;
        result.isClip = true;
        delete params.clip;
      } else if (match && match[1] && match[3]) {
        result.id = match[3];
        result.isClip = true;
      } else if (match && match[3] && match[4]) {
        result.channel = match[3];
        result.id = match[4];
        result.isClip = true;
      } else if (match && match[3]) {
        result.channel = match[3];
      }
      return result;
    };
    Twitch.prototype.parseMediaType = function(result) {
      var mediaType;
      if (result.id) {
        if (result.isClip) {
          mediaType = this.mediaTypes.CLIP;
          delete result.isClip;
        } else {
          mediaType = this.mediaTypes.VIDEO;
        }
      } else if (result.channel) {
        mediaType = this.mediaTypes.STREAM;
      }
      return mediaType;
    };
    Twitch.prototype.parseParameters = function(params) {
      if (params.t) {
        params.start = getTime$2(params.t);
        delete params.t;
      }
      return params;
    };
    Twitch.prototype.parse = function(url, params) {
      var _this = this;
      var result = {};
      result = _this.parseUrl(url, result, params);
      result.channel = _this.parseChannel(result, params);
      result.mediaType = _this.parseMediaType(result);
      result.params = _this.parseParameters(params);
      return result.channel || result.id ? result : void 0;
    };
    Twitch.prototype.createLongUrl = function(vi, params) {
      var url = "";
      if (vi.mediaType === this.mediaTypes.STREAM && vi.channel) {
        url = "https://twitch.tv/" + vi.channel;
      } else if (vi.mediaType === this.mediaTypes.VIDEO && vi.id) {
        var sep = this.seperateId(vi.id);
        url = "https://twitch.tv/videos/" + sep.id;
        if (params.start) {
          params.t = params.start + "s";
          delete params.start;
        }
      } else if (vi.mediaType === this.mediaTypes.CLIP && vi.id) {
        if (vi.channel) {
          url = "https://www.twitch.tv/" + vi.channel + "/clip/" + vi.id;
        } else {
          url = "https://clips.twitch.tv/" + vi.id;
        }
      } else {
        return void 0;
      }
      url += combineParams$4(params);
      return url;
    };
    Twitch.prototype.createEmbedUrl = function(vi, params) {
      var url = "https://player.twitch.tv/";
      if (vi.mediaType === this.mediaTypes.STREAM && vi.channel) {
        params.channel = vi.channel;
      } else if (vi.mediaType === this.mediaTypes.VIDEO && vi.id) {
        params.video = vi.id;
        if (params.start) {
          params.t = params.start + "s";
          delete params.start;
        }
      } else if (vi.mediaType === this.mediaTypes.CLIP && vi.id) {
        url = "https://clips.twitch.tv/embed";
        params.clip = vi.id;
      } else {
        return void 0;
      }
      url += combineParams$4(params);
      return url;
    };
    base.bind(new Twitch());
    var combineParams$5 = util.combineParams, getTime$3 = util.getTime;
    function Vimeo() {
      this.provider = "vimeo";
      this.alternatives = ["vimeopro"];
      this.defaultFormat = "long";
      this.formats = {
        "long": this.createLongUrl,
        embed: this.createEmbedUrl
      };
      this.mediaTypes = {
        VIDEO: "video"
      };
    }
    Vimeo.prototype.parseUrl = function(url) {
      var match = url.match(/(?:\/(?:channels\/[\w]+|(?:(?:album\/\d+|groups\/[\w]+)\/)?videos?))?\/(\d+)/i);
      return match ? match[1] : void 0;
    };
    Vimeo.prototype.parseParameters = function(params) {
      return this.parseTime(params);
    };
    Vimeo.prototype.parseTime = function(params) {
      if (params.t) {
        params.start = getTime$3(params.t);
        delete params.t;
      }
      return params;
    };
    Vimeo.prototype.parse = function(url, params) {
      var result = {
        mediaType: this.mediaTypes.VIDEO,
        params: this.parseParameters(params),
        id: this.parseUrl(url)
      };
      return result.id ? result : void 0;
    };
    Vimeo.prototype.createUrl = function(baseUrl, vi, params) {
      if (!vi.id || vi.mediaType !== this.mediaTypes.VIDEO) {
        return void 0;
      }
      var url = baseUrl + vi.id;
      var startTime = params.start;
      delete params.start;
      url += combineParams$5(params);
      if (startTime) {
        url += "#t=" + startTime;
      }
      return url;
    };
    Vimeo.prototype.createLongUrl = function(vi, params) {
      return this.createUrl("https://vimeo.com/", vi, params);
    };
    Vimeo.prototype.createEmbedUrl = function(vi, params) {
      return this.createUrl("//player.vimeo.com/video/", vi, params);
    };
    base.bind(new Vimeo());
    var combineParams$6 = util.combineParams, getTime$4 = util.getTime;
    function Wistia() {
      this.provider = "wistia";
      this.alternatives = [];
      this.defaultFormat = "long";
      this.formats = {
        "long": this.createLongUrl,
        embed: this.createEmbedUrl,
        embedjsonp: this.createEmbedJsonpUrl
      };
      this.mediaTypes = {
        VIDEO: "video",
        EMBEDVIDEO: "embedvideo"
      };
    }
    Wistia.prototype.parseUrl = function(url) {
      var match = url.match(/(?:(?:medias|iframe)\/|wvideo=)([\w-]+)/);
      return match ? match[1] : void 0;
    };
    Wistia.prototype.parseChannel = function(url) {
      var match = url.match(/(?:(?:https?:)?\/\/)?([^.]*)\.wistia\./);
      var channel = match ? match[1] : void 0;
      if (channel === "fast" || channel === "content") {
        return void 0;
      }
      return channel;
    };
    Wistia.prototype.parseParameters = function(params, result) {
      if (params.wtime) {
        params.start = getTime$4(params.wtime);
        delete params.wtime;
      }
      if (params.wvideo === result.id) {
        delete params.wvideo;
      }
      return params;
    };
    Wistia.prototype.parseMediaType = function(result) {
      if (result.id && result.channel) {
        return this.mediaTypes.VIDEO;
      } else if (result.id) {
        delete result.channel;
        return this.mediaTypes.EMBEDVIDEO;
      } else {
        return void 0;
      }
    };
    Wistia.prototype.parse = function(url, params) {
      var result = {
        id: this.parseUrl(url),
        channel: this.parseChannel(url)
      };
      result.params = this.parseParameters(params, result);
      result.mediaType = this.parseMediaType(result);
      if (!result.id) {
        return void 0;
      }
      return result;
    };
    Wistia.prototype.createUrl = function(vi, params, url) {
      if (params.start) {
        params.wtime = params.start;
        delete params.start;
      }
      url += combineParams$6(params);
      return url;
    };
    Wistia.prototype.createLongUrl = function(vi, params) {
      if (!vi.id || vi.mediaType !== this.mediaTypes.VIDEO) {
        return void 0;
      }
      var url = "https://" + vi.channel + ".wistia.com/medias/" + vi.id;
      return this.createUrl(vi, params, url);
    };
    Wistia.prototype.createEmbedUrl = function(vi, params) {
      if (!vi.id || !(vi.mediaType === this.mediaTypes.VIDEO || vi.mediaType === this.mediaTypes.EMBEDVIDEO)) {
        return void 0;
      }
      var url = "https://fast.wistia.com/embed/iframe/" + vi.id;
      return this.createUrl(vi, params, url);
    };
    Wistia.prototype.createEmbedJsonpUrl = function(vi) {
      if (!vi.id || !(vi.mediaType === this.mediaTypes.VIDEO || vi.mediaType === this.mediaTypes.EMBEDVIDEO)) {
        return void 0;
      }
      return "https://fast.wistia.com/embed/medias/" + vi.id + ".jsonp";
    };
    base.bind(new Wistia());
    var combineParams$7 = util.combineParams;
    function Youku() {
      this.provider = "youku";
      this.defaultFormat = "long";
      this.formats = {
        embed: this.createEmbedUrl,
        "long": this.createLongUrl,
        flash: this.createFlashUrl,
        "static": this.createStaticUrl
      };
      this.mediaTypes = {
        VIDEO: "video"
      };
    }
    Youku.prototype.parseUrl = function(url) {
      var match = url.match(/(?:(?:embed|sid)\/|v_show\/id_|VideoIDS=)([a-zA-Z0-9]+)/);
      return match ? match[1] : void 0;
    };
    Youku.prototype.parseParameters = function(params) {
      if (params.VideoIDS) {
        delete params.VideoIDS;
      }
      return params;
    };
    Youku.prototype.parse = function(url, params) {
      var _this = this;
      var result = {
        mediaType: this.mediaTypes.VIDEO,
        id: _this.parseUrl(url),
        params: _this.parseParameters(params)
      };
      if (!result.id) {
        return void 0;
      }
      return result;
    };
    Youku.prototype.createUrl = function(baseUrl, vi, params) {
      if (!vi.id || vi.mediaType !== this.mediaTypes.VIDEO) {
        return void 0;
      }
      var url = baseUrl + vi.id;
      url += combineParams$7(params);
      return url;
    };
    Youku.prototype.createEmbedUrl = function(vi, params) {
      return this.createUrl("http://player.youku.com/embed/", vi, params);
    };
    Youku.prototype.createLongUrl = function(vi, params) {
      return this.createUrl("http://v.youku.com/v_show/id_", vi, params);
    };
    Youku.prototype.createStaticUrl = function(vi, params) {
      return this.createUrl("http://static.youku.com/v1.0.0638/v/swf/loader.swf?VideoIDS=", vi, params);
    };
    Youku.prototype.createFlashUrl = function(vi, params) {
      if (!vi.id || vi.mediaType !== this.mediaTypes.VIDEO) {
        return void 0;
      }
      var url = "http://player.youku.com/player.php/sid/" + vi.id + "/v.swf";
      url += combineParams$7(params);
      return url;
    };
    base.bind(new Youku());
    var combineParams$8 = util.combineParams, getTime$5 = util.getTime;
    function YouTube() {
      this.provider = "youtube";
      this.alternatives = ["youtu", "ytimg"];
      this.defaultFormat = "long";
      this.formats = {
        "short": this.createShortUrl,
        "long": this.createLongUrl,
        embed: this.createEmbedUrl,
        shortImage: this.createShortImageUrl,
        longImage: this.createLongImageUrl
      };
      this.imageQualities = {
        "0": "0",
        "1": "1",
        "2": "2",
        "3": "3",
        DEFAULT: "default",
        HQDEFAULT: "hqdefault",
        SDDEFAULT: "sddefault",
        MQDEFAULT: "mqdefault",
        MAXRESDEFAULT: "maxresdefault"
      };
      this.defaultImageQuality = this.imageQualities.HQDEFAULT;
      this.mediaTypes = {
        VIDEO: "video",
        PLAYLIST: "playlist",
        SHARE: "share",
        CHANNEL: "channel"
      };
    }
    YouTube.prototype.parseVideoUrl = function(url) {
      var match = url.match(/(?:(?:v|vi|be|videos|embed)\/(?!videoseries)|(?:v|ci)=)([\w-]{11})/i);
      return match ? match[1] : void 0;
    };
    YouTube.prototype.parseChannelUrl = function(url) {
      var match = url.match(/\/channel\/([\w-]+)/);
      if (match) {
        return {
          id: match[1],
          mediaType: this.mediaTypes.CHANNEL
        };
      }
      match = url.match(/\/(?:c|user)\/([\w-]+)/);
      if (match) {
        return {
          name: match[1],
          mediaType: this.mediaTypes.CHANNEL
        };
      }
    };
    YouTube.prototype.parseParameters = function(params, result) {
      if (params.start || params.t) {
        params.start = getTime$5(params.start || params.t);
        delete params.t;
      }
      if (params.v === result.id) {
        delete params.v;
      }
      if (params.list === result.id) {
        delete params.list;
      }
      return params;
    };
    YouTube.prototype.parseMediaType = function(result) {
      if (result.params.list) {
        result.list = result.params.list;
        delete result.params.list;
      }
      if (result.id && !result.params.ci) {
        result.mediaType = this.mediaTypes.VIDEO;
      } else if (result.list) {
        delete result.id;
        result.mediaType = this.mediaTypes.PLAYLIST;
      } else if (result.params.ci) {
        delete result.params.ci;
        result.mediaType = this.mediaTypes.SHARE;
      } else {
        return void 0;
      }
      return result;
    };
    YouTube.prototype.parse = function(url, params) {
      var channelResult = this.parseChannelUrl(url);
      if (channelResult) {
        return channelResult;
      } else {
        var result = {
          params,
          id: this.parseVideoUrl(url)
        };
        result.params = this.parseParameters(params, result);
        result = this.parseMediaType(result);
        return result;
      }
    };
    YouTube.prototype.createShortUrl = function(vi, params) {
      if (!vi.id || vi.mediaType !== this.mediaTypes.VIDEO) {
        return void 0;
      }
      var url = "https://youtu.be/" + vi.id;
      if (params.start) {
        url += "#t=" + params.start;
      }
      return url;
    };
    YouTube.prototype.createLongUrl = function(vi, params) {
      var url = "";
      var startTime = params.start;
      delete params.start;
      if (vi.mediaType === this.mediaTypes.CHANNEL) {
        if (vi.id) {
          url += "https://www.youtube.com/channel/" + vi.id;
        } else if (vi.name) {
          url += "https://www.youtube.com/c/" + vi.name;
        } else {
          return void 0;
        }
      } else if (vi.mediaType === this.mediaTypes.PLAYLIST && vi.list) {
        params.feature = "share";
        url += "https://www.youtube.com/playlist";
      } else if (vi.mediaType === this.mediaTypes.VIDEO && vi.id) {
        params.v = vi.id;
        url += "https://www.youtube.com/watch";
      } else if (vi.mediaType === this.mediaTypes.SHARE && vi.id) {
        params.ci = vi.id;
        url += "https://www.youtube.com/shared";
      } else {
        return void 0;
      }
      if (vi.list) {
        params.list = vi.list;
      }
      url += combineParams$8(params);
      if (vi.mediaType !== this.mediaTypes.PLAYLIST && startTime) {
        url += "#t=" + startTime;
      }
      return url;
    };
    YouTube.prototype.createEmbedUrl = function(vi, params) {
      var url = "https://www.youtube.com/embed";
      if (vi.mediaType === this.mediaTypes.PLAYLIST && vi.list) {
        params.listType = "playlist";
      } else if (vi.mediaType === this.mediaTypes.VIDEO && vi.id) {
        url += "/" + vi.id;
        if (params.loop === "1") {
          params.playlist = vi.id;
        }
      } else {
        return void 0;
      }
      if (vi.list) {
        params.list = vi.list;
      }
      url += combineParams$8(params);
      return url;
    };
    YouTube.prototype.createImageUrl = function(baseUrl, vi, params) {
      if (!vi.id || vi.mediaType !== this.mediaTypes.VIDEO) {
        return void 0;
      }
      var url = baseUrl + vi.id + "/";
      var quality = params.imageQuality || this.defaultImageQuality;
      return url + quality + ".jpg";
    };
    YouTube.prototype.createShortImageUrl = function(vi, params) {
      return this.createImageUrl("https://i.ytimg.com/vi/", vi, params);
    };
    YouTube.prototype.createLongImageUrl = function(vi, params) {
      return this.createImageUrl("https://img.youtube.com/vi/", vi, params);
    };
    base.bind(new YouTube());
    var combineParams$9 = util.combineParams, getTime$6 = util.getTime;
    function SoundCloud() {
      this.provider = "soundcloud";
      this.defaultFormat = "long";
      this.formats = {
        "long": this.createLongUrl,
        embed: this.createEmbedUrl
      };
      this.mediaTypes = {
        TRACK: "track",
        PLAYLIST: "playlist",
        APITRACK: "apitrack",
        APIPLAYLIST: "apiplaylist"
      };
    }
    SoundCloud.prototype.parseUrl = function(url, result) {
      var match = url.match(/(?:m\.)?soundcloud\.com\/(?:([\w-]+)\/(sets\/)?)([\w-]+)/i);
      if (!match) {
        return result;
      }
      result.channel = match[1];
      if (match[1] === "playlists" || match[2]) {
        result.list = match[3];
      } else {
        result.id = match[3];
      }
      return result;
    };
    SoundCloud.prototype.parseParameters = function(params) {
      if (params.t) {
        params.start = getTime$6(params.t);
        delete params.t;
      }
      return params;
    };
    SoundCloud.prototype.parseMediaType = function(result) {
      if (result.id) {
        if (result.channel === "tracks") {
          delete result.channel;
          delete result.params.url;
          result.mediaType = this.mediaTypes.APITRACK;
        } else {
          result.mediaType = this.mediaTypes.TRACK;
        }
      }
      if (result.list) {
        if (result.channel === "playlists") {
          delete result.channel;
          delete result.params.url;
          result.mediaType = this.mediaTypes.APIPLAYLIST;
        } else {
          result.mediaType = this.mediaTypes.PLAYLIST;
        }
      }
      return result;
    };
    SoundCloud.prototype.parse = function(url, params) {
      var result = {};
      result = this.parseUrl(url, result);
      result.params = this.parseParameters(params);
      result = this.parseMediaType(result);
      if (!result.id && !result.list) {
        return void 0;
      }
      return result;
    };
    SoundCloud.prototype.createLongUrl = function(vi, params) {
      var url = "";
      var startTime = params.start;
      delete params.start;
      if (vi.mediaType === this.mediaTypes.TRACK && vi.id && vi.channel) {
        url = "https://soundcloud.com/" + vi.channel + "/" + vi.id;
      } else if (vi.mediaType === this.mediaTypes.PLAYLIST && vi.list && vi.channel) {
        url = "https://soundcloud.com/" + vi.channel + "/sets/" + vi.list;
      } else if (vi.mediaType === this.mediaTypes.APITRACK && vi.id) {
        url = "https://api.soundcloud.com/tracks/" + vi.id;
      } else if (vi.mediaType === this.mediaTypes.APIPLAYLIST && vi.list) {
        url = "https://api.soundcloud.com/playlists/" + vi.list;
      } else {
        return void 0;
      }
      url += combineParams$9(params);
      if (startTime) {
        url += "#t=" + startTime;
      }
      return url;
    };
    SoundCloud.prototype.createEmbedUrl = function(vi, params) {
      var url = "https://w.soundcloud.com/player/";
      delete params.start;
      if (vi.mediaType === this.mediaTypes.APITRACK && vi.id) {
        params.url = "https%3A//api.soundcloud.com/tracks/" + vi.id;
      } else if (vi.mediaType === this.mediaTypes.APIPLAYLIST && vi.list) {
        params.url = "https%3A//api.soundcloud.com/playlists/" + vi.list;
      } else {
        return void 0;
      }
      url += combineParams$9(params);
      return url;
    };
    base.bind(new SoundCloud());
    var combineParams$a = util.combineParams;
    function TeacherTube() {
      this.provider = "teachertube";
      this.alternatives = [];
      this.defaultFormat = "long";
      this.formats = {
        "long": this.createLongUrl,
        embed: this.createEmbedUrl
      };
      this.mediaTypes = {
        VIDEO: "video",
        AUDIO: "audio",
        DOCUMENT: "document",
        CHANNEL: "channel",
        COLLECTION: "collection",
        GROUP: "group"
      };
    }
    TeacherTube.prototype.parse = function(url, params) {
      var result = {};
      result.list = this.parsePlaylist(params);
      result.params = params;
      var match = url.match(/\/(audio|video|document|user\/channel|collection|group)\/(?:[\w-]+-)?(\w+)/);
      if (!match) {
        return void 0;
      }
      result.mediaType = this.parseMediaType(match[1]);
      result.id = match[2];
      return result;
    };
    TeacherTube.prototype.parsePlaylist = function(params) {
      if (params["playlist-id"]) {
        var list2 = params["playlist-id"];
        delete params["playlist-id"];
        return list2;
      }
      return void 0;
    };
    TeacherTube.prototype.parseMediaType = function(mediaTypeMatch) {
      switch (mediaTypeMatch) {
        case "audio":
          return this.mediaTypes.AUDIO;
        case "video":
          return this.mediaTypes.VIDEO;
        case "document":
          return this.mediaTypes.DOCUMENT;
        case "user/channel":
          return this.mediaTypes.CHANNEL;
        case "collection":
          return this.mediaTypes.COLLECTION;
        case "group":
          return this.mediaTypes.GROUP;
      }
    };
    TeacherTube.prototype.createLongUrl = function(vi, params) {
      if (!vi.id) {
        return void 0;
      }
      var url = "https://www.teachertube.com/";
      if (vi.list) {
        params["playlist-id"] = vi.list;
      }
      if (vi.mediaType === this.mediaTypes.CHANNEL) {
        url += "user/channel/";
      } else {
        url += vi.mediaType + "/";
      }
      url += vi.id;
      url += combineParams$a(params);
      return url;
    };
    TeacherTube.prototype.createEmbedUrl = function(vi, params) {
      if (!vi.id) {
        return void 0;
      }
      var url = "https://www.teachertube.com/embed/";
      if (vi.mediaType === this.mediaTypes.VIDEO || vi.mediaType === this.mediaTypes.AUDIO) {
        url += vi.mediaType + "/" + vi.id;
      } else {
        return void 0;
      }
      url += combineParams$a(params);
      return url;
    };
    base.bind(new TeacherTube());
    var combineParams$b = util.combineParams;
    function TikTok() {
      this.provider = "tiktok";
      this.defaultFormat = "long";
      this.formats = {
        "long": this.createLongUrl
      };
      this.mediaTypes = {
        VIDEO: "video"
      };
    }
    TikTok.prototype.parse = function(url, params) {
      var result = {
        params,
        mediaType: this.mediaTypes.VIDEO
      };
      var match = url.match(/@([^/]+)\/video\/(\d{19})/);
      if (!match) {
        return;
      }
      result.channel = match[1];
      result.id = match[2];
      return result;
    };
    TikTok.prototype.createLongUrl = function(vi, params) {
      var url = "";
      if (vi.mediaType === this.mediaTypes.VIDEO && vi.id && vi.channel) {
        url += "https://www.tiktok.com/@".concat(vi.channel, "/video/").concat(vi.id);
      } else {
        return void 0;
      }
      url += combineParams$b(params);
      return url;
    };
    base.bind(new TikTok());
    var combineParams$c = util.combineParams;
    function Ted() {
      this.provider = "ted";
      this.formats = {
        "long": this.createLongUrl,
        embed: this.createEmbedUrl
      };
      this.mediaTypes = {
        VIDEO: "video",
        PLAYLIST: "playlist"
      };
    }
    Ted.prototype.parseUrl = function(url, result) {
      var match = url.match(/\/(talks|playlists\/(\d+))\/([\w-]+)/);
      var channel = match ? match[1] : void 0;
      if (!channel) {
        return result;
      }
      result.channel = channel.split("/")[0];
      result.id = match[3];
      if (result.channel === "playlists") {
        result.list = match[2];
      }
      return result;
    };
    Ted.prototype.parseMediaType = function(result) {
      if (result.id && result.channel === "playlists") {
        delete result.channel;
        result.mediaType = this.mediaTypes.PLAYLIST;
      }
      if (result.id && result.channel === "talks") {
        delete result.channel;
        result.mediaType = this.mediaTypes.VIDEO;
      }
      return result;
    };
    Ted.prototype.parse = function(url, params) {
      var result = {
        params
      };
      result = this.parseUrl(url, result);
      result = this.parseMediaType(result);
      if (!result.id) {
        return void 0;
      }
      return result;
    };
    Ted.prototype.createLongUrl = function(vi, params) {
      var url = "";
      if (vi.mediaType === this.mediaTypes.VIDEO && vi.id) {
        url += "https://ted.com/talks/" + vi.id;
      } else if (vi.mediaType === this.mediaTypes.PLAYLIST && vi.id) {
        url += "https://ted.com/playlists/" + vi.list + "/" + vi.id;
      } else {
        return void 0;
      }
      url += combineParams$c(params);
      return url;
    };
    Ted.prototype.createEmbedUrl = function(vi, params) {
      var url = "https://embed.ted.com/";
      if (vi.mediaType === this.mediaTypes.PLAYLIST && vi.id) {
        url += "playlists/" + vi.list + "/" + vi.id;
      } else if (vi.mediaType === this.mediaTypes.VIDEO && vi.id) {
        url += "talks/" + vi.id;
      } else {
        return void 0;
      }
      url += combineParams$c(params);
      return url;
    };
    base.bind(new Ted());
    var lib = base;
    return lib;
  });
})(jsVideoUrlParser);
var urlParser = jsVideoUrlParser.exports;
var convertPasteText = {
  command: "convertPasteText",
  execute: async (editor, text2) => {
    const embedUrl = urlParser.create({
      videoInfo: urlParser.parse(text2),
      format: "embed",
      mediaType: "clip"
    });
    if (embedUrl) {
      const center2 = editor.viewport.center;
      const width2 = 300;
      const height2 = 200;
      editor.emit("newComponent", "iframe", {
        x: center2[0] - width2 / 2,
        y: center2[1] - height2 / 2,
        width: width2,
        height: height2,
        "background-color": "transparent",
        url: embedUrl
      });
    }
  }
};
var __glob_0_31$2 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": convertPasteText
});
function convertPath(editor, pathString2, rect2 = null) {
  var current = editor.selection.current;
  if (current) {
    if (current.is("svg-path", "svg-brush", "svg-textpath")) {
      var d = pathString2;
      if (rect2) {
        var parser2 = new PathParser(pathString2);
        parser2.scale(current.width / rect2.width, current.height / rect2.height);
        d = parser2.d;
      }
      editor.command("setAttributeForMulti", "set attribute -d", editor.selection.packByValue({ d }, current.id));
    } else if (current["clip-path"].includes("path")) {
      var d = pathString2;
      if (rect2) {
        var parser2 = new PathParser(pathString2);
        parser2.scale(current.width / rect2.width, current.height / rect2.height);
        d = parser2.d;
      }
      editor.command("setAttributeForMulti", "change clip path", editor.selection.packByValue({ "clip-path": `path(${d})` }, current.id));
    }
  }
}
var __glob_0_32$2 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": convertPath
});
var copy_path = {
  command: "copy.path",
  description: "copy as path for item with path string(d attribute)",
  execute: function(editor) {
    const current = editor.selection.current;
    if (current) {
      let newPath = PathParser.fromSVGString(current.d);
      try {
        const newLayerAttrs = current.toSVGPath();
        editor.command("addLayer", `copy path`, editor.createModel(__spreadValues(__spreadValues({
          itemType: "svg-path"
        }, newLayerAttrs), current.updatePath(newPath.d))), true, current.parent);
      } catch (e2) {
        console.error(e2);
      }
    }
  }
};
var __glob_0_33$2 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": copy_path
});
var copyTimelineProperty = {
  command: "copyTimelineProperty",
  execute: function(editor, layerId, property, newTime = null) {
    _currentProject(editor, (project2, timeline) => {
      project2.copyTimelineKeyframe(layerId, property, newTime);
      editor.emit("refreshTimeline");
    });
  }
};
var __glob_0_34$2 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": copyTimelineProperty
});
var deleteTimelineKeyframe = {
  command: "deleteTimelineKeyframe",
  execute: function(editor) {
    _currentProject(editor, (project2, timeline) => {
      editor.timeline.each((item2) => {
        project2.deleteTimelineKeyframe(item2.layerId, item2.property, item2.id);
      });
      editor.timeline.empty();
      editor.emit("refreshTimeline");
      editor.emit("refreshSelectedOffset");
    });
  }
};
var __glob_0_35$2 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": deleteTimelineKeyframe
});
var doubleclick_item = {
  command: "doubleclick.item",
  execute: function(editor, evt, id) {
    const item2 = editor.get(id);
    if (editor.selection.isOne && item2) {
      if (editor.selection.checkChildren(item2.id)) {
        editor.selection.select(item2);
        editor.emit("refreshSelection");
        editor.emit("refreshSelectionTool");
      }
      if (editor.selection.check(item2)) {
        editor.emit("open.editor");
        editor.emit("removeGuideLine");
      } else {
        this.selectInWorldPosition(editor, evt, item2);
      }
    } else {
      this.selectInWorldPosition(editor, evt, item2);
    }
  },
  selectInWorldPosition: function(editor, evt, item2) {
    const point2 = editor.viewport.getWorldPosition(evt);
    if (editor.selection.hasPoint(point2) || editor.selection.hasChildrenPoint(point2)) {
      editor.selection.select(item2);
      editor.snapManager.clear();
      editor.emit("refreshSelectionTool", true);
      editor.emit("history.refreshSelection");
    }
  }
};
var __glob_0_36$2 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": doubleclick_item
});
function downloadFile(datauri, filename = "easylogic.json") {
  var a = document.createElement("a");
  a.href = datauri;
  a.download = filename;
  a.click();
}
var downloadJSON = {
  command: "downloadJSON",
  execute: function(editor, filename) {
    var json = JSON.stringify(editor.modelManager.toJSON());
    var datauri = "data:application/json;base64," + window.btoa(unescape(encodeURIComponent(json)));
    downloadFile(datauri, filename || "easylogic.json");
  }
};
var __glob_0_37$2 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": downloadJSON
});
function createImagePng(img, callback, imageType = "image/png") {
  var canvas = Dom.create("canvas");
  var { width: width2, height: height2 } = img;
  canvas.resize({ width: width2, height: height2 });
  canvas.drawImage(img);
  callback && callback(canvas.toDataURL(imageType));
}
var ExportManager = {
  makeProjectStyle(item2) {
    const keyframeString = item2.toKeyframeString();
    const rootVariable = item2.toRootVariableCSS();
    return `
      :root {
        ${CSS_TO_STRING$1(rootVariable)}
      }
      /* keyframe */
      ${keyframeString}
    `;
  },
  makeStyle(item2, appendCSS = "") {
    if (item2.is("project")) {
      return this.makeProjectStyle(item2);
    }
    const cssString = item2.generateView(`[data-id='${item2.id}']`, appendCSS);
    return `
    ${cssString}
    ` + item2.layers.map((it) => {
      return this.makeStyle(it);
    }).join("");
  },
  makeSvg(project2) {
    const SVGString = project2.toSVGString ? project2.toSVGString() : "";
    return `
      ${SVGString ? `<svg width="0" height="0">${SVGString}</svg>` : ""}
    `;
  },
  generateSVG(editor, rootItem) {
    return editor.replaceLocalUrltoRealUrl(editor.svg.render(rootItem));
  }
};
var downloadPNG = {
  command: "downloadPNG",
  execute: function(editor, callbackCommand = "") {
    const item2 = editor.selection.current;
    if (item2) {
      const svgString = ExportManager.generateSVG(editor, item2).trim();
      const datauri = "data:image/svg+xml;base64," + window.btoa(svgString);
      const filename = item2.id;
      loadOriginalImage({ local: datauri }, (info, img) => {
        createImagePng(img, (pngDataUri) => {
          downloadFile(pngDataUri, filename);
          if (callbackCommand) {
            editor.emit(callbackCommand, pngDataUri);
          }
        });
      });
    }
  }
};
var __glob_0_38$2 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": downloadPNG
});
var downloadSVG = {
  command: "downloadSVG",
  execute: function(editor) {
    const item2 = editor.selection.current;
    if (item2) {
      var svgString = ExportManager.generateSVG(editor, item2).trim();
      var datauri = "data:image/svg+xml;base64," + window.btoa(svgString);
      var filename = item2.id;
      downloadFile(datauri, filename);
    }
  }
};
var __glob_0_39$2 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": downloadSVG
});
var drop_asset = {
  command: "drop.asset",
  execute: async function(editor, obj2, id = null) {
    if (obj2.color) {
      editor.emit("addBackgroundColor", obj2.color, id);
    } else if (obj2.gradient) {
      editor.emit("addBackgroundImageGradient", obj2.gradient, id);
    } else if (obj2.pattern) {
      editor.emit("addBackgroundImagePattern", obj2.pattern, id);
    } else if (obj2.imageUrl) {
      editor.emit("addBackgroundImageAsset", obj2.imageUrl, id);
    } else if (obj2.asset) {
      const assetData = await editor.storageManager.getCustomAsset(obj2.asset.id);
      if (assetData) {
        editor.emit("addArtBoard", assetData, obj2.asset.center);
      }
    }
    _doForceRefreshSelection(editor);
  }
};
var __glob_0_40$2 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": drop_asset
});
var dropImageUrl = {
  command: "dropImageUrl",
  execute: function(editor, imageUrl) {
    loadOriginalImage({ local: imageUrl }, (info) => {
      editor.emit("addImage", __spreadValues({ src: info.local }, info));
      editor.changeMode(EDIT_MODE_SELECTION);
    });
  }
};
var __glob_0_41$2 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": dropImageUrl
});
var editor_config_body_event = {
  command: "config:bodyEvent",
  description: "fire when bodyEvent was set",
  execute: function(editor) {
    const $target = Dom.create(editor.config.get("bodyEvent").target);
    editor.config.init("onMouseMovepageContainer", $target);
  }
};
var __glob_0_42$2 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": editor_config_body_event
});
var fileDropItems = {
  command: "fileDropItems",
  execute: function(editor, items = []) {
    editor.emit("updateResource", items);
  }
};
var __glob_0_43$2 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": fileDropItems
});
var firstTimelineItem = {
  command: "firstTimelineItem",
  execute: function(editor) {
    _currentProject(editor, (project2, timeline) => {
      var firstTime = project2.getSelectedTimelineFirstTime();
      project2.setTimelineCurrentTime(timecode(timeline.fps, firstTime));
      project2.seek();
      editor.emit("playTimeline");
      editor.changeMode("SELECTION");
      editor.emit("afterChangeMode");
    });
  }
};
var __glob_0_44$2 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": firstTimelineItem
});
var group_item$1 = {
  command: "group.item",
  execute: function(editor, opt = {}) {
    if (editor.selection.length === 0)
      return;
    const project2 = editor.selection.currentProject;
    if (project2) {
      project2.generateListNumber();
      const list2 = editor.selection.map((item2) => {
        return { depth: item2.depth, item: item2 };
      });
      list2.sort((a, b) => {
        if (a.depth === b.depth) {
          return a.no > b.no ? -1 : 1;
        }
        return a.depth > b.depth ? 1 : -1;
      });
      const groupLayer = editor.createModel(__spreadValues(__spreadValues({
        itemType: "rect"
      }, editor.selection.itemRect), opt));
      list2[0].item.appendAfter(groupLayer);
      list2.forEach(({ item: item2 }) => {
        groupLayer.appendChild(item2);
      });
      editor.selection.select(groupLayer);
      editor.emit("refreshAll");
    }
  }
};
var __glob_0_45$2 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": group_item$1
});
var history_addLayer = {
  command: "history.addLayer",
  description: "add layer in history ",
  execute: function(editor, message, layer2, isSelected = true, containerItem) {
    editor.emit("addLayer", layer2, isSelected, containerItem);
    editor.nextTick(() => {
      editor.history.add(message, this, {
        currentValues: [layer2, isSelected, containerItem],
        undoValues: [layer2.id]
      });
    });
    editor.nextTick(() => {
      editor.history.saveSelection();
    });
  },
  redo: function(editor, { currentValues }) {
    editor.emit("addLayer", ...currentValues);
    editor.nextTick(() => {
      editor.emit("refreshAll");
    });
  },
  undo: function(editor, { undoValues }) {
    const ids = undoValues;
    const items = editor.selection.itemsByIds(ids);
    items.forEach((item2) => {
      if (item2) {
        item2.remove();
      }
    });
    editor.nextTick(() => {
      editor.selection.empty();
      editor.emit("refreshAll");
    });
  }
};
var __glob_0_46$2 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": history_addLayer
});
var history_group_item = {
  command: "history.group.item",
  description: "History Group Item",
  execute: function(editor, message = "selection") {
    var _a;
    const currentValues = editor.selection.ids;
    const projectId = (_a = editor.selection.currentProject) == null ? void 0 : _a.id;
    const undoValues = editor.history.selectedIds;
    if (isArrayEquals(currentValues, undoValues)) {
      return;
    }
    editor.history.add(message, this, {
      currentValues: {
        ids: currentValues,
        projectId
      },
      undoValues: {
        ids: undoValues,
        projectId
      }
    });
  },
  redo: function(editor, { currentValues: [ids, projectId] }) {
  },
  undo: function(editor, { undoValues: [ids, projectId] }) {
  }
};
var __glob_0_47$2 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": history_group_item
});
var history_redo$1 = {
  command: "history.redo",
  execute: function(editor) {
    editor.history.redo();
  }
};
var __glob_0_48$2 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": history_redo$1
});
var history_refreshSelection = {
  command: "history.refreshSelection",
  description: `save selection in history `,
  description_ko: "Selection \uC815\uBCF4\uB97C \uAC31\uC2E0\uD558\uBA74\uC11C History \uC5D0 \uC800\uC7A5\uD55C\uB2E4",
  execute: function(editor, message = "selection") {
    var _a;
    const currentValues = editor.selection.ids;
    const projectId = (_a = editor.selection.currentProject) == null ? void 0 : _a.id;
    const undoValues = editor.history.selectedIds;
    if (isArrayEquals$1(currentValues, undoValues)) {
      return;
    }
    editor.history.add(message, this, {
      currentValues: [currentValues, projectId],
      undoValues: [undoValues, projectId]
    });
    this.nextAction(editor);
  },
  nextAction(editor) {
    editor.nextTick(() => {
      editor.history.saveSelection();
      editor.emit("refreshSelection");
      editor.nextTick(() => {
        editor.emit("refreshSelectionTool");
      });
    });
  },
  redo: function(editor, { currentValues: [ids, projectId] }) {
    editor.selection.selectProject(projectId);
    editor.selection.select(...ids);
    this.nextAction(editor);
  },
  undo: function(editor, { undoValues: [ids, projectId] }) {
    editor.selection.selectProject(projectId);
    editor.selection.select(...ids);
    this.nextAction(editor);
  }
};
var __glob_0_49$2 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": history_refreshSelection
});
var history_refreshSelectionProject = {
  command: "history.refreshSelectionPorject",
  description: `save project selection in history `,
  description_ko: "Project Selection \uC815\uBCF4\uB97C \uAC31\uC2E0\uD558\uBA74\uC11C History \uC5D0 \uC800\uC7A5\uD55C\uB2E4",
  execute: function(editor, message = "selection", projectId) {
    var _a;
    const currentValues = [projectId];
    const undoValues = [(_a = editor.selection.currentProject) == null ? void 0 : _a.id];
    if (isArrayEquals$1(currentValues, undoValues)) {
      return;
    }
    editor.selection.selectProject(projectId);
    editor.history.add(message, this, {
      currentValues,
      undoValues
    });
    this.nextAction(editor);
  },
  nextAction(editor) {
    editor.nextTick(() => {
      editor.emit("refreshAll");
      editor.emit("refreshProjectList");
    });
  },
  redo: function(editor, { currentValues: [projectId] }) {
    editor.selection.selectProject(projectId);
    this.nextAction(editor);
  },
  undo: function(editor, { undoValues: [projectId] }) {
    editor.selection.selectProject(projectId);
    this.nextAction(editor);
  }
};
var __glob_0_50$2 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": history_refreshSelectionProject
});
function filterChildren(items = []) {
  return items.filter((item2) => {
    let total = 0;
    item2.path.forEach((treeItem) => {
      total += items.filter((it) => it.id === treeItem.id).length ? 1 : 0;
    });
    return total === 1;
  });
}
var history_removeLayer = {
  command: "history.removeLayer",
  description: "remove layer",
  execute: function(editor, message, ids = void 0) {
    let items = editor.selection.itemsByIds(ids || editor.selection.ids);
    items = filterChildren(items);
    const filtedIds = items.map((it) => it.id);
    console.log(filtedIds);
    editor.modelManager.markRemove(filtedIds);
    const parentIds = items.map((it) => it.parentId);
    items.forEach((item2) => item2.remove());
    editor.history.add(message, this, {
      currentValues: [filtedIds, parentIds],
      undoValues: filtedIds
    });
    editor.nextTick(() => {
      editor.selection.removeById(filtedIds);
      const commandMaker = editor.createCommandMaker();
      commandMaker.emit("refreshAllElementBoundSize");
      commandMaker.emit("refreshAll");
      commandMaker.emit("removeGuideLine");
      parentIds.forEach((parentId) => {
        commandMaker.emit("update", parentId, { "changedChildren": true });
      });
      commandMaker.run();
      editor.nextTick(() => {
        editor.history.saveSelection();
      });
    });
  },
  redo: function(editor, { currentValues }) {
    const ids = currentValues[0];
    let items = editor.selection.itemsByIds(ids || editor.selection.ids);
    items = filterChildren(items);
    editor.modelManager.markRemove(items.map((it) => it.id));
    items.forEach((item2) => item2.remove());
    editor.nextTick(() => {
      editor.emit("refreshAll");
    });
  },
  undo: function(editor, { undoValues: recoverIds }) {
    editor.modelManager.unmarkRemove(recoverIds);
    editor.nextTick(() => {
      editor.emit("refreshAll");
    });
  }
};
var __glob_0_51$2 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": history_removeLayer
});
var history_removeProject = {
  command: "history.removeProject",
  description: "remove project",
  execute: function(editor, message, projectId) {
    const index2 = editor.modelManager.markRemoveProject(projectId);
    editor.history.add(message, this, {
      currentValues: [projectId],
      undoValues: [projectId, index2]
    });
    editor.nextTick(() => {
      editor.selection.selectProject(editor.modelManager.projects[0]);
      editor.emit("refreshAll");
      editor.emit("removeGuideLine");
      editor.nextTick(() => {
        editor.history.saveSelection();
      });
    });
  },
  redo: function(editor, { currentValues: [projectId] }) {
    editor.modelManager.markRemoveProject(projectId);
    editor.nextTick(() => {
      editor.emit("refreshAll");
    });
  },
  undo: function(editor, { undoValues: [projectId, index2] }) {
    editor.modelManager.unmarkRemoveProject(projectId, index2);
    editor.nextTick(() => {
      editor.selection.selectProject(projectId);
      editor.emit("refreshAll");
    });
  }
};
var __glob_0_52$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": history_removeProject
});
var history_setAttributeForMulti = {
  command: "history.setAttributeForMulti",
  execute: function(editor, message, multiAttrs = {}, context = { origin: "*" }) {
    editor.emit("setAttributeForMulti", multiAttrs, context);
    editor.history.add(message, this, {
      currentValues: [multiAttrs],
      undoValues: editor.history.getUndoValuesForMulti(multiAttrs)
    });
    editor.nextTick(() => {
      editor.history.saveSelection();
    });
  },
  redo: function(editor, { currentValues }) {
    editor.emit("setAttributeForMulti", ...currentValues);
    editor.nextTick(() => {
      editor.selection.reselect();
      editor.emit("refreshAll");
    });
  },
  undo: function(editor, { undoValues }) {
    const ids = Object.keys(undoValues);
    const items = editor.selection.itemsByIds(ids);
    items.forEach((item2) => {
      item2.reset(undoValues[item2.id]);
    });
    editor.selection.reselect();
    editor.nextTick(() => {
      editor.emit("refreshAll");
    });
  }
};
var __glob_0_53$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": history_setAttributeForMulti
});
var history_undo$1 = {
  command: "history.undo",
  execute: function(editor) {
    editor.history.undo();
  }
};
var __glob_0_54$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": history_undo$1
});
var item_move_depth_down$1 = {
  command: "item.move.depth.down",
  execute: function(editor) {
    const current = editor.selection.current;
    if (current) {
      current.orderPrev();
    }
    _doForceRefreshSelection(editor);
  }
};
var __glob_0_55$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": item_move_depth_down$1
});
var item_move_depth_first = {
  command: "item.move.depth.first",
  execute: function(editor) {
    const current = editor.selection.current;
    if (current) {
      current.orderFirst();
    }
    _doForceRefreshSelection(editor);
  }
};
var __glob_0_56$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": item_move_depth_first
});
var item_move_depth_last = {
  command: "item.move.depth.last",
  execute: function(editor) {
    const current = editor.selection.current;
    if (current) {
      current.orderLast();
    }
    _doForceRefreshSelection(editor);
  }
};
var __glob_0_57$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": item_move_depth_last
});
var item_move_depth_up$1 = {
  command: "item.move.depth.up",
  execute: function(editor) {
    const current = editor.selection.current;
    if (current) {
      current.orderNext();
    }
    _doForceRefreshSelection(editor);
  }
};
var __glob_0_58$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": item_move_depth_up$1
});
var keymap_keydown = {
  command: "keymap.keydown",
  execute: function(editor, e2) {
    editor.keyboardManager.add(e2.code, e2.keyCode);
    editor.shortcuts.execute(e2, "keydown");
  }
};
var __glob_0_59$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": keymap_keydown
});
var keymap_keyup = {
  command: "keymap.keyup",
  execute: function(editor, e2) {
    editor.keyboardManager.remove(e2.key, e2.keyCode);
    editor.shortcuts.execute(e2, "keyup");
  }
};
var __glob_0_60$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": keymap_keyup
});
var lastTimelineItem = {
  command: "lastTimelineItem",
  execute: function(editor) {
    _currentProject(editor, (project2, timeline) => {
      var lastTime = project2.getSelectedTimelineLastTime();
      project2.setTimelineCurrentTime(timecode(timeline.fps, lastTime));
      project2.seek();
      editor.emit("playTimeline");
      editor.changeMode("SELECTION");
      editor.emit("afterChangeMode");
    });
  }
};
var __glob_0_61$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": lastTimelineItem
});
var load_json = {
  command: "load.json",
  execute: function(editor, json, context = { origin: "*" }) {
    editor.modelManager.load(json, context);
    _doForceRefreshSelection(editor);
  }
};
var __glob_0_62$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": load_json
});
var moveLayer = {
  command: "moveLayer",
  description: "move layer by keydown with matrix ",
  execute: function(editor, dx = 0, dy = 0) {
    editor.command("setAttributeForMulti", "item move down", editor.selection.packByValue({
      x: (item2) => item2.offsetX + dx,
      y: (item2) => item2.offsetY + dy
    }));
    editor.nextTick(() => {
      editor.selection.reselect();
      editor.emit("refreshAll");
    });
  }
};
var __glob_0_63$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": moveLayer
});
var moveLayerForItems = {
  command: "moveLayerForItems",
  description: "mova layer by multi items ",
  execute: function(editor, moveItems = []) {
    const itemsMap = {};
    moveItems.forEach((it) => {
      itemsMap[it.item.id] = {
        x: round$1(it.item.offsetX + it.dist[0]),
        y: round$1(it.item.offsetY + it.dist[1])
      };
    });
    editor.emit("history.setAttributeForMulti", "item move down", itemsMap);
    editor.nextTick(() => {
      editor.selection.reselect();
      editor.emit("refreshAll");
    });
  }
};
var __glob_0_64$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": moveLayerForItems
});
var moveSelectionToCenter = {
  command: "moveSelectionToCenter",
  description: "Move selection project or artboards to center on Viewport",
  execute: function(editor, withScale = true) {
    let areaVerties = [];
    if (editor.selection.isEmpty) {
      if (editor.selection.currentProject.layers.length > 0) {
        areaVerties = itemsToRectVerties(editor.selection.currentProject.layers);
      } else {
        areaVerties = rectToVerties(0, 0, 100, 100);
      }
    } else {
      areaVerties = itemsToRectVerties(editor.selection.items);
    }
    editor.emit("moveToCenter", areaVerties, withScale);
  }
};
var __glob_0_65$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": moveSelectionToCenter
});
var moveToCenter = {
  command: "moveToCenter",
  description: "Move Layer to Center on Viewport",
  execute: function(editor, areaVerties, withScale = false) {
    if (areaVerties) {
      editor.viewport.moveLayerToCenter(areaVerties, withScale ? -0.2 : 0, withScale);
    }
  }
};
var __glob_0_66$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": moveToCenter
});
function newComponent(editor, itemType, obj2, isSelected = true, containerItem = void 0) {
  if (itemType === "svg-textpath") {
    obj2 = __spreadProps(__spreadValues({}, obj2), {
      "font-size": obj2.height,
      textLength: "100%",
      d: PathParser.makeLine(0, obj2.height, obj2.width, obj2.height).d
    });
  } else if (itemType === "svg-circle") {
    itemType = "svg-path";
    obj2 = __spreadProps(__spreadValues({}, obj2), {
      "background-color": void 0,
      fill: `#C4C4C4`,
      d: PathParser.makeCircle(0, 0, obj2.width, obj2.height).d
    });
  } else if (itemType === "svg-rect") {
    itemType = "svg-path";
    obj2 = __spreadProps(__spreadValues({}, obj2), {
      "background-color": void 0,
      fill: `#C4C4C4`,
      d: PathParser.makeRect(0, 0, obj2.width, obj2.height).d
    });
  } else if (itemType === "text") {
    obj2 = __spreadValues({
      width: 300,
      height: 50
    }, obj2);
  } else if (itemType === "artboard") {
    obj2 = __spreadProps(__spreadValues({}, obj2), {
      "background-color": "white"
    });
  }
  const newObjAttrs = __spreadValues({ itemType }, obj2);
  editor.command("addLayer", `add layer - ${itemType}`, editor.createModel(newObjAttrs), isSelected, containerItem);
  editor.changeMode(EDIT_MODE_SELECTION);
}
var __glob_0_67$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": newComponent
});
var nextTimelineItem = {
  command: "nextTimelineItem",
  execute: function(editor) {
    _currentProject(editor, (project2, timeline) => {
      var nextTime = project2.getSelectedTimelineNextTime();
      project2.setTimelineCurrentTime(timecode(timeline.fps, nextTime));
      project2.seek();
      editor.emit("playTimeline");
      editor.changeMode("SELECTION");
      editor.emit("afterChangeMode");
    });
  }
};
var __glob_0_68$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": nextTimelineItem
});
var open_editor = {
  command: "open.editor",
  description: "Open custom editor for item  when doubleclick is fired",
  execute: function(editor, current) {
    if (!current && editor.selection.isOne === false)
      return;
    current = current || editor.selection.current;
    if (current) {
      if (current.editablePath) {
        editor.emit("showPathEditor", "modify", {
          box: "canvas",
          current,
          matrix: current.matrix,
          isControl: true,
          disableCurve: true,
          d: current.editablePath,
          changeEvent: (data) => {
            editor.command("setAttributeForMulti", "change editable path", editor.selection.packByValue(__spreadValues({}, current.recoverEditablePath(data.d)), [current.id]));
            editor.nextTick(() => {
              if (editor.isPointerUp) {
                editor.emit("recoverBooleanPath");
              }
            });
          }
        });
        editor.emit("hideSelectionToolView");
      } else if (current.d) {
        editor.emit("showPathEditor", "modify", {
          box: "canvas",
          current,
          matrix: current.matrix,
          d: current.absolutePath().d,
          changeEvent: (data) => {
            const newCurrent = editor.selection.current;
            if (newCurrent.isSVG() && newCurrent.isNot("svg-path")) {
              const newPathData = newCurrent.toSVGPath();
              const newPath = editor.createModel(__spreadValues({
                itemType: "svg-path"
              }, newPathData));
              editor.selection.select(newPath);
              newCurrent.appendAfter(newPath);
              editor.nextTick(() => {
                editor.emit("removeLayer", [newCurrent.id]);
                editor.emit("updatePathItem", data);
              });
            } else {
              editor.emit("updatePathItem", data);
              editor.nextTick(() => {
                if (editor.isPointerUp) {
                  editor.emit("recoverBooleanPath");
                }
              });
            }
          }
        });
        editor.emit("hideSelectionToolView");
      } else if (current["clip-path"]) {
        var obj2 = ClipPath.parseStyle(current["clip-path"]);
        if (obj2.type === "path") {
          var d = current.absolutePath(current.clipPathString).d;
          var mode = d ? "modify" : "path";
          editor.emit("showPathEditor", mode, {
            changeEvent: (data) => {
              const resultPath = current.invertPath(data.d).d;
              editor.command("setAttributeForMulti", "change clip-path", editor.selection.packByValue({
                "clip-path": `path(${resultPath})`
              }));
            },
            current,
            d
          });
          editor.emit("hideSelectionToolView");
        } else if (obj2.type === "svg")
          ;
        else {
          editor.emit("showClipPathPopup", {
            "clip-path": current["clip-path"],
            changeEvent: function(data) {
              editor.command("setAttributeForMulti", "change clip-path", editor.selection.packByValue(data));
            }
          });
        }
      } else
        ;
    }
  }
};
var __glob_0_69$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": open_editor
});
var pauseTimelineItem = {
  command: "pauseTimelineItem",
  execute: function(editor) {
    if (editor.timer) {
      editor.timer.stop();
    }
  }
};
var __glob_0_70$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": pauseTimelineItem
});
var playTimelineItem = {
  command: "playTimelineItem",
  description: "Play button action",
  execute: function(editor, speed2 = 1, iterationCount = 1, direction = "normal") {
    editor.selection.empty();
    editor.emit("refreshSelection");
    editor.changeMode("play");
    editor.emit("afterChangeMode");
    _currentProject(editor, (project2, timeline) => {
      var lastTime = project2.getSelectedTimelineLastTime();
      if (editor.timer) {
        editor.timer.stop();
      } else {
        editor.timer = makeTimer({
          elapsed: timeline.currentTime * 1e3,
          speed: speed2,
          duration: lastTime * 1e3,
          iterationCount,
          direction
        });
      }
      editor.timer.play({
        duration: lastTime * 1e3,
        elapsed: timeline.currentTime * 1e3,
        speed: speed2,
        iterationCount,
        direction,
        tick: (elapsed, timer2) => {
          project2.seek(timecode(timeline.fps, elapsed / 1e3));
          editor.emit("playTimeline");
        },
        last: (elapsed, timer2) => {
          project2.seek(timecode(timeline.fps, elapsed / 1e3));
          editor.emit("playTimeline");
          editor.nextTick(() => {
            editor.emit("stopTimeline");
            editor.changeMode("SELECTION");
            editor.emit("afterChangeMode");
          });
        },
        stop: (elapsed, timer2) => {
          project2.stop(timecode(timeline.fps, elapsed / 1e3));
          editor.emit("stopTimeline");
          editor.changeMode("SELECTION");
          editor.emit("afterChangeMode");
        }
      });
    });
  }
};
var __glob_0_71$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": playTimelineItem
});
var pop_mode_view = {
  command: "pop.mode.view",
  execute: function(editor, modeView = void 0) {
    editor.modeViewManager.popMode(modeView);
  }
};
var __glob_0_72$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": pop_mode_view
});
var prevTimelineItem = {
  command: "prevTimelineItem",
  execute: function(editor) {
    _currentProject(editor, (project2, timeline) => {
      var prevTime = project2.getSelectedTimelinePrevTime();
      project2.setTimelineCurrentTime(timecode(timeline.fps, prevTime));
      project2.seek();
      editor.emit("playTimeline");
      editor.changeMode("SELECTION");
      editor.emit("afterChangeMode");
    });
  }
};
var __glob_0_73$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": prevTimelineItem
});
var push_mode_view = {
  command: "push.mode.view",
  execute: function(editor, modeView = "CanvasView") {
    editor.modeViewManager.pushMode(modeView);
  }
};
var __glob_0_74$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": push_mode_view
});
var recoverBooleanPath = {
  command: "recoverBooleanPath",
  description: "recover box rectangle for boolean path result",
  execute: function(editor) {
    const current = editor.selection.current;
    let booleanContainer;
    if (current && current.isBooleanItem) {
      booleanContainer = current.parent;
    } else if (current && current.is("boolean-path")) {
      booleanContainer = current;
    }
    if (booleanContainer) {
      const isBooleanItem = typeof current.isBooleanItem === "boolean" && current.isBooleanItem;
      const booleanPath = booleanContainer.d;
      if (!booleanPath) {
        return;
      }
      const layersCache = booleanContainer.layers.map((it) => {
        return {
          item: it,
          matrix: it.matrix
        };
      });
      const newBooleanContainerRect = booleanContainer.updatePath(booleanPath);
      delete newBooleanContainerRect.d;
      booleanContainer.reset(newBooleanContainerRect);
      layersCache.forEach((it) => {
        booleanContainer.resetMatrix(it.item);
      });
      const ids = [...layersCache.map((it) => it.item.id), booleanContainer.id];
      const data = editor.selection.packByIds(ids, "x", "y", "width", "height");
      editor.command("setAttributeForMulti", "fit boolean path", data, { origin: "*", doNotChildrenScale: isBooleanItem });
    }
  }
};
var __glob_0_75$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": recoverBooleanPath
});
var recoverCursor = {
  command: "recoverCursor",
  execute: function(editor) {
    editor.emit("changeIconView", "auto");
  }
};
var __glob_0_76$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": recoverCursor
});
function refreshArtboard(editor) {
  editor.emit("refreshLayerTreeView");
  editor.emit("refreshAllCanvas");
  editor.emit("refreshStyleView");
  editor.emit("refreshSelectionStyleView");
  editor.emit("refreshAllElementBoundSize");
  editor.emit("refreshSelection");
  editor.nextTick(() => {
    editor.emit("refreshSelectionTool", true);
  });
}
var __glob_0_77$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": refreshArtboard
});
var refreshCursor = {
  command: "refreshCursor",
  execute: function(editor, iconType, ...args2) {
    editor.emit("changeIconView", iconType, ...args2);
  }
};
var __glob_0_78$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": refreshCursor
});
function refreshElement(editor, current) {
  editor.emit("refreshSelectionStyleView", current);
  if (current.isLayoutItem() || current.parent.is("boolean-path")) {
    editor.emit("refreshElementBoundSize", current.parent);
  } else {
    editor.emit("refreshElementBoundSize", current);
  }
}
var __glob_0_79$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": refreshElement
});
function refreshHistory(editor) {
  editor.emit("saveJSON");
}
var __glob_0_80$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": refreshHistory
});
function refreshProject(editor, current) {
  editor.emit("refreshStyleView", current, true);
}
var __glob_0_81$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": refreshProject
});
var refreshSelectedOffset = {
  command: "refreshSelectedOffset",
  execute: function(editor) {
    var offset = editor.timeline.items[0];
    if (offset) {
      editor.emit("refreshOffsetValue", offset);
    }
  }
};
var __glob_0_82$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": refreshSelectedOffset
});
var removeAnimationItem = {
  command: "removeAnimationItem",
  execute: function(editor, id) {
    const project2 = editor.selection.currentProject;
    if (project2) {
      project2.removeAnimationItem(id);
      editor.timeline.empty();
      editor.emit("refreshTimeline");
      editor.emit("removeAnimation");
    }
  }
};
var __glob_0_83$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": removeAnimationItem
});
var removeLayer$1 = {
  command: "removeLayer",
  execute: function(editor, ids = void 0) {
    const currentIds = ids || editor.selection.ids;
    const removedIds = [];
    editor.selection.itemsByIds(currentIds).forEach((item2) => {
      removedIds.push(item2.id);
      item2.remove();
    });
    editor.selection.removeById(removedIds);
    editor.nextTick(() => {
      editor.emit("refreshAll");
    });
  }
};
var __glob_0_84$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": removeLayer$1
});
var removeTimeline = {
  command: "removeTimeline",
  execute: function(editor, layerId) {
    const project2 = editor.selection.currentProject;
    if (project2) {
      project2.removeTimeline(layerId);
      editor.timeline.empty();
      editor.emit("refreshTimeline");
      editor.emit("refreshSelectedOffset");
    }
  }
};
var __glob_0_85$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": removeTimeline
});
var removeTimelineProperty = {
  command: "removeTimelineProperty",
  execute: function(editor, layerId, property) {
    const project2 = editor.selection.currentProject;
    if (project2) {
      project2.removeTimelineProperty(layerId, property);
      editor.timeline.empty();
      editor.emit("refreshTimeline");
      editor.emit("refreshSelectedOffset");
    }
  }
};
var __glob_0_86$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": removeTimelineProperty
});
function resetSelection(editor) {
  editor.nextTick(() => {
    editor.emit("refreshSelectionTool");
  });
}
var __glob_0_87$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": resetSelection
});
function resizeArtBoard(editor, size2 = "") {
  var current = editor.selection.current;
  if (current && current.is("artboard")) {
    if (!size2.trim())
      return;
    var [width2, height2] = size2.split("x");
    width2 = +width2;
    height2 = +height2;
    current.reset({ width: width2, height: height2 });
    editor.selection.select(current);
    _doForceRefreshSelection(editor);
  }
}
var __glob_0_88$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": resizeArtBoard
});
var rotateLayer = {
  command: "rotateLayer",
  description: "rotate layer by keydown with matrix ",
  execute: function(editor, distAngle = 0) {
    editor.command("setAttributeForMulti", "change rotate", editor.selection.packByValue({
      transform: (item2) => Transform.addTransform(item2.transform, `rotateZ(${Length.deg(distAngle).round(1e3)})`)
    }));
    editor.nextTick(() => {
      editor.selection.reselect();
      editor.emit("refreshAll");
    });
  }
};
var __glob_0_89$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": rotateLayer
});
var same_height$1 = {
  command: "same.height",
  description: "fit at the same height",
  execute: function(editor) {
    var len2 = editor.selection.length;
    if (len2 == 1)
      ;
    else if (len2 > 1) {
      const rect2 = vertiesToRectangle(editor.selection.verties);
      editor.command("setAttributeForMulti", "fit at the same height", editor.selection.packByValue({
        y: rect2.y,
        height: rect2.height
      }));
    }
  }
};
var __glob_0_90$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": same_height$1
});
var same_width$1 = {
  command: "same.width",
  description: "fit at the same width",
  execute: function(editor) {
    if (editor.selection.isMany) {
      const rect2 = vertiesToRectangle(editor.selection.verties);
      editor.command("setAttributeForMulti", "fit at the same width", editor.selection.packByValue({
        x: rect2.x,
        width: rect2.width
      }));
    }
  }
};
var __glob_0_91$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": same_width$1
});
var saveJSON = {
  command: "saveJSON",
  execute: function(editor) {
    editor.saveItem("model", editor.modelManager.toJSON());
  }
};
var __glob_0_92$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": saveJSON
});
var savePNG = {
  command: "savePNG",
  execute: function(editor, callbackCommand = "") {
    const item2 = editor.selection.current;
    if (item2) {
      const svgString = ExportManager.generateSVG(editor, item2).trim();
      const datauri = "data:image/svg+xml;base64," + window.btoa(svgString);
      loadOriginalImage({ local: datauri }, (info, img) => {
        createImagePng(img, (pngDataUri) => {
          if (callbackCommand) {
            editor.emit(callbackCommand, pngDataUri);
          }
        });
      });
    }
  }
};
var __glob_0_93$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": savePNG
});
var segment_delete$1 = {
  command: "segment.delete",
  execute: function(editor, current) {
    editor.emit("deleteSegment");
  }
};
var __glob_0_94$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": segment_delete$1
});
var segment_move_down = {
  command: "segment.move.down",
  execute: function(editor, obj2 = { dy: 1 }) {
    const dy = +obj2.dy;
    editor.emit("moveSegment", 0, dy);
  }
};
var __glob_0_95$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": segment_move_down
});
var segment_move_left = {
  command: "segment.move.left",
  execute: function(editor, obj2 = { dx: 1 }) {
    const dx = +obj2.dx;
    editor.emit("moveSegment", -1 * dx, 0);
  }
};
var __glob_0_96$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": segment_move_left
});
var segment_move_right = {
  command: "segment.move.right",
  execute: function(editor, obj2 = { dx: 1 }) {
    const dx = +obj2.dx;
    editor.emit("moveSegment", dx, 0);
  }
};
var __glob_0_97$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": segment_move_right
});
var segment_move_up = {
  command: "segment.move.up",
  execute: function(editor, obj2 = { dy: 1 }) {
    const dy = +obj2.dy;
    editor.emit("moveSegment", 0, -1 * dy);
  }
};
var __glob_0_98$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": segment_move_up
});
var select_all$1 = {
  command: "select.all",
  execute: function(editor) {
    var project2 = editor.selection.currentProject;
    if (project2) {
      editor.selection.select(...project2.layers);
      editor.emit("history.refreshSelection");
    }
  }
};
var __glob_0_99$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": select_all$1
});
var selectTimelineItem = {
  command: "selectTimelineItem",
  execute: function(editor, selectedId) {
    const project2 = editor.selection.currentProject;
    if (project2) {
      project2.selectTimeline(selectedId);
      editor.emit("refreshTimeline");
      editor.emit("selectTimeline");
    }
  }
};
var __glob_0_100$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": selectTimelineItem
});
var setAttributeForMulti = {
  command: "setAttributeForMulti",
  execute: function(editor, multiAttrs = {}, context = { origin: "*" }) {
    const messages = [];
    Object.entries(multiAttrs).forEach(([id, attrs]) => {
      const item2 = editor.modelManager.get(id);
      const newAttrs = {};
      Object.entries(attrs).forEach(([key, value]) => {
        newAttrs[key] = isFunction(value) ? value(item2) : value;
      });
      messages.push({ id: item2.id, parentId: item2.parentId, attrs: newAttrs });
    });
    if (messages.length == 0) {
      return;
    }
    const commandMaker = editor.createCommandMaker();
    messages.forEach((message) => {
      commandMaker.emit("update", message.id, message.attrs, context);
      const item2 = editor.get(message.id);
      if (item2.is("artboard")) {
        return;
      }
      const parent = item2.parent;
      if (item2.isLayoutItem() || parent.is("boolean-path")) {
        const parent2 = editor.get(message.parentId);
        if (message.parentId && (parent2 == null ? void 0 : parent2.isNot("project")) && parent2.children.length >= 1) {
          commandMaker.emit("update", message.parentId, { "changedChildren": true }, context);
        }
      }
    });
    commandMaker.run();
  }
};
var __glob_0_101$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": setAttributeForMulti
});
var setEditorLayout = {
  command: "setEditorLayout",
  execute: function(editor, layout2) {
    editor.setLayout(layout2);
    editor.emit("changedEditorlayout");
  }
};
var __glob_0_102$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": setEditorLayout
});
var setLocale = {
  command: "setLocale",
  execute: function(editor, locale) {
    editor.setLocale(locale);
    editor.emit("changed.locale");
  }
};
var __glob_0_103$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": setLocale
});
var setTimelineOffset = {
  command: "setTimelineOffset",
  debounce: 100,
  execute: function(editor, obj2) {
    const project2 = editor.selection.currentProject;
    if (project2) {
      project2.setTimelineKeyframeOffsetValue(obj2.layerId, obj2.property, obj2.id, obj2.value, obj2.timing, obj2.time);
      editor.emit("refreshTimeline");
    }
  }
};
var __glob_0_104$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": setTimelineOffset
});
var showExportView = {
  command: "showExportView",
  execute: function(editor) {
    editor.emit("showExportWindow");
  }
};
var __glob_0_105$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": showExportView
});
var sort_bottom = {
  command: "sort.bottom",
  execute: function(editor) {
    if (editor.selection.isOne) {
      const current = editor.selection.current;
      if (current.parent.is("project"))
        ;
      else {
        const parent = current.parent;
        const distY = getVertiesMaxY(parent.verties) - getVertiesMaxY(editor.selection.verties);
        editor.emit("moveLayer", 0, distY);
      }
    } else if (editor.selection.isMany) {
      let maxRightY = getVertiesMaxY(editor.selection.verties);
      editor.emit("moveLayerForItems", editor.selection.map((item2) => {
        let itemRightY = getVertiesMaxY(item2.verties);
        return { item: item2, dist: [0, maxRightY - itemRightY, 0, 0] };
      }));
    }
  }
};
var __glob_0_106$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": sort_bottom
});
var sort_center = {
  command: "sort.center",
  execute: function(editor) {
    if (editor.selection.isOne) {
      const current = editor.selection.current;
      if (current.parent.is("project"))
        ;
      else if (current.artboard) {
        const distX = getVertiesCenterX(current.artboard.verties) - getVertiesCenterX(editor.selection.verties);
        editor.emit("moveLayer", distX, 0);
      }
    } else if (editor.selection.isMany) {
      let maxRightX = getVertiesCenterX(editor.selection.verties);
      editor.emit("moveLayerForItems", editor.selection.map((item2) => {
        let itemRightX = getVertiesCenterX(item2.verties);
        return { item: item2, dist: [maxRightX - itemRightX, 0, 0] };
      }));
    }
  }
};
var __glob_0_107$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": sort_center
});
var sort_left = {
  command: "sort.left",
  execute: function(editor) {
    if (editor.selection.isOne) {
      const current = editor.selection.current;
      if (current.parent.is("project"))
        ;
      else {
        const parent = current.parent;
        const distX = getVertiesMinX(parent.verties) - getVertiesMinX(editor.selection.verties);
        editor.emit("moveLayer", distX, 0);
      }
    } else if (editor.selection.isMany) {
      let maxRightX = getVertiesMinX(editor.selection.verties);
      editor.emit("moveLayerForItems", editor.selection.map((item2) => {
        let itemRightX = getVertiesMinX(item2.verties);
        return { item: item2, dist: [maxRightX - itemRightX, 0, 0] };
      }));
    }
  }
};
var __glob_0_108$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": sort_left
});
var sort_middle = {
  command: "sort.middle",
  execute: function(editor) {
    if (editor.selection.isOne) {
      const current = editor.selection.current;
      if (current.parent.is("project"))
        ;
      else if (current.artboard) {
        const distY = getVertiesCenterY(current.artboard.verties) - getVertiesCenterY(editor.selection.verties);
        editor.emit("moveLayer", 0, distY);
      }
    } else if (editor.selection.isMany) {
      let maxRightY = getVertiesCenterY(editor.selection.verties);
      editor.emit("moveLayerForItems", editor.selection.map((item2) => {
        let itemRightY = getVertiesCenterY(item2.verties);
        return { item: item2, dist: [0, maxRightY - itemRightY, 0, 0] };
      }));
    }
  }
};
var __glob_0_109$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": sort_middle
});
var sort_right = {
  command: "sort.right",
  execute: function(editor) {
    if (editor.selection.isOne) {
      const current = editor.selection.current;
      if (current.parent.is("project"))
        ;
      else {
        const parent = current.parent;
        const distX = getVertiesMaxX(parent.verties) - getVertiesMaxX(editor.selection.verties);
        editor.emit("moveLayer", distX, 0);
      }
    } else if (editor.selection.isMany) {
      let maxRightX = getVertiesMaxX(editor.selection.verties);
      editor.emit("moveLayerForItems", editor.selection.map((item2) => {
        let itemRightX = getVertiesMaxX(item2.verties);
        return { item: item2, dist: [maxRightX - itemRightX, 0, 0] };
      }));
    }
  }
};
var __glob_0_110$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": sort_right
});
var sort_top = {
  command: "sort.top",
  execute: function(editor) {
    if (editor.selection.isOne) {
      const current = editor.selection.current;
      if (current.parent.is("project"))
        ;
      else {
        const parent = current.parent;
        const distY = getVertiesMinY(parent.verties) - getVertiesMinY(editor.selection.verties);
        editor.emit("moveLayer", 0, distY);
      }
    } else if (editor.selection.isMany) {
      let maxRightY = getVertiesMinY(editor.selection.verties);
      editor.emit("moveLayerForItems", editor.selection.map((item2) => {
        let itemRightY = getVertiesMinY(item2.verties);
        return { item: item2, dist: [0, maxRightY - itemRightY, 0, 0] };
      }));
    }
  }
};
var __glob_0_111$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": sort_top
});
var switch_path = {
  command: "switch.path",
  execute: async (editor, text2) => {
    const current = editor.selection.current;
    if (!current)
      return;
    if (current.is("boolean-path") || current.isBooleanItem) {
      let parent = current;
      if (current.isBooleanItem) {
        parent = current.parent;
      }
      editor.selection.select(parent);
      editor.command("setAttributeForMulti", "change boolean operation", editor.selection.packByValue({
        "boolean-operation": parent["boolean-operation"],
        children: parent.children.reverse()
      }));
      editor.nextTick(() => {
        editor.emit("recoverBooleanPath");
        editor.selection.select(current);
        editor.emit("refreshSelection");
        editor.emit("refreshSelectionTool");
      });
    }
  }
};
var __glob_0_112$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": switch_path
});
var toggle_tool_hand = {
  command: "toggleToolHand",
  execute: function(editor) {
    editor.config.toggle("set.tool.hand");
  }
};
var __glob_0_113$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": toggle_tool_hand
});
var ungroup_item$1 = {
  command: "ungroup.item",
  execute: function(editor) {
    if (editor.selection.length === 0)
      return;
    const current = editor.selection.current;
    if (current) {
      let groupLayer = current;
      let layers2 = [...groupLayer.layers];
      layers2.reverse();
      layers2.forEach((child) => {
        groupLayer.appendBefore(child);
      });
      editor.selection.select(...layers2);
      editor.emit("refreshAll");
    }
  }
};
var __glob_0_114$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": ungroup_item$1
});
var updateClipPath = {
  command: "updateClipPath",
  description: "update clip-path property ",
  execute: function(editor, pathObject) {
    editor.command("setAttributeForMulti", "change clip-path", editor.selection.packByValue({
      "clip-path": `path(${pathObject.d})`
    }));
  }
};
var __glob_0_115$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": updateClipPath
});
var updateImage = {
  command: "updateImage",
  execute: function(editor, imageFileOrBlob, rect2, containerItem) {
    var reader = new FileReader();
    reader.onload = (e2) => {
      var datauri = e2.target.result;
      var local = URL.createObjectURL(imageFileOrBlob);
      editor.emit("addImageAssetItem", {
        id: uuidShort$1(),
        type: imageFileOrBlob.type,
        name: imageFileOrBlob.name,
        original: datauri,
        local
      }, rect2, containerItem);
    };
    reader.readAsDataURL(imageFileOrBlob);
  }
};
var __glob_0_116$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": updateImage
});
var updateImageAssetItem = {
  command: "updateImageAssetItem",
  execute: function(editor, item2, callback) {
    var reader = new FileReader();
    reader.onload = (e2) => {
      var datauri = e2.target.result;
      var local = URL.createObjectURL(item2);
      var project2 = editor.selection.currentProject;
      if (project2) {
        const image2 = project2.createImage({
          id: uuidShort$1(),
          type: item2.type,
          name: item2.name,
          original: datauri,
          local
        });
        editor.emit("addImageAsset");
        isFunction(callback) && callback(image2.id);
      }
    };
    reader.readAsDataURL(item2);
  }
};
var __glob_0_117$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": updateImageAssetItem
});
var updatePathItem = {
  command: "updatePathItem",
  description: "Update path string for selected svg path item",
  execute: function(editor, pathObject) {
    const current = editor.selection.current;
    if (current) {
      if (pathObject.box === "box") {
        const newPath = current.invertPath(pathObject.d);
        editor.command("setAttributeForMulti", "change local path", editor.selection.packByValue({
          d: newPath.d
        }));
      } else {
        const newPath = new PathParser(pathObject.d);
        newPath.transformMat4(pathObject.matrix.absoluteMatrixInverse);
        let bbox = newPath.getBBox();
        const newWidth = distance$1(bbox[1], bbox[0]);
        const newHeight = distance$1(bbox[3], bbox[0]);
        let oldBBox = vertiesMap(rectToVerties(bbox[0][0], bbox[0][1], newWidth, newHeight), pathObject.matrix.absoluteMatrix);
        let newBBox = vertiesMap(oldBBox, calculateMatrixInverse(fromTranslation([], oldBBox[4]), Transform.createTransformMatrix(Transform.parseStyle(pathObject.matrix.transform), newWidth, newHeight), fromTranslation([], negate([], oldBBox[4]))));
        const worldMatrix = calculateMatrix(fromTranslation([], newBBox[0]), current.getLocalTransformMatrix(newWidth, newHeight));
        const realXY = getTranslation([], calculateMatrix(pathObject.matrix.parentMatrixInverse, worldMatrix, invert([], current.getLocalTransformMatrix(newWidth, newHeight))));
        editor.command("setAttributeForMulti", "change path", editor.selection.packByValue({
          d: newPath.translate(-bbox[0][0], -bbox[0][1]).d,
          x: realXY[0],
          y: realXY[1],
          width: newWidth,
          height: newHeight
        }));
      }
    }
  }
};
var __glob_0_118$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": updatePathItem
});
var updateResource = {
  command: "updateResource",
  execute: function(editor, items) {
    items.forEach((item2) => {
      switch (item2.type) {
        case "image/svg+xml":
        case "image/png":
        case "image/gif":
        case "image/jpg":
        case "image/jpeg":
          editor.emit("updateImage", item2);
          break;
        case "text/plain":
        case "text/html":
          editor.emit("addText", {
            content: item2.data
          });
          break;
        case "text/uri-list":
          editor.emit("updateUriList", item2);
          break;
      }
    });
  }
};
var __glob_0_119$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": updateResource
});
var updateScale = {
  command: "updateScale",
  execute: function(editor, scale2) {
    const oldScale = editor.viewport.scale;
    editor.viewport.setScale(scale2);
    editor.emit("updateViewport", scale2, oldScale);
  }
};
var __glob_0_120$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": updateScale
});
class AssetParser {
  static parse(datauri, enableParselocal = false) {
    var [_, data] = datauri.split("data:");
    var [mediaType, ...content2] = data.split(",");
    var [mimeType, encoding] = mediaType.split(";");
    content2 = content2.join(",");
    return {
      mimeType,
      local: enableParselocal && AssetParser.getLink(mimeType, encoding, content2)
    };
  }
  static getLink(mimeType, encoding, content2) {
    if (encoding === "base64") {
      var binary = atob(content2);
      var len2 = binary.length;
      var unit8Array = new Uint8Array(len2);
      for (var i = 0; i < len2; i++) {
        unit8Array[i] = binary.charCodeAt(i);
      }
      var blob = new Blob([unit8Array], { type: mimeType });
      return URL.createObjectURL(blob);
    }
    return "";
  }
}
var updateUriList = {
  command: "updateUriList",
  execute: function(editor, item2) {
    var datauri = item2.data;
    if (datauri.indexOf("data:") > -1) {
      var info = AssetParser.parse(datauri, true);
      switch (info.mimeType) {
        case "image/png":
        case "image/gif":
        case "image/jpg":
        case "image/jpeg":
          editor.emit("addImageAssetItem", {
            id: uuidShort$1(),
            type: info.mimeType,
            name: "",
            original: datauri,
            local: info.local
          });
          break;
      }
    } else {
      var ext = item2.data.split(".").pop();
      var name2 = item2.data.split("/").pop();
      switch (ext) {
        case "png":
        case "jpg":
        case "gif":
        case "svg":
          editor.emit("addImageAssetItem", {
            id: uuidShort$1(),
            type: "image/" + ext,
            name: name2,
            original: item2.data,
            local: item2.data
          });
          break;
      }
    }
  }
};
var __glob_0_121$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": updateUriList
});
var updateVideo = {
  command: "updateVideo",
  execute: function(editor, item2, rect2, containerItem = void 0) {
    var reader = new FileReader();
    reader.onload = (e2) => {
      var datauri = e2.target.result;
      var local = URL.createObjectURL(item2);
      editor.emit("addVideoAssetItem", {
        id: uuidShort$1(),
        type: item2.type,
        name: item2.name,
        original: datauri,
        local
      }, rect2, containerItem);
    };
    reader.readAsDataURL(item2);
  }
};
var __glob_0_122$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": updateVideo
});
var updateVideoAssetItem = {
  command: "updateVideoAssetItem",
  execute: function(editor, item2, callback) {
    var reader = new FileReader();
    reader.onload = (e2) => {
      var datauri = e2.target.result;
      var local = URL.createObjectURL(item2);
      var project2 = editor.selection.currentProject;
      if (project2) {
        project2.createVideo({
          id: uuidShort$1(),
          type: item2.type,
          name: item2.name,
          original: datauri,
          local
        });
        editor.emit("addVideoAsset");
        isFunction(callback) && callback(local);
      }
    };
    reader.readAsDataURL(item2);
  }
};
var __glob_0_123$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": updateVideoAssetItem
});
var zoom_default$1 = {
  command: "zoom.default",
  execute: function(editor) {
    editor.viewport.zoomDefault();
  }
};
var __glob_0_124$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": zoom_default$1
});
var zoom_in$1 = {
  command: "zoom.in",
  execute: function(editor) {
    editor.viewport.zoomIn(0.02);
  }
};
var __glob_0_125$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": zoom_in$1
});
var zoom_out$1 = {
  command: "zoom.out",
  execute: function(editor) {
    editor.viewport.zoomOut(0.02);
  }
};
var __glob_0_126$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": zoom_out$1
});
var update = {
  command: "update",
  description: "Update the model",
  execute: function(editor, id = null, attrs = {}, context = { origin: "*" }) {
    const item2 = editor.modelManager.get(id);
    if (item2) {
      const isChanged = item2.reset(attrs, context);
      if (isChanged) {
        editor.emit("refreshElement", item2);
      }
    }
  }
};
var __glob_0_127$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": update
});
const modules$4 = { "./command_list/_currentProject.js": __glob_0_0$4, "./command_list/_doForceRefreshSelection.js": __glob_0_1$4, "./command_list/addArtBoard.js": __glob_0_2$4, "./command_list/addBackgroundColor.js": __glob_0_3$4, "./command_list/addBackgroundImageAsset.js": __glob_0_4$4, "./command_list/addBackgroundImageGradient.js": __glob_0_5$4, "./command_list/addBackgroundImagePattern.js": __glob_0_6$4, "./command_list/addCustomComponent.js": __glob_0_7$4, "./command_list/addImage.js": __glob_0_8$4, "./command_list/addImageAssetItem.js": __glob_0_9$4, "./command_list/addLayer.js": __glob_0_10$4, "./command_list/addLayerView.js": __glob_0_11$4, "./command_list/addProject.js": __glob_0_12$4, "./command_list/addSVGFilterAssetItem.js": __glob_0_13$4, "./command_list/addText.js": __glob_0_14$4, "./command_list/addTimelineCurrentProperty.js": __glob_0_15$4, "./command_list/addTimelineItem.js": __glob_0_16$4, "./command_list/addTimelineKeyframe.js": __glob_0_17$4, "./command_list/addTimelineProperty.js": __glob_0_18$4, "./command_list/addVideo.js": __glob_0_19$4, "./command_list/addVideoAssetItem.js": __glob_0_20$4, "./command_list/clipboard.copy.js": __glob_0_21$3, "./command_list/clipboard.paste.js": __glob_0_22$3, "./command_list/convert.flatten.path.js": __glob_0_23$3, "./command_list/convert.no.transform.path.js": __glob_0_24$2, "./command_list/convert.normalize.path.js": __glob_0_25$2, "./command_list/convert.path.operation.js": __glob_0_26$2, "./command_list/convert.polygonal.path.js": __glob_0_27$2, "./command_list/convert.simplify.path.js": __glob_0_28$2, "./command_list/convert.smooth.path.js": __glob_0_29$2, "./command_list/convert.stroke.to.path.js": __glob_0_30$2, "./command_list/convertPasteText.js": __glob_0_31$2, "./command_list/convertPath.js": __glob_0_32$2, "./command_list/copy.path.js": __glob_0_33$2, "./command_list/copyTimelineProperty.js": __glob_0_34$2, "./command_list/deleteTimelineKeyframe.js": __glob_0_35$2, "./command_list/doubleclick.item.js": __glob_0_36$2, "./command_list/downloadJSON.js": __glob_0_37$2, "./command_list/downloadPNG.js": __glob_0_38$2, "./command_list/downloadSVG.js": __glob_0_39$2, "./command_list/drop.asset.js": __glob_0_40$2, "./command_list/dropImageUrl.js": __glob_0_41$2, "./command_list/editor.config.body.event.js": __glob_0_42$2, "./command_list/fileDropItems.js": __glob_0_43$2, "./command_list/firstTimelineItem.js": __glob_0_44$2, "./command_list/group.item.js": __glob_0_45$2, "./command_list/history.addLayer.js": __glob_0_46$2, "./command_list/history.group.item.js": __glob_0_47$2, "./command_list/history.redo.js": __glob_0_48$2, "./command_list/history.refreshSelection.js": __glob_0_49$2, "./command_list/history.refreshSelectionProject.js": __glob_0_50$2, "./command_list/history.removeLayer.js": __glob_0_51$2, "./command_list/history.removeProject.js": __glob_0_52$1, "./command_list/history.setAttributeForMulti.js": __glob_0_53$1, "./command_list/history.undo.js": __glob_0_54$1, "./command_list/item.move.depth.down.js": __glob_0_55$1, "./command_list/item.move.depth.first.js": __glob_0_56$1, "./command_list/item.move.depth.last.js": __glob_0_57$1, "./command_list/item.move.depth.up.js": __glob_0_58$1, "./command_list/keymap.keydown.js": __glob_0_59$1, "./command_list/keymap.keyup.js": __glob_0_60$1, "./command_list/lastTimelineItem.js": __glob_0_61$1, "./command_list/load.json.js": __glob_0_62$1, "./command_list/moveLayer.js": __glob_0_63$1, "./command_list/moveLayerForItems.js": __glob_0_64$1, "./command_list/moveSelectionToCenter.js": __glob_0_65$1, "./command_list/moveToCenter.js": __glob_0_66$1, "./command_list/newComponent.js": __glob_0_67$1, "./command_list/nextTimelineItem.js": __glob_0_68$1, "./command_list/open.editor.js": __glob_0_69$1, "./command_list/pauseTimelineItem.js": __glob_0_70$1, "./command_list/playTimelineItem.js": __glob_0_71$1, "./command_list/pop.mode.view.js": __glob_0_72$1, "./command_list/prevTimelineItem.js": __glob_0_73$1, "./command_list/push.mode.view.js": __glob_0_74$1, "./command_list/recoverBooleanPath.js": __glob_0_75$1, "./command_list/recoverCursor.js": __glob_0_76$1, "./command_list/refreshArtboard.js": __glob_0_77$1, "./command_list/refreshCursor.js": __glob_0_78$1, "./command_list/refreshElement.js": __glob_0_79$1, "./command_list/refreshHistory.js": __glob_0_80$1, "./command_list/refreshProject.js": __glob_0_81$1, "./command_list/refreshSelectedOffset.js": __glob_0_82$1, "./command_list/removeAnimationItem.js": __glob_0_83$1, "./command_list/removeLayer.js": __glob_0_84$1, "./command_list/removeTimeline.js": __glob_0_85$1, "./command_list/removeTimelineProperty.js": __glob_0_86$1, "./command_list/resetSelection.js": __glob_0_87$1, "./command_list/resizeArtBoard.js": __glob_0_88$1, "./command_list/rotateLayer.js": __glob_0_89$1, "./command_list/same.height.js": __glob_0_90$1, "./command_list/same.width.js": __glob_0_91$1, "./command_list/saveJSON.js": __glob_0_92$1, "./command_list/savePNG.js": __glob_0_93$1, "./command_list/segment.delete.js": __glob_0_94$1, "./command_list/segment.move.down.js": __glob_0_95$1, "./command_list/segment.move.left.js": __glob_0_96$1, "./command_list/segment.move.right.js": __glob_0_97$1, "./command_list/segment.move.up.js": __glob_0_98$1, "./command_list/select.all.js": __glob_0_99$1, "./command_list/selectTimelineItem.js": __glob_0_100$1, "./command_list/setAttributeForMulti.js": __glob_0_101$1, "./command_list/setEditorLayout.js": __glob_0_102$1, "./command_list/setLocale.js": __glob_0_103$1, "./command_list/setTimelineOffset.js": __glob_0_104$1, "./command_list/showExportView.js": __glob_0_105$1, "./command_list/sort.bottom.js": __glob_0_106$1, "./command_list/sort.center.js": __glob_0_107$1, "./command_list/sort.left.js": __glob_0_108$1, "./command_list/sort.middle.js": __glob_0_109$1, "./command_list/sort.right.js": __glob_0_110$1, "./command_list/sort.top.js": __glob_0_111$1, "./command_list/switch.path.js": __glob_0_112$1, "./command_list/toggle.tool.hand.js": __glob_0_113$1, "./command_list/ungroup.item.js": __glob_0_114$1, "./command_list/updateClipPath.js": __glob_0_115$1, "./command_list/updateImage.js": __glob_0_116$1, "./command_list/updateImageAssetItem.js": __glob_0_117$1, "./command_list/updatePathItem.js": __glob_0_118$1, "./command_list/updateResource.js": __glob_0_119$1, "./command_list/updateScale.js": __glob_0_120$1, "./command_list/updateUriList.js": __glob_0_121$1, "./command_list/updateVideo.js": __glob_0_122$1, "./command_list/updateVideoAssetItem.js": __glob_0_123$1, "./command_list/zoom.default.js": __glob_0_124$1, "./command_list/zoom.in.js": __glob_0_125$1, "./command_list/zoom.out.js": __glob_0_126$1, "./command_list/model/update.js": __glob_0_127$1 };
const obj$1 = {};
Object.entries(modules$4).forEach(([key, value]) => {
  key = key.replace("./command_list/", "").replace(".js", "");
  obj$1[key] = value.default;
});
class CommandManager {
  constructor(editor) {
    this.$editor = editor;
    this.promiseProxy = this.localCommands = {};
    this.loadCommands();
    return new Proxy(this, {
      get: (target, key) => {
        var originMethod = target[key];
        if (isFunction(originMethod)) {
          return (...args2) => {
            return originMethod.apply(target, args2);
          };
        } else {
          return this.makePromiseEvent(key);
        }
      }
    });
  }
  loadCommands() {
    Object.keys(obj$1).forEach((command) => {
      if (isFunction(obj$1[command])) {
        this.registerCommand(command, obj$1[command]);
      } else {
        this.registerCommand(obj$1[command]);
      }
    });
  }
  registerCommand(command, commandCallback) {
    if (this.localCommands[command]) {
      throw new Error(`command ${command} is already registered`);
    }
    if (arguments.length === 2) {
      const callback = (...args2) => {
        const result = commandCallback.call(this, this.$editor, ...args2);
        this.$editor.debug("command execute", this, ...args2);
        return result;
      };
      callback.source = command;
      this.localCommands[command] = callback;
      return this.$editor.on(command, callback, this, 0);
    } else if (isObject(command)) {
      const callback = (...args2) => {
        const result = command.execute.call(command, this.$editor, ...args2);
        this.$editor.debug("command execute", command, ...args2);
        return result;
      };
      callback.source = command.command;
      this.localCommands[command.command] = callback;
      return this.$editor.on(command.command, callback, command, command.debounce || 0);
    }
  }
  getCallback(command) {
    return this.localCommands[command];
  }
  makePromiseEvent(command) {
    const callback = this.getCallback(command);
    if (callback) {
      return (...args2) => new Promise((resolve) => {
        resolve(callback(...args2));
      });
    }
  }
}
let osInfo = {
  name: void 0
};
function os() {
  if (osInfo.name === void 0) {
    if (navigator.appVersion.indexOf("Win") != -1)
      osInfo.name = "win";
    else if (navigator.appVersion.indexOf("Mac") != -1)
      osInfo.name = "mac";
    else if (navigator.appVersion.indexOf("X11") != -1)
      osInfo.name = "linux";
    else
      osInfo.name = "";
  }
  return osInfo.name;
}
var add_artboard = {
  category: "Tool",
  key: "a",
  command: "addLayerView",
  args: ["artboard"],
  description: "Add ArtBoard",
  when: "CanvasView"
};
var __glob_0_0$3 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": add_artboard
});
var add_brush = {
  category: "Tool",
  key: "b",
  command: "addLayerView",
  args: ["brush"],
  description: "Draw SVG Path"
};
var __glob_0_1$3 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": add_brush
});
var add_circle$1 = {
  category: "Tool",
  key: "o",
  command: "addLayerView",
  args: ["circle"],
  description: "Add circle layer"
};
var __glob_0_2$3 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": add_circle$1
});
var add_circle_l = {
  category: "Tool",
  key: "l",
  command: "addLayerView",
  args: ["circle"],
  description: "Add circle layer"
};
var __glob_0_3$3 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": add_circle_l
});
var add_path = {
  category: "Tool",
  key: "p",
  command: "addLayerView",
  args: ["path"],
  description: "Add SVG Path layer"
};
var __glob_0_4$3 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": add_path
});
var add_rect = {
  category: "Tool",
  key: "r",
  command: "addLayerView",
  args: ["rect"],
  description: "Add rect layer"
};
var __glob_0_5$3 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": add_rect
});
var add_rect_m = {
  category: "Tool",
  key: "m",
  command: "addLayerView",
  args: ["rect"],
  description: "Add rect layer"
};
var __glob_0_6$3 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": add_rect_m
});
var add_text = {
  category: "Tool",
  key: "t",
  command: "addLayerView",
  args: ["text"],
  description: "Add text layer"
};
var __glob_0_7$3 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": add_text
});
var clipboard_copy = {
  category: "Edit",
  key: "cmd+c",
  command: "clipboard.copy",
  description: "Copy objects",
  when: "CanvasView"
};
var __glob_0_8$3 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": clipboard_copy
});
var clipboard_paste = {
  category: "Edit",
  key: "cmd+v",
  win: "ctrl+v",
  command: "clipboard.paste",
  description: "Paste selected objects",
  when: "CanvasView"
};
var __glob_0_9$3 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": clipboard_paste
});
var group_item = {
  category: "Group",
  key: "cmd+g",
  win: "ctrl+g",
  command: "group.item",
  description: "Grouping selected items",
  when: "CanvasView"
};
var __glob_0_10$3 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": group_item
});
var history_redo = {
  category: "History",
  key: "cmd+shift+z",
  win: "ctrl+shift+z",
  command: "history.redo",
  description: "redoing in history",
  when: "CanvasView"
};
var __glob_0_11$3 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": history_redo
});
var history_undo = {
  category: "History",
  key: "cmd+z",
  win: "ctrl+z",
  command: "history.undo",
  description: "undoing in history",
  when: "CanvasView"
};
var __glob_0_12$3 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": history_undo
});
var item_move_alt_down = {
  category: "Layer",
  key: "Alt+ArrowDown",
  command: "moveLayer",
  description: "move 5px to down",
  args: [0, 5],
  when: "CanvasView"
};
var __glob_0_13$3 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": item_move_alt_down
});
var item_move_alt_left = {
  category: "Layer",
  key: "Alt+ArrowLeft",
  command: "moveLayer",
  description: "move 5px to left",
  args: [-5, 0],
  when: "CanvasView"
};
var __glob_0_14$3 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": item_move_alt_left
});
var item_move_alt_right = {
  category: "Layer",
  key: "Alt+ArrowRight",
  command: "moveLayer",
  description: "move 5px to right",
  args: [5, 0],
  when: "CanvasView"
};
var __glob_0_15$3 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": item_move_alt_right
});
var item_move_alt_up = {
  category: "Layer",
  key: "Alt+ArrowUp",
  command: "moveLayer",
  description: "move 5px to up",
  args: [0, -5],
  when: "CanvasView"
};
var __glob_0_16$3 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": item_move_alt_up
});
var item_move_depth_down = {
  category: "Layer",
  key: "ctrl+[",
  command: "item.move.depth.down",
  description: "move layer to below",
  when: "CanvasView"
};
var __glob_0_17$3 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": item_move_depth_down
});
var item_move_depth_up = {
  category: "Layer",
  key: "ctrl+]",
  command: "item.move.depth.up",
  description: "move layer to above",
  when: "CanvasView"
};
var __glob_0_18$3 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": item_move_depth_up
});
var item_move_key_down = {
  category: "Layer",
  key: "ArrowDown",
  command: "moveLayer",
  description: "move 1px to down",
  args: [0, 1],
  when: "CanvasView"
};
var __glob_0_19$3 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": item_move_key_down
});
var item_move_key_left = {
  category: "Layer",
  key: "ArrowLeft",
  command: "moveLayer",
  description: "move 1px to left",
  args: [-1, 0],
  when: "CanvasView"
};
var __glob_0_20$3 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": item_move_key_left
});
var item_move_key_right = {
  category: "Layer",
  key: "ArrowRight",
  command: "moveLayer",
  description: "move 1px to right",
  args: [1, 0],
  when: "CanvasView"
};
var __glob_0_21$2 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": item_move_key_right
});
var item_move_key_up = {
  category: "Layer",
  key: "ArrowUp",
  command: "moveLayer",
  description: "move 1px to up",
  args: [0, -1],
  when: "CanvasView"
};
var __glob_0_22$2 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": item_move_key_up
});
var item_move_shift_down = {
  category: "Layer",
  key: "Shift+ArrowDown",
  command: "moveLayer",
  description: "move 10px to down",
  args: [0, 10],
  when: "CanvasView"
};
var __glob_0_23$2 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": item_move_shift_down
});
var item_move_shift_left = {
  category: "Layer",
  key: "Shift+ArrowLeft",
  command: "moveLayer",
  description: "move 10px to left",
  args: [-10, 0],
  when: "CanvasView"
};
var __glob_0_24$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": item_move_shift_left
});
var item_move_shift_right = {
  category: "Layer",
  key: "Shift+ArrowRight",
  command: "moveLayer",
  description: "move 10px to right",
  args: [10, 0],
  when: "CanvasView"
};
var __glob_0_25$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": item_move_shift_right
});
var item_move_shift_up = {
  category: "Layer",
  key: "Shift+ArrowUp",
  command: "moveLayer",
  description: "move 10px to up",
  args: [0, -10],
  when: "CanvasView"
};
var __glob_0_26$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": item_move_shift_up
});
var item_rotate_meta_left = {
  category: "Layer",
  key: "Meta+ArrowLeft",
  command: "rotateLayer",
  description: "rotate to left",
  args: [-5],
  when: "CanvasView"
};
var __glob_0_27$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": item_rotate_meta_left
});
var item_rotate_meta_right = {
  category: "Layer",
  key: "Meta+ArrowRight",
  command: "rotateLayer",
  description: "rotate to right",
  args: [5],
  when: "CanvasView"
};
var __glob_0_28$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": item_rotate_meta_right
});
var removeLayer = {
  category: "Layer",
  key: "Backspace",
  command: "history.removeLayer",
  description: "Delete selected items",
  args: ["Delete selected items"],
  when: "CanvasView"
};
var __glob_0_29$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": removeLayer
});
var removeLayerByDeleteKey = {
  category: "Layer",
  key: "Delete",
  command: "history.removeLayer",
  description: "Delete selected items",
  args: ["Delete selected items"],
  when: "CanvasView"
};
var __glob_0_30$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": removeLayerByDeleteKey
});
var segment_delete = {
  category: "Path",
  key: "Backspace",
  command: "segment.delete",
  description: "Delete selected segment",
  when: "PathEditorView"
};
var __glob_0_31$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": segment_delete
});
var segment_move_alt_down = {
  category: "Path",
  key: "Alt+ArrowDown",
  command: "segment.move.down",
  description: "move 5px to down",
  args: [{ dy: 5 }],
  when: "PathEditorView"
};
var __glob_0_32$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": segment_move_alt_down
});
var segment_move_alt_left = {
  category: "Path",
  key: "Alt+ArrowLeft",
  command: "segment.move.left",
  description: "move 5px to left",
  args: [{ dx: 5 }],
  when: "PathEditorView"
};
var __glob_0_33$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": segment_move_alt_left
});
var segment_move_alt_right = {
  category: "Path",
  key: "Alt+ArrowRight",
  command: "segment.move.right",
  description: "move 5px to right",
  args: [{ dx: 5 }],
  when: "PathEditorView"
};
var __glob_0_34$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": segment_move_alt_right
});
var segment_move_alt_up = {
  category: "Path",
  key: "Alt+ArrowUp",
  command: "segment.move.up",
  description: "move 5px to up ",
  args: [{ dy: 5 }],
  when: "PathEditorView"
};
var __glob_0_35$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": segment_move_alt_up
});
var segment_move_key_down = {
  category: "Path",
  key: "ArrowDown",
  command: "segment.move.down",
  description: "move 1px to down",
  args: [{ dy: 1 }],
  when: "PathEditorView"
};
var __glob_0_36$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": segment_move_key_down
});
var segment_move_key_left = {
  category: "Path",
  key: "ArrowLeft",
  command: "segment.move.left",
  description: "move 1px to left",
  args: [{ dx: 1 }],
  when: "PathEditorView"
};
var __glob_0_37$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": segment_move_key_left
});
var segment_move_key_right = {
  category: "Path",
  key: "ArrowRight",
  command: "segment.move.right",
  description: "move 1px to right",
  args: [{ dx: 1 }],
  when: "PathEditorView"
};
var __glob_0_38$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": segment_move_key_right
});
var segment_move_key_up = {
  category: "Path",
  key: "ArrowUp",
  command: "segment.move.up",
  description: "move 1px to up",
  args: [{ dy: 1 }],
  when: "PathEditorView"
};
var __glob_0_39$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": segment_move_key_up
});
var segment_move_shift_down = {
  category: "Path",
  key: "Shift+ArrowDown",
  command: "segment.move.down",
  description: "move 10px to down",
  args: [{ dy: 10 }],
  when: "PathEditorView"
};
var __glob_0_40$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": segment_move_shift_down
});
var segment_move_shift_left = {
  category: "Path",
  key: "Shift+ArrowLeft",
  command: "segment.move.left",
  description: "move 10px to left",
  args: [{ dx: 10 }],
  when: "PathEditorView"
};
var __glob_0_41$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": segment_move_shift_left
});
var segment_move_shift_right = {
  category: "Path",
  key: "Shift+ArrowRight",
  command: "segment.move.right",
  description: "move 10px to right",
  args: [{ dx: 10 }],
  when: "PathEditorView"
};
var __glob_0_42$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": segment_move_shift_right
});
var segment_move_shift_up = {
  category: "Path",
  key: "Shift+ArrowUp",
  command: "segment.move.up",
  description: "move 10px to up",
  args: [{ dy: 10 }],
  when: "PathEditorView"
};
var __glob_0_43$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": segment_move_shift_up
});
var select_all = {
  category: "Tool",
  key: "CMD+A",
  win: "CTRL+A",
  command: "select.all",
  description: "Selection all layers"
};
var __glob_0_44$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": select_all
});
var select_view = {
  category: "Tool",
  key: "v",
  command: "addLayerView",
  args: "select",
  description: "Selection"
};
var __glob_0_45$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": select_view
});
var set_tool_hand$1 = {
  category: "Tools",
  key: "h",
  command: "toggleToolHand",
  description: "set hand tool on",
  when: "CanvasView"
};
var __glob_0_46$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": set_tool_hand$1
});
var show_pan = {
  category: "Tool",
  key: "space",
  command: "showPan",
  description: "Show panning area"
};
var __glob_0_47$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": show_pan
});
var ungroup_item = {
  category: "Group",
  key: "shift+cmd+g",
  win: "shift+ctrl+g",
  command: "ungroup.item",
  description: "Ungrouping selected group layer",
  when: "CanvasView"
};
var __glob_0_48$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": ungroup_item
});
var zoom_default = {
  category: "View",
  key: "0",
  command: "zoom.default",
  description: "zoom by scale 1",
  when: "CanvasView"
};
var __glob_0_49$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": zoom_default
});
var zoom_in = {
  category: "View",
  key: "Equal",
  command: "zoom.in",
  description: "zoom in",
  when: "CanvasView"
};
var __glob_0_50$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": zoom_in
});
var zoom_out = {
  category: "View",
  key: "minus",
  command: "zoom.out",
  description: "zoom Out",
  when: "CanvasView"
};
var __glob_0_51$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": zoom_out
});
const modules$3 = { "./shortcuts_list/add.artboard.js": __glob_0_0$3, "./shortcuts_list/add.brush.js": __glob_0_1$3, "./shortcuts_list/add.circle.js": __glob_0_2$3, "./shortcuts_list/add.circle.l.js": __glob_0_3$3, "./shortcuts_list/add.path.js": __glob_0_4$3, "./shortcuts_list/add.rect.js": __glob_0_5$3, "./shortcuts_list/add.rect.m.js": __glob_0_6$3, "./shortcuts_list/add.text.js": __glob_0_7$3, "./shortcuts_list/clipboard.copy.js": __glob_0_8$3, "./shortcuts_list/clipboard.paste.js": __glob_0_9$3, "./shortcuts_list/group.item.js": __glob_0_10$3, "./shortcuts_list/history.redo.js": __glob_0_11$3, "./shortcuts_list/history.undo.js": __glob_0_12$3, "./shortcuts_list/item.move.alt.down.js": __glob_0_13$3, "./shortcuts_list/item.move.alt.left.js": __glob_0_14$3, "./shortcuts_list/item.move.alt.right.js": __glob_0_15$3, "./shortcuts_list/item.move.alt.up.js": __glob_0_16$3, "./shortcuts_list/item.move.depth.down.js": __glob_0_17$3, "./shortcuts_list/item.move.depth.up.js": __glob_0_18$3, "./shortcuts_list/item.move.key.down.js": __glob_0_19$3, "./shortcuts_list/item.move.key.left.js": __glob_0_20$3, "./shortcuts_list/item.move.key.right.js": __glob_0_21$2, "./shortcuts_list/item.move.key.up.js": __glob_0_22$2, "./shortcuts_list/item.move.shift.down.js": __glob_0_23$2, "./shortcuts_list/item.move.shift.left.js": __glob_0_24$1, "./shortcuts_list/item.move.shift.right.js": __glob_0_25$1, "./shortcuts_list/item.move.shift.up.js": __glob_0_26$1, "./shortcuts_list/item.rotate.meta.left.js": __glob_0_27$1, "./shortcuts_list/item.rotate.meta.right.js": __glob_0_28$1, "./shortcuts_list/removeLayer.js": __glob_0_29$1, "./shortcuts_list/removeLayerByDeleteKey.js": __glob_0_30$1, "./shortcuts_list/segment.delete.js": __glob_0_31$1, "./shortcuts_list/segment.move.alt.down.js": __glob_0_32$1, "./shortcuts_list/segment.move.alt.left.js": __glob_0_33$1, "./shortcuts_list/segment.move.alt.right.js": __glob_0_34$1, "./shortcuts_list/segment.move.alt.up.js": __glob_0_35$1, "./shortcuts_list/segment.move.key.down.js": __glob_0_36$1, "./shortcuts_list/segment.move.key.left.js": __glob_0_37$1, "./shortcuts_list/segment.move.key.right.js": __glob_0_38$1, "./shortcuts_list/segment.move.key.up.js": __glob_0_39$1, "./shortcuts_list/segment.move.shift.down.js": __glob_0_40$1, "./shortcuts_list/segment.move.shift.left.js": __glob_0_41$1, "./shortcuts_list/segment.move.shift.right.js": __glob_0_42$1, "./shortcuts_list/segment.move.shift.up.js": __glob_0_43$1, "./shortcuts_list/select.all.js": __glob_0_44$1, "./shortcuts_list/select.view.js": __glob_0_45$1, "./shortcuts_list/set.tool.hand.js": __glob_0_46$1, "./shortcuts_list/show.pan.js": __glob_0_47$1, "./shortcuts_list/ungroup.item.js": __glob_0_48$1, "./shortcuts_list/zoom.default.js": __glob_0_49$1, "./shortcuts_list/zoom.in.js": __glob_0_50$1, "./shortcuts_list/zoom.out.js": __glob_0_51$1 };
var shortcuts = Object.values(modules$3).map((it) => it.default);
const KEY_CODE = {
  "backspace": 8,
  "tab": 9,
  "enter": 13,
  "escape": 27,
  "space": 32,
  "pageup": 33,
  "pagedown": 34,
  "end": 35,
  "home": 36,
  "left": 37,
  "up": 38,
  "right": 39,
  "down": 40,
  "insert": 45,
  "delete": 46,
  "0": 48,
  "1": 49,
  "2": 50,
  "3": 51,
  "4": 52,
  "5": 53,
  "6": 54,
  "7": 55,
  "8": 56,
  "9": 57,
  "semicolon": 59,
  "equals": 61,
  "a": 65,
  "b": 66,
  "c": 67,
  "d": 68,
  "e": 69,
  "f": 70,
  "g": 71,
  "h": 72,
  "i": 73,
  "j": 74,
  "k": 75,
  "l": 76,
  "m": 77,
  "n": 78,
  "o": 79,
  "p": 80,
  "q": 81,
  "r": 82,
  "s": 83,
  "t": 84,
  "u": 85,
  "v": 86,
  "w": 87,
  "x": 88,
  "y": 89,
  "z": 90,
  "multiply": 106,
  "add": 107,
  "subtract": 109,
  "divide": 111,
  "f1": 112,
  "f2": 113,
  "f3": 114,
  "f4": 115,
  "f5": 116,
  "f6": 117,
  "f7": 118,
  "f8": 119,
  "f9": 120,
  "f10": 121,
  "f11": 122,
  "f12": 123,
  "f13": 124,
  "f14": 125,
  "f15": 126,
  "f16": 127,
  "f17": 128,
  "f18": 129,
  "f19": 130,
  "comma": 188,
  ",": 188,
  "period": 190,
  ".": 190,
  "slash": 191,
  "/": 191,
  "backquote": 192,
  "`": 192,
  "openbracket": 219,
  "[": 219,
  "backslash": 220,
  "\\": 220,
  "closebracket": 221,
  "]": 221,
  "quote": 222,
  "'": 222,
  "altgr": 225
};
const keyAlias$1 = {
  "ARROWRIGHT": "\u2192",
  "ARROWLEFT": "\u2190",
  "ARROWUP": "\u2191",
  "ARROWDOWN": "\u2192",
  "BACKSPACE": "\u232B",
  "CMD": "\u2318",
  "SHIFT": "\u21E7",
  "CTRL": "\u2303",
  "ALT": "\u2325",
  "ENTER": "\u21B5",
  "ESC": "\u238B",
  "TAB": "\u21E5",
  "SPACE": "\u2423",
  "CAPSLOCK": "\u21EA",
  "DELETE": "\u2326",
  "INSERT": "\u2324",
  "HOME": "\u21F1",
  "END": "\u21F2",
  "PAGEUP": "\u21DE",
  "PAGEDOWN": "\u21DF",
  "PRINTSCREEN": "\u2399",
  "SCROLLLOCK": "\u21DE",
  "PAUSE": "\u23CF",
  "NUMLOCK": "\u21EA",
  "META": "\u2318",
  "WINDOWS": "\u2318",
  "CONTEXTMENU": "\u2325",
  "COMMAND": "\u2318"
};
const OSName$1 = os();
const KeyStringMaker = (item2, os2 = OSName$1) => {
  return (item2[os2] || item2.key).split("+").map((it) => it.trim()).map((it) => {
    const keyString = it.toUpperCase();
    return keyAlias$1[keyString] || keyString;
  }).join(" ");
};
function joinKeys(...args2) {
  return args2.filter(Boolean).join("+");
}
function generateKeyCode(code2) {
  return KEY_CODE[`${code2}`.toLowerCase()] || code2;
}
class ShortCutManager {
  constructor(editor) {
    this.$editor = editor;
    this.loadShortCuts();
  }
  getGeneratedKeyCode(code2) {
    return generateKeyCode(code2);
  }
  loadShortCuts() {
    this.list = [];
    this.commands = {};
    shortcuts.forEach((shortcut) => {
      this.registerShortCut(shortcut);
    });
    this.sort();
  }
  registerShortCut(shortcut) {
    const OSName2 = os();
    this.list.push(__spreadProps(__spreadValues({
      key: "",
      command: "",
      args: [],
      eventType: "keydown"
    }, shortcut), {
      checkKeyString: this.splitShortCut(shortcut[OSName2] || shortcut.key),
      whenFunction: this.makeWhenFunction(shortcut.command, shortcut.when || true)
    }));
    this.sort();
  }
  makeWhenFunction(command, when) {
    if (isBoolean(when) && when) {
      return () => true;
    }
    const editor = this.$editor;
    const whenList = when.split("|").map((it) => it.trim());
    return () => {
      return whenList.some((it) => editor.modeViewManager.isCurrentMode(it));
    };
  }
  sort() {
    this.commands = {};
    this.list.forEach((it) => {
      if (Array.isArray(this.commands[it.checkKeyString]) === false) {
        this.commands[it.checkKeyString] = [];
      }
      this.commands[it.checkKeyString].push(it);
    });
  }
  splitShortCut(key) {
    var arr = key.toUpperCase().split("+").map((it) => it.trim()).filter(Boolean);
    let isAlt = false;
    let isControl = false;
    let isShift = false;
    let isMeta = false;
    let restKeys = [];
    arr.forEach((key2) => {
      if (key2.includes("ALT"))
        isAlt = true;
      else if (key2.includes("CTRL"))
        isControl = true;
      else if (key2.includes("SHIFT"))
        isShift = true;
      else if (key2.includes("CMD") || key2.includes("WIN") || key2.includes("META"))
        isMeta = true;
      else
        restKeys.push(key2);
    });
    return joinKeys(isAlt ? "ALT" : "", isControl ? "CTRL" : "", isShift ? "SHIFT" : "", isMeta ? "META" : "", generateKeyCode(restKeys.join("")));
  }
  makeKeyString(e2) {
    return joinKeys(e2.altKey ? "ALT" : "", e2.ctrlKey ? "CTRL" : "", e2.shiftKey ? "SHIFT" : "", e2.metaKey ? "META" : "", e2.key.toUpperCase());
  }
  makeCodeString(e2) {
    return joinKeys(e2.altKey ? "ALT" : "", e2.ctrlKey ? "CTRL" : "", e2.shiftKey ? "SHIFT" : "", e2.metaKey ? "META" : "", e2.code.toUpperCase());
  }
  makeKeyCodeString(e2) {
    return joinKeys(e2.altKey ? "ALT" : "", e2.ctrlKey ? "CTRL" : "", e2.shiftKey ? "SHIFT" : "", e2.metaKey ? "META" : "", e2.keyCode);
  }
  checkShortCut(keyCodeString, keyString, codeString) {
    return this.commands[keyCodeString] || this.commands[keyString] || this.commands[codeString];
  }
  checkWhen(command) {
    return command.whenFunction();
  }
  execute(e2, eventType = "keydown") {
    let commands = this.checkShortCut(this.makeKeyCodeString(e2), this.makeKeyString(e2), this.makeCodeString(e2));
    if (commands) {
      const filteredCommands = commands.filter((it) => it.eventType === eventType).filter((it) => this.checkWhen(it));
      if (filteredCommands.length) {
        e2.preventDefault();
      }
      filteredCommands.forEach((it) => {
        this.$editor.emit(it.command, ...it.args);
      });
    }
  }
}
class ConfigManager {
  constructor(editor) {
    this.editor = editor;
    this.configList = [];
    this.config = new Map();
  }
  load() {
    const obj2 = this.editor.loadItem("config") || {};
    Object.keys(obj2).forEach((key) => {
      this.config.set(key, obj2[key]);
    });
  }
  get(key) {
    var _a;
    if (this.config.has(key) === false) {
      this.config.set(key, (_a = this.configList.find((it) => it.key == key)) == null ? void 0 : _a.defaultValue);
    }
    return this.config.get(key);
  }
  set(key, value, isSave = true) {
    const oldValue = this.config.get(key);
    if (oldValue !== value) {
      this.config.set(key, value);
      this.editor.emit("config:" + key, value, oldValue);
      if (isSave) {
        this.save();
      }
    }
  }
  init(key, value) {
    this.set(key, value, false);
  }
  save() {
    const obj2 = {};
    this.configList.filter((it) => it.storage !== "none").forEach((it) => {
      obj2[it.key] = this.get(it.key);
    });
    this.editor.saveItem("config", obj2);
  }
  setAll(obj2) {
    Object.keys(obj2).forEach((key) => {
      this.set(key, obj2[key]);
    });
  }
  getType(key) {
    var _a;
    return (_a = this.configList.find((it) => it.key == key)) == null ? void 0 : _a.type;
  }
  isType(key, type) {
    return this.getType(key) === type;
  }
  isBoolean(key) {
    return this.isType(key, "boolean");
  }
  toggle(key) {
    if (this.isBoolean(key)) {
      this.set(key, !this.get(key));
    }
  }
  true(key) {
    return this.get(key) === true;
  }
  false(key) {
    return this.get(key) === false;
  }
  is(key, value) {
    return this.get(key) === value;
  }
  remove(key) {
    this.config.delete(key);
    this.editor.emit("config:" + key);
  }
  registerConfig(config) {
    this.config.set(config.key, config.defaultValue);
    this.configList.push(config);
  }
}
class HistoryManager {
  constructor(editor) {
    this.$editor = editor;
    this.currentIndex = -1;
    this.undoHistories = [];
    this.redoHistories = [];
    this.selection = {};
  }
  get length() {
    return this.undoHistories.length;
  }
  get selectedIds() {
    return Object.keys(this.selection);
  }
  createCommand(commandString) {
    return this.$editor.isPointerUp ? `history.${commandString}` : commandString;
  }
  saveSelection(obj2 = {}) {
    this.selection = this.$editor.selection.toCloneObject();
  }
  getUndoValues(attrs = {}) {
    let result = {};
    Object.keys(this.selection).forEach((id) => {
      result[id] = {};
      Object.keys(attrs).forEach((key) => {
        result[id][key] = this.selection[id][key];
      });
    });
    return result;
  }
  getUndoValuesForMulti(multiAttrs = {}) {
    let result = {};
    Object.keys(multiAttrs).forEach((id) => {
      result[id] = {};
      const selectedObject = this.selection[id] || this.$editor.selection.itemsByIds(id)[0];
      const attrs = multiAttrs[id];
      Object.keys(attrs).forEach((key) => {
        result[id][key] = selectedObject[key];
      });
    });
    return result;
  }
  add(message, command, data) {
    const time = performance.now();
    const lastUndoObject = this.undoHistories[this.undoHistories.length - 1];
    const historyObject = { message, command, data, time };
    if (lastUndoObject && lastUndoObject.message === message && time - lastUndoObject.time < this.$editor.config.get("history.delay.ms")) {
      this.undoHistories[this.undoHistories.length - 1] = historyObject;
    } else {
      this.undoHistories.push(historyObject);
      this.currentIndex++;
      this.undoHistories.length = this.currentIndex + 1;
    }
    this.$editor.emit("refreshHistory", command.command);
    return historyObject;
  }
  map(callback) {
    let results = [...this.undoHistories.map(callback), "-", ...this.redoHistories.map(callback)].reverse();
    return results;
  }
  undo() {
    if (this.currentIndex < -1)
      return;
    if (this.currentIndex === this.length) {
      this.currentIndex--;
    }
    const commandObject = this.undoHistories[this.currentIndex];
    if (commandObject && commandObject.command) {
      commandObject.command.undo(this.$editor, commandObject.data);
      this.currentIndex--;
      this.$editor.nextTick(() => {
        this.$editor.emit("refreshHistory", commandObject.command);
      });
    }
  }
  redo() {
    if (this.currentIndex > this.length)
      return;
    if (this.currentIndex < 0) {
      this.currentIndex++;
    }
    const commandObject = this.undoHistories[this.currentIndex];
    if (commandObject && commandObject.command) {
      this.currentIndex++;
      commandObject.command.redo(this.$editor, commandObject.data);
      this.$editor.debug(commandObject);
      this.$editor.nextTick(() => {
        this.$editor.emit("refreshHistory", commandObject.command);
      });
    }
  }
}
const MAX_SNAP_DISTANCE = 3;
const DEFAULT_DIST_VECTOR = fromValues(0, 0, 0);
const AXIS_X = "x";
const AXIS_Y = "y";
function checkXAxis(sourceVertex, targetVertex) {
  return Math.abs(sourceVertex[0] - targetVertex[0]) < 1;
}
function checkYAxis(sourceVertex, targetVertex) {
  return Math.abs(sourceVertex[1] - targetVertex[1]) < 1;
}
class SnapManager {
  constructor(editor, snapDistance = MAX_SNAP_DISTANCE) {
    this.editor = editor;
    this.map = new Map();
    this.snapTargetLayers = [];
    this.snapDistance = snapDistance;
  }
  get dist() {
    return this.editor.config.get("snap.distance") || this.snapDistance;
  }
  get gridSize() {
    return this.editor.config.get("snap.grid") || 50;
  }
  clear() {
    this.snapTargetLayers = this.editor.selection.snapTargetLayers.map((it) => {
      return this.convertMatrix(it);
    });
  }
  convertMatrix(item2) {
    const verties = this.convertGuideAndPathMatrix(item2);
    const xList = verties.map((it) => it[0]);
    const yList = verties.map((it) => it[1]);
    return { id: item2.id, xList, yList, verties, rectVerties: toRectVertiesWithoutTransformOrigin(item2.originVerties) };
  }
  convertGuideAndPathMatrix(item2) {
    const guideVerties = item2.guideVerties;
    return [...guideVerties];
  }
  getSnapPoints() {
    const points2 = [];
    this.editor.selection.snapTargetLayersWithSelection.forEach((it) => {
      points2.push.apply(points2, this.convertGuideAndPathMatrix(it));
    });
    return points2;
  }
  checkX(targetXList, sourceXList, dist2 = 0) {
    const checkXList = [];
    targetXList.forEach((targetX, targetIndex) => {
      sourceXList.forEach((sourceX, sourceIndex) => {
        const localDistX = targetX - sourceX;
        const localGridDistX = this.gridSize - Math.abs(sourceX) % this.gridSize;
        if (Math.abs(localDistX) <= dist2) {
          checkXList.push({ targetX, sourceX, sourceIndex, targetIndex, dx: localDistX });
        } else if (Math.abs(localGridDistX) <= dist2) {
          checkXList.push({ targetX, sourceX, sourceIndex, targetIndex, dx: localGridDistX });
        }
      });
    });
    return checkXList;
  }
  checkY(targetYList, sourceYList, dist2 = 0) {
    const checkYList = [];
    targetYList.forEach((targetY, targetIndex) => {
      sourceYList.forEach((sourceY, sourceIndex) => {
        const localDistY = targetY - sourceY;
        if (Math.abs(localDistY) <= dist2) {
          checkYList.push({ targetY, sourceY, sourceIndex, targetIndex, dy: localDistY });
        }
      });
    });
    return checkYList;
  }
  check(sourceVerties) {
    const snaps = [];
    const dist2 = this.dist;
    const sourceXList = sourceVerties.map((it) => it[0]);
    const sourceYList = sourceVerties.map((it) => it[1]);
    this.snapTargetLayers.forEach((target) => {
      const x2 = this.checkX(target.xList, sourceXList, dist2)[0];
      const y2 = this.checkY(target.yList, sourceYList, dist2)[0];
      snaps.push(fromValues(x2 ? x2.dx : 0, y2 ? y2.dy : 0, 0));
    });
    return snaps.find((it) => isNotZero(it[0]) || isNotZero(it[1])) || DEFAULT_DIST_VECTOR;
  }
  checkPoint(sourceVertex) {
    const snap = this.check([sourceVertex]);
    return add$1([], sourceVertex, snap);
  }
  getGuidesByPointPoint(sourceVerties, targetVerties) {
    const points2 = [];
    const groupPoints = {};
    let sourceVertex, targetVertex;
    for (let sourceIndex = 0, sourceLength = sourceVerties.length; sourceIndex < sourceLength; sourceIndex++) {
      sourceVertex = sourceVerties[sourceIndex];
      const keyX = `${sourceVertex[0]}_x`;
      const keyY = `${sourceVertex[1]}_y`;
      if (!groupPoints[keyX]) {
        groupPoints[keyX] = [];
      }
      if (!groupPoints[keyY]) {
        groupPoints[keyY] = [];
      }
      for (let targetIndex = 0, targetLength = targetVerties.length; targetIndex < targetLength; targetIndex++) {
        targetVertex = targetVerties[targetIndex];
        if (checkXAxis(sourceVertex, targetVertex)) {
          groupPoints[keyX].push([sourceVertex, targetVertex, AXIS_X, dist(sourceVertex, targetVertex)]);
        }
        if (checkYAxis(sourceVertex, targetVertex)) {
          groupPoints[keyY].push([sourceVertex, targetVertex, AXIS_Y, dist(sourceVertex, targetVertex)]);
        }
      }
    }
    Object.keys(groupPoints).forEach((key) => {
      if (groupPoints[key] && groupPoints[key].length) {
        const sorted = groupPoints[key].sort((a, b) => a[3] - b[3]);
        const [sourceVertex2, targetVertex2, axis] = sorted[0];
        points2.push([sourceVertex2, targetVertex2, axis]);
      }
    });
    return points2;
  }
  findGuide(sourceVerties) {
    const guides = [];
    this.snapTargetLayers.forEach((target) => {
      const points2 = this.getGuidesByPointPoint(sourceVerties, target.verties);
      guides.push.apply(guides, points2);
    });
    return guides;
  }
  findGuideOne(sourceVerties) {
    return [this.findGuide(sourceVerties)[0]];
  }
}
class KeyBoardManager {
  constructor(editor) {
    this.editor = editor;
    this.codeSet = new Set();
    this.keyCodeSet = new Set();
  }
  add(key, keyCode) {
    if (this.codeSet.has(key) === false) {
      this.codeSet.add(key);
    }
    if (this.keyCodeSet.has(keyCode) === false) {
      this.keyCodeSet.add(keyCode);
    }
  }
  remove(key, keyCode) {
    this.codeSet.delete(key);
    this.keyCodeSet.delete(keyCode);
  }
  hasKey(keyOrKeyCode) {
    return this.codeSet.has(keyOrKeyCode) || this.keyCodeSet.has(keyOrKeyCode);
  }
  check(...args2) {
    return args2.some((keyOrKeyCode) => this.hasKey(keyOrKeyCode));
  }
}
class ViewportManager {
  constructor(editor) {
    this.editor = editor;
    this.canvasSize = null;
    this.cachedViewport = rectToVerties(0, 0, 0, 0);
    this.mouse = create$4();
    this.scale = 1;
    this.translate = create$4(), this.transformOrigin = create$4(), this.maxScale = 250;
    this.minScale = 0.2;
    this.zoomFactor = 1;
    this.resetWorldMatrix();
  }
  setTransformOrigin(originVec) {
    this.transformOrigin = originVec;
    this.resetWorldMatrix();
  }
  setTransformOriginWithTranslate(newOrigin) {
    const oldOrigin = clone(this.transformOrigin);
    this.setTransformOrigin(newOrigin);
    this.setTranslate(add$1([], this.translate, subtract([], oldOrigin, newOrigin)));
  }
  setScale(scale2) {
    this.scale = Math.min(Math.max(this.minScale, scale2), this.maxScale);
    this.resetWorldMatrix();
  }
  setTranslate(translate2) {
    this.translate = translate2;
    this.resetWorldMatrix();
  }
  resetWorldMatrix() {
    this.translate = this.translate.map((it) => +it.toFixed(4));
    this.transformOrigin = this.transformOrigin.map((it) => +it.toFixed(4));
    this.scale = +this.scale.toFixed(4);
    this.matrix = calculateMatrix(fromTranslation([], this.translate), fromTranslation([], this.transformOrigin), fromScaling([], [this.scale, this.scale, 1]), fromTranslation([], negate([], this.transformOrigin)));
    this.matrixInverse = invert([], this.matrix);
    this.scaleMatrix = calculateMatrix(fromScaling([], [this.scale, this.scale, 1]));
    this.scaleMatrixInverse = invert([], this.scaleMatrix);
    this.refresh();
  }
  refreshCanvasSize(rect2) {
    if (this.canvasSize) {
      this.canvasSize = rect2;
      this.cachedViewport = rectToVerties(0, 0, this.canvasSize.width, this.canvasSize.height);
      const newVerties = transformMat4([], [this.canvasSize.width, this.canvasSize.height, 0], this.scaleMatrixInverse);
      const newTransformOrigin = add$1([], this.verties[0], [newVerties[0] / 2, newVerties[1] / 2, 0]);
      const newTranslate = getTranslation([], calculateMatrix(this.matrix, calculateMatrixInverse(fromTranslation([], newTransformOrigin), this.scaleMatrix, invert([], fromTranslation([], newTransformOrigin)))));
      this.setTranslate(newTranslate);
      this.setTransformOrigin(newTransformOrigin);
    } else {
      this.canvasSize = rect2;
      this.cachedViewport = rectToVerties(0, 0, this.canvasSize.width, this.canvasSize.height);
      this.setTransformOrigin([
        this.canvasSize.width / 2,
        this.canvasSize.height / 2,
        0
      ]);
    }
    this.editor.emit("updateViewport");
  }
  refresh() {
    if (this.cachedViewport) {
      this.verties = vertiesMap(this.cachedViewport, this.matrixInverse);
    }
  }
  getWorldPosition(e2) {
    e2 = e2 || this.editor.config.get("bodyEvent");
    if (!e2) {
      return this.createWorldPosition(0, 0);
    }
    return this.createWorldPosition(e2.clientX, e2.clientY);
  }
  createWorldPosition(x2, y2) {
    if (!this.canvasSize) {
      return create$4();
    }
    const origin2 = {
      x: x2 - this.canvasSize.x,
      y: y2 - this.canvasSize.y
    };
    const mouseX = this.verties[0][0] + (this.verties[2][0] - this.verties[0][0]) * (origin2.x / this.canvasSize.width);
    const mouseY = this.verties[0][1] + (this.verties[2][1] - this.verties[0][1]) * (origin2.y / this.canvasSize.height);
    return [mouseX, mouseY, 0];
  }
  setMousePoint(x2, y2) {
    this.mouse = this.createWorldPosition(x2, y2);
    this.setTransformOriginWithTranslate(lerp([], this.verties[0], this.verties[2], 0.5));
    this.editor.emit("updateViewport");
  }
  zoom(zoomFactor) {
    const oldScale = this.scale;
    const newScale = oldScale * zoomFactor;
    this.setScale(newScale);
    const newZoomFactor = this.scale / oldScale;
    this.zoomFactor = newZoomFactor;
    if (newZoomFactor !== 1) {
      this.setTransformOriginWithTranslate(lerp([], this.mouse, this.transformOrigin, 1 / zoomFactor));
      this.editor.emit("updateViewport");
    }
  }
  pan(x2, y2, z = 0) {
    this.setTransformOriginWithTranslate(add$1([], this.transformOrigin, [x2, y2, 0]));
    this.editor.emit("updateViewport");
  }
  moveLayerToCenter(areaVerties, scaleRate = -0.2, withScale = true) {
    const areaCenter = lerp([], areaVerties[0], areaVerties[2], 0.5);
    const width2 = dist(areaVerties[0], areaVerties[1]);
    const height2 = dist(areaVerties[0], areaVerties[3]);
    const viewportCenter = lerp([], this.verties[0], this.verties[2], 0.5);
    const viewportWidth = dist(this.verties[0], this.verties[1]);
    const viewportHeight = dist(this.verties[0], this.verties[3]);
    const minRate = withScale ? Math.min(viewportWidth / width2, viewportHeight / height2) + scaleRate : 1;
    this.setTranslate(add$1([], this.translate, subtract([], viewportCenter, areaCenter)));
    this.setTransformOrigin(areaCenter);
    this.setScale(this.scale * minRate);
    this.editor.emit("updateViewport");
  }
  get pos() {
    const mouseX = (this.mouse[0] - this.verties[0][0]) / (this.verties[2][0] - this.verties[0][0]) * 100;
    const mouseY = (this.mouse[1] - this.verties[0][1]) / (this.verties[2][1] - this.verties[0][1]) * 100;
    return [mouseX, mouseY, 0];
  }
  get minX() {
    return this.verties[0][0];
  }
  get maxX() {
    return this.verties[2][0];
  }
  get minY() {
    return this.verties[0][1];
  }
  get maxY() {
    return this.verties[2][1];
  }
  get center() {
    return this.verties[4];
  }
  get height() {
    return this.maxY - this.minY;
  }
  get width() {
    return this.maxX - this.minX;
  }
  checkInViewport(pointVertex) {
    const xInViewport = this.minX < pointVertex[0] && pointVertex[0] < this.maxX;
    const yInViewport = this.minY < pointVertex[1] && pointVertex[1] < this.maxY;
    return xInViewport && yInViewport;
  }
  applyVertex(vertex) {
    return transformMat4([], vertex, this.matrix);
  }
  applyVertexInverse(vertex) {
    return transformMat4([], vertex, this.matrixInverse);
  }
  applyVerties(verties) {
    return vertiesMap(verties, this.matrix);
  }
  applyScaleVerties(verties) {
    return vertiesMap(verties, this.scaleMatrix);
  }
  applyVertiesInverse(verties) {
    return vertiesMap(verties, this.matrixInverse);
  }
  applyScaleVertiesInverse(verties) {
    return vertiesMap(verties, this.scaleMatrixInverse);
  }
  createAreaVerties(x2, y2, width2, height2) {
    return this.applyVertiesInverse(rectToVertiesForArea(x2, y2, width2, height2));
  }
  zoomIn(zoomFactor = 0.01) {
    this.setScale(this.scale + zoomFactor);
    this.editor.emit("updateViewport");
  }
  zoomOut(zoomFactor = 0.01) {
    this.zoomIn(-zoomFactor);
  }
  zoomDefault() {
    this.setScale(1);
    this.editor.emit("updateViewport");
  }
}
class StorageManager {
  constructor(editor) {
    this.editor = editor;
    this.customAssetKey = "custom-assets";
  }
  async getCustomAssetList() {
    let isNew = false;
    const artboards = (this.editor.loadItem(this.customAssetKey) || []).map((it) => {
      if (!it.id) {
        it.id = uuid$1();
        isNew = true;
      }
      return it;
    });
    if (isNew) {
      await this.setCustomAssetList(artboards);
    }
    return artboards;
  }
  async setCustomAssetList(list2) {
    this.editor.saveItem(this.customAssetKey, list2);
  }
  async getCustomAsset(id) {
    const assetList = await this.getCustomAssetList();
    const it = assetList.find((it2) => it2.id === id);
    if (it && it.component) {
      return it.component;
    }
    return null;
  }
  async saveCustomAsset(datauri = "") {
    const current = this.editor.selection.current;
    if (current) {
      const assetList = await this.getCustomAssetList();
      const json = await this.editor.json.render(current);
      json.x = "0px";
      json.y = "0px";
      await this.setCustomAssetList([
        ...assetList,
        {
          id: uuid$1(),
          preview: datauri,
          component: json
        }
      ]);
    }
  }
  async removeCustomAsset(id) {
    const assetList = await this.getCustomAssetList();
    await this.setCustomAssetList(assetList.filter((it) => {
      return it.id !== id;
    }));
  }
}
function _icon_template(tpl, opt) {
  const defaultOpts = Object.assign({
    width: 24,
    height: 24
  }, opt);
  return `
        <svg 
            xmlns="http://www.w3.org/2000/svg" 
            width="${defaultOpts.width}" 
            height="${defaultOpts.height}" 
            viewBox="0 0 ${defaultOpts.viewBoxWidth || defaultOpts.width} ${defaultOpts.viewBoxHeight || defaultOpts.height}">${tpl}</svg>`;
}
var __glob_0_0$2 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": _icon_template
});
var account_tree = _icon_template(`<path d="M22 11V3h-7v3H9V3H2v8h7V8h2v10h4v3h7v-8h-7v3h-2V8h2v3z"/>`);
var __glob_0_1$2 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": account_tree
});
var add = _icon_template(`<path d="M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6v2z"/>`);
var __glob_0_2$2 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": add
});
var add_box = _icon_template(`<path d="M19 3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-2 10h-4v4h-2v-4H7v-2h4V7h2v4h4v2z"/>`);
var __glob_0_3$2 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": add_box
});
var add_circle = _icon_template(`<path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm5 11h-4v4h-2v-4H7v-2h4V7h2v4h4v2z"/>`);
var __glob_0_4$2 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": add_circle
});
var add_note = _icon_template(`<path d="M14 2H6c-1.1 0-1.99.9-1.99 2L4 20c0 1.1.89 2 1.99 2H18c1.1 0 2-.9 2-2V8l-6-6zm2 14h-3v3h-2v-3H8v-2h3v-3h2v3h3v2zm-3-7V3.5L18.5 9H13z"/>`);
var __glob_0_5$2 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": add_note
});
var align_center = _icon_template(`<path d="M7 15v2h10v-2H7zm-4 6h18v-2H3v2zm0-8h18v-2H3v2zm4-6v2h10V7H7zM3 3v2h18V3H3z"/>`);
var __glob_0_6$2 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": align_center
});
var align_horizontal_center = _icon_template(`<polygon points="11,2 13,2 13,7 21,7 21,10 13,10 13,14 18,14 18,17 13,17 13,22 11,22 11,17 6,17 6,14 11,14 11,10 3,10 3,7 11,7"/>`);
var __glob_0_7$2 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": align_horizontal_center
});
var align_horizontal_left = _icon_template(`<path d="M4,22H2V2h2V22z M22,7H6v3h16V7z M16,14H6v3h10V14z"/>`);
var __glob_0_8$2 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": align_horizontal_left
});
var align_horizontal_right = _icon_template(`<path d="M20,2h2v20h-2V2z M2,10h16V7H2V10z M8,17h10v-3H8V17z"/>`);
var __glob_0_9$2 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": align_horizontal_right
});
var align_justify = _icon_template(`<path d="M3 21h18v-2H3v2zm0-4h18v-2H3v2zm0-4h18v-2H3v2zm0-4h18V7H3v2zm0-6v2h18V3H3z"/>`);
var __glob_0_10$2 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": align_justify
});
var align_left = _icon_template(`<path d="M15 15H3v2h12v-2zm0-8H3v2h12V7zM3 13h18v-2H3v2zm0 8h18v-2H3v2zM3 3v2h18V3H3z"/>`);
var __glob_0_11$2 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": align_left
});
var align_right = _icon_template(`<path d="M3 21h18v-2H3v2zm6-4h12v-2H9v2zm-6-4h18v-2H3v2zm6-4h12V7H9v2zM3 3v2h18V3H3z"/>`);
var __glob_0_12$2 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": align_right
});
var align_vertical_bottom = _icon_template(`<path d="M22,22H2v-2h20V22z M10,2H7v16h3V2z M17,8h-3v10h3V8z"/>`);
var __glob_0_13$2 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": align_vertical_bottom
});
var align_vertical_center = _icon_template(`<polygon points="22,11 17,11 17,6 14,6 14,11 10,11 10,3 7,3 7,11 1.84,11 1.84,13 7,13 7,21 10,21 10,13 14,13 14,18 17,18 17,13 22,13"/>`);
var __glob_0_14$2 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": align_vertical_center
});
var align_vertical_top = _icon_template(`<path d="M22,2v2H2V2H22z M7,22h3V6H7V22z M14,16h3V6h-3V16z"/>`);
var __glob_0_15$2 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": align_vertical_top
});
var alternate = _icon_template(`<path d="M7 7h10v3l4-4-4-4v3H5v6h2V7zm10 10H7v-3l-4 4 4 4v-3h12v-6h-2v4z"/>`);
var __glob_0_16$2 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": alternate
});
var alternate_reverse = _icon_template(`<path d="M7 7h10v3l4-4-4-4v3H5v6h2V7zm10 10H7v-3l-4 4 4 4v-3h12v-6h-2v4z" />`);
var __glob_0_17$2 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": alternate_reverse
});
var apps = _icon_template(`<path d="M4 8h4V4H4v4zm6 12h4v-4h-4v4zm-6 0h4v-4H4v4zm0-6h4v-4H4v4zm6 0h4v-4h-4v4zm6-10v4h4V4h-4zm-6 4h4V4h-4v4zm6 6h4v-4h-4v4zm0 6h4v-4h-4v4z"/>`);
var __glob_0_18$2 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": apps
});
var archive = _icon_template(`<path d="M20.54 5.23l-1.39-1.68C18.88 3.21 18.47 3 18 3H6c-.47 0-.88.21-1.16.55L3.46 5.23C3.17 5.57 3 6.02 3 6.5V19c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V6.5c0-.48-.17-.93-.46-1.27zM12 17.5L6.5 12H10v-2h4v2h3.5L12 17.5zM5.12 5l.81-1h12l.94 1H5.12z"/>`);
var __glob_0_19$2 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": archive
});
var arrowLeft = _icon_template(`<path d="M14 7l-5 5 5 5V7z"/>`);
var __glob_0_20$2 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": arrowLeft
});
var arrowRight = _icon_template(`<path d="M10 17l5-5-5-5v10z"/>`);
var __glob_0_21$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": arrowRight
});
var arrow_right = _icon_template(`<path d="M10 17l5-5-5-5v10z"/>`);
var __glob_0_22$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": arrow_right
});
var artboard$1 = _icon_template(`<path d="M6 2c-1.1 0-1.99.9-1.99 2L4 20c0 1.1.89 2 1.99 2H18c1.1 0 2-.9 2-2V8l-6-6H6zm7 7V3.5L18.5 9H13z"/>`);
var __glob_0_23$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": artboard$1
});
var auto_awesome = _icon_template(`<path d="M19 9l1.25-2.75L23 5l-2.75-1.25L19 1l-1.25 2.75L15 5l2.75 1.25L19 9zm-7.5.5L9 4 6.5 9.5 1 12l5.5 2.5L9 20l2.5-5.5L17 12l-5.5-2.5zM19 15l-1.25 2.75L15 19l2.75 1.25L19 23l1.25-2.75L23 19l-2.75-1.25L19 15z"/>`);
var __glob_0_24 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": auto_awesome
});
var autorenew = _icon_template(`<path d="M12 6v3l4-4-4-4v3c-4.42 0-8 3.58-8 8 0 1.57.46 3.03 1.24 4.26L6.7 14.8c-.45-.83-.7-1.79-.7-2.8 0-3.31 2.69-6 6-6zm6.76 1.74L17.3 9.2c.44.84.7 1.79.7 2.8 0 3.31-2.69 6-6 6v-3l-4 4 4 4v-3c4.42 0 8-3.58 8-8 0-1.57-.46-3.03-1.24-4.26z"/>`);
var __glob_0_25 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": autorenew
});
var ballot = _icon_template(`<clipPath><use xlink:href="#a" overflow="visible"/></clipPath><path fill-rule="evenodd" clip-rule="evenodd" d="M13 9.5h5v-2h-5v2zm0 7h5v-2h-5v2zm6 4.5H5c-1.1 0-2-.9-2-2V5c0-1.1.9-2 2-2h14c1.1 0 2 .9 2 2v14c0 1.1-.9 2-2 2zM6 11h5V6H6v5zm1-4h3v3H7V7zM6 18h5v-5H6v5zm1-4h3v3H7v-3z"/>`);
var __glob_0_26 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": ballot
});
var bar_chart = _icon_template(`<path d="M5 9.2h3V19H5zM10.6 5h2.8v14h-2.8zm5.6 8H19v6h-2.8z"/>`);
var __glob_0_27 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": bar_chart
});
var blur = _icon_template(`<path d="M6 13c-.55 0-1 .45-1 1s.45 1 1 1 1-.45 1-1-.45-1-1-1zm0 4c-.55 0-1 .45-1 1s.45 1 1 1 1-.45 1-1-.45-1-1-1zm0-8c-.55 0-1 .45-1 1s.45 1 1 1 1-.45 1-1-.45-1-1-1zm-3 .5c-.28 0-.5.22-.5.5s.22.5.5.5.5-.22.5-.5-.22-.5-.5-.5zM6 5c-.55 0-1 .45-1 1s.45 1 1 1 1-.45 1-1-.45-1-1-1zm15 5.5c.28 0 .5-.22.5-.5s-.22-.5-.5-.5-.5.22-.5.5.22.5.5.5zM14 7c.55 0 1-.45 1-1s-.45-1-1-1-1 .45-1 1 .45 1 1 1zm0-3.5c.28 0 .5-.22.5-.5s-.22-.5-.5-.5-.5.22-.5.5.22.5.5.5zm-11 10c-.28 0-.5.22-.5.5s.22.5.5.5.5-.22.5-.5-.22-.5-.5-.5zm7 7c-.28 0-.5.22-.5.5s.22.5.5.5.5-.22.5-.5-.22-.5-.5-.5zm0-17c.28 0 .5-.22.5-.5s-.22-.5-.5-.5-.5.22-.5.5.22.5.5.5zM10 7c.55 0 1-.45 1-1s-.45-1-1-1-1 .45-1 1 .45 1 1 1zm0 5.5c-.83 0-1.5.67-1.5 1.5s.67 1.5 1.5 1.5 1.5-.67 1.5-1.5-.67-1.5-1.5-1.5zm8 .5c-.55 0-1 .45-1 1s.45 1 1 1 1-.45 1-1-.45-1-1-1zm0 4c-.55 0-1 .45-1 1s.45 1 1 1 1-.45 1-1-.45-1-1-1zm0-8c-.55 0-1 .45-1 1s.45 1 1 1 1-.45 1-1-.45-1-1-1zm0-4c-.55 0-1 .45-1 1s.45 1 1 1 1-.45 1-1-.45-1-1-1zm3 8.5c-.28 0-.5.22-.5.5s.22.5.5.5.5-.22.5-.5-.22-.5-.5-.5zM14 17c-.55 0-1 .45-1 1s.45 1 1 1 1-.45 1-1-.45-1-1-1zm0 3.5c-.28 0-.5.22-.5.5s.22.5.5.5.5-.22.5-.5-.22-.5-.5-.5zm-4-12c-.83 0-1.5.67-1.5 1.5s.67 1.5 1.5 1.5 1.5-.67 1.5-1.5-.67-1.5-1.5-1.5zm0 8.5c-.55 0-1 .45-1 1s.45 1 1 1 1-.45 1-1-.45-1-1-1zm4-4.5c-.83 0-1.5.67-1.5 1.5s.67 1.5 1.5 1.5 1.5-.67 1.5-1.5-.67-1.5-1.5-1.5zm0-4c-.83 0-1.5.67-1.5 1.5s.67 1.5 1.5 1.5 1.5-.67 1.5-1.5-.67-1.5-1.5-1.5z"/>`);
var __glob_0_28 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": blur
});
var blur_linear = _icon_template(`<path d="M5 17.5c.83 0 1.5-.67 1.5-1.5s-.67-1.5-1.5-1.5-1.5.67-1.5 1.5.67 1.5 1.5 1.5zM9 13c.55 0 1-.45 1-1s-.45-1-1-1-1 .45-1 1 .45 1 1 1zm0-4c.55 0 1-.45 1-1s-.45-1-1-1-1 .45-1 1 .45 1 1 1zM3 21h18v-2H3v2zM5 9.5c.83 0 1.5-.67 1.5-1.5S5.83 6.5 5 6.5 3.5 7.17 3.5 8 4.17 9.5 5 9.5zm0 4c.83 0 1.5-.67 1.5-1.5s-.67-1.5-1.5-1.5-1.5.67-1.5 1.5.67 1.5 1.5 1.5zM9 17c.55 0 1-.45 1-1s-.45-1-1-1-1 .45-1 1 .45 1 1 1zm8-.5c.28 0 .5-.22.5-.5s-.22-.5-.5-.5-.5.22-.5.5.22.5.5.5zM3 3v2h18V3H3zm14 5.5c.28 0 .5-.22.5-.5s-.22-.5-.5-.5-.5.22-.5.5.22.5.5.5zm0 4c.28 0 .5-.22.5-.5s-.22-.5-.5-.5-.5.22-.5.5.22.5.5.5zM13 9c.55 0 1-.45 1-1s-.45-1-1-1-1 .45-1 1 .45 1 1 1zm0 4c.55 0 1-.45 1-1s-.45-1-1-1-1 .45-1 1 .45 1 1 1zm0 4c.55 0 1-.45 1-1s-.45-1-1-1-1 .45-1 1 .45 1 1 1z"/>`);
var __glob_0_29 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": blur_linear
});
var boolean_difference = _icon_template(`<path d="M 20 10L 30 10L 30 30L 10 30L 10 20L 20 20L 20 10Z M 0 0L 20 0L 20 20L 0 20L 0 0Z  M 2 2L 2 18L 18 18L 18 2L 2 2Z" />`, { width: 30, height: 30 });
var __glob_0_30 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": boolean_difference
});
var boolean_intersection = _icon_template(`<path d="
    M 10 10L 30 10L 30 30L 10 30L 10 10Z 
    M 20 12L 18 18L 12 18L 12 28L 28 28L 28 12L 12 12Z 
    M 0 0L 20 0L 20 20L 0 20L 0 0Z  
    M 2 2L 2 18L 18 18L 18 2L 2 2Z
" />`, { width: 30, height: 30 });
var __glob_0_31 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": boolean_intersection
});
var boolean_union = _icon_template(`<path d="M 0 0L 20 0L 20 20L 0 20L 0 0Z M 10 10L 30 10L 30 30L 10 30L 10 10Z"/>`, { width: 30, height: 30 });
var __glob_0_32 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": boolean_union
});
var boolean_xor = _icon_template(`<path d="
    M 10 10L 30 10L 30 30L 10 30L 10 10Z
    M 0 0L 20 0L 20 20L 0 20L 0 0Z 
" fill-rule="evenodd"/>`, { width: 30, height: 30 });
var __glob_0_33 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": boolean_xor
});
var border_all = _icon_template(`<path d="M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-1 16H6c-.55 0-1-.45-1-1V6c0-.55.45-1 1-1h12c.55 0 1 .45 1 1v12c0 .55-.45 1-1 1z"/>`);
var __glob_0_34 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": border_all
});
var border_inner = _icon_template(`<path d="M3 5v3c0 .55.45 1 1 1s1-.45 1-1V6c0-.55.45-1 1-1h2c.55 0 1-.45 1-1s-.45-1-1-1H5c-1.1 0-2 .9-2 2zm1 10c-.55 0-1 .45-1 1v3c0 1.1.9 2 2 2h3c.55 0 1-.45 1-1s-.45-1-1-1H6c-.55 0-1-.45-1-1v-2c0-.55-.45-1-1-1zm15 3c0 .55-.45 1-1 1h-2c-.55 0-1 .45-1 1s.45 1 1 1h3c1.1 0 2-.9 2-2v-3c0-.55-.45-1-1-1s-1 .45-1 1v2zm0-15h-3c-.55 0-1 .45-1 1s.45 1 1 1h2c.55 0 1 .45 1 1v2c0 .55.45 1 1 1s1-.45 1-1V5c0-1.1-.9-2-2-2z"/>`);
var __glob_0_35 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": border_inner
});
var border_style = _icon_template(`<path d="M15 21h2v-2h-2v2zm4 0h2v-2h-2v2zM7 21h2v-2H7v2zm4 0h2v-2h-2v2zm8-4h2v-2h-2v2zm0-4h2v-2h-2v2zM3 3v18h2V5h16V3H3zm16 6h2V7h-2v2z"/>`);
var __glob_0_36 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": border_style
});
var bottom = _icon_template(`<path d="M4,20 L20,20Z M10,8 L10,16 L14,16 L14,8Z" stroke-width="1" />`);
var __glob_0_37 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": bottom
});
var broken_image = _icon_template(`<path d="M21 5v6.59l-3-3.01-4 4.01-4-4-4 4-3-3.01V5c0-1.1.9-2 2-2h14c1.1 0 2 .9 2 2zm-3 6.42l3 3.01V19c0 1.1-.9 2-2 2H5c-1.1 0-2-.9-2-2v-6.58l3 2.99 4-4 4 4 4-3.99z"/>`);
var __glob_0_38 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": broken_image
});
var brush = _icon_template(`<path d="M7 14c-1.66 0-3 1.34-3 3 0 1.31-1.16 2-2 2 .92 1.22 2.49 2 4 2 2.21 0 4-1.79 4-4 0-1.66-1.34-3-3-3zm13.71-9.37l-1.34-1.34c-.39-.39-1.02-.39-1.41 0L9 12.25 11.75 15l8.96-8.96c.39-.39.39-1.02 0-1.41z"/>`);
var __glob_0_39 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": brush
});
var build = _icon_template(`<path d="M22.7 19l-9.1-9.1c.9-2.3.4-5-1.5-6.9-2-2-5-2.4-7.4-1.3L9 6 6 9 1.6 4.7C.4 7.1.9 10.1 2.9 12.1c1.9 1.9 4.6 2.4 6.9 1.5l9.1 9.1c.4.4 1 .4 1.4 0l2.3-2.3c.5-.4.5-1.1.1-1.4z"/>`);
var __glob_0_40 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": build
});
var camera_roll = _icon_template(`<path d="M14 5c0-1.1-.9-2-2-2h-1V2c0-.55-.45-1-1-1H6c-.55 0-1 .45-1 1v1H4c-1.1 0-2 .9-2 2v15c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2h8V5h-8zm-2 13h-2v-2h2v2zm0-9h-2V7h2v2zm4 9h-2v-2h2v2zm0-9h-2V7h2v2zm4 9h-2v-2h2v2zm0-9h-2V7h2v2z"/>`);
var __glob_0_41 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": camera_roll
});
var cat = _icon_template(`
<path d="M712.4846,631.2673c-8.3777-59.9758-44.6997-121.2822-117.7703-198.7816
	c-51.7295-54.8649-72.0865-105.7791-55.8514-139.6883c12.4393-25.9817,42.587-35.8935,65.343-34.1103
	c26.3435,2.0661,37.3148,18.5905,41.88,32.0888c6.5847,19.471,2.7829,43.5175-8.4753,53.6029
	c-2.4382,2.1843-19.5444,15.6083-31.617,2.486c-16.0995-17.4994,1.3123-34.1181,1.3123-34.1181s25.7198-19.4211,11.5477-34.6431
	c-14.1721-15.2219-81.6211,4.7241-73.1766,62.9098c2.102,14.4833,9.8525,35.0453,41.7667,49.9105
	c31.3411,14.5985,62.0806,11.5356,84.3365-8.4017c26.8387-24.0431,36.221-68.5172,22.8163-108.1526
	c-13.0433-38.5685-45.3375-63.5167-86.387-66.7359c-22.4584-1.7602-45.9053,2.9182-66.0231,13.1776
	c-22.1882,11.3155-39.3094,28.5606-49.5124,49.8713c-15.207,31.7608-27.0118,99.5788,64.7797,196.9337
	c64.4428,68.3486,97.5892,122.6011,104.3126,170.7358c6.1263,43.8577-32.9753,141.2908-59.1734,141.8642
	c-18.2653,0.3997-13.0681-28.0174-11.1219-46.1832c3.4623-32.3166,9.02-64.4668,7.8147-96.946
	c-1.7692-47.6774-16.0649-83.7216-38.2463-125.1911c-20.1995-37.7643-37.8974-60.6029-92.5699-111.4463
	c-13.4884-12.5438-27.4699-22.5866-44.7675-38.1754c-17.5431-15.8101-21.9685-33.5474-24.195-48.6835
	c-4.6472-31.5926,5.266-35.0392,22.933-61.1816c7.51,6.1134,15.132,13.1576,22.5878,21.2593
	c0.8908,0.9678,2.1063,1.4586,3.3257,1.4586c1.0938,0,2.1906-0.3947,3.059-1.1939c1.8362-1.6895,1.9548-4.548,0.2647-6.3846
	c-8.043-8.7399-16.2394-16.2892-24.29-22.8068c1.0196-1.6815,1.9806-3.3693,2.913-5.06
	c11.2809,3.873,22.4781,8.5857,32.8744,14.3263c0.6923,0.3824,1.4415,0.5638,2.1804,0.5638c1.592,0,3.1354-0.8433,3.9596-2.3353
	c1.2061-2.1848,0.4133-4.9333-1.7714-6.14c-10.5501-5.8255-21.7927-10.625-33.0861-14.5846
	c1.7051-3.6655,3.2152-7.3481,4.5178-11.0449c9.9095,1.0547,20.2559,2.6507,30.8756,4.9542
	c2.4407,0.5281,4.8451-1.0193,5.3736-3.4585c0.5285-2.4387-1.0193-4.8446-3.4586-5.3736
	c-10.3543-2.2456-20.4231-3.8448-30.0823-4.9431c6.761-25.5357,4.0583-51.5754-8.0207-76.8648
	C448.2098,115.8869,474.731,76.8288,466.0513,18c-68.8775,17.9071-87.2624,54.1776-94.1043,50.875
	c-7.9472-3.8361-40.5018-11.036-62.952-10.6586c-37.278,0.6267-61.382,7.0395-61.382,7.0395
	c-11.2537-14.6686-35.9431-36.6889-90.105-41.2683c2.9433,47.1602,13.4346,82.2557,28.5291,102.9373l-0.7433,2.377
	c-11.7879,32.4393-13.5817,62.8858-3.8016,89.6451c-9.0883,1.1019-18.5685,2.7173-28.321,4.9987
	c-2.4299,0.5687-3.939,2.9991-3.3708,5.429c0.5687,2.4294,2.9972,3.939,5.429,3.3708c10.3087-2.4115,20.3424-4.0428,29.9266-5.0891
	c1.4184,2.9763,2.9836,5.904,4.7147,8.7755c-11.2262,4.119-22.4456,9.1879-32.9296,15.4312
	c-2.1445,1.2767-2.8476,4.0498-1.5704,6.1939c0.8453,1.4199,2.3461,2.2073,3.8866,2.2073c0.7859,0,1.5827-0.2054,2.3073-0.6369
	c10.5541-6.2849,22.0078-11.3381,33.4798-15.4008c3.3157,4.5403,7.0729,8.9251,11.2576,13.1527
	c-5.6694,5.3088-11.3757,11.2216-17,17.8125c-1.6199,1.8979-1.3944,4.7505,0.504,6.3699c0.8507,0.7266,1.8935,1.0816,2.931,1.0816
	c1.2767,0,2.5456-0.5383,3.4389-1.5856c5.5062-6.4525,11.1144-12.2327,16.692-17.4078c5.7832,5.4212,11.3758,11.1287,15.514,17.8627
	c7.8208,12.7265,8.3216,25.8196,6.7598,40.6753c-3.119,29.6671-13.4278,58.0414-20.0391,87.1301
	c-16.8163,73.989-9.0635,132.7513,20.7169,202.5388c8.0053,18.7598,17.5698,36.9144,23.7843,56.341
	c10.5081,32.8488,7.8436,88.3559,8.2697,122.8419v2.9318c0,0-19.9931,0.1384-28.4717,6.0748
	c-8.2555,5.7802-10.3883,21.931-4.3929,28.6906c6.6872,7.5395,21.6739,10.6397,31.6837,11.8093
	c119.664,13.9824,293.6021-2.6707,341.7446-8.3345C701.2023,821.2982,721.1432,693.2562,712.4846,631.2673z M437.2106,66.5267
	c-0.1946,33.6617-23.5064,50.7886-23.5064,50.7886c-6.2684-17.19-21.1558-25.3943-21.1558-25.3943
	C408.2194,68.8708,437.2106,66.5267,437.2106,66.5267z M201.6607,103.3024c0,0-19.8527-14.6264-20.0184-43.3732
	c0,0,24.6894,2.0019,38.035,21.6866C219.6773,81.6158,206.999,88.6223,201.6607,103.3024z M215.969,158.6876
	c15.0275-4.1452,27.2506-3.8264,37.1033-1.1182c-15.9193,16.5729-7.4137,31.0502-3.2583,36.286
	C221.2402,186.9178,215.969,158.6876,215.969,158.6876z M252.8369,194.4974c13.6546-17.1619,7.1357-30.6827,3.4758-35.9226
	c24.8589,8.5877,33.2057,32.5095,33.2057,32.5095C274.4792,195.6167,262.4471,196.221,252.8369,194.4974z M308.1766,232.8661
	c-4.1644,0.2111-22.0216-7.8084-21.8634-21.8635c0.1244-11.0539,40.2451-7.8568,42.1652,0
	C330.8523,220.7164,312.3411,232.655,308.1766,232.8661z M327.2252,191.0843c0,0,8.7972-25.2037,35.2186-33.1565
	c-12.424,19.1432-1.5466,31.7233,3.55,36.1478C356.055,196.2867,343.3752,195.9514,327.2252,191.0843z M369.7458,193.0825
	c10.0879-20.4091-1.0878-32.4358-4.9794-35.7968c9.66-2.4378,21.5306-2.5917,36.0081,1.4018
	C400.7746,158.6876,395.8536,185.0439,369.7458,193.0825z"/>
`);
var __glob_0_42 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": cat
});
var center = _icon_template(`
    <path d="M12,4 L12,20Z M6,10 L18,10 L18,14 L6,14Z" stroke-width="1" />
`);
var __glob_0_43 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": center
});
var chart = _icon_template(`<path d="M9 17H7v-7h2v7zm4 0h-2V7h2v10zm4 0h-2v-4h2v4zm2.5 2.1h-15V5h15v14.1zm0-16.1h-15c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h15c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2z"/>`);
var __glob_0_44 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": chart
});
var check$1 = _icon_template(`<path d="M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41z"/>`);
var __glob_0_45 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": check$1
});
var chevron_left = _icon_template(`<path d="M15.41 7.41L14 6l-6 6 6 6 1.41-1.41L10.83 12z"/>`);
var __glob_0_46 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": chevron_left
});
var chevron_right = _icon_template(`
    <path d="M10 6L8.59 7.41 13.17 12l-4.58 4.59L10 18l6-6-6-6z"/>
`);
var __glob_0_47 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": chevron_right
});
var circle = _icon_template(`<path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8z"/>`);
var __glob_0_48 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": circle
});
var close = _icon_template(`<path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/>`);
var __glob_0_49 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": close
});
var code = _icon_template(`<path d="M9.4 16.6L4.8 12l4.6-4.6L8 6l-6 6 6 6 1.4-1.4zm5.2 0l4.6-4.6-4.6-4.6L16 6l6 6-6 6-1.4-1.4z"/>`);
var __glob_0_50 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": code
});
var color$1 = _icon_template(`<path d="M12 3c-4.97 0-9 4.03-9 9s4.03 9 9 9c.83 0 1.5-.67 1.5-1.5 0-.39-.15-.74-.39-1.01-.23-.26-.38-.61-.38-.99 0-.83.67-1.5 1.5-1.5H16c2.76 0 5-2.24 5-5 0-4.42-4.03-8-9-8zm-5.5 9c-.83 0-1.5-.67-1.5-1.5S5.67 9 6.5 9 8 9.67 8 10.5 7.33 12 6.5 12zm3-4C8.67 8 8 7.33 8 6.5S8.67 5 9.5 5s1.5.67 1.5 1.5S10.33 8 9.5 8zm5 0c-.83 0-1.5-.67-1.5-1.5S13.67 5 14.5 5s1.5.67 1.5 1.5S15.33 8 14.5 8zm3 4c-.83 0-1.5-.67-1.5-1.5S16.67 9 17.5 9s1.5.67 1.5 1.5-.67 1.5-1.5 1.5z"/>`);
var __glob_0_51 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": color$1
});
var color_lens = _icon_template(`<path d="M12 3c-4.97 0-9 4.03-9 9s4.03 9 9 9c.83 0 1.5-.67 1.5-1.5 0-.39-.15-.74-.39-1.01-.23-.26-.38-.61-.38-.99 0-.83.67-1.5 1.5-1.5H16c2.76 0 5-2.24 5-5 0-4.42-4.03-8-9-8zm-5.5 9c-.83 0-1.5-.67-1.5-1.5S5.67 9 6.5 9 8 9.67 8 10.5 7.33 12 6.5 12zm3-4C8.67 8 8 7.33 8 6.5S8.67 5 9.5 5s1.5.67 1.5 1.5S10.33 8 9.5 8zm5 0c-.83 0-1.5-.67-1.5-1.5S13.67 5 14.5 5s1.5.67 1.5 1.5S15.33 8 14.5 8zm3 4c-.83 0-1.5-.67-1.5-1.5S16.67 9 17.5 9s1.5.67 1.5 1.5-.67 1.5-1.5 1.5z"/>`);
var __glob_0_52 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": color_lens
});
var control_point = _icon_template(`<path d="M13 7h-2v4H7v2h4v4h2v-4h4v-2h-4V7zm-1-5C6.49 2 2 6.49 2 12s4.49 10 10 10 10-4.49 10-10S17.51 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8z"/>`);
var __glob_0_53 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": control_point
});
var copy = _icon_template(`<path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12V1zm-1 4l6 6v10c0 1.1-.9 2-2 2H7.99C6.89 23 6 22.1 6 21l.01-14c0-1.1.89-2 1.99-2h7zm-1 7h5.5L14 6.5V12z"/>`);
var __glob_0_54 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": copy
});
var create_folder = _icon_template(`
    <path d="M22 6H12l-2-2H2v16h20V6zm-3 8h-3v3h-2v-3h-3v-2h3V9h2v3h3v2z"/>
`);
var __glob_0_55 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": create_folder
});
var cube = _icon_template(`<path d="M21 16.5a1 1 0 0 1-.527.881l-7.907 4.443a.996.996 0 0 1-1.132 0l-7.907-4.443A1 1 0 0 1 3 16.5v-9a1 1 0 0 1 .527-.881l7.907-4.443a.995.995 0 0 1 1.132 0l7.907 4.443A1 1 0 0 1 21 7.5v9zM12 4.15L6.042 7.5l5.96 3.35 5.958-3.35-5.958-3.35zM5 15.916l6 3.372V12.58L5 9.209v6.706zm14 0V9.209l-6 3.372v6.707l6-3.373z" />`);
var __glob_0_56 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": cube
});
var cylinder = _icon_template(`
<g class="cylinder">
<path d="M 12 0 C 7.636719 0 3 1.226562 3 3.5 L 3 20.5 C 3 22.773438 7.636719 24 12 24 C 16.363281 24 21 22.773438 21 20.5 L 21 3.5 C 21 1.226562 16.363281 0 12 0 Z M 20 19.121094 C 19.921875 19.140625 19.84375 19.171875 19.78125 19.230469 C 19.574219 19.414062 19.554688 19.726562 19.738281 19.933594 C 19.914062 20.128906 20 20.320312 20 20.5 C 20 21.542969 16.957031 23 12 23 C 7.042969 23 4 21.542969 4 20.5 C 4 20.320312 4.085938 20.128906 4.261719 19.933594 C 4.445312 19.726562 4.425781 19.410156 4.21875 19.226562 C 4.15625 19.171875 4.078125 19.140625 4 19.121094 L 4 5.160156 C 5.59375 6.363281 8.863281 7 12 7 C 15.136719 7 18.40625 6.363281 20 5.160156 Z M 12 6 C 7.042969 6 4 4.542969 4 3.5 C 4 2.457031 7.042969 1 12 1 C 16.957031 1 20 2.457031 20 3.5 C 20 4.542969 16.957031 6 12 6 Z M 12 6 "/>
</g>
`);
var __glob_0_57 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": cylinder
});
var dahaze = _icon_template(`<path d="M2 15.5v2h20v-2H2zm0-5v2h20v-2H2zm0-5v2h20v-2H2z"/>`);
var __glob_0_58 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": dahaze
});
var dark = _icon_template(`<path d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"/>`);
var __glob_0_59 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": dark
});
var delete_forever = _icon_template(`<path d="M6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7H6v12zm2.46-7.12l1.41-1.41L12 12.59l2.12-2.12 1.41 1.41L13.41 14l2.12 2.12-1.41 1.41L12 15.41l-2.12 2.12-1.41-1.41L10.59 14l-2.13-2.12zM15.5 4l-1-1h-5l-1 1H5v2h14V4z"/>`);
var __glob_0_60 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": delete_forever
});
var device_hub = _icon_template(`<path d="M17 16l-4-4V8.82C14.16 8.4 15 7.3 15 6c0-1.66-1.34-3-3-3S9 4.34 9 6c0 1.3.84 2.4 2 2.82V12l-4 4H3v5h5v-3.05l4-4.2 4 4.2V21h5v-5h-4z"/>`);
var __glob_0_61 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": device_hub
});
var diffuse = _icon_template(`<path d="M5 14.5h14v-6H5v6zM11 .55V3.5h2V.55h-2zm8.04 2.5l-1.79 1.79 1.41 1.41 1.8-1.79-1.42-1.41zM13 22.45V19.5h-2v2.95h2zm7.45-3.91l-1.8-1.79-1.41 1.41 1.79 1.8 1.42-1.42zM3.55 4.46l1.79 1.79 1.41-1.41-1.79-1.79-1.41 1.41zm1.41 15.49l1.79-1.8-1.41-1.41-1.79 1.79 1.41 1.42z"/>`);
var __glob_0_62 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": diffuse
});
var doc = _icon_template(`<path d="M6 2c-1.1 0-1.99.9-1.99 2L4 20c0 1.1.89 2 1.99 2H18c1.1 0 2-.9 2-2V8l-6-6H6zm7 7V3.5L18.5 9H13z"/>`);
var __glob_0_63 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": doc
});
var drag_indicator = _icon_template(`<path d="M11 18c0 1.1-.9 2-2 2s-2-.9-2-2 .9-2 2-2 2 .9 2 2zm-2-8c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm0-6c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm6 4c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2zm0 2c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm0 6c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2z"/>`);
var __glob_0_64 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": drag_indicator
});
var draw = _icon_template(`<path d="M18.85,10.39l1.06-1.06c0.78-0.78,0.78-2.05,0-2.83L18.5,5.09c-0.78-0.78-2.05-0.78-2.83,0l-1.06,1.06L18.85,10.39z M14.61,11.81L7.41,19H6v-1.41l7.19-7.19L14.61,11.81z M13.19,7.56L4,16.76V21h4.24l9.19-9.19L13.19,7.56L13.19,7.56z M19,17.5 c0,2.19-2.54,3.5-5,3.5c-0.55,0-1-0.45-1-1s0.45-1,1-1c1.54,0,3-0.73,3-1.5c0-0.47-0.48-0.87-1.23-1.2l1.48-1.48 C18.32,15.45,19,16.29,19,17.5z M4.58,13.35C3.61,12.79,3,12.06,3,11c0-1.8,1.89-2.63,3.56-3.36C7.59,7.18,9,6.56,9,6 c0-0.41-0.78-1-2-1C5.74,5,5.2,5.61,5.17,5.64C4.82,6.05,4.19,6.1,3.77,5.76C3.36,5.42,3.28,4.81,3.62,4.38C3.73,4.24,4.76,3,7,3 c2.24,0,4,1.32,4,3c0,1.87-1.93,2.72-3.64,3.47C6.42,9.88,5,10.5,5,11c0,0.31,0.43,0.6,1.07,0.86L4.58,13.35z" />`);
var __glob_0_65 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": draw
});
var east = _icon_template(`<path d="M15,5l-1.41,1.41L18.17,11H2V13h16.17l-4.59,4.59L15,19l7-7L15,5z"/>`);
var __glob_0_66 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": east
});
var edit = _icon_template(`<path d="M3 17.46v3.04c0 .28.22.5.5.5h3.04c.13 0 .26-.05.35-.15L17.81 9.94l-3.75-3.75L3.15 17.1c-.1.1-.15.22-.15.36zM20.71 7.04c.39-.39.39-1.02 0-1.41l-2.34-2.34c-.39-.39-1.02-.39-1.41 0l-1.83 1.83 3.75 3.75 1.83-1.83z"/>`);
var __glob_0_67 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": edit
});
var end = _icon_template(`<path transform="translate(24,0) scale(-1, 1)" d="M14.59,7.41L18.17,11H6v2h12.17l-3.59,3.59L16,18l6-6l-6-6L14.59,7.41z M2,6v12h2V6H2z"/>`);
var __glob_0_68 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": end
});
var exit_to_app = _icon_template(`<path d="M10.09 15.59L11.5 17l5-5-5-5-1.41 1.41L12.67 11H3v2h9.67l-2.58 2.59zM19 3H5c-1.11 0-2 .9-2 2v4h2V5h14v14H5v-4H3v4c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2z"/>`);
var __glob_0_69 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": exit_to_app
});
var expand = _icon_template(`<path d="M16.59 8.59L12 13.17 7.41 8.59 6 10l6 6 6-6z"/>`);
var __glob_0_70 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": expand
});
var expand_more = _icon_template(`<path d="M16.59 8.59L12 13.17 7.41 8.59 6 10l6 6 6-6-1.41-1.41z"/>`);
var __glob_0_71 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": expand_more
});
var _export = _icon_template(`<path d="M9 3L5 6.99h3V14h2V6.99h3L9 3zm7 14.01V10h-2v7.01h-3L15 21l4-3.99h-3z"/>`);
var __glob_0_72 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": _export
});
var face = _icon_template(`<path d="M9 11.75c-.69 0-1.25.56-1.25 1.25s.56 1.25 1.25 1.25 1.25-.56 1.25-1.25-.56-1.25-1.25-1.25zm6 0c-.69 0-1.25.56-1.25 1.25s.56 1.25 1.25 1.25 1.25-.56 1.25-1.25-.56-1.25-1.25-1.25zM12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8 0-.29.02-.58.05-.86 2.36-1.05 4.23-2.98 5.21-5.37C11.07 8.33 14.05 10 17.42 10c.78 0 1.53-.09 2.25-.26.21.71.33 1.47.33 2.26 0 4.41-3.59 8-8 8z"/>`);
var __glob_0_73 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": face
});
var fast_forward = _icon_template(`<path d="M4 18l8.5-6L4 6v12zm9-12v12l8.5-6L13 6z"/>`);
var __glob_0_74 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": fast_forward
});
var fast_rewind = _icon_template(`<path d="M11 18V6l-8.5 6 8.5 6zm.5-6l8.5 6V6l-8.5 6z"/>`);
var __glob_0_75 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": fast_rewind
});
var file_copy = _icon_template(`<path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12V1zm-1 4l6 6v10c0 1.1-.9 2-2 2H7.99C6.89 23 6 22.1 6 21l.01-14c0-1.1.89-2 1.99-2h7zm-1 7h5.5L14 6.5V12z"/>`);
var __glob_0_76 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": file_copy
});
var filter$1 = _icon_template(`<path d="M18.7 12.4c-.28-.16-.57-.29-.86-.4.29-.11.58-.24.86-.4 1.92-1.11 2.99-3.12 3-5.19-1.79-1.03-4.07-1.11-6 0-.28.16-.54.35-.78.54.05-.31.08-.63.08-.95 0-2.22-1.21-4.15-3-5.19C10.21 1.85 9 3.78 9 6c0 .32.03.64.08.95-.24-.2-.5-.39-.78-.55-1.92-1.11-4.2-1.03-6 0 0 2.07 1.07 4.08 3 5.19.28.16.57.29.86.4-.29.11-.58.24-.86.4-1.92 1.11-2.99 3.12-3 5.19 1.79 1.03 4.07 1.11 6 0 .28-.16.54-.35.78-.54-.05.32-.08.64-.08.96 0 2.22 1.21 4.15 3 5.19 1.79-1.04 3-2.97 3-5.19 0-.32-.03-.64-.08-.95.24.2.5.38.78.54 1.92 1.11 4.2 1.03 6 0-.01-2.07-1.08-4.08-3-5.19zM12 16c-2.21 0-4-1.79-4-4s1.79-4 4-4 4 1.79 4 4-1.79 4-4 4z"/>`);
var __glob_0_77 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": filter$1
});
var flag = _icon_template(`<path d="M14.4 6L14 4H5v17h2v-7h5.6l.4 2h7V6z"/>`);
var __glob_0_78 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": flag
});
var flash_on = _icon_template(`<path d="M7 2v11h3v9l7-12h-4l4-8z"/>`);
var __glob_0_79 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": flash_on
});
var flatten = _icon_template(`<path d="M4,9v2h16V9H4z M16,4l-1.41-1.41L13,4.17V1h-2v3.19L9.39,2.61L8,4l4,4L16,4z M4,14h16v-2H4V14z M8,19l1.39,1.39L11,18.81 V22h2v-3.17l1.59,1.59L16,19l-4-4L8,19z"/>`);
var __glob_0_80 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": flatten
});
var flex = _icon_template(`<path d="M3,5v14h18V5H3z M8.33,17H5V7h3.33V17z M13.67,17h-3.33V7h3.33V17z M19,17h-3.33V7H19V17z"/>`);
var __glob_0_81 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": flex
});
var flip = _icon_template(`<path d="M15 21h2v-2h-2v2zm4-12h2V7h-2v2zM3 5v14c0 1.1.9 2 2 2h4v-2H5V5h4V3H5c-1.1 0-2 .9-2 2zm16-2v2h2c0-1.1-.9-2-2-2zm-8 20h2V1h-2v22zm8-6h2v-2h-2v2zM15 5h2V3h-2v2zm4 8h2v-2h-2v2zm0 8c1.1 0 2-.9 2-2h-2v2z"/>`);
var __glob_0_82 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": flip
});
var flipY = _icon_template(`<path d="M15 21h2v-2h-2v2zm4-12h2V7h-2v2zM3 5v14c0 1.1.9 2 2 2h4v-2H5V5h4V3H5c-1.1 0-2 .9-2 2zm16-2v2h2c0-1.1-.9-2-2-2zm-8 20h2V1h-2v22zm8-6h2v-2h-2v2zM15 5h2V3h-2v2zm4 8h2v-2h-2v2zm0 8c1.1 0 2-.9 2-2h-2v2z"/>`);
var __glob_0_83 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": flipY
});
var flip_camera = _icon_template(`
    <path d="M9,12c0,1.66,1.34,3,3,3s3-1.34,3-3s-1.34-3-3-3S9,10.34,9,12z"/>
    <path d="M8,10V8H5.09C6.47,5.61,9.05,4,12,4c3.72,0,6.85,2.56,7.74,6h2.06c-0.93-4.56-4.96-8-9.8-8C8.73,2,5.82,3.58,4,6.01V4H2v6
        H8z"/>
    <path d="M16,14v2h2.91c-1.38,2.39-3.96,4-6.91,4c-3.72,0-6.85-2.56-7.74-6H2.2c0.93,4.56,4.96,8,9.8,8c3.27,0,6.18-1.58,8-4.01V20
        h2v-6H16z"/>
`);
var __glob_0_84 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": flip_camera
});
var folder = _icon_template(`<path d="M10 4H4c-1.1 0-1.99.9-1.99 2L2 18c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V8c0-1.1-.9-2-2-2h-8l-2-2z"/>`);
var __glob_0_85 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": folder
});
var font_download = _icon_template(`<path d="M9.93 13.5h4.14L12 7.98zM20 2H4c-1.1 0-2 .9-2 2v16c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zm-4.05 16.5l-1.14-3H9.17l-1.12 3H5.96l5.11-13h1.86l5.11 13h-2.09z"/>`);
var __glob_0_86 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": font_download
});
var format_bold = _icon_template(`<path d="M15.6 10.79c.97-.67 1.65-1.77 1.65-2.79 0-2.26-1.75-4-4-4H7v14h7.04c2.09 0 3.71-1.7 3.71-3.79 0-1.52-.86-2.82-2.15-3.42zM10 6.5h3c.83 0 1.5.67 1.5 1.5s-.67 1.5-1.5 1.5h-3v-3zm3.5 9H10v-3h3.5c.83 0 1.5.67 1.5 1.5s-.67 1.5-1.5 1.5z"/>`);
var __glob_0_87 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": format_bold
});
var format_indent = _icon_template(`<path d="M3 21h18v-2H3v2zM3 8v8l4-4-4-4zm8 9h10v-2H11v2zM3 3v2h18V3H3zm8 6h10V7H11v2zm0 4h10v-2H11v2z"/>`);
var __glob_0_88 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": format_indent
});
var format_line_spacing = _icon_template(`<path d="M6 7h2.5L5 3.5 1.5 7H4v10H1.5L5 20.5 8.5 17H6V7zm4-2v2h12V5H10zm0 14h12v-2H10v2zm0-6h12v-2H10v2z"/>`);
var __glob_0_89 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": format_line_spacing
});
var format_shapes = _icon_template(`<path d="M23 7V1h-6v2H7V1H1v6h2v10H1v6h6v-2h10v2h6v-6h-2V7h2zM3 3h2v2H3V3zm2 18H3v-2h2v2zm12-2H7v-2H5V7h2V5h10v2h2v10h-2v2zm4 2h-2v-2h2v2zM19 5V3h2v2h-2zm-5.27 9h-3.49l-.73 2H7.89l3.4-9h1.4l3.41 9h-1.63l-.74-2zm-3.04-1.26h2.61L12 8.91l-1.31 3.83z"/>`);
var __glob_0_90 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": format_shapes
});
var format_size = _icon_template(`<path d="M9 4v3h5v12h3V7h5V4H9zm-6 8h3v7h3v-7h3V9H3v3z"/>`);
var __glob_0_91 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": format_size
});
var fullscreen = _icon_template(`<path d="M7 14H5v5h5v-2H7v-3zm-2-4h2V7h3V5H5v5zm12 7h-3v2h5v-5h-2v3zM14 5v2h3v3h2V5h-5z"/>`);
var __glob_0_92 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": fullscreen
});
var gps_fixed = _icon_template(`<path d="M12 8c-2.21 0-4 1.79-4 4s1.79 4 4 4 4-1.79 4-4-1.79-4-4-4zm8.94 3c-.46-4.17-3.77-7.48-7.94-7.94V1h-2v2.06C6.83 3.52 3.52 6.83 3.06 11H1v2h2.06c.46 4.17 3.77 7.48 7.94 7.94V23h2v-2.06c4.17-.46 7.48-3.77 7.94-7.94H23v-2h-2.06zM12 19c-3.87 0-7-3.13-7-7s3.13-7 7-7 7 3.13 7 7-3.13 7-7 7z"/>`);
var __glob_0_93 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": gps_fixed
});
var gradient$1 = _icon_template('<path d="M11 9h2v2h-2zm-2 2h2v2H9zm4 0h2v2h-2zm2-2h2v2h-2zM7 9h2v2H7zm12-6H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zM9 18H7v-2h2v2zm4 0h-2v-2h2v2zm4 0h-2v-2h2v2zm2-7h-2v2h2v2h-2v-2h-2v2h-2v-2h-2v2H9v-2H7v2H5v-2h2v-2H5V5h14v6z"/>');
var __glob_0_94 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": gradient$1
});
var grid$1 = _icon_template(`<path d="M3,3v8h8V3H3z M9,9H5V5h4V9z M3,13v8h8v-8H3z M9,19H5v-4h4V19z M13,3v8h8V3H13z M19,9h-4V5h4V9z M13,13v8h8v-8H13z M19,19h-4v-4h4V19z"/>`);
var __glob_0_95 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": grid$1
});
var grid3x3 = _icon_template(`<path d="M20,10V8h-4V4h-2v4h-4V4H8v4H4v2h4v4H4v2h4v4h2v-4h4v4h2v-4h4v-2h-4v-4H20z M14,14h-4v-4h4V14z"/>`);
var __glob_0_96 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": grid3x3
});
var group = _icon_template(`
        <path d="M3 5h2V3c-1.1 0-2 .9-2 2zm0 8h2v-2H3v2zm4 8h2v-2H7v2zM3 9h2V7H3v2zm10-6h-2v2h2V3zm6 0v2h2c0-1.1-.9-2-2-2zM5 21v-2H3c0 1.1.9 2 2 2zm-2-4h2v-2H3v2zM9 3H7v2h2V3zm2 18h2v-2h-2v2zm8-8h2v-2h-2v2zm0 8c1.1 0 2-.9 2-2h-2v2zm0-12h2V7h-2v2zm0 8h2v-2h-2v2zm-4 4h2v-2h-2v2zm0-16h2V3h-2v2zM7 17h10V7H7v10zm2-8h6v6H9V9z"/>
    `);
var __glob_0_97 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": group
});
var height = _icon_template(`<polygon points="13,6.99 16,6.99 12,3 8,6.99 11,6.99 11,17.01 8,17.01 12,21 16,17.01 13,17.01"/>`);
var __glob_0_98 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": height
});
var highlight_at = _icon_template(`<path d="M17,5h-2V3h2V5z M15,15v6l2.29-2.29L19.59,21L21,19.59l-2.29-2.29L21,15H15z M19,9h2V7h-2V9z M19,13h2v-2h-2V13z M11,21h2 v-2h-2V21z M7,5h2V3H7V5z M3,17h2v-2H3V17z M5,21v-2H3C3,20.1,3.9,21,5,21z M19,3v2h2C21,3.9,20.1,3,19,3z M11,5h2V3h-2V5z M3,9h2 V7H3V9z M7,21h2v-2H7V21z M3,13h2v-2H3V13z M3,5h2V3C3.9,3,3,3.9,3,5z"/>`);
var __glob_0_99 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": highlight_at
});
var horizontal_distribute = _icon_template(`<path d="M4,22H2V2h2V22z M22,2h-2v20h2V2z M13.5,7h-3v10h3V7z"/>`);
var __glob_0_100 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": horizontal_distribute
});
var horizontal_rule = _icon_template(`<rect fill-rule="evenodd" height="2" width="16" x="4" y="11"/>`);
var __glob_0_101 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": horizontal_rule
});
var image$1 = _icon_template(`<path d="M21 19V5c0-1.1-.9-2-2-2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2zM8.5 13.5l2.5 3.01L14.5 12l4.5 6H5l3.5-4.5z"/>`);
var __glob_0_102 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": image$1
});
var input = _icon_template(`<path d="M21 3.01H3c-1.1 0-2 .9-2 2V9h2V4.99h18v14.03H3V15H1v4.01c0 1.1.9 1.98 2 1.98h18c1.1 0 2-.88 2-1.98v-14c0-1.11-.9-2-2-2zM11 16l4-4-4-4v3H1v2h10v3z"/>`);
var __glob_0_103 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": input
});
var italic = _icon_template(`<path d="M10 4v3h2.21l-3.42 8H6v3h8v-3h-2.21l3.42-8H18V4z"/>`);
var __glob_0_104 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": italic
});
var join_full = _icon_template(`
<g>
    <g>
        <ellipse cx="12" cy="12" rx="3" ry="5.74"/>
        <path d="M7.5,12c0-0.97,0.23-4.16,3.03-6.5C9.75,5.19,8.9,5,8,5c-3.86,0-7,3.14-7,7s3.14,7,7,7c0.9,0,1.75-0.19,2.53-0.5 C7.73,16.16,7.5,12.97,7.5,12z"/><path d="M16,5c-0.9,0-1.75,0.19-2.53,0.5c2.8,2.34,3.03,5.53,3.03,6.5c0,0.97-0.23,4.16-3.03,6.5C14.25,18.81,15.1,19,16,19 c3.86,0,7-3.14,7-7S19.86,5,16,5z"/>
    </g>
</g>
`);
var __glob_0_105 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": join_full
});
var join_right = _icon_template(`
<ellipse cx="12" cy="12" rx="3" ry="5.74"/>
<path d="M16.5,12c0,0.97-0.23,4.16-3.03,6.5C14.25,18.81,15.1,19,16,19c3.86,0,7-3.14,7-7s-3.14-7-7-7c-0.9,0-1.75,0.19-2.53,0.5 C16.27,7.84,16.5,11.03,16.5,12z"/></g><g><path d="M8,19c0.9,0,1.75-0.19,2.53-0.5c-0.61-0.51-1.1-1.07-1.49-1.63C8.71,16.95,8.36,17,8,17c-2.76,0-5-2.24-5-5s2.24-5,5-5 c0.36,0,0.71,0.05,1.04,0.13c0.39-0.56,0.88-1.12,1.49-1.63C9.75,5.19,8.9,5,8,5c-3.86,0-7,3.14-7,7S4.14,19,8,19z"/>
`);
var __glob_0_106 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": join_right
});
var justify_content_space_around = _icon_template(`<path d="M15,7v10H9V7H15z M21,5h-3v14h3V5z M17,5H7v14h10V5z M6,5H3v14h3V5z"/>`);
var __glob_0_107 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": justify_content_space_around
});
var keyboard = _icon_template(`<path d="M20 5H4c-1.1 0-1.99.9-1.99 2L2 17c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm-9 3h2v2h-2V8zm0 3h2v2h-2v-2zM8 8h2v2H8V8zm0 3h2v2H8v-2zm-1 2H5v-2h2v2zm0-3H5V8h2v2zm9 7H8v-2h8v2zm0-4h-2v-2h2v2zm0-3h-2V8h2v2zm3 3h-2v-2h2v2zm0-3h-2V8h2v2z"/>`);
var __glob_0_108 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": keyboard
});
var keyboard_arrow_down = _icon_template(`<path d="M7.41 8.59L12 13.17l4.59-4.58L18 10l-6 6-6-6 1.41-1.41z"/>`);
var __glob_0_109 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": keyboard_arrow_down
});
var keyboard_arrow_left = _icon_template(`<path d="M15.41 16.59L10.83 12l4.58-4.59L14 6l-6 6 6 6 1.41-1.41z"/>`);
var __glob_0_110 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": keyboard_arrow_left
});
var keyboard_arrow_right = _icon_template(`<path d="M8.59 16.59L13.17 12 8.59 7.41 10 6l6 6-6 6-1.41-1.41z"/>`);
var __glob_0_111 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": keyboard_arrow_right
});
var keyboard_arrow_up = _icon_template(`<path d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6 1.41 1.41z"/>`);
var __glob_0_112 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": keyboard_arrow_up
});
var landscape = _icon_template(`<path d="M14 6l-3.75 5 2.85 3.8-1.6 1.2C9.81 13.75 7 10 7 10l-6 8h22L14 6z"/>`);
var __glob_0_113 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": landscape
});
var launch = _icon_template(`
        <path d="M19 19H5V5h7V3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2v-7h-2v7zM14 3v2h3.59l-9.83 9.83 1.41 1.41L19 6.41V10h2V3h-7z"/>
    `);
var __glob_0_114 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": launch
});
var layers = _icon_template(`<path d="M11.99 18.54l-7.37-5.73L3 14.07l9 7 9-7-1.63-1.27-7.38 5.74zM12 16l7.36-5.73L21 9l-9-7-9 7 1.63 1.27L12 16z"/>`);
var __glob_0_115 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": layers
});
var layout_default = _icon_template(`<path d="M19 7h-8v6h8V7zm-2 4h-4V9h4v2zm4-8H3c-1.1 0-2 .9-2 2v14c0 1.1.9 1.98 2 1.98h18c1.1 0 2-.88 2-1.98V5c0-1.1-.9-2-2-2zm0 16.01H3V4.98h18v14.03z"/>`);
var __glob_0_116 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": layout_default
});
var layout_flex = _icon_template(`<path d="M20,4H4C2.9,4,2,4.9,2,6v12c0,1.1,0.9,2,2,2h16c1.1,0,2-0.9,2-2V6C22,4.9,21.1,4,20,4z M8,18H4V6h4V18z M14,18h-4V6h4V18z M20,18h-4V6h4V18z"/>`);
var __glob_0_117 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": layout_flex
});
var layout_grid = _icon_template(`<path d="M3,3v8h8V3H3z M9,9H5V5h4V9z M3,13v8h8v-8H3z M9,19H5v-4h4V19z M13,3v8h8V3H13z M19,9h-4V5h4V9z M13,13v8h8v-8H13z M19,19h-4v-4h4V19z"/>`);
var __glob_0_118 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": layout_grid
});
var left = _icon_template(`<path d="M2,4 L2,20Z M6,10 L16,10 L16,14 L6,14Z" stroke-width="1" />`);
var __glob_0_119 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": left
});
var left_hide = _icon_template(`<path d="M18.41 16.59L13.82 12l4.59-4.59L17 6l-6 6 6 6zM6 6h2v12H6z"/>`);
var __glob_0_120 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": left_hide
});
var lens = _icon_template(`<path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2z"/>`);
var __glob_0_121 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": lens
});
var light = _icon_template(`<path d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"/>`);
var __glob_0_122 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": light
});
var line_cap_butt = _icon_template(`
        <rect class="base" width="13" height="12" x="3" y="2" fill="transparent" fill-rule="nonzero"></rect>
        <path fill="currentColor" fill-rule="nonzero" d="M3.5,6.06300874 C4.20280365,6.2438979 4.7561021,6.79719635 4.93699126,7.5 L16,7.5 L16,8.5 L4.93699126,8.5 C4.7561021,9.20280365 4.20280365,9.7561021 3.5,9.93699126 L3.5,13.5 L16,13.5 L16,14.5 L2.5,14.5 L2.5,9.93699126 C1.63738639,9.71496986 1,8.93191971 1,8 C1,7.06808029 1.63738639,6.28503014 2.5,6.06300874 L2.5,1.5 L16,1.5 L16,2.5 L3.5,2.5 L3.5,6.06300874 Z"></path>
    `, { width: 18, height: 16 });
var __glob_0_123 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": line_cap_butt
});
var line_cap_round = _icon_template(`
        <path class="base" fill="transparent" fill-rule="nonzero" d="M8,2 L16,2 L16,14 L8,14 C4.6862915,14 2,11.3137085 2,8 L2,8 C2,4.6862915 4.6862915,2 8,2 Z"></path>
        <path fill="currentColor" fill-rule="nonzero" d="M9.93699126,8.5 C9.71496986,9.36261361 8.93191971,10 8,10 C6.8954305,10 6,9.1045695 6,8 C6,6.8954305 6.8954305,6 8,6 C8.93191971,6 9.71496986,6.63738639 9.93699126,7.5 L16,7.5 L16,8.5 L9.93699126,8.5 Z M16,13.5 L16,14.5 L8,14.5 C4.41014913,14.5 1.5,11.5898509 1.5,8 C1.5,4.41014913 4.41014913,1.5 8,1.5 L16,1.5 L16,2.5 L8,2.5 C4.96243388,2.5 2.5,4.96243388 2.5,8 C2.5,11.0375661 4.96243388,13.5 8,13.5 L16,13.5 Z"></path>
    `, { width: 18, height: 16 });
var __glob_0_124 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": line_cap_round
});
var line_cap_square = _icon_template(`
        <rect class="base" width="14" height="12" x="2" y="2" fill="transparent" fill-rule="nonzero"></rect>
        <path fill="currentColor" fill-rule="nonzero" d="M9.93699126,8.5 C9.71496986,9.36261361 8.93191971,10 8,10 C6.8954305,10 6,9.1045695 6,8 C6,6.8954305 6.8954305,6 8,6 C8.93191971,6 9.71496986,6.63738639 9.93699126,7.5 L16,7.5 L16,8.5 L9.93699126,8.5 Z M2.5,13.5 L16,13.5 L16,14.5 L1.5,14.5 L1.5,1.5 L16,1.5 L16,2.5 L2.5,2.5 L2.5,13.5 Z"></path>
    `, { width: 18, height: 16 });
var __glob_0_125 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": line_cap_square
});
var line_chart = _icon_template(`<path d="M3.5 18.49l6-6.01 4 4L22 6.92l-1.41-1.41-7.09 7.97-4-4L2 16.99z"/>`);
var __glob_0_126 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": line_chart
});
var line_join_bevel = _icon_template(`<g fill="none" fill-rule="evenodd"><polygon class="base" fill="transparent" fill-rule="nonzero" points="2 14.5 2 7.538 7.382 1.5 16 1.5 16 14.5"></polygon><path fill="currentColor" fill-rule="nonzero" d="M2.96551724,7.95245414 L2.96551724,14.5 L2,14.5 L2,7.53775146 L7.38172454,1.5 L16,1.5 L16,2.46 L7.76471206,2.46 L2.96551724,7.95245414 Z M10.9369913,9 C10.7561021,9.70280365 10.2028036,10.2561021 9.5,10.4369913 L9.5,14.5 L8.5,14.5 L8.5,10.4369913 C7.63738639,10.2149699 7,9.43191971 7,8.5 C7,7.3954305 7.8954305,6.5 9,6.5 C9.93191971,6.5 10.7149699,7.13738639 10.9369913,8 L16,8 L16,9 L10.9369913,9 Z"></path></g>`, { width: 18, height: 16 });
var __glob_0_127 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": line_join_bevel
});
var line_join_miter = _icon_template(`<g fill="none" fill-rule="evenodd"><rect class="base" width="14" height="13" x="2" y="1.5" fill="transparent" fill-rule="nonzero"></rect><path fill="currentColor" fill-rule="nonzero" d="M10.9369913,9 C10.7561021,9.70280365 10.2028036,10.2561021 9.5,10.4369913 L9.5,14.5 L8.5,14.5 L8.5,10.4369913 C7.63738639,10.2149699 7,9.43191971 7,8.5 C7,7.3954305 7.8954305,6.5 9,6.5 C9.93191971,6.5 10.7149699,7.13738639 10.9369913,8 L16,8 L16,9 L10.9369913,9 Z M3,2.5 L3,14.5 L2,14.5 L2,1.5 L16,1.5 L16,2.5 L3,2.5 Z"></path></g>`, { width: 18, height: 16 });
var __glob_0_128 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": line_join_miter
});
var line_join_round = _icon_template(`<g fill="none" fill-rule="evenodd"><path class="base" fill="transparent" fill-rule="nonzero" d="M9,1.5 L16,1.5 L16,14.5 L2,14.5 L2,8.5 C2,4.63400675 5.13400675,1.5 9,1.5 Z"></path><path fill="currentColor" fill-rule="nonzero" d="M2.96551724,14.5 L2,14.5 L2,7.74 C2,4.29374316 4.80979916,1.5 8.27586207,1.5 L16,1.5 L16,2.46 L8.27586207,2.46 C5.3430396,2.46 2.96551724,4.82393652 2.96551724,7.74 L2.96551724,14.5 Z M10.9369913,9 C10.7561021,9.70280365 10.2028036,10.2561021 9.5,10.4369913 L9.5,14.5 L8.5,14.5 L8.5,10.4369913 C7.63738639,10.2149699 7,9.43191971 7,8.5 C7,7.3954305 7.8954305,6.5 9,6.5 C9.93191971,6.5 10.7149699,7.13738639 10.9369913,8 L16,8 L16,9 L10.9369913,9 Z"></path></g>`, { width: 18, height: 16 });
var __glob_0_129 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": line_join_round
});
var line_style = _icon_template(`<path d="M3 16h5v-2H3v2zm6.5 0h5v-2h-5v2zm6.5 0h5v-2h-5v2zM3 20h2v-2H3v2zm4 0h2v-2H7v2zm4 0h2v-2h-2v2zm4 0h2v-2h-2v2zm4 0h2v-2h-2v2zM3 12h8v-2H3v2zm10 0h8v-2h-8v2zM3 4v4h18V4H3z"/>`);
var __glob_0_130 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": line_style
});
var line_weight = _icon_template(`<path d="M3 17h18v-2H3v2zm0 3h18v-1H3v1zm0-7h18v-3H3v3zm0-9v4h18V4H3z"/>`);
var __glob_0_131 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": line_weight
});
var list = _icon_template(`<path d="M4 14h4v-4H4v4zm0 5h4v-4H4v4zM4 9h4V5H4v4zm5 5h12v-4H9v4zm0 5h12v-4H9v4zM9 5v4h12V5H9z"/>`);
var __glob_0_132 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": list
});
var local_library = _icon_template(`<path d="M12 11.55C9.64 9.35 6.48 8 3 8v11c3.48 0 6.64 1.35 9 3.55 2.36-2.19 5.52-3.55 9-3.55V8c-3.48 0-6.64 1.35-9 3.55zM12 8c1.66 0 3-1.34 3-3s-1.34-3-3-3-3 1.34-3 3 1.34 3 3 3z"/>`);
var __glob_0_133 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": local_library
});
var local_movie = _icon_template(`<path d="M18 3v2h-2V3H8v2H6V3H4v18h2v-2h2v2h8v-2h2v2h2V3h-2zM8 17H6v-2h2v2zm0-4H6v-2h2v2zm0-4H6V7h2v2zm10 8h-2v-2h2v2zm0-4h-2v-2h2v2zm0-4h-2V7h2v2z"/>`);
var __glob_0_134 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": local_movie
});
var lock = _icon_template(`<path d="M18 8h-1V6c0-2.76-2.24-5-5-5S7 3.24 7 6v2H6c-1.1 0-2 .9-2 2v10c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V10c0-1.1-.9-2-2-2zm-6 9c-1.1 0-2-.9-2-2s.9-2 2-2 2 .9 2 2-.9 2-2 2zm3.1-9H8.9V6c0-1.71 1.39-3.1 3.1-3.1 1.71 0 3.1 1.39 3.1 3.1v2z"/>`);
var __glob_0_135 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": lock
});
var lock_open = _icon_template(`<path d="M12 17c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2zm6-9h-1V6c0-2.76-2.24-5-5-5S7 3.24 7 6h1.9c0-1.71 1.39-3.1 3.1-3.1 1.71 0 3.1 1.39 3.1 3.1v2H6c-1.1 0-2 .9-2 2v10c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V10c0-1.1-.9-2-2-2zm0 12H6V10h12v10z"/>`);
var __glob_0_136 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": lock_open
});
var looks = _icon_template(`<path d="M12 10c-3.86 0-7 3.14-7 7h2c0-2.76 2.24-5 5-5s5 2.24 5 5h2c0-3.86-3.14-7-7-7zm0-4C5.93 6 1 10.93 1 17h2c0-4.96 4.04-9 9-9s9 4.04 9 9h2c0-6.07-4.93-11-11-11z"/>`);
var __glob_0_137 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": looks
});
var margin = _icon_template(`<path d="M3,3v18h18V3H3z M19,19H5V5h14V19z M11,7h2v2h-2V7z M7,7h2v2H7V7z M15,7h2v2h-2V7z M7,11h2v2H7V11z M11,11h2v2h-2V11z M15,11h2v2h-2V11z"/>`);
var __glob_0_138 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": margin
});
var merge = _icon_template(`<path d="M17 20.41L18.41 19 15 15.59 13.59 17 17 20.41zM7.5 8H11v5.59L5.59 19 7 20.41l6-6V8h3.5L12 3.5 7.5 8z"/>`);
var __glob_0_139 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": merge
});
var middle = _icon_template(`<path d="M4,12 L20,12Z M10,8 L10,16 L14,16 L14,8Z" stroke-width="1" />`);
var __glob_0_140 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": middle
});
var navigation = _icon_template(`<path d="M12 2L4.5 20.29l.71.71L12 18l6.79 3 .71-.71z" transform="rotate(-30 12 12)" stroke-width="1" fill="transparent"/>`);
var __glob_0_141 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": navigation
});
var near_me = _icon_template(`<path d="M21 3L3 10.53v.98l6.84 2.65L12.48 21h.98L21 3z"/>`);
var __glob_0_142 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": near_me
});
var north = _icon_template(`<path d="M5,9l1.41,1.41L11,5.83V22H13V5.83l4.59,4.59L19,9l-7-7L5,9z"/>`);
var __glob_0_143 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": north
});
var note = _icon_template(`<path d="M17 10H7v2h10v-2zm2-7h-1V1h-2v2H8V1H6v2H5c-1.11 0-1.99.9-1.99 2L3 19c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm0 16H5V8h14v11zm-5-5H7v2h7v-2z"/>`);
var __glob_0_144 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": note
});
var nowrap = _icon_template(`<path d="M14 17H4v2h10v-2zm6-8H4v2h16V9zM4 15h16v-2H4v2zM4 5v2h16V5H4z"/>`);
var __glob_0_145 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": nowrap
});
var opacity = _icon_template(`<path d="M17.66 8L12 2.35 6.34 8C4.78 9.56 4 11.64 4 13.64s.78 4.11 2.34 5.67 3.61 2.35 5.66 2.35 4.1-.79 5.66-2.35S20 15.64 20 13.64 19.22 9.56 17.66 8zM6 14c.01-2 .62-3.27 1.76-4.4L12 5.27l4.24 4.38C17.38 10.77 17.99 12 18 14H6z"/>`);
var __glob_0_146 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": opacity
});
function open_in_full(transform2 = "") {
  return _icon_template(`
        <g transform='${transform2}'><path fill='#fff' d='M2.6 5.6L0 8.3 2.6 11l1.2-1.2-.5-.5h9.4l-.5.5 1.2 1.2L16 8.3l-2.6-2.7-1.2 1.2.5.5H3.3l.5-.5-1.2-1.2z'/><path fill='#231f20' d='M5.1 279h-4v1h5v-5h-1zm5 0v5h-5v1h5v5h1v-5h5v-1h-5v-5z'/><path fill='#fff' d='M.6 278.5h4v-4h2v6h-6zm4.5.5h-4v1h5v-5h-1zm4.5-.5h2v5h5v2h-5v5h-2v-5h-5v-2h5zm.5 5.5h-5v1h5v5h1v-5h5v-1h-5v-5h-1z'/><path fill='#000' d='M2.6 6.3l-2 2 2 2 .6-.5-1-1H14l-1 1 .5.5 2-2-2-2-.5.5 1 1H2.1l1-1-.5-.5z'/></g>
    `, { width: 24, height: 24, viewBoxWidth: 16, viewBoxHeight: 16 });
}
var __glob_0_147 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": open_in_full
});
var outline = _icon_template(`
    <path d="M19.77 4.93l1.4 1.4L8.43 19.07l-5.6-5.6 1.4-1.4 4.2 4.2L19.77 4.93m0-2.83L8.43 13.44l-4.2-4.2L0 13.47l8.43 8.43L24 6.33 19.77 2.1z"/>
`);
var __glob_0_148 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": outline
});
var outline_circle = _icon_template(`<path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8z"/>`);
var __glob_0_149 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": outline_circle
});
var outline_image = _icon_template(`<path d="M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm0 16H5V5h14v14zm-5.04-6.71l-2.75 3.54-1.96-2.36L6.5 17h11l-3.54-4.71z"/>`);
var __glob_0_150 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": outline_image
});
var outline_rect = _icon_template(`<path d="M19 5v14H5V5h14m0-2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2z"/>`);
var __glob_0_151 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": outline_rect
});
var outline_shape = _icon_template(`<path d="M2 12C2 6.48 6.48 2 12 2s10 4.48 10 10-4.48 10-10 10S2 17.52 2 12zm10 6c3.31 0 6-2.69 6-6s-2.69-6-6-6-6 2.69-6 6 2.69 6 6 6z"/>`);
var __glob_0_152 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": outline_shape
});
var padding = _icon_template(`<path d="M3 5h2V3c-1.1 0-2 .9-2 2zm0 8h2v-2H3v2zm4 8h2v-2H7v2zM3 9h2V7H3v2zm10-6h-2v2h2V3zm6 0v2h2c0-1.1-.9-2-2-2zM5 21v-2H3c0 1.1.9 2 2 2zm-2-4h2v-2H3v2zM9 3H7v2h2V3zm2 18h2v-2h-2v2zm8-8h2v-2h-2v2zm0 8c1.1 0 2-.9 2-2h-2v2zm0-12h2V7h-2v2zm0 8h2v-2h-2v2zm-4 4h2v-2h-2v2zm0-16h2V3h-2v2zM7 17h10V7H7v10zm2-8h6v6H9V9z"/>`);
var __glob_0_153 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": padding
});
var paint = _icon_template(`<path d="M18 4V3c0-.55-.45-1-1-1H5c-.55 0-1 .45-1 1v4c0 .55.45 1 1 1h12c.55 0 1-.45 1-1V6h1v4H9v11c0 .55.45 1 1 1h2c.55 0 1-.45 1-1v-9h8V4h-3z"/>`);
var __glob_0_154 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": paint
});
var palette = _icon_template(`<path d="M12 3c-4.97 0-9 4.03-9 9s4.03 9 9 9c.83 0 1.5-.67 1.5-1.5 0-.39-.15-.74-.39-1.01-.23-.26-.38-.61-.38-.99 0-.83.67-1.5 1.5-1.5H16c2.76 0 5-2.24 5-5 0-4.42-4.03-8-9-8zm-5.5 9c-.83 0-1.5-.67-1.5-1.5S5.67 9 6.5 9 8 9.67 8 10.5 7.33 12 6.5 12zm3-4C8.67 8 8 7.33 8 6.5S8.67 5 9.5 5s1.5.67 1.5 1.5S10.33 8 9.5 8zm5 0c-.83 0-1.5-.67-1.5-1.5S13.67 5 14.5 5s1.5.67 1.5 1.5S15.33 8 14.5 8zm3 4c-.83 0-1.5-.67-1.5-1.5S16.67 9 17.5 9s1.5.67 1.5 1.5-.67 1.5-1.5 1.5z"/>`);
var __glob_0_155 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": palette
});
var pantool = _icon_template(`<path d="M18 24h-6.55c-1.08 0-2.14-.45-2.89-1.23l-7.3-7.61 2.07-1.83c.62-.55 1.53-.66 2.26-.27L8 14.34V4.79c0-1.38 1.12-2.5 2.5-2.5.17 0 .34.02.51.05.09-1.3 1.17-2.33 2.49-2.33.86 0 1.61.43 2.06 1.09.29-.12.61-.18.94-.18 1.38 0 2.5 1.12 2.5 2.5v.28c.16-.03.33-.05.5-.05 1.38 0 2.5 1.12 2.5 2.5V20c0 2.21-1.79 4-4 4zM4.14 15.28l5.86 6.1c.38.39.9.62 1.44.62H18c1.1 0 2-.9 2-2V6.15c0-.28-.22-.5-.5-.5s-.5.22-.5.5V12h-2V3.42c0-.28-.22-.5-.5-.5s-.5.22-.5.5V12h-2V2.51c0-.28-.22-.5-.5-.5s-.5.22-.5.5V12h-2V4.79c0-.28-.22-.5-.5-.5s-.5.23-.5.5v12.87l-5.35-2.83-.51.45z"/>`);
var __glob_0_156 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": pantool
});
var pattern_check = _icon_template(`<path d="M4 8h4V4H4v4zm6 12h4v-4h-4v4zm-6 0h4v-4H4v4zm0-6h4v-4H4v4zm6 0h4v-4h-4v4zm6-10v4h4V4h-4zm-6 4h4V4h-4v4zm6 6h4v-4h-4v4zm0 6h4v-4h-4v4z"/>`);
var __glob_0_157 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": pattern_check
});
var pattern_cross_dot = _icon_template(`<path d="M6,13c-0.55,0-1,0.45-1,1s0.45,1,1,1s1-0.45,1-1S6.55,13,6,13z M6,17c-0.55,0-1,0.45-1,1s0.45,1,1,1s1-0.45,1-1 S6.55,17,6,17z M6,9c-0.55,0-1,0.45-1,1s0.45,1,1,1s1-0.45,1-1S6.55,9,6,9z M3,9.5c-0.28,0-0.5,0.22-0.5,0.5s0.22,0.5,0.5,0.5 s0.5-0.22,0.5-0.5S3.28,9.5,3,9.5z M6,5C5.45,5,5,5.45,5,6s0.45,1,1,1s1-0.45,1-1S6.55,5,6,5z M21,10.5c0.28,0,0.5-0.22,0.5-0.5 S21.28,9.5,21,9.5s-0.5,0.22-0.5,0.5S20.72,10.5,21,10.5z M14,7c0.55,0,1-0.45,1-1s-0.45-1-1-1s-1,0.45-1,1S13.45,7,14,7z M14,3.5 c0.28,0,0.5-0.22,0.5-0.5S14.28,2.5,14,2.5S13.5,2.72,13.5,3S13.72,3.5,14,3.5z M3,13.5c-0.28,0-0.5,0.22-0.5,0.5 s0.22,0.5,0.5,0.5s0.5-0.22,0.5-0.5S3.28,13.5,3,13.5z M10,20.5c-0.28,0-0.5,0.22-0.5,0.5s0.22,0.5,0.5,0.5s0.5-0.22,0.5-0.5 S10.28,20.5,10,20.5z M10,3.5c0.28,0,0.5-0.22,0.5-0.5S10.28,2.5,10,2.5S9.5,2.72,9.5,3S9.72,3.5,10,3.5z M10,7c0.55,0,1-0.45,1-1 s-0.45-1-1-1S9,5.45,9,6S9.45,7,10,7z M10,12.5c-0.83,0-1.5,0.67-1.5,1.5s0.67,1.5,1.5,1.5s1.5-0.67,1.5-1.5S10.83,12.5,10,12.5z M18,13c-0.55,0-1,0.45-1,1s0.45,1,1,1s1-0.45,1-1S18.55,13,18,13z M18,17c-0.55,0-1,0.45-1,1s0.45,1,1,1s1-0.45,1-1 S18.55,17,18,17z M18,9c-0.55,0-1,0.45-1,1s0.45,1,1,1s1-0.45,1-1S18.55,9,18,9z M18,5c-0.55,0-1,0.45-1,1s0.45,1,1,1s1-0.45,1-1 S18.55,5,18,5z M21,13.5c-0.28,0-0.5,0.22-0.5,0.5s0.22,0.5,0.5,0.5s0.5-0.22,0.5-0.5S21.28,13.5,21,13.5z M14,17 c-0.55,0-1,0.45-1,1s0.45,1,1,1s1-0.45,1-1S14.55,17,14,17z M14,20.5c-0.28,0-0.5,0.22-0.5,0.5s0.22,0.5,0.5,0.5s0.5-0.22,0.5-0.5 S14.28,20.5,14,20.5z M10,8.5c-0.83,0-1.5,0.67-1.5,1.5s0.67,1.5,1.5,1.5s1.5-0.67,1.5-1.5S10.83,8.5,10,8.5z M10,17 c-0.55,0-1,0.45-1,1s0.45,1,1,1s1-0.45,1-1S10.55,17,10,17z M14,12.5c-0.83,0-1.5,0.67-1.5,1.5s0.67,1.5,1.5,1.5s1.5-0.67,1.5-1.5 S14.83,12.5,14,12.5z M14,8.5c-0.83,0-1.5,0.67-1.5,1.5s0.67,1.5,1.5,1.5s1.5-0.67,1.5-1.5S14.83,8.5,14,8.5z"/>`);
var __glob_0_158 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": pattern_cross_dot
});
var pattern_dot = _icon_template(`<path d="M6,13c-0.55,0-1,0.45-1,1s0.45,1,1,1s1-0.45,1-1S6.55,13,6,13z M6,17c-0.55,0-1,0.45-1,1s0.45,1,1,1s1-0.45,1-1 S6.55,17,6,17z M6,9c-0.55,0-1,0.45-1,1s0.45,1,1,1s1-0.45,1-1S6.55,9,6,9z M3,9.5c-0.28,0-0.5,0.22-0.5,0.5s0.22,0.5,0.5,0.5 s0.5-0.22,0.5-0.5S3.28,9.5,3,9.5z M6,5C5.45,5,5,5.45,5,6s0.45,1,1,1s1-0.45,1-1S6.55,5,6,5z M21,10.5c0.28,0,0.5-0.22,0.5-0.5 S21.28,9.5,21,9.5s-0.5,0.22-0.5,0.5S20.72,10.5,21,10.5z M14,7c0.55,0,1-0.45,1-1s-0.45-1-1-1s-1,0.45-1,1S13.45,7,14,7z M14,3.5 c0.28,0,0.5-0.22,0.5-0.5S14.28,2.5,14,2.5S13.5,2.72,13.5,3S13.72,3.5,14,3.5z M3,13.5c-0.28,0-0.5,0.22-0.5,0.5 s0.22,0.5,0.5,0.5s0.5-0.22,0.5-0.5S3.28,13.5,3,13.5z M10,20.5c-0.28,0-0.5,0.22-0.5,0.5s0.22,0.5,0.5,0.5s0.5-0.22,0.5-0.5 S10.28,20.5,10,20.5z M10,3.5c0.28,0,0.5-0.22,0.5-0.5S10.28,2.5,10,2.5S9.5,2.72,9.5,3S9.72,3.5,10,3.5z M10,7c0.55,0,1-0.45,1-1 s-0.45-1-1-1S9,5.45,9,6S9.45,7,10,7z M10,12.5c-0.83,0-1.5,0.67-1.5,1.5s0.67,1.5,1.5,1.5s1.5-0.67,1.5-1.5S10.83,12.5,10,12.5z M18,13c-0.55,0-1,0.45-1,1s0.45,1,1,1s1-0.45,1-1S18.55,13,18,13z M18,17c-0.55,0-1,0.45-1,1s0.45,1,1,1s1-0.45,1-1 S18.55,17,18,17z M18,9c-0.55,0-1,0.45-1,1s0.45,1,1,1s1-0.45,1-1S18.55,9,18,9z M18,5c-0.55,0-1,0.45-1,1s0.45,1,1,1s1-0.45,1-1 S18.55,5,18,5z M21,13.5c-0.28,0-0.5,0.22-0.5,0.5s0.22,0.5,0.5,0.5s0.5-0.22,0.5-0.5S21.28,13.5,21,13.5z M14,17 c-0.55,0-1,0.45-1,1s0.45,1,1,1s1-0.45,1-1S14.55,17,14,17z M14,20.5c-0.28,0-0.5,0.22-0.5,0.5s0.22,0.5,0.5,0.5s0.5-0.22,0.5-0.5 S14.28,20.5,14,20.5z M10,8.5c-0.83,0-1.5,0.67-1.5,1.5s0.67,1.5,1.5,1.5s1.5-0.67,1.5-1.5S10.83,8.5,10,8.5z M10,17 c-0.55,0-1,0.45-1,1s0.45,1,1,1s1-0.45,1-1S10.55,17,10,17z M14,12.5c-0.83,0-1.5,0.67-1.5,1.5s0.67,1.5,1.5,1.5s1.5-0.67,1.5-1.5 S14.83,12.5,14,12.5z M14,8.5c-0.83,0-1.5,0.67-1.5,1.5s0.67,1.5,1.5,1.5s1.5-0.67,1.5-1.5S14.83,8.5,14,8.5z"/>`);
var __glob_0_159 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": pattern_dot
});
var pattern_grid = _icon_template(`<path d="M22,7V5h-3V2h-2v3h-4V2h-2v3H7V2H5v3H2v2h3v4H2v2h3v4H2v2h3v3h2v-3h4v3h2v-3h4v3h2v-3h3v-2h-3v-4h3v-2h-3V7H22z M7,7h4v4 H7V7z M7,17v-4h4v4H7z M17,17h-4v-4h4V17z M17,11h-4V7h4V11z"/>`);
var __glob_0_160 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": pattern_grid
});
var pattern_horizontal_line = _icon_template(`<path d="M3 15h18v-2H3v2zm0 4h18v-2H3v2zm0-8h18V9H3v2zm0-6v2h18V5H3z"/>`);
var __glob_0_161 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": pattern_horizontal_line
});
var pause = _icon_template(`<path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"/>`);
var __glob_0_162 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": pause
});
var pentool = _icon_template(`
    <g transform="translate(4.000003875248012, 4.000001937624006)">
        <path stroke="currentColor" d="M 7.501491970838878 -0.0000015572448855733659Q 14.336036333057622 7.389304433496911 15.674208571053226 11.025537025755131Q 17.012380809048864 14.661769618013372 12.854180922821438 14.544928811787997L 12.854180922821438 16.99999278410904L 3.2146550430021494 16.99999278410904L 3.2146550430021494 14.544928811787997Q -0.8480130988910353 14.661769618013372 0.22369613306813782 11.025537025755131Q 1.295405365027311 7.389304433496911 7.501491970838878 -0.0000015572448855733659Z M 7.501491970838878 -0.0000015572448855733659M 7.043097362212707 10.615180199186797L 7.043097362212707 2.029497238417552Q 2.4235653311211847 7.389304433496911 1.2143202542326725 11.099378313047254Q 0.22369613306813782 14.380813978493594 4.269842778971384 13.709709450113499L 4.269842778971384 16.233605781316655L 11.751764459057853 16.233605781316655L 11.751764459057853 13.709709450113499Q 15.84146041516868 14.140123940309786 14.670231046646997 10.775846698306177Q 14.195747591990225 9.593976493057127 8.077664264490855 2.029497238417552L 8.077664264490855 10.615180199186797L 7.043097362212707 10.615180199186797Z"/>
    </g>
`);
var __glob_0_163 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": pentool
});
var photo = _icon_template(`<path d="M21 19V5c0-1.1-.9-2-2-2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2zM8.5 13.5l2.5 3.01L14.5 12l4.5 6H5l3.5-4.5z"/>`);
var __glob_0_164 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": photo
});
var play = _icon_template(`<path d="M8 5v14l11-7z"/>`);
var __glob_0_165 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": play
});
var plugin = _icon_template(`<path d="M3 3h8v8H3zm10 0h8v8h-8zM3 13h8v8H3zm15 0h-2v3h-3v2h3v3h2v-3h3v-2h-3z"/>`);
var __glob_0_166 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": plugin
});
var polygon$1 = _icon_template(`<path d="M17.2,3H6.8l-5.2,9l5.2,9h10.4l5.2-9L17.2,3z M16.05,19H7.95l-4.04-7l4.04-7h8.09l4.04,7L16.05,19z"/>`);
var __glob_0_167 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": polygon$1
});
var power_input = _icon_template(`<path d="M2 9v2h19V9H2zm0 6h5v-2H2v2zm7 0h5v-2H9v2zm7 0h5v-2h-5v2z"/>`);
var __glob_0_168 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": power_input
});
var publish = _icon_template(`<path d="M5 4v2h14V4H5zm0 10h4v6h6v-6h4l-7-7-7 7z"/>`);
var __glob_0_169 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": publish
});
var rect$1 = _icon_template(`<path d="M19 3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2z"/>`);
var __glob_0_170 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": rect$1
});
var redo = _icon_template(`<path d="M18.4 10.6C16.55 8.99 14.15 8 11.5 8c-4.65 0-8.58 3.03-9.96 7.22L3.9 16c1.05-3.19 4.05-5.5 7.6-5.5 1.95 0 3.73.72 5.12 1.88L13 16h9V7l-3.6 3.6z"/>`);
var __glob_0_171 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": redo
});
var refresh = _icon_template(`<path d="M17.65 6.35C16.2 4.9 14.21 4 12 4c-4.42 0-7.99 3.58-7.99 8s3.57 8 7.99 8c3.73 0 6.84-2.55 7.73-6h-2.08c-.82 2.33-3.04 4-5.65 4-3.31 0-6-2.69-6-6s2.69-6 6-6c1.66 0 3.14.69 4.22 1.78L13 11h7V4l-2.35 2.35z"/>`);
var __glob_0_172 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": refresh
});
var remove = _icon_template(`<path d="M6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7H6v12zM19 4h-3.5l-1-1h-5l-1 1H5v2h14V4z"/>`);
var __glob_0_173 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": remove
});
var remove2 = _icon_template(`<path d="M19 13H5v-2h14v2z"/>`);
var __glob_0_174 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": remove2
});
var repeat = _icon_template(`<path d="M7 7h10v3l4-4-4-4v3H5v6h2V7zm10 10H7v-3l-4 4 4 4v-3h12v-6h-2v4z"/>`);
var __glob_0_175 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": repeat
});
var replay = _icon_template(`<defs><path id="a" d="M0 0h24v24H0V0z"/></defs><clipPath id="b"><use xlink:href="#a" overflow="visible"/></clipPath><path d="M12 5V1L7 6l5 5V7c3.3 0 6 2.7 6 6s-2.7 6-6 6-6-2.7-6-6H4c0 4.4 3.6 8 8 8s8-3.6 8-8-3.6-8-8-8zm-1.1 11H10v-3.3L9 13v-.7l1.8-.6h.1V16zm4.3-1.8c0 .3 0 .6-.1.8l-.3.6s-.3.3-.5.3-.4.1-.6.1-.4 0-.6-.1-.3-.2-.5-.3-.2-.3-.3-.6-.1-.5-.1-.8v-.7c0-.3 0-.6.1-.8l.3-.6s.3-.3.5-.3.4-.1.6-.1.4 0 .6.1c.2.1.3.2.5.3s.2.3.3.6.1.5.1.8v.7zm-.9-.8v-.5s-.1-.2-.1-.3-.1-.1-.2-.2-.2-.1-.3-.1-.2 0-.3.1l-.2.2s-.1.2-.1.3v2s.1.2.1.3.1.1.2.2.2.1.3.1.2 0 .3-.1l.2-.2s.1-.2.1-.3v-1.5z" clip-path="url(#b)"/>`);
var __glob_0_176 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": replay
});
var right = _icon_template(`<path d="M20,4 L20,20Z M6,10 L16,10 L16,14 L6,14Z" stroke-width="1" />`);
var __glob_0_177 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": right
});
var right_hide = _icon_template(`<path d="M5.59 7.41L10.18 12l-4.59 4.59L7 18l6-6-6-6zM16 6h2v12h-2z"/>`);
var __glob_0_178 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": right_hide
});
var rotate = _icon_template(`
        <path d="M7.11 8.53L5.7 7.11C4.8 8.27 4.24 9.61 4.07 11h2.02c.14-.87.49-1.72 1.02-2.47zM6.09 13H4.07c.17 1.39.72 2.73 1.62 3.89l1.41-1.42c-.52-.75-.87-1.59-1.01-2.47zm1.01 5.32c1.16.9 2.51 1.44 3.9 1.61V17.9c-.87-.15-1.71-.49-2.46-1.03L7.1 18.32zM13 4.07V1L8.45 5.55 13 10V6.09c2.84.48 5 2.94 5 5.91s-2.16 5.43-5 5.91v2.02c3.95-.49 7-3.85 7-7.93s-3.05-7.44-7-7.93z" stroke='white' stroke-width="0.5" />
    `);
var __glob_0_179 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": rotate
});
var rotate_left = _icon_template(`<path d="M7.11 8.53L5.7 7.11C4.8 8.27 4.24 9.61 4.07 11h2.02c.14-.87.49-1.72 1.02-2.47zM6.09 13H4.07c.17 1.39.72 2.73 1.62 3.89l1.41-1.42c-.52-.75-.87-1.59-1.01-2.47zm1.01 5.32c1.16.9 2.51 1.44 3.9 1.61V17.9c-.87-.15-1.71-.49-2.46-1.03L7.1 18.32zM13 4.07V1L8.45 5.55 13 10V6.09c2.84.48 5 2.94 5 5.91s-2.16 5.43-5 5.91v2.02c3.95-.49 7-3.85 7-7.93s-3.05-7.44-7-7.93z"/>`);
var __glob_0_180 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": rotate_left
});
var round = _icon_template(`<path d="M19 19h2v2h-2v-2zm0-2h2v-2h-2v2zM3 13h2v-2H3v2zm0 4h2v-2H3v2zm0-8h2V7H3v2zm0-4h2V3H3v2zm4 0h2V3H7v2zm8 16h2v-2h-2v2zm-4 0h2v-2h-2v2zm4 0h2v-2h-2v2zm-8 0h2v-2H7v2zm-4 0h2v-2H3v2zM21 8c0-2.76-2.24-5-5-5h-5v2h5c1.65 0 3 1.35 3 3v5h2V8z"/>`);
var __glob_0_181 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": round
});
var same_height = _icon_template(`
    <path d="M4,4 L20,4Z M4,20 L20,20Z M10,8 L10,16 L14,16 L14,8Z" stroke-width="1" />
`);
var __glob_0_182 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": same_height
});
var same_width = _icon_template(`
    <path d="M20,4 L20,20Z M2,4 L2,20Z M6,10 L16,10 L16,14 L6,14Z" stroke-width="1" />
`);
var __glob_0_183 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": same_width
});
var save = _icon_template(`<path d="M19 12v7H5v-7H3v7c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2v-7h-2zm-6 .67l2.59-2.58L17 11.5l-5 5-5-5 1.41-1.41L11 12.67V3h2z"/><path fill="none" d="M0 0h24v24H0z"/>`);
var __glob_0_184 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": save
});
var scatter = _icon_template(`<g fill="#010101"><circle cx="7" cy="14" r="3"/><circle cx="11" cy="6" r="3"/><circle cx="16.6" cy="17.6" r="3"/></g>`);
var __glob_0_185 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": scatter
});
var screen = _icon_template(`<path d="M7 14H5v5h5v-2H7v-3zm-2-4h2V7h3V5H5v5zm12 7h-3v2h5v-5h-2v3zM14 5v2h3v3h2V5h-5z"/>`);
var __glob_0_186 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": screen
});
var setting = _icon_template(`<path d="M15.95 10.78c.03-.25.05-.51.05-.78s-.02-.53-.06-.78l1.69-1.32c.15-.12.19-.34.1-.51l-1.6-2.77c-.1-.18-.31-.24-.49-.18l-1.99.8c-.42-.32-.86-.58-1.35-.78L12 2.34c-.03-.2-.2-.34-.4-.34H8.4c-.2 0-.36.14-.39.34l-.3 2.12c-.49.2-.94.47-1.35.78l-1.99-.8c-.18-.07-.39 0-.49.18l-1.6 2.77c-.1.18-.06.39.1.51l1.69 1.32c-.04.25-.07.52-.07.78s.02.53.06.78L2.37 12.1c-.15.12-.19.34-.1.51l1.6 2.77c.1.18.31.24.49.18l1.99-.8c.42.32.86.58 1.35.78l.3 2.12c.04.2.2.34.4.34h3.2c.2 0 .37-.14.39-.34l.3-2.12c.49-.2.94-.47 1.35-.78l1.99.8c.18.07.39 0 .49-.18l1.6-2.77c.1-.18.06-.39-.1-.51l-1.67-1.32zM10 13c-1.65 0-3-1.35-3-3s1.35-3 3-3 3 1.35 3 3-1.35 3-3 3z"/>`);
var __glob_0_187 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": setting
});
var settings_input_component = _icon_template(`<path d="M5 2c0-.55-.45-1-1-1s-1 .45-1 1v4H1v6h6V6H5V2zm4 14c0 1.3.84 2.4 2 2.82V23h2v-4.18c1.16-.41 2-1.51 2-2.82v-2H9v2zm-8 0c0 1.3.84 2.4 2 2.82V23h2v-4.18C6.16 18.4 7 17.3 7 16v-2H1v2zM21 6V2c0-.55-.45-1-1-1s-1 .45-1 1v4h-2v6h6V6h-2zm-8-4c0-.55-.45-1-1-1s-1 .45-1 1v4H9v6h6V6h-2V2zm4 14c0 1.3.84 2.4 2 2.82V23h2v-4.18c1.16-.41 2-1.51 2-2.82v-2h-6v2z"/>`);
var __glob_0_188 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": settings_input_component
});
var shadow$1 = _icon_template(`<path d="M15.96 10.29l-2.75 3.54-1.96-2.36L8.5 15h11l-3.54-4.71zM3 5H1v16c0 1.1.9 2 2 2h16v-2H3V5zm18-4H7c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V3c0-1.1-.9-2-2-2zm0 16H7V3h14v14z"/>`);
var __glob_0_189 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": shadow$1
});
var shape = _icon_template(`<path d="M23 7V1h-6v2H7V1H1v6h2v10H1v6h6v-2h10v2h6v-6h-2V7h2zM3 3h2v2H3V3zm2 18H3v-2h2v2zm12-2H7v-2H5V7h2V5h10v2h2v10h-2v2zm4 2h-2v-2h2v2zM19 5V3h2v2h-2z"/>`);
var __glob_0_190 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": shape
});
var shuffle = _icon_template(`<path d="M10.59 9.17L5.41 4 4 5.41l5.17 5.17 1.42-1.41zM14.5 4l2.04 2.04L4 18.59 5.41 20 17.96 7.46 20 9.5V4h-5.5zm.33 9.41l-1.41 1.41 3.13 3.13L14.5 20H20v-5.5l-2.04 2.04-3.13-3.13z"/>`);
var __glob_0_191 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": shuffle
});
var size = _icon_template(`<path d="M21 15h2v2h-2v-2zm0-4h2v2h-2v-2zm2 8h-2v2c1 0 2-1 2-2zM13 3h2v2h-2V3zm8 4h2v2h-2V7zm0-4v2h2c0-1-1-2-2-2zM1 7h2v2H1V7zm16-4h2v2h-2V3zm0 16h2v2h-2v-2zM3 3C2 3 1 4 1 5h2V3zm6 0h2v2H9V3zM5 3h2v2H5V3zm-4 8v8c0 1.1.9 2 2 2h12V11H1zm2 8l2.5-3.21 1.79 2.15 2.5-3.22L13 19H3z"/>`);
var __glob_0_192 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": size
});
var skip_next = _icon_template(`<path d="M6 18l8.5-6L6 6v12zM16 6v12h2V6h-2z"/>`);
var __glob_0_193 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": skip_next
});
var skip_prev = _icon_template(`<path d="M6 6h2v12H6zm3.5 6l8.5 6V6z"/>`);
var __glob_0_194 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": skip_prev
});
var smooth = _icon_template(`<path d="M4.59 6.89c.7-.71 1.4-1.35 1.71-1.22.5.2 0 1.03-.3 1.52-.25.42-2.86 3.89-2.86 6.31 0 1.28.48 2.34 1.34 2.98.75.56 1.74.73 2.64.46 1.07-.31 1.95-1.4 3.06-2.77 1.21-1.49 2.83-3.44 4.08-3.44 1.63 0 1.65 1.01 1.76 1.79-3.78.64-5.38 3.67-5.38 5.37 0 1.7 1.44 3.09 3.21 3.09 1.63 0 4.29-1.33 4.69-6.1H21v-2.5h-2.47c-.15-1.65-1.09-4.2-4.03-4.2-2.25 0-4.18 1.91-4.94 2.84-.58.73-2.06 2.48-2.29 2.72-.25.3-.68.84-1.11.84-.45 0-.72-.83-.36-1.92.35-1.09 1.4-2.86 1.85-3.52.78-1.14 1.3-1.92 1.3-3.28C8.95 3.69 7.31 3 6.44 3 5.12 3 3.97 4 3.72 4.25c-.36.36-.66.66-.88.93l1.75 1.71zm9.29 11.66c-.31 0-.74-.26-.74-.72 0-.6.73-2.2 2.87-2.76-.3 2.69-1.43 3.48-2.13 3.48z"/>`);
var __glob_0_195 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": smooth
});
var source = _icon_template(`<path d="M20,6h-8l-2-2H4C2.9,4,2.01,4.9,2.01,6L2,18c0,1.1,0.9,2,2,2h16c1.1,0,2-0.9,2-2V8C22,6.9,21.1,6,20,6z M20,18L4,18V6h5.17 l2,2H20V18z M18,12H6v-2h12V12z M14,16H6v-2h8V16z"/>`);
var __glob_0_196 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": source
});
var south = _icon_template(`<path d="M19,15l-1.41-1.41L13,18.17V2H11v16.17l-4.59-4.59L5,15l7,7L19,15z"/>`);
var __glob_0_197 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": south
});
var space = _icon_template(`<path d="M18 9v4H6V9H4v6h16V9h-2z"/>`);
var __glob_0_198 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": space
});
var specular = _icon_template(`<path d="M3.55 18.54l1.41 1.41 1.79-1.8-1.41-1.41-1.79 1.8zM11 22.45h2V19.5h-2v2.95zM4 10.5H1v2h3v-2zm11-4.19V1.5H9v4.81C7.21 7.35 6 9.28 6 11.5c0 3.31 2.69 6 6 6s6-2.69 6-6c0-2.22-1.21-4.15-3-5.19zm5 4.19v2h3v-2h-3zm-2.76 7.66l1.79 1.8 1.41-1.41-1.8-1.79-1.4 1.4z"/>`);
var __glob_0_199 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": specular
});
var speed = _icon_template(`<path d="M20.38 8.57l-1.23 1.85a8 8 0 0 1-.22 7.58H5.07A8 8 0 0 1 15.58 6.85l1.85-1.23A10 10 0 0 0 3.35 19a2 2 0 0 0 1.72 1h13.85a2 2 0 0 0 1.74-1 10 10 0 0 0-.27-10.44zm-9.79 6.84a2 2 0 0 0 2.83 0l5.66-8.49-8.49 5.66a2 2 0 0 0 0 2.83z"/>`);
var __glob_0_200 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": speed
});
var star = _icon_template(`<path d="M22 9.24l-7.19-.62L12 2 9.19 8.63 2 9.24l5.46 4.73L5.82 21 12 17.27 18.18 21l-1.63-7.03L22 9.24zM12 15.4l-3.76 2.27 1-4.28-3.32-2.88 4.38-.38L12 6.1l1.71 4.04 4.38.38-3.32 2.88 1 4.28L12 15.4z"/>`);
var __glob_0_201 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": star
});
var start$1 = _icon_template(`<path d="M14.59,7.41L18.17,11H6v2h12.17l-3.59,3.59L16,18l6-6l-6-6L14.59,7.41z M2,6v12h2V6H2z"/>`);
var __glob_0_202 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": start$1
});
var storage = _icon_template(`<path d="M2 20h20v-4H2v4zm2-3h2v2H4v-2zM2 4v4h20V4H2zm4 3H4V5h2v2zm-4 7h20v-4H2v4zm2-3h2v2H4v-2z"/>`);
var __glob_0_203 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": storage
});
var straighten = _icon_template(`<path d="M21 6H3c-1.1 0-2 .9-2 2v8c0 1.1.9 2 2 2h18c1.1 0 2-.9 2-2V8c0-1.1-.9-2-2-2zm0 10H3V8h2v4h2V8h2v4h2V8h2v4h2V8h2v4h2V8h2v8z"/>`);
var __glob_0_204 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": straighten
});
var strikethrough = _icon_template(`<defs><path id="a" d="M0 0h24v24H0V0z"/></defs><clipPath id="b"><use xlink:href="#a" overflow="visible"/></clipPath><path clip-path="url(#b)" d="M7.24 8.75c-.26-.48-.39-1.03-.39-1.67 0-.61.13-1.16.4-1.67.26-.5.63-.93 1.11-1.29.48-.35 1.05-.63 1.7-.83.66-.19 1.39-.29 2.18-.29.81 0 1.54.11 2.21.34.66.22 1.23.54 1.69.94.47.4.83.88 1.08 1.43.25.55.38 1.15.38 1.81h-3.01c0-.31-.05-.59-.15-.85-.09-.27-.24-.49-.44-.68-.2-.19-.45-.33-.75-.44-.3-.1-.66-.16-1.06-.16-.39 0-.74.04-1.03.13-.29.09-.53.21-.72.36-.19.16-.34.34-.44.55-.1.21-.15.43-.15.66 0 .48.25.88.74 1.21.38.25.77.48 1.41.7H7.39c-.05-.08-.11-.17-.15-.25zM21 12v-2H3v2h9.62c.18.07.4.14.55.2.37.17.66.34.87.51.21.17.35.36.43.57.07.2.11.43.11.69 0 .23-.05.45-.14.66-.09.2-.23.38-.42.53-.19.15-.42.26-.71.35-.29.08-.63.13-1.01.13-.43 0-.83-.04-1.18-.13s-.66-.23-.91-.42c-.25-.19-.45-.44-.59-.75-.14-.31-.25-.76-.25-1.21H6.4c0 .55.08 1.13.24 1.58.16.45.37.85.65 1.21.28.35.6.66.98.92.37.26.78.48 1.22.65.44.17.9.3 1.38.39.48.08.96.13 1.44.13.8 0 1.53-.09 2.18-.28s1.21-.45 1.67-.79c.46-.34.82-.77 1.07-1.27s.38-1.07.38-1.71c0-.6-.1-1.14-.31-1.61-.05-.11-.11-.23-.17-.33H21z"/>`);
var __glob_0_205 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": strikethrough
});
var stroke_to_path = _icon_template(`<path d="M20 4h-4l-4-4-4 4H4c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2zm0 16H4V6h4.52l3.52-3.5L15.52 6H20v14zM6 18h12V8H6v10zm2-8h8v6H8v-6z"/>`);
var __glob_0_206 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": stroke_to_path
});
var swap_horiz = _icon_template(`<path d="M6.99 11L3 15l3.99 4v-3H14v-2H6.99v-3zM21 9l-3.99-4v3H10v2h7.01v3L21 9z"/>`);
var __glob_0_207 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": swap_horiz
});
var switch_left = _icon_template(`<path d="M8.5,8.62v6.76L5.12,12L8.5,8.62 M10,5l-7,7l7,7V5L10,5z M14,5v14l7-7L14,5z"/>`);
var __glob_0_208 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": switch_left
});
var switch_right = _icon_template(`<path d="M15.5,15.38V8.62L18.88,12L15.5,15.38 M14,19l7-7l-7-7V19L14,19z M10,19V5l-7,7L10,19z"/>`);
var __glob_0_209 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": switch_right
});
var sync = _icon_template(`<path d="M12 4V1L8 5l4 4V6c3.31 0 6 2.69 6 6 0 1.01-.25 1.97-.7 2.8l1.46 1.46C19.54 15.03 20 13.57 20 12c0-4.42-3.58-8-8-8zm0 14c-3.31 0-6-2.69-6-6 0-1.01.25-1.97.7-2.8L5.24 7.74C4.46 8.97 4 10.43 4 12c0 4.42 3.58 8 8 8v3l4-4-4-4v3z"/>`);
var __glob_0_210 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": sync
});
var table_rows = _icon_template(`<path d="M19,3H5C3.9,3,3,3.9,3,5v14c0,1.1,0.9,2,2,2h14c1.1,0,2-0.9,2-2V5C21,3.9,20.1,3,19,3z M19,5v3H5V5H19z M19,10v4H5v-4H19z M5,19v-3h14v3H5z"/>`);
var __glob_0_211 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": table_rows
});
var text_rotate = _icon_template(`<path d="M12.75 3h-1.5L6.5 14h2.1l.9-2.2h5l.9 2.2h2.1L12.75 3zm-2.62 7L12 4.98 13.87 10h-3.74zm10.37 8l-3-3v2H5v2h12.5v2l3-3z"/>`);
var __glob_0_212 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": text_rotate
});
var texture$1 = _icon_template(`<path d="M19.51 3.08L3.08 19.51c.09.34.27.65.51.9.25.24.56.42.9.51L20.93 4.49c-.19-.69-.73-1.23-1.42-1.41zM11.88 3L3 11.88v2.83L14.71 3h-2.83zM5 3c-1.1 0-2 .9-2 2v2l4-4H5zm14 18c.55 0 1.05-.22 1.41-.59.37-.36.59-.86.59-1.41v-2l-4 4h2zm-9.71 0h2.83L21 12.12V9.29L9.29 21z"/>`);
var __glob_0_213 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": texture$1
});
var timer = _icon_template(`<path d="M15 1H9v2h6V1zm-4 13h2V8h-2v6zm8.03-6.61l1.42-1.42c-.43-.51-.9-.99-1.41-1.41l-1.42 1.42C16.07 4.74 14.12 4 12 4c-4.97 0-9 4.03-9 9s4.02 9 9 9 9-4.03 9-9c0-2.12-.74-4.07-1.97-5.61zM12 20c-3.87 0-7-3.13-7-7s3.13-7 7-7 7 3.13 7 7-3.13 7-7 7z"/>`);
var __glob_0_214 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": timer
});
var title = _icon_template(`<path d="M5 4v3h5.5v12h3V7H19V4z"/>`);
var __glob_0_215 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": title
});
var to_back = _icon_template(`<path d="M 7 7L 22 7L 22 22L 7 22L 7 7Z" style="fill:white !important;"/><path d="M 0 0L 14 0L 14 14L 0 14L 0 0Z M 16 16L 30 16L 30 30L 16 30L 16 16Z"/>`, { width: 30, height: 30 });
var __glob_0_216 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": to_back
});
var to_front = _icon_template(`<path d="M 0 0L 14 0L 14 14L 0 14L 0 0Z M 16 16L 30 16L 30 30L 16 30L 16 16Z"/><path d="M 7 7L 22 7L 22 22L 7 22L 7 7Z" style="fill:white !important;"/>`, { width: 30, height: 30 });
var __glob_0_217 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": to_front
});
var tonality = _icon_template(`<path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-1 17.93c-3.94-.49-7-3.85-7-7.93s3.05-7.44 7-7.93v15.86zm2-15.86c1.03.13 2 .45 2.87.93H13v-.93zM13 7h5.24c.25.31.48.65.68 1H13V7zm0 3h6.74c.08.33.15.66.19 1H13v-1zm0 9.93V19h2.87c-.87.48-1.84.8-2.87.93zM18.24 17H13v-1h5.92c-.2.35-.43.69-.68 1zm1.5-3H13v-1h6.93c-.04.34-.11.67-.19 1z"/>`);
var __glob_0_218 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": tonality
});
var top = _icon_template(`<path d="M4,4 L20,4Z M10,8 L10,16 L14,16 L14,8Z" stroke-width="1" />`);
var __glob_0_219 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": top
});
var transform$1 = _icon_template(`<path d="M22 18v-2H8V4h2L7 1 4 4h2v2H2v2h4v8c0 1.1.9 2 2 2h8v2h-2l3 3 3-3h-2v-2h4zM10 8h6v6h2V8c0-1.1-.9-2-2-2h-6v2z"/>`);
var __glob_0_220 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": transform$1
});
var underline = _icon_template(`<path d="M12 17c3.31 0 6-2.69 6-6V3h-2.5v8c0 1.93-1.57 3.5-3.5 3.5S8.5 12.93 8.5 11V3H6v8c0 3.31 2.69 6 6 6zm-7 2v2h14v-2H5z"/>`);
var __glob_0_221 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": underline
});
var undo = _icon_template(`<path d="M12.5 8c-2.65 0-5.05.99-6.9 2.6L2 7v9h9l-3.62-3.62c1.39-1.16 3.16-1.88 5.12-1.88 3.54 0 6.55 2.31 7.6 5.5l2.37-.78C21.08 11.03 17.15 8 12.5 8z"/>`);
var __glob_0_222 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": undo
});
var unfold = _icon_template(`<path d="M12 5.83L15.17 9l1.41-1.41L12 3 7.41 7.59 8.83 9 12 5.83zm0 12.34L8.83 15l-1.41 1.41L12 21l4.59-4.59L15.17 15 12 18.17z"/>`);
var __glob_0_223 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": unfold
});
var vertical_align_baseline = _icon_template(`<path d="M16,18v2H8v-2H16z M11,7.99V16h2V7.99h3L12,4L8,7.99H11z"/>`);
var __glob_0_224 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": vertical_align_baseline
});
var vertical_align_bottom = _icon_template(`<path d="M16 13h-3V3h-2v10H8l4 4 4-4zM4 19v2h16v-2H4z"/>`);
var __glob_0_225 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": vertical_align_bottom
});
var vertical_align_center = _icon_template(`<path d="M8 19h3v4h2v-4h3l-4-4-4 4zm8-14h-3V1h-2v4H8l4 4 4-4zM4 11v2h16v-2H4z"/>`);
var __glob_0_226 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": vertical_align_center
});
var vertical_align_stretch = _icon_template(`
    <path d="M19,13H5c-1.1,0-2,0.9-2,2v4c0,1.1,0.9,2,2,2h14c1.1,0,2-0.9,2-2v-4C21,13.9,20.1,13,19,13z M19,19H5v-4h14V19z"/>
    <path d="M19,3H5C3.9,3,3,3.9,3,5v4c0,1.1,0.9,2,2,2h14c1.1,0,2-0.9,2-2V5C21,3.9,20.1,3,19,3z M19,9H5V5h14V9z"/>
`);
var __glob_0_227 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": vertical_align_stretch
});
var vertical_align_top = _icon_template(`<path d="M8 11h3v10h2V11h3l-4-4-4 4zM4 3v2h16V3H4z"/>`);
var __glob_0_228 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": vertical_align_top
});
var vertical_distribute = _icon_template(`<path d="M22,2v2H2V2H22z M7,10.5v3h10v-3H7z M2,20v2h20v-2H2z"/>`);
var __glob_0_229 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": vertical_distribute
});
var video$1 = _icon_template(`
        <path d="M17 10.5V7c0-.55-.45-1-1-1H4c-.55 0-1 .45-1 1v10c0 .55.45 1 1 1h12c.55 0 1-.45 1-1v-3.5l4 4v-11l-4 4z"/>
    `);
var __glob_0_230 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": video$1
});
var view_comfy = _icon_template(`<path d="M3 9h4V5H3v4zm0 5h4v-4H3v4zm5 0h4v-4H8v4zm5 0h4v-4h-4v4zM8 9h4V5H8v4zm5-4v4h4V5h-4zm5 9h4v-4h-4v4zM3 19h4v-4H3v4zm5 0h4v-4H8v4zm5 0h4v-4h-4v4zm5 0h4v-4h-4v4zm0-14v4h4V5h-4z"/>`);
var __glob_0_231 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": view_comfy
});
var view_list = _icon_template(`<path d="M4 14h4v-4H4v4zm0 5h4v-4H4v4zM4 9h4V5H4v4zm5 5h12v-4H9v4zm0 5h12v-4H9v4zM9 5v4h12V5H9z"/>`);
var __glob_0_232 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": view_list
});
var view_week = _icon_template(`<path d="M20,4H4C2.9,4,2,4.9,2,6v12c0,1.1,0.9,2,2,2h16c1.1,0,2-0.9,2-2V6C22,4.9,21.1,4,20,4z M8,18H4V6h4V18z M14,18h-4V6h4V18z M20,18h-4V6h4V18z"/>`);
var __glob_0_233 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": view_week
});
var view_week_reverse = _icon_template(`<path d="M20,4H4C2.9,4,2,4.9,2,6v12c0,1.1,0.9,2,2,2h16c1.1,0,2-0.9,2-2V6C22,4.9,21.1,4,20,4z M8,18H4V6h4V18z M14,18h-4V6h4V18z M20,18h-4V6h4V18z M0,12 L24,12"/>`);
var __glob_0_234 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": view_week_reverse
});
var vignette = _icon_template(`<path d="M21 3H3c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h18c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-9 15c-4.42 0-8-2.69-8-6s3.58-6 8-6 8 2.69 8 6-3.58 6-8 6z"/>`);
var __glob_0_235 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": vignette
});
var vintage = _icon_template(`<path d="M18.7 12.4c-.28-.16-.57-.29-.86-.4.29-.11.58-.24.86-.4 1.92-1.11 2.99-3.12 3-5.19-1.79-1.03-4.07-1.11-6 0-.28.16-.54.35-.78.54.05-.31.08-.63.08-.95 0-2.22-1.21-4.15-3-5.19C10.21 1.85 9 3.78 9 6c0 .32.03.64.08.95-.24-.2-.5-.39-.78-.55-1.92-1.11-4.2-1.03-6 0 0 2.07 1.07 4.08 3 5.19.28.16.57.29.86.4-.29.11-.58.24-.86.4-1.92 1.11-2.99 3.12-3 5.19 1.79 1.03 4.07 1.11 6 0 .28-.16.54-.35.78-.54-.05.32-.08.64-.08.96 0 2.22 1.21 4.15 3 5.19 1.79-1.04 3-2.97 3-5.19 0-.32-.03-.64-.08-.95.24.2.5.38.78.54 1.92 1.11 4.2 1.03 6 0-.01-2.07-1.08-4.08-3-5.19zM12 16c-2.21 0-4-1.79-4-4s1.79-4 4-4 4 1.79 4 4-1.79 4-4 4z"/>`);
var __glob_0_236 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": vintage
});
var visible = _icon_template(`<path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>`);
var __glob_0_237 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": visible
});
var volume_down = _icon_template(`
        <path d="M18.5 12c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02zM5 9v6h4l5 5V4L9 9H5z"/>
    `);
var __glob_0_238 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": volume_down
});
var volume_off = _icon_template(`
    <path d="M16.5 12c0-1.77-1.02-3.29-2.5-4.03v2.21l2.45 2.45c.03-.2.05-.41.05-.63zm2.5 0c0 .94-.2 1.82-.54 2.64l1.51 1.51C20.63 14.91 21 13.5 21 12c0-4.28-2.99-7.86-7-8.77v2.06c2.89.86 5 3.54 5 6.71zM4.27 3L3 4.27 7.73 9H3v6h4l5 5v-6.73l4.25 4.25c-.67.52-1.42.93-2.25 1.18v2.06c1.38-.31 2.63-.95 3.69-1.81L19.73 21 21 19.73l-9-9L4.27 3zM12 4L9.91 6.09 12 8.18V4z"/>
`);
var __glob_0_239 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": volume_off
});
var volume_up = _icon_template(`
    <path d="M3 9v6h4l5 5V4L7 9H3zm13.5 3c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02zM14 3.23v2.06c2.89.86 5 3.54 5 6.71s-2.11 5.85-5 6.71v2.06c4.01-.91 7-4.49 7-8.77s-2.99-7.86-7-8.77z"/>
`);
var __glob_0_240 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": volume_up
});
var wave = _icon_template(`<path d="M17 16.99c-1.35 0-2.2.42-2.95.8-.65.33-1.18.6-2.05.6-.9 0-1.4-.25-2.05-.6-.75-.38-1.57-.8-2.95-.8s-2.2.42-2.95.8c-.65.33-1.17.6-2.05.6v1.95c1.35 0 2.2-.42 2.95-.8.65-.33 1.17-.6 2.05-.6s1.4.25 2.05.6c.75.38 1.57.8 2.95.8s2.2-.42 2.95-.8c.65-.33 1.18-.6 2.05-.6.9 0 1.4.25 2.05.6.75.38 1.58.8 2.95.8v-1.95c-.9 0-1.4-.25-2.05-.6-.75-.38-1.6-.8-2.95-.8zm0-4.45c-1.35 0-2.2.43-2.95.8-.65.32-1.18.6-2.05.6-.9 0-1.4-.25-2.05-.6-.75-.38-1.57-.8-2.95-.8s-2.2.43-2.95.8c-.65.32-1.17.6-2.05.6v1.95c1.35 0 2.2-.43 2.95-.8.65-.35 1.15-.6 2.05-.6s1.4.25 2.05.6c.75.38 1.57.8 2.95.8s2.2-.43 2.95-.8c.65-.35 1.15-.6 2.05-.6s1.4.25 2.05.6c.75.38 1.58.8 2.95.8v-1.95c-.9 0-1.4-.25-2.05-.6-.75-.38-1.6-.8-2.95-.8zm2.95-8.08c-.75-.38-1.58-.8-2.95-.8s-2.2.42-2.95.8c-.65.32-1.18.6-2.05.6-.9 0-1.4-.25-2.05-.6-.75-.37-1.57-.8-2.95-.8s-2.2.42-2.95.8c-.65.33-1.17.6-2.05.6v1.93c1.35 0 2.2-.43 2.95-.8.65-.33 1.17-.6 2.05-.6s1.4.25 2.05.6c.75.38 1.57.8 2.95.8s2.2-.43 2.95-.8c.65-.32 1.18-.6 2.05-.6.9 0 1.4.25 2.05.6.75.38 1.58.8 2.95.8V5.04c-.9 0-1.4-.25-2.05-.58zM17 8.09c-1.35 0-2.2.43-2.95.8-.65.35-1.15.6-2.05.6s-1.4-.25-2.05-.6c-.75-.38-1.57-.8-2.95-.8s-2.2.43-2.95.8c-.65.35-1.15.6-2.05.6v1.95c1.35 0 2.2-.43 2.95-.8.65-.32 1.18-.6 2.05-.6s1.4.25 2.05.6c.75.38 1.57.8 2.95.8s2.2-.43 2.95-.8c.65-.32 1.18-.6 2.05-.6.9 0 1.4.25 2.05.6.75.38 1.58.8 2.95.8V9.49c-.9 0-1.4-.25-2.05-.6-.75-.38-1.6-.8-2.95-.8z"/>`);
var __glob_0_241 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": wave
});
var waves = _icon_template(`<path d="M17 16.99c-1.35 0-2.2.42-2.95.8-.65.33-1.18.6-2.05.6-.9 0-1.4-.25-2.05-.6-.75-.38-1.57-.8-2.95-.8s-2.2.42-2.95.8c-.65.33-1.17.6-2.05.6v1.95c1.35 0 2.2-.42 2.95-.8.65-.33 1.17-.6 2.05-.6s1.4.25 2.05.6c.75.38 1.57.8 2.95.8s2.2-.42 2.95-.8c.65-.33 1.18-.6 2.05-.6.9 0 1.4.25 2.05.6.75.38 1.58.8 2.95.8v-1.95c-.9 0-1.4-.25-2.05-.6-.75-.38-1.6-.8-2.95-.8zm0-4.45c-1.35 0-2.2.43-2.95.8-.65.32-1.18.6-2.05.6-.9 0-1.4-.25-2.05-.6-.75-.38-1.57-.8-2.95-.8s-2.2.43-2.95.8c-.65.32-1.17.6-2.05.6v1.95c1.35 0 2.2-.43 2.95-.8.65-.35 1.15-.6 2.05-.6s1.4.25 2.05.6c.75.38 1.57.8 2.95.8s2.2-.43 2.95-.8c.65-.35 1.15-.6 2.05-.6s1.4.25 2.05.6c.75.38 1.58.8 2.95.8v-1.95c-.9 0-1.4-.25-2.05-.6-.75-.38-1.6-.8-2.95-.8zm2.95-8.08c-.75-.38-1.58-.8-2.95-.8s-2.2.42-2.95.8c-.65.32-1.18.6-2.05.6-.9 0-1.4-.25-2.05-.6-.75-.37-1.57-.8-2.95-.8s-2.2.42-2.95.8c-.65.33-1.17.6-2.05.6v1.93c1.35 0 2.2-.43 2.95-.8.65-.33 1.17-.6 2.05-.6s1.4.25 2.05.6c.75.38 1.57.8 2.95.8s2.2-.43 2.95-.8c.65-.32 1.18-.6 2.05-.6.9 0 1.4.25 2.05.6.75.38 1.58.8 2.95.8V5.04c-.9 0-1.4-.25-2.05-.58zM17 8.09c-1.35 0-2.2.43-2.95.8-.65.35-1.15.6-2.05.6s-1.4-.25-2.05-.6c-.75-.38-1.57-.8-2.95-.8s-2.2.43-2.95.8c-.65.35-1.15.6-2.05.6v1.95c1.35 0 2.2-.43 2.95-.8.65-.32 1.18-.6 2.05-.6s1.4.25 2.05.6c.75.38 1.57.8 2.95.8s2.2-.43 2.95-.8c.65-.32 1.18-.6 2.05-.6.9 0 1.4.25 2.05.6.75.38 1.58.8 2.95.8V9.49c-.9 0-1.4-.25-2.05-.6-.75-.38-1.6-.8-2.95-.8z"/>`);
var __glob_0_242 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": waves
});
var web = _icon_template(`<path d="M20 4H4c-1.1 0-1.99.9-1.99 2L2 18c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2zm-5 14H4v-4h11v4zm0-5H4V9h11v4zm5 5h-4V9h4v9z"/>`);
var __glob_0_243 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": web
});
var west = _icon_template(`<path d="M9,19l1.41-1.41L5.83,13H22V11H5.83l4.59-4.59L9,5l-7,7L9,19z"/>`);
var __glob_0_244 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": west
});
var width$1 = _icon_template(`<polygon transform="rotate(90 12 12)" points="13,6.99 16,6.99 12,3 8,6.99 11,6.99 11,17.01 8,17.01 12,21 16,17.01 13,17.01"/>`);
var __glob_0_245 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": width$1
});
var wrap = _icon_template(`<path d="M11 9l1.42 1.42L8.83 14H18V4h2v12H8.83l3.59 3.58L11 21l-6-6 6-6z"/>`);
var __glob_0_246 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": wrap
});
var wrap_text = _icon_template(`<path d="M4 19h6v-2H4v2zM20 5H4v2h16V5zm-3 6H4v2h13.25c1.1 0 2 .9 2 2s-.9 2-2 2H15v-2l-3 3 3 3v-2h2c2.21 0 4-1.79 4-4s-1.79-4-4-4z"/>`);
var __glob_0_247 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": wrap_text
});
const modules$2 = { "./icon_list/_icon_template.js": __glob_0_0$2, "./icon_list/account_tree.js": __glob_0_1$2, "./icon_list/add.js": __glob_0_2$2, "./icon_list/add_box.js": __glob_0_3$2, "./icon_list/add_circle.js": __glob_0_4$2, "./icon_list/add_note.js": __glob_0_5$2, "./icon_list/align_center.js": __glob_0_6$2, "./icon_list/align_horizontal_center.js": __glob_0_7$2, "./icon_list/align_horizontal_left.js": __glob_0_8$2, "./icon_list/align_horizontal_right.js": __glob_0_9$2, "./icon_list/align_justify.js": __glob_0_10$2, "./icon_list/align_left.js": __glob_0_11$2, "./icon_list/align_right.js": __glob_0_12$2, "./icon_list/align_vertical_bottom.js": __glob_0_13$2, "./icon_list/align_vertical_center.js": __glob_0_14$2, "./icon_list/align_vertical_top.js": __glob_0_15$2, "./icon_list/alternate.js": __glob_0_16$2, "./icon_list/alternate_reverse.js": __glob_0_17$2, "./icon_list/apps.js": __glob_0_18$2, "./icon_list/archive.js": __glob_0_19$2, "./icon_list/arrowLeft.js": __glob_0_20$2, "./icon_list/arrowRight.js": __glob_0_21$1, "./icon_list/arrow_right.js": __glob_0_22$1, "./icon_list/artboard.js": __glob_0_23$1, "./icon_list/auto_awesome.js": __glob_0_24, "./icon_list/autorenew.js": __glob_0_25, "./icon_list/ballot.js": __glob_0_26, "./icon_list/bar_chart.js": __glob_0_27, "./icon_list/blur.js": __glob_0_28, "./icon_list/blur_linear.js": __glob_0_29, "./icon_list/boolean_difference.js": __glob_0_30, "./icon_list/boolean_intersection.js": __glob_0_31, "./icon_list/boolean_union.js": __glob_0_32, "./icon_list/boolean_xor.js": __glob_0_33, "./icon_list/border_all.js": __glob_0_34, "./icon_list/border_inner.js": __glob_0_35, "./icon_list/border_style.js": __glob_0_36, "./icon_list/bottom.js": __glob_0_37, "./icon_list/broken_image.js": __glob_0_38, "./icon_list/brush.js": __glob_0_39, "./icon_list/build.js": __glob_0_40, "./icon_list/camera_roll.js": __glob_0_41, "./icon_list/cat.js": __glob_0_42, "./icon_list/center.js": __glob_0_43, "./icon_list/chart.js": __glob_0_44, "./icon_list/check.js": __glob_0_45, "./icon_list/chevron_left.js": __glob_0_46, "./icon_list/chevron_right.js": __glob_0_47, "./icon_list/circle.js": __glob_0_48, "./icon_list/close.js": __glob_0_49, "./icon_list/code.js": __glob_0_50, "./icon_list/color.js": __glob_0_51, "./icon_list/color_lens.js": __glob_0_52, "./icon_list/control_point.js": __glob_0_53, "./icon_list/copy.js": __glob_0_54, "./icon_list/create_folder.js": __glob_0_55, "./icon_list/cube.js": __glob_0_56, "./icon_list/cylinder.js": __glob_0_57, "./icon_list/dahaze.js": __glob_0_58, "./icon_list/dark.js": __glob_0_59, "./icon_list/delete_forever.js": __glob_0_60, "./icon_list/device_hub.js": __glob_0_61, "./icon_list/diffuse.js": __glob_0_62, "./icon_list/doc.js": __glob_0_63, "./icon_list/drag_indicator.js": __glob_0_64, "./icon_list/draw.js": __glob_0_65, "./icon_list/east.js": __glob_0_66, "./icon_list/edit.js": __glob_0_67, "./icon_list/end.js": __glob_0_68, "./icon_list/exit_to_app.js": __glob_0_69, "./icon_list/expand.js": __glob_0_70, "./icon_list/expand_more.js": __glob_0_71, "./icon_list/export.js": __glob_0_72, "./icon_list/face.js": __glob_0_73, "./icon_list/fast_forward.js": __glob_0_74, "./icon_list/fast_rewind.js": __glob_0_75, "./icon_list/file_copy.js": __glob_0_76, "./icon_list/filter.js": __glob_0_77, "./icon_list/flag.js": __glob_0_78, "./icon_list/flash_on.js": __glob_0_79, "./icon_list/flatten.js": __glob_0_80, "./icon_list/flex.js": __glob_0_81, "./icon_list/flip.js": __glob_0_82, "./icon_list/flipY.js": __glob_0_83, "./icon_list/flip_camera.js": __glob_0_84, "./icon_list/folder.js": __glob_0_85, "./icon_list/font_download.js": __glob_0_86, "./icon_list/format_bold.js": __glob_0_87, "./icon_list/format_indent.js": __glob_0_88, "./icon_list/format_line_spacing.js": __glob_0_89, "./icon_list/format_shapes.js": __glob_0_90, "./icon_list/format_size.js": __glob_0_91, "./icon_list/fullscreen.js": __glob_0_92, "./icon_list/gps_fixed.js": __glob_0_93, "./icon_list/gradient.js": __glob_0_94, "./icon_list/grid.js": __glob_0_95, "./icon_list/grid3x3.js": __glob_0_96, "./icon_list/group.js": __glob_0_97, "./icon_list/height.js": __glob_0_98, "./icon_list/highlight_at.js": __glob_0_99, "./icon_list/horizontal_distribute.js": __glob_0_100, "./icon_list/horizontal_rule.js": __glob_0_101, "./icon_list/image.js": __glob_0_102, "./icon_list/input.js": __glob_0_103, "./icon_list/italic.js": __glob_0_104, "./icon_list/join_full.js": __glob_0_105, "./icon_list/join_right.js": __glob_0_106, "./icon_list/justify_content_space_around.js": __glob_0_107, "./icon_list/keyboard.js": __glob_0_108, "./icon_list/keyboard_arrow_down.js": __glob_0_109, "./icon_list/keyboard_arrow_left.js": __glob_0_110, "./icon_list/keyboard_arrow_right.js": __glob_0_111, "./icon_list/keyboard_arrow_up.js": __glob_0_112, "./icon_list/landscape.js": __glob_0_113, "./icon_list/launch.js": __glob_0_114, "./icon_list/layers.js": __glob_0_115, "./icon_list/layout_default.js": __glob_0_116, "./icon_list/layout_flex.js": __glob_0_117, "./icon_list/layout_grid.js": __glob_0_118, "./icon_list/left.js": __glob_0_119, "./icon_list/left_hide.js": __glob_0_120, "./icon_list/lens.js": __glob_0_121, "./icon_list/light.js": __glob_0_122, "./icon_list/line_cap_butt.js": __glob_0_123, "./icon_list/line_cap_round.js": __glob_0_124, "./icon_list/line_cap_square.js": __glob_0_125, "./icon_list/line_chart.js": __glob_0_126, "./icon_list/line_join_bevel.js": __glob_0_127, "./icon_list/line_join_miter.js": __glob_0_128, "./icon_list/line_join_round.js": __glob_0_129, "./icon_list/line_style.js": __glob_0_130, "./icon_list/line_weight.js": __glob_0_131, "./icon_list/list.js": __glob_0_132, "./icon_list/local_library.js": __glob_0_133, "./icon_list/local_movie.js": __glob_0_134, "./icon_list/lock.js": __glob_0_135, "./icon_list/lock_open.js": __glob_0_136, "./icon_list/looks.js": __glob_0_137, "./icon_list/margin.js": __glob_0_138, "./icon_list/merge.js": __glob_0_139, "./icon_list/middle.js": __glob_0_140, "./icon_list/navigation.js": __glob_0_141, "./icon_list/near_me.js": __glob_0_142, "./icon_list/north.js": __glob_0_143, "./icon_list/note.js": __glob_0_144, "./icon_list/nowrap.js": __glob_0_145, "./icon_list/opacity.js": __glob_0_146, "./icon_list/open_in_full.js": __glob_0_147, "./icon_list/outline.js": __glob_0_148, "./icon_list/outline_circle.js": __glob_0_149, "./icon_list/outline_image.js": __glob_0_150, "./icon_list/outline_rect.js": __glob_0_151, "./icon_list/outline_shape.js": __glob_0_152, "./icon_list/padding.js": __glob_0_153, "./icon_list/paint.js": __glob_0_154, "./icon_list/palette.js": __glob_0_155, "./icon_list/pantool.js": __glob_0_156, "./icon_list/pattern_check.js": __glob_0_157, "./icon_list/pattern_cross_dot.js": __glob_0_158, "./icon_list/pattern_dot.js": __glob_0_159, "./icon_list/pattern_grid.js": __glob_0_160, "./icon_list/pattern_horizontal_line.js": __glob_0_161, "./icon_list/pause.js": __glob_0_162, "./icon_list/pentool.js": __glob_0_163, "./icon_list/photo.js": __glob_0_164, "./icon_list/play.js": __glob_0_165, "./icon_list/plugin.js": __glob_0_166, "./icon_list/polygon.js": __glob_0_167, "./icon_list/power_input.js": __glob_0_168, "./icon_list/publish.js": __glob_0_169, "./icon_list/rect.js": __glob_0_170, "./icon_list/redo.js": __glob_0_171, "./icon_list/refresh.js": __glob_0_172, "./icon_list/remove.js": __glob_0_173, "./icon_list/remove2.js": __glob_0_174, "./icon_list/repeat.js": __glob_0_175, "./icon_list/replay.js": __glob_0_176, "./icon_list/right.js": __glob_0_177, "./icon_list/right_hide.js": __glob_0_178, "./icon_list/rotate.js": __glob_0_179, "./icon_list/rotate_left.js": __glob_0_180, "./icon_list/round.js": __glob_0_181, "./icon_list/same_height.js": __glob_0_182, "./icon_list/same_width.js": __glob_0_183, "./icon_list/save.js": __glob_0_184, "./icon_list/scatter.js": __glob_0_185, "./icon_list/screen.js": __glob_0_186, "./icon_list/setting.js": __glob_0_187, "./icon_list/settings_input_component.js": __glob_0_188, "./icon_list/shadow.js": __glob_0_189, "./icon_list/shape.js": __glob_0_190, "./icon_list/shuffle.js": __glob_0_191, "./icon_list/size.js": __glob_0_192, "./icon_list/skip_next.js": __glob_0_193, "./icon_list/skip_prev.js": __glob_0_194, "./icon_list/smooth.js": __glob_0_195, "./icon_list/source.js": __glob_0_196, "./icon_list/south.js": __glob_0_197, "./icon_list/space.js": __glob_0_198, "./icon_list/specular.js": __glob_0_199, "./icon_list/speed.js": __glob_0_200, "./icon_list/star.js": __glob_0_201, "./icon_list/start.js": __glob_0_202, "./icon_list/storage.js": __glob_0_203, "./icon_list/straighten.js": __glob_0_204, "./icon_list/strikethrough.js": __glob_0_205, "./icon_list/stroke_to_path.js": __glob_0_206, "./icon_list/swap_horiz.js": __glob_0_207, "./icon_list/switch_left.js": __glob_0_208, "./icon_list/switch_right.js": __glob_0_209, "./icon_list/sync.js": __glob_0_210, "./icon_list/table_rows.js": __glob_0_211, "./icon_list/text_rotate.js": __glob_0_212, "./icon_list/texture.js": __glob_0_213, "./icon_list/timer.js": __glob_0_214, "./icon_list/title.js": __glob_0_215, "./icon_list/to_back.js": __glob_0_216, "./icon_list/to_front.js": __glob_0_217, "./icon_list/tonality.js": __glob_0_218, "./icon_list/top.js": __glob_0_219, "./icon_list/transform.js": __glob_0_220, "./icon_list/underline.js": __glob_0_221, "./icon_list/undo.js": __glob_0_222, "./icon_list/unfold.js": __glob_0_223, "./icon_list/vertical_align_baseline.js": __glob_0_224, "./icon_list/vertical_align_bottom.js": __glob_0_225, "./icon_list/vertical_align_center.js": __glob_0_226, "./icon_list/vertical_align_stretch.js": __glob_0_227, "./icon_list/vertical_align_top.js": __glob_0_228, "./icon_list/vertical_distribute.js": __glob_0_229, "./icon_list/video.js": __glob_0_230, "./icon_list/view_comfy.js": __glob_0_231, "./icon_list/view_list.js": __glob_0_232, "./icon_list/view_week.js": __glob_0_233, "./icon_list/view_week_reverse.js": __glob_0_234, "./icon_list/vignette.js": __glob_0_235, "./icon_list/vintage.js": __glob_0_236, "./icon_list/visible.js": __glob_0_237, "./icon_list/volume_down.js": __glob_0_238, "./icon_list/volume_off.js": __glob_0_239, "./icon_list/volume_up.js": __glob_0_240, "./icon_list/wave.js": __glob_0_241, "./icon_list/waves.js": __glob_0_242, "./icon_list/web.js": __glob_0_243, "./icon_list/west.js": __glob_0_244, "./icon_list/width.js": __glob_0_245, "./icon_list/wrap.js": __glob_0_246, "./icon_list/wrap_text.js": __glob_0_247 };
const obj = {};
Object.entries(modules$2).forEach(([key, value]) => {
  key = key.replace("./icon_list/", "").replace(".js", "");
  obj[key] = value.default;
});
function iconUse$1(name2, transform2 = "", opt = { width: 24, height: 24 }) {
  return `<svg viewBox="0 0 ${opt.width} ${opt.height}" xmlns="http://www.w3.org/2000/svg">
  <use href="#icon-${name2}" transform="${transform2 || ""}" width="${opt.width}" height="${opt.height}" /> 
</svg>`;
}
function iconUseForPath(pathString2, opt = { width: 24, height: 24 }) {
  return `
    <svg viewBox="0 0 ${opt.width} ${opt.height}" xmlns="http://www.w3.org/2000/svg">
      <path d="${pathString2}" style="fill:${opt.fill || "transparent"};stroke:${opt.stroke || "white"}" stroke-width="1" />
    </svg>
  `;
}
function iconMake(svgString, opt = { width: 24, height: 24 }) {
  return `
    <svg viewBox="0 0 ${opt.width} ${opt.height}" xmlns="http://www.w3.org/2000/svg">
      ${svgString}
    </svg>
  `;
}
function iconBlank() {
  return iconMake(`<path d="M0 0h24v24H0z" fill="none" fill-opacity="0"/>`);
}
class CursorManager {
  async load(iconName = "default", ...args2) {
    if (obj[iconName]) {
      const iconContent = isFunction(obj[iconName]) ? obj[iconName].call(obj[iconName], ...args2) : obj[iconName];
      const blob = new Blob([iconContent], { type: "image/svg+xml" });
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = (e2) => {
          const datauri = e2.target.result;
          resolve(`url(${datauri}) 12 12, auto`);
        };
        reader.readAsDataURL(blob);
      });
    } else {
      return iconName;
    }
  }
}
class AssetManager {
  constructor(editor) {
    this.$editor = editor;
  }
  get project() {
    return this.$editor.selection.currentProject;
  }
  revokeResource(value) {
    var json = JSON.parse(value || "[]");
    var assets = {};
    json.forEach((project2) => {
      project2.images.forEach((it) => {
        assets[`#${it.id}`] = it;
      });
    });
    Object.keys(assets).map((idString) => {
      var a = assets[idString];
      var info = AssetParser.parse(a.original, true);
      a.local = info.local;
    });
    json.forEach((project2) => {
      project2.layers = this.applyAsset(project2.layers, assets);
    });
    return json;
  }
  applyAsset(json, assets) {
    if (Array.isArray(json)) {
      json = json.map((it) => this.applyAsset(it, assets));
    } else if (isObject(json)) {
      Object.keys(json).forEach((key) => {
        json[key] = this.applyAsset(json[key], assets);
      });
    } else if (isString(json)) {
      Object.keys(assets).forEach((idString) => {
        var a = assets[idString];
        if (json.indexOf(`#${a.id}`) > -1) {
          json = json.replace(new RegExp(`#${a.id}`, "g"), a.local);
        }
      });
    }
    return json;
  }
}
class PluginManager {
  constructor(editor) {
    this.editor = editor;
    this.plugins = [];
  }
  registerPlugin(func2) {
    this.plugins.push(func2);
  }
  async initializePlugin(options2 = {}) {
    return await Promise.all(this.plugins.map(async (CreatePluginFunction) => {
      return await CreatePluginFunction(this.editor, options2);
    }));
  }
}
class RendererManager {
  constructor(editor) {
    this.editor = editor;
    this.renderers = {};
    this.rendererTypes = {};
  }
  getRenderType(rendererType) {
    if (!this.renderers[rendererType]) {
      this.renderers[rendererType] = {};
    }
    return this.renderers[rendererType];
  }
  registerRenderer(rendererType, name2, rendererInstance) {
    const typedRenderer = this.getRenderType(rendererType);
    if (typedRenderer[name2])
      throw new Error("It has duplicated renderer name. " + name2);
    typedRenderer[name2] = rendererInstance;
  }
  registerRendererType(rendererType, rendererTypeInstance) {
    if (this.rendererTypes[rendererType])
      throw new Error("It has duplcated renderer type name. " + name);
    this.rendererTypes[rendererType] = rendererTypeInstance;
  }
  getRenderer(rendererType) {
    return this.rendererTypes[rendererType];
  }
  getRendererInstance(rendererType, name2) {
    const typedRenderer = this.getRenderType(rendererType);
    return typedRenderer[name2];
  }
}
function CSS_TO_STRING(style, postfix = "") {
  var newStyle = style || {};
  return Object.keys(newStyle).filter((key) => isNotUndefined(newStyle[key])).map((key) => `${key}: ${newStyle[key]}`).join(";" + postfix);
}
function OBJECT_TO_PROPERTY(obj2) {
  const target = obj2 || {};
  return Object.keys(target).map((key) => {
    if (key === "class") {
      if (isObject(obj2[key])) {
        return `${key}="${OBJECT_TO_CLASS(obj2[key])}"`;
      }
    }
    if (key === "style") {
      if (isObject(obj2[key])) {
        return `${key}="${CSS_TO_STRING(obj2[key])}"`;
      }
    }
    if (isBoolean(obj2[key]) || isUndefined(obj2[key]) || obj2[key] === "undefined") {
      if (obj2[key]) {
        return key;
      } else {
        return "";
      }
    }
    return `${key}="${obj2[key]}"`;
  }).join(" ");
}
function OBJECT_TO_CLASS(obj2) {
  return Object.keys(obj2).filter((k) => obj2[k]).map((key) => {
    return key;
  }).join(" ");
}
function createComponent(ComponentName, props2 = {}, children2 = []) {
  children2 = children2.flat(Infinity).join("");
  const targetVariable = Object.keys(props2).length ? variable$4(props2) : "";
  return `<object refClass="${ComponentName}" ${targetVariable}>${children2}</object>`;
}
function createComponentList(...args2) {
  return args2.map((it) => {
    let ComponentName;
    let props2 = {};
    let children2 = [];
    if (isString(it)) {
      ComponentName = it;
    } else if (isArray(it)) {
      [ComponentName, props2 = {}, children2 = []] = it;
    }
    if (children2.length) {
      return createComponent(ComponentName, props2, createComponentList(children2));
    }
    return createComponent(ComponentName, props2);
  }).join("\n");
}
function createElement(Component2, props2, children2 = []) {
  children2 = children2.flat(Infinity);
  return `<${Component2} ${OBJECT_TO_PROPERTY(props2)}>${children2.join(" ")}</${Component2}>`;
}
function createElementJsx(Component2, props2, ...children2) {
  children2 = children2.flat(Infinity);
  if (typeof Component2 !== "string") {
    const ComponentName = Component2.name;
    registElement({
      [ComponentName]: Component2
    });
    return createComponent(ComponentName, props2, children2);
  } else {
    return createElement(Component2, props2, children2);
  }
}
class InjectManager {
  constructor(editor) {
    this.editor = editor;
    this.menuItems = {};
  }
  registerMenuItem(target, obj2 = {}) {
    if (!this.menuItems[target]) {
      this.menuItems[target] = [];
    }
    Object.keys(obj2).forEach((refClass) => {
      this.menuItems[target].push({
        refClass,
        class: obj2[refClass]
      });
    });
  }
  getTargetMenuItems(target) {
    return this.menuItems[target] || [];
  }
  generate(target, hasRef = false) {
    return this.getTargetMenuItems(target).map((it) => {
      const props2 = {};
      if (hasRef) {
        props2.ref = `$${it.refClass}`;
      }
      return createComponent(it.refClass, props2);
    }).join("\n");
  }
}
class I18nManager {
  constructor(editor) {
    this.editor = editor;
    this.locales = {};
    this.fallbackLang = "en_US";
  }
  getLang(lang = void 0) {
    return lang || this.fallbackLang;
  }
  setFallbackLang(lang) {
    this.fallbackLang = lang;
  }
  get(key, params = {}, lang = void 0) {
    var _a, _b;
    const currentLang = this.getLang(lang);
    const str = ((_a = this.locales[currentLang]) == null ? void 0 : _a[key]) || ((_b = this.locales[this.fallbackLang]) == null ? void 0 : _b[key]) || key || void 0;
    if (isFunction(str)) {
      return str(params);
    } else {
      let newValue = str;
      if (key === newValue) {
        return key.split(".").pop();
      }
      Object.entries(params).forEach(([key2, value]) => {
        newValue = newValue.replace(new RegExp(`{${key2}}`, "ig"), value);
      });
      return newValue;
    }
  }
  hasKey(key, lang = void 0) {
    const currentLang = this.getLang(lang);
    return !!(this.locales[currentLang][key] || this.locales[this.fallbackLang][key]);
  }
  registerI18nMessage(lang, messages) {
    if (!this.locales[lang]) {
      this.locales[lang] = {};
    }
    Object.assign(this.locales[lang], messages);
  }
}
class ModeViewManager {
  constructor(editor) {
    this.editor = editor;
    this.modes = ["CanvasView"];
  }
  pushMode(mode) {
    this.modes.push(mode);
  }
  popMode(mode = void 0) {
    if (mode) {
      if (this.isCurrentMode(mode)) {
        this.modes.pop();
      }
    } else {
      this.modes.pop();
    }
  }
  currentMode() {
    return this.modes[this.modes.length - 1];
  }
  isCurrentMode(mode) {
    return this.currentMode() === mode;
  }
}
class PathKitManager {
  constructor(editor) {
    this.editor = editor;
    this.pathkit = null;
  }
  registerPathKit(pathkit2) {
    this.pathkit = pathkit2;
    this.editor.emit("updatePathKit");
  }
  has() {
    return !!this.pathkit;
  }
  booleanOperation(first, second2, pathOp) {
    const PathKit = this.pathkit;
    return PathKit.MakeFromOp(PathKit.FromSVGString(first), PathKit.FromSVGString(second2), pathOp).toSVGString();
  }
  intersection(first, second2) {
    const PathKit = this.pathkit;
    if (!PathKit)
      return;
    return this.reversePathString(this.booleanOperation(first, second2, PathKit.PathOp.INTERSECT));
  }
  union(first, second2) {
    const PathKit = this.pathkit;
    if (!PathKit)
      return;
    return this.booleanOperation(first, second2, PathKit.PathOp.UNION);
  }
  difference(first, second2) {
    const PathKit = this.pathkit;
    if (!PathKit)
      return;
    return this.reversePathString(this.booleanOperation(first, second2, PathKit.PathOp.DIFFERENCE));
  }
  reverseDifference(first, second2) {
    const PathKit = this.pathkit;
    if (!PathKit)
      return;
    return this.reversePathString(this.booleanOperation(first, second2, PathKit.PathOp.REVERSE_DIFFERENCE));
  }
  xor(first, second2) {
    const PathKit = this.pathkit;
    if (!PathKit)
      return;
    return this.reversePathString(this.booleanOperation(first, second2, PathKit.PathOp.XOR));
  }
  reversePathString(pathString2) {
    return PathParser.fromSVGString(pathString2).reversePathStringByFunc((_, index2) => index2 % 2 === 0);
  }
  isValidPath(path) {
    const PathKit = this.pathkit;
    let pathKitPath = PathKit.FromSVGString(path);
    return pathKitPath.isValid();
  }
  simplify(path) {
    const PathKit = this.pathkit;
    const pathObject = PathKit.FromSVGString(path);
    return pathObject.simplify().toSVGString();
  }
  convertLineJoin(lineJoin) {
    const PathKit = this.pathkit;
    switch (lineJoin) {
      case "miter":
        return PathKit.StrokeJoin.MITER;
      case "round":
        return PathKit.StrokeJoin.ROUND;
      case "bevel":
        return PathKit.StrokeJoin.BEVEL;
    }
  }
  convertLineCap(lineCap) {
    const PathKit = this.pathkit;
    switch (lineCap) {
      case "butt":
        return PathKit.StrokeCap.BUTT;
      case "round":
        return PathKit.StrokeCap.ROUND;
      case "square":
        return PathKit.StrokeCap.SQUARE;
    }
  }
  stroke(path, opt = { width: 1, miter_limit: 4 }) {
    const PathKit = this.pathkit;
    const pathObject = PathKit.FromSVGString(path);
    if (isArray(opt["stroke-dasharray"])) {
      const arr = opt["stroke-dasharray"];
      if (arr.length >= 2) {
        pathObject.dash(arr[0], arr[1], +(opt["stroke-dashoffset"] || 0));
      }
    }
    let newPathObject = pathObject.stroke({
      width: +opt["stroke-width"],
      join: this.convertLineJoin(opt["stroke-linejoin"]),
      cap: this.convertLineCap(opt["stroke-linecap"])
    });
    newPathObject.setFillType(PathKit.FillType.WINDING);
    return newPathObject.simplify().toSVGString();
  }
  round(path, opt = { width: 1, miter_limit: 4 }) {
    return this.stroke(path, __spreadProps(__spreadValues({}, opt), {
      "stroke-linejoin": "round"
    }));
  }
  grow(path, opt = { width: 1, miter_limit: 4 }) {
    const PathKit = this.pathkit;
    const pathObject = PathKit.FromSVGString(path);
    return pathObject.copy().stroke(opt).op(pathObject, PathKit.PathOp.DIFFERENCE).toSVGString();
  }
  shrink(path, opt = { width: 1, miter_limit: 4 }) {
    const PathKit = this.pathkit;
    const pathObject = PathKit.FromSVGString(path);
    const simplifyPath = pathObject.copy().simplify();
    return pathObject.copy().stroke(opt).op(simplifyPath, PathKit.PathOp.DIFFERENCE).toSVGString();
  }
  dash(path, on, off, phase = 1) {
    const PathKit = this.pathkit;
    const pathObject = PathKit.FromSVGString(path);
    return pathObject.dash(on, off, phase).toSVGString();
  }
  trim(path, startT, stopT, isComplement = false) {
    const PathKit = this.pathkit;
    const pathObject = PathKit.FromSVGString(path);
    return pathObject.trim(startT, stopT, isComplement).toSVGString();
  }
}
class SegmentSelectionManager {
  constructor(editor) {
    this.$editor = editor;
    this.selectedPointKeys = {};
    this.selectedPointList = [];
  }
  get length() {
    return this.selectedPointList.length;
  }
  initialize() {
    this.selectedPointKeys = {};
    this.selectedPointList = [];
  }
  makeSegmentKey(index2, key) {
    return `${index2}_${key}`;
  }
  select(...list2) {
    this.selectedPointKeys = {};
    this.selectedPointList = list2.map(({ key, index: index2 }) => ({
      key,
      index: +index2 || 0
    }));
    list2.forEach((it) => {
      var key = this.makeSegmentKey(it.index, it.key);
      this.selectedPointKeys[key] = it;
    });
  }
  toggleSegment(index2, key) {
    if (!this.isSelectedSegment(key, index2)) {
      this.select(...this.selectedPointList, { key, index: index2 });
    } else {
      this.select(...this.selectedPointList.filter((it) => {
        return it.key !== key || it.index !== index2;
      }));
    }
  }
  toggleSelect(...list2) {
    list2 = list2.map((it) => {
      return __spreadProps(__spreadValues({}, it), { included: this.isSelectedSegment(it.index, it.key) });
    });
    const includedList = list2.filter((it) => it.included);
    const notIncludedList = list2.filter((it) => !it.included);
    let uniqueList = [...this.selectedPointList];
    if (includedList.length) {
      uniqueList = this.selectedPointList.filter((it) => {
        const oldKey = this.makeSegmentKey(it);
        return Boolean(includedList.find((includeNode) => {
          return oldKey === this.makeSegmentKey(includeNode);
        })) === false;
      });
    }
    this.select(...uniqueList, ...notIncludedList);
  }
  selectKeyIndex(index2, key) {
    if (!this.isSelectedSegment(index2, key)) {
      this.select({ key, index: index2 });
    }
  }
  isSelectedSegment(index2, key) {
    var key = this.makeSegmentKey(index2, key);
    return !!this.selectedPointKeys[key];
  }
}
class LockManager {
  constructor(editor) {
    this.editor = editor;
    this.lockList = {};
  }
  get(key) {
    return this.lockList[key];
  }
  set(key, value) {
    this.lockList[key] = true;
  }
  toggle(key) {
    if (this.lockList[key]) {
      delete this.lockList[key];
    } else {
      this.lockList[key] = true;
    }
  }
}
class VisibleManager {
  constructor(editor) {
    this.editor = editor;
    this.hiddenList = {};
  }
  get list() {
    return Object.keys(this.hiddenList);
  }
  get(key) {
    return !this.hiddenList[key];
  }
  set(key, value) {
    if (value) {
      delete this.hiddenList[key];
    } else {
      this.hiddenList[key] = true;
    }
  }
  toggle(key) {
    if (this.get(key)) {
      this.set(key, false);
    } else {
      this.set(key, true);
    }
  }
}
class CommandMaker {
  constructor(editor) {
    this.editor = editor;
    this.commands = [];
  }
  emit(...args2) {
    this.commands.push(args2);
  }
  run() {
    this.editor.emit(this.commands);
  }
}
class ClipboardManager {
  constructor(editor) {
    this.editor = editor;
    this.clipboard = [];
  }
  get length() {
    return this.clipboard.length;
  }
  clear() {
    this.clipboard = [];
  }
  get isEmpty() {
    return this.clipboard.length == 0;
  }
  push(data) {
    this.clipboard.push(data);
  }
  pop() {
    return this.clipboard.pop();
  }
}
class IconManager$1 {
  constructor(editor) {
    this.editor = editor;
    this.iconMap = {};
  }
  get(itemType, item2) {
    const icon = this.iconMap[itemType];
    if (isFunction(icon)) {
      return icon(item2);
    }
    return iconUse$1(icon || item2.getIcon());
  }
  set(itemType, value) {
    this.iconMap[itemType] = value;
  }
  registerIcon(itemType, iconOrFunction) {
    this.set(itemType, iconOrFunction);
  }
}
const EDIT_MODE_SELECTION = "SELECTION";
const EDIT_MODE_ADD = "ADD";
class Editor {
  constructor() {
    this.EDITOR_ID = uuid$1();
    this.projects = [];
    this.popupZIndex = 1e4;
    this.canvasWidth = 1e5;
    this.canvasHeight = 1e5;
    this.symbols = {};
    this.images = {};
    this.openRightPanel = true;
    this.mode = EDIT_MODE_SELECTION;
    this.loadManagers();
  }
  loadManagers() {
    this.store = new BaseStore(this);
    this.config = new ConfigManager(this);
    this.snapManager = new SnapManager(this);
    this.commands = new CommandManager(this);
    this.shortcuts = new ShortCutManager(this);
    this.selection = new SelectionManager(this);
    this.segmentSelection = new SegmentSelectionManager(this);
    this.timeline = new TimelineSelectionManager(this);
    this.history = new HistoryManager(this);
    this.keyboardManager = new KeyBoardManager(this);
    this.viewport = new ViewportManager(this);
    this.storageManager = new StorageManager(this);
    this.cursorManager = new CursorManager(this);
    this.assetManager = new AssetManager(this);
    this.injectManager = new InjectManager(this);
    this.components = new ComponentManager(this);
    this.pluginManager = new PluginManager(this);
    this.renderers = new RendererManager(this);
    this.i18n = new I18nManager(this);
    this.modelManager = new ModelManager(this);
    this.modeViewManager = new ModeViewManager(this);
    this.pathKitManager = new PathKitManager(this);
    this.lockManager = new LockManager(this);
    this.visibleManager = new VisibleManager(this);
    this.clipboard = new ClipboardManager(this);
    this.iconManager = new IconManager$1(this);
    this.initPlugins();
    this.initStorage();
  }
  initStorage() {
    this.locale = this.loadItem("locale") || "en_US";
    this.layout = this.loadItem("layout") || "all";
  }
  createProject() {
    return this.createModel({ itemType: "project" });
  }
  getI18nMessage(key, params = {}, locale) {
    return this.i18n.get(key, params, locale || this.locale);
  }
  $i18n(key, params = {}, locale) {
    return this.getI18nMessage(key, params, locale);
  }
  hasI18nkey(key, locale) {
    return this.i18n.hasKey(key, locale || this.locale);
  }
  initI18nMessage(root = "") {
    return (key, params = {}, locale) => {
      const i18nKey = `${root}.${key}`;
      if (this.hasI18nkey(i18nKey, locale)) {
        return this.i18n(`${root}.${key}`, params, locale);
      } else {
        return this.i18n(`${key}`, params, locale);
      }
    };
  }
  setLocale(locale = "en_US") {
    this.locale = locale;
    this.saveItem("locale", this.locale);
  }
  setLayout(layout2 = "all") {
    this.layout = layout2;
    this.saveItem("layout", this.layout);
  }
  setUser(user) {
    this.user = user;
  }
  initPlugins(options2 = {}) {
    this.pluginManager.initializePlugin(options2);
  }
  themeValue(key, defaultValue = "") {
    return theme[this.config.get("editor.theme")][key] || defaultValue;
  }
  changeMode(mode = EDIT_MODE_SELECTION) {
    this.mode = mode;
  }
  isMode(mode) {
    return this.mode === mode;
  }
  isAddMode() {
    return this.isMode(EDIT_MODE_ADD);
  }
  get zIndex() {
    return this.popupZIndex++;
  }
  get isPointerUp() {
    const e2 = this.config.get("bodyEvent");
    if (!e2)
      return true;
    if (e2.type === "pointerup")
      return true;
    else if (e2.type === "pointermove" && e2.buttons === 0)
      return true;
    return false;
  }
  get isPointerDown() {
    return !this.isPointerUp;
  }
  get isPointerMove() {
    if (!this.config.get("bodyEvent"))
      return false;
    return this.config.get("bodyEvent").type === "pointermove";
  }
  getFile(url) {
    return this.images[url] || url;
  }
  setStore(store) {
    this.store = store;
  }
  emit(...args2) {
    this.store.source = this.EDITOR_ID;
    this.store.emit(...args2);
  }
  on(...args2) {
    const [name2, callback, context, ...rest] = args2;
    return this.store.on(name2, callback, context || this, ...rest);
  }
  off(...args2) {
    this.store.off(...args2);
  }
  offAll(...args2) {
    this.store.offAll(...args2);
  }
  debug(...args2) {
  }
  command(command, message, ...args2) {
    if (this.isPointerUp) {
      return this.store.emit(`history.${command}`, message, ...args2);
    } else {
      return this.store.emit(command, ...args2);
    }
  }
  nextTick(callback) {
    if (this.store) {
      this.store.nextTick(callback);
    }
  }
  get(id) {
    return this.modelManager.get(id);
  }
  replaceLocalUrltoRealUrl(str) {
    var project2 = this.selection.currentProject;
    var images = {};
    project2.images.forEach((a) => {
      if (str.indexOf(a.local) > -1) {
        images[a.local] = a.original;
      }
    });
    Object.keys(images).forEach((local) => {
      if (str.indexOf(local) > -1) {
        str = str.replace(new RegExp(local, "g"), images[local]);
      }
    });
    return str;
  }
  createModel(itemObject, isRegister = true) {
    return this.modelManager.createModel(itemObject, isRegister);
  }
  searchItem(id) {
    return this.modelManager.searchItem(id);
  }
  get storeKey() {
    return `__els__.${this.config.get("store.key")}`;
  }
  saveItem(key, value) {
    window.localStorage.setItem(`${this.storeKey}.${key}`, JSON.stringify(value));
  }
  loadItem(key) {
    return JSON.parse(window.localStorage.getItem(`${this.storeKey}.${key}`) || JSON.stringify(""));
  }
  createCommandMaker() {
    return new CommandMaker(this);
  }
  registerElement(obj2) {
    registElement(obj2);
  }
  registerAlias(obj2) {
    Object.entries(obj2).forEach(([key, value]) => {
      registAlias(key, value);
    });
  }
  registerMenuItem(target, obj2 = {}) {
    this.injectManager.registerMenuItem(target, obj2);
    this.registerElement(obj2);
  }
  registerComponent(name2, component2) {
    this.components.registerComponent(name2, component2);
  }
  registerItem(name2, item2) {
    this.registerComponent(name2, item2);
  }
  registerInspector(name2, inspectorCallback) {
    this.components.registerInspector(name2, inspectorCallback);
  }
  registerRenderer(rendererType, name2, rendererInstance) {
    this.renderers.registerRenderer(rendererType, name2, rendererInstance);
  }
  registerRendererType(rendererType, rendererTypeInstance) {
    this.renderers.registerRendererType(rendererType, rendererTypeInstance);
  }
  getRendererInstance(rendererType, itemType) {
    return this.renderers.getRendererInstance(rendererType, itemType);
  }
  renderer(rendererType) {
    return this.renderers.getRenderer(rendererType);
  }
  get html() {
    return this.renderer("html");
  }
  get svg() {
    return this.renderer("svg");
  }
  get json() {
    return this.renderer("json");
  }
  registerCommand(commandObject) {
    return this.commands.registerCommand(commandObject);
  }
  registerShortCut(shortcut) {
    this.shortcuts.registerShortCut(shortcut);
  }
  registerPlugin(createPluginFunction) {
    this.pluginManager.registerPlugin(createPluginFunction);
  }
  registerPluginList(plugins = []) {
    plugins.forEach((p) => this.registerPlugin(p));
  }
  registerConfig(config) {
    this.config.registerConfig(config);
  }
  registerI18nMessage(locale, messages) {
    this.i18n.registerI18nMessage(locale, messages);
  }
  registerI18nMessageWithLocale(messages) {
    Object.entries(messages).forEach(([locale, messages2]) => {
      this.registerI18nMessage(locale, messages2);
    });
  }
  registerIcon(itemType, iconOrFunction) {
    this.iconManager.registerIcon(itemType, iconOrFunction);
  }
  get(id) {
    return this.modelManager.get(id);
  }
}
const ADD_BODY_FIRST_MOUSEMOVE = "add/body/first/mousemove";
const ADD_BODY_MOUSEMOVE = "add/body/mousemove";
const ADD_BODY_MOUSEUP = "add/body/mouseup";
const FIRSTMOVE = (method = "move") => {
  return AFTER(`bodyMouseFirstMove ${method}`);
};
const MOVE = (method = "move") => {
  return AFTER(`bodyMouseMove ${method}`);
};
const END = (method = "end") => {
  return AFTER(`bodyMouseUp ${method}`);
};
class UIElement extends EventMachine {
  constructor(opt, props2 = {}) {
    super(opt, props2);
    if (props2.store) {
      this.__storeInstance = props2.store;
    } else {
      this.__storeInstance = new BaseStore();
    }
    this.created();
    this.initialize();
    this.initializeStoreEvent();
  }
  setStore(storeInstance) {
    this.__storeInstance = storeInstance;
  }
  get $store() {
    return this.__storeInstance || this.parent.$store;
  }
  created() {
  }
  getRealEventName(e2, s = MULTI_PREFIX) {
    var startIndex = e2.indexOf(s);
    return e2.substr(startIndex < 0 ? 0 : startIndex + s.length);
  }
  splitMethod(arr, keyword, defaultValue = 0) {
    var [methods, params] = splitMethodByKeyword(arr, keyword);
    return [
      methods.length ? +params[0].target : defaultValue,
      methods,
      params
    ];
  }
  createLocalCallback(event, callback) {
    var newCallback = callback.bind(this);
    newCallback.displayName = `${this.sourceName}.${event}`;
    newCallback.source = this.source;
    return newCallback;
  }
  initializeStoreEvent() {
    this.filterProps(CHECK_SUBSCRIBE_PATTERN).forEach((key) => {
      const events = this.getRealEventName(key, SUBSCRIBE_SAPARATOR);
      const [method, ...methodLine] = events.split(CHECK_SAPARATOR);
      const checkMethodList = methodLine.map((it) => it.trim()).filter((code2) => this[code2]).map((target) => ({ target }));
      const [debounceSecond, debounceMethods] = this.splitMethod(methodLine, "debounce");
      const [throttleSecond, throttleMethods] = this.splitMethod(methodLine, "throttle");
      const [allTrigger, allTriggerMethods] = this.splitMethod(methodLine, "allTrigger");
      const [selfTrigger, selfTriggerMethods] = this.splitMethod(methodLine, "selfTrigger");
      events.split(CHECK_SAPARATOR).filter((it) => {
        return checkMethodList.indexOf(it) === -1 && debounceMethods.indexOf(it) === -1 && allTriggerMethods.indexOf(it) === -1 && selfTriggerMethods.indexOf(it) === -1 && throttleMethods.indexOf(it) === -1;
      }).map((it) => it.trim()).filter(Boolean).forEach((e2) => {
        if (isFunction(this[key])) {
          var callback = this.createLocalCallback(e2, this[key]);
          this.$store.on(e2, callback, this, debounceSecond, throttleSecond, allTriggerMethods.length, selfTriggerMethods.length, checkMethodList);
        }
      });
    });
  }
  destoryStoreSUBSCRIBE() {
    this.$store.offAll(this);
  }
  destroy() {
    super.destroy();
    this.destoryStoreSUBSCRIBE();
  }
  rerender() {
    super.rerender();
    this.initialize();
    this.initializeStoreEvent();
  }
  emit(messageName, ...args2) {
    this.$store.source = this.source;
    this.$store.sourceContext = this;
    this.$store.emit(messageName, ...args2);
  }
  nextTick(callback, delay = 0) {
    setTimeout(() => {
      this.$store.nextTick(callback);
    }, delay);
  }
  trigger(messageName, ...args2) {
    this.$store.source = this.source;
    this.$store.trigger(messageName, ...args2);
  }
  broadcast(messageName, ...args2) {
    Object.keys(this.children).forEach((key) => {
      this.children[key].trigger(messageName, ...args2);
    });
  }
  on(message, callback, debounceDelay = 0, throttleDelay = 0, enableAllTrigger = false, enableSelfTrigger = false) {
    this.$store.on(message, callback, this.source, debounceDelay, throttleDelay, enableAllTrigger, enableSelfTrigger);
  }
  off(message, callback) {
    this.$store.off(message, callback, this.source);
  }
  subscribe(callback, debounceSecond = 0, throttleSecond = 0) {
    const id = `subscribe.${uuidShort()}`;
    const newCallback = this.createLocalCallback(id, callback);
    this.$store.on(id, newCallback, this, debounceSecond, throttleSecond, false, true);
    return id;
  }
}
class EditorElement extends UIElement {
  initialize() {
    super.initialize();
    this.$editor.registerI18nMessageWithLocale(this.initializeI18nMessage());
  }
  initializeI18nMessage() {
    return {};
  }
  get $editor() {
    if (!this.__cacheParentEditor) {
      this.__cacheParentEditor = this.parent.$editor;
    }
    return this.__cacheParentEditor;
  }
  get $store() {
    return this.$editor.store || this.parent.$store;
  }
  $i18n(key, params = {}, locale) {
    return this.$editor.getI18nMessage(key, params, locale);
  }
  $initI18n(key) {
    return this.$editor.initI18nMessage(key);
  }
  get $config() {
    return this.$editor.config;
  }
  get $selection() {
    return this.$editor.selection;
  }
  get $segmentSelection() {
    return this.$editor.segmentSelection;
  }
  get $commands() {
    return this.$editor.commands;
  }
  get $viewport() {
    return this.$editor.viewport;
  }
  get $snapManager() {
    return this.$editor.snapManager;
  }
  get $timeline() {
    return this.$editor.timeline;
  }
  get $history() {
    return this.$editor.history;
  }
  get $shortcuts() {
    return this.$editor.shortcuts;
  }
  get $keyboardManager() {
    return this.$editor.keyboardManager;
  }
  get $storageManager() {
    return this.$editor.storageManager;
  }
  get $injectManager() {
    return this.$editor.injectManager;
  }
  get $menuManager() {
    return this.$injectManager;
  }
  get $model() {
    return this.$editor.modelManager;
  }
  get $lockManager() {
    return this.$editor.lockManager;
  }
  get $visibleManager() {
    return this.$editor.visibleManager;
  }
  get $modeView() {
    return this.$editor.modeViewManager;
  }
  get $pathkit() {
    return this.$editor.pathKitManager;
  }
  get $icon() {
    return this.$editor.iconManager;
  }
  command(command, description, ...args2) {
    if (this.$editor.isPointerUp) {
      return this.emit(`history.${command}`, description, ...args2);
    } else {
      return this.emit(command, ...args2);
    }
  }
  $theme(key) {
    return this.$editor.themeValue(key);
  }
  bodyMouseFirstMove(e2, methodName) {
    if (this[methodName]) {
      this.emit(ADD_BODY_FIRST_MOUSEMOVE, this[methodName], this, e2.xy);
    }
  }
  bodyMouseMove(e2, methodName) {
    if (this[methodName]) {
      this.emit(ADD_BODY_MOUSEMOVE, this[methodName], this, e2.xy);
    }
  }
  bodyMouseUp(e2, methodName) {
    if (this[methodName]) {
      this.emit(ADD_BODY_MOUSEUP, this[methodName], this, e2.xy);
    }
  }
}
const EMPTY_POS = { x: 0, y: 0 };
const DEFAULT_POS = { x: Number.MAX_SAFE_INTEGER, y: Number.MAX_SAFE_INTEGER };
const MOVE_CHECK_MS = 0;
class BaseLayout extends EditorElement {
  created() {
    this.$editor.registerPluginList(this.getPlugins());
    if (Array.isArray(this.opt.plugins)) {
      this.$editor.registerPluginList(this.opt.plugins);
    }
    this.$editor.initPlugins();
    this.$config.load();
    if (isObject(this.opt.config)) {
      this.$config.setAll(this.opt.config || {});
    }
  }
  get $editor() {
    if (!this.__editorInstance) {
      this.__editorInstance = new Editor();
    }
    return this.__editorInstance;
  }
  afterRender() {
    super.afterRender();
    this.$el.attr("data-theme", this.$config.get("editor.theme"));
    this.$el.addClass(navigator.userAgent.includes("Windows") ? "ua-window" : "ua-default");
    this.trigger("initialize");
  }
  initialize() {
    super.initialize();
    this.__initBodyMoves();
    this.emit("load.json", this.opt.data);
  }
  [CONFIG("editor.theme")]() {
    this.$el.attr("data-theme", this.$config.get("editor.theme"));
  }
  getPlugins() {
    return [];
  }
  __initBodyMoves() {
    this.__firstMove = new Set();
    this.__moves = new Set();
    this.__ends = new Set();
    this.__modifyBodyMoveSecond(MOVE_CHECK_MS);
  }
  __modifyBodyMoveSecond(ms = MOVE_CHECK_MS) {
    this.$config.set("body.move.ms", ms);
    const callback = ms === 0 ? this.__loopBodyMoves.bind(this) : debounce(this.__loopBodyMoves.bind(this), this.$config.get("body.move.ms"));
    this.__funcBodyMoves = callback;
  }
  __loopBodyMoves() {
    var pos = this.pos;
    var e2 = this.$config.get("bodyEvent");
    var lastPos = this.lastPos || DEFAULT_POS;
    var isNotEqualLastPos = !(lastPos.x === pos.x && lastPos.y === pos.y);
    if (isNotEqualLastPos && this.__firstMove.size) {
      let i = 0;
      this.__firstMove.forEach((v) => {
        const dist2 = getDist(pos.x, pos.y, v.xy.x, v.xy.y);
        if (Math.abs(dist2) > 0) {
          var dx = pos.x - v.xy.x;
          var dy = pos.y - v.xy.y;
          v.func.call(v.context, dx, dy, "move", e2.pressure);
          i++;
        }
      });
      if (i > 0) {
        this.__firstMove.clear();
      }
    }
    if (isNotEqualLastPos && this.__moves.size) {
      this.__moves.forEach((v) => {
        const dist2 = getDist(pos.x, pos.y, v.xy.x, v.xy.y);
        if (Math.abs(dist2) > 0.5) {
          var dx = pos.x - v.xy.x;
          var dy = pos.y - v.xy.y;
          v.func.call(v.context, dx, dy, "move", e2.pressure);
        }
      });
      this.lastPos = pos;
    }
    requestAnimationFrame(this.__funcBodyMoves);
  }
  __removeBodyMoves() {
    var pos = this.lastPos;
    var e2 = this.$config.get("bodyEvent");
    if (pos) {
      this.__ends.forEach((v) => {
        v.func.call(v.context, pos.x - v.xy.x, pos.y - v.xy.y, "end", e2.pressure);
      });
    }
    this.__firstMove.clear();
    this.__moves.clear();
    this.__ends.clear();
  }
  [SUBSCRIBE_ALL(ADD_BODY_FIRST_MOUSEMOVE)](func2, context, xy2) {
    this.__firstMove.add({ func: func2, context, xy: xy2 });
  }
  [SUBSCRIBE_ALL(ADD_BODY_MOUSEMOVE)](func2, context, xy2) {
    this.__moves.add({ func: func2, context, xy: xy2 });
  }
  [SUBSCRIBE_ALL(ADD_BODY_MOUSEUP)](func2, context, xy2) {
    this.__ends.add({ func: func2, context, xy: xy2 });
  }
  [POINTERSTART()](e2) {
    var newPos = e2.xy || EMPTY_POS;
    this.$config.init("bodyEvent", e2);
    this.pos = newPos;
  }
  [POINTERMOVE()](e2) {
    var newPos = e2.xy || EMPTY_POS;
    this.$config.init("bodyEvent", e2);
    this.pos = newPos;
    if (!this.__requestId) {
      this.__requestId = requestAnimationFrame(this.__funcBodyMoves);
    }
  }
  [POINTEREND()](e2) {
    this.$config.set("bodyEvent", e2);
    this.__removeBodyMoves();
    cancelAnimationFrame(this.__requestId);
    this.__requestId = null;
  }
  [RESIZE("window") + DEBOUNCE(100)]() {
    this.emit("resize.window");
  }
  [SUBSCRIBE("refreshAll")]() {
    this.emit("refreshProjectList");
    this.trigger("refreshAllSelectProject");
  }
  [SUBSCRIBE("refreshAllSelectProject")]() {
    this.emit("refreshArtboard");
  }
  [SUBSCRIBE("changed.locale")]() {
    this.rerender();
  }
}
var HorizontalRuler$1 = "";
let pathString$1 = [];
class HorizontalRuler extends EditorElement {
  template() {
    return `
            <div class="elf--horizontal-ruler">
                <div class='horizontal-ruler-container' ref='$layerRuler'>
                    <svg class="lines" width="100%" width="100%" overflow="hidden">
                        <path ref="$rulerLines" d="" />
                    </svg>
                </div>                            
                <div class='horizontal-ruler-container' ref='$ruler'></div>
                <div class='horizontal-ruler-container'>
                    <svg width="100%" width="100%" overflow="hidden">
                        <path data-mouse="true" d="" stroke="transparent" ref="$cursor" />
                    </svg>
                </div>
            </div>
        `;
  }
  afterRender() {
    this.refreshCanvasSize();
  }
  refreshCanvasSize() {
    this.state.rect = this.$el.rect();
  }
  initializeRect() {
    if (!this.state.rect || this.state.rect.width == 0) {
      this.state.rect = this.$el.rect();
    }
  }
  makeLine(pathString2, baseNumber, minX, maxX, realWidth, width2, epsilon = 3, lineWidth = 30, expect = 10) {
    let startX = minX - minX % baseNumber;
    let endX = maxX + maxX % baseNumber;
    const firstX = (startX - minX) / realWidth * width2;
    const secondX = (startX + baseNumber - minX) / realWidth * width2;
    if (Math.abs(secondX - firstX) < epsilon)
      return;
    for (var i = startX; i < endX; i += baseNumber) {
      if (i != 0 && i % expect === 0)
        continue;
      const x2 = Math.floor((i - minX) / realWidth * width2);
      pathString2[pathString2.length] = `M ${x2} ${30 - lineWidth} L ${x2} 30 `;
    }
  }
  makeLineText(baseNumber, minX, maxX, realWidth, width2, epsilon = 3) {
    const text2 = [];
    let startX = minX - minX % baseNumber;
    let endX = maxX + maxX % baseNumber;
    const firstX = (startX - minX) / realWidth * width2;
    const secondX = (startX + baseNumber - minX) / realWidth * width2;
    if (Math.abs(secondX - firstX) < epsilon)
      return;
    for (var i = startX; i < endX; i += baseNumber) {
      const x2 = Math.floor((i - minX) / realWidth * width2);
      text2[text2.length] = `<text x="${x2}" y="${0}" dx="0" dy="8" text-anchor="middle" alignment-baseline="bottom" >${i}</text>`;
    }
    return text2.join("");
  }
  makeRulerForCurrentArtboard() {
    const current = this.$selection.current;
    if (!current)
      return "";
    const currentArtboard = current.artboard;
    if (!currentArtboard)
      return "";
    const verties = currentArtboard.verties;
    const { minX, maxX, width: realWidth } = this.$viewport;
    const width2 = this.state.rect.width;
    const firstX = (verties[0][0] - minX) / realWidth * width2;
    const secondX = (verties[2][0] - minX) / realWidth * width2;
    return `
            M ${firstX} 20 
            L ${firstX} 30 
            L ${secondX} 30 
            L ${secondX} 20 
            Z
        `;
  }
  makeRulerForCurrent() {
    const current = this.$selection.current;
    if (!current)
      return "";
    const verties = this.$selection.verties;
    const xList = verties.map((it) => it[0]);
    const currentMinX = Math.min.apply(Math, xList);
    const currentMaxX = Math.max.apply(Math, xList);
    const { minX, width: realWidth } = this.$viewport;
    const width2 = this.state.rect.width;
    const firstX = (currentMinX - minX) / realWidth * width2;
    const secondX = (currentMaxX - minX) / realWidth * width2;
    return `
            M ${firstX} 0 
            L ${firstX} 20 
            L ${secondX} 20 
            L ${secondX} 0 
            Z
        `;
  }
  makeRuler() {
    const { minX, maxX, width: realWidth } = this.$viewport;
    const width2 = this.state.rect.width;
    pathString$1 = [];
    this.makeLine(pathString$1, 200, minX, maxX, realWidth, width2, 10, 20, 1e4);
    this.makeLine(pathString$1, 100, minX, maxX, realWidth, width2, 10, 20, 200);
    this.makeLine(pathString$1, 50, minX, maxX, realWidth, width2, 10, 20, 100);
    this.makeLine(pathString$1, 10, minX, maxX, realWidth, width2, 10, 18, 50);
    this.makeLine(pathString$1, 5, minX, maxX, realWidth, width2, 10, 15, 10);
    this.makeLine(pathString$1, 1, minX, maxX, realWidth, width2, 10, 13, 5);
    return pathString$1.join("");
  }
  makeRulerText() {
    const { minX, maxX, width: realWidth } = this.$viewport;
    const width2 = this.state.rect.width;
    const dist2 = Math.abs(maxX - minX);
    return [
      dist2 > 3e3 ? this.makeLineText(500, minX, maxX, realWidth, width2, 20) : "",
      1e3 < dist2 && dist2 < 3e3 ? this.makeLineText(100, minX, maxX, realWidth, width2, 20) : "",
      800 < dist2 && dist2 < 1e3 ? this.makeLineText(100, minX, maxX, realWidth, width2, 20) : "",
      500 < dist2 && dist2 < 800 ? this.makeLineText(100, minX, maxX, realWidth, width2, 20) : "",
      500 < dist2 && dist2 < 800 ? this.makeLineText(50, minX, maxX, realWidth, width2, 20) : "",
      200 < dist2 && dist2 < 500 ? this.makeLineText(50, minX, maxX, realWidth, width2, 20) : "",
      50 < dist2 && dist2 < 200 ? this.makeLineText(10, minX, maxX, realWidth, width2, 20) : "",
      15 < dist2 && dist2 < 50 ? this.makeLineText(5, minX, maxX, realWidth, width2, 20) : "",
      0 < dist2 && dist2 < 15 ? this.makeLineText(1, minX, maxX, realWidth, width2, 20) : ""
    ].join("");
  }
  [LOAD("$ruler")]() {
    this.initializeRect();
    return `
            <svg width="100%" width="100%" overflow="hidden">
                <path d="${this.makeRuler()}" fill="transparent" stroke-width="0.5" stroke="white" transform="translate(0.5, 0)" />
                ${this.makeRulerText()}                
            </svg>
        `;
  }
  [BIND("$rulerLines")]() {
    return {
      d: this.makeRulerForCurrent()
    };
  }
  makeRulerCursor() {
    const targetMousePoint = this.$viewport.getWorldPosition();
    const { minX, maxX, width: realWidth } = this.$viewport;
    this.initializeRect();
    const width2 = this.state.rect.width;
    const distX = targetMousePoint[0] - minX;
    const x2 = distX === 0 ? 0 : distX / realWidth * width2;
    return `M ${x2 - 0.5} 0 L ${x2 - 0.5} 20`;
  }
  [BIND("$cursor")]() {
    return {
      d: this.makeRulerCursor()
    };
  }
  refresh() {
    if (this.$config.get("show.ruler")) {
      this.load();
    }
  }
  [SUBSCRIBE("updateViewport", "refreshSelection")]() {
    this.refresh();
  }
  [SUBSCRIBE("refreshSelectionStyleView") + THROTTLE(10)]() {
    if (this.$selection.current) {
      const current = this.$selection.current;
      if (current.hasChangedField("x", "y", "width", "height", "transform", "rotateZ", "rotate")) {
        this.refresh();
      }
    }
  }
  [SUBSCRIBE("resize.window", "resizeCanvas")]() {
    this.refreshCanvasSize();
  }
  [CONFIG("onMouseMovepageContainer")]() {
    this.bindData("$cursor");
    this.bindData("$rulerLines");
  }
}
var VerticalRuler$1 = "";
let pathString = [];
class VerticalRuler extends EditorElement {
  template() {
    return `
            <div class="elf--vertical-ruler">
                <div class='vertical-ruler-container' ref='$layerRuler'>
                    <svg class="lines" width="100%" height="100%" overflow="hidden">
                        <path ref="$rulerLines" d=""/>
                    </svg>
                </div>                                        
                <div class='vertical-ruler-container' ref='$body'></div>
                <div class='vertical-ruler-container'>
                    <svg width="100%" height="100%" overflow="hidden">
                        <path data-mouse="true" d="" stroke="transparent" ref="$cursor" />
                    </svg>
                </div>                
            </div>
        `;
  }
  afterRender() {
    this.refreshCanvasSize();
  }
  refreshCanvasSize() {
    this.state.rect = this.$el.rect();
  }
  initializeRect() {
    if (!this.state.rect || this.state.rect.width == 0) {
      this.state.rect = this.$el.rect();
    }
  }
  makeLine(pathString2, baseNumber, minY, maxY, realHeight, height2, epsilon = 3, lineWidth = 30, expect = 10) {
    let startY = minY - minY % baseNumber;
    let endY = maxY + maxY % baseNumber;
    const firstY = (startY - minY) / realHeight * height2;
    const secondY = (startY + baseNumber - minY) / realHeight * height2;
    if (Math.abs(secondY - firstY) < epsilon)
      return;
    for (var i = startY; i < endY; i += baseNumber) {
      if (i != 0 && i % expect === 0)
        continue;
      const y2 = Math.floor((i - minY) / realHeight * height2);
      pathString2[pathString2.length] = `M ${30 - lineWidth} ${y2} L 30 ${y2}`;
    }
  }
  makeLineText(baseNumber, minY, maxY, realHeight, height2, epsilon = 3) {
    const text2 = [];
    let startY = minY - minY % baseNumber;
    let endY = maxY + maxY % baseNumber;
    const firstY = (startY - minY) / realHeight * height2;
    const secondY = (startY + baseNumber - minY) / realHeight * height2;
    if (Math.abs(secondY - firstY) < epsilon)
      return;
    for (var i = startY; i < endY; i += baseNumber) {
      const y2 = Math.floor((i - minY) / realHeight * height2);
      text2[text2.length] = `<text x="${1}" y="${y2}" dy="6" dominant-baseline="central" transform="rotate(-90, 1, ${y2})">${i}</text>`;
    }
    return text2.join("");
  }
  makeRulerForCurrentArtboard() {
    const current = this.$selection.current;
    if (!current)
      return "";
    const currentArtboard = current.artboard;
    if (!currentArtboard)
      return "";
    const verties = currentArtboard.verties;
    const { minY, maxY, height: realHeight } = this.$viewport;
    const height2 = this.state.rect.height;
    const firstY = (verties[0][1] - minY) / realHeight * height2;
    const secondY = (verties[2][1] - minY) / realHeight * height2;
    return `
            M 20 ${firstY}
            L 30 ${firstY}
            L 30 ${secondY}
            L 20 ${secondY}
            Z
        `;
  }
  makeRulerForCurrent() {
    const current = this.$selection.current;
    if (!current)
      return "";
    const { minY, height: realHeight } = this.$viewport;
    const height2 = this.state.rect.height;
    const verties = this.$selection.verties;
    const yList = verties.map((it) => it[1]);
    const currentMinY = Math.min.apply(Math, yList);
    const currentMaxY = Math.max.apply(Math, yList);
    const firstY = (currentMinY - minY) / realHeight * height2;
    const secondY = (currentMaxY - minY) / realHeight * height2;
    return `
            M 0 ${firstY}
            L 20 ${firstY}
            L 20 ${secondY}
            L 0 ${secondY}
            Z
        `;
  }
  makeRuler() {
    const { minY, maxY, height: realHeight } = this.$viewport;
    const height2 = this.state.rect.height;
    pathString = [];
    this.makeLine(pathString, 200, minY, maxY, realHeight, height2, 10, 18, 1e4);
    this.makeLine(pathString, 100, minY, maxY, realHeight, height2, 10, 18, 200);
    this.makeLine(pathString, 50, minY, maxY, realHeight, height2, 10, 18, 100);
    this.makeLine(pathString, 10, minY, maxY, realHeight, height2, 10, 18, 50);
    this.makeLine(pathString, 5, minY, maxY, realHeight, height2, 10, 15, 10);
    this.makeLine(pathString, 1, minY, maxY, realHeight, height2, 10, 14, 5);
    return pathString.join("");
  }
  makeRulerText() {
    const { minY, maxY, height: realHeight } = this.$viewport;
    const height2 = this.state.rect.height;
    const dist2 = Math.abs(maxY - minY);
    return [
      dist2 > 3e3 ? this.makeLineText(500, minY, maxY, realHeight, height2, 20) : "",
      1e3 < dist2 && dist2 < 3e3 ? this.makeLineText(100, minY, maxY, realHeight, height2, 20) : "",
      800 < dist2 && dist2 < 1e3 ? this.makeLineText(100, minY, maxY, realHeight, height2, 20) : "",
      500 < dist2 && dist2 < 800 ? this.makeLineText(100, minY, maxY, realHeight, height2, 20) : "",
      500 < dist2 && dist2 < 800 ? this.makeLineText(50, minY, maxY, realHeight, height2, 20) : "",
      200 < dist2 && dist2 < 500 ? this.makeLineText(50, minY, maxY, realHeight, height2, 20) : "",
      50 < dist2 && dist2 < 200 ? this.makeLineText(10, minY, maxY, realHeight, height2, 20) : "",
      15 < dist2 && dist2 < 50 ? this.makeLineText(5, minY, maxY, realHeight, height2, 20) : "",
      0 < dist2 && dist2 < 15 ? this.makeLineText(1, minY, maxY, realHeight, height2, 20) : ""
    ].join("");
  }
  [LOAD("$body")]() {
    if (!this.state.rect || this.state.rect.width == 0) {
      this.state.rect = this.$el.rect();
    }
    return `
            <svg width="100%" height="100%" overflow="hidden">
                <path d="${this.makeRuler()}" fill="transparent" stroke-width="0.5" stroke="white" transform="translate(0, 0.5)" />
                ${this.makeRulerText()}
            </svg>
        `;
  }
  [BIND("$rulerLines")]() {
    return {
      d: this.makeRulerForCurrent()
    };
  }
  makeRulerCursor() {
    const targetMousePoint = this.$viewport.getWorldPosition();
    const { minY, maxY, height: realHeight } = this.$viewport;
    this.initializeRect();
    const height2 = this.state.rect.height;
    const distY = targetMousePoint[1] - minY;
    const y2 = distY === 0 ? 0 : distY / realHeight * height2;
    return `M 0 ${y2 - 0.5} L 20 ${y2 - 0.5}`;
  }
  [BIND("$cursor")]() {
    return {
      d: this.makeRulerCursor()
    };
  }
  refresh() {
    if (this.$config.get("show.ruler")) {
      this.load();
    }
  }
  [SUBSCRIBE("refreshSelectionStyleView") + THROTTLE(10)]() {
    const current = this.$selection.current;
    if (current && current.hasChangedField("x", "y", "width", "height", "transform", "rotateZ", "rotate")) {
      this.refresh();
    }
  }
  [SUBSCRIBE("updateViewport", "refreshSelection")]() {
    this.refresh();
  }
  [SUBSCRIBE("resize.window", "resizeCanvas")]() {
    this.refreshCanvasSize();
  }
  [CONFIG("onMouseMovepageContainer")]() {
    this.bindData("$cursor");
    this.bindData("$rulerLines");
  }
}
class Resource {
  static getAllDropItems(e2) {
    var items = [];
    if (e2.dataTransfer) {
      items = [...e2.dataTransfer.types].map((type, index2) => {
        if (type.includes("text")) {
          return {
            kind: "string",
            type,
            data: e2.dataTransfer.getData(type)
          };
        }
      }).filter((it) => it);
    }
    var files = [];
    if (e2.dataTransfer) {
      files = [...e2.dataTransfer.files];
    }
    return [...items, ...files];
  }
}
const filter_list$2 = [
  "blur",
  "grayscale",
  "hue-rotate",
  "invert",
  "brightness",
  "contrast",
  "drop-shadow",
  "opacity",
  "saturate",
  "sepia",
  "svg"
];
const TEMP_DIV = Dom.create("div");
class StyleView extends EditorElement {
  initState() {
    return {
      lastChangedList: {}
    };
  }
  template() {
    return `
    <div class='style-view' style='pointer-events: none; position: absolute;display:inline-block;left:-1000px;'>
      <div ref='$svgArea'></div>
      <style ref="$innerStyleView" type="text/css"></style>
    </div>
    `;
  }
  initialize() {
    super.initialize();
    this.refs.$styleView = Dom.create(document.head);
  }
  makeStyle(item2) {
    return this.$editor.html.toStyle(item2);
  }
  refreshStyleHead() {
    var project2 = this.$selection.currentProject || new Project();
    this.refs.$styleView.$$(`style[data-renderer-type="html"]`).forEach(($style) => $style.remove());
    this.changeStyleHead(project2);
    project2.layers.forEach((item2) => this.changeStyleHead(item2));
  }
  changeStyleHead(item2) {
    var $temp = Dom.create("div");
    const styleTag = this.makeStyle(item2);
    $temp.html(styleTag).children().forEach(($item) => {
      this.refs.$styleView.append($item);
    });
  }
  refreshStyleHeadOne(item2, isOnlyOne = false) {
    var list2 = [item2];
    if (!isOnlyOne) {
      list2 = item2.allLayers;
    }
    var selector2 = list2.map((it) => {
      return `style[data-renderer-type="html"][data-id="${it.id}"]`;
    }).join(",");
    let isChanged = false;
    this.refs.$styleView.$$(selector2).forEach((it) => {
      const renderItem = this.$model.get(it.data("id"));
      if (renderItem.isChanged(this.state.lastChangedList[renderItem.id])) {
        isChanged = true;
        it.remove();
        this.state.lastChangedList[renderItem.id] = renderItem.timestamp;
      }
    });
    if (isChanged) {
      this.changeStyleHead(item2);
    }
  }
  [SUBSCRIBE("refreshStyleView", "moveTimeline", "playTimeline")](current, isOnlyOne = false) {
    if (current) {
      this.load();
      this.refreshStyleHeadOne(current, isOnlyOne);
    } else {
      this.refresh();
    }
  }
  [SUBSCRIBE("refreshSVGArea")]() {
    this.load("$svgArea");
  }
  [SUBSCRIBE("refreshSelectionStyleView")](obj2 = null) {
    var ids = obj2;
    if (Array.isArray(obj2)) {
      ids = obj2;
    } else if (obj2 !== null) {
      ids = [obj2];
    }
    let items = [];
    if (!ids) {
      items = this.$selection.items;
    } else if (isString(ids[0])) {
      items = this.$selection.itemsByIds(ids);
    } else {
      items = ids;
    }
    const styleTags = [];
    const removeStyleSelector = [];
    for (let i = 0, len2 = items.length; i < len2; i++) {
      const item2 = items[i];
      var selector2 = item2.allLayers.map((it) => {
        return `style[data-renderer-type="html"][data-id="${it.id}"]`;
      }).join(",");
      removeStyleSelector.push(selector2);
      styleTags.push(this.makeStyle(item2));
    }
    if (removeStyleSelector.length) {
      this.refs.$styleView.$$(removeStyleSelector).forEach((it) => {
        it.remove();
      });
    }
    var $fragment = TEMP_DIV.html(styleTags.join("")).createChildrenFragment();
    this.refs.$styleView.append($fragment);
  }
  refresh() {
    this.load();
    this.refreshStyleHead();
  }
  [BIND("$innerStyleView")]() {
    return {
      html: `${this.$visibleManager.list.map((id) => {
        return `[data-id="${id}"]`;
      }).join(",")} { 
        display: none;
      }`
    };
  }
  [SUBSCRIBE("refreshVisibleView")]() {
    this.bindData("$innerStyleView");
  }
}
var HTMLRenderView$1 = "";
class HTMLRenderView extends EditorElement {
  components() {
    return {
      StyleView
    };
  }
  initState() {
    return {
      mode: "selection",
      x: 0,
      y: 0,
      width: 1e4,
      height: 1e4,
      cachedCurrentElement: {}
    };
  }
  template() {
    return `
            <div class='elf--element-view' ref='$body'>
                ${createComponent("StyleView", { ref: "$styleView" })}
                <div class='canvas-view' 
                        data-renderer-id='${this.$editor.EDITOR_ID}' 
                        ref='$view' 
                        data-outline="${this.$config.get("show.outline")}"
                ></div>
                ${this.$injectManager.generate("render.view")}
            </div>
        `;
  }
  [BIND("$body")]() {
    const { canvasWidth, canvasHeight } = this.$editor;
    var width2 = canvasWidth;
    var height2 = canvasHeight;
    return {
      "tabIndex": -1,
      style: {
        width: width2,
        height: height2
      }
    };
  }
  [BIND("$view")]() {
    const { translate: translate2, transformOrigin: origin2, scale: scale2 } = this.$viewport;
    const transform2 = `translate(${translate2[0]}px, ${translate2[1]}px) scale(${scale2 || 1})`;
    const transformOrigin = `${origin2[0]}px ${origin2[1]}px`;
    return {
      style: {
        "transform-origin": transformOrigin,
        transform: transform2
      }
    };
  }
  [CONFIG("show.outline")]() {
    this.refs.$view.attr("data-outline", this.$config.get("show.outline"));
  }
  [SUBSCRIBE("refElement")](id, callback) {
    isFunction(callback) && callback(this.getElement(id));
  }
  [SUBSCRIBE("refreshSelectionStyleView")](obj2) {
    this.refreshSelectionStyleView(obj2);
  }
  [SUBSCRIBE("updateViewport")]() {
    this.bindData("$view");
  }
  [CONFIG("bodyEvent")]() {
    const number = Dom.create(this.$config.get("bodyEvent").target).data("number");
    if (!number) {
      this.emit("recoverCursor");
    }
  }
  [SUBSCRIBE("refreshAllElementBoundSize")]() {
    this.refreshAllElementBoundSize();
  }
  [SUBSCRIBE("refreshElementBoundSize")](parentObj) {
    this.refreshElementBoundSize(parentObj);
  }
  [SUBSCRIBE("updateAllCanvas")](parentLayer) {
    this.updateAllCanvas(parentLayer);
  }
  [SUBSCRIBE("refreshAllCanvas")]() {
    this.refreshAllCanvas();
  }
  [SUBSCRIBE("playTimeline", "moveTimeline")]() {
    const project2 = this.$selection.currentProject;
    var timeline = project2.getSelectedTimeline();
    if (timeline) {
      timeline.animations.map((it) => this.$model.get(it.id)).forEach((current) => {
        this.updateTimelineElement(current, true, false);
      });
    }
  }
  clearElementAll() {
    this.state.cachedCurrentElement = {};
  }
  clearElement(id) {
    this.state.cachedCurrentElement[id] = void 0;
  }
  getElement(id) {
    if (!this.state.cachedCurrentElement[id]) {
      this.state.cachedCurrentElement[id] = this.refs.$view.$(`[data-id="${id}"]`);
    }
    return this.state.cachedCurrentElement[id];
  }
  [DOUBLECLICK("$view .element-item.text .text-content")](e2) {
    e2.$dt.addClass("focused");
    e2.$dt.attr("contenteditable", "true");
    e2.$dt.focus();
    e2.$dt.select();
  }
  [FOCUSOUT("$view .element-item.text .text-content")](e2) {
    e2.$dt.removeAttr("contenteditable");
    e2.$dt.removeClass("focused");
  }
  [KEYUP("$view .element-item.text .text-content")](e2) {
    var content2 = e2.$dt.html();
    var text2 = e2.$dt.text();
    var id = e2.$dt.parent().attr("data-id");
    var arr = [];
    this.$selection.items.filter((it) => it.id === id).forEach((item2) => {
      item2.reset({
        content: content2,
        text: text2
      });
      arr.push({ id: item2.id, content: content2, text: text2 });
      var $el = this.getElement(item2.id);
      const { width: width2, height: height2 } = $el.offsetRect();
      item2.reset({
        width: width2,
        height: height2
      });
      this.emit("refreshSelectionStyleView", item2);
    });
    this.emit("refreshContent", arr);
    this.emit("refreshSelectionTool", false);
  }
  checkEditMode(e2) {
    if (this.$config.get("set.tool.hand")) {
      return false;
    }
    const code2 = this.$shortcuts.getGeneratedKeyCode(KEY_CODE.space);
    if (this.$keyboardManager.check(code2)) {
      return false;
    }
    const $target = Dom.create(e2.target);
    if ($target.hasClass("canvas-view")) {
      return false;
    }
    if (!e2.shiftKey) {
      const mousePoint = this.$viewport.getWorldPosition(e2);
      if (this.$selection.hasPoint(mousePoint)) {
        if (this.$selection.hasHoverItem()) {
          if (this.$selection.hasParent(this.$selection.hoverId) === false) {
            this.$selection.selectHoverItem();
          }
        }
        return true;
      }
      if (this.$selection.hasHoverItem()) {
        this.$selection.selectHoverItem();
        return true;
      }
    }
    const $element = $target.closest("element-item");
    if ($element) {
      if ($element.hasClass("focused")) {
        return false;
      }
      var id = $element.attr("data-id");
      if (e2.altKey === false) {
        const item2 = this.$model.get(id);
        if (item2.is("artboard") && item2.hasChildren()) {
          this.$config.init("set.dragarea.mode", true);
          return true;
        }
      }
    } else {
      return false;
    }
    return true;
  }
  [DOUBLECLICK("$view")](e2) {
    const $item = Dom.create(e2.target).closest("element-item");
    if ($item) {
      const id = $item.attr("data-id");
      this.nextTick(() => {
        this.emit("doubleclick.item", e2, id);
      }, 100);
    }
  }
  [POINTERSTART("$view") + IF("checkEditMode") + MOVE("calculateMovedElement") + FIRSTMOVE("calculateFirstMovedElement") + END("calculateEndedElement")](e2) {
    this.initMousePoint = this.$viewport.getWorldPosition(e2);
    this.$config.init("set.move.control.point", true);
    if (this.$config.get("set.dragarea.mode")) {
      this.emit("startDragAreaView");
      return;
    }
    let isInSelectedArea = this.$selection.hasPoint(this.initMousePoint);
    const $target = Dom.create(e2.target);
    if ($target.hasClass("canvas-view")) {
      this.$selection.select();
      this.initializeDragSelection();
      this.emit("history.refreshSelection");
      return false;
    }
    const $element = $target.closest("element-item");
    var id = $element && $element.attr("data-id");
    if (e2.altKey) {
      if (isInSelectedArea)
        ;
      else {
        if (this.$selection.check({ id }) === false) {
          this.$selection.selectByGroup(id);
        }
      }
      if (this.$selection.isEmpty === false) {
        this.$selection.selectAfterCopy();
        this.refreshAllCanvas();
        this.emit("refreshLayerTreeView");
        this.initializeDragSelection();
        this.emit("history.refreshSelection");
      }
    } else {
      if (isInSelectedArea)
        ;
      else {
        if (e2.shiftKey) {
          this.$selection.toggleById(id);
        } else {
          if (this.$selection.check({ id }) === false) {
            const current = this.$model.get(id);
            if (current && current.is("artboard") && current.hasChildren())
              ;
            else if (current.hasChildren()) {
              this.$selection.selectByGroup(id);
            } else {
              this.$selection.selectByGroup(id);
            }
          }
        }
      }
      this.initializeDragSelection();
      this.emit("history.refreshSelection");
    }
  }
  initializeDragSelection() {
    this.$selection.reselect();
    this.$snapManager.clear();
    this.emit("refreshSelectionTool", true);
  }
  calculateFirstMovedElement() {
    this.emit("hideSelectionToolView");
  }
  calculateMovedElement() {
    if (this.$config.get("set.dragarea.mode")) {
      this.emit("moveDragAreaView");
      return;
    }
    if (this.$selection.isLayoutItem) {
      return;
    }
    const targetMousePoint = this.$viewport.getWorldPosition();
    const newDist = floor([], subtract([], targetMousePoint, this.initMousePoint));
    this.moveTo(newDist);
    if (this.$selection.changeArtBoard()) {
      this.initMousePoint = targetMousePoint;
      this.$selection.reselect();
      this.$snapManager.clear();
      this.clearElementAll();
      this.refreshAllCanvas();
      this.emit("refreshLayerTreeView");
      this.refreshAllElementBoundSize();
    }
    this.emit("setAttributeForMulti", this.$selection.packByValue({
      "x": (item2) => item2.x,
      "y": (item2) => item2.y,
      "right": void 0,
      "bottom": void 0
    }));
  }
  moveTo(dist2) {
    const snap = this.$snapManager.check(this.$selection.cachedRectVerties.map((v) => {
      return add$1([], v, dist2);
    }), 3);
    const localDist = add$1([], snap, dist2);
    const result = {};
    this.$selection.cachedItemMatrices.forEach((it) => {
      const newVerties = it.verties.map((v) => {
        return add$1([], v, localDist);
      });
      const newDist = subtract([], transformMat4([], newVerties[0], it.parentMatrixInverse), transformMat4([], it.verties[0], it.parentMatrixInverse));
      result[it.id] = {
        x: Math.floor(it.x + newDist[0]),
        y: Math.floor(it.y + newDist[1])
      };
    });
    this.$selection.reset(result);
  }
  calculateEndedElement(dx, dy) {
    const targetMousePoint = this.$viewport.getWorldPosition();
    const newDist = dist(targetMousePoint, this.initMousePoint);
    this.$config.init("set.move.control.point", false);
    if (this.$config.get("set.dragarea.mode")) {
      this.emit("endDragAreaView");
      this.$config.init("set.dragarea.mode", false);
      return;
    }
    if (newDist < 1)
      ;
    else {
      this.$selection.reselect();
      this.$snapManager.clear();
      this.command("setAttributeForMulti", "move item", this.$selection.pack("x", "y"));
      this.nextTick(() => {
        this.emit("recoverBooleanPath");
      });
    }
    this.nextTick(() => {
      this.emit("refreshSelection");
      this.emit("refreshSelectionTool", true);
    }, 100);
  }
  refreshSelectionStyleView(obj2) {
    if (obj2) {
      this.updateElement(obj2);
    } else {
      this.$selection.items.forEach((current) => {
        this.updateElement(current);
      });
    }
  }
  updateElement(item2) {
    if (item2) {
      this.$editor.html.update(item2, this.getElement(item2.id), this.$editor);
    }
  }
  updateTimelineElement(item2) {
    if (item2) {
      this.$editor.html.update(item2, this.getElement(item2.id), this.$editor);
    }
  }
  refreshAllCanvas() {
    this.clearElementAll();
    const project2 = this.$selection.currentProject;
    const html2 = this.$editor.html.render(project2, null, this.$editor) || "";
    this.refs.$view.updateDiff(html2, void 0, {
      checkPassed: (oldEl, newEl) => {
        const isPassed = oldEl.getAttribute("data-id") === newEl.getAttribute("data-id");
        return isPassed;
      }
    });
    this.bindData("$view");
    this.updateAllCanvas(project2);
  }
  updateAllCanvas(parentLayer) {
    parentLayer.layers.forEach((item2) => {
      this.updateElement(item2, this.getElement(item2.id));
      this.updateAllCanvas(item2);
    });
  }
  refreshAllElementBoundSize() {
    var selectionList = this.$selection.items.map((it) => {
      if (it.is("artboard")) {
        return it;
      }
      return it.parent;
    });
    var list2 = [...new Set(selectionList)];
    list2.forEach((it) => {
      this.refreshElementBoundSize(it);
    });
  }
  refreshElementBoundSize(parentObj) {
    if (parentObj) {
      if (parentObj.hasChildren() === false) {
        if (parentObj.hasChangedField("width", "height", "border") === false) {
          return;
        }
        var $el = this.getElement(parentObj.id);
        const { x: x2, y: y2, width: width2, height: height2 } = $el.offsetRect();
        if (width2 > 0 && height2 > 0) {
          parentObj.reset({ x: x2, y: y2, width: width2, height: height2 });
          this.refreshSelectionStyleView(parentObj);
        }
        return;
      }
      const hasChangedDimension = parentObj.changedLayout || parentObj.hasChangedField("children", "box-model", "width", "height");
      parentObj.layers.forEach((it) => {
        var $el2 = this.getElement(it.id);
        if ($el2 && (hasChangedDimension || it.isLayoutItem())) {
          const { x: x2, y: y2, width: width2, height: height2 } = $el2.offsetRect();
          if (width2 > 0 && height2 > 0) {
            it.reset({ x: x2, y: y2, width: width2, height: height2 });
            this.refreshSelectionStyleView(it);
          }
        }
        this.trigger("refreshElementBoundSize", it);
      });
    }
  }
}
var PageTools$1 = "";
class PageTools extends EditorElement {
  template() {
    return `     
      <div class='elf--page-tools'>
        <button type='button' ref='$minus'>${iconUse$1("remove2")}</button>
        <div class='select'>
          ${createComponent("NumberInputEditor", {
      ref: "$scaleInput",
      min: 10,
      max: 240,
      step: 1,
      key: "scale",
      value: this.$viewport.scale * 100,
      onchange: this.subscribe((key, scale2) => {
        this.$viewport.setScale(scale2 / 100);
        this.emit("updateViewport");
        this.trigger("updateViewport");
      }, 1e3)
    })}
        </div>
        <label>%</label>
        <button type='button' ref='$plus'>${iconUse$1("add")}</button>        
        <button type='button' ref='$center' data-tooltip="Move to Center" data-direction="top">${iconUse$1("gps_fixed")}</button>    
        <button type='button' ref='$ruler' data-tooltip="Toggle Ruler" data-direction="top">${iconUse$1("straighten")}</button>    
        <button type='button' ref='$fullscreen' data-tooltip="FullScreen Canvas" data-direction="top">${iconUse$1("fullscreen")}</button>                        
        <button type='button' ref='$pantool' class="${OBJECT_TO_CLASS$1({
      on: this.$config.get("set.tool.hand")
    })}" data-tooltip="Hand | H" data-direction="top">${iconUse$1("pantool")}</button>   
        <span class="divider">|</span>
        <button type="button" ref="$selectedCount" style="color:var(--elf--selected-color);font-weight: bold;text-shadow: 1px 1px 1px rgba(255, 255, 255, 0.1)"></button>
        <span ref="$buttons"></span>
        ${this.$injectManager.generate("page.tools")}                             
      </div>

    `;
  }
  [SUBSCRIBE("updateViewport")]() {
    const scale2 = Math.floor(this.$viewport.scale * 100);
    if (this.children.$scaleInput) {
      this.children.$scaleInput.setValue(scale2);
    }
  }
  [CLICK("$plus") + PREVENT + STOP]() {
    const oldScale = this.$viewport.scale;
    this.$viewport.setScale(oldScale + 0.01);
    this.emit("updateViewport");
    this.trigger("updateViewport");
  }
  [CLICK("$minus") + PREVENT + STOP]() {
    const oldScale = this.$viewport.scale;
    this.$viewport.setScale(oldScale - 0.01);
    this.emit("updateViewport");
    this.trigger("updateViewport");
  }
  [CLICK("$center") + PREVENT + STOP]() {
    this.emit("moveSelectionToCenter");
  }
  [CLICK("$pantool") + PREVENT + STOP]() {
    this.$config.toggle("set.tool.hand");
  }
  [CLICK("$ruler") + PREVENT + STOP]() {
    this.$config.toggle("show.ruler");
  }
  [CLICK("$fullscreen") + PREVENT + STOP]() {
    this.emit("bodypanel.toggle.fullscreen");
  }
  [CLICK("$buttons button") + PREVENT + STOP](e2) {
    const itemId = e2.$dt.data("item-id");
    const pathIndex = e2.$dt.data("path-index");
    const current = this.$editor.get(itemId);
    if (current.editablePath) {
      this.emit("open.editor", current);
    } else {
      const pathList = PathParser.fromSVGString(current.absolutePath().d).toPathList();
      this.emit("showPathEditor", "modify", {
        box: "canvas",
        current,
        matrix: current.matrix,
        d: pathList[pathIndex].d,
        changeEvent: (data) => {
          pathList[pathIndex].reset(data.d);
          const newPathD = current.invertPath(PathParser.joinPathList(pathList).d).d;
          this.command("setAttributeForMulti", "modify sub path", {
            [itemId]: current.updatePath(newPathD)
          });
        }
      });
    }
    this.emit("hideSelectionToolView");
  }
  [CONFIG("set.tool.hand")]() {
    this.refs.$pantool.toggleClass("on", this.$config.get("set.tool.hand"));
  }
  [SUBSCRIBE("refreshSelection")]() {
    this.refs.$selectedCount.html(this.$selection.length + "");
    this.load("$buttons");
  }
  [LOAD("$buttons") + DOMDIFF]() {
    if (this.$selection.isEmpty)
      return "";
    const buttons = [];
    this.$selection.items.forEach((selectedItem) => {
      selectedItem.allLayers.forEach((item2) => {
        if (item2.isNot("boolean-path")) {
          const list2 = PathParser.fromSVGString(item2.absolutePath().d).toPathList();
          list2.forEach((path, index2) => {
            buttons.push({
              item: item2,
              index: index2,
              path
            });
          });
        }
      });
    });
    return buttons.map((it) => {
      const { item: item2, index: index2, path } = it;
      return `
        <button type="button" data-item-id="${item2.id}" data-path-index="${index2}">
          <svg width="16" height="16" overflow="visible">
            <path d="${path.scaleWith(16, 16).d}" style="fill:${item2.fill};stroke:currentColor" stroke-width="1" />
          </svg>
        </button>
      `;
    });
  }
}
var DragAreaView$1 = "";
class DragAreaView extends EditorElement {
  initState() {
    return {
      mode: "selection",
      x: 0,
      y: 0,
      width: 1e4,
      height: 1e4,
      cachedCurrentElement: {},
      html: ""
    };
  }
  template() {
    return `
            <div class="elf--drag-area-view" ref="$dragAreaView"></div>            
        `;
  }
  checkSelectionArea(e2) {
    const mousePoint = this.$viewport.getWorldPosition(e2);
    if (this.$selection.hasPoint(mousePoint)) {
      return true;
    }
  }
  checkEditMode(e2) {
    if (this.$config.get("set.tool.hand")) {
      return false;
    }
    const code2 = this.$shortcuts.getGeneratedKeyCode(KEY_CODE.space);
    if (this.$keyboardManager.check(code2)) {
      return false;
    }
    const mousePoint = this.$viewport.getWorldPosition(e2);
    this.inSelection = false;
    if (this.$selection.hasPoint(mousePoint)) {
      this.inSelection = true;
      if (this.$selection.current.is("artboard")) {
        if (this.$selection.current.hasChildren()) {
          this.$config.init("set.dragarea.mode", true);
          this.$config.init("set.move.mode", false);
          return true;
        } else {
          this.$config.init("set.dragarea.mode", false);
          this.$config.init("set.move.mode", true);
          return true;
        }
      } else {
        this.$config.init("set.dragarea.mode", false);
        this.$config.init("set.move.mode", true);
        return true;
      }
    }
    this.mouseOverItem = this.$selection.filteredLayers[0];
    if (this.mouseOverItem) {
      this.$config.init("set.dragarea.mode", false);
      this.$config.init("set.move.mode", true);
    } else {
      this.$config.init("set.dragarea.mode", true);
      this.$config.init("set.move.mode", false);
    }
    return true;
  }
  [POINTERSTART("$dragAreaView") + IF("checkEditMode") + MOVE("movePointer") + END("moveEndPointer")](e2) {
    if (this.$config.get("set.dragarea.mode")) {
      this.emit("startDragAreaView");
    } else if (this.$config.get("set.move.mode")) {
      this.initMousePoint = this.$viewport.getWorldPosition();
      this.mouseOverItem = this.$selection.filteredLayers[0];
      if (e2.altKey) {
        if (this.$selection.isEmpty === false && this.$selection.hasPoint(this.initMousePoint)) {
          this.$selection.selectAfterCopy();
          this.trigger("refreshAllCanvas");
          this.emit("refreshLayerTreeView");
          this.initializeDragSelection();
          this.emit("history.refreshSelection");
        }
      } else {
        if (this.mouseOverItem) {
          const id = this.mouseOverItem.id;
          if (e2.shiftKey) {
            this.$selection.toggleById(id);
          } else {
            if (this.$selection.check({ id }) === false) {
              const current = this.$model.get(id);
              if (current && current.is("artboard") && current.hasChildren())
                ;
              else {
                this.$selection.selectByGroup(id);
              }
            }
          }
        }
        this.initializeDragSelection();
        this.emit("history.refreshSelection");
      }
    }
  }
  initializeDragSelection() {
    this.$selection.reselect();
    this.$snapManager.clear();
    this.emit("refreshSelectionTool", true);
  }
  movePointer(dx, dy) {
    if (this.$config.get("set.dragarea.mode")) {
      this.emit("moveDragAreaView");
    } else if (this.$config.get("set.move.mode"))
      ;
  }
  moveEndPointer() {
    if (this.$config.get("set.dragarea.mode")) {
      this.emit("endDragAreaView");
    } else if (this.$config.get("set.move.mode"))
      ;
    this.$config.init("set.dragarea.mode", false);
    this.$config.init("set.move.mode", false);
  }
}
class DragAreaRectView extends EditorElement {
  initState() {
    return {
      mode: "selection",
      x: 0,
      y: 0,
      width: 1e4,
      height: 1e4,
      cachedCurrentElement: {},
      html: ""
    };
  }
  template() {
    return `
            <div class="elf--drag-area-view" ref="$dragAreaView" style="pointer-events:none;">
                <div class='drag-area-rect' ref='$dragAreaRect'></div>
            </div>            
        `;
  }
  [SUBSCRIBE("drawAreaView")](style) {
    this.refs.$dragAreaRect.css(style);
  }
  [SUBSCRIBE("initDrawAreaView")]() {
    this.trigger("drawAreaView", {
      left: Length.px(-1e4),
      top: Length.px(0),
      width: Length.px(0),
      height: Length.px(0)
    });
  }
  [SUBSCRIBE("startDragAreaView")]() {
    this.initMousePoint = this.$viewport.getWorldPosition();
    this.$config.init("set.move.control.point", true);
    this.dragRect = {
      left: Length.px(this.initMousePoint[0]),
      top: Length.px(this.initMousePoint[1]),
      width: Length.px(0),
      height: Length.px(0)
    };
    this.trigger("drawAreaView", this.dragRect);
  }
  getSelectedItems(rect2, areaVerties) {
    var project2 = this.$selection.currentProject;
    let items = [];
    let selectedArtboard = [];
    if (project2) {
      if (rect2.width === 0 && rect2.height === 0) {
        items = [];
      } else {
        project2.layers.forEach((layer2) => {
          if (layer2.is("artboard") && layer2.isIncludeByArea(areaVerties)) {
            selectedArtboard.push(layer2);
          } else if (layer2.is("artboard") && layer2.checkInArea(areaVerties) && layer2.hasChildren() === false) {
            items.push(layer2);
          } else {
            items.push.apply(items, layer2.checkInAreaForAll(areaVerties));
          }
        });
        items = items.filter((it) => {
          return it.isDragSelectable;
        });
        if (items.length > 1) {
          items = items.filter((it) => {
            return it.is("artboard") === false;
          });
        }
      }
    }
    const selectedItems = selectedArtboard.length ? selectedArtboard : items;
    return selectedItems;
  }
  [SUBSCRIBE("moveDragAreaView")]() {
    const e2 = this.$config.get("bodyEvent");
    const targetMousePoint = this.$viewport.getWorldPosition();
    const newDist = floor([], subtract([], targetMousePoint, this.initMousePoint));
    if (e2.shiftKey) {
      newDist[1] = newDist[0];
    }
    const startVertex = floor([], this.initMousePoint);
    const endVertex = floor([], add$1([], this.initMousePoint, newDist));
    const start2 = this.$viewport.applyVertex(startVertex);
    const end2 = this.$viewport.applyVertex(endVertex);
    const locaRect = toRectVerties([start2, end2]);
    this.dragRect = {
      left: locaRect[0][0],
      top: locaRect[0][1],
      width: Math.abs(locaRect[1][0] - locaRect[0][0]),
      height: Math.abs(locaRect[3][1] - locaRect[0][1])
    };
    this.trigger("drawAreaView", {
      left: Length.px(this.dragRect.left),
      top: Length.px(this.dragRect.top),
      width: Length.px(this.dragRect.width),
      height: Length.px(this.dragRect.height)
    });
    var { left: x2, top: y2, width: width2, height: height2 } = this.dragRect;
    var rect2 = {
      x: x2,
      y: y2,
      width: width2,
      height: height2
    };
    const selectedItems = this.getSelectedItems(rect2, toRectVertiesWithoutTransformOrigin([startVertex, endVertex]));
    if (this.$selection.selectByGroup(...selectedItems)) {
      this.emit("refreshSelection");
      this.emit("refreshSelectionTool", true);
    }
  }
  [SUBSCRIBE("endDragAreaView")]() {
    const targetMousePoint = this.$viewport.getWorldPosition();
    const newDist = floor([], subtract([], targetMousePoint, this.initMousePoint));
    this.$config.init("set.move.control.point", false);
    if (newDist[0] === 0 && newDist[1] === 0) {
      this.$selection.empty();
    }
    this.trigger("initDrawAreaView");
    this.$selection.reselect();
    this.emit("history.refreshSelection");
    this.emit("refreshSelectionTool", true);
    this.emit("removeGuideLine");
  }
}
var CanvasView$1 = "";
class CanvasView extends EditorElement {
  components() {
    return {
      PageTools,
      DragAreaRectView,
      HTMLRenderView,
      DragAreaView
    };
  }
  initState() {
    return {
      cursor: "auto",
      cursorArgs: []
    };
  }
  afterRender() {
    this.nextTick(() => {
      this.trigger("resizeCanvas");
      this.emit("moveSelectionToCenter", false);
      this.refreshCursor();
    }, 10);
  }
  template() {
    return `
      <div class='elf--page-container' tabIndex="-1" ref='$container'>
        <div class='page-view' ref="$pageView">
          <div class='page-lock scrollbar' ref='$lock'>            

            <!-- \uC120\uD0DD \uC601\uC5ED \uC774\uBCA4\uD2B8 \uC124\uC815  -->
            ${createComponent("DragAreaView", {
      ref: "$dragAreaView"
    })}

            <!-- HTML \uB80C\uB354\uB9C1 \uC601\uC5ED  --> 
            ${createComponent("HTMLRenderView", {
      ref: "$htmlRenderView"
    })}

            <!-- \uB4DC\uB798\uADF8 \uC601\uC5ED \uADF8\uB824\uC8FC\uB294 \uBDF0 --> 
            ${createComponent("DragAreaRectView", {
      ref: "$dragAreaRectView"
    })}

            <!-- \uCE94\uBC84\uC2A4 \uC601\uC5ED\uC5D0 \uADF8\uB9AC\uAE30 \uB3C4\uC640\uC8FC\uB294 \uBDF0 -->
            ${this.$injectManager.generate("canvas.view")}              

          </div>
        </div>
        ${createComponent("PageTools")}
      </div>
    `;
  }
  [BIND("$pageView")]() {
    return {
      style: {
        "--elf--canvas-background-color": this.$config.get("style.canvas.background.color")
      }
    };
  }
  checkSpace(e2) {
    if (this.$config.get("set.tool.hand")) {
      return true;
    }
    return this.$keyboardManager.check(this.$shortcuts.getGeneratedKeyCode(KEY_CODE.space));
  }
  [POINTERSTART("$lock") + IF("checkSpace") + MOVE("movePan") + END("moveEndPan")](e2) {
    this.startMovePan();
  }
  [CONFIG("set.tool.hand")](value) {
    if (value) {
      this.startMovePan();
      this.emit("refreshCursor", "grab");
    } else {
      this.emit("recoverCursor", "auto");
      this.emit("addStatusBarMessage", "");
    }
  }
  startMovePan() {
    this.lastDist = create$4();
    this.emit("addStatusBarMessage", this.$i18n("viewport.panning.enable"));
  }
  movePan(dx, dy) {
    this.emit("refreshCursor", "grabbing");
    const currentDist = fromValues(dx, dy, 0);
    this.$viewport.pan(...transformMat4([], subtract([], this.lastDist, currentDist), this.$viewport.scaleMatrixInverse));
    this.lastDist = currentDist;
  }
  refreshCursor() {
    if (this.$config.get("set.tool.hand") === false) {
      this.emit("refreshCursor", "auto");
      this.emit("addStatusBarMessage", "");
    } else {
      this.emit("refreshCursor", "grab");
    }
  }
  moveEndPan() {
    this.refreshCursor();
  }
  async [BIND("$container")]() {
    const cursor = await this.$editor.cursorManager.load(this.state.cursor, ...this.state.cursorArgs || []);
    return {
      style: {
        cursor
      }
    };
  }
  [DRAGOVER("$lock") + PREVENT]() {
  }
  [DROP("$lock") + PREVENT](e2) {
    const newCenter = this.$viewport.getWorldPosition(e2);
    if (e2.dataTransfer.getData("text/asset")) {
      this.emit("drop.asset", {
        asset: { id: e2.dataTransfer.getData("text/asset"), center: newCenter }
      });
    } else {
      Resource.getAllDropItems(e2);
      const id = Dom.create(e2.target).attr("data-id");
      if (id) {
        this.emit("drop.asset", {
          gradient: e2.dataTransfer.getData("text/gradient"),
          pattern: e2.dataTransfer.getData("text/pattern"),
          color: e2.dataTransfer.getData("text/color"),
          imageUrl: e2.dataTransfer.getData("image/info")
        }, id);
      } else {
        const imageUrl = e2.dataTransfer.getData("image/info");
        this.emit("dropImageUrl", imageUrl);
      }
    }
  }
  [WHEEL("$lock") + PREVENT](e2) {
    const [dx, dy] = normalizeWheelEvent(e2);
    if (!this.state.gesture) {
      if (e2.ctrlKey) {
        this.$viewport.setMousePoint(e2.clientX, e2.clientY);
      }
      this.emit("startGesture");
      this.state.gesture = true;
    } else {
      if (e2.ctrlKey) {
        const zoomFactor = 1 - 2.5 * dy / 100;
        this.$viewport.zoom(zoomFactor);
      } else {
        const newDx = -2.5 * dx;
        const newDy = -2.5 * dy;
        this.$viewport.pan(-newDx / this.$viewport.scale, -newDy / this.$viewport.scale, 0);
      }
    }
    clearTimeout(this.state.timer);
    this.state.timer = setTimeout(() => {
      this.state.gesture = void 0;
      this.emit("endGesture");
    }, 200);
  }
  refreshCanvasSize() {
    this.$viewport.refreshCanvasSize(this.refs.$lock.rect());
  }
  [SUBSCRIBE("resize.window", "resizeCanvas")]() {
    this.refreshCanvasSize();
  }
  [SUBSCRIBE("changeIconView")](cursor, ...args2) {
    if (`${this.state.cursor} ${this.state.cursorArgs}` === `${cursor} ${args2}`) {
      return;
    }
    this.state.cursor = cursor;
    this.state.cursorArgs = args2;
    this.bindData("$container");
  }
}
var BodyPanel$1 = "";
var PageSubEditor$1 = "";
class PageSubEditor extends EditorElement {
  template() {
    return `
      <div class='elf--page-subeditor'>
        ${this.$injectManager.generate("page.subeditor.view")}         
      </div>
    `;
  }
}
class BodyPanel extends EditorElement {
  components() {
    return {
      CanvasView,
      VerticalRuler,
      HorizontalRuler,
      PageSubEditor
    };
  }
  template() {
    return `
      <div class="elf--body-panel">
        <div class="submenu-area">
          ${createComponent("PageSubEditor")}
        </div>
        <div class='editing-area'>
          ${createComponent("HorizontalRuler")}
          ${createComponent("VerticalRuler")}
          ${createComponent("CanvasView")}
        </div>
      </div>
    `;
  }
  [BIND("$el")]() {
    return {
      class: `elf--body-panel ${this.$config.get("show.ruler") ? "ruler" : ""}`
    };
  }
  [CONFIG("show.ruler")]() {
    this.refresh();
  }
  [SUBSCRIBE("bodypanel.toggle.fullscreen")]() {
    this.refs.$el.toggleFullscreen();
  }
}
var BaseWindow$1 = "";
class BaseWindow extends EditorElement {
  template() {
    return `
      <div class='elf--window-background'>
        <div class='window ${this.getClassName()}'>
            <div class='window-title' ref="$title">
                <label>${this.getTitle()}</label>
                <span class="tools">
                  ${this.getTools()}
                  <button type='button' class='close' ref='$close'>${iconUse$1("close")}</button>
                </span>
            </div>
            <div class='window-body'>${this.getBody()}</div>
        </div>
      </div>
        `;
  }
  getClassName() {
    return "";
  }
  getTitle() {
    return "";
  }
  getTools() {
    return "";
  }
  getBody() {
    return "";
  }
  [CLICK("$close")]() {
    this.$el.hide();
  }
  show(width2 = 200) {
    this.$el.show("block");
  }
  hide() {
    this.$el.hide();
  }
}
var ExportWindow$1 = "";
class ExportWindow extends BaseWindow {
  getClassName() {
    return "elf--export-window";
  }
  getTitle() {
    return "Export";
  }
  initState() {
    return {
      selectedIndex: 1
    };
  }
  getBody() {
    return `
        <div class="tab" ref="$tab">
            <div class="tab-header full" ref="$header">
                <div class="tab-item selected" data-value="1">
                    <label>HTML</label>
                </div>
                <div class="tab-item" data-value="2">
                    <label>CSS</label>
                </div>                
                <div class="tab-item" data-value="6">
                    <label>SVG Image</label>
                </div>     
            </div>
            <div class="tab-body" ref="$body">
                <div class="tab-content selected" data-value="1" ref="$html">
                </div>
                <div class='tab-content' data-value='2' ref="$css">
                </div>                        
                <div class="tab-content" data-value="6" ref="$svgimage">
                </div>                                                                       
            </div>
      </div>
        `;
  }
  [SUBSCRIBE("showExportWindow")]() {
    this.show();
    this.refresh();
  }
  refresh() {
    var project2 = this.$selection.currentProject || { layers: [] };
    var css = `
${this.makeStyle(project2)}
${project2.layers.map((item2) => this.makeStyle(item2)).join("\n")}
`;
    var html2 = `
${this.$editor.html.renderSVG(project2)}
${this.$editor.html.render(project2)}
        `;
    var svgData = project2.layers.map((item2) => {
      return this.$editor.svg.render(item2);
    });
    if (shiki) {
      shiki.getHighlighter({
        theme: "light-plus"
      }).then((highlighter) => {
        if (html_beautify) {
          html2 = html_beautify(html2, { indent: 2 });
          const changedHtml = highlighter.codeToHtml(html2, "html");
          this.refs.$html.html(changedHtml);
          css = html_beautify(css, { indent: 2 });
          const changedCss = highlighter.codeToHtml(css, "html");
          this.refs.$css.html(changedCss);
          svgData = html_beautify(svgData.join(""), { indent: 2 });
          const changedSvgData = highlighter.codeToHtml(svgData, "html");
          this.refs.$svgimage.html(changedSvgData);
        }
      });
    }
  }
  makeStyle(item2) {
    return this.$editor.html.toExportStyle(item2, null);
  }
  makeHTML(item2) {
    return this.$editor.html.render(item2);
  }
  [CLICK("$header .tab-item")](e2) {
    var selectedIndex = +e2.$dt.attr("data-value");
    if (this.state.selectedIndex === selectedIndex) {
      return;
    }
    this.$el.$$(`[data-value="${this.state.selectedIndex}"]`).forEach((it) => it.removeClass("selected"));
    this.$el.$$(`[data-value="${selectedIndex}"]`).forEach((it) => it.addClass("selected"));
    this.setState({ selectedIndex }, false);
  }
}
registElement({ ExportWindow });
var ShortcutWindow$1 = "";
const categories = new Set();
shortcuts.forEach((it) => {
  categories.add(it.category);
});
const keys = {};
categories.forEach((it) => {
  shortcuts.filter((item2) => item2.category === it).forEach((item2) => {
    if (!keys[item2.category]) {
      keys[item2.category] = [];
    }
    keys[item2.category].push(item2);
  });
});
const keyAlias = {
  "ARROWRIGHT": "\u2192",
  "ARROWLEFT": "\u2190",
  "ARROWUP": "\u2191",
  "ARROWDOWN": "\u2192",
  "BACKSPACE": "\u232B",
  "CMD": "\u2318"
};
const OSName = os();
class ShortcutWindow extends BaseWindow {
  getClassName() {
    return "elf--shortcut-window";
  }
  getTitle() {
    return "ShortCuts";
  }
  getKeyString(os2, item2) {
    return (item2[os2] || item2.key).split("+").map((it) => it.trim()).map((it) => {
      const keyString = it.toUpperCase();
      return `<span>${keyAlias[keyString] || keyString}</span>`;
    }).join(" + ");
  }
  getTemplateForShortcutItem(item2) {
    return `
            <div class='shortcut-view-item'>
                <div class='title'>${item2.description}</div>
                <div class='os-item'>${this.getKeyString(OSName, item2)}</div>
            </div>                        
        `;
  }
  getTemplateForCategory(category, list2 = []) {
    return `
            <div class='item'>
                <h2>${category}</h2>
                <div>
                    ${list2.map((it) => this.getTemplateForShortcutItem(it)).join("")}
                </div>
            </div>
        `;
  }
  getTemplateForLayer() {
    return `
            <div class='item'>
                <h2>Layer</h2>
                <div>
                    <div class='shortcut-view-item'>
                        <div class='title'>
                            Add Rect
                            <span class='description'>fdsafdsfdf</span>
                        </div>

                        <div class='os-item mac'><span>CTRL</span>+<span>R</span></div>
                        <div class='os-item win'>R</div>
                        <div class='os-item linux'>R</div>
                    </div>
                </div>
            </div>
        `;
  }
  getBody() {
    return `
        <div class="list">
            ${Object.keys(keys).map((category) => {
      return this.getTemplateForCategory(category, keys[category]);
    }).join("")}
        </div>
        `;
  }
  [SUBSCRIBE("showShortcutWindow")]() {
    this.show();
  }
}
registElement({ ShortcutWindow });
var ProjectWindow$1 = "";
class ProjectWindow extends BaseWindow {
  getClassName() {
    return "elf--project-window";
  }
  getTitle() {
    return "Project Manager";
  }
  initState() {
    return {
      selectedIndex: 1
    };
  }
  getBody() {
    return `
        <div class="project-container">
            <div class="project-menu left">
                Project Menu
            </div>
            <div class="project-list right">
                Project List
            </div>
        </div>
        `;
  }
  [SUBSCRIBE("open.projects")]() {
    this.show();
    this.refresh();
  }
  refresh() {
    this.$selection.currentProject || { layers: [] };
  }
}
registElement({ ProjectWindow });
const start = (ElementClass, opt) => {
  const $container = Dom.create(opt.container || document.body);
  const app = new ElementClass(opt, opt);
  app.render($container);
  return app;
};
class EmbedEditorWindow extends BaseWindow {
  getClassName() {
    return "elf--export-window";
  }
  getTitle() {
    return "Mini Editor";
  }
  initState() {
    return {
      selectedIndex: 1
    };
  }
  refresh() {
    if (this.$el.isShow()) {
      App.createDesignEditor({
        container: this.refs.$body.el,
        config: {
          "editor.design.mode": "item"
        }
      });
    }
  }
  getBody() {
    return `
        <div class="test" ref="$body">

      </div>
        `;
  }
  [SUBSCRIBE("showEmbedEditorWindow")]() {
    this.show();
    this.refresh();
  }
}
registElement({ EmbedEditorWindow });
var NotificationView$1 = "";
class NotificationView extends EditorElement {
  template() {
    return `
            <div class='elf--notification-view'>
            </div>
        `;
  }
  [TRANSITIONEND("$el")](e2) {
    Dom.create(e2.target).remove();
  }
  [CLICK("$el .item > .icon")](e2) {
    e2.$dt.parent().remove();
  }
  getMessageTemplate(type, title2, description, duration = 1e3) {
    return `
        <div class='item ${type}' style='transition-duration: ${duration}ms;'>
            <div class='title'>${title2}</div> 
            <div class='description'>${description}</div>
            <span class='icon'>${iconUse$1("close")}</span>
        </div>
    `;
  }
  [SUBSCRIBE("notify")](type, title2, description, duration = 1e3) {
    const $dom = Dom.createByHTML(this.getMessageTemplate(type, title2, description, 1e3));
    this.$el.prepend($dom);
    setTimeout(($dom2) => {
      $dom2.css("opacity", 0);
    }, duration, $dom);
  }
}
class PopupManager extends EditorElement {
  components() {
    return {
      NotificationView
    };
  }
  template() {
    return `
      <div class="popup-manger">
        ${createComponent("ExportWindow")}
        ${createComponent("EmbedEditorWindow")}
        ${createComponent("ProjectWindow")}
        ${createComponent("ShortcutWindow")}
        ${createComponent("NotificationView")}
        ${this.$injectManager.generate("popup")}
      </div>
    `;
  }
}
const formElements = ["TEXTAREA", "INPUT", "SELECT"];
class KeyboardManager extends EditorElement {
  template() {
    return `
      <div class="keyboard-manager"></div>
    `;
  }
  isNotFormElement(e2) {
    var tagName = e2.target.tagName;
    if (formElements.includes(tagName))
      return false;
    else if (Dom.create(e2.target).attr("contenteditable") === "true")
      return false;
    return true;
  }
  [KEYDOWN("document") + IF("isNotFormElement")](e2) {
    this.emit("keymap.keydown", e2);
  }
  [KEYUP("document") + IF("isNotFormElement")](e2) {
    this.emit("keymap.keyup", e2);
  }
}
class TabPanel extends EditorElement {
  initState() {
    return {
      value: this.props.value || ""
    };
  }
  template() {
    const { content: content2 } = this.props;
    const { value } = this.state;
    return /* @__PURE__ */ createElementJsx("div", {
      class: "tab-content scrollbar",
      "data-value": value
    }, content2);
  }
}
var Tabs$1 = "";
class Tabs extends EditorElement {
  afterRender() {
    setTimeout(() => {
      this.setValue(this.state.selectedValue);
    }, 0);
  }
  initState() {
    return {
      type: this.props.type || "number",
      selectedValue: this.props.selectedValue || ""
    };
  }
  template() {
    return `
        <div class="tab" ref="$tab"></div>
      `;
  }
  [LOAD("$tab")]() {
    const { content: content2, contentChildren } = this.props;
    const children2 = contentChildren.filter((it) => it.component === TabPanel);
    return [
      /* @__PURE__ */ createElementJsx("div", {
        class: "tab-header",
        ref: "$header"
      }, children2.map((it) => /* @__PURE__ */ createElementJsx("div", {
        class: "tab-item",
        "data-value": it.props.value,
        title: it.props.title
      }, /* @__PURE__ */ createElementJsx("label", {
        class: "title"
      }, it.props.title)))),
      /* @__PURE__ */ createElementJsx("div", {
        class: "tab-body",
        ref: "$body"
      }, content2)
    ];
  }
  [CLICK("$header .tab-item:not(.empty-item)")](e2) {
    var selectedValue = e2.$dt.attr("data-value");
    this.setValue(selectedValue);
  }
  updateData(data) {
    this.setState(data, false);
    this.parent.trigger(this.props.onchange, this.getValue());
  }
  getValue() {
    return this.state.selectedValue;
  }
  setValue(selectedValue) {
    var _a, _b;
    (_a = this.$el.$(`* > .tab-item[data-value="${selectedValue}"]`)) == null ? void 0 : _a.onlyOneClass("selected");
    (_b = this.$el.$(`* > .tab-content[data-value="${selectedValue}"]`)) == null ? void 0 : _b.onlyOneClass("selected");
    this.updateData({ selectedValue });
  }
}
class Inspector extends EditorElement {
  afterRender() {
    this.$el.toggle(this.$config.is("editor.design.mode", DesignMode.DESIGN));
  }
  [BIND("$el")]() {
    return {
      style: {
        display: this.$config.is("editor.design.mode", DesignMode.DESIGN) ? "block" : "none"
      }
    };
  }
  template() {
    return /* @__PURE__ */ createElementJsx("div", {
      class: "feature-control inspector"
    }, /* @__PURE__ */ createElementJsx("div", null, /* @__PURE__ */ createElementJsx(Tabs, {
      ref: "$tab",
      selectedValue: "style",
      onchange: (value) => {
        this.$config.set("inspector.selectedValue", value);
      }
    }, /* @__PURE__ */ createElementJsx(TabPanel, {
      value: "style",
      title: this.$i18n("inspector.tab.title.design")
    }, /* @__PURE__ */ createElementJsx("div", {
      style: "display: flex; flex-direction: column;"
    }, this.$injectManager.generate("inspector.tab.style"), /* @__PURE__ */ createElementJsx("div", {
      class: "empty",
      style: "order: 1000000;"
    }))), /* @__PURE__ */ createElementJsx(TabPanel, {
      value: "transition",
      title: this.$i18n("inspector.tab.title.transition")
    }, /* @__PURE__ */ createElementJsx("div", {
      style: "display: flex; flex-direction: column;"
    }, this.$injectManager.generate("inspector.tab.transition"), /* @__PURE__ */ createElementJsx("div", {
      class: "empty",
      style: "order: 1000000;"
    }))), /* @__PURE__ */ createElementJsx(TabPanel, {
      value: "code",
      title: this.$i18n("inspector.tab.title.code")
    }, /* @__PURE__ */ createElementJsx("div", {
      style: "display: flex; flex-direction: column;"
    }, this.$injectManager.generate("inspector.tab.code"), /* @__PURE__ */ createElementJsx("div", {
      class: "empty",
      style: "order: 1000000;"
    }))), this.$injectManager.getTargetMenuItems("inspector.tab").map((it) => {
      const { value, title: title2, loadElements } = it.class;
      return /* @__PURE__ */ createElementJsx(TabPanel, {
        value,
        title: title2,
        icon: it.icon
      }, /* @__PURE__ */ createElementJsx("div", {
        style: "display: flex: flex-direction: column;"
      }, loadElements.map((element) => craeteElement(element)), this.$injectManager.generate("inspector.tab." + it.value), /* @__PURE__ */ createElementJsx("div", {
        class: "empty",
        style: "order: 1000000;"
      })));
    }))));
  }
}
class LanguageSelector extends EditorElement {
  get locales() {
    return Object.keys(this.$editor.i18n.locales);
  }
  template() {
    var languages = this.locales.map((lang) => {
      var label = this.$i18n(`app.lang.${lang}`);
      return { text: label, value: lang };
    });
    return `
            <div class='status-selector'>
                <div class='item'>
                    ${createComponent("SelectEditor", {
      ref: "$locale",
      options: languages,
      value: this.$editor.locale,
      onchange: "changeLocale"
    })}
                    /> 
                </div>
            </div>
        `;
  }
  [SUBSCRIBE_SELF("changeLocale")](key, locale) {
    this.emit("setLocale", locale);
  }
}
class LayoutSelector extends EditorElement {
  template() {
    var layouts = ["all", "css", "svg"].map((layout2) => {
      var label = this.$i18n(`app.layout.${layout2}`);
      return { value: layout2, text: label };
    });
    return `
            <div class='status-selector'>
                <div class='item'>
                    ${createComponent("SelectEditor", {
      ref: "$locale",
      options: layouts,
      value: this.$editor.layout,
      onchange: "changeEditorLayoutValue"
    })}
                        
                    /> 
                </div>
            </div>
        `;
  }
  [SUBSCRIBE_SELF("changeEditorLayoutValue")](key, layout2) {
    this.$config.set("editor.layout.mode", layout2);
  }
}
class VersionView extends EditorElement {
  initState() {
    return {
      version: `@@VERSION@@`
    };
  }
  template() {
    return `<div class="version-view">v${this.state.version}</div>`;
  }
}
var StatusBar$1 = "";
class StatusBar extends EditorElement {
  components() {
    return {
      LanguageSelector,
      LayoutSelector,
      VersionView
    };
  }
  template() {
    return `
            <div class='elf--status-bar'>
                <div class='tool-view left' ref='$leftTool'>
                    ${this.$injectManager.generate("statusbar.left")}                    
                </div>            
                <div class='message-view' ref='$msg'></div>
                <div class='tool-view right' ref='$rightTool'>
                    ${this.$injectManager.generate("statusbar.right")}
                    ${createComponent("LayoutSelector")}
                    ${createComponent("VersionView")}
                </div>
            </div>
        `;
  }
  initState() {
    return {
      msg: ""
    };
  }
  [BIND("$msg")]() {
    return {
      text: this.state.msg
    };
  }
  [SUBSCRIBE("addStatusBarMessage")](msg) {
    this.setState({ msg });
  }
}
const DEFAULT_TITLE = "";
const DEFAULT_ICON = "";
const DEFAULT_CHECKED = false;
class MenuItem extends EditorElement {
  template() {
    return `
        <button 
            type="button" 
            class='elf--menu-item ${this.getClassName()}' 
            data-no-title="${this.isHideTitle()}" 
            ${this.isHideTitle() && this.isHideTooltip() === false ? `data-tooltip="${this.getTitle()}"` : ""} 
            checked="${this.getChecked() ? "checked" : ""}"
            ${this.isDisabled() ? "disabled" : ""}
            data-direction="${this.getDirection()}"
        >
            <div class="icon ${this.getIcon()}" ref="$icon">${obj[this.getIconString()] || this.getIconString() || ""}</div>
            ${this.isHideTitle() ? "" : `<div class="title">${this.getTitle()}</div>`}
            
        </button>
        `;
  }
  getClassName() {
    return "";
  }
  clickButton(e2) {
  }
  getChecked() {
    return DEFAULT_CHECKED;
  }
  isDisabled() {
    return false;
  }
  setSelected(isSelected) {
    this.$el.toggleClass("selected", isSelected);
  }
  getTitle() {
    return DEFAULT_TITLE;
  }
  getIcon() {
    return DEFAULT_ICON;
  }
  setIcon(iconString) {
    this.refs.$icon.html(obj[iconString] || iconString || "");
  }
  getIconString() {
    return DEFAULT_ICON;
  }
  isHideTitle() {
    return false;
  }
  isHideTooltip() {
    return true;
  }
  [CLICK()](e2) {
    this.clickButton(e2);
  }
  getDirection() {
    return this.props.direction || "";
  }
  static createMenuItem(opt = {}) {
    return class extends MenuItem {
      getIconString() {
        return opt.iconString || "add_box";
      }
      getTitle() {
        return opt.title || "New Item";
      }
      isHideTitle() {
        return opt.isHideTitle || true;
      }
      clickButton(e2) {
        opt.clickButton(e2);
      }
      getDirection() {
        return opt.direction;
      }
    };
  }
}
class Projects extends MenuItem {
  getIconString() {
    return "note";
  }
  getTitle() {
    return this.$i18n("menu.item.projects.title");
  }
  isHideTitle() {
    return true;
  }
  clickButton(e2) {
    this.emit("open.projects");
  }
}
var ToolBar$1 = "";
var DropdownMenu$1 = "";
class DropdownMenu extends EditorElement {
  initialize() {
    super.initialize();
    const events = this.props.events || [];
    if (events.length) {
      events.forEach((event) => {
        this.on(event, () => this.refresh());
      });
    }
  }
  initState() {
    return {
      direction: this.props.direction || "left",
      opened: this.props.opened || false,
      items: this.props.items || [],
      selectedKey: this.props.selectedKey,
      dy: this.props.dy || 0
    };
  }
  makeMenuItem(it) {
    var _a;
    if (it === "-" || it.type === "divider") {
      return `<li class="dropdown-divider"></li>`;
    }
    if (it.type === "link") {
      return `
          <li><a href="${it.href}" target="${it.target || "_blank"}">${this.$i18n(it.title)}</a></li>
        `;
    }
    if (Array.isArray(it.items)) {
      return `
          <li>
              <label>${this.$i18n(it.title)}</label> 
              <span>${iconUse$1("arrowRight")}</span>              
              <ul>
                  ${it.items.map((child) => this.makeMenuItem(child)).join("")}
              </ul>
          </li>
        `;
    }
    const checked = isFunction(it.checked) ? it.checked(this.$editor) : "";
    return `
        <li data-command="${it.command}" data-has-children="${Boolean((_a = it.items) == null ? void 0 : _a.length)}"
          ${it.disabled && "disabled"} 
          ${it.shortcut && "shortcut"}
          ${checked && "checked"}
          ${it.nextTick && `data-next-tick=${variable$4(it.nextTick, this.groupId)}`} 
          ${it.args && `data-args=${variable$4(it.args, this.groupId)}`} 
          ${it.key && `data-key=${it.key}`} 
        >
            <span class="icon">${checked ? iconUse$1("check") : it.icon || ""}</span>
            <div class='menu-item-text'>
              <label>${this.$i18n(it.title)}</label>
              <kbd class="shortcut">${it.shortcut || ""}</kbd>
            </div>
        </li>
      `;
  }
  template() {
    const { direction, opened, items } = this.state;
    const openedClass = opened ? "opened" : "";
    return `
        <div class="dropdown-menu ${openedClass}" data-direction="${direction}">
          <span class='icon' ref="$icon"></span>
          <span class='dropdown-arrow' ref="$arrow">${iconUse$1("keyboard_arrow_down")}</span>
          <ul class="dropdown-menu-item-list" ref="$list"></ul>
          <div class="dropdown-menu-arrow">
              <svg viewBox="0 0 12 6" width="12" height="6">
                <path d="M0,6 L6,0 L12,6 "></path>
              </svg>
          </div>
      </div>
      `;
  }
  [LOAD("$icon")]() {
    return isFunction(this.props.icon) ? this.props.icon(this.state) : this.props.icon;
  }
  [BIND("$el")]() {
    const selected = isFunction(this.props.selected) ? this.props.selected(this.state, this.$editor) : false;
    return {
      "data-selected": selected,
      style: __spreadProps(__spreadValues({}, this.props.style || {}), {
        "--elf--dropdown-menu-width": this.props.width,
        "--elf--dropdown-menu-dy": isNotUndefined(this.props.dy) ? Length.px(this.props.dy) : 0
      })
    };
  }
  close() {
    this.setState({
      opened: false
    }, false);
    this.$el.removeClass("opened");
  }
  toggle() {
    this.setState({
      opened: !this.state.opened
    }, false);
    this.$el.toggleClass("opened", this.state.opened);
    if (this.state.opened) {
      this.emit("hideDropdownMenu");
    }
  }
  get groupId() {
    return this.id + "$list";
  }
  [LOAD("$list") + DOMDIFF]() {
    initializeGroupVariables(this.groupId);
    return this.state.items.map((it) => this.makeMenuItem(it));
  }
  checkDropdownOpen(e2) {
    const ul = Dom.create(e2.target).closest("dropdown-menu-item-list");
    if (!ul)
      return true;
    return false;
  }
  [CLICK("$arrow") + IF("checkDropdownOpen")](e2) {
    this.toggle();
  }
  [CLICK("$icon")](e2) {
    if (this.state.selectedKey) {
      const menuItem = this.state.items.find((it) => it.key === this.state.selectedKey);
      const command = menuItem.command;
      const args2 = menuItem.args;
      const nextTick = menuItem.nextTick;
      const key = menuItem.key;
      if (command) {
        this.emit(command, ...args2);
      }
      if (nextTick && isFunction(nextTick)) {
        this.nextTick(nextTick);
      }
      this.setState({
        selectedKey: key
      });
      this.close();
    }
  }
  [CLICK("$el [data-command]")](e2) {
    const command = e2.$dt.data("command");
    const args2 = e2.$dt.data("args") || [];
    const nextTick = e2.$dt.data("next-tick");
    const key = e2.$dt.data("key");
    if (command) {
      this.emit(command, ...args2);
    }
    if (nextTick && isFunction(nextTick)) {
      this.nextTick(nextTick);
    }
    this.setState({
      selectedKey: key
    });
    this.close();
  }
  [SUBSCRIBE_SELF("updateMenuItems")](items) {
    this.setState({ items });
  }
  [SUBSCRIBE("hideDropdownMenu")]() {
    this.close();
  }
  [POINTERSTART("document")](e2) {
    const $target = Dom.create(e2.target);
    const $dropdown = $target.closest("dropdown-menu");
    if (!$dropdown) {
      this.close();
    } else if ($dropdown.el !== this.$el.el) {
      this.close();
    }
  }
}
class Undo extends MenuItem {
  getIconString() {
    return "undo";
  }
  getTitle() {
    return "Undo";
  }
  isHideTitle() {
    return true;
  }
  clickButton(e2) {
    this.emit("history.undo");
  }
}
class Redo extends MenuItem {
  getIconString() {
    return "redo";
  }
  getTitle() {
    return "Redo";
  }
  isHideTitle() {
    return true;
  }
  clickButton(e2) {
    this.emit("history.redo");
  }
}
class ExportView extends MenuItem {
  getIconString() {
    return "launch";
  }
  getTitle() {
    return this.$i18n("menu.item.export.title");
  }
  clickButton(e2) {
    this.emit("showExportView");
  }
}
class Download extends MenuItem {
  getIconString() {
    return "source";
  }
  getTitle() {
    return this.$i18n("menu.item.download.title");
  }
  clickButton(e2) {
    this.emit("downloadJSON");
  }
}
class Save extends MenuItem {
  getIconString() {
    return "storage";
  }
  getTitle() {
    return this.$i18n("menu.item.save.title");
  }
  clickButton(e2) {
    this.emit("saveJSON");
    this.nextTick(() => {
      this.emit("notify", "alert", "Save", "Save the content on localStorage", 2e3);
    });
  }
}
class Outline extends MenuItem {
  getIconString() {
    return "outline";
  }
  getTitle() {
    return "Outline";
  }
  isHideTitle() {
    return true;
  }
  clickButton(e2) {
    this.$config.toggle("show.outline");
    this.emit("addLayerView", "select");
  }
  [CONFIG("show.outline")](isShow) {
    this.setSelected(isShow);
  }
}
class SelectTool extends MenuItem {
  afterRender() {
    this.$el.$(".icon").css("transform", "rotate(-30deg)");
  }
  getIconString() {
    return "navigation";
  }
  getTitle() {
    return this.props.title || "Select";
  }
  clickButton(e2) {
    this.emit("addLayerView", "select");
  }
  doSelect() {
    this.setSelected(this.$config.is("editing.mode", EditingMode.SELECT));
  }
  [SUBSCRIBE("refreshSelection")]() {
    this.doSelect();
  }
  isHideTitle() {
    return true;
  }
  [CONFIG("editing.mode")]() {
    this.doSelect();
  }
}
class ThemeChanger extends MenuItem {
  getIconString() {
    if (this.$config.is("editor.theme", "dark")) {
      return "dark";
    } else {
      return "light";
    }
  }
  getTitle() {
    return "Theme";
  }
  isHideTitle() {
    return true;
  }
  clickButton(e2) {
    if (this.$config.get("editor.theme") === "dark") {
      this.$config.set("editor.theme", "light");
      this.setIcon("light");
    } else {
      this.$config.set("editor.theme", "dark");
      this.setIcon("dark");
    }
  }
}
class AddArtboard extends MenuItem {
  getIconString() {
    return "artboard";
  }
  getTitle() {
    return this.props.title || "ArtBoard";
  }
  clickButton(e2) {
    this.emit("addLayerView", "artboard");
  }
  isHideTitle() {
    return true;
  }
  doSelect() {
    this.setSelected(this.$config.is("editing.mode", EditingMode.APPEND) && this.$config.is("editing.mode.itemType", "artboard"));
  }
  [CONFIG("editing.mode")]() {
    this.doSelect();
  }
  [CONFIG("editing.mode.itemType")]() {
    this.doSelect();
  }
}
registElement({ AddArtboard });
[
  { icon: iconUse$1("rect"), title: "Rect Layer", command: "addLayerView", args: ["rect"], shortcut: KeyStringMaker({ key: "R" }) },
  { icon: iconUse$1("lens"), title: "Circle Layer", command: "addLayerView", args: ["circle"], shortcut: KeyStringMaker({ key: "O" }) },
  { icon: iconUse$1("title"), title: "Text", command: "addLayerView", args: ["text"], shortcut: KeyStringMaker({ key: "T" }) },
  { icon: iconUse$1("image"), title: "Image", command: "addLayerView", args: ["image"], shortcut: KeyStringMaker({ key: "I" }) },
  "-",
  { icon: iconUse$1("video"), title: "Video", command: "addLayerView", args: ["video"], shortcut: KeyStringMaker({ key: "V" }) },
  { icon: iconUse$1("iframe"), title: "IFrame", command: "addLayerView", args: ["iframe"], shortcut: KeyStringMaker({ key: "F" }) }
];
[
  { icon: iconUse$1("outline_rect"), title: "Rectangle", command: "addLayerView", args: ["svg-rect"], shortcut: KeyStringMaker({ key: "Shift+R" }) },
  { icon: iconUse$1("outline_circle"), title: "Circle", command: "addLayerView", args: ["svg-circle"], shortcut: KeyStringMaker({ key: "Shift+O" }) },
  { icon: iconUse$1("polygon"), title: "Polygon", command: "addLayerView", args: ["polygon", {
    "background-color": "transparent"
  }], shortcut: KeyStringMaker({ key: "Shift+P" }) },
  { icon: iconUse$1("star"), title: "Star", command: "addLayerView", args: ["star", {
    "background-color": "transparent"
  }], shortcut: KeyStringMaker({ key: "Shift+S" }) },
  "-",
  { icon: iconUse$1("smooth"), title: "Spline", command: "addLayerView", args: ["spline", {
    "background-color": "transparent"
  }], shortcut: KeyStringMaker({ key: "Shift+L" }) },
  { icon: iconUse$1("text_rotate"), title: "TextPath", command: "addLayerView", args: ["svg-textpath", {
    "background-color": "transparent"
  }], shortcut: KeyStringMaker({ key: "Shift+T" }) }
];
class AddRect extends MenuItem {
  getIconString() {
    return "rect";
  }
  getTitle() {
    return this.props.title || "Rect";
  }
  clickButton(e2) {
    this.emit("addLayerView", "rect");
  }
  isHideTitle() {
    return true;
  }
  doSelect() {
    this.setSelected(this.$config.is("editing.mode", EditingMode.APPEND) && this.$config.is("editing.mode.itemType", "rect"));
  }
  [CONFIG("editing.mode")]() {
    this.doSelect();
  }
  [CONFIG("editing.mode.itemType")]() {
    this.doSelect();
  }
}
registElement({ AddRect });
class AddSVGRect extends MenuItem {
  getIconString() {
    return "outline_rect";
  }
  getTitle() {
    return this.props.title || "RectPath";
  }
  clickButton(e2) {
    this.emit("addLayerView", "svg-rect");
  }
  isHideTitle() {
    return true;
  }
}
registElement({ AddSVGRect });
var DefaultMenu = [
  {
    type: "dropdown",
    style: {
      "margin-left": "12px"
    },
    icon: `<div class="logo-item"><label class='logo'></label></div>`,
    items: [
      { title: "menu.item.fullscreen.title", command: "toggle.fullscreen", shortcut: "ALT+/" },
      { title: "menu.item.shortcuts.title", command: "showShortcutWindow" },
      "-",
      { title: "menu.item.export.title", command: "showExportView" },
      { title: "menu.item.export.title", command: "showEmbedEditorWindow" },
      { title: "menu.item.download.title", command: "downloadJSON" },
      {
        title: "menu.item.save.title",
        command: "saveJSON",
        nextTick: () => {
          globalThis.emit("notify", "alert", "Save", "Save the content on localStorage", 2e3);
        }
      },
      {
        title: "menu.item.language.title",
        items: [
          { title: "English", command: "setLocale", args: [Language.EN], checked: (editor) => editor.locale === Language.EN },
          { title: "Fran\xE7ais", command: "setLocale", args: [Language.FR], checked: (editor) => editor.locale === Language.FR },
          { title: "Korean", command: "setLocale", args: [Language.KO], checked: (editor) => editor.locale === Language.KO }
        ]
      },
      "-",
      {
        title: "EasyLogic Studio",
        items: [
          { type: "link", title: "Github", href: "https://github.com/easylogic/editor" },
          { type: "link", title: "Learn", href: "https://www.easylogic.studio" }
        ]
      }
    ]
  },
  {
    type: "button",
    icon: "navigation",
    events: ["config:editing.mode"],
    selected: (editor) => {
      return editor.config.is("editing.mode", EditingMode.SELECT);
    },
    action: (editor) => {
      editor.emit("addLayerView", "select");
    }
  },
  {
    type: "button",
    icon: "artboard",
    events: ["config:editing.mode", "config:editing.mode.itemType"],
    selected: (editor) => {
      return editor.config.is("editing.mode", EditingMode.APPEND) && editor.config.is("editing.mode.itemType", "artboard");
    },
    action: (editor) => {
      editor.emit("addLayerView", "artboard");
    }
  },
  {
    type: "dropdown",
    selectedKey: "rect",
    icon: (state) => {
      switch (state.selectedKey) {
        case "circle":
          return iconUse$1("lens");
        case "text":
          return iconUse$1("title");
        case "image":
          return iconUse$1("image");
        case "video":
          return iconUse$1("video");
        case "iframe":
          return iconUse$1("iframe");
      }
      return iconUse$1("rect");
    },
    items: [
      { icon: iconUse$1("rect"), title: "Rect Layer", key: "rect", command: "addLayerView", args: ["rect"], shortcut: KeyStringMaker({ key: "R" }) },
      { icon: iconUse$1("lens"), title: "Circle Layer", key: "circle", command: "addLayerView", args: ["circle"], shortcut: KeyStringMaker({ key: "O" }) },
      { icon: iconUse$1("title"), title: "Text", key: "text", command: "addLayerView", args: ["text"], shortcut: KeyStringMaker({ key: "T" }) },
      { icon: iconUse$1("image"), title: "Image", key: "image", command: "addLayerView", args: ["image"], shortcut: KeyStringMaker({ key: "I" }) },
      "-",
      { icon: iconUse$1("video"), title: "Video", key: "video", command: "addLayerView", args: ["video"], shortcut: KeyStringMaker({ key: "V" }) },
      { icon: iconUse$1("iframe"), title: "IFrame", key: "iframe", command: "addLayerView", args: ["iframe"], shortcut: KeyStringMaker({ key: "F" }) }
    ],
    events: ["config:editing.mode", "config:editing.mode.itemType"],
    selected: (state, editor) => {
      return editor.config.is("editing.mode", EditingMode.APPEND) && (editor.config.is("editing.mode.itemType", "rect") || editor.config.is("editing.mode.itemType", "circle") || editor.config.is("editing.mode.itemType", "text") || editor.config.is("editing.mode.itemType", "image") || editor.config.is("editing.mode.itemType", "video") || editor.config.is("editing.mode.itemType", "iframe"));
    }
  },
  {
    type: "dropdown",
    selectedKey: "path",
    icon: (state) => {
      switch (state.selectedKey) {
        case "brush":
          return iconUse$1("brush");
      }
      return iconUse$1("pentool");
    },
    items: [
      { icon: iconUse$1("pentool"), title: "Pen", key: "path", command: "addLayerView", args: ["path"], shortcut: KeyStringMaker({ key: "P" }) },
      { icon: iconUse$1("brush"), title: "Pencil", key: "brush", command: "addLayerView", args: ["brush"], shortcut: KeyStringMaker({ key: "B" }) }
    ],
    events: ["config:editing.mode", "config:editing.mode.itemType"],
    selected: (state, editor) => {
      return (editor.config.is("editing.mode", EditingMode.PATH) || editor.config.is("editing.mode", EditingMode.DRAW)) && (state.selectedKey === "path" || state.selectedKey === "brush");
    }
  },
  {
    type: "dropdown",
    selectedKey: "svg-rect",
    icon: (state) => {
      switch (state.selectedKey) {
        case "svg-circle":
          return iconUse$1("outline_circle");
        case "polygon":
          return iconUse$1("polygon");
        case "star":
          return iconUse$1("star");
        case "spline":
          return iconUse$1("smooth");
        case "svg-textpath":
          return iconUse$1("text_rotate");
      }
      return iconUse$1("outline_rect");
    },
    items: [
      { icon: iconUse$1("outline_rect"), title: "Rectangle", key: "svg-rect", command: "addLayerView", args: ["svg-rect"], shortcut: KeyStringMaker({ key: "Shift+R" }) },
      { icon: iconUse$1("outline_circle"), title: "Circle", key: "svg-circle", command: "addLayerView", args: ["svg-circle"], shortcut: KeyStringMaker({ key: "Shift+O" }) },
      { icon: iconUse$1("polygon"), title: "Polygon", key: "svg-polygon", command: "addLayerView", args: ["polygon", {
        "background-color": "transparent"
      }], shortcut: KeyStringMaker({ key: "Shift+P" }) },
      { icon: iconUse$1("star"), title: "Star", key: "star", command: "addLayerView", args: ["star", {
        "background-color": "transparent"
      }], shortcut: KeyStringMaker({ key: "Shift+S" }) },
      "-",
      { icon: iconUse$1("smooth"), title: "Spline", key: "spline", command: "addLayerView", args: ["spline", {
        "background-color": "transparent"
      }], shortcut: KeyStringMaker({ key: "Shift+L" }) },
      { icon: iconUse$1("text_rotate"), title: "TextPath", key: "svg-texpath", command: "addLayerView", args: ["svg-textpath", {
        "background-color": "transparent"
      }], shortcut: KeyStringMaker({ key: "Shift+T" }) }
    ],
    events: ["config:editing.mode", "config:editing.mode.itemType"],
    selected: (state, editor) => {
      return editor.config.is("editing.mode", EditingMode.APPEND) && (editor.config.is("editing.mode.itemType", "svg-rect") || editor.config.is("editing.mode.itemType", "svg-circle") || editor.config.is("editing.mode.itemType", "polygon") || editor.config.is("editing.mode.itemType", "star") || editor.config.is("editing.mode.itemType", "spline") || editor.config.is("editing.mode.itemType", "svg-textpath"));
    }
  }
];
var RightMenu = [
  {
    type: "button",
    icon: (editor) => {
      if (editor.config.is("editor.theme", "dark")) {
        return "dark";
      } else {
        return "light";
      }
    },
    action: (editor) => {
      if (editor.config.get("editor.theme") === "dark") {
        editor.config.set("editor.theme", "light");
      } else {
        editor.config.set("editor.theme", "dark");
      }
    }
  }
];
var ToolbarMenu = {
  left: () => {
    return DefaultMenu;
  },
  center: () => {
    return [];
  },
  right: () => {
    return RightMenu;
  }
};
var ToolbarMenuItem$1 = "";
class ToolbarMenuItem extends EditorElement {
  initialize() {
    super.initialize();
    const events = this.props.events || [];
    if (events.length) {
      events.forEach((event) => {
        this.on(event, () => this.refresh());
      });
    }
  }
  template() {
    return `
        <button type="button"  class='elf--toolbar-menu-item' >
            <span class="icon" ref="$icon"></span>
        </button>
        `;
  }
  [CLICK("$el")](e2) {
    if (this.props.command) {
      this.emit(this.props.command, ...this.props.args);
    } else if (this.props.action) {
      this.props.action(this.$editor);
    }
  }
  [LOAD("$icon") + DOMDIFF]() {
    return iconUse$1(this.props.icon);
  }
  [BIND("$el")]() {
    const selected = isFunction(this.props.selected) ? this.props.selected(this.$editor) : false;
    return {
      "data-selected": selected
    };
  }
}
class ToolBarRenderer extends EditorElement {
  components() {
    return {
      DropdownMenu,
      ToolbarMenuItem
    };
  }
  template() {
    return `<div class="toolbar-renderer"></div>`;
  }
  [LOAD("$el")]() {
    return this.props.items.map((item2, index2) => {
      return this.renderMenuItem(item2, index2);
    });
  }
  renderMenuItem(item2, index2) {
    switch (item2.type) {
      case "link":
        return this.renderLink(item2, index2);
      case "menu":
        return this.renderMenu(item2, index2);
      case "button":
        return this.renderButton(item2, index2);
      case "dropdown":
        return this.renderDropdown(item2, index2);
      default:
        return this.renderButton(item2, index2);
    }
  }
  renderButton(item2, index2) {
    return createComponent("ToolbarMenuItem", {
      ref: "$button-" + index2,
      title: item2.title,
      icon: item2.icon,
      command: item2.command,
      shortcut: item2.shortcut,
      args: item2.args,
      nextTick: item2.nextTick,
      disabled: item2.disabled,
      selected: item2.selected,
      selectedKey: item2.selectedKey,
      action: item2.action,
      events: item2.events
    });
  }
  renderDropdown(item2, index2) {
    return createComponent("DropdownMenu", {
      ref: "$dropdown-" + index2,
      items: item2.items,
      icon: item2.icon,
      events: item2.events,
      selected: item2.selected,
      selectedKey: item2.selectedKey,
      action: item2.action,
      style: item2.style,
      dy: 6
    }, [
      item2.content
    ]);
  }
}
class ToolBar extends EditorElement {
  initState() {
    return {
      items: [
        { title: "menu.item.fullscreen.title", command: "toggle.fullscreen", shortcut: "ALT+/" },
        { title: "menu.item.shortcuts.title", command: "showShortcutWindow" },
        "-",
        { title: "menu.item.export.title", command: "showExportView" },
        { title: "menu.item.export.title", command: "showEmbedEditorWindow" },
        { title: "menu.item.download.title", command: "downloadJSON" },
        {
          title: "menu.item.save.title",
          command: "saveJSON",
          nextTick: () => {
            this.emit("notify", "alert", "Save", "Save the content on localStorage", 2e3);
          }
        },
        {
          title: "menu.item.language.title",
          items: [
            { title: "English", command: "setLocale", args: [Language.EN], checked: () => this.$editor.locale === Language.EN },
            { title: "Fran\xE7ais", command: "setLocale", args: [Language.FR], checked: () => this.$editor.locale === Language.FR },
            { title: "Korean", command: "setLocale", args: [Language.KO], checked: () => this.$editor.locale === Language.KO }
          ]
        },
        "-",
        {
          title: "EasyLogic Studio",
          items: [
            { type: "link", title: "Github", href: "https://github.com/easylogic/editor" },
            { type: "link", title: "Learn", href: "https://www.easylogic.studio" }
          ]
        }
      ]
    };
  }
  components() {
    return {
      ToolBarRenderer,
      LayoutSelector,
      LanguageSelector,
      ThemeChanger,
      Outline,
      SelectTool,
      ExportView,
      Download,
      Save,
      Undo,
      Redo,
      DropdownMenu,
      Projects,
      AddArtboard,
      AddRect,
      AddSVGRect
    };
  }
  template() {
    return `
            <div class='elf--tool-bar'>
                ${createComponent("ToolBarRenderer", {
      items: ToolbarMenu.left(this.$editor)
    })}
                <div class='center'>
                </div>
                <div class='right'>
                    ${this.$injectManager.generate("toolbar.right")}
                    ${createComponent("ThemeChanger")}
                </div>
            </div>
        `;
  }
  [LOAD("$logo")]() {
    return `
            <div class="logo-item">           
                ${createComponent("DropdownMenu", {
      ref: "$menu",
      items: this.state.items,
      dy: 6
    }, [
      createElement("label", { class: "logo" })
    ])}
            </div>                                
        `;
  }
  [CONFIG("language.locale")]() {
    this.refresh();
  }
}
class BottomAlign extends MenuItem {
  getIconString() {
    return "align_vertical_bottom";
  }
  getTitle() {
    return "Bottom";
  }
  isHideTitle() {
    return true;
  }
  clickButton(e2) {
    this.emit("sort.bottom");
  }
}
class CenterAlign extends MenuItem {
  getIconString() {
    return "align_horizontal_center";
  }
  getTitle() {
    return "Center";
  }
  isHideTitle() {
    return true;
  }
  clickButton(e2) {
    this.emit("sort.center");
  }
}
class LeftAlign extends MenuItem {
  getIconString() {
    return "align_horizontal_left";
  }
  getTitle() {
    return "Left";
  }
  isHideTitle() {
    return true;
  }
  clickButton(e2) {
    this.emit("sort.left");
  }
}
class MiddleAlign extends MenuItem {
  getIconString() {
    return "align_vertical_center";
  }
  getTitle() {
    return "middle";
  }
  isHideTitle() {
    return true;
  }
  clickButton(e2) {
    this.emit("sort.middle");
  }
}
class RightAlign extends MenuItem {
  getIconString() {
    return "align_horizontal_right";
  }
  getTitle() {
    return "Right";
  }
  isHideTitle() {
    return true;
  }
  clickButton(e2) {
    this.emit("sort.right");
  }
}
class SameHeight extends MenuItem {
  getIconString() {
    return "vertical_distribute";
  }
  getTitle() {
    return "height";
  }
  isHideTitle() {
    return true;
  }
  clickButton(e2) {
    this.emit("same.height");
  }
}
class SameWidth extends MenuItem {
  getIconString() {
    return "horizontal_distribute";
  }
  getTitle() {
    return "width";
  }
  isHideTitle() {
    return true;
  }
  clickButton(e2) {
    this.emit("same.width");
  }
}
class TopAlign extends MenuItem {
  getIconString() {
    return "align_vertical_top";
  }
  getTitle() {
    return "Top";
  }
  isHideTitle() {
    return true;
  }
  clickButton(e2) {
    this.emit("sort.top");
  }
}
var BaseProperty$1 = "";
class BaseProperty extends EditorElement {
  onToggleShow() {
  }
  template() {
    return `
        <div class='elf--property ${this.isHideHeader() ? "no-title" : ""} ${this.getClassName()} ${this.isFirstShow() ? "show" : ""}'>
            ${this.isHideHeader() ? "" : `
            <div class='property-title ${this.getTitleClassName()}' ref="$title">
                <label class="${this.hasKeyframe() ? "has-keyframe" : ""}"> 
                  ${this.hasKeyframe() ? `
                      <span class='add-timeline-property' data-property='${this.getKeyframeProperty()}'></span>
                    ` : ""} 
                  <span ref='$propertyTitle'>${this.getTitle()}</span>
                </label>
                <span class="tools">${this.getTools()}</span>
            </div>`}
            <div class='property-body ${this.getBodyClassName()}'>${this.getBody()}</div>
            ${this.getFooter() ? `<div class='property-footer'>${this.getFooter()}</div>` : ""}
        </div>
        `;
  }
  [BIND("$el")]() {
    return {
      style: {
        "--property-order": this.order
      }
    };
  }
  setTitle(title2) {
    this.refs.$propertyTitle.html(title2);
  }
  hasKeyframe() {
    return false;
  }
  isHideHeader() {
    return false;
  }
  isFirstShow() {
    return true;
  }
  getClassName() {
    return "";
  }
  getTitleClassName() {
    return "";
  }
  getBodyClassName() {
    return "";
  }
  getKeyframeProperty() {
    return "";
  }
  getTitle() {
    return "";
  }
  getTools() {
    return "";
  }
  getBody() {
    return "";
  }
  getFooter() {
    return "";
  }
  isPropertyShow() {
    return this.$el.hasClass("show");
  }
  toggle(isShow) {
    this.$el.toggle(isShow);
  }
  hide() {
    this.$el.hide();
  }
  show() {
    this.$el.show();
  }
  onShowTitle(isShow) {
  }
  refreshShowIsNot(type = "", isRefresh = true) {
    var current = this.$selection.current;
    if (current) {
      if (type.includes(current.itemType)) {
        this.hide();
      } else {
        this.show();
        if (isRefresh)
          this.refresh();
      }
    }
  }
  refreshShow(type, isRefresh = true) {
    var current = this.$selection.current;
    if (current) {
      if (isFunction(type) && type()) {
        this.show();
        if (isRefresh)
          this.refresh();
      } else {
        if (!isFunction(type) && type.includes(current.itemType)) {
          this.show();
          if (isRefresh)
            this.refresh();
        } else {
          this.hide();
        }
      }
    } else {
      this.hide();
    }
  }
  startInputEditing(input2) {
    if (!input2)
      return;
    input2.attr("contenteditable", true);
    input2.css({
      "background-color": "white",
      "outline": "1px auto black",
      "color": "black"
    });
    input2.focus();
  }
  endInputEditing(input2, callback) {
    if (!input2)
      return;
    input2.attr("contenteditable", false);
    input2.css({
      "background-color": null,
      "outline": null,
      "color": null
    });
    var index2 = input2.attr("data-index");
    callback && callback(index2, input2.text().trim());
    input2.blur();
  }
  get editableProperty() {
    return "";
  }
  get order() {
    return 1e3;
  }
  checkShow() {
    if (!this.$selection.current) {
      this.hide();
      return false;
    }
    if (this.$selection.current.editable(this.editableProperty)) {
      this.show();
      return true;
    } else {
      this.hide();
      return false;
    }
  }
}
var AlignmentProperty$1 = "";
class AlignmentProperty extends BaseProperty {
  components() {
    return {
      LeftAlign,
      CenterAlign,
      RightAlign,
      TopAlign,
      MiddleAlign,
      BottomAlign,
      SameWidth,
      SameHeight
    };
  }
  getTitle() {
    return this.$i18n("alignment.property.title");
  }
  isHideHeader() {
    return true;
  }
  getBody() {
    return `
      <div class="elf--alignment-item">
        ${createComponentList("LeftAlign", "CenterAlign", "RightAlign", "TopAlign", "MiddleAlign", "BottomAlign", ["SameWidth", { direction: "bottom" }], "SameHeight")}
      </div>
    `;
  }
}
function alignment(editor) {
  editor.registerMenuItem("inspector.tab.style", {
    AlignmentProperty
  });
}
function getCustomParseIndexString(it, prefix = "@") {
  return `${prefix}${it.startIndex}`.padEnd(10, "0");
}
function customParseMatches(str, regexp) {
  const matches2 = str.match(regexp);
  let result = [];
  if (!matches2) {
    return result;
  }
  for (var i = 0, len2 = matches2.length; i < len2; i++) {
    result.push({ parsedString: matches2[i] });
  }
  var pos = { next: 0 };
  result.forEach((item2) => {
    const startIndex = str.indexOf(item2.parsedString, pos.next);
    item2.startIndex = startIndex;
    item2.endIndex = startIndex + item2.parsedString.length;
    pos.next = item2.endIndex;
  });
  return result;
}
function customParseConvertMatches(str, regexp) {
  const m = customParseMatches(str, regexp);
  m.forEach((it) => {
    str = str.replace(it.parsedString, getCustomParseIndexString(it));
  });
  return { str, matches: m };
}
function customParseReverseMatches(str, matches2) {
  matches2.forEach((it) => {
    str = str.replace(getCustomParseIndexString(it), it.parsedString);
  });
  return str;
}
const ANIMATION_TIMING_REG = /((cubic-bezier|steps)\(([^\)]*)\))/gi;
class Animation extends PropertyItem {
  static parse(obj2) {
    return new Animation(obj2);
  }
  getDefaultObject() {
    return {
      itemType: "animation",
      checked: true,
      name: "none",
      direction: "normal",
      duration: Length.second(0),
      timingFunction: "linear",
      delay: Length.second(0),
      iterationCount: Length.string("infinite"),
      playState: "running",
      fillMode: "none"
    };
  }
  convert(json) {
    json = super.convert(json);
    json.duration = Length.parse(json.duration);
    json.iterationCount = Length.parse(json.iterationCount);
    return json;
  }
  toCloneObject() {
    return __spreadValues({}, this.attrs("name", "direction", "duration", "timingFunction", "delay", "iterationCount", "playState", "fillMode"));
  }
  togglePlayState(forcedValue) {
    if (forcedValue) {
      this.reset({ playState: forcedValue === "running" ? "running" : "paused" });
    } else {
      if (this.json.playState === "paused") {
        this.reset({ playState: "running" });
      } else {
        this.reset({ playState: "paused" });
      }
    }
  }
  toCSS() {
    if (!this.json.name)
      return {};
    return {
      "animation": this.toString()
    };
  }
  toString() {
    var json = this.json;
    return [
      json.duration,
      json.timingFunction,
      json.delay,
      json.iterationCount,
      json.direction,
      json.fillMode,
      json.playState,
      json.name
    ].join(" ");
  }
  static join(list2) {
    return list2.map((it) => new Animation(it).toString()).join(",");
  }
  static add(animation2, item2 = {}) {
    const list2 = Animation.parseStyle(animation2);
    list2.push(Animation.parse(item2));
    return Animation.join(list2);
  }
  static remove(animation2, removeIndex) {
    return Animation.filter(animation2, (it, index2) => {
      return removeIndex != index2;
    });
  }
  static filter(animation2, filterFunction) {
    return Animation.join(Animation.parseStyle(animation2).filter((it) => filterFunction(it)));
  }
  static replace(animation2, replaceIndex, valueObject) {
    var list2 = Animation.parseStyle(animation2);
    if (list2[replaceIndex]) {
      list2[replaceIndex] = valueObject;
    } else {
      list2.push(valueObject);
    }
    return Animation.join(list2);
  }
  static get(animation2, index2) {
    var arr = Animation.parseStyle(animation2);
    return arr[index2];
  }
  static parseStyle(animation2) {
    var list2 = [];
    if (!animation2)
      return list2;
    const result = customParseConvertMatches(animation2, ANIMATION_TIMING_REG);
    list2 = result.str.split(",").map((it) => {
      const fields2 = it.split(" ").filter(Boolean);
      if (fields2.length >= 7) {
        return {
          duration: Length.parse(fields2[0]),
          timingFunction: customParseReverseMatches(fields2[1], result.matches),
          delay: Length.parse(fields2[2]),
          iterationCount: fields2[3] === "infinite" ? Length.string("infinite") : Length.parse(fields2[3]),
          direction: fields2[4],
          fillMode: fields2[5],
          playState: fields2[6],
          name: fields2[7]
        };
      } else if (fields2.length >= 3) {
        return {
          duration: Length.parse(fields2[0]),
          timingFunction: customParseReverseMatches(fields2[1], result.matches),
          delay: Length.parse(fields2[2]),
          name: fields2[3]
        };
      } else if (fields2.length >= 1) {
        return {
          duration: Length.parse(fields2[0]),
          name: fields2[1]
        };
      } else {
        return {};
      }
    });
    return list2.map((it) => Animation.parse(it));
  }
}
var AnimationProperty$1 = "";
class AnimationProperty extends BaseProperty {
  getTitle() {
    return this.$i18n("animation.property.title");
  }
  getBody() {
    return `<div class='animation-list' ref='$animationList'></div>`;
  }
  getTools() {
    return `
        <button type="button" ref="$add" title="add Fill">${iconUse$1("add")}</button>
    `;
  }
  isFirstShow() {
    return true;
  }
  [LOAD("$animationList") + DOMDIFF]() {
    var current = this.$selection.current;
    if (!current)
      return "";
    return Animation.parseStyle(current.animation).map((it, index2) => {
      const selectedClass = this.state.selectedIndex === index2 ? "selected" : "";
      const path = curveToPath(it.timingFunction, 30, 30);
      return `
      <div class='animation-group-item'>
        <div class='animation-item ${selectedClass}' 
             data-index='${index2}' 
             ref="animationIndex${index2}" 
          >
            <div class='timing preview' data-index='${index2}' ref='$preview${index2}'>
              <svg class='item-canvas' width="30" height="30" viewBox="0 0 30 30">
                <path d="${path}" stroke="white" stroke-width="1" fill='none' />
              </svg>
            </div>
            <div class='name'>
              <div class='title' ref="animationName${index2}">
                ${it.name ? it.name : `&lt; ${this.$i18n("animation.property.select a keyframe")} &gt;`}
              </div>
              <div class='labels'>
                <label class='count' title='${this.$i18n("animation.property.iteration.count")}'><small>${it.iterationCount}</small></label>
                <label class='delay' title='${this.$i18n("animation.property.delay")}'><small>${it.delay}</small></label>
                <label class='duration' title='${this.$i18n("animation.property.duration")}'><small>${it.duration}</small></label>
                <label class='direction' title='${this.$i18n("animation.property.direction")}'><small>${it.direction}</small></label>
                <label class='fill-mode' title='${this.$i18n("animation.property.fill.mode")}'><small>${it.fillMode}</small></label>
                <label class='play-state' title='${this.$i18n("animation.property.play.state")}' data-index='${index2}' data-play-state-selected-value="${it.playState}">
                  <small data-play-state-value='running'>${iconUse$1("play")}</small>
                  <small data-play-state-value='paused'>${iconUse$1("pause")}</small>
                </label>
              </div>
            </div>
            <div class='tools'>
                <button type="button" class="del" data-index="${index2}">
                  ${iconUse$1("remove2")}
                </button>
            </div>
        </div>
      </div>        
      `;
    });
  }
  [SUBSCRIBE("refreshSelection") + DEBOUNCE(100)]() {
    const current = this.$selection.current;
    if (current && current.hasChangedField("animation")) {
      this.refresh();
    }
    this.emit("hideAnimationPropertyPopup");
  }
  [CLICK("$add")](e2) {
    var current = this.$selection.current;
    if (current) {
      this.command("setAttributeForMulti", "add animation property", this.$selection.packByValue({
        animation: (item2) => Animation.add(item2.animation, { name: null })
      }));
      this.nextTick(() => {
        setTimeout(() => {
          this.refresh();
        }, 100);
      });
    } else {
      alert("Select a layer");
    }
  }
  [CLICK("$animationList .tools .del")](e2) {
    var removeIndex = e2.$dt.attr("data-index");
    var current = this.$selection.current;
    if (!current)
      return;
    current.reset({
      animation: Animation.remove(current.animation, removeIndex)
    });
    this.emit("refreshElement", current);
    this.refresh();
  }
  [CLICK("$animationList .play-state")](e2) {
    var index2 = +e2.$dt.attr("data-index");
    var current = this.$selection.current;
    if (!current)
      return;
    const list2 = Animation.parseStyle(current.animation);
    var animation2 = list2[index2];
    if (animation2) {
      animation2.togglePlayState();
      e2.$dt.attr("data-play-state-selected-value", animation2.playState);
      current.reset({
        animation: Animation.join(list2)
      });
      this.emit("refreshElement", current);
    }
  }
  selectItem(selectedIndex, isSelected = true) {
    if (isSelected) {
      this.refs[`animationIndex${selectedIndex}`].addClass("selected");
    } else {
      this.refs[`animationIndex${selectedIndex}`].removeClass("selected");
    }
  }
  viewAnimationPicker($preview) {
    if (typeof this.selectedIndex === "number") {
      this.selectItem(this.selectedIndex, false);
    }
    this.selectedIndex = +$preview.attr("data-index");
    this.current = this.$selection.current;
    if (!this.current)
      return;
    this.currentAnimation = Animation.get(this.current.animation, this.selectedIndex);
    this.viewAnimationPropertyPopup();
  }
  viewAnimationPropertyPopup() {
    if (!this.currentAnimation)
      return;
    const animation2 = this.currentAnimation;
    this.emit("showAnimationPropertyPopup", {
      changeEvent: "changeAnimationPropertyPopup",
      data: animation2.toCloneObject(),
      instance: this
    });
  }
  [CLICK("$animationList .preview")](e2) {
    this.viewAnimationPicker(e2.$dt);
  }
  getRef(...args2) {
    return this.refs[args2.join("")];
  }
  [SUBSCRIBE("changeAnimationPropertyPopup")](data) {
    if (this.currentAnimation) {
      this.currentAnimation.reset(__spreadValues({}, data));
      if (this.current) {
        this.command("setAttributeForMulti", "change animation property", this.$selection.packByValue({
          animation: (item2) => Animation.replace(item2.animation, this.selectedIndex, this.currentAnimation)
        }));
        this.refresh();
      }
    }
  }
}
var BasePopup$1 = "";
class BasePopup extends EditorElement {
  template() {
    return `
        <div class='elf--popup ${this.getClassName()}'>
            <div class='popup-title' ref="$title">
                <label>${this.getTitle()}</label>
                <span class="tools">
                  ${this.getTools()}
                  <button type='button' class='close' ref='$close'>${iconUse$1("close")}</button>
                </span>
            </div>
            <div class='popup-body'>${this.getBody()}</div>
            <!--<div class='popup-resizer' ref='$resizer'></div> -->
        </div>
        `;
  }
  getClassName() {
    return "";
  }
  getTitle() {
    return "";
  }
  getTools() {
    return "";
  }
  getBody() {
    return "";
  }
  [CLICK("$close")]() {
    this.$el.hide();
  }
  setTitle(title2) {
    this.refs.$title.$("label").text(title2);
  }
  [POINTERSTART("$title") + MOVE("movePopupTitle") + END("endPopupTitle")]() {
    this.x = Length.parse(this.$el.css("left"));
    this.y = Length.parse(this.$el.css("top"));
  }
  movePopupTitle(dx, dy) {
    var left2 = Length.px(this.x.value + dx);
    var top2 = Length.px(this.y.value + dy);
    this.$el.css({ left: left2, top: top2, right: "auto", bottom: "auto" });
  }
  show(width2 = 200) {
    var popupPadding = 28;
    var rightPosition = 320;
    var top2 = this.$el.css("top");
    var left2 = this.$el.css("left");
    var realTop = top2 !== "auto" ? Length.parse(top2) : 110;
    var realLeft = left2 !== "auto" ? Length.parse(left2) : document.body.clientWidth - rightPosition - popupPadding - width2;
    this.$el.css({
      top: Length.px(realTop),
      left: Length.px(realLeft),
      "z-index": this.$editor.zIndex
    }).show("inline-block");
  }
  makeRect(width2, height2, rect2) {
    const elements = this.$config.get("editor.layout.elements");
    const bodyRect = elements.$bodyPanel.rect();
    const left2 = bodyRect.left + bodyRect.width - (width2 - 10);
    const top2 = rect2.top + height2 > bodyRect.top + bodyRect.height ? bodyRect.top + bodyRect.height - height2 - 10 : rect2.top;
    return {
      top: top2,
      left: left2 < rect2.left && rect2.left <= left2 + width2 ? left2 - (left2 + width2 - rect2.left) - 10 : left2,
      width: width2,
      height: height2
    };
  }
  showByRect(rect2) {
    this.$el.css({
      top: Length.px(rect2.top),
      left: Length.px(rect2.left),
      width: Length.px(rect2.width),
      height: Length.px(rect2.height),
      "z-index": this.$editor.zIndex
    }).show("inline-block");
  }
  hide() {
    this.$el.hide();
  }
  [SUBSCRIBE("hidePropertyPopup")]() {
    this.hide();
  }
  [POINTERSTART("$resizer") + MOVE("moveResizer")](e2) {
    this.width = Length.parse(this.$el.css("width"));
    this.height = Length.parse(this.$el.css("height"));
  }
  moveResizer(dx, dy) {
    this.$el.css({
      width: Math.min(this.width + dx, 1e3),
      height: Math.min(this.height + dy, 700)
    });
  }
}
var AnimationPropertyPopup$1 = "";
class AnimationPropertyPopup extends BasePopup {
  getTitle() {
    return this.$i18n("animation.property.popup.title");
  }
  initState() {
    return {
      changeEvent: "",
      instance: {},
      data: {}
    };
  }
  updateData(opt) {
    this.state.data = __spreadValues(__spreadValues({}, this.state.data), opt);
    if (this.state.instance) {
      this.state.instance.trigger(this.state.changeEvent, this.state.data);
    }
  }
  getBody() {
    return `<div class='elf--animation-property-popup' ref='$popup'></div>`;
  }
  [LOAD("$popup")]() {
    return `
      <div class="box">
        ${this.templateForKeyframe()}
        ${this.templateForTimingFunction()}
        ${this.templateForIterationCount()}
        ${this.templateForDelay()}
        ${this.templateForDuration()}
        ${this.templateForDirection()}
        ${this.templateForFillMode()}
        ${this.templateForPlayState()}
      </div>
    `;
  }
  templateForTimingFunction() {
    return `
    <div class='timing-function'>
      <label>${this.$i18n("animation.property.popup.timing.function")}</label>
      ${createComponent("CubicBezierEditor", {
      ref: "$cubicBezierEditor",
      key: "timingFunction",
      value: this.state.data.timingFunction || "linear",
      onChange: "changeCubicBezier"
    })}
    </div>
    `;
  }
  templateForKeyframe() {
    return `
      <div class='name'>
        <label>${this.$i18n("animation.property.popup.keyframe")}</label>
        <div class='input grid-1'>
          <select ref='$name'></select>
        </div>
      </div>
    `;
  }
  [LOAD("$name")]() {
    var current = this.$selection.currentProject;
    var names2 = [];
    if (current && current.keyframes) {
      names2 = current.keyframes.map((it) => {
        return { key: it.name, value: it.name };
      });
    }
    names2.unshift({ key: "Select a keyframe", value: "" });
    return names2.map((it) => {
      var selected = it.value === this.name ? "selected" : "";
      var label = this.$i18n(it.key);
      return `<option value='${it.value}' ${selected}>${label}</option>`;
    });
  }
  [CHANGE("$name")]() {
    this.updateData({ name: this.refs.$name.value });
  }
  templateForDirection() {
    var options2 = "normal,reverse,alternate,alternate-reverse".split(",").map((it) => {
      return `${it}:${this.$i18n(it)}`;
    }).join(",");
    return `
      <div class='direction'>
        ${createComponent("SelectEditor", {
      label: this.$i18n("animation.property.popup.direction"),
      ref: "$direction",
      key: "direction",
      value: this.state.data.direction,
      options: options2,
      onChange: "changeSelect"
    })}
      </div>
    `;
  }
  [SUBSCRIBE_SELF("changeSelect")](key, value) {
    this.updateData({ [key]: value });
  }
  templateForPlayState() {
    return `
    <div class='play-state'>
      ${createComponent("SelectEditor", {
      label: this.$i18n("animation.property.popup.play.state"),
      ref: "$playState",
      key: "playState",
      value: this.state.data.playState,
      options: ["paused", "running"],
      onChange: "changeSelect"
    })}
    </div>
  `;
  }
  templateForFillMode() {
    var options2 = "none,forwards,backwards,both".split(",").map((it) => {
      return `${it}:${this.$i18n(it)}`;
    }).join(",");
    return `
    <div class='fill-mode'>
      ${createComponent("SelectEditor", {
      label: this.$i18n("animation.property.popup.fill.mode"),
      ref: "$fillMode",
      key: "fillMode",
      value: this.state.data.fillMode,
      options: options2,
      onChange: "changeSelect"
    })}
    </div>
  `;
  }
  templateForDelay() {
    return `
    <div class='delay'>
      ${createComponent("RangeEditor", {
      ref: "$delay",
      label: this.$i18n("animation.property.popup.delay"),
      key: "delay",
      value: this.state.data.delay,
      units: ["s", "ms"],
      onChange: "changeRangeEditor"
    })} 
    </div>
    `;
  }
  templateForDuration() {
    return `
    <div class='duration'>
      ${createComponent("RangeEditor", {
      ref: "$duration",
      label: this.$i18n("animation.property.popup.duration"),
      key: "duration",
      value: this.state.data.duration,
      units: ["s", "ms"],
      onChange: "changeRangeEditor"
    })} 
    </div>
    `;
  }
  templateForIterationCount() {
    return `
      <div class='iteration-count'>
        ${createComponent("IterationCountEditor", {
      ref: "$iterationCount",
      label: this.$i18n("animation.property.popup.iteration"),
      key: "iterationCount",
      value: this.state.iterationCount || 0,
      units: ["normal", "infinite"],
      onChange: "changeRangeEditor"
    })}
      </div>
    `;
  }
  [SUBSCRIBE_SELF("changeRangeEditor")](key, value) {
    if (key === "iterationCount") {
      if (value.unit === "normal") {
        value = Length.number(value.value);
      } else {
        value = Length.string(value.unit);
      }
    }
    this.updateData({ [key]: value });
  }
  [SUBSCRIBE_SELF("changeCubicBezier")](key, value) {
    this.updateData({ [key]: value });
  }
  [SUBSCRIBE("showAnimationPropertyPopup")](data) {
    this.setState(data);
    this.show(250);
    this.children.$cubicBezierEditor.trigger("showCubicBezierEditor", data.data.timingFunction);
  }
  [SUBSCRIBE("hideAnimationPropertyPopup")]() {
    this.$el.hide();
  }
}
function animation(editor) {
  editor.registerMenuItem("inspector.tab.transition", {
    AnimationProperty
  });
  editor.registerMenuItem("popup", {
    AnimationPropertyPopup
  });
}
class ObjectProperty {
  static create(json) {
    return class extends BaseProperty {
      getTitle() {
        return json.title;
      }
      getClassName() {
        return json.className || "item";
      }
      get editableProperty() {
        return json.editableProperty;
      }
      get order() {
        return isUndefined(json.order) ? 1e3 : json.order;
      }
      refresh() {
        const current = this.$selection.current;
        if (current) {
          this.setTitle(json.title || current.getDefaultTitle() || current.itemType || current.name);
          this.load();
          const inspector = isFunction(json.inspector) ? json.inspector(current) : this.$editor.components.createInspector(current, json.editableProperty);
          this.children.$comp.setInspector(inspector);
        }
      }
      [SUBSCRIBE("refreshSelection") + IF("checkShow")]() {
        if (json.preventUpdate) {
          if (this.$editor.isPointerUp) {
            this.refresh();
          }
        } else {
          this.refresh();
        }
      }
      [LOAD("$body")]() {
        var current = this.$selection.current;
        if (!current)
          return "";
        const inspector = isFunction(json.inspector) ? json.inspector(current) : this.$editor.components.createInspector(current, json.editableProperty);
        return createComponent("ComponentEditor", {
          ref: "$comp",
          inspector,
          onchange: "changeComponentProperty"
        });
      }
      getBody() {
        var current = this.$selection.current || {};
        const inspector = isFunction(json.inspector) ? json.inspector(current) : this.$editor.components.createInspector(current, json.editableProperty);
        return createComponent("ComponentEditor", {
          ref: "$comp",
          inspector,
          onchange: "changeComponentProperty"
        });
      }
      [SUBSCRIBE_SELF("changeComponentProperty")](key, value) {
        if (json.action) {
          this.command(json.action, `change attribute : ${key}`, key, value);
        } else {
          this.command("setAttributeForMulti", `change attribute : ${key}`, this.$selection.packByValue({
            [key]: value
          }));
        }
      }
    };
  }
}
function appearance(editor) {
  editor.registerMenuItem("inspector.tab.style", {
    AppearanceProperty: ObjectProperty.create({
      title: editor.$i18n("background.color.property.title"),
      editableProperty: "appearance",
      preventUpdate: true,
      inspector: (current) => {
        return [
          {
            type: "column",
            size: [1, 1],
            columns: [
              {
                key: "background-color",
                editor: "color-view",
                editorOptions: {
                  compact: true,
                  format: true
                },
                defaultValue: current["background-color"]
              },
              {
                key: "mix-blend-mode",
                editor: "blend-select",
                editorOptions: {
                  label: "tonality",
                  compact: true
                },
                defaultValue: current["mix-blend-mode"]
              }
            ]
          },
          {
            key: "overflow",
            editor: "select",
            editorOptions: {
              label: editor.$i18n("background.color.property.overflow"),
              options: [Overflow.VISIBLE, Overflow.HIDDEN, Overflow.SCROLL, Overflow.AUTO].map((it) => {
                return { value: it, text: editor.$i18n(`background.color.property.overflow.${it}`) };
              })
            },
            defaultValue: current["overflow"]
          }
        ];
      }
    })
  });
}
var artboardSize = [
  {
    category: "Web",
    groups: [
      { group: "Landscape", devices: [
        { device: "Web Small", size: "1024x600" },
        { device: "Web Medium", size: "1280x800" },
        { device: "Web Large", size: "1440x900" },
        { device: "Web X Large", size: "1920x1200" }
      ] },
      {
        group: "Portrait",
        devices: [
          { device: "Web Small", size: "600x1024" },
          { device: "Web Medium", size: "800x1280" },
          { device: "Web Large", size: "900x1440" },
          { device: "Web X Large", size: "1200x1920" }
        ]
      }
    ]
  },
  {
    category: "Apple Devices",
    groups: [
      { group: "iphone", devices: [
        { device: "iPhone 8", size: "375x667" },
        { device: "iPhone 8 Plus", size: "414x736" },
        { device: "iPhone SE", size: "320x568" },
        { device: "iPhone XS", size: "375x812" },
        { device: "iPhone XR", size: "414x896" },
        { device: "iPhone XS Max", size: "414x896" }
      ] },
      { group: "ipad", devices: [
        { device: "iPad", size: "768x1024" },
        { device: "iPad Pro", size: "1024x1366" }
      ] },
      { group: "apple watch", devices: [
        { device: "Apple Watch 38nm", size: "272x340" },
        { device: "Apple Watch 40nm", size: "326x394" },
        { device: "Apple Watch 42nm", size: "313x390" },
        { device: "Apple Watch 44nm", size: "368x448" }
      ] },
      { group: "apple tv", devices: [
        { device: "Apple TV", size: "1920x1080" }
      ] },
      { group: "MAC", devices: [
        { device: "Touch Bar", size: "1085x30" }
      ] }
    ]
  },
  {
    category: "Android Devices",
    groups: [
      { group: "android mobile", devices: [
        { device: "Android Mobile", size: "360x640" }
      ] },
      { group: "android tablet", devices: [
        { device: "Android Tablet", size: "768x1024" }
      ] }
    ]
  }
];
var ArtBoardSizeProperty$1 = "";
class ArtBoardSizeProperty extends BaseProperty {
  getClassName() {
    return "elf--artboard-size-list";
  }
  get editableProperty() {
    return "artboard-size";
  }
  [SUBSCRIBE("refreshSelection") + IF("checkShow")]() {
    this.refresh();
  }
  initState() {
    return {
      selectedIndex: 0
    };
  }
  getTitle() {
    return "ArtBoard Preset";
  }
  getTools() {
    var categories2 = artboardSize.map((it, index2) => {
      return { category: it.category, index: index2 };
    });
    return createComponent("SelectEditor", {
      ref: "$select",
      value: categories2[0].category,
      options: categories2.map((it) => it.category),
      onchange: "changeSizeIndex"
    });
  }
  [SUBSCRIBE_SELF("changeSizeIndex")](key, value) {
    var selectedIndex = this.state.selectedIndex;
    artboardSize.forEach((it, index2) => {
      if (it.category === value) {
        selectedIndex = index2;
      }
    });
    this.state.selectedIndex = selectedIndex;
    this.refresh();
  }
  getBody() {
    return `
      <div class='artboard-size-item' ref='$list'></div>
    `;
  }
  makeDevice(device) {
    return `
      <div class='device-item' data-size='${device.size}'>
        <div class='title'>${device.device}</div>
        <div class='size'>${device.size}</div>
      </div>
    `;
  }
  [CLICK("$list .device-item")](e2) {
    var size2 = e2.$dt.attr("data-size");
    this.emit("resizeArtBoard", size2);
  }
  makeGroup(group2) {
    return `
      <div class='group-item'>
        <div class='title'>${group2.group}</div>
      </div>
      <div class='devices'>
        ${group2.devices.map((device) => this.makeDevice(device)).join("")}
      </div>
    `;
  }
  makeCategory(category) {
    return `
      <div class='category'>
        <div class='title'>${category.category}</div>
      </div>
      <div class='groups'>
        ${category.groups.map((group2) => this.makeGroup(group2)).join("")}
      </div>
    `;
  }
  [LOAD("$list") + DOMDIFF]() {
    var category = artboardSize[this.state.selectedIndex];
    return category.groups.map((group2) => this.makeGroup(group2));
  }
}
function artboard(editor) {
  editor.registerMenuItem("inspector.tab.style", {
    ArtBoardSizeProperty
  });
}
const filter_list$1 = [
  "blur",
  "grayscale",
  "hue-rotate",
  "invert",
  "brightness",
  "contrast",
  "drop-shadow",
  "opacity",
  "saturate",
  "sepia",
  "svg"
];
var BackdropFilterProperty$1 = "";
class BackdropFilterProperty extends BaseProperty {
  getTitle() {
    return this.$i18n("backdrop.filter.property.title");
  }
  hasKeyframe() {
    return true;
  }
  getTitleClassName() {
    return "filter";
  }
  getKeyframeProperty() {
    return "backdrop-filter";
  }
  getBodyClassName() {
    return "no-padding";
  }
  getBody() {
    return `<div class='full filter-property' ref='$body'></div>`;
  }
  getTools() {
    return `
      <select class="filter-select" ref="$filterSelect"></select>
      <button type="button" ref="$add" title="add Filter">${iconUse$1("add")}</button>
    `;
  }
  [CLICK("$add")]() {
    var filterType = this.refs.$filterSelect.value;
    this.children.$filterEditor.trigger("add", filterType);
  }
  [LOAD("$filterSelect")]() {
    var list2 = filter_list$1.map((it) => {
      return { title: this.$i18n(`filter.property.${it}`), value: it };
    });
    var svgFilterList = this.getSVGFilterList();
    var totalList = [];
    if (svgFilterList.length) {
      totalList = [
        ...list2,
        { title: "-------", value: "" },
        ...svgFilterList
      ];
    } else {
      totalList = [
        ...list2
      ];
    }
    return totalList.map((it) => {
      var { title: title2, value } = it;
      return `<option value='${value}'>${title2}</option>`;
    });
  }
  getSVGFilterList() {
    var current = this.$selection.currentProject;
    var arr = [];
    if (current) {
      arr = current.svgfilters.map((it) => {
        return {
          title: `svg - #${it.id}`,
          value: it.id
        };
      });
    }
    return arr;
  }
  [LOAD("$body")]() {
    var current = this.$selection.current || {};
    var value = current["backdrop-filter"];
    return `
      <div>
        ${createComponent("FilterEditor", {
      ref: "$filterEditor",
      key: "backdrop-filter",
      value,
      hideLabel: true,
      onchange: "changeFilterEditor"
    })}
      </div>
    `;
  }
  [SUBSCRIBE_SELF("changeFilterEditor")](key, filter2) {
    this.command("setAttributeForMulti", "change backdrop filter", this.$selection.packByValue({
      [key]: filter2
    }));
  }
  get editableProperty() {
    return "backdrop-filter";
  }
  [SUBSCRIBE("refreshSelection") + IF("checkShow") + DEBOUNCE(1e3)]() {
    this.refresh();
  }
}
function backdropFilter(editor) {
  editor.registerMenuItem("inspector.tab.style", {
    BackdropFilterProperty
  });
}
class BackgroundClipProperty extends BaseProperty {
  getTitle() {
    return "Background Clip";
  }
  isFirstShow() {
    return false;
  }
  getTools() {
    return `<div ref='$backgroundClip' style='padding-top: 3px;'></div>`;
  }
  [LOAD("$backgroundClip")]() {
    var current = this.$selection.current || {};
    var clip = current["background-clip"] || "";
    return createComponent("SelectEditor", {
      ref: "$1",
      key: "background-clip",
      icon: true,
      value: clip,
      options: ["", "paddinb-box", "border-box", "content-box", "text"],
      onchange: "changeSelect"
    });
  }
  [SUBSCRIBE_SELF("changeSelect")](key, value) {
    this.command("setAttributeForMulti", "change background clip", this.$selection.packByValue({
      [key]: value
    }));
  }
  [SUBSCRIBE("refreshSelection") + DEBOUNCE(100)]() {
    this.refreshShow(["rect", "circle", "text"]);
  }
}
function backgroundClip(editor) {
  editor.registerElement({
    BackgroundClipProperty
  });
}
var BackgroundImageEditor$1 = "";
const names$1 = {
  "image-resource": "Image",
  "url": "Image",
  image: "Image",
  "static-gradient": "Static",
  "linear-gradient": "Linear",
  "repeating-linear-gradient": `Linear`,
  "radial-gradient": "Radial",
  "repeating-radial-gradient": `Radial`,
  "conic-gradient": "Conic",
  "repeating-conic-gradient": `Conic`
};
const types = {
  image: "image",
  "image-resource": "image",
  "url": "image",
  "static-gradient": "gradient",
  "linear-gradient": "gradient",
  "repeating-linear-gradient": "gradient",
  "radial-gradient": "gradient",
  "repeating-radial-gradient": "gradient",
  "conic-gradient": "gradient",
  "repeating-conic-gradient": "gradient"
};
class BackgroundImageEditor extends EditorElement {
  initState() {
    return {
      hideLabel: this.props.hideLabel || false,
      value: this.props.value,
      images: this.parseBackgroundImage(this.props.value)
    };
  }
  parseBackgroundImage(str) {
    if (str === "")
      return [];
    return BackgroundImage.parseStyle(STRING_TO_CSS(str));
  }
  setValue(value) {
    this.setState({
      value,
      images: this.parseBackgroundImage(value)
    });
  }
  template() {
    return `
            <div class='elf--background-image-editor' >
                <div class='fill-list' ref='$fillList'></div>
            </div>
        `;
  }
  [LOAD("$fillList") + DOMDIFF]() {
    const current = this.$selection.current || { color: "black" };
    return this.state.images.map((it, index2) => {
      var image2 = it.image;
      var backgroundType = types[image2.type];
      var backgroundTypeName = names$1[image2.type];
      const selectedClass = it.selected ? "selected" : "";
      if (it.selected) {
        this.selectedIndex = index2;
      }
      return `
            <div class='fill-item ${selectedClass}' data-index='${index2}' ref="fillIndex${index2}"  draggable='true' data-fill-type="${backgroundType}" >
                <label draggable="true" data-index="${index2}">${iconUse$1("drag_indicator")}</label>
                ${createComponentList(["BackgroundPositionEditor", {
        key: "background-position",
        index: index2,
        ref: `$bp${index2}`,
        x: it.x,
        y: it.y,
        width: it.width,
        height: it.height,
        repeat: it.repeat,
        size: it.size,
        blendMode: it.blendMode,
        onchange: "changePattern"
      }], ["GradientSingleEditor", {
        index: index2,
        ref: `$gse${index2}`,
        image: it.image,
        color: current.color,
        key: "background-image",
        onchange: "changePattern"
      }])}
                <div class='fill-info'>
                  <div class='gradient-info'>
                    <div class='fill-title' ref="fillTitle${index2}" data-repeat="${image2.type.includes("repeating")}">${backgroundTypeName}</div>
                    <div class='blend'>
                        ${createComponent("BlendSelectEditor", {
        ref: `$blend_${index2}`,
        key: "blendMode",
        label: "tonality",
        value: it.blendMode,
        params: index2,
        compact: true,
        onchange: "changeRangeEditor"
      })}
                    </div>
                    <div class='tools'>
                      <button type="button" class='remove' data-index='${index2}'>${obj.remove2}</button>
                    </div>
                  </div>
                </div>
            </div>
            `;
    });
  }
  modifyBackgroundImage() {
    var value = CSS_TO_STRING$1(BackgroundImage.toPropertyCSS(this.state.images));
    this.parent.trigger(this.props.onchange, this.props.key, value);
  }
  makeGradient(type) {
    switch (type) {
      case "linear-gradient":
        return `linear-gradient(90deg, white 0%, black 100%)`;
      case "repeating-linear-gradient":
        return `repeating-linear-gradient(90deg, white 2px, black 4px)`;
      case "radial-gradient":
        return `radial-gradient(circle, white 0%, black 100%)`;
      case "repeating-radial-gradient":
        return `repeating-radial-gradient(circle, white 2px, black 4px)`;
      case "conic-gradient":
        return `conic-gradient(white 0%, black 100%)`;
      case "repeating-conic-gradient":
        return `repeating-conic-gradient(white 50%, black 100%)`;
    }
  }
  [SUBSCRIBE("add")](gradientType) {
    this.state.images.push(new BackgroundImage({
      image: BackgroundImage.parseImage(this.makeGradient(gradientType))
    }));
    this.refresh();
    this.modifyBackgroundImage();
  }
  [CLICK("$add")]() {
    this.trigger("add");
  }
  [DRAGSTART("$fillList .fill-item > label")](e2) {
    this.startIndex = +e2.$dt.attr("data-index");
  }
  [DRAGOVER("$fillList .fill-item") + PREVENT](e2) {
  }
  sortItem(arr, startIndex, targetIndex) {
    arr.splice(targetIndex + (startIndex < targetIndex ? -1 : 0), 0, ...arr.splice(startIndex, 1));
  }
  sortBackgroundImage(startIndex, targetIndex) {
    this.sortItem(this.state.images, startIndex, targetIndex);
  }
  [DROP("$fillList .fill-item") + PREVENT](e2) {
    var targetIndex = +e2.$dt.attr("data-index");
    this.selectItem(this.startIndex, true);
    this.sortBackgroundImage(this.startIndex, targetIndex);
    this.refresh();
    this.modifyBackgroundImage();
  }
  getCurrentBackgroundImage() {
    return this.state.images[this.selectedIndex];
  }
  [CLICK("$fillList .tools .remove")](e2) {
    var removeIndex = +e2.$dt.attr("data-index");
    this.state.images.splice(removeIndex, 1);
    this.refresh();
    this.modifyBackgroundImage();
  }
  selectItem(selectedIndex, isSelected = true) {
    if (isSelected) {
      this.refs[`fillIndex${selectedIndex}`].addClass("selected");
    } else {
      this.refs[`fillIndex${selectedIndex}`].removeClass("selected");
    }
    this.state.images.forEach((it, index2) => {
      it.selected = index2 === selectedIndex;
    });
  }
  [SUBSCRIBE("selectFillPopupTab")](type, data) {
    var typeName = types[type];
    var $fillItem = this.refs[`fillIndex${this.selectedIndex}`];
    $fillItem.attr("data-fill-type", typeName);
  }
  [SUBSCRIBE_SELF("changeRangeEditor")](key, value, params) {
    this.trigger("changePattern", key, { [key]: value }, params);
  }
  [SUBSCRIBE_SELF("changePattern")](key, value, params) {
    var index2 = +params;
    var image2 = this.state.images[index2];
    image2.reset(value);
    this.modifyBackgroundImage();
    this.refresh();
  }
}
var BackgroundImagePositionPopup$1 = "";
class BackgroundImagePositionPopup extends BasePopup {
  getTitle() {
    return this.$i18n("background.image.position.popup.title");
  }
  initState() {
    return {
      size: this.props.size || "auto",
      repeat: this.props.repeat || "repeat",
      x: this.props.x || 0,
      y: this.props.y || 0,
      width: this.props.width || 0,
      height: this.props.height || 0,
      blendMode: this.props.blendMode
    };
  }
  updateData(opt = {}) {
    this.setState(opt, false);
    this.emit(this.state.changeEvent, opt, this.state.params);
  }
  templateForSize() {
    return `
      <div>
        ${createComponent("SelectEditor", {
      label: this.$i18n("background.image.position.popup.size"),
      ref: "$size",
      key: "size",
      value: this.state.size,
      options: ["contain", "cover", "auto"],
      onchange: "changeRangeEditor"
    })}
      </div>
    `;
  }
  [SUBSCRIBE_SELF("changeRangeEditor")](key, value) {
    this.updateData({ [key]: value });
  }
  templateForX() {
    return `
      <div>
        ${createComponent("InputRangeEditor", {
      label: "X",
      compact: true,
      ref: "$x",
      key: "x",
      value: this.state.x,
      min: -1e3,
      max: 1e3,
      step: 1,
      onchange: "changeRangeEditor"
    })}
      </div>
    `;
  }
  templateForY() {
    return `
      <div >
        <object refClass="InputRangeEditor" ${variable$4({
      label: "Y",
      compact: true,
      ref: "$y",
      key: "y",
      value: this.state.y,
      min: -1e3,
      max: 1e3,
      step: 1,
      onchange: "changeRangeEditor"
    })}  
          
        />
      </div>
    `;
  }
  templateForWidth() {
    return `
    <div >
      <object refClass="InputRangeEditor" ${variable$4({
      label: "W",
      compact: true,
      ref: "$width",
      key: "width",
      value: this.state.width,
      min: 0,
      max: 500,
      step: 1,
      onchange: "changeRangeEditor"
    })} 
        
      />
    </div>
    `;
  }
  templateForHeight() {
    return `
    <div >
      <object refClass="InputRangeEditor" ${variable$4({
      label: "H",
      compact: true,
      ref: "$height",
      key: "height",
      value: this.state.height,
      min: 0,
      max: 500,
      step: 1,
      onchange: "changeRangeEditor"
    })} 

      />
    </div>
    `;
  }
  templateForRepeat() {
    return `
    <div class='grid'>
      <label>${this.$i18n("background.image.position.popup.repeat")}</label>
      <div class='repeat-list' ref="$repeat" data-value='${this.state.repeat}'>
          <button type="button" value='no-repeat' title="${this.$i18n("background.image.position.popup.type.no-repeat")}"></button>
          <button type="button" value='repeat' title="${this.$i18n("background.image.position.popup.type.repeat")}"></button>
          <button type="button" value='repeat-x' title="${this.$i18n("background.image.position.popup.type.repeat-x")}"></button>
          <button type="button" value='repeat-y' title="${this.$i18n("background.image.position.popup.type.repeat-y")}"></button>
          <button type="button" value='space' title="${this.$i18n("background.image.position.popup.type.space")}"></button>
          <button type="button" value='round' title="${this.$i18n("background.image.position.popup.type.round")}"></button>
      </div>
    </div>
    `;
  }
  [CLICK("$repeat button")]({ $dt: $t }) {
    this.refs.$repeat.attr("data-value", $t.value);
    this.updateData({ repeat: $t.value });
  }
  getBody() {
    return `
      <div class="elf--background-image-position-picker" ref='$picker'></div>
    `;
  }
  [LOAD("$picker")]() {
    return `
      
      <div class='box'>

        <div class='background-property'>
          ${this.templateForSize()}      
          <div class="grid-2">            
            ${this.templateForX()}
            ${this.templateForY()}
          </div>
          <div class="grid-2">            
            ${this.templateForWidth()}
            ${this.templateForHeight()}
          </div>
          ${this.templateForRepeat()}
        </div>
      </div>
    `;
  }
  [SUBSCRIBE("showBackgroundImagePositionPopup")](data, params) {
    this.state.changeEvent = data.changeEvent || "changeFillPopup";
    this.state.params = params;
    this.setState(data.data);
    this.show(460);
  }
}
var BackgroundImageProperty$1 = "";
class BackgroundImageProperty extends BaseProperty {
  getTitle() {
    return this.$i18n("background.image.property.title");
  }
  hasKeyframe() {
    return true;
  }
  afterRender() {
    this.show();
  }
  getKeyframeProperty() {
    return "background-image";
  }
  getClassName() {
    return "background-image";
  }
  getBodyClassName() {
    return "no-padding";
  }
  getBody() {
    return `
      <div class='full' ref='$property'></div>               
    `;
  }
  getTools() {
    return `
      <div class="fill-sample-list" ref='$add'>
        <button type="button" class='fill' data-value="static-gradient" data-tooltip="Static" ></button>
        <button type="button" class='fill' data-value="linear-gradient" data-tooltip="Linear" ></button>
        <button type="button" class='fill' data-value="repeating-linear-gradient" data-tooltip="R Linear" ></button>
        <button type="button" class='fill' data-value="radial-gradient" data-tooltip="Radial" ></button>
        <button type="button" class='fill' data-value="repeating-radial-gradient" data-tooltip="R Radial" ></button>
        <button type="button" class='fill' data-value="conic-gradient" data-tooltip="Conic" ></button>
        <button type="button" class='fill' data-value="repeating-conic-gradient" data-tooltip="R Conic" data-direction="bottom right" ></button>
      </div>
    `;
  }
  [CLICK("$add [data-value]")](e2) {
    this.children.$backgroundImageEditor.trigger("add", e2.$dt.data("value"));
  }
  [LOAD("$property")]() {
    var current = this.$selection.current || {};
    var value = current["background-image"] || "";
    return createComponent("BackgroundImageEditor", {
      ref: "$backgroundImageEditor",
      key: "background-image",
      value,
      onchange: "changeBackgroundImage"
    });
  }
  get editableProperty() {
    return "background-image";
  }
  [SUBSCRIBE("refreshSelection") + IF("checkShow")]() {
    this.refresh();
  }
  [SUBSCRIBE_SELF("changeBackgroundImage")](key, value) {
    this.command("setAttributeForMulti", "change background image", this.$selection.packByValue({
      [key]: value
    }));
  }
}
var BackgroundPositionEditor$1 = "";
class BackgroundPositionEditor extends EditorElement {
  initState() {
    return {
      index: this.props.index,
      x: this.props.x,
      y: this.props.y,
      width: this.props.width,
      height: this.props.height,
      repeat: this.props.repeat,
      size: this.props.size,
      blendMode: this.props.blendMode,
      color: "rgba(0, 0, 0, 1)"
    };
  }
  updateData(opt = {}) {
    this.setState(opt, false);
    this.modifyValue(opt);
  }
  modifyValue(value) {
    this.parent.trigger(this.props.onchange, this.props.key, value, this.state.index);
  }
  setValue(obj2) {
    this.setState(__spreadValues({}, obj2));
  }
  [BIND("$miniView")]() {
    return {
      style: {
        "background-image": "linear-gradient(to top right, black, white)",
        "background-repeat": this.state.repeat,
        "background-size": "7px 7px"
      }
    };
  }
  template() {
    return `
            <div class='elf--background-position-editor'>
                <div class='preview' ref='$preview'>
                    <div class='mini-view'>
                        <div class='color-view' style="background-color: ${this.state.color}" ref='$miniView'></div>
                    </div>
                </div>
            </div>
        `;
  }
  [CLICK("$preview")](e2) {
    this.viewBackgroundPositionPopup();
  }
  viewBackgroundPositionPopup() {
    this.emit("showBackgroundImagePositionPopup", {
      changeEvent: "changeBackgroundPositionPattern",
      data: this.state
    }, {
      id: this.id
    });
  }
  [SUBSCRIBE("changeBackgroundPositionPattern")](pattern, params) {
    if (params.id === this.id) {
      this.updateData(__spreadValues({}, pattern));
    }
  }
}
function backgroundImage(editor) {
  editor.registerElement({
    BackgroundImageEditor,
    BackgroundPositionEditor
  });
  editor.registerMenuItem("inspector.tab.style", {
    BackgroundImageProperty
  });
  editor.registerMenuItem("popup", {
    BackgroundImagePositionPopup
  });
}
var Button$1 = "";
class BaseUI extends EditorElement {
  getValue() {
    return this.props.defaultValue;
  }
  sendEvent() {
    const key = this.props.key;
    const value = this.getValue();
    const params = this.props.params;
    if (isFunction(this.props.onClick)) {
      this.props.onClick(key, value, params);
    } else if (isString(this.props.action)) {
      this.emit(this.props.action, key, value, params);
    } else if (isArray(this.props.action)) {
      this.emit(...this.props.action, key, value, params);
    } else {
      this.parent.trigger(this.props.onchange, key, value, params);
    }
  }
}
class Button extends BaseUI {
  initialize() {
    super.initialize();
    this.notEventRedefine = true;
  }
  initState() {
    return {
      label: this.props.label || "",
      text: this.props.text || "",
      params: this.props.params || ""
    };
  }
  template() {
    return `<div class='small-editor button' ref='$body'></div>`;
  }
  [LOAD("$body")]() {
    var { label, text: text2 } = this.state;
    var hasLabel = !!label ? "has-label" : "";
    return `
        <div class='elf--button ${hasLabel}'>
            ${label ? `<label title="${label}">${label}</label>` : ""}
            <div class='area'>
                <button type="button" >${text2 || label}</button>
            </div>
        </div>
    `;
  }
  getValue() {
    return this.props.defaultValue;
  }
  [CLICK("$el button")]() {
    this.sendEvent();
  }
}
var ToggleCheckBox$1 = "";
const DEFAULT_LABELS$1 = ["True", "False"];
class ToggleCheckBox extends BaseUI {
  initialize() {
    super.initialize();
    this.notEventRedefine = true;
  }
  initState() {
    return {
      label: this.props.label || "",
      checked: this.props.value || "false",
      toggleLabels: this.props.toggleLabels || DEFAULT_LABELS$1,
      toggleTitles: this.props.toggleTitles || [],
      toggleValues: this.props.toggleValues || ["true", "false"]
    };
  }
  template() {
    return `<div class='small-editor button' ref='$body'></div>`;
  }
  [LOAD("$body")]() {
    var { label, checked } = this.state;
    var hasLabel = !!label ? "has-label" : "";
    return `
        <div class='elf--toggle-checkbox ${hasLabel}'>
            ${label ? `<label title="${label}">${label}</label>` : ""}
            <div class='area' ref="$area">
                ${this.state.toggleValues.map((it, index2) => {
      let label2 = this.state.toggleLabels[index2];
      this.state.toggleTitles[index2];
      if (obj[label2]) {
        label2 = iconUse$1(label2, "", { width: 30, height: 30 });
      }
      return createElementJsx("div", null, createElementJsx("button", {
        type: "button",
        class: `${it === checked ? "checked" : ""}`,
        "data-index": index2,
        value: it,
        style: "--elf--toggle-checkbox-tooltip-top: -20%;"
      }, label2));
    }).join("")}
            </div>
        </div>
    `;
  }
  [BIND("$area")]() {
    const selectedIndex = this.state.toggleValues.findIndex((v) => v === this.state.checked);
    const unit = 100 / this.state.toggleValues.length;
    return {
      "data-selected-index": selectedIndex,
      cssText: `
                --unit-count: ${this.state.toggleValues.length};
                --button-font-size: ${13 - this.state.toggleValues.length}px ;
                --selected-button-size: ${1 / this.state.toggleValues.length * 100}%;
                --selected-button-position: ${selectedIndex * unit}%;
            `
    };
  }
  setValue(checked) {
    this.setState({
      checked
    });
  }
  getValue() {
    return this.state.checked;
  }
  [CLICK("$el button")](e2) {
    this.setValue(e2.$dt.value);
    this.trigger("change");
  }
  [SUBSCRIBE_SELF("change")]() {
    this.sendEvent();
  }
}
var ToggleButton$1 = "";
const DEFAULT_LABELS = ["True", "False"];
class ToggleButton extends BaseUI {
  initialize() {
    super.initialize();
    this.notEventRedefine = true;
  }
  initState() {
    return {
      checkedValue: this.props.checkedValue || this.props.value,
      checked: this.props.value || "false",
      toggleLabels: this.props.toggleLabels || DEFAULT_LABELS,
      toggleTitles: this.props.toggleTitles || [],
      toggleValues: this.props.toggleValues || ["true", "false"]
    };
  }
  template() {
    return `<div class='small-editor button' ref='$body'></div>`;
  }
  [LOAD("$body")]() {
    var { checked, checkedValue } = this.state;
    return `
        <div class='elf--toggle-button'>
            <div class='area' ref="$area">
                ${this.state.toggleValues.map((it, index2) => {
      let label = this.state.toggleLabels[index2];
      let title2 = this.state.toggleTitles[index2] || label;
      if (obj[label]) {
        label = iconUse$1(label, "", { width: 30, height: 30 });
      }
      return createElementJsx("div", {
        class: `${it === checked ? "visible" : ""} ${it === checkedValue ? "checked" : ""}`
      }, createElementJsx("button", {
        type: "button",
        "data-index": index2,
        class: it === checkedValue ? "checked" : "",
        value: it,
        title: title2,
        style: "--elf--toggle-checkbox-tooltip-top: -20%;"
      }, label));
    }).join("")}
            </div>
        </div>
    `;
  }
  [BIND("$area")]() {
    const selectedIndex = this.state.toggleValues.findIndex((v) => v === this.state.checked);
    return {
      "data-selected-index": selectedIndex
    };
  }
  setValue(checked) {
    this.setState({
      checked
    });
  }
  getValue() {
    return this.state.checked;
  }
  [CLICK("$el button")](e2) {
    const value = e2.$dt.value;
    const selectedIndex = this.state.toggleValues.findIndex((v) => v === value);
    const nextValue = this.state.toggleValues[(selectedIndex + 1) % this.state.toggleValues.length];
    this.setValue(nextValue);
    this.trigger("change");
  }
  [SUBSCRIBE_SELF("change")]() {
    this.sendEvent();
  }
}
function baseEditor(editor) {
  editor.registerElement({
    ToggleCheckBox,
    ToggleButton,
    Button
  });
  editor.registerAlias({
    "toggle-checkbox": "ToggleCheckBox",
    "toggle-button": "ToggleButton",
    "button": "Button"
  });
}
var PathToolProperty$1 = "";
class PathToolProperty extends BaseProperty {
  components() {
    return {
      LeftAlign,
      CenterAlign,
      RightAlign,
      TopAlign,
      MiddleAlign,
      BottomAlign,
      SameWidth,
      SameHeight
    };
  }
  getTitle() {
    return this.$i18n("alignment.property.title");
  }
  isHideHeader() {
    return true;
  }
  getBody() {
    return `
      <div class="elf--boolean-item" ref="$buttons">
        <div>
          <button type="button" data-command="convert.path.operation" data-args="union">${iconUse$1("boolean_union", "", { width: 30, height: 30 })} Union</button>        
          <button type="button" data-command="convert.path.operation" data-args="intersection">${iconUse$1("boolean_intersection", "", { width: 30, height: 30 })} Intersection</button>        
        </div>
        <div>
          <button type="button" data-command="convert.path.operation" data-args="difference">${iconUse$1("boolean_difference", "", { width: 30, height: 30 })} Subtract</button>        
          <button type="button" data-command="convert.path.operation" data-args="xor">${iconUse$1("boolean_xor", "", { width: 30, height: 30 })} Exclude</button>        
        </div>
        <div class="divider"></div>
        <!--div>
          <button type="button" data-command="convert.no.transform.path">${iconUse$1("grid3x3", "", { width: 24, height: 24 })} No Transform</button>        
        </div-->
        <div>
          <button type="button" data-command="convert.simplify.path">${iconUse$1("grid3x3", "", { width: 24, height: 24 })} Self Intersection</button>        
          <button type="button" data-command="convert.flatten.path">${iconUse$1("flatten", "", { width: 24, height: 24 })} Flatten</button>                  
        </div>        
        <div>
          <!--<button type="button" data-command="convert.smooth.path">${iconUse$1("smooth", "", { width: 24, height: 24 })} Smooth Path</button>-->                
          <button type="button" data-command="switch.path">${iconUse$1("sync", "", { width: 30, height: 30 })} Switch path</button>                  
          <button type="button" data-command="convert.stroke.to.path">${iconUse$1("outline_shape", "", { width: 24, height: 24 })} Outline Path</button> 
        </div>        
        <!--div>
          <button type="button" data-command="convert.polygonal.path">${iconUse$1("highlight_at", "", { width: 24, height: 24 })} Polygonal</button>                
          <button type="button" data-command="convert.normalize.path">${iconUse$1("stroke_to_path", "", { width: 24, height: 24 })} Normalize</button> 
        </div-->                
      </div>
    `;
  }
  [CLICK("$buttons button")](e2) {
    const command = e2.$dt.data("command");
    const args2 = e2.$dt.data("args");
    if (command === "convert.smooth.path") {
      this.emit(command);
    } else {
      this.emit(command, args2);
    }
  }
  [SUBSCRIBE("refreshSelection")]() {
    this.refreshShow(() => {
      if (this.$selection.length === 1 && this.$selection.is("boolean-path"))
        return true;
      return this.$selection.is("svg-path", "polygon", "star");
    });
  }
}
function pathTool(editor) {
  editor.registerMenuItem("inspector.tab.style", {
    PathToolProperty
  });
}
var BorderStyles = {
  "none": true,
  "hidden": true,
  "dotted": true,
  "dashed": true,
  "solid": true,
  "double": true,
  "groove": true,
  "ridge": true,
  "inset": true,
  "outset": true
};
class Border {
  static parseStyle(str) {
    return STRING_TO_CSS(str);
  }
  static parseValue(str = "") {
    var style = "";
    var width2 = "";
    var color2 = "";
    str.split(" ").filter((it) => it.trim()).forEach((value) => {
      if (BorderStyles[value]) {
        style = value;
      } else if (Color.isColor(value)) {
        color2 = value;
      } else {
        width2 = Length.parse(value).value;
      }
    });
    return {
      style,
      color: color2,
      width: width2
    };
  }
  static joinValue(obj2) {
    return `${obj2.width}px ${obj2.style || "solid"} ${obj2.color}`;
  }
  static join(obj2) {
    var arr = [
      obj2["border"] ? `border: ${obj2["border"]}` : "",
      obj2["border-top"] ? `border-top: ${obj2["border-top"]}` : "",
      obj2["border-left"] ? `border-left: ${obj2["border-left"]}` : "",
      obj2["border-right"] ? `border-right: ${obj2["border-right"]}` : "",
      obj2["border-bottom"] ? `border-bottom: ${obj2["border-bottom"]}` : ""
    ].filter((it) => it);
    return arr.join(";");
  }
}
var BorderEditor$1 = "";
const borderTypeList = [
  "border"
];
const borderTypeTitle = {
  "border": "all",
  "border-top": "top",
  "border-right": "right",
  "border-bottom": "bottom",
  "border-left": "left"
};
class BorderEditor extends EditorElement {
  initState() {
    var borders = Border.parseStyle(this.props.value);
    var direction = Object.keys(borders)[0] || "border";
    return {
      direction,
      borders
    };
  }
  updateData(obj2) {
    this.setState(obj2, false);
    this.parent.trigger(this.props.onchange, this.props.key, this.getValue(), this.props.params);
  }
  getValue() {
    return Border.join(this.state.borders);
  }
  setValue(value) {
    this.state.borders = Border.parseStyle(value);
    this.refresh();
  }
  [LOAD("$editorArea")]() {
    return borderTypeList.map((type) => {
      var label = borderTypeTitle[type] || type;
      label = this.$i18n("border.editor." + label);
      return `
      <div>
        <object refClass='BorderValueEditor' ${variable$4({
        ref: `$${type}`,
        label,
        key: type,
        value: this.state.borders[type],
        onchange: "changeKeyValue"
      })}  />
      </div>
      `;
    });
  }
  template() {
    return `
      <div class="elf--border-editor">
        <div class='editor-area' ref='$editorArea'>

        </div>
      </div>
    `;
  }
  [SUBSCRIBE_SELF("changeKeyValue")](key, value) {
    var borders = this.state.borders;
    borders[key] = value;
    this.updateData({ borders });
  }
}
var BorderProperty$1 = "";
class BorderProperty extends BaseProperty {
  getTitle() {
    return this.$i18n("border.property.title");
  }
  getBody() {
    return `<div class="property-item full border-item" ref='$body'></div>`;
  }
  [LOAD("$body")]() {
    var current = this.$selection.current || {};
    var value = current["border"] || "";
    return `
      <object refClass='BorderEditor' ${variable$4({
      ref: "$1",
      key: "border",
      value,
      onchange: "changeKeyValue"
    })}  />
    `;
  }
  get editableProperty() {
    return "border";
  }
  [SUBSCRIBE("refreshSelection") + DEBOUNCE(100) + IF("checkShow")]() {
    this.refresh();
  }
  [SUBSCRIBE_SELF("changeKeyValue")](key, value) {
    this.command("setAttributeForMulti", "change border", this.$selection.packByValue({
      [key]: value
    }));
  }
}
var BorderValueEditor$1 = "";
const borderStyleList = [
  BorderStyle.NONE,
  BorderStyle.HIDDEN,
  BorderStyle.SOLID,
  BorderStyle.DASHED,
  BorderStyle.DOTTED,
  BorderStyle.DOUBLE,
  BorderStyle.GROOVE,
  BorderStyle.RIDGE,
  BorderStyle.INSET,
  BorderStyle.OUTSET
].join(",");
class BorderValueEditor extends EditorElement {
  initState() {
    return {
      value: Border.parseValue(this.props.value)
    };
  }
  updateData(obj2) {
    this.setState(obj2, false);
    this.parent.trigger(this.props.onchange, this.props.key, this.getValue(), this.props.params);
  }
  getValue() {
    return Border.joinValue(this.state.value);
  }
  setValue(value) {
    this.state.value = Border.parseValue(value);
    this.refresh();
  }
  refresh() {
    const width2 = Length.parse(this.state.value.width === "undefined" ? 0 : this.state.value.width);
    this.children.$width.setValue(width2.value || 0);
    this.children.$style.setValue(this.state.value.style || "solid");
    this.children.$color.setValue(this.state.value.color || "rgba(0, 0, 0, 1)");
  }
  template() {
    var { width: width2, style, color: color2 } = this.state.value;
    return `
      <div class="elf--border-value-editor">
        <div class='editor-area'>
          <object refClass="NumberInputEditor" ${variable$4({
      label: iconUse$1("line_weight"),
      compact: true,
      ref: "$width",
      min: 0,
      max: 100,
      step: 1,
      key: "width",
      value: width2,
      onchange: "changeKeyValue"
    })}/>        
          <object refClass="SelectEditor" ${variable$4({
      ref: "$style",
      key: "style",
      label: iconUse$1("line_style"),
      title: "Style",
      compact: true,
      options: borderStyleList,
      value: style || "solid",
      onchange: "changeKeyValue"
    })} />
          <object refClass="ColorViewEditor" ${variable$4({
      ref: "$color",
      key: "color",
      mini: true,
      value: color2 || "rgba(0, 0, 0, 1)",
      onchange: "changeKeyValue"
    })} />          
        </div>
      </div>
    `;
  }
  [SUBSCRIBE_SELF("changeKeyValue")](key, v) {
    var value = this.state.value;
    value[key] = v;
    this.updateData({ value });
  }
}
function border(editor) {
  editor.registerElement({
    BorderEditor,
    BorderValueEditor
  });
  editor.registerMenuItem("inspector.tab.style", {
    BorderProperty
  });
}
const typeList$3 = [
  { key: "top", title: "Top" },
  { key: "bottom", title: "Bottom" },
  { key: "left", title: "Left" },
  { key: "right", title: "Right" }
];
const keyList$2 = typeList$3.map((it) => it.key);
const names = {
  image: "Image",
  "static-gradient": "Static",
  "linear-gradient": "Linear",
  "repeating-linear-gradient": `${obj.repeat} Linear`,
  "radial-gradient": "Radial",
  "repeating-radial-gradient": `${obj.repeat} Radial`,
  "conic-gradient": "Conic",
  "repeating-conic-gradient": `${obj.repeat} Conic`
};
class BorderImageProperty extends BaseProperty {
  getTitle() {
    return "Border Image";
  }
  [SUBSCRIBE("refreshSelection")]() {
    this.refresh();
  }
  getTools() {
    var current = this.$selection.current || {};
    var appliedBorderImage = current.appliedBorderImage || false;
    return `
      <label><input type='checkbox' ${appliedBorderImage ? "checked" : ""} ref='$apply' /> Apply</label>
    `;
  }
  [CLICK("$apply")]() {
    var current = this.$selection.current;
    if (!current)
      return;
    var applyBorderImage = this.refs.$apply.checked();
    current.reset({ applyBorderImage });
    this.emit("refreshElement", current);
  }
  getColorStepList(image2) {
    switch (image2.type) {
      case "static-gradient":
      case "linear-gradient":
      case "repeating-linear-gradient":
      case "radial-gradient":
      case "repeating-radial-gradient":
      case "conic-gradient":
      case "repeating-conic-gradient":
        return this.getColorStepString(image2.colorsteps);
    }
    return "";
  }
  getColorStepString(colorsteps) {
    return colorsteps.map((step2) => {
      return `<div class='step' data-colorstep-id="${step2.id}" data-selected='${step2.selected}' style='background-color:${step2.color};'></div>`;
    }).join("");
  }
  [LOAD("$borderImageView")]() {
    var current = this.$selection.current || { borderImage: { image: {} } };
    var borderImage2 = current.borderImage;
    var backgroundTypeName = borderImage2.type ? names[borderImage2.type] : "";
    const imageCSS = `background-image: ${borderImage2.image.toString()}; background-size: cover;`;
    return ` 
      <div class='preview' ref="$preview">
        <div class='mini-view'>
          <div class='color-view'  style="${imageCSS}" ref="$miniView"></div>
        </div>
      </div> 
      <div class='fill-info'>
        <div class='gradient-info'>
          <div class='fill-title' ref="$fillTitle">${backgroundTypeName}</div>
          <div class='colorsteps' ref="$colorsteps">
            ${this.getColorStepList(borderImage2.image)}
          </div>
        </div>
      </div>
    `;
  }
  [SUBSCRIBE_SELF("changeBorderImage")](key, value) {
    if (key === "border-image-slice") {
      keyList$2.forEach((type) => {
        this.children[`$${type}Slice`].setValue(value);
      });
    }
    this.setBorderImageProperty();
  }
  getBody() {
    return `
      <div class="property-item border-image-item" ref='$borderImageView'></div>    
      <div class="property-item border-slice-item">
        <div class="slice-selector" data-selected-value="all" ref="$selector">
          <button type="button" data-value="all">${obj.border_all}</button>
          <button type="button" data-value="partitial">
            ${obj.border_inner}
          </button>
        </div>
        <div class="slice-value">
          ${createComponent("RangeEditor", {
      ref: "$allSlice",
      key: "border-image-slice",
      onchange: "changeBorderImage"
    })}
        </div>
      </div>
      <div
        class="property-item border-slice-item full has-list"
        ref="$partitialSetting"
        style="display: none;"
      >
        <div class="slice-setting-box" ref="$sliceSettingBox">
          ${typeList$3.map((it) => {
      return `
              <div>
                <label class='title'>${it.title}</label>
              </div>
              <div>
                ${createComponent("RangeEditor", {
        ref: `$${it.key}Slice`,
        label: "Slice",
        key: `border-image-slice-${it.key}`,
        onchange: "changeBorderImage"
      })}
              </div>  
              <div>
                ${createComponent("RangeEditor", {
        ref: `$${it.key}Width`,
        label: "Width",
        key: `border-image-width-${it.key}`,
        onchange: "changeBorderImage"
      })}              
              </div>                
            `;
    }).join("")}
        </div>
      </div>
    `;
  }
  [CHANGE("$sliceSettingBox select")](e2) {
    this.setBorderImageProperty();
  }
  [CLICK("$borderImageView .preview")]() {
    this.viewFillPopup(this.refs.$preview, "");
  }
  [CLICK("$borderImageView .colorsteps .step")](e2) {
    this.refs.$colorsteps.$(`[data-selected="true"]`).removeAttr("data-selected");
    var selectColorStepId = e2.$dt.attr("data-colorstep-id");
    e2.$dt.attr("data-selected", true);
    var $preview = e2.$dt.closest("border-image-item").$(".preview");
    this.viewFillPopup($preview, selectColorStepId);
  }
  getFillData(borderImage2) {
    let data = {
      type: borderImage2.type
    };
    switch (data.type) {
      case "image":
        data.url = borderImage2.image ? borderImage2.image.url : "";
        break;
      default:
        if (borderImage2.image) {
          const image2 = borderImage2.image;
          data.type = image2.type;
          data.colorsteps = [...image2.colorsteps];
          data.angle = image2.angle;
          data.radialType = image2.radialType || "ellipse";
          data.radialPosition = image2.radialPosition || Position.CENTER;
        } else {
          data.colorsteps = [];
          data.angle = 0;
          data.radialType = "ellipse";
          data.radialPosition = Position.CENTER;
        }
        break;
    }
    return data;
  }
  viewFillPopup($preview, selectColorStepId) {
    var current = this.$selection.current;
    if (!current)
      return;
    this.emit("showFillPopup", __spreadProps(__spreadValues({
      changeEvent: "changeBorderImageFillPopup"
    }, this.getFillData(current.borderImage)), {
      selectColorStepId,
      refresh: true
    }));
  }
  viewChangeImage(data) {
    var current = this.$selection.current;
    if (!current)
      return;
    var borderImage2 = current.borderImage;
    if (!borderImage2)
      return;
    var $el = this.getRef("$miniView");
    if ($el && borderImage2.image) {
      $el.css({
        "background-image": borderImage2.image.toString(),
        "background-size": "cover"
      });
    }
    var $el = this.getRef("$fillTitle");
    if ($el) {
      $el.html(names["image"]);
    }
    var $el = this.getRef("$colorsteps", this.selectedIndex);
    if ($el) {
      $el.empty();
    }
  }
  setImage(data) {
    var current = this.$selection.current;
    if (!current)
      return;
    current.borderImage.setImageUrl(data);
    this.viewChangeImage(data);
    this.emit("refreshElement", current);
  }
  viewChangeGradient(data) {
    var current = this.$selection.current;
    if (!current)
      return;
    var borderImage2 = current.borderImage;
    if (!borderImage2)
      return;
    var $el = this.getRef("$miniView");
    if ($el) {
      $el.css({
        "background-image": borderImage2.image.toString(),
        "background-size": "cover"
      });
    }
    var $el = this.getRef("$fillTitle");
    if ($el) {
      $el.html(names[data.type]);
    }
    var $el = this.getRef("$colorsteps", this.selectedIndex);
    if ($el) {
      $el.html(this.getColorStepString(data.colorsteps));
    }
  }
  setGradient(data) {
    var current = this.$selection.current;
    if (!current)
      return;
    current.borderImage.setGradient(data);
    this.viewChangeGradient(data);
    this.emit("refreshElement", current);
  }
  [SUBSCRIBE("changeBorderImageFillPopup")](data) {
    switch (data.type) {
      case "image":
        this.setImage(data);
        break;
      default:
        this.setGradient(data);
        break;
    }
  }
  setBorderImageProperty() {
    var current = this.$selection.current;
    if (!current)
      return;
    var borderImage2 = current.borderImage;
    var type = this.refs.$selector.attr("data-selected-value");
    if (type === "all") {
      var len2 = this.children.$allSlice.getValue();
      borderImage2.reset({
        slice: {
          top: len2.clone(),
          right: len2.clone(),
          bottom: len2.clone(),
          left: len2.clone()
        }
      });
    } else {
      keyList$2.forEach((type2) => {
        borderImage2.slice[type2] = this.children[`$${type2}Slice`].getValue();
        borderImage2.width[type2] = this.children[`$${type2}Width`].getValue();
      });
    }
    this.emit("refreshElement", current);
  }
  [CLICK("$selector button")](e2) {
    var type = e2.$dt.attr("data-value");
    this.refs.$selector.attr("data-selected-value", type);
    if (type === "all") {
      this.refs.$partitialSetting.hide();
    } else {
      this.refs.$partitialSetting.show("grid");
    }
    this.setBorderImageProperty();
  }
}
function borderImage(editor) {
  editor.registerElement({
    BorderImageProperty
  });
}
var BorderRadiusEditor$1 = "";
const typeList$2 = [
  { key: "border-top-left-radius", title: "topLeft", label: "TL" },
  { key: "border-top-right-radius", title: "topRight", label: "TR" },
  { key: "border-bottom-left-radius", title: "bottomLeft", label: "BL" },
  { key: "border-bottom-right-radius", title: "bottomRight", label: "BR" }
];
const keyList$1 = typeList$2.map((it) => it.key);
const BorderGroup = {
  ALL: "all",
  PARTITIAL: "partial"
};
class BorderRadiusEditor extends EditorElement {
  initState() {
    return __spreadValues({}, BorderRadius.parseStyle(this.props.value));
  }
  template() {
    return `<div class='elf--border-radius-editor' ref='$body'></div>`;
  }
  [SUBSCRIBE_SELF("changeBorderRadius")](key, value) {
    if (key === "border-radius") {
      keyList$1.forEach((type) => {
        this.children[`$${type}`].setValue(value.clone());
      });
    }
    this.setBorderRadius();
  }
  [LOAD("$body")]() {
    BorderGroup.ALL;
    var borderRadius2 = this.state["border-radius"];
    return `
      <div class="border-radius-item">
        <div class="radius-value">
          ${createComponent("InputRangeEditor", {
      label: iconUse$1("outline_rect"),
      ref: "$all",
      compact: "true",
      key: "border-radius",
      value: borderRadius2,
      min: 0,
      onchange: "changeBorderRadius"
    })}
        </div>
        <div></div>

        <object refClass="ToggleButton" ${variable$4({
      compact: true,
      ref: "$toggle",
      key: "border-all",
      checkedValue: BorderGroup.PARTITIAL,
      value: BorderGroup.ALL,
      toggleLabels: ["border_inner", "border_inner"],
      toggleValues: [BorderGroup.ALL, BorderGroup.PARTITIAL],
      onchange: "changeKeyValue"
    })}
        />
      </div>
      <div
        class="full border-radius-item"
        ref="$partitialSetting"
        style="display: none;"
      >
        <div class="radius-setting-box" ref="$radiusSettingBox">
          <div>
            ${typeList$2.map((it) => {
      var value = this.state[it.key];
      var title2 = this.$i18n("border.radius.editor." + it.title);
      var label = it.label;
      return `
                <div>
                    <object refClass="InputRangeEditor"  compact="true" ref='$${it.key}' label='${label}' title="${title2}" key='${it.key}' value='${value}' min="0" step="1" onchange='changeBorderRadius' />
                </div>  
              `;
    }).join("")}
          </div>
        </div>
      </div>
    `;
  }
  [INPUT("$radiusSettingBox input")](e2) {
    this.setBorderRadius();
  }
  [CHANGE("$radiusSettingBox select")](e2) {
    this.setBorderRadius();
  }
  setBorderRadius() {
    var type = this.selectedValue;
    if (type === BorderGroup.ALL) {
      this.state["border-radius"] = this.children[`$all`].getValue();
    } else {
      keyList$1.forEach((key) => {
        this.state[key] = this.children[`$${key}`].getValue();
      });
    }
    this.modifyBorderRadius();
  }
  modifyBorderRadius() {
    var value = "";
    if (this.selectedValue === BorderGroup.ALL) {
      value = this.state["border-radius"] + "";
    } else {
      value = keyList$1.map((key) => `${this.state[key]}`).join(" ");
    }
    this.parent.trigger(this.props.onchange, value);
  }
  [SUBSCRIBE_SELF("changeKeyValue")](key, value) {
    const type = value;
    if (type === BorderGroup.PARTITIAL) {
      this.selectedValue = BorderGroup.PARTITIAL;
      this.refs.$partitialSetting.show();
    } else {
      this.selectedValue = BorderGroup.ALL;
      this.refs.$partitialSetting.hide();
    }
    this.setBorderRadius();
  }
}
class BorderRadiusProperty extends BaseProperty {
  getTitle() {
    return this.$i18n("border.radius.property.title");
  }
  getBody() {
    return `<div class="property-item full border-radius-item" ref='$body'></div>`;
  }
  [LOAD("$body")]() {
    var current = this.$selection.current || {};
    var value = current["border-radius"] || "";
    return `
      <object refClass="BorderRadiusEditor" ref='$1' value='${value}' onchange='changeBorderRadius' />
    `;
  }
  get editableProperty() {
    return "border-radius";
  }
  [SUBSCRIBE("refreshSelection") + DEBOUNCE(100) + IF("checkShow")]() {
    this.refresh();
  }
  [SUBSCRIBE_SELF("changeBorderRadius")](value) {
    this.command("setAttributeForMulti", "change border radius", this.$selection.packByValue({
      "border-radius": value
    }));
  }
}
function borderRadius(editor) {
  editor.registerElement({
    BorderRadiusEditor
  });
  editor.registerMenuItem("inspector.tab.style", {
    BorderRadiusProperty
  });
}
var BoxModelProperty$1 = "";
const fields = ["margin", "padding"];
let styleKeys = [];
fields.forEach((field) => {
  styleKeys.push.apply(styleKeys, ["-top", "-bottom", "-left", "-right"].map((it) => field + it));
});
class BoxModelProperty extends BaseProperty {
  initialize() {
    super.initialize();
    this.notEventRedefine = true;
  }
  getTitle() {
    return this.$i18n("box.model.property.title");
  }
  get editableProperty() {
    return "box-model-block";
  }
  [SUBSCRIBE("refreshSelection") + DEBOUNCE(100) + IF("checkShow")]() {
    this.refresh();
  }
  [SUBSCRIBE("refreshSelectionStyleView")]() {
    const current = this.$selection.current;
    if (current == null ? void 0 : current.hasChangedField("padding-left", "padding-right", "padding-top", "padding-bottom")) {
      this.refresh();
    }
  }
  getBody() {
    return `<div class="property-item elf--box-model-item" ref="$boxModelItem"></div>`;
  }
  templateInput(key, current) {
    var value = Length.parse(current[key] || 0);
    return `<input type="number" ref="$${key}" value="${value.value}" tabIndex="1" />`;
  }
  [LOAD("$boxModelItem") + DOMDIFF]() {
    var current = this.$selection.current;
    if (!current)
      return "";
    return `
      <div>
        <div class="margin" data-title="${this.$i18n("box.model.property.margin")}">
          <div data-value="top">
            ${this.templateInput("margin-top", current)}
          </div>
          <div data-value="bottom">
            ${this.templateInput("margin-bottom", current)}
          </div>
          <div data-value="left">
            ${this.templateInput("margin-left", current)}
          </div>
          <div data-value="right">
            ${this.templateInput("margin-right", current)}
          </div>
        </div>
        <div class="padding" data-title="${this.$i18n("box.model.property.padding")}">
          <div data-value="top">
            ${this.templateInput("padding-top", current)}
          </div>
          <div data-value="bottom">
            ${this.templateInput("padding-bottom", current)}
          </div>
          <div data-value="left">
            ${this.templateInput("padding-left", current)}
          </div>
          <div data-value="right">
            ${this.templateInput("padding-right", current)}
          </div>
        </div>
        <div class='content' title='Content'>
        
        </div>
      </div>
    `;
  }
  [INPUT("$boxModelItem input")](e2) {
    this.resetBoxModel();
  }
  resetBoxModel() {
    var data = {};
    styleKeys.forEach((key) => {
      data[key] = this.refs["$" + key].value;
    });
    this.command("setAttributeForMulti", "change padding or margin", this.$selection.packByValue(data));
  }
}
function boxModel(editor) {
  editor.registerMenuItem("inspector.tab.style", {
    BoxModelProperty
  });
}
var BoxShadowEditor$1 = "";
class BoxShadowEditor extends EditorElement {
  initState() {
    return {
      boxShadows: BoxShadow.parseStyle(this.props.value || "")
    };
  }
  template() {
    return `
      <div class="elf--box-shadow-editor" >
        <div class='box-shadow-list' ref='$shadowList'></div>
      </div>
    `;
  }
  [LOAD("$shadowList")]() {
    var arr = this.state.boxShadows.map((shadow2, index2) => {
      return `
        <div class="shadow-item real" data-index="${index2}">
            <label draggable="true" data-index="${index2}">${iconUse$1("drag_indicator")}</label>
            ${createComponent("ColorViewEditor", {
        mini: true,
        key: "color",
        value: shadow2.color,
        params: index2,
        onchange: "changeKeyValue"
      })}
            ${createComponent("ToggleButton", {
        mini: true,
        key: "inset",
        value: shadow2.inset,
        params: index2,
        onchange: "changeKeyValue",
        checkedValue: BoxShadowStyle.INSET,
        toggleLabels: ["border_style", "border_style"],
        toggleTitles: [BoxShadowStyle.INSET, BoxShadowStyle.INSET],
        toggleValues: [BoxShadowStyle.OUTSET, BoxShadowStyle.INSET]
      })}            
            ${createComponent("NumberInputEditor", {
        mini: true,
        key: "offsetX",
        label: "X",
        value: shadow2.offsetX,
        params: index2,
        onchange: "changeKeyValue"
      })}          
            ${createComponent("NumberInputEditor", {
        mini: true,
        key: "offsetY",
        label: "Y",
        value: shadow2.offsetY,
        params: index2,
        onchange: "changeKeyValue"
      })}                    
            ${createComponent("NumberInputEditor", {
        mini: true,
        label: "B",
        key: "blurRadius",
        value: shadow2.blurRadius,
        params: index2,
        onchange: "changeKeyValue"
      })} 
            ${createComponent("NumberInputEditor", {
        mini: true,
        label: "S",
        key: "spreadRadius",
        value: shadow2.spreadRadius,
        params: index2,
        onchange: "changeKeyValue"
      })}             
          <div class="tools">
            <button type="button" class="remove" data-index="${index2}">
              ${iconUse$1("remove2")}
            </button>
          </div>
        </div>
      `;
    });
    return arr.join("");
  }
  modifyBoxShadow() {
    var value = this.state.boxShadows.join(", ");
    this.parent.trigger(this.props.onchange, this.props.key, value);
  }
  [SUBSCRIBE("add")](shadow2 = "") {
    if (shadow2) {
      this.state.boxShadows = BoxShadow.parseStyle(shadow2);
    } else {
      const shadowObj = new BoxShadow({
        color: "black",
        inset: BoxShadowStyle.OUTSET,
        offsetX: 2,
        offsetY: 2,
        blurRadius: 3,
        spreadRadius: 1
      });
      this.state.boxShadows.push(shadowObj);
    }
    this.refresh();
    this.modifyBoxShadow();
  }
  [CLICK("$add")]() {
    this.trigger("add");
  }
  [DRAGSTART("$shadowList .shadow-item > label")](e2) {
    this.startIndex = +e2.$dt.attr("data-index");
  }
  [DRAGOVER("$shadowList .shadow-item") + PREVENT](e2) {
  }
  sortItem(arr, startIndex, targetIndex) {
    arr.splice(targetIndex + (startIndex < targetIndex ? -1 : 0), 0, ...arr.splice(startIndex, 1));
  }
  sortBoxShadow(startIndex, targetIndex) {
    this.sortItem(this.state.boxShadows, startIndex, targetIndex);
  }
  [DROP("$shadowList .shadow-item") + PREVENT](e2) {
    var targetIndex = +e2.$dt.attr("data-index");
    this.sortBoxShadow(this.startIndex, targetIndex);
    this.refresh();
    this.modifyBoxShadow();
  }
  [CLICK("$shadowList .remove")](e2) {
    var index2 = +e2.$dt.attr("data-index");
    this.state.boxShadows.splice(index2, 1);
    this.refresh();
    this.modifyBoxShadow();
  }
  [SUBSCRIBE("changeKeyValue")](key, value, index2) {
    var shadow2 = this.state.boxShadows[index2];
    shadow2.reset({
      [key]: value
    });
    this.modifyBoxShadow();
  }
}
var boxShadow$1 = [
  { name: "Box", shadow: `0px 3px 3px 0px rgba(0,0,0,0.2)` },
  { name: "Shadow-4", shadow: `
        0px 1px 1px 0px rgba(0,0,0,0.15), 
        0px 2px 2px 0px rgba(0,0,0,0.15), 
        0px 4px 4px 0px rgba(0,0,0,0.15), 
        0px 8px 8px 0px rgba(0,0,0,0.15)
    ` },
  { name: "Shadow-5", shadow: `
        0px  1px 1px 0px rgba(0,0,0,0.12), 
        0px  2px 2px 0px rgba(0,0,0,0.12), 
        0px  4px 4px 0px rgba(0,0,0,0.12), 
        0px  8px 8px 0px rgba(0,0,0,0.12),
        0px  16px 16px 0px rgba(0,0,0,0.12)
    ` },
  { name: "Shadow-6", shadow: `
        0px 1px 1px 0px rgba(0,0,0,0.11), 
        0px 2px 2px 0px rgba(0,0,0,0.11), 
        0px 4px 4px 0px rgba(0,0,0,0.11), 
        0px 8px 8px 0px rgba(0,0,0,0.11), 
        0px 16px 16px 0px rgba(0,0,0,0.11), 
        0px 32px 32px 0px rgba(0,0,0,0.11)
    ` },
  { name: "Sharp", shadow: `
        0px 1px 1px 0px rgba(0,0,0,0.25), 
        0px 2px 2px 0px rgba(0,0,0,0.20), 
        0px 4px 4px 0px rgba(0,0,0,0.15), 
        0px 8px 8px 0px rgba(0,0,0,0.10),
        0px 16px 16px 0px rgba(0,0,0,0.05)
    ` },
  { name: "Diffuse", shadow: `
        0px 1px 1px 0px rgba(0,0,0,0.08), 
        0px 2px 2px 0px rgba(0,0,0,0.12), 
        0px 4px 4px 0px rgba(0,0,0,0.16), 
        0px 8px 8px 0px rgba(0,0,0,0.20)
    ` }
];
var BoxShadowProperty$1 = "";
class BoxShadowProperty extends BaseProperty {
  getTitle() {
    return this.$i18n("boxshadow.property.title");
  }
  getBody() {
    return `
      <div class="full box-shadow-item" ref="$shadowList"></div>
    `;
  }
  getTools() {
    return `
      <select class='box-shadow-samples' ref="$select">
      ${boxShadow$1.map((item2, index2) => {
      return `
          <option value="${index2}">${item2.name}</option>
        `;
    }).join("")}
      </select>
      <button type="button" ref='$add'>${obj.add}</button>
    `;
  }
  [CLICK("$add")]() {
    const index2 = +this.refs.$select.value;
    this.children.$boxshadow.trigger("add", boxShadow$1[index2].shadow);
  }
  [LOAD("$shadowList")]() {
    var current = this.$selection.current || {};
    return createComponent("BoxShadowEditor", {
      ref: "$boxshadow",
      key: "box-shadow",
      value: current["box-shadow"],
      onchange: (key, value) => {
        this.command("setAttributeForMulti", "change box shadow", this.$selection.packByValue({
          [key]: value
        }));
      }
    });
  }
  get editableProperty() {
    return "box-shadow";
  }
  [SUBSCRIBE("refreshSelection") + DEBOUNCE(100) + IF("checkShow")]() {
    this.refresh();
  }
}
function boxShadow(editor) {
  editor.registerElement({
    BoxShadowEditor
  });
  editor.registerMenuItem("inspector.tab.style", {
    BoxShadowProperty
  });
}
class CircleEditor extends EditorElement {
  parseValue(str = "50%") {
    var radius = new Length("", "closest-side"), position2 = "";
    str = str || "50%";
    if (str.includes("at")) {
      [radius, position2] = str.split("at").map((it) => it.trim());
    } else {
      position2 = str.trim();
    }
    var [x2, y2] = position2.split(" ");
    if (isUndefined(y2)) {
      y2 = x2;
    }
    x2 = Length.parse(x2);
    y2 = Length.parse(y2);
    return {
      radius,
      x: x2,
      y: y2
    };
  }
  initState() {
    return this.parseValue(this.props.value);
  }
  template() {
    return `
        <div class='clip-path-editor circle-editor'>
            ${createComponent("InputRangeEditor", {
      ref: "$range",
      label: "Radius",
      key: "radius",
      value: this.state.radius,
      min: 0,
      max: 100,
      step: 0.1,
      units: ["%", "closest-side", "farthest-side"],
      onchange: "changeRangeEditor"
    })}
            <div class='drag-area' ref='$area'>
                <div class='drag-pointer' ref='$pointer' style='left: ${this.state.x};top: ${this.state.y};'></div>
                <div class='clip-area circle' ref='$clipArea'></div>
            </div>
        </div>
    `;
  }
  [BIND("$clipArea")]() {
    return {
      style: {
        "clip-path": `${this.props.key}(${this.toClipPathValueString()})`
      }
    };
  }
  [POINTERSTART("$area") + MOVE() + END()](e2) {
    this.areaRect = this.refs.$area.rect();
    this.startXY = e2.xy;
  }
  move(dx, dy) {
    var x2 = this.startXY.x + dx;
    var y2 = this.startXY.y + dy;
    if (this.areaRect.x > x2) {
      x2 = this.areaRect.x;
    } else if (this.areaRect.right < x2) {
      x2 = this.areaRect.right;
    }
    if (this.areaRect.y > y2) {
      y2 = this.areaRect.y;
    } else if (this.areaRect.bottom < y2) {
      y2 = this.areaRect.bottom;
    }
    var left2 = Length.percent((x2 - this.areaRect.x) / this.areaRect.width * 100).round(1);
    var top2 = Length.percent((y2 - this.areaRect.y) / this.areaRect.height * 100).round(1);
    this.refs.$pointer.css({
      left: left2,
      top: top2
    });
    this.updateData({
      x: left2,
      y: top2
    });
    this.bindData("$clipArea");
  }
  toClipPathValueString() {
    var { x: x2, y: y2, radius } = this.state;
    var results = `${x2} ${y2}`;
    var radiusString = radius + "";
    if (radiusString.includes("closest-side")) {
      radiusString = "closest-side";
    } else if (radiusString.includes("farthest-side")) {
      radiusString = "farthest-side";
    }
    return radius ? `${radiusString} at ${results}` : `${results}`;
  }
  updateData(data) {
    this.setState(data);
    this.parent.trigger(this.props.onchange, this.props.key, this.toClipPathValueString(), this.props.params);
  }
  [SUBSCRIBE_SELF("changeRangeEditor")](key, value) {
    if (key === "radius") {
      var radius = value;
      var tempValue = value.unit + "";
      if (tempValue.includes("closest-side")) {
        radius = new Length("", "closest-side");
      } else if (tempValue.includes("farthest-side")) {
        radius = new Length("", "farthest-side");
      }
      this.updateData({
        radius
      });
    }
  }
}
class InsetEditor extends EditorElement {
  parseValue(str = "") {
    var [inset, round2] = str.split("round");
    var [_count, top2, right2, bottom2, left2] = DirectionLength.parse(inset);
    if (round2) {
      var [_roundCount, topRadius, rightRadius, bottomRadius, leftRadius] = DirectionLength.parse(round2);
    }
    return {
      isAll: _count === 1,
      top: top2,
      right: right2,
      bottom: bottom2,
      left: left2,
      round: round2,
      isAllRadius: _roundCount === 1,
      topRadius,
      rightRadius,
      bottomRadius,
      leftRadius
    };
  }
  initState() {
    return this.parseValue(this.props.value);
  }
  template() {
    var { top: top2, right: right2, bottom: bottom2, left: left2, round: round2 } = this.state;
    var maxWidth = 220;
    var maxHeight = 220;
    var topX = Length.percent(Math.abs((left2.value - (100 - right2.value)) / 2)).toPx(maxWidth);
    var topY = top2.toPx(maxHeight);
    var bottomX = topX.clone();
    var bottomY = Length.percent(100 - bottom2.value).toPx(maxHeight);
    var rightX = Length.percent(100 - right2.value).toPx(maxWidth);
    var rightY = Length.percent(Math.abs((top2.value - (100 - bottom2.value)) / 2)).toPx(maxHeight);
    var leftX = left2.toPx(maxWidth);
    var leftY = Length.percent(Math.abs((top2.value - (100 - bottom2.value)) / 2)).toPx(maxHeight);
    var roundCheckStatus = round2 ? "checked" : "";
    return `
        <div class='clip-path-editor inset-editor'>
            <div class='drag-area' ref='$area'>
                <div class='drag-pointer' data-type='top' ref='$top' style='left: ${topX};top: ${topY};'></div>
                <div class='drag-pointer' data-type='right' ref='$right' style='left: ${rightX};top: ${rightY};'></div>
                <div class='drag-pointer' data-type='bottom' ref='$bottom' style='left: ${bottomX};top: ${bottomY};'></div>
                <div class='drag-pointer' data-type='left' ref='$left' style='left: ${leftX};top: ${leftY};'></div>
                <div class='clip-area inset' ref='$clipAreaView' style='pointer-events: none;'></div>
                <div class='clip-area-handle' ref='$clipArea' style='left: ${leftX};top: ${topY};width: ${Length.px(rightX.value - left2.value)};height: ${Length.px(bottomY.value - topY.value)};'></div>
            </div>
            <div class='round-area'>
                <label><input type="checkbox" ${roundCheckStatus} ref='$hasRound' /> Round </label>
                <div ref='$round'></div>
            </div>
        </div>
    `;
  }
  [BIND("$clipAreaView")]() {
    return {
      style: {
        "clip-path": `${this.props.key}(${this.toClipPathValueString()})`
      }
    };
  }
  [CLICK("$hasRound")](e2) {
    this.updateData({
      round: this.refs.$hasRound.checked()
    });
    this.bindData("$clipAreaView");
  }
  [LOAD("$round")]() {
    var { topRadius, rightRadius, bottomRadius, leftRadius } = this.state;
    var value = [topRadius, rightRadius, bottomRadius, leftRadius].join(" ");
    return `<object refClass="DirectionEditor" ref='$borderRadius' value='${value}' onchange='changeBorderRadius' />`;
  }
  [SUBSCRIBE_SELF("changeBorderRadius")]([_count, topRadius, rightRadius, bottomRadius, leftRadius]) {
    this.updateData({
      isAllRadius: _count === 1,
      topRadius,
      rightRadius,
      bottomRadius,
      leftRadius
    });
    this.bindData("$clipAreaView");
  }
  refreshPointer() {
    var { top: top2, right: right2, bottom: bottom2, left: left2 } = this.state;
    var maxWidth = 220;
    var maxHeight = 220;
    var halfWidth = Math.abs((left2.value + (100 - right2.value)) / 2);
    var halfHeight = Math.abs((top2.value + (100 - bottom2.value)) / 2);
    var topX = Length.percent(halfWidth).toPx(maxWidth);
    var topY = top2.toPx(maxHeight);
    var bottomX = Length.percent(halfWidth).toPx(maxWidth);
    var bottomY = Length.percent(100 - bottom2.value).toPx(maxHeight);
    var rightX = Length.percent(100 - right2.value).toPx(maxWidth);
    var rightY = Length.percent(halfHeight).toPx(maxHeight);
    var leftX = left2.toPx(maxWidth);
    var leftY = Length.percent(halfHeight).toPx(maxHeight);
    this.refs.$top.css({ left: topX, top: topY });
    this.refs.$right.css({ left: rightX, top: rightY });
    this.refs.$bottom.css({ left: bottomX, top: bottomY });
    this.refs.$left.css({ left: leftX, top: leftY });
    this.refs.$clipArea.css({
      left: leftX,
      top: topY,
      width: rightX.value - leftX.value,
      height: bottomY.value - topY.value
    });
    this.bindData("$clipAreaView");
  }
  [POINTERSTART("$area .clip-area-handle") + MOVE("moveClipArea")](e2) {
    this.type = e2.$dt.attr("data-type");
    this.$target = e2.$dt;
    this.areaRect = this.refs.$area.rect();
    this.startXY = e2.xy;
    this.clipRect = {
      left: Length.parse(this.$target.css("left")).value,
      top: Length.parse(this.$target.css("top")).value,
      width: Length.parse(this.$target.css("width")).value,
      height: Length.parse(this.$target.css("height")).value
    };
  }
  moveClipArea(dx, dy) {
    var clipWidth = this.clipRect.width;
    var clipHeight = this.clipRect.height;
    var x2 = this.clipRect.left.value + dx;
    var y2 = this.clipRect.top.value + dy;
    if (0 > x2) {
      x2 = 0;
    } else if (this.areaRect.width < x2 + clipWidth) {
      x2 = this.areaRect.width - clipWidth;
    }
    if (0 > y2) {
      y2 = 0;
    } else if (this.areaRect.height < y2 + clipHeight) {
      y2 = this.areaRect.height - clipHeight;
    }
    var left2 = x2;
    var top2 = y2;
    this.updateData({
      top: Length.px(top2).toPercent(this.areaRect.height).round(100),
      bottom: Length.px(this.areaRect.height - (y2 + clipHeight)).toPercent(this.areaRect.height).round(100),
      right: Length.px(this.areaRect.width - (x2 + clipWidth)).toPercent(this.areaRect.width).round(100),
      left: Length.px(left2).toPercent(this.areaRect.width).round(100)
    });
    this.refreshPointer();
  }
  [POINTERSTART("$area .drag-pointer") + MOVE()](e2) {
    this.type = e2.$dt.attr("data-type");
    this.$target = e2.$dt;
    this.areaRect = this.refs.$area.rect();
    this.startXY = e2.xy;
  }
  move(dx, dy) {
    var x2 = this.startXY.x + dx;
    var y2 = this.startXY.y + dy;
    if (this.areaRect.x > x2) {
      x2 = this.areaRect.x;
    } else if (this.areaRect.right < x2) {
      x2 = this.areaRect.right;
    }
    if (this.areaRect.y > y2) {
      y2 = this.areaRect.y;
    } else if (this.areaRect.bottom < y2) {
      y2 = this.areaRect.bottom;
    }
    var left2 = x2 - this.areaRect.x;
    var top2 = y2 - this.areaRect.y;
    if (this.type === "top") {
      this.updateData({
        top: Length.px(top2).toPercent(this.areaRect.height).round(100)
      });
    } else if (this.type === "bottom") {
      this.updateData({
        bottom: Length.px(this.areaRect.height - top2).toPercent(this.areaRect.height).round(100)
      });
    } else if (this.type === "right") {
      this.updateData({
        right: Length.px(this.areaRect.width - left2).toPercent(this.areaRect.width).round(100)
      });
    } else if (this.type === "left") {
      this.updateData({
        left: Length.px(left2).toPercent(this.areaRect.width).round(100)
      });
    }
    this.refreshPointer();
  }
  toClipPathValueString() {
    var { top: top2, right: right2, left: left2, bottom: bottom2, round: round2, topRadius, leftRadius, bottomRadius, rightRadius } = this.state;
    var position2 = [top2, right2, bottom2, left2].join(" ");
    var radius = [topRadius, rightRadius, bottomRadius, leftRadius].join(" ");
    var results = `${position2} ${round2 && radius.trim() ? `round ${radius}` : ""}`;
    return results;
  }
  updateData(data) {
    this.setState(data, false);
    this.parent.trigger(this.props.onchange, this.props.key, this.toClipPathValueString(), this.props.params);
  }
}
var polygon = {
  key: "polygon",
  title: "Polygon",
  execute: function() {
    return [
      { name: "Triangle", polygon: "50% 0%, 0% 100%, 100% 100%" },
      { name: "Trapezoid", polygon: "20% 0%, 80% 0%, 100% 100%, 0% 100%" },
      {
        name: "Parallelogram",
        polygon: "25% 0%, 100% 0%, 75% 100%, 0% 100%"
      },
      {
        name: "Rhombus",
        polygon: "50% 0%, 100% 50%, 50% 100%, 0% 50%"
      },
      {
        name: "Pentagon",
        polygon: "50% 0%, 100% 38%, 82% 100%, 18% 100%, 0% 38%"
      },
      {
        name: "Hexagon",
        polygon: "50% 0%, 100% 25%, 100% 75%, 50% 100%, 0% 75%, 0% 25%"
      },
      {
        name: "Heptagon",
        polygon: "50% 0%, 90% 20%, 100% 60%, 75% 100%, 25% 100%, 0% 60%, 10% 20%"
      },
      {
        name: "Octagon",
        polygon: "30% 0%, 70% 0%, 100% 30%, 100% 70%, 70% 100%, 30% 100%, 0% 70%, 0% 30%"
      }
    ];
  }
};
class PolygonEditor extends EditorElement {
  parseValue(str = "") {
    return str.split(",").filter((it) => it.trim()).map((it) => {
      var [x2, y2] = it.trim().split(" ");
      return {
        x: Length.parse(x2),
        y: Length.parse(y2)
      };
    });
  }
  initState() {
    return {
      value: this.parseValue(this.props.value)
    };
  }
  template() {
    const polygonList = polygon.execute();
    return `
        <div class='clip-path-editor polygon-editor'>
            ${createComponent("SelectEditor", {
      ref: "$polygonSelect",
      options: ["", ...polygonList.map((it) => it.name)],
      onchange: (key, value) => {
        const polygon2 = polygonList.find((it) => it.name === value);
        if (polygon2) {
          this.updateData({ value: this.parseValue(polygon2.polygon) });
          this.refresh();
        }
      }
    })}
            <div class='drag-area' ref='$area'>
                <div class='pointer-list' ref='$list'></div>
                <div class='clip-area polygon' ref='$clipArea'></div>            
            </div>
        </div>
    `;
  }
  [CLICK("$area") + PREVENT](e2) {
    if (Dom.create(e2.target).is(this.refs.$area)) {
      this.areaRect = this.refs.$area.rect();
      var { x: x2, y: y2 } = e2.xy;
      this.appendValue({
        x: Length.px(x2 - this.areaRect.left).toPercent(this.areaRect.width),
        y: Length.px(y2 - this.areaRect.top).toPercent(this.areaRect.height)
      });
      this.refresh();
    }
  }
  [BIND("$clipArea")]() {
    return {
      style: {
        "clip-path": `polygon(${this.toClipPathValueString()})`
      }
    };
  }
  [LOAD("$list")]() {
    return this.state.value.map((it, index2) => {
      var className = [
        index2 === 0 ? "first" : "",
        index2 === this.state.value.length - 1 ? "last" : ""
      ].filter((it2) => it2).join(" ");
      return `<div class='drag-pointer ${className}' data-index="${index2.toString()}" style='left: ${it.x};top: ${it.y};'></div>`;
    });
  }
  [CLICK("$area .drag-pointer") + ALT + PREVENT](e2) {
    var index2 = +e2.$dt.attr("data-index");
    this.removeValue(index2);
    this.refresh();
  }
  [CLICK("$area .drag-pointer") + SHIFT + PREVENT](e2) {
    var index2 = +e2.$dt.attr("data-index");
    this.copyValue(index2);
    this.refresh();
  }
  [POINTERSTART("$area .drag-pointer") + MOVE()](e2) {
    this.selectedIndex = +e2.$dt.attr("data-index");
    this.$target = e2.$dt;
    this.areaRect = this.refs.$area.rect();
    this.startXY = e2.xy;
    this.$value = this.state.value[this.selectedIndex];
  }
  move(dx, dy) {
    var x2 = this.startXY.x + dx;
    var y2 = this.startXY.y + dy;
    if (this.areaRect.x > x2) {
      x2 = this.areaRect.x;
    } else if (this.areaRect.right < x2) {
      x2 = this.areaRect.right;
    }
    if (this.areaRect.y > y2) {
      y2 = this.areaRect.y;
    } else if (this.areaRect.bottom < y2) {
      y2 = this.areaRect.bottom;
    }
    var left2 = Length.percent((x2 - this.areaRect.x) / this.areaRect.width * 100);
    var top2 = Length.percent((y2 - this.areaRect.y) / this.areaRect.height * 100);
    this.$target.css({
      left: left2,
      top: top2
    });
    this.updateValue(this.selectedIndex, {
      x: left2,
      y: top2
    });
    this.bindData("$clipArea");
  }
  toClipPathValueString() {
    return this.state.value.map((it) => {
      return `${it.x.round(10)} ${it.y.round(10)}`;
    }).join(",");
  }
  updateData(data) {
    this.setState(data, false);
    this.parent.trigger(this.props.onchange, this.props.key, this.toClipPathValueString(), this.props.params);
  }
  appendValue(data) {
    this.state.value.push(data);
    this.parent.trigger(this.props.onchange, this.props.key, this.toClipPathValueString(), this.props.params);
  }
  removeValue(index2) {
    this.state.value.splice(index2, 1);
    this.parent.trigger(this.props.onchange, this.props.key, this.toClipPathValueString(), this.props.params);
  }
  copyValue(index2) {
    var { x: x2, y: y2 } = this.state.value[index2];
    this.state.value.splice(index2 + 1, 0, {
      x: x2.clone().add(0.1),
      y: y2.clone().add(0.1)
    });
    this.parent.trigger(this.props.onchange, this.props.key, this.toClipPathValueString(), this.props.params);
  }
  updateValue(index2, data) {
    this.state.value[index2] = __spreadValues(__spreadValues({}, this.state.value[index2]), data);
    this.parent.trigger(this.props.onchange, this.props.key, this.toClipPathValueString(), this.props.params);
  }
}
class EllipseEditor extends EditorElement {
  parseValue(str = "50% 50%") {
    var radius = `50% 50%`, position2 = "";
    str = str || "50%";
    if (str.includes("at")) {
      [radius, position2] = str.split("at").map((it) => it.trim());
    } else {
      position2 = str.trim();
    }
    var [x2, y2] = position2.split(" ");
    if (isUndefined(y2)) {
      y2 = x2;
    }
    x2 = Length.parse(x2);
    y2 = Length.parse(y2);
    var [radiusX, radiusY] = radius.split(" ");
    if (isUndefined(radiusY)) {
      radiusY = radiusX;
    }
    radiusX = Length.parse(radiusX);
    radiusY = Length.parse(radiusY);
    return {
      radiusX,
      radiusY,
      x: x2,
      y: y2
    };
  }
  initState() {
    return this.parseValue(this.props.value);
  }
  template() {
    return `
        <div class='clip-path-editor circle-editor'>
            <div>
                ${createComponent("InputRangeEditor", {
      ref: "$rangeX",
      label: "Radius X",
      key: "radiusX",
      value: this.state.radiusX,
      min: 0,
      max: 100,
      step: 0.1,
      units: ["%"],
      onchange: "changeRangeEditor"
    })}
            </div>
            <div>
            ${createComponent("InputRangeEditor", {
      ref: "$rangeY",
      label: "Radius Y",
      key: "radiusY",
      value: this.state.radiusY,
      min: 0,
      max: 100,
      step: 0.1,
      units: ["%"],
      onchange: "changeRangeEditor"
    })}            
            </div>            
            <div class='drag-area' ref='$area'>
                <div class='drag-pointer' ref='$pointer' style='left: ${this.state.x};top: ${this.state.y};'></div>
                <div class='clip-area circle' ref='$clipArea'></div>
            </div>
        </div>
    `;
  }
  [BIND("$clipArea")]() {
    return {
      style: {
        "clip-path": `${this.props.key}(${this.toClipPathValueString()})`
      }
    };
  }
  [POINTERSTART("$area") + MOVE() + END()](e2) {
    this.areaRect = this.refs.$area.rect();
    this.startXY = e2.xy;
  }
  move(dx, dy) {
    var x2 = this.startXY.x + dx;
    var y2 = this.startXY.y + dy;
    if (this.areaRect.x > x2) {
      x2 = this.areaRect.x;
    } else if (this.areaRect.right < x2) {
      x2 = this.areaRect.right;
    }
    if (this.areaRect.y > y2) {
      y2 = this.areaRect.y;
    } else if (this.areaRect.bottom < y2) {
      y2 = this.areaRect.bottom;
    }
    var left2 = Length.percent((x2 - this.areaRect.x) / this.areaRect.width * 100).round(1);
    var top2 = Length.percent((y2 - this.areaRect.y) / this.areaRect.height * 100).round(1);
    this.refs.$pointer.css({
      left: left2,
      top: top2
    });
    this.updateData({
      x: left2,
      y: top2
    });
    this.bindData("$clipArea");
  }
  toClipPathValueString() {
    var { x: x2, y: y2, radiusX, radiusY } = this.state;
    var results = `${x2} ${y2}`;
    var radiusString = `${radiusX} ${radiusY}`;
    return `${radiusString} at ${results}`;
  }
  updateData(data) {
    this.setState(data);
    this.parent.trigger(this.props.onchange, this.props.key, this.toClipPathValueString(), this.props.params);
  }
  [SUBSCRIBE_SELF("changeRangeEditor")](key, value) {
    this.updateData({
      [key]: value.clone()
    });
  }
}
var ClipPathPopup$1 = "";
class ClipPathPopup extends BasePopup {
  components() {
    return {
      CircleEditor,
      InsetEditor,
      PolygonEditor,
      EllipseEditor
    };
  }
  getTitle() {
    return "ClipPath";
  }
  initState() {
    return {
      type: "none",
      value: ""
    };
  }
  toClipPathCSS() {
    return ClipPath.toCSS(this.state);
  }
  updateData(opt) {
    this.setState(opt, false);
    this.emit(this.state.changeEvent || "changeClipPathPopup", this.toClipPathCSS());
  }
  getBody() {
    return `
    <div class='elf--clippath-popup' ref='$popup'>
      <div class="box">
        <div class='clip-path-editor clip-path-type' ref='$clippathType'></div>
        <div class='clip-path-editor' ref='$clippath'></div>
      </div>
    </div>`;
  }
  [LOAD("$clippathType")]() {
    return `
      <div>${this.state.type} Editor</div>
    `;
  }
  [LOAD("$clippath")]() {
    switch (this.state.type) {
      case "circle":
        return `<object refClass="CircleEditor" ref='$circle' key='circle' value='${this.state.value}' onchange='changeClipPath' />`;
      case "ellipse":
        return `<object refClass="EllipseEditor" ref='$ellipse' key='ellipse' value='${this.state.value}' onchange='changeClipPath' />`;
      case "inset":
        return `<object refClass="InsetEditor" ref='$inset' key='inset' value='${this.state.value}' onchange='changeClipPath' />`;
      case "polygon":
        return `<object refClass="PolygonEditor" ref='$polygon' key='polygon' value='${this.state.value}' onchange='changeClipPath' />`;
      case "path":
        return `<object refClass="PathEditor" ref='$path' key='path' value='${this.state.value}' onchange='changeClipPath' />`;
      case "svg":
        var current = this.$selection.currentProject || { svg: [] };
        var options2 = current.svg.filter((it) => it.type === "clip-path").map((it) => it.name).join(",");
        if (options2.length) {
          options2 = "," + options2;
        }
        return `<object refClass="SelectEditor"  ref='$svg' key='svg' value='${this.state.value}' options='${options2}' onchange='changeClipPath' />`;
      default:
        return `<div class='type none'></div>`;
    }
  }
  [SUBSCRIBE_SELF("changeClipPath")](type, value) {
    this.updateData({
      type,
      value
    });
  }
  [SUBSCRIBE("showClipPathPopup")](data) {
    this.state.changeEvent = data.changeEvent;
    this.setState(ClipPath.parseStyle(data["clip-path"]));
    this.refresh();
    this.show(220);
  }
  [SUBSCRIBE("hideClipPathPopup")]() {
    this.hide();
  }
}
var ClipPathProperty$1 = "";
class ClipPathProperty extends BaseProperty {
  getTitle() {
    return this.$i18n("clippath.property.title");
  }
  hasKeyframe() {
    return true;
  }
  getKeyframeProperty() {
    return "clip-path";
  }
  getClassName() {
    return "clip-path-property";
  }
  getBody() {
    return `<div class='elf--clip-path-list' ref='$clippathList'></div>`;
  }
  getTools() {
    return `
      <div ref="$tools" class="add-tools">
        <button type="button" data-value='circle' data-tooltip="Circle">${iconUse$1("outline_circle")}</button>
        <button type="button" data-value='ellipse' data-tooltip="Ellipse">${iconUse$1("outline_circle", "scale(1 0.7) translate(0 5)")}</button>
        <button type="button" data-value='inset' data-tooltip="Inset">${iconUse$1("outline_rect")}</button>
        <button type="button" data-value='polygon' data-tooltip="Polygon">${iconUse$1("polygon")}</button>
        <button type="button" data-value='path' data-tooltip="Path">${iconUse$1("pentool")}</button>
        <button type="button" data-value='svg' data-tooltip="SVG">${iconUse$1("image")}</button>
      </div>
    `;
  }
  makeClipPathTemplate(clippath, func2) {
    const isPath = clippath === "path";
    let newPathString = "";
    if (isPath) {
      const pathString2 = func2.split("(")[1].split(")")[0];
      let pathObject = PathParser.fromSVGString(pathString2);
      const bbox = pathObject.getBBox();
      const rectangle = vertiesToRectangle(bbox);
      const rate = 260 / rectangle.width;
      const hRate = 150 / rectangle.height;
      const lastRate = Math.min(rate, hRate);
      pathObject = pathObject.translate(-bbox[0][0], -bbox[0][1]).scale(lastRate, lastRate);
      const newBBox = pathObject.getBBox();
      const newRectangle = vertiesToRectangle(newBBox);
      newPathString = pathObject.translate(260 / 2 - newRectangle.width / 2, 0).d;
    }
    return `
      <div>
        <div class='clippath-item'>
          <label>${iconUse$1("drag_indicator")}</label>
          <div class='title'>
            <div class='name'>${clippath}</div>
          </div>
          <div class='tools'>
            <button type="button" class="del">${obj.remove2}</button>
          </div>        
        </div>
        ${isPath ? `<svg><path d="${newPathString}" fill="transparent" stroke="currentColor" /></svg>` : ""}
      </div>

    `;
  }
  [CLICK("$clippathList .clippath-item .title")](e2) {
    var current = this.$selection.current;
    if (!current)
      return;
    this.viewClipPathPicker();
  }
  [CLICK("$clippathList .del") + PREVENT](e2) {
    var current = this.$selection.current;
    if (!current)
      return;
    this.command("setAttributeForMulti", "delete clip-path", this.$selection.packByValue({
      "clip-path": ""
    }));
    this.emit("hideClipPathPopup");
    setTimeout(() => {
      this.refresh();
    }, 100);
  }
  get editableProperty() {
    return "clip-path";
  }
  [SUBSCRIBE("refreshSelection") + IF("checkShow")]() {
    this.refresh();
  }
  [LOAD("$clippathList")]() {
    var current = this.$selection.current;
    if (!current)
      return "";
    if (!current["clip-path"])
      return "";
    return this.makeClipPathTemplate(current["clip-path"].split("(")[0], current["clip-path"]);
  }
  [CLICK("$tools [data-value]")](e2) {
    var current = this.$selection.current;
    if (!current)
      return;
    if (current["clip-path"]) {
      alert("clip-path is already exists.");
      return;
    }
    if (current) {
      current.reset({
        "clip-path": e2.$dt.data("value")
      });
      this.command("setAttributeForMulti", "change clip-path", this.$selection.pack("clip-path"));
    }
    this.refresh();
  }
  viewClipPathPicker() {
    var current = this.$selection.current;
    if (!current)
      return;
    var obj2 = ClipPath.parseStyle(current["clip-path"]);
    switch (obj2.type) {
      case "path":
        var d = current.absolutePath(current.clipPathString).d;
        var mode = d ? "modify" : "path";
        this.emit("showPathEditor", mode, {
          changeEvent: (data) => {
            data.d = current.invertPath(data.d).d;
            this.updatePathInfo({
              "clip-path": `path(${data.d})`
            });
          },
          current,
          d
        });
        break;
      case "svg":
        break;
      default:
        this.emit("showClipPathPopup", {
          "clip-path": current["clip-path"],
          changeEvent: (data) => {
            this.updatePathInfo(data);
          }
        });
        break;
    }
  }
  updatePathInfo(data) {
    if (!data)
      return;
    var current = this.$selection.current;
    if (!current)
      return;
    current.reset(data);
    this.refresh();
    this.command("setAttributeForMulti", "change clip-path", this.$selection.packByValue(data));
  }
}
function clipPath(editor) {
  editor.registerMenuItem("inspector.tab.style", {
    ClipPathProperty
  });
  editor.registerMenuItem("popup", {
    ClipPathPopup
  });
}
var CodeViewProperty$1 = "";
class CodeViewProperty extends BaseProperty {
  initialize() {
    super.initialize();
    this.notEventRedefine = true;
  }
  getTitle() {
    return this.$i18n("code.view.property.title");
  }
  checkConfig() {
    return this.$config.is("inspector.selectedValue", "code");
  }
  [CONFIG("inspector.selectedValue")]() {
    this.refresh();
  }
  [SUBSCRIBE("refreshSelectionStyleView", "refreshSelection") + IF("checkConfig") + DEBOUNCE(100)]() {
    this.refresh();
  }
  getBody() {
    return `
      <div class="property-item elf--code-view-item" ref='$body'>
        <div class="elf--code-view-item-code" ref='$code'></div>
        <div class="elf--code-view-item-svg" ref='$svg'></div>
      </div>
    `;
  }
  [LOAD("$code") + DOMDIFF]() {
    return [
      this.$editor.html.codeview(this.$selection.current)
    ];
  }
  [LOAD("$svg") + DOMDIFF]() {
    return [
      this.$editor.svg.codeview(this.$selection.current)
    ];
  }
}
function codeview(editor) {
  editor.registerMenuItem("inspector.tab.code", {
    CodeViewProperty
  });
}
class Hue extends EditorElement {
  initState() {
    return {
      hue: 0,
      minValue: 0,
      maxValue: 360
    };
  }
  template() {
    return `
            <div class="hue">
                <div ref="$container" class="hue-container">
                    <div ref="$bar" class="drag-bar"></div>
                </div>
            </div>
        `;
  }
  [BIND("$bar")]() {
    const hue = this.state.hue;
    return {
      style: {
        left: Length.percent(hue / 360 * 100)
      },
      class: {
        first: hue <= this.state.minValue,
        last: hue >= this.state.maxValue
      }
    };
  }
  [POINTERSTART("$container") + MOVE("movePointer") + END("moveEndPointer")](e2) {
    this.rect = this.refs.$container.rect();
    this.refreshColorUI();
  }
  movePointer() {
    this.refreshColorUI();
  }
  refreshColorUI() {
    const minX = this.rect.left;
    const maxX = this.rect.right;
    const currentX = Math.max(Math.min(maxX, this.$config.get("bodyEvent").clientX), minX);
    const rate = (currentX - minX) / (maxX - minX);
    this.parent.changeColor({
      h: rate * this.state.maxValue,
      type: "hsv"
    });
  }
  setValue(hue) {
    this.setState({
      hue
    });
  }
}
class Opacity extends EditorElement {
  initState() {
    return {
      colorbar: Color.parse("rgba(0, 0, 0, 1)"),
      opacity: 0,
      minValue: 0,
      maxValue: 100
    };
  }
  template() {
    return `
        <div class="opacity">
            <div ref="$container" class="opacity-container">
                <div ref="$colorbar" class="color-bar"></div>
                <div ref="$bar" class="drag-bar2"></div>
            </div>
        </div>
        `;
  }
  [BIND("$colorbar")]() {
    const rgb2 = clone$1(this.state.colorbar);
    rgb2.a = 0;
    const start2 = Color.format(rgb2, "rgb");
    rgb2.a = 1;
    const end2 = Color.format(rgb2, "rgb");
    return {
      style: {
        background: `linear-gradient(to right, ${start2}, ${end2})`
      }
    };
  }
  [BIND("$bar")]() {
    const opacity2 = this.state.opacity * 100;
    return {
      style: {
        left: Length.percent(opacity2)
      },
      class: {
        first: opacity2 <= this.state.minValue,
        last: opacity2 >= this.state.maxValue
      }
    };
  }
  [POINTERSTART("$container") + MOVE("movePointer") + END("moveEndPointer")](e2) {
    this.rect = this.refs.$container.rect();
    this.refreshColorUI();
  }
  movePointer() {
    this.refreshColorUI();
  }
  refreshColorUI() {
    const minX = this.rect.left;
    const maxX = this.rect.right;
    const currentX = Math.max(Math.min(maxX, this.$config.get("bodyEvent").clientX), minX);
    const rate = (currentX - minX) / (maxX - minX);
    this.parent.changeColor({
      a: rate.toFixed(2)
    });
  }
  setValue(colorbar, opacity2) {
    this.setState({
      opacity: opacity2,
      colorbar
    });
  }
}
class ColorView extends EditorElement {
  initState() {
    return {
      value: "rgba(0, 0, 0, 1)"
    };
  }
  template() {
    return `<div class='color'></div>`;
  }
  [BIND("$el")]() {
    return {
      style: {
        "background-color": this.state.value
      }
    };
  }
  setValue(value) {
    this.setState({
      value
    });
  }
}
class ColorInformation extends EditorElement {
  template() {
    return `
        <div class="information hex">
            <div ref="$informationChange" class="information-change">
                <button ref="$formatChangeButton" type="button" class="format-change-button">
                    ${iconUse$1("unfold")}
                </button>
            </div>
            <div class="information-item hex">
                <div class="input-field hex">
                    <input ref="$hexCode" class="input" type="text" />
                    <div class="title">HEX</div>
                </div>
            </div>
            <div class="information-item rgb">
                <div class="input-field rgb-r">
                    <input ref="$rgb_r" class="input" type="number" step="1" min="0" max="255" />
                    <div class="title">R</div>
                </div>
                <div class="input-field rgb-g">
                    <input ref="$rgb_g" class="input" type="number" step="1" min="0" max="255" />
                    <div class="title">G</div>
                </div>
                <div class="input-field rgb-b">
                    <input ref="$rgb_b" class="input" type="number" step="1" min="0" max="255" />
                    <div class="title">B</div>
                </div>          
                <div class="input-field rgb-a">
                    <input ref="$rgb_a" class="input" type="number" step="0.01" min="0" max="1" />
                    <div class="title">A</div>
                </div>                                                            
            </div>
            <div class="information-item hsl">
                <div class="input-field hsl-h">
                    <input ref="$hsl_h" class="input" type="number" step="1" min="0" max="360" />
                    <div class="title">H</div>
                </div>
                <div class="input-field hsl-s">
                    <input ref="$hsl_s" class="input" type="number" step="1" min="0" max="100" />
                    <div class="postfix">%</div>
                    <div class="title">S</div>
                </div>
                <div class="input-field hsl-l">
                    <input ref="$hsl_l" class="input" type="number" step="1" min="0" max="100" />
                    <div class="postfix">%</div>                        
                    <div class="title">L</div>
                </div>
                <div class="input-field hsl-a">
                    <input ref="$hsl_a" class="input" type="number" step="0.01" min="0" max="1" />
                    <div class="title">A</div>
                </div>
            </div>
        </div>
        `;
  }
  get manager() {
    return this.parent.manager;
  }
  setCurrentFormat(format2) {
    this.format = format2;
    this.initFormat();
  }
  initFormat() {
    var current_format = this.format || "hex";
    ["hex", "rgb", "hsl"].filter((it) => it !== current_format).forEach((formatString) => {
      this.$el.removeClass(formatString);
    });
    this.$el.addClass(current_format);
  }
  nextFormat() {
    var current_format = this.format || "hex";
    var next_format = "hex";
    if (current_format == "hex") {
      next_format = "rgb";
    } else if (current_format == "rgb") {
      next_format = "hsl";
    } else if (current_format == "hsl") {
      if (this.parent.alpha == 1) {
        next_format = "hex";
      } else {
        next_format = "rgb";
      }
    }
    this.format = next_format;
    this.initFormat();
    this.parent.changeFormat(this.format);
  }
  goToFormat(to_format) {
    this.format = to_format;
    if (to_format === "rgb" || to_format === "hsl") {
      this.initFormat();
    }
    this.parent.changeFormat(this.format);
  }
  getFormat() {
    return this.format || "hex";
  }
  changeRgbColor() {
    this.parent.lastUpdateColor({
      type: "rgb",
      r: this.refs.$rgb_r.int(),
      g: this.refs.$rgb_g.int(),
      b: this.refs.$rgb_b.int(),
      a: this.refs.$rgb_a.float()
    });
  }
  changeHslColor() {
    this.parent.lastUpdateColor({
      type: "hsl",
      h: this.refs.$hsl_h.int(),
      s: this.refs.$hsl_s.int(),
      l: this.refs.$hsl_l.int(),
      a: this.refs.$hsl_a.float()
    });
  }
  hasValue(e2) {
    if (e2.target.value === "") {
      return false;
    }
    return true;
  }
  [INPUT("$rgb_r") + IF("hasValue")](e2) {
    this.changeRgbColor();
  }
  [INPUT("$rgb_g") + IF("hasValue")](e2) {
    this.changeRgbColor();
  }
  [INPUT("$rgb_b") + IF("hasValue")](e2) {
    this.changeRgbColor();
  }
  [INPUT("$rgb_a") + IF("hasValue")](e2) {
    this.changeRgbColor();
  }
  [INPUT("$hsl_h") + IF("hasValue")](e2) {
    this.changeHslColor();
  }
  [INPUT("$hsl_s") + IF("hasValue")](e2) {
    this.changeHslColor();
  }
  [INPUT("$hsl_l") + IF("hasValue")](e2) {
    this.changeHslColor();
  }
  [INPUT("$hsl_a") + IF("hasValue")](e2) {
    this.changeHslColor();
  }
  [KEYUP("$hexCode") + IF("hasValue")](e2) {
    var code2 = this.refs.$hexCode.val();
    if (code2.charAt(0) == "#" && (code2.length == 7 || code2.length === 9)) {
      this.parent.lastUpdateColor(code2);
    }
  }
  [PASTE("$hexCode") + IF("hasValue")](e2) {
    var code2 = this.refs.$hexCode.val();
    if (code2.charAt(0) == "#" && (code2.length == 7 || code2.length === 9)) {
      this.parent.lastUpdateColor(code2);
    }
  }
  [CLICK("$formatChangeButton")](e2) {
    this.nextFormat();
  }
  [CLICK("$el .information-item.hex .input-field .title")](e2) {
    this.goToFormat("hex");
  }
  [CLICK("$el .information-item.rgb .input-field .title")](e2) {
    this.goToFormat("hsl");
  }
  [CLICK("$el .information-item.hsl .input-field .title")](e2) {
    this.goToFormat("rgb");
  }
  setRGBInput() {
    this.refs.$rgb_r.val(this.manager.rgb.r);
    this.refs.$rgb_g.val(this.manager.rgb.g);
    this.refs.$rgb_b.val(this.manager.rgb.b);
    this.refs.$rgb_a.val(this.manager.alpha);
  }
  setHSLInput() {
    this.refs.$hsl_h.val(this.manager.hsl.h);
    this.refs.$hsl_s.val(this.manager.hsl.s);
    this.refs.$hsl_l.val(this.manager.hsl.l);
    this.refs.$hsl_a.val(this.manager.alpha);
  }
  setHexInput() {
    this.refs.$hexCode.val(this.manager.toString("hex"));
  }
  setValue() {
    this.refresh();
  }
  refresh() {
    this.setCurrentFormat(this.manager.format);
    this.setRGBInput();
    this.setHSLInput();
    this.setHexInput();
  }
}
class ColorPalette extends EditorElement {
  initState() {
    return {
      hueColor: "rgba(0, 0, 0, 1)",
      s: 0,
      v: 0
    };
  }
  template() {
    return `
        <div class="color-panel">
            <div ref="$saturation" class="saturation">
                <div ref="$value" class="value">
                    <div ref="$drag_pointer" class="drag-pointer"></div>
                </div>
            </div>        
        </div>        
        `;
  }
  afterRender() {
    this.rect = this.$el.rect();
  }
  [BIND("$el")]() {
    return {
      style: {
        "background-color": this.state.hueColor
      }
    };
  }
  [BIND("$drag_pointer")]() {
    if (this.rect.width === 0) {
      this.rect = this.$el.rect();
    }
    const x2 = this.rect.width * this.state.s;
    const y2 = this.rect.height * (1 - this.state.v);
    return {
      style: {
        left: x2,
        top: y2
      }
    };
  }
  [POINTERSTART("$el") + MOVE("movePointer") + END("moveEndPointer")](e2) {
    this.rect = this.$el.rect();
    this.refreshColorUI();
  }
  movePointer() {
    this.refreshColorUI();
  }
  moveEndPointer() {
    this.parent.changeEndColor();
  }
  refreshColorUI() {
    const e2 = this.$config.get("bodyEvent");
    const minX = this.rect.left;
    const maxX = this.rect.right;
    const minY = this.rect.top;
    const maxY = this.rect.bottom;
    const currentX = Math.min(maxX, Math.max(minX, e2.clientX));
    const currentY = Math.min(maxY, Math.max(minY, e2.clientY));
    const width2 = maxX - minX;
    const height2 = maxY - minY;
    var s = (currentX - minX) / width2;
    var v = (height2 - (currentY - minY)) / height2;
    this.parent.changeColor({
      type: "hsv",
      s,
      v
    });
  }
  setValue(s, v, hueColor) {
    this.setState({
      s,
      v,
      hueColor
    });
  }
}
const hue_color = [
  { rgb: "#ff0000", start: 0 },
  { rgb: "#ffff00", start: 0.17 },
  { rgb: "#00ff00", start: 0.33 },
  { rgb: "#00ffff", start: 0.5 },
  { rgb: "#0000ff", start: 0.67 },
  { rgb: "#ff00ff", start: 0.83 },
  { rgb: "#ff0000", start: 1 }
];
function checkHueColor(p) {
  var startColor, endColor;
  for (var i = 0; i < hue_color.length; i++) {
    if (hue_color[i].start >= p) {
      startColor = hue_color[i - 1];
      endColor = hue_color[i];
      break;
    }
  }
  if (startColor && endColor) {
    return Color.mix(startColor, endColor, (p - startColor.start) / (endColor.start - startColor.start));
  }
  return hue_color[0].rgb;
}
function initHueColors() {
  for (var i = 0, len2 = hue_color.length; i < len2; i++) {
    var hue = hue_color[i];
    var obj2 = Color.parse(hue.rgb);
    hue.r = obj2.r;
    hue.g = obj2.g;
    hue.b = obj2.b;
  }
}
initHueColors();
var HueColor = {
  colors: hue_color,
  checkHueColor
};
class ColorManagerV2 {
  constructor() {
    this.initialize();
  }
  initialize() {
    this.state = {
      rgb: {},
      hsl: {},
      hsv: {},
      alpha: 1,
      format: "hex"
    };
  }
  get hsv() {
    return this.state.hsv;
  }
  get rgb() {
    return this.state.rgb;
  }
  get hsl() {
    return this.state.hsl;
  }
  get hex() {
    return this.state.hex;
  }
  get alpha() {
    if (typeof this.state.alpha === "undefined")
      return 1;
    return this.state.alpha;
  }
  get format() {
    return this.state.format;
  }
  changeFormat(format2) {
    this.state.format = format2;
  }
  initColor(colorObj) {
    this.changeColor(colorObj);
  }
  changeColor(colorObj) {
    colorObj = colorObj || "#FF0000";
    if (typeof colorObj === "string") {
      colorObj = Color.parse(colorObj);
    }
    this.state.alpha = typeof colorObj.a !== "undefined" ? colorObj.a : this.state.alpha;
    this.state.format = colorObj.type != "hsv" ? colorObj.type || this.state.format : this.state.format;
    if (colorObj.type == "hsl") {
      this.state.hsl = __spreadValues(__spreadValues({}, this.state.hsl), colorObj);
      this.state.rgb = Color.HSLtoRGB(this.state.hsl);
      this.state.hsv = Color.HSLtoHSV(colorObj);
    } else if (colorObj.type == "hex") {
      this.state.rgb = __spreadValues(__spreadValues({}, this.state.rgb), colorObj);
      this.state.hsl = Color.RGBtoHSL(this.state.rgb);
      this.state.hsv = Color.RGBtoHSV(colorObj);
    } else if (colorObj.type == "rgb") {
      this.state.rgb = __spreadValues(__spreadValues({}, this.state.rgb), colorObj);
      this.state.hsl = Color.RGBtoHSL(this.state.rgb);
      this.state.hsv = Color.RGBtoHSV(colorObj);
    } else if (colorObj.type == "hsv") {
      this.state.hsv = __spreadValues(__spreadValues({}, this.state.hsv), colorObj);
      this.state.rgb = Color.HSVtoRGB(this.state.hsv);
      this.state.hsl = Color.HSVtoHSL(this.state.hsv);
    }
  }
  getHueColor() {
    return HueColor.checkHueColor(this.state.hsv.h / 360);
  }
  toString(type) {
    type = type || this.state.format;
    var colorObj = this.state[type] || this.state.rgb;
    return Color.format(__spreadProps(__spreadValues({}, colorObj), { a: this.state.alpha }), type);
  }
  toColor(type) {
    type = (type || this.state.format).toLowerCase();
    return this.toString(type);
  }
}
class ColorPickerEditor extends EditorElement {
  created() {
    this.manager = new ColorManagerV2();
  }
  initState() {
    const value = this.props.value || "rgba(0, 0, 0, 1)";
    this.manager.initColor(value);
    return {
      key: this.props.key,
      value: this.manager.toString()
    };
  }
  updateData(opt = {}) {
    this.setState(opt, false);
    this.modifyColorPicker();
  }
  modifyColorPicker() {
    this.parent.trigger(this.props.onchange, this.props.key, this.state.value, this.props.params);
  }
  initColor(newColor, format2) {
    this.manager.changeColor(newColor, format2);
    this.refresh();
  }
  changeColor(newColor, format2) {
    this.manager.changeColor(newColor, format2);
    this.refresh();
    this.updateData({
      value: this.manager.toColor()
    });
  }
  [SUBSCRIBE_SELF("selectColorAssets")](key, color2) {
    this.lastUpdateColor(color2);
  }
  changeFormat(format2) {
    this.manager.changeFormat(format2);
    this.setState({
      value: this.manager.toColor()
    }, false);
    this.modifyColorPicker();
    this.changeEndColor();
  }
  lastUpdateColor(newColor, format2) {
    this.manager.changeColor(newColor, format2);
    this.refresh();
    this.setState({
      value: this.manager.toColor()
    }, false);
    this.modifyColorPicker();
    this.changeEndColor();
  }
  changeEndColor() {
    this.parent.trigger(this.props.onchangeend, this.props.key, this.state.value, this.props.params);
  }
  refresh() {
    const color2 = this.manager.toColor();
    this.children.$palette.setValue(this.manager.hsv.s, this.manager.hsv.v, this.manager.getHueColor());
    this.children.$opacity.setValue(this.manager.rgb, this.manager.alpha);
    this.children.$hue.setValue(this.manager.hsv.h);
    this.children.$colorview.setValue(color2);
    this.children.$information.setValue();
  }
  components() {
    return {
      Hue,
      Opacity,
      ColorView,
      Palette: ColorPalette,
      ColorInformation
    };
  }
  template() {
    return `
        <div class='colorpicker sketch inline'>
            <div class='colorpicker-body'>
                <object refClass="Palette" ref='$palette' />
                <div class="control">
                    <object refClass="Hue" ref='$hue' />
                    <object refClass="Opacity" ref='$opacity' />
                    <div class="empty"></div>
                    <object refClass="ColorView" ref='$colorview' />
                </div>
                <object refClass="ColorInformation" ref='$information' />
                <object refClass="ColorAssetsEditor" ref='$colorAsset' key="colorAssets" onchange="selectColorAssets" /> 
            </div>
        </div>
      `;
  }
}
var ColorPickerPopup$1 = "";
class ColorPickerPopup extends BasePopup {
  getTitle() {
    return this.$i18n("colorpicker.popup.title");
  }
  getClassName() {
    return "compact elf--colorpicker-popup";
  }
  initState() {
    return {
      color: "rgba(0, 0, 0, 1)"
    };
  }
  updateData(opt = {}) {
    this.setState(opt, false);
    if (this.state.target) {
      this.state.target.trigger(this.state.changeEvent, this.state.color, this.params);
    }
  }
  updateEndData(opt = {}) {
    this.setState(opt, false);
    if (this.state.target) {
      this.state.target.trigger(this.state.changeEndEvent, this.state.color, this.params);
    }
  }
  getBody() {
    return `
    <div>
      <div class='box'>
        <object 
          refClass="EmbedColorPicker" 
          ref='$color' 
          value='${this.state.color}' 
          onchange=${this.subscribe((color2) => this.updateData({ color: color2 }))} 
          onchangeend=${this.subscribe((color2) => this.updateEndData({ color: color2 }))} />
      </div>
    </div>
  `;
  }
  [LOAD("$projectColors")]() {
    var project2 = this.$selection.currentProject || { colors: [] };
    var colors2 = project2.colors;
    return colors2.map((color2) => {
      return `
      <div class='color-item' title='${color2.name}'>
        <div class='color-view' data-color='${color2.color}' style='background-color: ${color2.color}'></div>
      </div>`;
    });
  }
  [CLICK("$projectColors .color-view")](e2) {
    this.updateData({
      color: e2.$dt.attr("data-color")
    });
    this.children.$color.setValue(this.state.color);
  }
  [SUBSCRIBE("showColorPickerPopup")](data, params, rect2) {
    data.changeEvent = data.changeEvent || "changeFillPopup";
    if (!(data.target instanceof UIElement)) {
      throw new Error("ColorPicker needs data.target");
    }
    this.params = params;
    this.setState(data, false);
    this.children.$color.setValue(this.state.color);
    this.showByRect(this.makeRect(245, 500, rect2));
  }
  [SUBSCRIBE("hideColorPickerPopup")]() {
    this.hide();
  }
}
class EmbedColorPicker extends EditorElement {
  initState() {
    return {
      value: this.props.value || "rgba(0, 0, 0, 1)"
    };
  }
  template() {
    return `
        <div class='embed-color-picker'>
          <object refClass="ColorPickerEditor" 
            ref='$colorpicker' 
            key="colorpicker" 
            value="${this.state.value}" 
            onchange='localChangeColor' 
            onchangeend='localLastUpdate' 
          />        
        </div>
      `;
  }
  [SUBSCRIBE_SELF("localChangeColor")](key, color2) {
    this.parent.trigger(this.props.onchange, color2);
  }
  [SUBSCRIBE_SELF("localLastUpdate")](key, color2) {
    this.parent.trigger(this.props.onchangeend, color2);
  }
  setValue(color2) {
    this.state.value = color2;
    this.children.$colorpicker.initColor(color2);
  }
  refresh() {
    this.children.$colorpicker.initColor(this.props.value);
  }
}
function color(editor) {
  editor.registerElement({
    ColorPickerEditor,
    EmbedColorPicker
  });
  editor.registerMenuItem("popup", {
    ColorPickerPopup
  });
}
var ComponentProperty$1 = "";
class ComponentProperty extends BaseProperty {
  getClassName() {
    return "component-property";
  }
  getTitle() {
    return "Component";
  }
  isShow() {
    var current = this.$selection.current;
    const inspector = this.$editor.components.createInspector(current);
    if (current && (current.is("component") || inspector.length > 0)) {
      return true;
    }
    return false;
  }
  [SUBSCRIBE("refreshSelection") + DEBOUNCE(100)]() {
    this.refreshShow((type) => {
      const current = this.$selection.current;
      const inspector = this.$editor.components.createInspector(current);
      return inspector.length > 0;
    });
  }
  refresh() {
    var current = this.$selection.current;
    if (current) {
      this.setTitle(current.getDefaultTitle() || current.itemType || current.name);
      this.load();
    }
  }
  getBody() {
    return `
      <div ref='$body'></div>
    `;
  }
  [LOAD("$body")]() {
    var current = this.$selection.current;
    if (!current)
      return "";
    const inspector = this.$editor.components.createInspector(current);
    inspector.forEach((it) => {
      let defaultValue = current[it.key] || it.defaultValue;
      if (isFunction(it.convertDefaultValue)) {
        defaultValue = it.convertDefaultValue(current, it.key);
      }
      it.defaultValue = defaultValue;
    });
    return `
      <object refClass="ComponentEditor" ref="$comp" inspector=${variable$4(inspector)} onchange="changeComponentProperty" />
    `;
  }
  [SUBSCRIBE_SELF("changeComponentProperty")](key, value) {
    this.command("setAttributeForMulti", "change component : " + key, this.$selection.packByValue({
      [key]: value
    }));
  }
}
var ComponentPopup$1 = "";
class ComponentPopup extends BasePopup {
  getClassName() {
    return "component-property w(800)";
  }
  getTitle() {
    return "Component";
  }
  initState() {
    return {
      title: "",
      inspector: []
    };
  }
  refresh() {
    this.setTitle(this.state.title || this.getTitle());
    this.load();
  }
  getBody() {
    return `
      <div ref='$body'></div>
    `;
  }
  [BIND("$body")]() {
    return {
      style: {
        width: this.state.width || 250
      }
    };
  }
  [LOAD("$body")]() {
    const inspector = this.state.inspector;
    return `
      <object refClass="ComponentEditor" inspector=${variable$4(inspector)} onchange="changeComponent" />
    `;
  }
  [SUBSCRIBE_SELF("changeComponent")](key, value) {
    if (isFunction(this.state.changeEvent)) {
      this.emit(this.state.changeEvent, key, value);
    }
  }
  [SUBSCRIBE("showComponentPopup")](data) {
    this.setState(data, false);
    this.refresh();
    this.show(data.width);
  }
}
var ComponentEditor$1 = "";
class ComponentEditor extends EditorElement {
  initState() {
    return {
      inspector: this.props.inspector
    };
  }
  template() {
    return `
      <div ref='$body' class="component-editor"></div>
    `;
  }
  getPropertyEditor(index2, childEditor) {
    if (childEditor.type === "column") {
      const size2 = (childEditor.size || [2]).join("-");
      return `
        <div class='column column-${size2}' style="--column-gap: ${childEditor.gap}px" >
          ${childEditor.columns.map((it, itemIndex) => {
        if (it === "-") {
          return `<div class="column-item"></div>`;
        } else if (it.type === "label") {
          return `<div class="column-item">
                <label>${it.label}</label>
              </div>`;
        }
        return `
              <div class='column-item'>
                ${this.getPropertyEditor(`${index2}${itemIndex}`, it)}
              </div>
            `;
      }).join("")}  
        </div>
      `;
    }
    return `
        <object 
          refClass="${childEditor.editor}" 
          ${variable$4(__spreadProps(__spreadValues({}, childEditor.editorOptions), {
      onchange: (key, value) => {
        const newValue = isFunction(childEditor.convert) ? childEditor.convert(key, value) : value;
        this.trigger("changeComponentValue", key, newValue);
      },
      ref: `${childEditor.key}${index2}`,
      key: childEditor.key,
      value: childEditor.defaultValue
    }))} 
        />
    `;
  }
  [LOAD("$body")]() {
    const inspector = this.state.inspector;
    var self2 = inspector.map((it, index2) => {
      if (isString(it) || it.type === "label") {
        const title2 = it.label || it;
        return `
          <div class='component-item'> 
            <label>${title2}</label>
          </div>`;
      } else {
        return `
            <div class='component-item'> 
              ${this.getPropertyEditor(index2, it)}
            </div>
          `;
      }
    });
    return self2;
  }
  setInspector(inspector) {
    this.setState({
      inspector
    });
  }
  setValue(obj2 = {}) {
    Object.keys(obj2).forEach((key) => {
      const value = obj2[key];
      this.eachChildren((child) => {
        if (child.setValue && child.props.key === key) {
          child.setValue(value);
        }
      });
    });
  }
  getValue() {
    const result = {};
    this.eachChildren((child) => {
      if (child.getValue) {
        result[child.props.key] = child.getValue();
      }
    });
    return result;
  }
  [SUBSCRIBE_SELF("changeComponentValue")](key, value) {
    this.parent.trigger(this.props.onchange, key, value);
  }
}
function component(editor) {
  editor.registerElement({
    ComponentEditor
  });
  editor.registerMenuItem("inspector.tab.style", {
    ComponentProperty
  });
  editor.registerMenuItem("popup", {
    ComponentPopup
  });
}
var ContentProperty$1 = "";
class ContentProperty extends BaseProperty {
  getTitle() {
    return "Content";
  }
  [SUBSCRIBE("refreshSelection", "refreshContent") + DEBOUNCE(100)]() {
    this.refreshShow(["text"]);
  }
  getBody() {
    return `
      <div class="property-item elf--content-item">
        <textarea ref="$contentItem"></textarea>
      </div>
    `;
  }
  [BIND("$contentItem")]() {
    var current = this.$selection.current;
    if (!current)
      return "";
    return {
      value: current.content || ""
    };
  }
  [INPUT("$contentItem")](e2) {
    this.setContent();
  }
  setContent() {
    var current = this.$selection.current;
    if (current) {
      var data = {
        content: this.refs.$contentItem.value
      };
      current.reset(data);
      this.emit("refreshSelectionStyleView", current);
    }
  }
}
function content(editor) {
  editor.registerElement({
    ContentProperty
  });
}
var area_width = {
  key: "area.width",
  defaultValue: 100,
  title: "Area Width to find layers fastly",
  description: "Set area width/height",
  type: "number"
};
var __glob_0_0$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": area_width
});
var body_move_ms = {
  key: "body.move.ms",
  defaultValue: 30,
  title: "pointer move delay millisecond",
  description: "Set delay millisecond to moving pointer in body  ",
  type: "number"
};
var __glob_0_1$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": body_move_ms
});
var canvas_height = {
  key: "canvas.height",
  defaultValue: 1e4,
  title: "Default canvas height",
  description: "Set default canvas height",
  type: "number"
};
var __glob_0_2$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": canvas_height
});
var canvas_width = {
  key: "canvas.width",
  defaultValue: 1e4,
  title: "Default canvas width",
  description: "Set default canvas width",
  type: "number"
};
var __glob_0_3$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": canvas_width
});
var debug_mode = {
  key: "debug",
  defaultValue: false,
  title: "debug mode",
  description: "Set debug mode to on ",
  type: "boolean"
};
var __glob_0_4$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": debug_mode
});
var editing_mode_itemType = {
  key: "editing.mode.itemType",
  defaultValue: "select",
  title: "set item type for  editing mode",
  description: "set item type for  editing mode",
  type: "string"
};
var __glob_0_5$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": editing_mode_itemType
});
var editing_mode = {
  key: "editing.mode",
  defaultValue: EditingMode.SELECT,
  title: "set editing mode for Editor",
  description: "set editing mode (select, append, draw, path)",
  type: "string"
};
var __glob_0_6$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": editing_mode
});
var editor_design_mode = {
  key: "editor.design.mode",
  defaultValue: "design",
  title: "Editor Design Mode ",
  description: "Set editor's design mode",
  options: ["design", "item"],
  type: "select"
};
var __glob_0_7$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": editor_design_mode
});
var editor_layout_mode = {
  key: "editor.layout.mode",
  defaultValue: "all",
  title: "Editor Layout Mode ",
  description: "Set editor's layout mode",
  type: "string"
};
var __glob_0_8$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": editor_layout_mode
});
var editor_theme = {
  key: "editor.theme",
  defaultValue: "light",
  title: "Editor Theme ",
  description: "Set editor's theme",
  type: "string"
};
var __glob_0_9$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": editor_theme
});
var fixed_angle = {
  key: "fixed.angle",
  defaultValue: 15,
  title: "fixed angle count",
  description: "Set fixed angle",
  type: "number"
};
var __glob_0_10$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": fixed_angle
});
var history_delay_ms = {
  key: "history.delay.ms",
  defaultValue: 500,
  title: "history delay milliseconds",
  description: "Set history delay time",
  type: "number"
};
var __glob_0_11$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": history_delay_ms
});
var language_locale = {
  key: "language.locale",
  defaultValue: Language.EN,
  title: "set locale for editor",
  description: "set locale for editor",
  type: "string"
};
var __glob_0_12$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": language_locale
});
var set_drag_path_area = {
  key: "set.drag.path.area",
  defaultValue: false,
  title: "Drag path area",
  description: "Drag path area",
  type: "boolean",
  storage: "none"
};
var __glob_0_13$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": set_drag_path_area
});
var set_move_control_point = {
  key: "set.move.control.point",
  defaultValue: false,
  title: "Moving Control Point",
  description: "Moving Control Point",
  type: "boolean",
  storage: "none"
};
var __glob_0_14$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": set_move_control_point
});
var set_tool_hand = {
  key: "set.tool.hand",
  defaultValue: false,
  title: "Hand tool",
  description: "Hand tool is on",
  type: "boolean",
  storage: "none"
};
var __glob_0_15$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": set_tool_hand
});
var show_left_panel = {
  key: "show.left.panel",
  defaultValue: true,
  title: "Show left panel",
  description: "Set left panel visibility to on",
  type: "boolean"
};
var __glob_0_16$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": show_left_panel
});
var show_outline = {
  key: "show.outline",
  defaultValue: false,
  title: "Show outline",
  description: "Set outline visibility to on",
  type: "boolean"
};
var __glob_0_17$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": show_outline
});
var show_right_panel = {
  key: "show.right.panel",
  defaultValue: true,
  title: "Show right panel",
  description: "Set right panel visibility to on",
  type: "boolean"
};
var __glob_0_18$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": show_right_panel
});
var show_ruler = {
  key: "show.ruler",
  defaultValue: true,
  title: "Show ruler",
  description: "Set ruler visibility to on",
  type: "boolean"
};
var __glob_0_19$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": show_ruler
});
var snap_distance = {
  key: "snap.distance",
  defaultValue: 3,
  title: "Snap distance between objects",
  description: "Set snap distance",
  type: "number"
};
var __glob_0_20$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": snap_distance
});
var snap_grid = {
  key: "snap.grid",
  defaultValue: 50,
  title: "Snap grid size between objects",
  description: "Set snap grid size",
  type: "number"
};
var __glob_0_21 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": snap_grid
});
var store_key = {
  key: "store.key",
  defaultValue: "easylogic.studio",
  title: "Store Key",
  description: "Set localStorage key",
  type: "number"
};
var __glob_0_22 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": store_key
});
var style_canvas_background_color = {
  key: "style.canvas.background.color",
  defaultValue: "#ececec",
  title: "Canvas Background Color",
  description: "Set canvas background color",
  type: "color"
};
var __glob_0_23 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": style_canvas_background_color
});
const modules$1 = { "./config_list/area.width.js": __glob_0_0$1, "./config_list/body.move.ms.js": __glob_0_1$1, "./config_list/canvas.height.js": __glob_0_2$1, "./config_list/canvas.width.js": __glob_0_3$1, "./config_list/debug.mode.js": __glob_0_4$1, "./config_list/editing.mode.itemType.js": __glob_0_5$1, "./config_list/editing.mode.js": __glob_0_6$1, "./config_list/editor.design.mode.js": __glob_0_7$1, "./config_list/editor.layout.mode.js": __glob_0_8$1, "./config_list/editor.theme.js": __glob_0_9$1, "./config_list/fixed.angle.js": __glob_0_10$1, "./config_list/history.delay.ms.js": __glob_0_11$1, "./config_list/language.locale.js": __glob_0_12$1, "./config_list/set.drag.path.area.js": __glob_0_13$1, "./config_list/set.move.control.point.js": __glob_0_14$1, "./config_list/set.tool.hand.js": __glob_0_15$1, "./config_list/show.left.panel.js": __glob_0_16$1, "./config_list/show.outline.js": __glob_0_17$1, "./config_list/show.right.panel.js": __glob_0_18$1, "./config_list/show.ruler.js": __glob_0_19$1, "./config_list/snap.distance.js": __glob_0_20$1, "./config_list/snap.grid.js": __glob_0_21, "./config_list/store.key.js": __glob_0_22, "./config_list/style.canvas.background.color.js": __glob_0_23 };
var configs = Object.values(modules$1).map((it) => it.default);
function defaultConfigs(editor) {
  configs.forEach((config) => {
    editor.registerConfig(config);
  });
}
class BaseAssetModel extends BaseModel {
  getDefaultObject(obj2 = {}) {
    return super.getDefaultObject(__spreadValues({
      svgfilters: [],
      keyframes: []
    }, obj2));
  }
  addKeyframe(keyframe2) {
    this.json.keyframes.push(keyframe2);
    return keyframe2;
  }
  createKeyframe(data = {}) {
    return this.addKeyframe(new Keyframe(__spreadValues({
      checked: true
    }, data)));
  }
  removeKeyframe(removeIndex) {
    this.removePropertyList(this.json.keyframes, removeIndex);
  }
  sortItem(arr, startIndex, targetIndex) {
    arr.splice(targetIndex + (startIndex < targetIndex ? -1 : 0), 0, ...arr.splice(startIndex, 1));
  }
  sortKeyframe(startIndex, targetIndex) {
    this.sortItem(this.json.keyframes, startIndex, targetIndex);
  }
  updateKeyframe(index2, data = {}) {
    this.json.keyframes[+index2].reset(data);
  }
  toKeyframeString(isAnimate = false) {
    return this.json.keyframes.map((keyframe2) => keyframe2.toString(isAnimate)).join("\n\n");
  }
  copyPropertyList(arr, index2) {
    var copyObject = __spreadValues({}, arr[index2]);
    arr.splice(index2, 0, copyObject);
  }
  toCloneObject() {
    return __spreadValues(__spreadValues({}, super.toCloneObject()), this.attrs("svgfilters", "keyframes"));
  }
  removePropertyList(arr, removeIndex) {
    arr.splice(removeIndex, 1);
  }
  getSVGFilterIndex(id) {
    var _a;
    var filter2 = this.json.svgfilters.map((it, index2) => {
      return { id: it.id, index: index2 };
    }).filter((it) => {
      return it.id === id;
    });
    return filter2.length ? (_a = filter2 == null ? void 0 : filter2[0]) == null ? void 0 : _a.index : -1;
  }
  removeSVGFilter(removeIndex) {
    this.removePropertyList(this.json.svgfilters, removeIndex);
  }
  copySVGFilter(index2) {
    this.copyPropertyList(this.json.svgfilters, index2);
  }
  sortSVGFilter(startIndex, targetIndex) {
    this.sortItem(this.json.svgfilters, startIndex, targetIndex);
  }
  setSVGFilterValue(index2, value) {
    this.json.svgfilters[index2] = __spreadValues(__spreadValues({}, this.json.svgfilters[index2]), value);
  }
  addSVGFilter(obj2 = {}) {
    this.json.svgfilters.push(obj2);
    var index2 = this.json.svgfilters.length - 1;
    return index2;
  }
  createSVGFilter(data = {}) {
    return this.addSVGFilter(__spreadValues({
      id: uuidShort$1()
    }, data));
  }
}
class MovableModel extends BaseAssetModel {
  getDefaultObject(obj2 = {}) {
    return super.getDefaultObject(__spreadValues({
      angle: 0
    }, obj2));
  }
  get isAbsolute() {
    return this.json.position === "absolute";
  }
  get isRelative() {
    return this.json.position === "relative";
  }
  get isChild() {
    if (this.json.parent) {
      var isParentDrawItem = this.json.parent.is("project") === false;
      if (isParentDrawItem && this.isAbsolute) {
        return true;
      }
    }
    return false;
  }
  get isDragSelectable() {
    return true;
  }
  get isBooleanItem() {
    return void 0;
  }
  get resizableWitChildren() {
    return false;
  }
  get transform() {
    return `rotateZ(${Length.deg(this.json.angle)})`;
  }
  get localMatrix() {
    return this._cachedLocalTransform || this.getLocalTransformMatrix();
  }
  get localMatrixInverse() {
    return this._cachedLocalTransformInverse || this.getLocalTransformMatrixInverse();
  }
  get transformWithTranslate() {
    return this._cachedTransformWithTranslate || this.getTransformWithTranslate(this);
  }
  get transformWithTranslateToTranspose() {
    return this._cachedTransformWithTranslateTranspose || transpose([], this.getTransformWithTranslate(this));
  }
  get transformWithTranslateInverse() {
    return this._cachedTransformWithTranslateInverse || invert([], this.getTransformWithTranslate(this));
  }
  get itemMatrix() {
    return this._cachedItemTransform || this.getItemTransformMatrix();
  }
  get itemMatrixInverse() {
    return this._cachedItemTransformInverse || this.getItemTransformMatrixInverse();
  }
  get absoluteMatrix() {
    return this._cachedAbsoluteMatrix || this.getAbsoluteMatrix();
  }
  get absoluteMatrixInverse() {
    return this._cachedAbsoluteMatrixInverse || this.getAbsoluteMatrixInverse();
  }
  get verties() {
    return this._cachedVerties || this.getVerties();
  }
  get originVerties() {
    return this._cachedVertiesWithoutTransformOrigin || this.rectVerties();
  }
  get localVerties() {
    return this._cachedLocalVerties || this.getLocalVerties();
  }
  get guideVerties() {
    return this._cachedGuideVerties || this.getGuideVerties();
  }
  get areaPosition() {
    return this._cachedAreaPosition || this.getAreaPosition(this._cachedAreaWidth);
  }
  get offsetX() {
    return this.json.x;
  }
  get offsetY() {
    return this.json.y;
  }
  get screenWidth() {
    return this.json.width;
  }
  get screenHeight() {
    return this.json.height;
  }
  get y() {
    return this.json.y;
  }
  get x() {
    return this.json.x;
  }
  get width() {
    return this.json.width;
  }
  get height() {
    return this.json.height;
  }
  get angle() {
    return this.json.angle;
  }
  get translate() {
    return [0, 0, 0];
  }
  get scale() {
    return [1, 1, 1];
  }
  get rotate() {
    return [0, 0, degreeToRadian(angle)];
  }
  get origin() {
    return TransformOrigin.scale(this.json["transform-origin"] || "50% 50% 0px", this.screenWidth, this.screenHeight);
  }
  get quat() {
    return fromEuler(create$2(), 0, 0, this.angle);
  }
  getAreaPosition(areaSize = 100) {
    const verties = this.getVerties();
    const rect2 = toRectVerties(verties);
    const [startRow, startColumn] = area(rect2[0][0], rect2[0][1], areaSize);
    const [endRow, endColumn] = area(rect2[2][0], rect2[2][1], areaSize);
    return {
      column: [startColumn, endColumn],
      row: [startRow, endRow]
    };
  }
  toCloneObject(isDeep = true) {
    return __spreadValues(__spreadValues({}, super.toCloneObject(isDeep)), this.attrs("x", "y", "right", "bottom", "width", "height", "angle"));
  }
  reset(obj2, context = { origin: "*" }) {
    const isChanged = super.reset(obj2, context);
    if (this.hasChangedField("children", "x", "y", "width", "height", "angle", "transform-origin", "perspective", "perspective-origin")) {
      this.refreshMatrixCache();
    }
    return isChanged;
  }
  setParentId(otherParentId) {
    super.setParentId(otherParentId);
    this.refreshMatrixCache();
  }
  refreshMatrixCache() {
    this.setCacheItemTransformMatrix();
    this.setCacheLocalTransformMatrix();
    this.setCacheAbsoluteMatrix();
    this.setCacheLocalVerties();
    this.setCacheVerties();
    this.setCacheGuideVerties();
    this.setCacheAreaPosition();
    this.layers.forEach((it) => {
      it.refreshMatrixCache();
    });
  }
  setCacheItemTransformMatrix() {
    this._cachedItemTransform = this.getItemTransformMatrix();
    this._cachedItemTransformInverse = invert([], this._cachedItemTransform);
  }
  setCacheLocalTransformMatrix() {
    this._cachedLocalTransform = this.getLocalTransformMatrix();
    this._cachedLocalTransformInverse = invert([], this._cachedLocalTransform);
    this._cachedTransformWithTranslate = this.getTransformWithTranslate(this);
    this._cachedTransformWithTranslateInverse = invert([], this._cachedTransformWithTranslate);
    this._cachedTransformWithTranslateTranspose = transpose([], this._cachedTransformWithTranslate);
  }
  setCacheAbsoluteMatrix() {
    this._cachedAbsoluteMatrix = this.getAbsoluteMatrix();
    this._cachedAbsoluteMatrixInverse = invert([], this._cachedAbsoluteMatrix);
  }
  setCacheVerties() {
    this._cachedVerties = this.getVerties();
    this._cachedVertiesWithoutTransformOrigin = this.rectVerties();
  }
  setCacheLocalVerties() {
    this._cachedLocalVerties = this.getLocalVerties();
  }
  setCacheGuideVerties() {
    this._cachedGuideVerties = this.getGuideVerties();
  }
  setCacheAreaPosition() {
    this._cachedAreaPosition = this.getAreaPosition(this._cachedAreaWidth || 100);
  }
  setCacheAreaWidth(areaWidth) {
    if (this._cachedAreaWidth !== areaWidth) {
      this._cachedAreaWidth = areaWidth;
      this.setCacheAreaPosition();
    }
  }
  move(distVector = [0, 0, 0]) {
    this.reset({
      x: round$1(this.offsetX + distVector[0]),
      y: round$1(this.offsetY + distVector[1])
    });
  }
  moveByCenter(newCenter = [0, 0, 0]) {
    this.reset({
      x: newCenter[0] - this.screenWidth / 2,
      y: newCenter[1] - this.screenHeight / 2
    });
  }
  startToCacheChildren() {
  }
  recoverChildren() {
  }
  resize(width2, height2) {
    this.startToCacheChildren();
    this.reset({ width: width2, height: height2 });
    this.recoverChildren();
  }
  setAngle(angle2 = 0) {
    this.reset({
      angle: angle2
    });
  }
  addAngle(angle2 = 0) {
    this.setAngle(this.angle + angle2);
  }
  checkInArea(areaVerties) {
    return polyPoly(areaVerties, this.originVerties);
  }
  hasPoint(x2, y2) {
    return this.isPointInRect(x2, y2);
  }
  isPointInRect(x2, y2) {
    return polyPoint(this.originVerties, x2, y2);
  }
  isIncludeByArea(areaVerties) {
    return this.originVerties.map((vector) => {
      return polyPoint(areaVerties, ...vector);
    }).filter(Boolean).length === 4;
  }
  getPerspectiveMatrix() {
    const hasPerspective = this.json["perspective"];
    if (!hasPerspective) {
      return void 0;
    }
    let [
      perspectiveOriginX = Length.percent(50),
      perspectiveOriginY = Length.percent(50)
    ] = TransformOrigin.parseStyle(this.json["perspective-origin"]);
    const width2 = this.screenWidth;
    const height2 = this.screenHeight;
    perspectiveOriginX = perspectiveOriginX.toPx(width2).value;
    perspectiveOriginY = perspectiveOriginY.toPx(height2).value;
    const view = create$5();
    translate(view, view, [perspectiveOriginX, perspectiveOriginY, 0]);
    if (this.json["perspective"] && this.json["perspective"] != "none") {
      multiply$1(view, view, fromValues$1(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, -1 / Length.parse(this.json["perspective"]).value, 1));
    } else {
      return void 0;
    }
    translate(view, view, [-perspectiveOriginX, -perspectiveOriginY, 0]);
    return view;
  }
  getItemTransformMatrix() {
    const list2 = Transform.parseStyle(this.transform);
    const width2 = this.screenWidth;
    const height2 = this.screenHeight;
    return Transform.createTransformMatrix(list2, width2, height2);
  }
  getItemTransformMatrixInverse() {
    return invert([], this.getItemTransformMatrix());
  }
  getLocalTransformMatrix(width2, height2) {
    const origin2 = TransformOrigin.scale(this.json["transform-origin"] || "50% 50% 0px", isUndefined(width2) ? this.screenWidth : width2, isUndefined(height2) ? this.screenHeight : height2);
    const view = create$5();
    translate(view, view, origin2);
    multiply$1(view, view, this.itemMatrix);
    translate(view, view, negate([], origin2));
    return view;
  }
  getLocalTransformMatrixInverse(width2, height2) {
    return invert([], this.getLocalTransformMatrix(width2, height2));
  }
  getDirectionTransformMatrix(vertexOffset, width2, height2) {
    const x2 = this.offsetX;
    const y2 = this.offsetY;
    const center2 = add$1([], TransformOrigin.scale(this.json["transform-origin"] || "50% 50% 0px", width2, height2), negate([], vertexOffset));
    const view = create$5();
    translate(view, view, [x2, y2, 0]);
    translate(view, view, vertexOffset);
    translate(view, view, center2);
    multiply$1(view, view, this.itemMatrix);
    translate(view, view, negate([], center2));
    return view;
  }
  getDirectionTopLeftMatrix(width2, height2) {
    return this.getDirectionTransformMatrix([0, 0, 0], width2, height2);
  }
  getDirectionLeftMatrix(width2, height2) {
    return this.getDirectionTransformMatrix([0, height2 / 2, 0], width2, height2);
  }
  getDirectionTopMatrix(width2, height2) {
    return this.getDirectionTransformMatrix([width2 / 2, 0, 0], width2, height2);
  }
  getDirectionBottomLeftMatrix(width2, height2) {
    return this.getDirectionTransformMatrix([0, height2, 0], width2, height2);
  }
  getDirectionTopRightMatrix(width2, height2) {
    return this.getDirectionTransformMatrix([width2, 0, 0], width2, height2);
  }
  getDirectionRightMatrix(width2, height2) {
    return this.getDirectionTransformMatrix([width2, height2 / 2, 0], width2, height2);
  }
  getDirectionBottomRightMatrix(width2, height2) {
    return this.getDirectionTransformMatrix([width2, height2, 0], width2, height2);
  }
  getDirectionBottomMatrix(width2, height2) {
    return this.getDirectionTransformMatrix([width2 / 2, height2, 0], width2, height2);
  }
  getAbsoluteMatrix() {
    let transform2 = create$5();
    if (this.parent) {
      multiply$1(transform2, transform2, this.parent.absoluteMatrix);
      if (isFunction(this.parent.getPerspectiveMatrix)) {
        const perspectiveMatrix = this.parent.getPerspectiveMatrix();
        if (perspectiveMatrix) {
          multiply$1(transform2, transform2, perspectiveMatrix);
        }
      }
    }
    multiply$1(transform2, transform2, this.getRelativeMatrix());
    return transform2;
  }
  getRelativeMatrix() {
    let transform2 = create$5();
    const offsetX = this.offsetX;
    const offsetY = this.offsetY;
    translate(transform2, transform2, [offsetX, offsetY, 0]);
    multiply$1(transform2, transform2, this.localMatrix);
    return transform2;
  }
  getTransformWithTranslate(item2) {
    item2 = item2 || this;
    let view = create$5();
    const offsetX = item2.offsetX;
    const offsetY = item2.offsetY;
    translate(view, view, [offsetX, offsetY, 0]);
    multiply$1(view, view, item2.localMatrix);
    return view;
  }
  getAbsoluteMatrixInverse() {
    return invert([], this.getAbsoluteMatrix());
  }
  getLocalVerties(width2, height2) {
    width2 = isNotUndefined(width2) ? width2 : this.screenWidth;
    height2 = isNotUndefined(height2) ? height2 : this.screenHeight;
    let model = rectToVerties(0, 0, width2, height2, this.json["transform-origin"]);
    return model;
  }
  getVerties(width2, height2) {
    width2 = isNotUndefined(width2) ? width2 : this.screenWidth;
    height2 = isNotUndefined(height2) ? height2 : this.screenHeight;
    let model = rectToVerties(0, 0, width2, height2, this.json["transform-origin"]);
    return vertiesMap(model, this.absoluteMatrix);
  }
  rectVerties() {
    return this.verties.filter((_, index2) => index2 < 4);
  }
  getGuideVerties() {
    const verties = this.originVerties;
    return [
      ...verties,
      lerp([], verties[0], verties[1], 0.5),
      lerp([], verties[1], verties[2], 0.5),
      lerp([], verties[2], verties[3], 0.5),
      lerp([], verties[3], verties[0], 0.5)
    ];
  }
  get toRectVerties() {
    return itemsToRectVerties([this]);
  }
  get matrix() {
    const id = this.id;
    const x2 = this.offsetX;
    const y2 = this.offsetY;
    const width2 = this.screenWidth;
    const height2 = this.screenHeight;
    const originalTransform = this.transform;
    const originalTransformOrigin = this.json["transform-origin"] || "50% 50% 0%";
    const transformOriginMatrix = this.getTransformOriginMatrix();
    const transformOriginMatrixInverse = this.getTransformOriginMatrixInverse();
    const parentMatrix = this.parent.absoluteMatrix;
    const parentMatrixInverse = this.parent.absoluteMatrixInverse;
    const localMatrix = this.localMatrix;
    const localMatrixInverse = this.localMatrixInverse;
    const itemMatrix = this.itemMatrix;
    const itemMatrixInverse = this.itemMatrixInverse;
    const absoluteMatrix = this.absoluteMatrix;
    const absoluteMatrixInverse = this.absoluteMatrixInverse;
    const relativeMatrix = this.relativeMatrix;
    const relativeMatrixInverse = this.relativeMatrixInverse;
    const directionMatrix = {
      "to top left": this.getDirectionTopLeftMatrix(width2, height2),
      "to top": this.getDirectionTopMatrix(width2, height2),
      "to top right": this.getDirectionTopRightMatrix(width2, height2),
      "to right": this.getDirectionRightMatrix(width2, height2),
      "to bottom left": this.getDirectionBottomLeftMatrix(width2, height2),
      "to bottom": this.getDirectionBottomMatrix(width2, height2),
      "to bottom right": this.getDirectionBottomRightMatrix(width2, height2),
      "to left": this.getDirectionLeftMatrix(width2, height2)
    };
    const verties = this.verties;
    const xList = verties.map((it) => it[0]);
    const yList = verties.map((it) => it[1]);
    return {
      id,
      x: x2,
      y: y2,
      width: width2,
      height: height2,
      transform: originalTransform,
      originalTransformOrigin,
      verties,
      originVerties: this.originVerties,
      xList,
      yList,
      directionMatrix,
      parentMatrix,
      parentMatrixInverse,
      localMatrix,
      localMatrixInverse,
      itemMatrix,
      itemMatrixInverse,
      absoluteMatrix,
      absoluteMatrixInverse,
      relativeMatrix,
      relativeMatrixInverse,
      transformOriginMatrix,
      transformOriginMatrixInverse
    };
  }
  absolutePath(pathString2 = "") {
    const d = pathString2 || this.d;
    const pathParser = new PathParser(d);
    pathParser.transformMat4(this.absoluteMatrix);
    return pathParser;
  }
  invertPath(pathString2 = "") {
    const path = new PathParser(pathString2);
    path.transformMat4(this.absoluteMatrixInverse);
    return path;
  }
  invertPoint(point2) {
    return transformMat4([], point2, this.absoluteMatrixInverse);
  }
  invertPathString(pathString2 = "") {
    return this.invertPath(pathString2).d;
  }
  updatePath(d) {
    const matrix = this.matrix;
    const newPath = new PathParser(d);
    let bbox = newPath.getBBox();
    const newWidth = distance$1(bbox[1], bbox[0]);
    const newHeight = distance$1(bbox[3], bbox[0]);
    let oldBBox = vertiesMap(rectToVerties(bbox[0][0], bbox[0][1], newWidth, newHeight), matrix.absoluteMatrix);
    let newBBox = vertiesMap(oldBBox, calculateMatrixInverse(fromTranslation([], oldBBox[4]), Transform.createTransformMatrix(Transform.parseStyle(matrix.transform), newWidth, newHeight), fromTranslation([], negate([], oldBBox[4]))));
    const worldMatrix = calculateMatrix(fromTranslation([], newBBox[0]), this.getLocalTransformMatrix(newWidth, newHeight));
    const realXY = getTranslation([], calculateMatrix(matrix.parentMatrixInverse, worldMatrix, invert([], this.getLocalTransformMatrix(newWidth, newHeight))));
    return {
      d: newPath.translate(-bbox[0][0], -bbox[0][1]).d,
      x: realXY[0],
      y: realXY[1],
      width: newWidth,
      height: newHeight
    };
  }
  checkInAreaForAll(areaVerties) {
    const items = [...this.checkInAreaForLayers(areaVerties)];
    if (this.is("artboard"))
      return items;
    if (this.is("project"))
      return items;
    if (this.checkInArea(areaVerties)) {
      items.push(this.ref);
    }
    return items;
  }
  checkInAreaForLayers(areaVerties) {
    var items = [];
    this.layers.forEach((layer2) => {
      items.push.apply(items, layer2.checkInAreaForLayers(areaVerties));
      if (layer2.checkInArea(areaVerties)) {
        items.push(layer2);
      }
    });
    return items;
  }
  getTransformOriginMatrix() {
    return fromTranslation([], TransformOrigin.scale(this.json["transform-origin"] || "50% 50% 0px", this.screenWidth, this.screenHeight));
  }
  getTransformOriginMatrixInverse() {
    return invert([], this.getTransformOriginMatrix());
  }
  recoverMatrix(newChildMatrix) {
    const matrix = calculateMatrix(this.absoluteMatrixInverse, newChildMatrix.absoluteMatrix);
    const q = getRotation([], matrix);
    const axis = [];
    const rad = getAxisAngle(axis, q);
    const angle2 = axis[2] ? radianToDegree(rad * axis[2]) : 0;
    const newTransformMatrix = create$5();
    fromRotation(newTransformMatrix, rad, axis);
    const [x2, y2, z] = getTranslation([], calculateMatrix(matrix, calculateMatrixInverse(newChildMatrix.transformOriginMatrix, newTransformMatrix, newChildMatrix.transformOriginMatrixInverse)));
    return { x: x2, y: y2, angle: angle2 };
  }
  resetMatrix(childItem) {
    const matrix = calculateMatrix(this.absoluteMatrixInverse, childItem.absoluteMatrix);
    const q = getRotation([], matrix);
    const axis = [];
    const rad = getAxisAngle(axis, q);
    const angle2 = axis[2] ? radianToDegree(rad * axis[2]) : 0;
    const newTransformMatrix = create$5();
    fromRotation(newTransformMatrix, rad, axis);
    const [x2, y2, z] = getTranslation([], calculateMatrix(matrix, calculateMatrixInverse(childItem.getTransformOriginMatrix(), newTransformMatrix, childItem.getTransformOriginMatrixInverse())));
    childItem.reset({ x: x2, y: y2, angle: angle2 });
    this.modelManager.setChanged("resetMatrix", this.id, { end: true, childItemId: childItem == null ? void 0 : childItem.id });
  }
  getIndex() {
    var parentLayers = this.parent.layers;
    var startIndex = -1;
    for (var i = 0, len2 = parentLayers.length; i < len2; i++) {
      if (parentLayers[i] === this.ref) {
        startIndex = i;
        break;
      }
    }
    return startIndex;
  }
  setOrder(targetIndex) {
    var parent = this.parent;
    var startIndex = this.getIndex();
    if (startIndex > -1) {
      parent.children[startIndex] = parent.children[targetIndex];
      parent.children[targetIndex] = this.id;
      this.modelManager.setChanged("setOrder", this.id, { targetIndex, startIndex, parentId: parent.id });
    }
  }
  next() {
    if (this.isLast()) {
      return this.ref;
    }
    const index2 = this.getIndex();
    return this.parent.layers[index2 + 1];
  }
  prev() {
    if (this.isFirst()) {
      return this.ref;
    }
    const index2 = this.getIndex();
    return this.parent.layers[index2 - 1];
  }
  orderNext() {
    if (this.isLast()) {
      if (this.parent.next) {
        let next = this.parent.next();
        if (next.enableHasChildren()) {
          next.appendChild(this);
        } else {
          next.appendAfter(this);
        }
      }
      return;
    }
    var startIndex = this.getIndex();
    if (startIndex > -1) {
      this.setOrder(startIndex + 1);
    }
  }
  isFirst() {
    return this.getIndex() === 0;
  }
  isLast() {
    return this.getIndex() === this.parent.children.length - 1;
  }
  orderPrev() {
    if (this.isFirst()) {
      const prev = this.parent.prev();
      if (prev) {
        prev.appendBefore(this);
      }
      return;
    }
    var startIndex = this.getIndex();
    if (startIndex > 0) {
      this.setOrder(startIndex - 1);
    }
  }
  orderFirst() {
    this.setOrder(0);
  }
  orderLast() {
    this.setOrder(this.parent.childrenLength - 1);
  }
  orderTop() {
  }
  orderBottom() {
  }
}
var DefaultLayoutEngine = {
  startCache(container) {
    container.addCache("cachedSize", {
      width: container.width,
      height: container.height
    });
    container.addCache("cachedLayerMatrix", container.layers.map((child) => {
      child.startToCacheChildren();
      return {
        id: child.id,
        matrix: child.attrs("x", "y", "width", "height"),
        constraints: {
          horizontal: child[ConstraintsDirection.HORIZONTAL],
          vertical: child[ConstraintsDirection.VERTICAL]
        }
      };
    }));
  },
  recover(container) {
    const obj2 = {
      width: container.width,
      height: container.height
    };
    const currentContainerWidth = obj2.width;
    const currentContainerHeight = obj2.height;
    const cachedSize = container.getCache("cachedSize");
    const oldContainerWidth = cachedSize.width;
    const oldContainerHeight = cachedSize.height;
    const scaleX = currentContainerWidth / oldContainerWidth;
    const scaleY = currentContainerHeight / oldContainerHeight;
    const cachedLayerMatrix = container.getCache("cachedLayerMatrix");
    cachedLayerMatrix.forEach(({ id, matrix, constraints }) => {
      const item2 = container.find(id);
      const { x: x2, y: y2, width: width2, height: height2 } = matrix;
      const left2 = x2;
      const right2 = oldContainerWidth - x2 - width2;
      const top2 = y2;
      const bottom2 = oldContainerHeight - y2 - height2;
      const localObj = {};
      switch (constraints.horizontal) {
        case Constraints.MIN:
          localObj.x = left2;
          break;
        case Constraints.MAX:
          localObj.x = currentContainerWidth - right2 - width2;
          break;
        case Constraints.STRETCH:
          localObj.x = left2;
          localObj.width = currentContainerWidth - left2 - right2;
          break;
        case Constraints.SCALE:
          localObj.x = left2 * scaleX;
          localObj.width = width2 * scaleX;
          break;
        case Constraints.CENTER:
          const halfWidth = width2 / 2;
          const scaleNew = x2 + halfWidth / oldContainerWidth;
          localObj.x = scaleNew * currentContainerWidth - halfWidth * scaleX;
          break;
      }
      switch (constraints.vertical) {
        case Constraints.MIN:
          localObj.y = top2;
          break;
        case Constraints.MAX:
          localObj.y = currentContainerHeight - bottom2 - height2;
          break;
        case Constraints.STRETCH:
          localObj.y = top2;
          localObj.width = currentContainerHeight - top2 - bottom2;
          break;
        case Constraints.SCALE:
          localObj.y = top2 * scaleY;
          localObj.height = height2 * scaleY;
          break;
        case Constraints.CENTER:
          const halfHeight = height2 / 2;
          const scaleNew = y2 + halfHeight / oldContainerHeight;
          localObj.y = scaleNew * currentContainerHeight - halfHeight * scaleY;
          break;
      }
      item2.reset(localObj);
      item2.recoverChildren();
    });
  }
};
const LayoutEngine = {
  [Layout.DEFAULT]: DefaultLayoutEngine
};
class GroupModel extends MovableModel {
  getDefaultObject(obj2 = {}) {
    return super.getDefaultObject(__spreadValues({
      "layout": Layout.DEFAULT,
      "constraints-horizontal": Constraints.NONE,
      "constraints-vertical": Constraints.NONE,
      "flex-direction": FlexDirection.ROW,
      "flex-wrap": FlexWrap.NOWRAP,
      "justify-content": JustifyContent.FLEX_START,
      "align-items": AlignItems.FLEX_START,
      "align-content": AlignContent.FLEX_START,
      "order": 0,
      "flex-grow": 0,
      "flex-shrink": 0,
      "flex-basis": "auto",
      "gap": 0,
      resizingHorizontal: ResizingMode.FIXED,
      resizingVertical: ResizingMode.FIXED,
      "grid-template-rows": "auto",
      "grid-template-columns": "auto",
      "grid-template-areas": "",
      "grid-auto-rows": "auto",
      "grid-auto-columns": "auto",
      "grid-auto-flow": "row"
    }, obj2));
  }
  get layout() {
    return this.json.layout;
  }
  isLayoutItem() {
    var _a;
    return !!((_a = this.parent) == null ? void 0 : _a.hasLayout());
  }
  hasConstraints() {
    return this.isLayout(Layout.DEFAULT);
  }
  hasLayout() {
    return !this.hasConstraints() || Boolean(this.json.layout) === false;
  }
  isLayout(layout2) {
    return this.json.layout === layout2;
  }
  isInDefault() {
    var _a;
    const parentLayout = ((_a = this.parent) == null ? void 0 : _a.layout) || "default";
    return Layout.DEFAULT === parentLayout;
  }
  isInGrid() {
    return this.isInLayout(Layout.GRID);
  }
  isInFlex() {
    return this.isInLayout(Layout.FLEX);
  }
  isInLayout(layout2) {
    if (!this.isLayoutItem())
      return false;
    return this.parent.layout === layout2;
  }
  get contentBox() {
    const x2 = this["padding-left"] || 0;
    const y2 = this["padding-top"] || 0;
    const width2 = this.screenWidth - (this["padding-left"] || 0) - (this["padding-right"] || 0);
    const height2 = this.screenHeight - (this["padding-top"] || 0) - (this["padding-bottom"] || 0);
    return rectToVerties(x2, y2, width2, height2);
  }
  reset(obj2) {
    const isChanged = super.reset(obj2);
    if (this.hasChangedField(ConstraintsDirection.VERTICAL, ConstraintsDirection.HORIZONTAL)) {
      console.log("a");
    }
    return isChanged;
  }
  changeConstraints(direction, value) {
    const h = this.json[direction];
    let newConstraints = value;
    if (h === Constraints.MAX) {
      if (value === Constraints.MAX) {
        newConstraints = Constraints.SCALE;
      }
      if (e.shiftKey && value === Constraints.MIN) {
        newConstraints = Constraints.STRETCH;
      }
    } else if (h === Constraints.MIN) {
      if (value === Constraints.MIN) {
        newConstraints = Constraints.SCALE;
      } else if (e.shiftKey && value === Constraints.MAX) {
        newConstraints = Constraints.STRETCH;
      }
    } else if (h === Constraints.STRETCH) {
      if (value === Constraints.MIN) {
        newConstraints = Constraints.MAX;
      } else if (value === Constraints.MAX) {
        newConstraints = Constraints.MIN;
      }
    }
    this.reset({
      [direction]: newConstraints
    });
  }
  startToCacheChildren() {
    var _a;
    (_a = LayoutEngine[this.layout]) == null ? void 0 : _a.startCache(this);
  }
  recoverChildren() {
    var _a;
    (_a = LayoutEngine[this.layout]) == null ? void 0 : _a.recover(this);
  }
}
class Selector extends PropertyItem {
  static parse(obj2) {
    return new Selector(obj2);
  }
  getDefaultObject(obj2) {
    return super.getDefaultObject(__spreadValues({
      itemType: "selector",
      selector: "",
      properties: []
    }, obj2));
  }
  toCloneObject() {
    return __spreadValues(__spreadValues({}, super.toCloneObject()), this.attrs("selector", "properties"));
  }
  isMultiStyle(key) {
    switch (key) {
      case "background-image":
      case "var":
        return true;
    }
    return false;
  }
  getMultiStyleString(p) {
    switch (p.key) {
      case "background-image":
        return p.value.toString() + ";";
    }
    return p.value.toString() + " !important;";
  }
  toPropertyString() {
    return this.json.properties.map((p) => {
      if (this.isMultiStyle(p.key)) {
        return this.getMultiStyleString(p);
      } else {
        var value = p.value.toString();
        if (value) {
          var key = p.key;
          if (key === "x")
            key = "left";
          else if (key === "y")
            key = "top";
          return `${key}: ${value} !important;`;
        } else {
          return "";
        }
      }
    }).join("\n");
  }
  toCSSText(prefix = "") {
    return `${prefix}${this.json.selector} {
    ${this.toPropertyString()}
}`;
  }
  toCSS() {
    return {};
  }
  toString(prefix = "") {
    return this.toCSSText(prefix);
  }
}
const editableList = [
  "appearance",
  "position",
  "right",
  "bottom",
  "rootVariable",
  "variable",
  "transform",
  "filter",
  "backdrop-filter",
  "background-color",
  "background-image",
  "border-radius",
  "border",
  "box-shadow",
  "clip-path",
  "color",
  "perspective-origin",
  "transform-origin",
  "transform-style",
  "perspective",
  "mix-blend-mode",
  "overflow",
  "opacity",
  "box-model",
  "layout",
  "flex-layout",
  "grid-layout",
  "animation",
  "transition",
  "pattern",
  "boolean-operation"
];
const editableKeys = {};
editableList.forEach(function(key) {
  editableKeys[key] = true;
});
class DomModel extends GroupModel {
  getDefaultObject(obj2 = {}) {
    return super.getDefaultObject(__spreadValues({
      "position": "absolute",
      "x": 0,
      "y": 0,
      "rootVariable": "",
      "variable": "",
      "width": 300,
      "height": 300,
      "color": "black",
      "overflow": "visible",
      "opacity": 1,
      "transform-style": "preserve-3d",
      "layout": Layout.DEFAULT,
      "flex-layout": "display:flex;",
      "grid-layout": "display:grid;",
      "constraints-vertical": Constraints.MIN,
      "constraints-horizontal": Constraints.MIN,
      selectors: [],
      svg: []
    }, obj2));
  }
  toCloneObject() {
    var json = this.json;
    return __spreadProps(__spreadValues(__spreadValues({}, super.toCloneObject()), this.attrs("position", "rootVariable", "variable", "transform", "filter", "backdrop-filter", "background-color", "background-image", "text-clip", "border-radius", "border", "border-top", "border-left", "border-right", "border-bottom", "box-shadow", "text-shadow", "clip-path", "color", "font-size", "line-height", "text-align", "text-transform", "text-decoration", "letter-spacing", "word-spacing", "text-indent", "perspective-origin", "transform-origin", "transform-style", "perspective", "mix-blend-mode", "overflow", "opacity", "flex-layout", "grid-layout", "animation", "transition", "margin-top", "margin-left", "margin-right", "margin-bottom", "padding-top", "padding-right", "padding-left", "padding-bottom", "constraints-horizontal", "constraints-vertical")), {
      selectors: json.selectors.map((selector2) => selector2.clone()),
      svg: json.svg.map((svg) => svg.clone())
    });
  }
  editable(editablePropertyName) {
    if (editablePropertyName == "border" && this.hasChildren()) {
      return false;
    }
    switch (editablePropertyName) {
      case "svg-item":
      case "transform-origin":
      case "perspective":
      case "perspective-origin":
        return false;
    }
    return Boolean(editableKeys[editablePropertyName]);
  }
  get changedBoxModel() {
    return this.hasChangedField("margin-top", "margin-left", "margin-bottom", "margin-right", "padding-top", "padding-left", "padding-right", "padding-bottom");
  }
  get changedFlexLayout() {
    return this.hasChangedField("flex-direction", "flex-wrap", "justify-content", "align-items", "align-content", "order", "flex-basis", "flex-grow", "flex-shrink", "flex-flow");
  }
  get changedGridLayout() {
    return this.hasChangedField("grid-template-rows", "grid-template-columns", "grid-template-areas", "grid-auto-rows", "grid-auto-columns", "grid-auto-flow", "grid-row-gap", "grid-column-gap", "grid-row-start", "grid-row-end", "grid-column-start", "grid-column-end", "grid-area");
  }
  get changedLayout() {
    return this.hasChangedField("layout") || this.changedBoxModel || this.changedFlexLayout || this.changedGridLayout;
  }
  addSelector(selector2) {
    this.json.selectors.push(selector2);
    return selector2;
  }
  createSelector(data = {}) {
    return this.addSelector(new Selector(__spreadValues({
      checked: true
    }, data)));
  }
  removePropertyList(arr, removeIndex) {
    arr.splice(removeIndex, 1);
  }
  removeSelector(removeIndex) {
    this.removePropertyList(this.json.selectors, removeIndex);
  }
  enableHasChildren() {
    return true;
  }
  sortItem(arr, startIndex, targetIndex) {
    arr.splice(targetIndex + (startIndex < targetIndex ? -1 : 0), 0, ...arr.splice(startIndex, 1));
  }
  updateSelector(index2, data = {}) {
    this.json.selectors[+index2].reset(data);
  }
  traverse(item2, results, hasLayoutItem) {
    if (item2.isAttribute())
      return;
    if (!hasLayoutItem && item2.isLayoutItem() && !item2.isRootItem())
      return;
    results.push(item2);
    item2.children.forEach((child) => {
      this.traverse(child, results);
    });
  }
  tree(hasLayoutItem) {
    var results = [];
    this.children.forEach((item2) => {
      this.traverse(item2, results, hasLayoutItem);
    });
    return results;
  }
  reset(obj2, context = { origin: "*" }) {
    const isChanged = super.reset(obj2, context);
    if (this.hasChangedField("clip-path")) {
      this.setClipPathCache();
    } else if (this.hasChangedField("width", "height")) {
      if (this.cacheClipPath) {
        const d = this.cacheClipPath.clone().scale(this.json.width / this.cacheClipPathWidth, this.json.height / this.cacheClipPathHeight).d;
        this.json["clip-path"] = `path(${d})`;
        this.modelManager.setChanged("reset", this.id, { "clip-path": this.json["clip-path"] });
      }
    } else if (this.hasChangedField("background-image", "pattern")) {
      this.setBackgroundImageCache();
    }
    return isChanged;
  }
  setBackgroundImageCache() {
    let list2 = [];
    if (this.json.pattern) {
      const patternList = this.computed("pattern", (pattern) => {
        return Pattern.parseStyle(pattern).map((it) => {
          return BackgroundImage.parseStyle(STRING_TO_CSS(it.toCSS()));
        });
      });
      for (var i = 0, len2 = patternList.length; i < len2; i++) {
        list2.push.apply(list2, patternList[i]);
      }
    }
    if (this.json["background-image"]) {
      const backgroundList = this.computed("background-image", (backgroundImage2) => {
        return BackgroundImage.parseStyle(STRING_TO_CSS(backgroundImage2));
      });
      list2.push.apply(list2, backgroundList);
    }
    if (list2.length) {
      this.cacheBackgroundImage = BackgroundImage.joinCSS(list2);
    } else {
      this.cacheBackgroundImage = {};
    }
  }
  setClipPathCache() {
    var obj2 = ClipPath.parseStyle(this.json["clip-path"]);
    this.cacheClipPathObject = obj2;
    if (obj2.type === "path") {
      this.cacheClipPath = new PathParser(obj2.value.trim());
      this.cacheClipPathWidth = this.json.width;
      this.cacheClipPathHeight = this.json.height;
    }
  }
  setCache() {
    super.setCache();
    this.setClipPathCache();
  }
  get clipPathString() {
    if (!this.cacheClipPath) {
      this.setClipPathCache();
    }
    if (this.cacheClipPath) {
      return this.cacheClipPath.clone().scale(this.json.width / this.cacheClipPathWidth, this.json.height / this.cacheClipPathHeight).d;
    }
  }
}
class LayerModel extends DomModel {
  static getIcon() {
    return obj.rect;
  }
  getDefaultObject(obj2 = {}) {
    return super.getDefaultObject(__spreadValues({
      itemType: "layer",
      name: "New Layer",
      tagName: "div"
    }, obj2));
  }
  getDefaultTitle() {
    return "Layer";
  }
  getIcon() {
    return obj.rect;
  }
  toCloneObject() {
    return __spreadValues(__spreadValues({}, super.toCloneObject()), this.attrs("tagName"));
  }
}
class ArtBoard extends LayerModel {
  getDefaultObject(obj2 = {}) {
    return super.getDefaultObject(__spreadValues({
      itemType: "artboard",
      name: "New ArtBoard",
      width: 1e3,
      height: 1e3,
      "background-color": "white",
      "transform-style": "flat"
    }, obj2));
  }
  toCloneObject() {
    return __spreadValues(__spreadValues({}, super.toCloneObject()), this.attrs("name"));
  }
  getDefaultTitle() {
    return "ArtBoard";
  }
  getIcon() {
    return obj.artboard;
  }
  editable(editablePropertyName) {
    switch (editablePropertyName) {
      case "border":
      case "border-radius":
      case "backdrop-filter":
      case "box-shadow":
      case "clip-path":
        return false;
      case "artboard-size":
      case "layout":
        return true;
    }
    return super.editable(editablePropertyName);
  }
}
class CircleLayer extends LayerModel {
  getIcon() {
    return obj.lens;
  }
  getDefaultObject(obj2 = {}) {
    return super.getDefaultObject(__spreadValues({
      itemType: "circle",
      name: "New Circle",
      "border-radius": "100%"
    }, obj2));
  }
  getDefaultTitle() {
    return "Circle";
  }
}
class ImageLayer extends LayerModel {
  getIcon() {
    return obj.image;
  }
  getDefaultObject(obj2 = {}) {
    return super.getDefaultObject(__spreadValues({
      itemType: "image",
      name: "New Image",
      elementType: "image",
      src: ""
    }, obj2));
  }
  enableHasChildren() {
    return false;
  }
  getDefaultTitle() {
    return "Image";
  }
  getIcon() {
    return obj.image;
  }
  toCloneObject() {
    return __spreadValues(__spreadValues({}, super.toCloneObject()), this.attrs("src"));
  }
  resize() {
    this.reset({
      width: this.json.naturalWidth.clone(),
      height: this.json.naturalHeight.clone()
    });
  }
}
class RectLayer extends LayerModel {
  getIcon() {
    return obj.rect;
  }
  getDefaultObject(obj2 = {}) {
    return super.getDefaultObject(__spreadValues({
      itemType: "rect",
      name: "New Rect"
    }, obj2));
  }
  getDefaultTitle() {
    return "Rect";
  }
}
const expectedProperties = [
  "appearance",
  "border",
  "border-radius",
  "background-image",
  "backdrop-filter",
  "clip-path",
  "pattern",
  "box-shadow",
  "layout",
  "transform",
  "transform-origin",
  "perspective",
  "perspective-origin",
  "backdrop-filter",
  "box-model"
];
const expectedPropertiesKeys = {};
expectedProperties.forEach((key) => {
  expectedPropertiesKeys[key] = true;
});
class SVGItem extends LayerModel {
  getDefaultObject(obj2 = {}) {
    return super.getDefaultObject(__spreadValues({
      itemType: "svg",
      name: "New SVG",
      elementType: "svg",
      overflow: "visible",
      stroke: "black",
      "stroke-width": 1,
      fill: "transparent",
      "fill-rule": "nonzero",
      "text-anchor": "start",
      "stroke-dasharray": [],
      "stroke-dashoffset": 0
    }, obj2));
  }
  get isDragSelectable() {
    return this.isBooleanItem === false;
  }
  get isBooleanItem() {
    return Boolean(this.parent.is("boolean-path"));
  }
  editable(editablePropertyName) {
    if (expectedPropertiesKeys[editablePropertyName]) {
      return false;
    }
    switch (editablePropertyName) {
      case "svg-item":
        return true;
    }
    return super.editable(editablePropertyName);
  }
  toCloneObject() {
    return __spreadValues(__spreadValues({}, super.toCloneObject()), this.attrs("overflow", "stroke", "stroke-width", "svgfilter", "fill", "fill-rule", "fill-opacity", "stroke-linecap", "stroke-linejoin", "stroke-dashoffset", "stroke-dasharray", "text-anchor"));
  }
  getDefaultTitle() {
    return "SVG";
  }
  isSVG() {
    return true;
  }
  hasPoint(x2, y2) {
    const obj2 = this.attrs("fill", "stroke", "fill-opacity", "stroke-width");
    const fill = obj2.fill;
    const fillOpacity = obj2["fill-opacity"];
    const strokeWidth = obj2["stroke-width"];
    const isTransparent = fill === "transparent" || fillOpacity === 0 || Color.parse(fill).a === 0;
    const isZeroStroke = strokeWidth === 0;
    if (isTransparent) {
      return this.isPointInStroke(x2, y2);
    } else if (!isTransparent && !isZeroStroke) {
      return this.isPointInStroke(x2, y2) || this.isPointInFill(x2, y2);
    } else if (!isTransparent && isZeroStroke) {
      return this.isPointInFill(x2, y2);
    }
    return false;
  }
  isPointInFill(x2, y2) {
    const svgEl = this.getCache("svgElement");
    const pathEl = this.getCache("pathElement");
    if (pathEl) {
      const [localX, localY] = this.invertPoint([x2, y2, 0]);
      const point2 = svgEl.createSVGPoint();
      Object.assign(point2, { x: localX, y: localY });
      return pathEl.isPointInFill(point2);
    }
    return false;
  }
  isPointInStroke(x2, y2) {
    const svgEl = this.getCache("svgElement");
    const pathEl = this.getCache("pathElement");
    if (pathEl) {
      const [localX, localY] = this.invertPoint([x2, y2, 0]);
      const point2 = svgEl.createSVGPoint();
      Object.assign(point2, { x: localX, y: localY });
      return pathEl.isPointInStroke(point2);
    }
    return false;
  }
  convertStrokeToPath(distX = 10, distY = 10) {
    const attrs = this.attrs("name", "width", "parentId", "height", "x", "y", "transform", "stroke");
    attrs.fill = attrs.stroke;
    delete attrs.stroke;
    return __spreadProps(__spreadValues({
      itemType: "svg-path",
      "fill-rule": "evenodd"
    }, attrs), {
      x: Length.parse(attrs.x).add(distX),
      y: Length.parse(attrs.y).add(distY)
    });
  }
  toSVGPath() {
    const attrs = this.toCloneObject();
    delete attrs.id;
    delete attrs.itemType;
    return __spreadProps(__spreadValues({}, attrs), {
      d: this.d
    });
  }
}
class SVGPathItem extends SVGItem {
  getIcon() {
    return obj.edit;
  }
  getDefaultObject(obj2 = {}) {
    return super.getDefaultObject(__spreadValues({
      itemType: "svg-path",
      name: "New Path",
      "stroke-width": 1,
      d: "",
      totalLength: 0
    }, obj2));
  }
  enableHasChildren() {
    return false;
  }
  reset(json, context = { origin: "*" }) {
    const isChanged = super.reset(json, context);
    if (this.hasChangedField("d")) {
      this.cachePath = new PathParser(this.json.d);
      this.cacheWidth = this.json.width;
      this.cacheHeight = this.json.height;
    }
    return isChanged;
  }
  refreshMatrixCache() {
    super.refreshMatrixCache();
    if (this.hasChangedField("d")) {
      this.cachePath = new PathParser(this.json.d);
      this.cacheWidth = this.json.width;
      this.cacheHeight = this.json.height;
    } else if (this.hasChangedField("width", "height")) {
      this.json.d = this.cachePath.clone().scale(this.json.width / this.cacheWidth, this.json.height / this.cacheHeight).d;
      this.modelManager.setChanged("reset", this.id, { d: this.json.d });
    }
  }
  setCache() {
    super.setCache();
    this.cachePath = new PathParser(this.json.d);
    this.cacheWidth = this.json.width;
    this.cacheHeight = this.json.height;
  }
  get d() {
    if (!this.json.d) {
      return null;
    }
    if (!this.cachePath) {
      this.cachePath = new PathParser(this.json.d);
      this.cacheWidth = this.json.width;
      this.cacheHeight = this.json.height;
    }
    return this.cachePath.clone().scale(this.json.width / this.cacheWidth, this.json.height / this.cacheHeight).d;
  }
  toCloneObject() {
    return __spreadProps(__spreadValues({}, super.toCloneObject()), {
      d: this.json.d
    });
  }
  getDefaultTitle() {
    return "Path";
  }
}
class SVGTextItem extends SVGItem {
  getIcon() {
    return obj.title;
  }
  getDefaultObject(obj2 = {}) {
    return super.getDefaultObject(__spreadValues({
      itemType: "svg-text",
      name: "New Text",
      totalLength: 0,
      fill: "rgba(0, 0, 0, 1)",
      text: "Insert a text",
      "font-weight": Length.number(100),
      textLength: Length.em(0),
      lengthAdjust: "spacingAndGlyphs",
      "shape-inside": "",
      "shape-subtract": "",
      "shape-margin": "",
      "shape-padding": ""
    }, obj2));
  }
  enableHasChildren() {
    return false;
  }
  convert(json) {
    json = super.convert(json);
    json.textLength = Length.parse(json.textLength);
    return json;
  }
  toCloneObject() {
    return __spreadValues(__spreadValues({}, super.toCloneObject()), this.attrs("totalLength", "text", "textLength", "lengthAdjust", "shape-inside"));
  }
  getDefaultTitle() {
    return "Text";
  }
}
class SVGTextPathItem extends SVGItem {
  getIcon() {
    return obj.text_rotate;
  }
  getDefaultObject(obj2 = {}) {
    return super.getDefaultObject(__spreadValues({
      itemType: "svg-textpath",
      name: "New TextPath",
      d: "",
      totalLength: 0,
      fill: "rgba(0, 0, 0, 1)",
      text: "Insert a text",
      textLength: Length.em(0),
      lengthAdjust: "spacingAndGlyphs",
      startOffset: Length.em(0)
    }, obj2));
  }
  enableHasChildren() {
    return false;
  }
  refreshMatrixCache() {
    super.refreshMatrixCache();
    if (this.hasChangedField("d")) {
      this.cachePath = new PathParser(this.json.d);
      this.cacheWidth = this.json.width;
      this.cacheHeight = this.json.height;
    } else if (this.hasChangedField("width", "height")) {
      this.json.d = this.cachePath.clone().scale(this.json.width / this.cacheWidth, this.json.height / this.cacheHeight).d;
      this.modelManager.setChanged("reset", this.id, { d: this.json.d });
    }
  }
  get d() {
    if (!this.json.d) {
      return null;
    }
    if (!this.cachePath) {
      this.cachePath = new PathParser(this.json.d);
      this.cacheWidth = this.json.width;
      this.cacheHeight = this.json.height;
    }
    return this.cachePath.clone().scale(this.json.width / this.cacheWidth, this.json.height / this.cacheHeight).d;
  }
  convert(json) {
    json = super.convert(json);
    json.textLength = Length.parse(json.textLength);
    json.startOffset = Length.parse(json.startOffset);
    return json;
  }
  toCloneObject() {
    return __spreadValues(__spreadValues({}, super.toCloneObject()), this.attrs("totalLength", "d", "text", "textLength", "lengthAdjust", "startOffset"));
  }
  getDefaultTitle() {
    return "TextPath";
  }
}
class Component extends LayerModel {
  is(...itemType) {
    if (itemType.includes("component")) {
      return true;
    }
    return super.is(...itemType);
  }
  getProps() {
    return [];
  }
  static createComponent({ iconString, title: title2 = "Unknown Title", attrs = {}, enableHasChildren = false }) {
    return class extends Component {
      getIcon() {
        return iconString || iconUse("add");
      }
      getDefaultObject() {
        return super.getDefaultObject(__spreadValues({
          itemType: "NewComponent",
          name: "New Component"
        }, attrs));
      }
      toCloneObject() {
        return __spreadValues(__spreadValues({}, super.toCloneObject()), this.attrs(...Object.keys(attrs)));
      }
      enableHasChildren() {
        return enableHasChildren || false;
      }
      getDefaultTitle() {
        return title2;
      }
    };
  }
}
const DEFAULT_TEMPLATE = `
  <svg>
    <rect width="100%" height="100%" fill="black" />
  </svg>
`;
class TemplateLayer extends Component {
  getIcon() {
    return obj.auto_awesome;
  }
  getDefaultObject(obj2 = {}) {
    return super.getDefaultObject(__spreadValues({
      itemType: "template",
      name: "New Template",
      engine: "dom",
      template: DEFAULT_TEMPLATE,
      params: []
    }, obj2));
  }
  enableHasChildren() {
    return false;
  }
  getDefaultTitle() {
    return "Template";
  }
  getIcon() {
    return obj.auto_awesome;
  }
  editable(editablePropertyName) {
    switch (editablePropertyName) {
      case "font":
        return true;
    }
    return super.editable(editablePropertyName);
  }
  toCloneObject() {
    return __spreadValues(__spreadValues({}, super.toCloneObject()), this.attrs("template"));
  }
}
class TextLayer extends LayerModel {
  getIcon() {
    return obj.title;
  }
  getDefaultObject(obj2 = {}) {
    return super.getDefaultObject(__spreadValues({
      itemType: "text",
      name: "New Text",
      elementType: "p",
      content: ""
    }, obj2));
  }
  enableHasChildren() {
    return false;
  }
  getDefaultTitle() {
    return "Text";
  }
  toCloneObject() {
    return __spreadValues(__spreadValues({}, super.toCloneObject()), this.attrs("content"));
  }
  editable(editablePropertyName) {
    switch (editablePropertyName) {
      case "svg-item":
      case "transform":
      case "transform-origin":
      case "perspective":
      case "perspective-origin":
      case "layout":
        return false;
      case "font":
      case "font-spacing":
      case "text-style":
      case "text-shadow":
      case "text-fill":
      case "text-clip":
      case "background-image":
      case "box-model":
      case "border":
      case "border-radius":
      case "backdrop-filter":
      case "background-image":
      case "pattern":
        return true;
    }
    return super.editable(editablePropertyName);
  }
}
class SVGPolygonItem extends SVGItem {
  getIcon() {
    return obj.edit;
  }
  getDefaultObject(obj2 = {}) {
    return super.getDefaultObject(__spreadValues({
      itemType: "polygon",
      name: "New Polygon",
      "stroke-width": 1,
      count: 3
    }, obj2));
  }
  convert(json) {
    json = super.convert(json);
    if (json.count)
      json.count = +json.count;
    return json;
  }
  enableHasChildren() {
    return false;
  }
  get editablePath() {
    return false;
  }
  get d() {
    const { width: width2, height: height2, count } = this.json;
    return PathParser.makePolygon(width2, height2, count).d;
  }
  toCloneObject() {
    return __spreadValues(__spreadValues({}, super.toCloneObject()), this.attrs("count"));
  }
  getDefaultTitle() {
    return "Polygon";
  }
  isPointInPath(point2) {
    const localPoint = transformMat4([], point2, this.absoluteMatrixInverse);
    return this.cachePath.isPointInPath({ x: localPoint[0], y: localPoint[1] }, this.json["stroke-width"] || 0);
  }
}
class SVGStarItem extends SVGItem {
  getIcon() {
    return obj.star;
  }
  getDefaultObject(obj2 = {}) {
    return super.getDefaultObject(__spreadValues({
      itemType: "star",
      name: "New Star",
      "stroke-width": 1,
      d: "",
      isCurve: false,
      count: 5,
      radius: 0.5,
      tension: 0.5
    }, obj2));
  }
  convert(json) {
    json = super.convert(json);
    if (json.count)
      json.count = +json.count;
    if (json.radius)
      json.radius = +json.radius;
    if (json.tension)
      json.tension = +json.tension;
    return json;
  }
  enableHasChildren() {
    return false;
  }
  get d() {
    const { width: width2, height: height2, count, radius, tension, isCurve } = this.json;
    let newPath = "";
    if (isCurve) {
      newPath = PathParser.makeCurvedStar(width2, height2, count, radius, tension).d;
    } else {
      newPath = PathParser.makeStar(width2, height2, count, radius).d;
    }
    return newPath;
  }
  toCloneObject() {
    return __spreadValues(__spreadValues({}, super.toCloneObject()), this.attrs("count", "radius", "tension", "isCurve"));
  }
  getDefaultTitle() {
    return "Star";
  }
}
var isNdarray$2 = function(arr) {
  if (!arr)
    return false;
  if (!arr.dtype)
    return false;
  var re = new RegExp("function View[0-9]+d(:?" + arr.dtype + ")+");
  return re.test(String(arr.constructor));
};
var isNdarrayLike$3 = function(arr) {
  if (!arr)
    return false;
  return arr.data !== void 0 && Array.isArray(arr.shape) && arr.offset !== void 0 && arr.stride !== void 0;
};
var isArrayLike$5 = function isArrayLike(data) {
  return Array.isArray(data) || ArrayBuffer.isView(data);
};
var isNdarray$1 = isNdarray$2;
var isNdarrayLike$2 = isNdarrayLike$3;
var isArrayLike$4 = isArrayLike$5;
function inferType$5(x2) {
  if (!x2) {
    return void 0;
  }
  if (isNdarray$1(x2) || isNdarrayLike$2(x2)) {
    if (x2.dtype === "generic") {
      return inferType$5.GENERIC_NDARRAY;
    }
    return inferType$5.NDARRAY;
  } else {
    if (isArrayLike$4(x2)) {
      return inferType$5.ARRAY_OF_ARRAYS;
    }
    throw new Error("Unhandled data type. Got type: " + typeof x2);
  }
}
inferType$5.ARRAY_OF_ARRAYS = "Arr";
inferType$5.NDARRAY = "Nd";
inferType$5.GENERIC_NDARRAY = "GenNd";
inferType$5.PACKED = "PackArr";
var inferType_1 = inferType$5;
var isArrayLike$3 = isArrayLike$5;
function capitalize(str) {
  return str[0].toUpperCase() + str.slice(1);
}
var cacheKey = function(nurbs2, debug, checkBounds, pointType, weightType, knotType) {
  var d;
  var degreeParts = [];
  var hasAnyKnots = false;
  for (d = 0; d < nurbs2.splineDimension; d++) {
    var hasKnots = isArrayLike$3(nurbs2.knots) && isArrayLike$3(nurbs2.knots[d]);
    if (hasKnots)
      hasAnyKnots = true;
    degreeParts.push("Deg" + nurbs2.degree[d] + (hasKnots ? "" : "Uniform") + capitalize(nurbs2.boundary[d]));
  }
  var parts = [
    [
      hasAnyKnots ? "NU" : "",
      nurbs2.weights ? "RBS" : "BS"
    ].join("") + nurbs2.dimension + "D",
    degreeParts.join("_")
  ];
  if (pointType) {
    parts.push(pointType + "Pts");
  }
  if (weightType) {
    parts.push(weightType + "Wts");
  }
  if (knotType) {
    parts.push(knotType + "Kts");
  }
  if (debug) {
    parts.push("debug");
  }
  if (checkBounds) {
    parts.push("chk");
  }
  return parts.join("_");
};
var createVariable$1 = function createVariable(name2, nurbs2) {
  return function(i, period) {
    if (i !== void 0 && !Array.isArray(i))
      i = [i];
    var dimAccessors = [];
    for (var j = 0; j < i.length; j++) {
      dimAccessors.push(createVariable.sum(i[j]));
    }
    if (period) {
      for (i = 0; i < dimAccessors.length; i++) {
        if (period[i] === void 0)
          continue;
        dimAccessors[i] = "(" + dimAccessors[i] + " + " + period[i] + ") % " + period[i];
      }
    }
    return name2 + dimAccessors.join("_");
  };
};
createVariable$1.sum = function(parts) {
  parts = Array.isArray(parts) ? parts : [parts];
  parts = parts.filter(function(part) {
    return part !== void 0 && part !== 0;
  });
  if (parts.length === 0)
    parts.push(0);
  return parts.join(" + ");
};
var variable$3 = createVariable$1;
var inferType$4 = inferType_1;
var createVariable2 = variable$3;
function wrapAccessor(callback) {
  return function(i, period) {
    if (i !== void 0 && !Array.isArray(i))
      i = [i];
    var dimAccessors = [];
    for (var j = 0; j < i.length; j++) {
      dimAccessors.push(createVariable2.sum(i[j]));
    }
    if (period) {
      for (i = 0; i < dimAccessors.length; i++) {
        if (period[i] === void 0)
          continue;
        dimAccessors[i] = "(" + dimAccessors[i] + " + " + period[i] + ") % " + period[i];
      }
    }
    return callback(dimAccessors);
  };
}
function createAccessor(name2, data) {
  var i;
  if (!data)
    return void 0;
  switch (inferType$4(data)) {
    case inferType$4.ARRAY_OF_ARRAYS:
      return wrapAccessor(function(accessors) {
        return name2 + "[" + accessors.join("][") + "]";
      });
    case inferType$4.GENERIC_NDARRAY:
      return wrapAccessor(function(accessors) {
        return name2 + ".get(" + accessors.join(",") + ")";
      });
    case inferType$4.NDARRAY:
      return wrapAccessor(function(accessors) {
        var code2 = [name2 + "Offset"];
        for (i = 0; i < accessors.length; i++) {
          code2.push(name2 + "Stride" + i + " * (" + accessors[i] + ")");
        }
        return name2 + "[" + code2.join(" + ") + "]";
      });
    case inferType$4.PACKED:
    default:
      return void 0;
  }
}
var createAccessors$1 = function(nurbs2) {
  var accessors = {};
  var accessor;
  accessor = createAccessor("x", nurbs2.points);
  if (accessor)
    accessors.point = accessor;
  accessor = createAccessor("w", nurbs2.weights);
  if (accessor)
    accessors.weight = accessor;
  accessor = createAccessor("k", nurbs2.knots);
  if (accessor)
    accessors.knot = accessor;
  return accessors;
};
var args = [];
var tmp = [];
var numericalDerivative$1 = function numericalDerivative(out, order, dimension) {
  if (order !== 1) {
    throw new Error("Numerical derivative not implemented for order n = " + order + ".");
  }
  var i;
  var h = arguments[this.splineDimension + 3] === void 0 ? 1e-4 : arguments[this.splineDimension + 3];
  args.length = this.splineDimension;
  for (i = 0; i < this.splineDimension; i++) {
    args[i + 1] = arguments[i + 3];
  }
  var domain = this.domain;
  var k0 = domain[dimension][0];
  var k1 = domain[dimension][1];
  var tm, tp, T;
  var t0 = args[dimension + 1];
  var dt = (k1 - k0) * h;
  if (this.boundary[dimension] === "closed") {
    T = k1 - k0;
    tm = k0 + (t0 - k0 - dt + T) % T;
    tp = k0 + (t0 - k0 + dt + T) % T;
    dt *= 2;
  } else {
    tm = Math.min(k1, Math.max(k0, t0 - dt));
    tp = Math.min(k1, Math.max(k0, t0 + dt));
    dt = tp - tm;
  }
  args[dimension + 1] = tm;
  args[0] = tmp;
  this.evaluate.apply(null, args);
  args[dimension + 1] = tp;
  args[0] = out;
  this.evaluate.apply(null, args);
  for (i = 0; i < this.dimension; i++) {
    out[i] = (out[i] - tmp[i]) / dt;
  }
  return out;
};
var ndloop$2 = function ndloop(n, callback) {
  for (var m = 1, k = 0, i = []; k < n.length; k++) {
    m *= Array.isArray(n[k]) ? n[k][1] - n[k][0] : n[k];
    i[k] = Array.isArray(n[k]) ? n[k][0] : 0;
  }
  for (var ptr = 0; ptr < m; ptr++) {
    callback(i.slice());
    for (k = n.length - 1; k >= 0; k--) {
      if (i[k] === (Array.isArray(n[k]) ? n[k][1] : n[k]) - 1) {
        i[k] = Array.isArray(n[k]) ? n[k][0] : 0;
      } else {
        i[k]++;
        break;
      }
    }
  }
};
var inferType$3 = inferType_1;
var accessorPreamble$3 = function(nurbs2, variableName, propertyName, data) {
  var i;
  var code2 = [];
  switch (inferType$3(data)) {
    case inferType$3.NDARRAY:
      code2.push("  var " + variableName + " = " + propertyName + ".data;");
      code2.push("  var " + variableName + "Offset = " + propertyName + ".offset;");
      for (i = 0; i < data.dimension; i++) {
        code2.push("  var " + variableName + "Stride" + i + " = " + propertyName + ".stride[" + i + "];");
      }
      break;
    case inferType$3.ARRAY_OF_ARRAYS:
      code2.push("  var " + variableName + " = " + propertyName + ";");
  }
  return code2.join("\n");
};
var isNdarrayLike$1 = isNdarrayLike$3;
var sizeGetter$3 = function(data, dataVariableName, dimension) {
  if (!data) {
    return "this.size[" + dimension + "]";
  } else if (isNdarrayLike$1(data)) {
    return dataVariableName + ".shape[" + dimension + "]";
  } else {
    var str = dataVariableName;
    for (var i = 0; i < dimension; i++) {
      str += "[0]";
    }
    return str + ".length";
  }
};
var ndloop$1 = ndloop$2;
var variable$2 = variable$3;
var accessorPreamble$2 = accessorPreamble$3;
var inferType$2 = inferType_1;
var isArrayLike$2 = isArrayLike$5;
var sizeGetter$2 = sizeGetter$3;
var evaluatorCache = {};
var codeCache = {};
var evaluate = function(cacheKey2, nurbs2, accessors, debug, checkBounds, isBasis, derivative) {
  var splineDimension = nurbs2.splineDimension;
  var i, j, n, m, d, kvar;
  var points2 = nurbs2.points;
  var degree = nurbs2.degree;
  var weights = nurbs2.weights;
  var hasWeights = weights !== void 0;
  var knots = nurbs2.knots;
  var spaceDimension = nurbs2.dimension;
  var boundary = nurbs2.boundary;
  if (derivative !== void 0 && derivative !== null) {
    if (!Array.isArray(derivative)) {
      derivative = [derivative];
    }
    var totalDerivativeOrder = 0;
    for (i = 0; i < splineDimension; i++) {
      if (derivative[i] === void 0)
        derivative[i] = 0;
      totalDerivativeOrder += derivative[i];
    }
    if (hasWeights && totalDerivativeOrder > 1) {
      throw new Error("Analytical derivative not implemented for rational b-splines with order n = " + totalDerivativeOrder + ".");
    }
  }
  if (isBasis)
    cacheKey2 = "Basis" + cacheKey2;
  if (derivative)
    cacheKey2 = "Der" + derivative.join("_") + "_" + cacheKey2;
  var cachedEvaluator = evaluatorCache[cacheKey2];
  if (debug) {
    var logger = typeof debug === "function" ? debug : console.log;
  }
  if (cachedEvaluator) {
    if (debug) {
      logger(codeCache[cacheKey2]);
    }
    return cachedEvaluator.bind(nurbs2);
  }
  var code2 = [];
  var functionName = "evaluate" + cacheKey2;
  var pointAccessor = accessors.point;
  if (isBasis) {
    pointAccessor = function(src, period) {
      var terms = [];
      for (var i2 = 0; i2 < src.length; i2++) {
        var accessor = src[i2];
        var terms2 = [];
        for (var j2 = 0; j2 < accessor.length; j2++) {
          if (accessor[j2] !== 0)
            terms2.push(accessor[j2]);
        }
        accessor = terms2.join(" + ");
        if (period[i2]) {
          accessor = "(" + accessor + " + " + period[i2] + ") % " + period[i2];
        }
        terms.push(accessor + " === " + indexVar(i2));
      }
      return "((" + terms.join(" && ") + ") ? 1 : 0)";
    };
  }
  var weightAccessor = accessors.weight;
  var knotAccessor = accessors.knot;
  var knotVar = variable$2("k");
  var pointVar = variable$2("x");
  var weightVar = variable$2("w");
  var indexVar = variable$2("i");
  var tVar = variable$2("t");
  var domainVar = debug ? "domain" : "d";
  var sizeVar = variable$2(debug ? "size" : "s");
  var knotIndex = variable$2(debug ? "knotIndex" : "j");
  var allDimensionUniform = true;
  for (d = 0; d < splineDimension; d++) {
    if (isArrayLike$2(knots) && isArrayLike$2(knots[d])) {
      allDimensionUniform = false;
    }
  }
  function line2(str) {
    code2.push("  " + (str || ""));
  }
  function debugLine(str) {
    if (debug)
      line2(str);
  }
  if (isBasis) {
    var indexArgs = [];
  }
  var parameterArgs = [];
  for (i = 0; i < splineDimension; i++) {
    if (isBasis) {
      indexArgs.push(indexVar([i]));
    }
    parameterArgs.push(tVar([i]));
  }
  code2.push("function " + functionName + " (" + (isBasis ? "" : "out, ") + parameterArgs.join(", ") + (isBasis ? ", " + indexArgs.join(", ") : "") + ") {");
  line2("var h, m, a, b;");
  if (checkBounds) {
    line2("var " + domainVar + " = this.domain;");
    line2("for (var i = 0; i < this.splineDimension; i++) {");
    line2("  a = arguments[i + 1];");
    line2("  if (a < " + domainVar + "[i][0] || a > " + domainVar + "[i][1] || a === undefined || isNaN(a)) {");
    line2("    throw new Error('Invalid Spline parameter in dimension '+i+'. Valid domain is ['+" + domainVar + "[i][0]+', '+" + domainVar + "[i][1]+']. but got t'+i+' = '+arguments[i + 1]+'.');");
    line2("  }");
    line2("}");
  }
  for (d = 0; d < splineDimension; d++) {
    line2("var " + sizeVar(d) + " = " + sizeGetter$2(points2, "this.points", d) + ";");
  }
  code2.push(accessorPreamble$2(nurbs2, "x", "this.points", points2));
  if (hasWeights) {
    code2.push(accessorPreamble$2(nurbs2, "w", "this.weights", weights));
  }
  if (!allDimensionUniform) {
    code2.push(accessorPreamble$2(nurbs2, "k", "this.knots", knots));
  }
  function ternary(cond, a, b) {
    return "(" + cond + ") ? (" + a + ") : (" + b + ")";
  }
  var hasKnots = [];
  for (d = 0; d < splineDimension; d++) {
    switch (inferType$2(knots)) {
      case inferType$2.NDARRAY:
        hasKnots[d] = true;
        break;
      case inferType$2.ARRAY_OF_ARRAYS:
        hasKnots[d] = isArrayLike$2(knots[d]);
        break;
    }
  }
  for (d = 0; d < splineDimension; d++) {
    if (hasKnots[d]) {
      debugLine("\n  // Bisect to locate the knot interval in dimension " + d + "\n");
      line2("var " + knotIndex(d) + " = 0;");
      line2("h = " + sizeVar(d) + ";");
      line2("while(h > " + knotIndex(d) + " + 1) {");
      line2("  m = 0.5 * (h + " + knotIndex(d) + ") | 0;");
      line2("  if (" + knotAccessor([d, "m"]) + " > " + tVar(d) + ") h = m;");
      line2("  else " + knotIndex(d) + " = m;");
      line2("}");
      debugLine("\n  // Fetch knots for dimension " + d + "\n");
      for (i = -degree[d] + 1; i <= degree[d]; i++) {
        if (boundary[d] === "closed") {
          if (i < 0) {
            line2("var " + knotVar([d, i + degree[d] - 1]) + " = " + ternary(knotIndex(d) + " < " + -i, knotAccessor([d, 0]) + " + " + knotAccessor([d, [sizeVar(d), knotIndex(d), i]]) + " - " + knotAccessor([d, [sizeVar(d)]]), knotAccessor([d, [knotIndex(d), i]])) + ";");
          } else if (i > 0) {
            line2("var " + knotVar([d, i + degree[d] - 1]) + " = " + ternary(knotIndex(d) + " + " + i + " > " + sizeVar(d), knotAccessor([d, sizeVar(d)]) + " + " + knotAccessor([d, i + " + " + knotIndex(d) + " - " + sizeVar(d)]) + " - " + knotAccessor([d, 0]), knotAccessor([d, [knotIndex(d), i]])) + ";");
          } else {
            line2("var " + knotVar([d, i + degree[d] - 1]) + " = " + knotAccessor([d, [knotIndex(d), i]]) + ";");
          }
        } else {
          line2("var " + knotVar([d, i + degree[d] - 1]) + " = " + knotAccessor([d, [knotIndex(d), i]]) + ";");
        }
      }
    } else {
      debugLine("\n  // Directly compute knot interval for dimension " + d + "\n");
      if (boundary[d] === "closed") {
        line2(knotIndex(d) + " = (" + tVar(d) + " | 0) % " + sizeVar(d) + ";");
      } else {
        line2(knotIndex(d) + " = (" + tVar(d) + " | 0);");
        line2("if (" + knotIndex(d) + " < " + degree[d] + ") " + knotIndex(d) + " = " + degree[d] + ";");
        line2("if (" + knotIndex(d) + " > " + sizeVar(d) + " - 1) " + knotIndex(d) + " = " + sizeVar(d) + " - 1;");
      }
      debugLine("\n  // Compute and clamp knots for dimension " + d + "\n");
      for (i = -degree[d] + 1; i <= degree[d]; i++) {
        kvar = knotVar([d, i + degree[d] - 1]);
        line2("var " + kvar + " = " + knotIndex(d) + " + " + i + ";");
      }
      if (boundary[d] === "clamped") {
        for (i = -degree[d] + 1; i <= degree[d]; i++) {
          kvar = knotVar([d, i + degree[d] - 1]);
          if (i < 0) {
            line2("if (" + kvar + " < " + degree[d] + ") " + kvar + " = " + degree[d] + ";");
          }
          if (i > 0) {
            line2("if (" + kvar + " > " + sizeVar(d) + ") " + kvar + " = " + sizeVar(d) + ";");
          }
        }
      }
      if (boundary[d] === "closed") {
        debugLine("\n  // Wrap the B-Spline parameter for closed boundary");
        line2(tVar(d) + " %= " + sizeVar(d) + ";");
      }
    }
  }
  for (d = 0, n = []; d < splineDimension; d++) {
    n[d] = degree[d] + 1;
  }
  if (hasWeights) {
    debugLine("\n  // Fetch weights\n");
    ndloop$1(n, function(dst) {
      var readIdx = [];
      var period = [];
      for (var d2 = 0; d2 < splineDimension; d2++) {
        readIdx[d2] = [knotIndex(d2), dst[d2] - degree[d2]];
        if (boundary[d2] === "closed" && dst[d2] - degree[d2] < 0)
          period[d2] = sizeVar(d2);
      }
      line2("var " + weightVar(dst) + " = " + weightAccessor(readIdx, period) + ";");
    });
  }
  if (debug) {
    if (hasWeights) {
      line2("\n  // Fetch points and project into homogeneous (weighted) coordinates\n");
    } else {
      line2("\n  // Fetch points\n");
    }
  }
  ndloop$1(n, function(dst) {
    var readIdx = [];
    var period = [];
    for (var d2 = 0; d2 < splineDimension; d2++) {
      readIdx[d2] = [knotIndex(d2), dst[d2] - degree[d2]];
      if (boundary[d2] === "closed" && dst[d2] - degree[d2] < 0)
        period[d2] = sizeVar(d2);
    }
    if (isBasis) {
      if (hasWeights) {
        line2("var " + pointVar(dst) + " = " + pointAccessor(readIdx, period) + " * " + weightVar(dst) + ";");
      } else {
        line2("var " + pointVar(dst) + " = " + pointAccessor(readIdx, period) + ";");
      }
    } else {
      for (d2 = 0; d2 < spaceDimension; d2++) {
        var dstWithDim = dst.concat(d2);
        readIdx[splineDimension] = d2;
        if (hasWeights) {
          line2("var " + pointVar(dstWithDim) + " = " + pointAccessor(readIdx, period) + " * " + weightVar(dst) + ";");
        } else {
          line2("var " + pointVar(dstWithDim) + " = " + pointAccessor(readIdx, period) + ";");
        }
      }
    }
  });
  debugLine("\n");
  debugLine("// Perform De Boor's algorithm");
  for (d = n.length - 1; d >= 0; d--) {
    n[d] = [degree[d], degree[d] + 1];
    for (i = 0; i < degree[d]; i++) {
      debugLine("\n  // Degree " + degree[d] + " evaluation in dimension " + d + ", step " + (i + 1) + "\n");
      for (j = degree[d]; j > i; j--) {
        var isDerivative = derivative && degree[d] - i - derivative[d] <= 0;
        if (isDerivative) {
          line2("m = 1 / (" + knotVar([d, j - i + degree[d] - 1]) + " - " + knotVar([d, j - 1]) + ");");
          if (hasWeights) {
            line2("a = (" + tVar(d) + " - " + knotVar([d, j - 1]) + ") * m;");
            line2("b = 1 - a;");
          }
        } else {
          line2("a = (" + tVar(d) + " - " + knotVar([d, j - 1]) + ") / (" + knotVar([d, j - i + degree[d] - 1]) + " - " + knotVar([d, j - 1]) + ");");
          line2("b = 1 - a;");
        }
        if (hasWeights) {
          ndloop$1(n, function(ii) {
            var ij = ii.slice();
            var ij1 = ii.slice();
            ij[d] = j;
            ij1[d] = j - 1;
            if (isDerivative && hasWeights)
              line2("h = " + weightVar(ij) + ";");
            line2(weightVar(ij) + " = b * " + weightVar(ij1) + " + a * " + weightVar(ij) + ";");
          });
        }
        ndloop$1(n, function(ii) {
          var weightFactor, pt1, pt2;
          var ij = ii.slice();
          var ij1 = ii.slice();
          ij[d] = j;
          ij1[d] = j - 1;
          if (isDerivative) {
            var derivCoeff = i + 1;
            if (isBasis) {
              weightFactor = hasWeights ? "h * " + weightVar(ij1) + " / " + weightVar(ij) + " * " : "";
              pt1 = pointVar(ij) + (hasWeights ? " / h" : "");
              pt2 = pointVar(ij1) + (hasWeights ? " / " + weightVar(ij1) : "");
              line2(pointVar(ij) + " = " + derivCoeff + " * " + weightFactor + "(" + pt1 + " - " + pt2 + ") * m;");
            } else {
              var ijWithDimension = ij.slice();
              var ij1WithDimension = ij1.slice();
              for (m = 0; m < spaceDimension; m++) {
                ijWithDimension[splineDimension] = ij1WithDimension[splineDimension] = m;
                weightFactor = hasWeights ? "h * " + weightVar(ij1) + " / " + weightVar(ij) + " * " : "";
                pt1 = pointVar(ijWithDimension) + (hasWeights ? " / h" : "");
                pt2 = pointVar(ij1WithDimension) + (hasWeights ? " / " + weightVar(ij1) : "");
                line2(pointVar(ijWithDimension) + " = " + derivCoeff + " * " + weightFactor + "(" + pt1 + " - " + pt2 + ") * m;");
              }
            }
          } else {
            if (isBasis) {
              line2(pointVar(ij) + " = b * " + pointVar(ij1) + " + a * " + pointVar(ij) + ";");
            } else {
              for (m = 0; m < spaceDimension; m++) {
                ij[splineDimension] = ij1[splineDimension] = m;
                line2(pointVar(ij) + " = b * " + pointVar(ij1) + " + a * " + pointVar(ij) + ";");
              }
            }
          }
        });
        debugLine("\n");
      }
    }
  }
  if (debug) {
    if (hasWeights) {
      line2("\n  // Project back from homogeneous coordinates and return final output\n");
    } else {
      line2("\n  // Return final output\n");
    }
  }
  if (isBasis) {
    if (hasWeights) {
      line2("return " + pointVar(degree) + " / " + weightVar(degree) + ";");
    } else {
      line2("return " + pointVar(degree) + ";");
    }
  } else {
    for (d = 0; d < spaceDimension; d++) {
      if (hasWeights) {
        line2("out[" + d + "] = " + pointVar(degree.concat([d])) + " / " + weightVar(degree) + ";");
      } else {
        line2("out[" + d + "] = " + pointVar(degree.concat([d])) + ";");
      }
    }
  }
  if (!isBasis) {
    line2("return out;");
  }
  code2.push("}");
  if (debug) {
    var codeStr = code2.join("\n");
    logger(codeStr);
    codeCache[cacheKey2] = codeStr;
  }
  var evaluator = new Function([code2.join("\n"), "; return ", functionName].join(""))();
  evaluatorCache[cacheKey2] = evaluator;
  return evaluator.bind(nurbs2);
};
var transformerCache = {};
var accessorPreamble$1 = accessorPreamble$3;
var sizeGetter$1 = sizeGetter$3;
var variable$1 = variable$3;
var transform = function createTransform(cacheKey2, nurbs2, accessors, debug) {
  var i, j, iterator, iterators, terms, n, rvalue, lvalue;
  var cachedTransformer = transformerCache[cacheKey2];
  if (cachedTransformer) {
    return cachedTransformer.bind(nurbs2);
  }
  var code2 = [];
  var functionName = "transform" + cacheKey2;
  code2.push("function " + functionName + "(m) {");
  code2.push("var i, w;");
  code2.push(accessorPreamble$1(nurbs2, "x", "this.points", nurbs2.points));
  var sizeVar = variable$1(debug ? "size" : "s");
  for (i = 0; i < nurbs2.splineDimension; i++) {
    code2.push("var " + sizeVar(i) + " = " + sizeGetter$1(nurbs2.points, "this.points", i) + ";");
  }
  iterators = [];
  for (i = 0; i < nurbs2.splineDimension; i++) {
    iterator = "i" + i;
    iterators.push(iterator);
    code2.push("for (" + iterator + " = " + sizeVar(i) + "- 1; " + iterator + " >= 0; " + iterator + "--) {");
  }
  for (i = 0; i < nurbs2.dimension; i++) {
    code2.push("x" + i + " = " + accessors.point(iterators.concat([i])));
  }
  terms = [];
  for (i = 0; i < nurbs2.dimension; i++) {
    terms.push("m[" + ((nurbs2.dimension + 1) * (i + 1) - 1) + "] * x" + i);
  }
  terms.push("m[" + ((nurbs2.dimension + 1) * (nurbs2.dimension + 1) - 1) + "]");
  code2.push("var w = (" + terms.join(" + ") + ") || 1.0;");
  for (i = 0; i < nurbs2.dimension; i++) {
    terms = [];
    n = nurbs2.dimension;
    for (j = 0; j < n; j++) {
      terms.push("m[" + (j * (n + 1) + i) + "] * x" + j);
    }
    terms.push("m[" + (j * (n + 1) + i) + "]");
    lvalue = accessors.point(iterators.concat([i]));
    rvalue = "(" + terms.join(" + ") + ") / w";
    code2.push(lvalue + " = " + rvalue + ";");
  }
  for (i = nurbs2.splineDimension - 1; i >= 0; i--) {
    code2.push("}");
  }
  code2.push("return this;");
  code2.push("}");
  var transform2 = new Function([code2.join("\n"), "; return ", functionName].join(""))();
  if (debug)
    console.log(code2.join("\n"));
  transformerCache[cacheKey2] = transform2;
  return transform2.bind(nurbs2);
};
var ndloop2 = ndloop$2;
var variable = variable$3;
var accessorPreamble = accessorPreamble$3;
var inferType$1 = inferType_1;
var isArrayLike$1 = isArrayLike$5;
var sizeGetter = sizeGetter$3;
var supportCache = {};
var support = function(cacheKey2, nurbs2, accessors, debug, checkBounds) {
  var cachedSupport = supportCache[cacheKey2];
  if (cachedSupport) {
    return cachedSupport.bind(nurbs2);
  }
  var degree = nurbs2.degree;
  var knots = nurbs2.knots;
  var splineDimension = nurbs2.splineDimension;
  var boundary = nurbs2.boundary;
  var i, n, d;
  var code2 = [];
  var functionName = "support" + cacheKey2;
  var knotAccessor = accessors.knot;
  var tVar = variable("t");
  var domainVar = debug ? "domain" : "d";
  var sizeVar = variable(debug ? "size" : "s");
  var knotIndex = variable(debug ? "knotIndex" : "i");
  var allDimensionUniform = true;
  for (d = 0; d < splineDimension; d++) {
    if (isArrayLike$1(knots) && isArrayLike$1(knots[d])) {
      allDimensionUniform = false;
    }
  }
  function line2(str) {
    code2.push("  " + (str || ""));
  }
  var parameterArgs = [];
  for (i = 0; i < splineDimension; i++) {
    parameterArgs.push(tVar([i]));
  }
  code2.push("function " + functionName + " (out, " + parameterArgs.join(", ") + ") {");
  var c2 = 0;
  function pushSupport(args2, period) {
    if (period === void 0) {
      line2("out[" + c2++ + "] = " + args2.join(" + ") + ";");
    } else {
      line2("out[" + c2++ + "] = (" + args2.join(" + ") + " + " + period + ") % " + period + ";");
    }
  }
  line2("var h, m;");
  line2("var c = 0;");
  if (checkBounds) {
    line2("var " + domainVar + " = this.domain;");
    line2("for (var i = 0; i < this.splineDimension; i++) {");
    line2("  a = arguments[i + 1];");
    line2("  if (a < " + domainVar + "[i][0] || a > " + domainVar + "[i][1] || a === undefined || isNaN(a)) {");
    line2("    throw new Error('Invalid Spline parameter in dimension '+i+'. Valid domain is ['+" + domainVar + "[i][0]+', '+" + domainVar + "[i][1]+']. but got t'+i+' = '+arguments[i + 1]+'.');");
    line2("  }");
    line2("}");
  }
  for (d = 0; d < splineDimension; d++) {
    line2("var " + sizeVar(d) + " = " + sizeGetter(nurbs2.points, "this.points", d) + ";");
  }
  if (!allDimensionUniform) {
    code2.push(accessorPreamble(nurbs2, "k", "this.knots", knots));
  }
  var hasKnots = [];
  for (d = 0; d < splineDimension; d++) {
    switch (inferType$1(knots)) {
      case inferType$1.NDARRAY:
        hasKnots[d] = true;
        break;
      case inferType$1.ARRAY_OF_ARRAYS:
        hasKnots[d] = isArrayLike$1(knots[d]);
        break;
    }
  }
  for (d = 0; d < splineDimension; d++) {
    if (hasKnots[d]) {
      line2("var " + knotIndex(d) + " = 0;");
      line2("h = " + sizeVar(d) + ";");
      line2("while(h > " + knotIndex(d) + " + 1) {");
      line2("  m = 0.5 * (h + " + knotIndex(d) + ") | 0;");
      line2("  if (" + knotAccessor([d, "m"]) + " > " + tVar(d) + ") h = m;");
      line2("  else " + knotIndex(d) + " = m;");
      line2("}");
    } else {
      if (boundary[d] === "closed") {
        line2(knotIndex(d) + " = (" + tVar(d) + " | 0) % " + sizeVar(d) + ";");
      } else {
        line2(knotIndex(d) + " = (" + tVar(d) + " | 0);");
        line2("if (" + knotIndex(d) + " < " + degree[d] + ") " + knotIndex(d) + " = " + degree[d] + ";");
        line2("if (" + knotIndex(d) + " > " + sizeVar(d) + " - 1) " + knotIndex(d) + " = " + sizeVar(d) + " - 1;");
      }
    }
  }
  for (d = 0, n = []; d < splineDimension; d++) {
    n[d] = degree[d] + 1;
  }
  ndloop2(n, function(dst) {
    var readIdx = [];
    var period = [];
    for (var d2 = 0; d2 < splineDimension; d2++) {
      readIdx[d2] = [knotIndex(d2), dst[d2] - degree[d2]];
      if (boundary[d2] === "closed" && dst[d2] - degree[d2] < 0)
        period[d2] = sizeVar(d2);
    }
    for (d2 = 0; d2 < splineDimension; d2++) {
      pushSupport(readIdx[d2], period[d2]);
    }
  });
  line2("out.length = " + c2 + ";");
  line2("return out;");
  code2.push("}");
  if (debug)
    console.log(code2.join("\n"));
  var evaluator = new Function([code2.join("\n"), "; return ", functionName].join(""))();
  supportCache[cacheKey2] = evaluator;
  return evaluator.bind(nurbs2);
};
var inferType = inferType_1;
var computeCacheKey = cacheKey;
var isNdarray = isNdarray$2;
var isNdarrayLike = isNdarrayLike$3;
var createAccessors = createAccessors$1;
var numericalDerivative2 = numericalDerivative$1;
var isArrayLike2 = isArrayLike$5;
var createEvaluator = evaluate;
var createTransform2 = transform;
var createSupport = support;
var BOUNDARY_TYPES = {
  open: "open",
  closed: "closed",
  clamped: "clamped"
};
function isBlank(x2) {
  return x2 === void 0 || x2 === null;
}
function parseNURBS(points2, degree, knots, weights, boundary, opts) {
  var i, dflt;
  if (points2 && !isArrayLike2(points2) && !isNdarray(points2)) {
    opts = points2;
    this.debug = points2.debug;
    this.checkBounds = !!points2.checkBounds;
    this.weights = points2.weights;
    this.knots = points2.knots;
    this.degree = points2.degree;
    this.boundary = points2.boundary;
    this.points = points2.points;
    Object.defineProperty(this, "size", { value: opts.size, writable: true, configurable: true });
  } else {
    opts = opts || {};
    this.weights = weights;
    this.knots = knots;
    this.degree = degree;
    this.points = points2;
    this.boundary = boundary;
    this.debug = opts.debug;
    this.checkBounds = !!opts.checkBounds;
    Object.defineProperty(this, "size", { value: opts.size, writable: true, configurable: true });
  }
  var pointType = inferType(this.points);
  var weightType = inferType(this.weights);
  var knotType = inferType(this.knots);
  if (this.points) {
    switch (pointType) {
      case inferType.GENERIC_NDARRAY:
      case inferType.NDARRAY:
        Object.defineProperties(this, {
          splineDimension: {
            value: this.points.shape.length - 1,
            writable: false,
            configurable: true
          },
          dimension: {
            value: this.points.shape[this.points.shape.length - 1],
            writable: false,
            configurable: true
          },
          size: {
            get: function() {
              return this.points.shape.slice(0, this.points.shape.length - 1);
            },
            set: function() {
              throw new Error("Cannot assign to read only property 'size'");
            },
            configurable: true
          }
        });
        break;
      case inferType.ARRAY_OF_ARRAYS:
        var splineDimension = 0;
        var size2 = this.size || [];
        size2.length = 0;
        for (var ptr = this.points; isArrayLike2(ptr[0]); ptr = ptr[0]) {
          splineDimension++;
          size2.push(ptr.length);
        }
        if (splineDimension === 0) {
          throw new Error("Expected an array of points");
        }
        Object.defineProperties(this, {
          splineDimension: {
            value: splineDimension,
            writable: false,
            configurable: true
          },
          dimension: {
            value: ptr.length,
            writable: false,
            configurable: true
          },
          size: {
            get: function() {
              var size3 = [];
              size3.length = 0;
              for (var i2 = 0, ptr2 = this.points; i2 < this.splineDimension; i2++, ptr2 = ptr2[0]) {
                size3[i2] = ptr2.length;
              }
              return size3;
            },
            set: function() {
              throw new Error("Cannot assign to read only property 'size'");
            },
            configurable: true
          }
        });
        break;
      case inferType.PACKED:
      default:
        throw new Error("Expected either a packed array, array of arrays, or ndarray of points");
    }
  } else {
    if (this.size === void 0 || this.size === null) {
      throw new Error("Either points or a control hull size must be provided.");
    }
    if (!isArrayLike2(this.size)) {
      Object.defineProperty(this, "size", {
        value: [this.size],
        writable: true,
        configurable: true
      });
    }
    if (this.size.length === 0) {
      throw new Error("`size` must be a number or an array of length at least one.");
    }
    Object.defineProperties(this, {
      splineDimension: {
        value: this.size.length,
        writable: false,
        configurable: true
      },
      dimension: {
        value: 0,
        writable: false,
        configurable: true
      }
    });
  }
  if (isArrayLike2(this.degree)) {
    for (i = 0; i < this.splineDimension; i++) {
      if (isBlank(this.degree[i])) {
        throw new Error("Missing degree in dimension " + (i + 1));
      }
    }
  } else {
    var hasBaseDegree = !isBlank(this.degree);
    var baseDegree = isBlank(this.degree) ? 2 : this.degree;
    this.degree = [];
    for (i = 0; i < this.splineDimension; i++) {
      if (this.size[i] <= baseDegree) {
        if (hasBaseDegree) {
          throw new Error("Expected at least " + (baseDegree + 1) + " points for degree " + baseDegree + " spline in dimension " + (i + 1) + " but got only " + this.size[i]);
        } else {
          this.degree[i] = this.size[i] - 1;
        }
      } else {
        this.degree[i] = baseDegree;
      }
    }
  }
  dflt = typeof this.boundary !== "string" ? "open" : this.boundary;
  if (!BOUNDARY_TYPES[dflt]) {
    throw new Error("Boundary type must be one of " + Object.keys(BOUNDARY_TYPES) + ". Got " + dflt);
  }
  this.boundary = isArrayLike2(this.boundary) ? this.boundary : [];
  this.boundary.length = this.splineDimension;
  for (i = 0; i < this.splineDimension; i++) {
    this.boundary[i] = isBlank(this.boundary[i]) ? dflt : this.boundary[i];
    if (!BOUNDARY_TYPES[dflt]) {
      throw new Error("Boundary type must be one of " + Object.keys(BOUNDARY_TYPES) + ". Got " + dflt + " for dimension " + (i + 1));
    }
  }
  switch (knotType) {
    case inferType.ARRAY_OF_ARRAYS:
      if (isArrayLike2(this.knots) && this.knots.length > 0 && !isArrayLike2(this.knots[0])) {
        this.knots = [this.knots];
      }
      for (i = 0; i < this.splineDimension; i++) {
        if (this.size[i] <= this.degree[i]) {
          throw new Error("Expected at least " + (this.degree[i] + 1) + " points in dimension " + (i + 1) + " but got " + this.size[i] + ".");
        }
        if (isArrayLike2(this.knots[i])) {
          if (this.boundary[i] !== "closed" && this.knots[i].length !== this.degree[i] + this.size[i] + 1) {
            throw new Error("Expected " + (this.degree[i] + this.size[i] + 1) + " knots in dimension " + (i + 1) + " but got " + this.knots[i].length + ".");
          } else if (this.boundary[i] === "closed" && this.knots[i].length !== this.size[i] + 1) {
            var canBeFudged = this.knots[i].length === this.size[i] + this.degree[i] + 1;
            if (!canBeFudged) {
              throw new Error("Expected " + (this.size[i] + 1) + " knots for closed spline in dimension " + (i + 1) + " but got " + this.knots[i].length + ".");
            }
          }
        }
      }
      break;
  }
  var newCacheKey = computeCacheKey(this, this.debug, this.checkBounds, pointType, weightType, knotType);
  if (newCacheKey !== this.__cacheKey) {
    this.__cacheKey = newCacheKey;
    var accessors = createAccessors(this);
    this.evaluate = createEvaluator(this.__cacheKey, this, accessors, this.debug, this.checkBounds, false);
    this.transform = createTransform2(this.__cacheKey, this, accessors, this.debug);
    this.support = createSupport(this.__cacheKey, this, accessors, this.debug, this.checkBounds);
    this.evaluator = function(derivativeOrder, isBasis) {
      return createEvaluator(this.__cacheKey, this, accessors, this.debug, this.checkBounds, isBasis, derivativeOrder);
    };
  }
  this.numericalDerivative = numericalDerivative2.bind(this);
  return this;
}
function domainGetter() {
  var sizeArray;
  var ret = [];
  var ptr = this.points;
  if (!ptr) {
    sizeArray = this.size;
  } else if (isNdarrayLike(ptr)) {
    sizeArray = ptr.shape;
  }
  for (var d = 0; d < this.splineDimension; d++) {
    var size2 = sizeArray ? sizeArray[d] : ptr.length;
    var p = this.degree[d];
    var isClosed = this.boundary[d] === "closed";
    if (this.knots && this.knots[d]) {
      var k = this.knots[d];
      ret[d] = [k[isClosed ? 0 : p], k[size2]];
    } else {
      ret[d] = [isClosed ? 0 : p, size2];
    }
    if (ptr)
      ptr = ptr[0];
  }
  return ret;
}
function nurbs(points2, degree, knots, weights, boundary, opts) {
  var ctor = function(points3, degree2, knots2, weights2, boundary2, opts2) {
    parseFcn(points3, degree2, knots2, weights2, boundary2, opts2);
    return ctor;
  };
  var parseFcn = parseNURBS.bind(ctor);
  Object.defineProperty(ctor, "domain", {
    get: domainGetter
  });
  parseFcn(points2, degree, knots, weights, boundary, opts);
  return ctor;
}
var nurbs_1 = nurbs;
class SplineItem extends SVGItem {
  getIcon() {
    return obj.star;
  }
  getDefaultObject(obj2 = {}) {
    return super.getDefaultObject(__spreadValues({
      itemType: "spline",
      name: "New Spline",
      "stroke-width": 1,
      points: [],
      traceCount: 100,
      degree: 2,
      boundary: "clamped"
    }, obj2));
  }
  enableHasChildren() {
    return false;
  }
  refreshMatrixCache() {
    super.refreshMatrixCache();
    if (this.hasChangedField("points", "boundary")) {
      this.setCache();
    } else if (this.hasChangedField("width", "height")) {
      if (!this.cachePath) {
        this.setCache();
      }
      this.json.points = this.cachePath.clone().scale(this.json.width / this.cacheWidth, this.json.height / this.cacheHeight).verties;
      this.modelManager.setChanged("reset", this.id, { points: this.json.points });
    }
  }
  setCache() {
    super.setCache();
    this.cachePath = PathParser.makePathByVerties(this.json.points);
    this.cacheWidth = this.json.width;
    this.cacheHeight = this.json.height;
  }
  get editablePath() {
    let { width: width2, height: height2, points: points2 } = this.json;
    if (!points2 || points2.length == 0) {
      points2 = [[0, height2], [0, 0], [width2, 0], [width2, height2]];
    }
    return this.absolutePath(PathParser.makePathByVerties(points2).d).d;
  }
  recoverEditablePath(d) {
    const points2 = this.invertPath(d).verties;
    const pathData = this.updatePath(this.getPath(points2));
    delete pathData.d;
    return __spreadValues({
      points: points2
    }, pathData);
  }
  get d() {
    return this.getPath(this.json.points, this.json.boundary);
  }
  getPath(points2, boundary) {
    let { width: width2, height: height2 } = this.json;
    if (!points2) {
      points2 = this.json.points;
    }
    if (!boundary) {
      boundary = this.json.boundary;
    }
    if (!points2 || points2.length == 0) {
      points2 = [[0, height2], [0, 0], [width2, 0], [width2, height2]];
    }
    const curve = nurbs_1({
      points: points2,
      degree: points2.length - 2,
      boundary
    });
    const pt = [];
    const verties = [];
    const traceCount = (points2.length - 1) * 100;
    const unit = 1 / traceCount;
    const d0 = curve.domain[0][0];
    const d1 = curve.domain[0][1];
    for (var t = 0; t <= 1; t += unit) {
      curve.evaluate(pt, d0 + (d1 - d0) * t);
      verties.push(clone(pt));
    }
    return PathParser.makePathByVerties(verties, false).round(1e3).d;
  }
  toCloneObject() {
    return __spreadValues(__spreadValues({}, super.toCloneObject()), this.attrs("points", "degree", "boundary"));
  }
  getDefaultTitle() {
    return "BSpline";
  }
}
class BooleanPathItem extends SVGPathItem {
  getIcon() {
    return obj.edit;
  }
  getDefaultObject(obj2 = {}) {
    return super.getDefaultObject(__spreadValues({
      itemType: "boolean-path",
      name: "New Boolean Path",
      "stroke-width": 1,
      d: "",
      "boolean-operation": "none"
    }, obj2));
  }
  enableHasChildren() {
    return true;
  }
  reset(json, context = { origin: "*" }) {
    var _a;
    const isChanged = super.reset(json, context);
    if (!this.cachePath) {
      this.setCache();
    }
    if (this.hasChangedField("changedChildren", "boolean-operation")) {
      if (this.json.children.length === 1) {
        const newPath = this.layers[0].absolutePath().d;
        this.json.d = this.invertPath(newPath).d;
        this.setCache();
        this.modelManager.setChanged("reset", this.id, { d: newPath });
      } else if (this.json["boolean-operation"] !== "none") {
        if (((_a = this.json.children) == null ? void 0 : _a.length) >= 2) {
          if (this.modelManager.editor.pathKitManager.has()) {
            const paths = this.layers.filter((it) => it.d);
            if (paths.length >= 2) {
              const newPath = this.doBooleanOperation();
              this.json.d = newPath;
              this.setCache();
              this.modelManager.setChanged("reset", this.id, { d: newPath });
            } else {
              this.json.d = void 0;
              this.removeCache();
              this.modelManager.setChanged("reset", this.id, { d: void 0 });
            }
          }
        }
      }
    }
    return isChanged;
  }
  get resizableWitChildren() {
    return true;
  }
  startToCacheChildren() {
    this.cachedSize = {
      width: this.json.width.clone(),
      height: this.json.height.clone()
    };
    this.cachedLayerMatrix = this.layers.map((item2) => {
      item2.startToCacheChildren();
      return {
        item: item2,
        matrix: item2.matrix
      };
    });
  }
  recoverChildren() {
    const obj2 = {
      width: this.json.width.clone(),
      height: this.json.height.clone()
    };
    const scaleX = obj2.width / this.cachedSize.width;
    const scaleY = obj2.height / this.cachedSize.height;
    this.cachedLayerMatrix.forEach(({ item: item2, matrix, constraints }) => {
      item2.reset({
        x: item2.x.changeUnitValue(matrix.x * scaleX, obj2.width),
        y: item2.y.changeUnitValue(matrix.y * scaleY, obj2.height),
        width: item2.width.changeUnitValue(matrix.width * scaleX, obj2.width),
        height: item2.height.changeUnitValue(matrix.height * scaleY, obj2.height)
      });
      item2.recoverChildren();
    });
  }
  getFieldValueByBooleanOperation(field) {
    const layers2 = this.layers;
    if (layers2.length === 0) {
      return;
    } else if (layers2.length === 1) {
      return layers2[0][field];
    }
    const op = this["boolean-operation"];
    switch (op) {
      case BooleanOperation.DIFFERENCE:
        return layers2[1][field];
    }
    return layers2[0][field];
  }
  get fill() {
    return this.getFieldValueByBooleanOperation("fill");
  }
  get stroke() {
    return this.getFieldValueByBooleanOperation("stroke");
  }
  setCache() {
    super.setCache();
    this.cachePath = new PathParser(this.json.d);
    this.cacheWidth = this.json.width;
    this.cacheHeight = this.json.height;
  }
  removeCache() {
    super.removeCache();
    this.cachePath = void 0;
    this.cacheWidth = void 0;
    this.cacheHeight = void 0;
  }
  toCloneObject() {
    return __spreadProps(__spreadValues({}, super.toCloneObject()), {
      d: this.json.d
    });
  }
  getDefaultTitle() {
    return "Path";
  }
  doBooleanOperation() {
    const op = this.json["boolean-operation"];
    switch (op) {
      case BooleanOperation.INTERSECTION:
        return this.intersection();
      case BooleanOperation.UNION:
        return this.union();
      case BooleanOperation.DIFFERENCE:
        return this.difference();
      case BooleanOperation.REVERSE_DIFFERENCE:
        return this.reverseDifference();
      case BooleanOperation.XOR:
        return this.xor();
    }
    return "";
  }
  getPathList() {
    return this.layers.map((it) => it.absolutePath().d);
  }
  intersection() {
    const [first, ...rest] = this.getPathList();
    const newPath = rest.reduce((path1, path2) => {
      return this.modelManager.editor.pathKitManager.intersection(path1, path2);
    }, first);
    return this.invertPath(newPath).d;
  }
  union() {
    const [first, ...rest] = this.getPathList();
    const newPath = rest.reduce((path1, path2) => {
      return this.modelManager.editor.pathKitManager.union(path1, path2);
    }, first);
    return this.invertPath(newPath).d;
  }
  difference() {
    const [first, ...rest] = this.getPathList();
    const newPath = rest.reduce((path1, path2) => {
      return this.modelManager.editor.pathKitManager.difference(path1, path2);
    }, first);
    return this.invertPath(newPath).d;
  }
  reverseDifference() {
    const [first, ...rest] = this.getPathList();
    const newPath = rest.reduce((path1, path2) => {
      return this.modelManager.editor.pathKitManager.reverseDifference(path1, path2);
    }, first);
    return this.invertPath(newPath).d;
  }
  xor() {
    const [first, ...rest] = this.getPathList();
    const newPath = rest.reduce((path1, path2) => {
      return this.modelManager.editor.pathKitManager.xor(path1, path2);
    }, first);
    return this.invertPath(newPath).d;
  }
}
function defaultItems(editor) {
  editor.registerItem("project", Project);
  editor.registerItem("artboard", ArtBoard);
  editor.registerItem("rect", RectLayer);
  editor.registerItem("circle", CircleLayer);
  editor.registerItem("image", ImageLayer);
  editor.registerItem("text", TextLayer);
  editor.registerItem("boolean-path", BooleanPathItem);
  editor.registerItem("svg-path", SVGPathItem);
  editor.registerItem("svg-text", SVGTextItem);
  editor.registerItem("svg-textpath", SVGTextPathItem);
  editor.registerItem("template", TemplateLayer);
  editor.registerItem("polygon", SVGPolygonItem);
  editor.registerItem("star", SVGStarItem);
  editor.registerItem("spline", SplineItem);
}
var en_US = {
  "app.title": "EASYLOGIC",
  "app.sample": (a, b, c2) => {
    return `${a}-${b}-${c2}`;
  },
  "app.lang.en_US": "English",
  "app.lang.ko_KR": "\uD55C\uAD6D\uC5B4",
  "app.lang.fr_FR": "Fran\xE7ais",
  "app.label.lang": "Language",
  "app.layout.all": "Layout",
  "app.layout.css": "CSS Mode",
  "app.layout.svg": "SVG Mode",
  "app.label.layout": "Menu Layout",
  "app.theme.dark": "Dark",
  "app.theme.light": "Light",
  "app.theme.toon": "Toon",
  "app.theme.gray": "Gray",
  "app.label.theme": "Theme",
  "app.tab.title.projects": "Projects",
  "app.tab.title.layers": "Layers",
  "app.tab.title.libraries": "Library",
  "app.tab.title.components": "Component",
  "app.tab.title.artboards": "Artboard",
  "app.tab.title.assets": "Assets",
  "app.tab.title.keyMap": "KeyMap",
  "app.confirm.message.artboard.items.removeArtboard": "Do you remove an artboard preview really?",
  "app.confirm.message.custom-component.items.removeCustomComponent": "Do you remove a custom component preview really?",
  "menu.item.download.title": "Source",
  "menu.item.save.title": "Save",
  "menu.item.export.title": "Export",
  "menu.item.codepen.title": "CodePen",
  "menu.item.fullscreen.title": "Full Screen",
  "menu.item.shortcuts.title": "ShortCuts",
  "menu.item.github.title": "Github",
  "menu.item.learn.title": "Learn",
  "menu.item.projects.title": "Projects",
  "menu.item.language.title": "Language",
  "project.property.title": "Project",
  "project.information.property.title": "Project information",
  "project.information.property.name": "Name",
  "project.information.property.description": "Description",
  "artboard.property.title": "ArtBoards",
  "artboard.property.layout.title.flex": "Flex",
  "artboard.property.layout.title.grid": "Grid",
  "layer.tree.property.title": "Layers",
  "layer.tree.property.layout.title.flex": "Flex",
  "layer.tree.property.layout.title.grid": "Grid",
  "alignment.property.title": "Alignment",
  "position.property.title": "Position",
  "position.property.X": "X",
  "position.property.Y": "Y",
  "size.property.title": "Size",
  "position.property.width": "W",
  "position.property.height": "H",
  "position.property.opacity": "Opacity",
  "position.property.rotate": "Rotate",
  "background.color.property.title": "Appearance",
  "background.color.property.color": "Color",
  "background.color.property.zindex": "z-index",
  "background.color.property.blend": "Blend",
  "background.color.property.overflow": "Overflow",
  "background.color.property.overflow.visible": "Visible",
  "background.color.property.overflow.hidden": "Hidden",
  "background.color.property.overflow.scroll": "Scroll",
  "background.color.property.overflow.auto": "Auto",
  "blend.normal": "normal",
  "blend.multiply": "multiply",
  "blend.screen": "screen",
  "blend.overlay": "overlay",
  "blend.darken": "darken",
  "blend.lighten": "lighten",
  "blend.color-dodge": "color-dodge",
  "blend.color-burn": "color-burn",
  "blend.hard-light": "hard-light",
  "blend.soft-light": "soft-light",
  "blend.difference": "difference",
  "blend.exclusion": "exclusion",
  "blend.hue": "hue",
  "blend.saturation": "saturation",
  "blend.color": "color",
  "blend.luminosity": "luminosity",
  "background.image.property.title": "Fill",
  "border.property.title": "Border",
  "border.radius.property.title": "Border Radius",
  "boxshadow.property.title": "Box Shadows",
  "filter.property.title": "Filter",
  "filter.property.blur": "Blur",
  "filter.property.grayscale": "GrayScale",
  "filter.property.hue-rotate": "Hue Rotate",
  "filter.property.invert": "Invert",
  "filter.property.brightness": "Brightness",
  "filter.property.contrast": "Contrast",
  "filter.property.drop-shadow": "Drop Shadow",
  "filter.property.drop-shadow.color": "Color",
  "filter.property.drop-shadow.offsetX": "Offset X",
  "filter.property.drop-shadow.offsetY": "Offset Y",
  "filter.property.drop-shadow.blurRadius": "Blur",
  "filter.property.opacity": "Opacity",
  "filter.property.saturate": "Saturate",
  "filter.property.sepia": "Sepia",
  "filter.property.svg": "SVG",
  "font.property.title": "Font",
  "font.property.color": "Color",
  "font.property.size": "Size",
  "font.property.stretch": "Stretch",
  "font.property.weight": "Weight",
  "font.property.style": "Style",
  "font.property.family": "Family",
  "font.spacing.property.title": "Font spacing",
  "font.spacing.property.lineHeight": "Line height",
  "font.spacing.property.letterSpacing": "Letter spacing",
  "font.spacing.property.wordSpacing": "Word spacing",
  "font.spacing.property.indent": "Indent",
  "backdrop.filter.property.title": "Backdrop Filter",
  "clippath.property.title": "Clip Path",
  "export.property.title": "Export",
  "export.property.download": "Download",
  "iframe.property.title": "IFrame",
  "image.property.title": "Image",
  "image.property.origin": "Origin",
  "image.property.size": "Size",
  "image.property.width": "Width",
  "image.property.height": "height",
  "video.property.title": "Video",
  "video.property.play": "Play",
  "video.property.pause": "Pause",
  "video.property.volume": "Volume",
  "video.property.playbackRate": "Playback Rate",
  "video.property.currentTime": "Current Time",
  "video.property.playTime": "Play Time Distance",
  "motion.property.title": "Motion",
  "text.property.title": "Text Style",
  "text.property.align": "Align",
  "text.property.transform": "Transform",
  "text.property.decoration": "Decoration",
  "text.clip.property.title": "Text Clip",
  "text.shadow.property.title": "Text Shadows",
  "text.fill.property.title": "Text Fill",
  "text.fill.property.fill": "Fill",
  "text.fill.property.stroke": "Stroke",
  "text.fill.property.strokeWidth": "Width",
  "transform.property.title": "Transform",
  "transform.origin.property.title": "Transform Origin",
  "transition.property.title": "CSS Transition",
  "keyframe.property.title": "CSS Keyframe",
  "selector.property.title": "Selector",
  "selector.property.none": "None selector",
  "path.data.property.title": "Path Information",
  "polygon.data.property.title": "Polygon Information",
  "perspective.property.title": "Perspective",
  "perspective.origin.property.title": "Perspective Origin",
  "svg.item.property.title": "Appearance",
  "svg.item.property.isMotionPath": "Motion Path",
  "svg.item.property.fill": "Fill",
  "svg.item.property.fillOpacity": "Opacity",
  "svg.item.property.path": "Path",
  "svg.item.property.polygon": "Polygon",
  "svg.item.property.totalLength": "Total Length",
  "svg.item.property.fillRule": "Fill Rule",
  "svg.item.property.stroke": "Stroke",
  "svg.item.property.strokeWidth": "Width",
  "svg.item.property.dashArray": "Dash Array",
  "svg.item.property.dashOffset": "Dash Offset",
  "svg.item.property.lineCap": "Line Cap",
  "svg.item.property.lineJoin": "Line Join",
  "svg.item.property.filter": "Filter",
  "svg.item.property.blend": "Blend Mode",
  "border.editor.all": "All",
  "border.editor.width": "Width",
  "border.editor.style": "Style",
  "border.editor.color": "C",
  "border.editor.top": "Top",
  "border.editor.left": "Left",
  "border.editor.right": "Right",
  "border.editor.bottom": "Bottom",
  "border.radius.editor.topLeft": "Top Left",
  "border.radius.editor.topRight": "Top Right",
  "border.radius.editor.bottomLeft": "Bottom Left",
  "border.radius.editor.bottomRight": "Bottom Right",
  "boxshadow.editor.blur": "Blur",
  "boxshadow.editor.spread": "Spread",
  "css.property.editor.properties": "Properties",
  "offset.path.list.editor.path": "Path",
  "offset.path.list.editor.totalLength": "Total Length",
  "offset.path.list.editor.distance": "Distance",
  "offset.path.list.editor.direction": "Direction",
  "offset.path.list.editor.rotate": "Rotate",
  "svgfilter.select.editor.message.create": "Create new svg filter",
  "svgfilter.select.editor.message.select": "Select a filter",
  "fill.editor.message.click.image": "Click the preview area if you want to select a image",
  "fill.editor.message.drag.position": "Drag if you want to move center position",
  "fill.editor.x1": "Start X",
  "fill.editor.x2": "End X",
  "fill.editor.y1": "Start Y",
  "fill.editor.y2": "End Y",
  "fill.editor.spread": "Spread",
  "fill.editor.offset": "Offset",
  "fill.editor.cx": "Center X",
  "fill.editor.cy": "Center Y",
  "fill.editor.r": "End radius",
  "fill.editor.fx": "Start X",
  "fill.editor.fy": "Start Y",
  "fill.editor.fr": "Start radius",
  "perspective.origin.editor.originX": "Origin X",
  "perspective.origin.editor.originY": "Origin Y",
  "path.manager.msg": "Keydown ESC or Enter key to close editing",
  "path.manager.mode.done": "Done",
  "path.manager.mode.modify": "Modify",
  "path.manager.mode.path": "Path",
  "path.manager.mode.warp": "Warp",
  "path.manager.mode.transform": "Transform",
  "path.manager.mode.reverse": "Reverse",
  "path.manager.mode.flipX": "Flip X",
  "path.manager.mode.flipY": "Flip Y",
  "path.manager.mode.flipOrigin": "Flip Origin",
  "colorpicker.popup.title": "ColorPicker",
  "selector.popup.title": "Selector Property",
  "selector.popup.selector": "Selector",
  "background.image.position.popup.title": "Background Pattern",
  "background.image.position.popup.size": "Size",
  "background.image.position.popup.width": "Width",
  "background.image.position.popup.height": "Height",
  "background.image.position.popup.repeat": "Repeat",
  "background.image.position.popup.blend": "Blend",
  "background.image.position.popup.type.repeat": "repeat",
  "background.image.position.popup.type.no-repeat": "no repeat",
  "background.image.position.popup.type.repeat-x": "repeat-x",
  "background.image.position.popup.type.repeat-y": "repeat-y",
  "background.image.position.popup.type.space": "space",
  "background.image.position.popup.type.round": "round",
  "gradient.picker.popup.title": "Gradient & Image Picker",
  "image.asset.property.title": "Image",
  "video.asset.property.title": "Video",
  "color.asset.property.title": "Color",
  "gradient.asset.property.title": "Gradient",
  "pattern.asset.property.title": "Pattern",
  "svgfilter.asset.property.title": "SVG Filter",
  "inspector.tab.title.design": "Design",
  "inspector.tab.title.component": "Component",
  "inspector.tab.title.transition": "Animation",
  "inspector.tab.title.asset": "Assets",
  "inspector.tab.title.text": "Text",
  "inspector.tab.title.code": "Code",
  "inspector.tab.title.history": "History",
  "timeline.property.title": "Timeline",
  "timeline.property.resize": "Drag if you want to resize timeline height.",
  "timeline.animation.property.title": "Animations",
  "timeline.play.control.play": "Play",
  "timeline.play.control.pause": "Pause",
  "timeline.play.control.first": "First",
  "timeline.play.control.prev": "Previous",
  "timeline.play.control.next": "Next",
  "timeline.play.control.last": "Last",
  "timeline.play.control.direction": "Direction",
  "timeline.play.control.speed": "Speed",
  "timeline.play.control.repeat": "Repeat",
  "timeline.play.control.infinite": "Infinite",
  "timeline.play.control.normal": "normal",
  "timeline.play.control.alternate": "alternate",
  "timeline.play.control.reverse": "reverse",
  "timeline.play.control.alternate.reverse": "alternate reverse",
  "timeline.value.editor.value": "Value",
  "timeline.value.editor.time": "Time",
  "timeline.value.editor.timing": "Timing",
  "timeline.value.editor.offset.message": "Please input enter key to change time offset.",
  "svgfilter.popup.title": "SVG Filter",
  "css.item.rotate": "Rotate",
  "css.item.rotateX": "Rotate X",
  "css.item.rotateY": "Rotate Y",
  "css.item.rotateZ": "Rotate Z",
  "css.item.rotate3d": "3D Rotate",
  "css.item.skewX": "Skew X",
  "css.item.skewY": "Skew Y",
  "css.item.translate": "Translate",
  "css.item.translateX": "Translate X",
  "css.item.translateY": "Translate Y",
  "css.item.translateZ": "Translate Z",
  "css.item.translate3d": "3D Translate",
  "css.item.perspective": "Perspective",
  "css.item.scale": "Scale",
  "css.item.scaleX": "Scale X",
  "css.item.scaleY": "Scale Y",
  "css.item.scaleZ": "Scale Z",
  "css.item.scale3d": "3D Scale",
  "css.item.matrix": "Matrix",
  "css.item.matrix3d": "3D Matrix",
  "animation.property.title": "CSS Animation",
  "animation.property.direction": "Direction",
  "animation.property.play.state": "Play State",
  "animation.property.fill.mode": "Fill Mode",
  "animation.property.delay": "Delay",
  "animation.property.duration": "Duration",
  "animation.property.iteration.count": "Iteration Count",
  "animation.property.Select a keyframe": "Select a keyframe",
  "animation.property.popup.title": "Animation",
  "animation.property.popup.timing.function": "Timing Function",
  "animation.property.popup.keyframe": "Keyframe",
  "animation.property.popup.direction": "Direction",
  "animation.property.popup.play.state": "Play State",
  "animation.property.popup.fill.mode": "Fill Mode",
  "animation.property.popup.delay": "Delay",
  "animation.property.popup.duration": "Duration",
  "animation.property.popup.iteration": "Iteration",
  "animation.property.popup.normal": "normal",
  "animation.property.popup.reverse": "reverse",
  "animation.property.popup.alternate": "alternate",
  "animation.property.popup.alternate-reverse": "alternate-reverse",
  "animation.property.popup.none": "none",
  "animation.property.popup.forwards": "forwards",
  "animation.property.popup.backwards": "backwards",
  "animation.property.popup.both": "both",
  "animation.property.popup.Select a keyframe": "Select a keyframe",
  "keyframe.popup.title": "Keyframe",
  "code.view.property.title": "CodeView",
  "svg.filter.editor.tab.filter": "Filter",
  "svg.filter.editor.tab.preset": "Preset",
  "svg.filter.editor.tab.asset": "Assets",
  "svg.filter.editor.GRAPHIC REFERENCES": "GRAPHIC REFERENCES",
  "svg.filter.editor.SOURCES": "SOURCES",
  "svg.filter.editor.MODIFIER": "MODIFIER",
  "svg.filter.editor.LIGHTING": "LIGHTING",
  "svg.filter.editor.COMBINERS": "COMBINERS",
  "svg.filter.editor.Template": "Template",
  "layout.property.title": "Layout",
  "layout.property.flex": "Flex Box",
  "layout.property.grid": "Grid",
  "layout.property.default": "Default",
  "layout.property.resizing.title": "Resizing",
  "default.layout.item.property.title.constraints": "Constraints",
  "flex.layout.editor.row": "Row",
  "flex.layout.editor.column": "column",
  "flex.layout.editor.row-reverse": "Row Reverse",
  "flex.layout.editor.column-reverse": "Column Reverse",
  "flex.layout.editor.nowrap": "Nowrap",
  "flex.layout.editor.wrap": "Wrap",
  "flex.layout.editor.wrap-reverse": "Wrap Reverse",
  "flex.layout.editor.flex-start": "Start",
  "flex.layout.editor.flex-end": "End",
  "flex.layout.editor.center": "Center",
  "flex.layout.editor.space-between": "Between",
  "flex.layout.editor.space-around": "Around",
  "flex.layout.editor.baseline": "BaseLine",
  "flex.layout.editor.stretch": "Stretch",
  "flex.layout.editor.direction": "Direction",
  "flex.layout.editor.justify-content": "Justify Content",
  "flex.layout.editor.align-items": "Align Items",
  "flex.layout.editor.align-content": "Align Content",
  "flex.layout.item.property.title": "Flex Item Detail",
  "flex.layout.item.property.grow": "Flex Grow",
  "flex.layout.item.property.shrink": "Flex Shrink",
  "flex.layout.item.property.basis": "Flex Basis",
  "flex.layout.item.property.none": "none",
  "flex.layout.item.property.auto": "auto",
  "flex.layout.item.property.value": "value",
  "grid.layout.editor.template.columns": "Columns",
  "grid.layout.editor.column.gap": "Column Gap",
  "grid.layout.editor.template.rows": "Rows",
  "grid.layout.editor.row.gap": "Row Gap",
  "grid.box.editor.box.title": "Box",
  "grid.box.editor.type": "Type",
  "grid.box.editor.repeat": "Repeat",
  "grid.box.editor.length": "Length",
  "grid.box.editor.none": "None",
  "grid.box.editor.auto": "Auto",
  "grid.box.editor.count": "Count",
  "grid.box.editor.value": "Size",
  "grid.layout.item.property.title": "Layout Item Detail",
  "grid.layout.item.property.column": "Column",
  "grid.layout.item.property.row": "Row",
  "grid.layout.item.property.start": "Start",
  "grid.layout.item.property.end": "End",
  "grid.layout.item.property.none": "none",
  "grid.layout.item.property.value": "value",
  "box.model.property.title": "Box Model",
  "box.model.property.margin": "Margin",
  "box.model.property.padding": "Padding",
  "component.items.canvas": "Canvas",
  "component.items.layer": "Layer",
  "component.items.3dlayer": "3D Layer",
  "component.items.drawing": "Drawing",
  "component.items.custom": "Custom Component",
  "component.items.chart": "Chart",
  "component.items.plugin": "Plugin",
  "svg.text.property.title": "SVG Text Style",
  "svg.text.property.textarea": "Text Area",
  "svg.text.property.size": "Font Size",
  "svg.text.property.weight": "Font Weight",
  "svg.text.property.style": "Font Style",
  "svg.text.property.anchor": "Text Anchor",
  "svg.text.property.family": "Font Family",
  "svg.text.property.length.adjust": "Length Adjust",
  "svg.text.property.text.length": "Text Length",
  "svg.text.property.start.offset": "Start Offset",
  "fill.picker.popup.title": "SVG Fragment picker",
  "gradient.editor.drag.message": "Drag if you want to move center pointer.",
  "draw.manager.tolerance": "Tolerance",
  "pattern.property.title": "Pattern",
  "pattern.info.popup.title": "Pattern Info",
  "pattern.info.popup.width": "Width",
  "pattern.info.popup.height": "Height",
  "pattern.info.popup.lineWidth": "Line Width",
  "pattern.info.popup.lineHeight": "Line Height",
  "pattern.info.popup.rotate": "Rotate",
  "pattern.info.popup.blend": "Blend Mode",
  "pattern.info.popup.foreColor": "Fore",
  "pattern.info.popup.backColor": "Back",
  "stroke.dasharray.editor.add": "Add Dash",
  "viewport.panning.enable": "You can move the area by holding down space key and dragging the screen."
};
var ko_KR = {
  "app.title": "EASYLOGIC",
  "app.sample": (a, b, c2) => {
    return `${a}-${b}-${c2}`;
  },
  "app.lang.en_US": "English",
  "app.lang.ko_KR": "\uD55C\uAD6D\uC5B4",
  "app.lang.fr_FR": "Fran\xE7ais",
  "app.label.lang": "\uC5B8\uC5B4",
  "app.layout.all": "\uB808\uC774\uC544\uC6C3",
  "app.layout.css": "CSS \uBAA8\uB4DC",
  "app.layout.svg": "SVG \uBAA8\uB4DC",
  "app.label.layout": "\uBA54\uB274\uAD6C\uC131",
  "app.theme.dark": "\uC5B4\uB450\uC6B4",
  "app.theme.light": "\uBC1D\uC740",
  "app.theme.toon": "\uADF8\uB9AC\uAE30",
  "app.theme.gray": "\uD68C\uC0C9",
  "app.label.theme": "\uD14C\uB9C8",
  "app.tab.title.projects": "\uD504\uB85C\uC81D\uD2B8",
  "app.tab.title.layers": "\uB808\uC774\uC5B4",
  "app.tab.title.libraries": "\uB77C\uC774\uBE0C\uB7EC\uB9AC",
  "app.tab.title.components": "\uCEF4\uD3EC\uB10C\uD2B8",
  "app.tab.title.artboards": "\uC544\uD2B8\uBCF4\uB4DC",
  "app.tab.title.assets": "\uC5D0\uC14B",
  "app.tab.title.keyMap": "\uB2E8\uCD95\uD0A4",
  "app.confirm.message.artboard.items.removeArtboard": "\uC544\uD2B8\uBCF4\uB4DC \uD504\uB9AC\uBDF0\uB97C \uC0AD\uC81C \uD558\uC2DC\uACA0\uC2B5\uB2C8\uAE4C?",
  "app.confirm.message.custom-component.items.removeCustomComponent": "\uCEF4\uD3EC\uB10C\uD2B8 \uD504\uB9AC\uBDF0\uB97C \uC0AD\uC81C \uD558\uC2DC\uACA0\uC2B5\uB2C8\uAE4C?",
  "menu.item.download.title": "\uB2E4\uC6B4\uB85C\uB4DC",
  "menu.item.save.title": "\uC800\uC7A5",
  "menu.item.export.title": "\uB0B4\uBCF4\uB0B4\uAE30",
  "menu.item.fullscreen.title": "\uC804\uCCB4\uD654\uBA74",
  "menu.item.shortcuts.title": "\uB2E8\uCD95\uD0A4",
  "menu.item.github.title": "Github",
  "menu.item.learn.title": "\uBC30\uC6B0\uAE30",
  "menu.item.projects.title": "\uD504\uB85C\uC81D\uD2B8",
  "project.property.title": "\uD504\uB85C\uC81D\uD2B8",
  "project.information.property.title": "\uD504\uB85C\uC81D\uD2B8 \uC815\uBCF4",
  "project.information.property.name": "\uC774\uB984",
  "project.information.property.description": "\uC124\uBA85",
  "artboard.property.title": "\uC544\uD2B8\uBCF4\uB4DC",
  "artboard.property.layout.title.flex": "\uD50C\uB809\uC2A4",
  "artboard.property.layout.title.grid": "\uADF8\uB9AC\uB4DC",
  "layer.tree.property.title": "\uB808\uC774\uC5B4",
  "layer.tree.property.layout.title.flex": "\uD50C\uB809\uC2A4",
  "layer.tree.property.layout.title.grid": "\uADF8\uB9AC\uB4DC",
  "alignment.property.title": "\uC815\uB82C",
  "position.property.title": "\uC704\uCE58",
  "position.property.X": "X",
  "position.property.Y": "Y",
  "size.property.title": "\uD06C\uAE30",
  "position.property.width": "\uB113\uC774",
  "position.property.height": "\uB192\uC774",
  "position.property.rotate": "\uD68C\uC804",
  "position.property.opacity": "\uD22C\uBA85",
  "background.color.property.title": "\uD45C\uC2DC",
  "background.color.property.color": "\uBC30\uACBD\uC0C9",
  "background.color.property.zindex": "z-index",
  "background.color.property.blend": "\uBE14\uB80C\uB4DC\uBAA8\uB4DC",
  "background.color.property.overflow": "\uC624\uBC84\uD50C\uB85C\uC6B0",
  "background.color.property.overflow.visible": "\uBCF4\uC774\uAE30",
  "background.color.property.overflow.hidden": "\uC228\uAE30\uAE30",
  "background.color.property.overflow.scroll": "\uC2A4\uD06C\uB864",
  "background.color.property.overflow.auto": "\uC790\uB3D9",
  "blend.normal": "Normal(\uD45C\uC900) \uD63C\uD569\uBAA8\uB4DC",
  "blend.multiply": "Multiply(\uACF1\uD558\uAE30) \uBAA8\uB4DC",
  "blend.screen": "Screen(\uC2A4\uD06C\uB9B0) \uBAA8\uB4DC ",
  "blend.overlay": "Overlay(\uC624\uBC84\uB808\uC774) \uBAA8\uB4DC",
  "blend.darken": "Darken(\uC5B4\uB461\uAE30) \uBAA8\uB4DC",
  "blend.lighten": "Lighten(\uBC1D\uAE30) \uBAA8\uB4DC ",
  "blend.color-dodge": "Color Dodge(\uCEEC\uB7EC \uB2F7\uC9C0) \uBAA8\uB4DC ",
  "blend.color-burn": "Color Burn(\uCEEC\uB7EC \uBC88) \uBAA8\uB4DC ",
  "blend.hard-light": "Hard Light(\uD558\uB4DC \uB77C\uC774\uD2B8) \uBAA8\uB4DC ",
  "blend.soft-light": "Soft Light(\uC18C\uD504\uD2B8 \uB77C\uC774\uD2B8) \uBAA8\uB4DC ",
  "blend.difference": "Difference(\uCC28\uC774) \uBAA8\uB4DC",
  "blend.exclusion": "Exclusion(\uC81C\uC678) \uBAA8\uB4DC",
  "blend.hue": "Hue(\uC0C9\uC870) \uBAA8\uB4DC ",
  "blend.saturation": "Saturation(\uCC44\uB3C4) \uBAA8\uB4DC",
  "blend.color": "Color(\uC0C9\uC0C1) \uBAA8\uB4DC",
  "blend.luminosity": "Luminosity(\uAD11\uB3C4) \uBAA8\uB4DC ",
  "background.image.property.title": "\uCC44\uC6B0\uAE30",
  "border.property.title": "\uC678\uACFD\uC120",
  "border.radius.property.title": "\uB465\uADFC \uC678\uACFD\uC120",
  "boxshadow.property.title": "\uADF8\uB9BC\uC790",
  "filter.property.title": "\uD544\uD130",
  "filter.property.blur": "\uD750\uB9BC(Blur)",
  "filter.property.grayscale": "\uD68C\uC0C9(GrayScale)",
  "filter.property.hue-rotate": "\uC0C9\uC870(HueRotate)",
  "filter.property.invert": "\uBC18\uC804(Invert)",
  "filter.property.brightness": "\uBC1D\uAE30(Brightness)",
  "filter.property.contrast": "\uB300\b\uC870(Contrast)",
  "filter.property.drop-shadow": "\uADF8\uB9BC\uC790(Drop Shadow)",
  "filter.property.drop-shadow.color": "\uC0C9",
  "filter.property.drop-shadow.offsetX": "X",
  "filter.property.drop-shadow.offsetY": "Y",
  "filter.property.drop-shadow.blurRadius": "\uD750\uB9BC",
  "filter.property.opacity": "\uD22C\uBA85\uB3C4(Opacity)",
  "filter.property.saturate": "\uCC44\uB3C4(Saturate)",
  "filter.property.sepia": "\uAC08\uC0C9\uD1A4(Sepia)",
  "filter.property.svg": "SVG",
  "font.property.title": "\uD3F0\uD2B8",
  "font.property.color": "\uC0C9",
  "font.property.size": "\uD06C\uAE30",
  "font.property.stretch": "\uBED7\uAE30",
  "font.property.weight": "\uAD75\uAE30",
  "font.property.style": "\uC2A4\uD0C0\uC77C",
  "font.property.family": "\uAE00\uAF34",
  "font.spacing.property.title": "\uD3F0\uD2B8 \uACF5\uAC04",
  "font.spacing.property.lineHeight": "\uC904 \uB192\uC774",
  "font.spacing.property.letterSpacing": "\uAE00\uC790 \uAC04\uACA9",
  "font.spacing.property.wordSpacing": "\uB2E8\uC5B4 \uAC04\uACA9",
  "font.spacing.property.indent": "\uB4E4\uC5EC\uC4F0\uAE30",
  "backdrop.filter.property.title": "\uD6C4\uBA74 \uD544\uD130",
  "clippath.property.title": "\uD074\uB9BD\uD328\uC2A4",
  "export.property.title": "\uB0B4\uBCF4\uB0B4\uAE30",
  "export.property.download": "\uB2E4\uC6B4\uB85C\uB4DC",
  "iframe.property.title": "\uC544\uC774\uD504\uB808\uC784",
  "image.property.title": "\uC774\uBBF8\uC9C0",
  "image.property.origin": "\uC6D0\uBCF8",
  "image.property.size": "\uD06C\uAE30",
  "image.property.width": "\uB113\uC774",
  "image.property.height": "\uB192\uC774",
  "video.property.title": "\uBE44\uB514\uC624",
  "video.property.play": "\uC2DC\uC791",
  "video.property.pause": "\uBA48\uCDA4",
  "video.property.volume": "\uBCFC\uB968",
  "video.property.playbackRate": "\uBE60\uB974\uAE30",
  "video.property.currentTime": "\uD604\uC7AC \uC2DC\uAC04",
  "video.property.playTime": "\uD50C\uB808\uC774 \uC2DC\uAC04 \uAC04\uACA9",
  "motion.property.title": "\uBAA8\uC158",
  "path.data.property.title": "\uD328\uC2A4 \uC815\uBCF4",
  "polygon.data.property.title": "\uD3F4\uB9AC\uACE4 \uC815\uBCF4",
  "text.property.title": "\uD14D\uC2A4\uD2B8 \uC2A4\uD0C0\uC77C",
  "text.property.align": "\uC815\uB82C",
  "text.property.transform": "\uBCC0\uD615",
  "text.property.decoration": "\uC7A5\uC2DD",
  "text.clip.property.title": "\uD14D\uC2A4\uD2B8 \uD074\uB9BD",
  "text.shadow.property.title": "\uD14D\uC2A4\uD2B8 \uADF8\uB9BC\uC790",
  "text.fill.property.title": "\uD14D\uC2A4\uD2B8 \uCC44\uC6B0\uAE30",
  "text.fill.property.fill": "\uCC44\uC6B0\uAE30",
  "text.fill.property.stroke": "\uC724\uACFD\uC120",
  "text.fill.property.strokeWidth": "\uC724\uACFD\uC120 \uAD75\uAE30",
  "transform.property.title": "\uD2B8\uB79C\uC2A4\uD3FC",
  "transform.origin.property.title": "\uD2B8\uB79C\uC2A4\uD3FC Origin",
  "transition.property.title": "CSS \uD2B8\uB79C\uC9C0\uC158",
  "keyframe.property.title": "CSS \uD0A4\uD504\uB808\uC784",
  "selector.property.title": "CSS \uC140\uB809\uD130",
  "selector.property.none": "\uC120\uD0DD\uC790 \uC5C6\uC74C",
  "perspective.property.title": "\uD22C\uC601(perspective)",
  "perspective.origin.property.title": "\uD22C\uC601 \uC911\uC2EC\uC810",
  "svg.item.property.title": "\uBCF4\uC774\uAE30",
  "svg.item.property.isMotionPath": "\uBAA8\uC158 \uD328\uC2A4",
  "svg.item.property.fill": "\uCC44\uC6B0\uAE30",
  "svg.item.property.fillOpacity": "\uD22C\uBA85\uB3C4",
  "svg.item.property.path": "\uD328\uC2A4",
  "svg.item.property.polygon": "\uD3F4\uB9AC\uACE4",
  "svg.item.property.totalLength": "\uC804\uCCB4 \uAE38\uC774",
  "svg.item.property.fillRule": "\uCC44\uC6B0\uAE30 \uADDC\uCE59",
  "svg.item.property.stroke": "\uC120",
  "svg.item.property.strokeWidth": "\uC120 \uAD75\uAE30",
  "svg.item.property.dashArray": "\uC810\uC120 \uAE38\uC774",
  "svg.item.property.dashOffset": "\uC810\uC120 \uC704\uCE58",
  "svg.item.property.lineCap": "\uC120 \uBAA8\uC591",
  "svg.item.property.lineJoin": "\uACB9\uCE5C \uC120",
  "svg.item.property.filter": "\uD544\uD130",
  "svg.item.property.blend": "\uBE14\uB80C\uB4DC",
  "border.editor.all": "\uC804\uCCB4",
  "border.editor.width": "\uD06C\uAE30",
  "border.editor.style": "\uC2A4\uD0C0\uC77C",
  "border.editor.color": "\uC0C9",
  "border.editor.top": "\uC704",
  "border.editor.left": "\uC67C\uCABD",
  "border.editor.right": "\uC624\uB978\uCABD",
  "border.editor.bottom": "\uC544\uB798",
  "border.radius.editor.topLeft": "\uC67C\uCABD \uC704",
  "border.radius.editor.topRight": "\uC624\uB978\uCABD \uC704",
  "border.radius.editor.bottomLeft": "\uC67C\uCABD \uC544\uB798",
  "border.radius.editor.bottomRight": "\uC624\uB978\uCABD \uC544\uB798",
  "boxshadow.editor.blur": "\uD750\uB9BC",
  "boxshadow.editor.spread": "\uAE38\uC774",
  "css.property.editor.properties": "\uC18D\uC131",
  "offset.path.list.editor.path": "\uD328\uC2A4",
  "offset.path.list.editor.totalLength": "\uC804\uCCB4 \uAE38\uC774",
  "offset.path.list.editor.distance": "\uAC70\uB9AC",
  "offset.path.list.editor.direction": "\uBC29\uD5A5",
  "offset.path.list.editor.rotate": "\uD68C\uC804",
  "svgfilter.select.editor.message.create": "\uC0C8\uB85C\uC6B4 SVG Filter \uB97C \uB9CC\uB4DC\uC138\uC694.",
  "svgfilter.select.editor.message.select": "\uD544\uD130\uB97C \uC120\uD0DD\uD558\uC138\uC694.",
  "fill.editor.message.click.image": "\uC774\uBBF8\uC9C0\uB97C \uC120\uD0DD\uD558\uACE0 \uC2F6\uC73C\uBA74 \uD504\uB9AC\uBDF0 \uC601\uC5ED\uC744 \uD074\uB9AD\uD558\uC138\uC694.",
  "fill.editor.message.drag.position": "\uAC00\uC6B4\uB370 \uC704\uCE58\uB97C \uB4DC\uB798\uADF8 \uD574\uBCF4\uC138\uC694.",
  "fill.editor.x1": "\uC2DC\uC791 X",
  "fill.editor.x2": "\uB05D X",
  "fill.editor.y1": "\uC2DC\uC791 Y",
  "fill.editor.y2": "\uB05D Y",
  "fill.editor.spread": "\uD655\uC0B0",
  "fill.editor.offset": "\uC704\uCE58",
  "fill.editor.cx": "\uC911\uC2EC\uC810 X",
  "fill.editor.cy": "\uC911\uC2EC\uC810 Y",
  "fill.editor.r": "\uB05D \uBC18\uC9C0\uB984",
  "fill.editor.fx": "\uC2DC\uC791 X",
  "fill.editor.fy": "\uC2DC\uC791 Y",
  "fill.editor.fr": "\uC2DC\uC791 \uBC18\uC9C0\uB984",
  "perspective.origin.editor.originX": "\uC911\uC2EC\uC810 X",
  "perspective.origin.editor.originY": "\uC911\uC2EC\uC810 Y",
  "path.manager.msg": "\uD3B8\uC9D1\uC744 \uC885\uB8CC\uD560 \uB54C\uB294 ESC \uD0A4\uB098 Enter \uD0A4\uB97C \uB204\uB974\uC138\uC694. \uB610\uB294 \uD654\uBA74\uC744 \uD074\uB9AD\uD558\uC2DC\uBA74 \uB429\uB2C8\uB2E4.",
  "path.manager.mode.done": "\uC644\uB8CC",
  "path.manager.mode.modify": "\uC810 \uD3B8\uC9D1",
  "path.manager.mode.path": "\uC810 \uCD94\uAC00",
  "path.manager.mode.warp": "\uC6CC\uD504",
  "path.manager.mode.transform": "\uBCC0\uD615",
  "path.manager.mode.reverse": "\uC21C\uC11C\uBCC0\uACBD",
  "path.manager.mode.flipX": "X\uCD95 \uD68C\uC804",
  "path.manager.mode.flipY": "Y\uCD95 \uD68C\uC804",
  "path.manager.mode.flipOrigin": "\uC804\uCCB4 \uD68C\uC804",
  "colorpicker.popup.title": "\uC0C9\uC0C1 \uC120\uD0DD",
  "selector.popup.title": "\uC120\uD0DD\uC790 \uC18D\uC131",
  "selector.popup.selector": "\uC120\uD0DD\uC790",
  "background.image.position.popup.title": "\uBC30\uACBD \uD328\uD134",
  "background.image.position.popup.size": "\uD06C\uAE30",
  "background.image.position.popup.width": "\uB113\uC774",
  "background.image.position.popup.height": "\uB192\uC774",
  "background.image.position.popup.repeat": "\uBC18\uBCF5",
  "background.image.position.popup.blend": "\uBE14\uB80C\uB4DC",
  "background.image.position.popup.type.repeat": "\uBC18\uBCF5",
  "background.image.position.popup.type.no-repeat": "\uBC18\uBCF5 \uC548\uD568",
  "background.image.position.popup.type.repeat-x": "x\uCD95 \uBC18\uBCF5",
  "background.image.position.popup.type.repeat-y": "y\uCD95 \uBC18\uBCF5",
  "background.image.position.popup.type.space": "\uACF5\uBC31\uC720\uC9C0",
  "background.image.position.popup.type.round": "\uBC18\uC62C\uB9BC",
  "gradient.picker.popup.title": "\uADF8\uB77C\uB514\uC5B8\uD2B8\uC640 \uC774\uBBF8\uC9C0",
  "image.asset.property.title": "\uC774\uBBF8\uC9C0",
  "video.asset.property.title": "\uBE44\uB514\uC624",
  "color.asset.property.title": "\uC0C9",
  "gradient.asset.property.title": "\uADF8\uB77C\uB514\uC5B8\uD2B8",
  "pattern.asset.property.title": "\uD328\uD134",
  "svgfilter.asset.property.title": "SVG \uD544\uD130",
  "inspector.tab.title.design": "\uB514\uC790\uC778",
  "inspector.tab.title.component": "\uCEF4\uD3EC\uB10C\uD2B8 \uC18D\uC131",
  "inspector.tab.title.transition": "\uC560\uB2C8\uBA54\uC774\uC158",
  "inspector.tab.title.asset": "\uC5D0\uC14B \uAD00\uB9AC\uC790",
  "inspector.tab.title.text": "\uD14D\uC2A4\uD2B8",
  "inspector.tab.title.code": "\uCF54\uB4DC",
  "inspector.tab.title.history": "\uAE30\uB85D",
  "timeline.property.title": "\uD0C0\uC784\uB77C\uC778",
  "timeline.property.resize": "\uD0C0\uC784\uB77C\uC778 \uB192\uC774\uB97C \uBCC0\uACBD\uD569\uB2C8\uB2E4. \uB4DC\uB798\uADF8 \uD574\uC8FC\uC138\uC694.",
  "timeline.animation.property.title": "\uC560\uB2C8\uBA54\uC774\uC158",
  "timeline.play.control.play": "\uD50C\uB808\uC774",
  "timeline.play.control.pause": "\uBA48\uCDA4",
  "timeline.play.control.first": "\uCC98\uC74C\uC73C\uB85C",
  "timeline.play.control.prev": "\uC774\uC804\uC73C\uB85C",
  "timeline.play.control.next": "\uB2E4\uC74C\uC73C\uB85C",
  "timeline.play.control.last": "\uB9C8\uC9C0\uB9C9\uC73C\uB85C",
  "timeline.play.control.direction": "\uBC29\uD5A5",
  "timeline.play.control.speed": "\uC18D\uB825",
  "timeline.play.control.repeat": "\uBC18\uBCF5",
  "timeline.play.control.infinite": "\uBB34\uD55C",
  "timeline.play.control.normal": "normal",
  "timeline.play.control.alternate": "alternate",
  "timeline.play.control.reverse": "reverse",
  "timeline.play.control.alternate.reverse": "alternate reverse",
  "timeline.value.editor.value": "\uAC12",
  "timeline.value.editor.time": "\uC2DC\uAC04",
  "timeline.value.editor.timing": "\uD0C0\uC774\uBC0D \uD568\uC218",
  "timeline.value.editor.offset.message": "Enter\uD0A4\uB97C \uC785\uB825\uD558\uBA74 \uC801\uC6A9\uB429\uB2C8\uB2E4.",
  "svgfilter.popup.title": "SVG \uD544\uD130",
  "css.item.rotate": "\uD68C\uC804",
  "css.item.rotateX": "X\uCD95 \uD68C\uC804",
  "css.item.rotateY": "Y\uCD95 \uD68C\uC804",
  "css.item.rotateZ": "Z\uCD95 \uD68C\uC804",
  "css.item.rotate3d": "3D \uD68C\uC804",
  "css.item.skewX": "X\uCD95 \uB298\uC774\uAE30",
  "css.item.skewY": "Y\uCD95 \uB298\uC774\uAE30",
  "css.item.translate": "\uC774\uB3D9",
  "css.item.translateX": "X\uCD95 \uC774\uB3D9",
  "css.item.translateY": "Y\uCD95 \uC774\uB3D9",
  "css.item.translateZ": "Z\uCD95 \uC774\uB3D9",
  "css.item.translate3d": "3D \uC774\uB3D9",
  "css.item.perspective": "\uC6D0\uADFC",
  "css.item.scale": "\uD06C\uAE30\uBCC0\uACBD",
  "css.item.scaleX": "X\uCD95 \uD06C\uAE30\uBCC0\uACBD",
  "css.item.scaleY": "Y\uCD95 \uD06C\uAE30\uBCC0\uACBD",
  "css.item.scaleZ": "Z\uCD95 \uD06C\uAE30\uBCC0\uACBD",
  "css.item.scale3d": "3D \uD06C\uAE30\uBCC0\uACBD",
  "css.item.matrix": "\uBCC0\uD658 \uD589\uB82C",
  "css.item.matrix3d": "3D \uBCC0\uD658 \uD589\uB82C",
  "animation.property.title": "CSS \uC560\uB2C8\uBA54\uC774\uC158",
  "animation.property.direction": "\uBC29\uD5A5",
  "animation.property.play.state": "\uD50C\uB808\uC774 \uC0C1\uD0DC",
  "animation.property.fill.mode": "\uCC44\uC6B0\uAE30 \uBAA8\uB4DC",
  "animation.property.delay": "\uB300\uAE30\uC2DC\uAC04",
  "animation.property.duration": "\uC2DC\uAC04",
  "animation.property.iteration.count": "\uBC18\uBCF5 \uD69F\uC218",
  "animation.property.select a keyframe": "\uD0A4\uD504\uB808\uC784\uC744 \uC120\uD0DD\uD574\uC8FC\uC138\uC694",
  "animation.property.popup.title": "CSS \uC560\uB2C8\uBA54\uC774\uC158",
  "animation.property.popup.timing.function": "\uD0C0\uC774\uBC0D \uD568\uC218",
  "animation.property.popup.keyframe": "\uD0A4\uD504\uB808\uC784",
  "animation.property.popup.direction": "\uBC29\uD5A5",
  "animation.property.popup.play.state": "\uD50C\uB808\uC774 \uC0C1\uD0DC",
  "animation.property.popup.fill.mode": "\uCC44\uC6B0\uAE30 \uBAA8\uB4DC",
  "animation.property.popup.delay": "\uB300\uAE30\uC2DC\uAC04",
  "animation.property.popup.duration": "\uC2DC\uAC04",
  "animation.property.popup.iteration": "\uBC18\uBCF5 \uD69F\uC218",
  "animation.property.popup.normal": "\uC2DC\uAC04\uC21C",
  "animation.property.popup.reverse": "\uC5ED\uC2DC\uAC04\uC21C",
  "animation.property.popup.alternate": "\uC655\uBCF5 \uC2DC\uAC04\uC21C",
  "animation.property.popup.alternate-reverse": "\uC655\uBCF5 \uC5ED\uC2DC\uAC04\uC21C",
  "animation.property.popup.none": "none",
  "animation.property.popup.forwards": "forwards",
  "animation.property.popup.backwards": "backwards",
  "animation.property.popup.both": "both",
  "animation.property.popup.Select a keyframe": "\uD0A4\uD504\uB808\uC784\uC744 \uC120\uD0DD\uD574\uC8FC\uC138\uC694.",
  "keyframe.popup.title": "\uD0A4\uD504\uB808\uC784",
  "code.view.property.title": "\uCF54\uB4DC\uBDF0",
  "svg.filter.editor.tab.filter": "\uD544\uD130",
  "svg.filter.editor.tab.preset": "\uD504\uB9AC\uC14B",
  "svg.filter.editor.tab.asset": "\uC5D0\uC14B",
  "svg.filter.editor.GRAPHIC REFERENCES": "\uCC38\uC870 \uADF8\uB798\uD53D",
  "svg.filter.editor.SOURCES": "\uC6D0\uBCF8",
  "svg.filter.editor.MODIFIER": "\uC218\uC815",
  "svg.filter.editor.LIGHTING": "\uBE5B",
  "svg.filter.editor.COMBINERS": "\uACB0\uD569",
  "svg.filter.editor.Template": "\uD15C\uD50C\uB9BF",
  "layout.property.title": "\uB808\uC774\uC544\uC6C3",
  "layout.property.flex": "\uD50C\uB809\uC2A4 \uBC15\uC2A4",
  "layout.property.grid": "\uADF8\uB9AC\uB4DC",
  "layout.property.default": "\uAE30\uBCF8 \uC88C\uD45C",
  "layout.property.resizing.title": "\uC0AC\uC774\uC988 \uC870\uC808",
  "default.layout.item.property.title.constraints": "Constraints",
  "flex.layout.editor.row": "\uD589",
  "flex.layout.editor.column": "\uC5F4",
  "flex.layout.editor.row-reverse": "\uC5ED\uBC29\uD5A5 \uD589",
  "flex.layout.editor.column-reverse": "\uC5ED\uBC29\uD5A5 \uC5F4",
  "flex.layout.editor.nowrap": "\uAC10\uC2F8\uC9C0 \uC54A\uAE30",
  "flex.layout.editor.wrap": "\uAC10\uC2F8\uAE30",
  "flex.layout.editor.wrap-reverse": "\uC5ED\uBC29\uD5A5 \uAC10\uC2F8\uAE30",
  "flex.layout.editor.flex-start": "\uC2DC\uC791",
  "flex.layout.editor.flex-end": "\uB05D",
  "flex.layout.editor.center": "\uC911\uAC04",
  "flex.layout.editor.space-between": "\uACF5\uAC04 \uC911\uAC04 \uCC44\uC6C0",
  "flex.layout.editor.space-around": "\uACF5\uAC04 \uC591\uB05D \uCC44\uC6C0",
  "flex.layout.editor.baseline": "\uAE30\uBCF8\uC120",
  "flex.layout.editor.stretch": "\uD3BC\uCE58\uAE30",
  "flex.layout.editor.direction": "\uBC29\uD5A5",
  "flex.layout.editor.justify-content": "\uCEE8\uD150\uCE20 \uC870\uC815",
  "flex.layout.editor.align-items": "\uC544\uC774\uD15C \uC815\uB82C",
  "flex.layout.editor.align-content": "\uCEE8\uD150\uCE20 \uC815\uB82C",
  "flex.layout.item.property.title": "\uD50C\uB809\uC2A4 \uC544\uC774\uD15C \uC124\uC815",
  "flex.layout.item.property.grow": "\uACF5\uAC04 \uBE44\uC728",
  "flex.layout.item.property.shrink": "\uCD95\uC18C \uBE44\uC728",
  "flex.layout.item.property.basis": "\uCD08\uAE30 \uD06C\uAE30",
  "flex.layout.item.property.none": "\uC5C6\uC74C",
  "flex.layout.item.property.auto": "\uC790\uB3D9",
  "flex.layout.item.property.value": "\uAC12",
  "grid.layout.editor.template.columns": "\uC5F4",
  "grid.layout.editor.column.gap": "\uC5F4 \uAC04\uACA9",
  "grid.layout.editor.template.rows": "\uD589",
  "grid.layout.editor.row.gap": "\uD589 \uAC04\uACA9",
  "grid.box.editor.box.title": "\uC601\uC5ED",
  "grid.box.editor.type": "\uD0C0\uC785",
  "grid.box.editor.repeat": "\uBC18\uBCF5",
  "grid.box.editor.length": "\uAE38\uC774",
  "grid.box.editor.none": "\uC5C6\uC74C",
  "grid.box.editor.auto": "\uC790\uB3D9",
  "grid.box.editor.count": "\uAC1C\uC218",
  "grid.box.editor.value": "\uD06C\uAE30",
  "grid.layout.item.property.title": "\uADF8\uB9AC\uB4DC \uC544\uC774\uD15C \uC124\uC815",
  "grid.layout.item.property.column": "\uC5F4",
  "grid.layout.item.property.row": "\uD589",
  "grid.layout.item.property.start": "\uC2DC\uC791",
  "grid.layout.item.property.End": "\uB05D",
  "grid.layout.item.property.none": "\uC5C6\uC74C",
  "grid.layout.item.property.value": "\uAC12",
  "box.model.property.title": "\uBC15\uC2A4 \uBAA8\uB378",
  "box.model.property.margin": "\uB9C8\uC9C4",
  "box.model.property.padding": "\uD328\uB529",
  "component.items.canvas": "\uCE94\uBC84\uC2A4",
  "component.items.layer": "\uB808\uC774\uC5B4",
  "component.items.3dlayer": "3D \uB808\uC774\uC5B4",
  "component.items.drawing": "\uADF8\uB9AC\uAE30",
  "component.items.custom": "\uC0AC\uC6A9\uC790 \uC815\uC758 \uCEF4\uD3EC\uB10C\uD2B8",
  "component.items.chart": "\uCC28\uD2B8",
  "component.items.plugin": "\uD50C\uB7EC\uADF8\uC778",
  "svg.text.property.title": "SVG Text \uC2A4\uD0C0\uC77C",
  "svg.text.property.textarea": "\uD14D\uC2A4\uD2B8 \uC785\uB825",
  "svg.text.property.size": "\uD3F0\uD2B8 \uD06C\uAE30",
  "svg.text.property.weight": "\uD3F0\uD2B8 \uAD75\uAE30",
  "svg.text.property.style": "\uD3F0\uD2B8 \uC2A4\uD0C0\uC77C",
  "svg.text.property.anchor": "\uD14D\uC2A4\uD2B8 \uC704\uCE58",
  "svg.text.property.family": "\uD3F0\uD2B8 \uAE00\uAF34",
  "svg.text.property.length.adjust": "\uAE38\uC774 \uB300\uC751",
  "svg.text.property.text.length": "\uD14D\uC2A4\uD2B8 \uAE38\uC774",
  "svg.text.property.start.offset": "\uC2DC\uC791 \uC9C0\uC810",
  "fill.picker.popup.title": "\uC0C9 \uCC44\uC6B0\uAE30",
  "gradient.editor.drag.message": "\uB4DC\uB798\uADF8 \uD558\uBA74 \uC911\uC2EC\uC810\uC744 \uC62E\uAE38 \uC218 \uC788\uC2B5\uB2C8\uB2E4.",
  "draw.manager.tolerance": "\uD3EC\uC778\uD2B8 \uD5C8\uC6A9 \uC624\uCC28",
  "pattern.property.title": "\uD328\uD134",
  "pattern.info.popup.title": "\uD328\uD134 \uC815\uBCF4",
  "pattern.info.popup.width": "\uB113\uC774",
  "pattern.info.popup.height": "\uB192\uC774",
  "pattern.info.popup.lineWidth": "\uC120 \uB113\uC774",
  "pattern.info.popup.lineHeight": "\uC120 \uB192\uC774",
  "pattern.info.popup.rotate": "\uD68C\uC804",
  "pattern.info.popup.blend": "\uBE14\uB80C\uB4DC",
  "pattern.info.popup.foreColor": "\uD328\uD134\uC0C9",
  "pattern.info.popup.backColor": "\uBC30\uACBD\uC0C9",
  "stroke.dasharray.editor.add": "\uC810 \uCD94\uAC00",
  "viewport.panning.enable": "space \uB97C \uB204\uB978\uCC44 \uD654\uBA74\uC744 \uB4DC\uB798\uADF8 \uD558\uBA74 \uC601\uC5ED\uC744 \uC6C0\uC9C1\uC77C \uC218 \uC788\uC2B5\uB2C8\uB2E4."
};
var fr_FR = {
  "app.title": "EASYLOGIC",
  "app.sample": (a, b, c2) => {
    return `${a}-${b}-${c2}`;
  },
  "app.lang.en_US": "English",
  "app.lang.ko_KR": "\uD55C\uAD6D\uC5B4",
  "app.lang.fr_FR": "Fran\xE7ais",
  "app.label.lang": "Langue",
  "app.layout.all": "Layout",
  "app.layout.css": "CSS Mode",
  "app.layout.svg": "SVG Mode",
  "app.label.layout": "Menu Layout",
  "app.theme.dark": "Sombre",
  "app.theme.light": "Clair",
  "app.theme.gray": "Gris",
  "app.label.theme": "Th\xE8me",
  "app.tab.title.projects": "Projets",
  "app.tab.title.layers": "Objets",
  "app.tab.title.libraries": "Librarie",
  "app.tab.title.components": "Objet",
  "app.tab.title.artboards": "Artboard",
  "app.tab.title.assets": "Elements",
  "app.tab.title.keyMap": "Clavier",
  "app.confirm.message.artboard.items.removeArtboard": "Do you remove an artboard preview really?",
  "app.confirm.message.custom-component.items.removeCustomComponent": "Do you remove a custom component preview really?",
  "menu.item.download.title": "T\xE9l\xE9charger",
  "menu.item.save.title": "Enregistrer",
  "menu.item.export.title": "Exporter",
  "menu.item.codepen.title": "CodePen",
  "menu.item.fullscreen.title": "Ecran",
  "menu.item.shortcuts.title": "ShortCuts",
  "menu.item.github.title": "Github",
  "menu.item.learn.title": "Docs",
  "menu.item.projects.title": "Projects",
  "project.property.title": "Projet",
  "project.information.property.title": "Information",
  "project.information.property.name": "Nom",
  "project.information.property.description": "Description",
  "artboard.property.title": "Planche",
  "artboard.property.layout.title.flex": "Flex",
  "artboard.property.layout.title.grid": "Grille",
  "layer.tree.property.title": "Objets",
  "layer.tree.property.layout.title.flex": "Flex",
  "layer.tree.property.layout.title.grid": "Grille",
  "alignment.property.title": "Alignment",
  "position.property.title": "Position",
  "position.property.X": "X",
  "position.property.Y": "Y",
  "size.property.title": "Taille",
  "position.property.width": "Largeur",
  "position.property.height": "Hauteur",
  "position.property.opacity": "Opacity",
  "position.property.rotate": "Rotate",
  "background.color.property.title": "Apparance",
  "background.color.property.color": "Couleur",
  "background.color.property.zindex": "z-index",
  "background.color.property.opacity": "Opacit\xE9",
  "background.color.property.blend": "M\xE9lange",
  "background.color.property.overflow": "D\xE9bordement",
  "background.color.property.overflow.visible": "Visible",
  "background.color.property.overflow.hidden": "Cach\xE9",
  "background.color.property.overflow.scroll": "Scroll",
  "background.color.property.overflow.auto": "Auto",
  "blend.normal": "normal",
  "blend.multiply": "multiplie",
  "blend.screen": "\xE9cran",
  "blend.overlay": "couche",
  "blend.darken": "sombre",
  "blend.lighten": "clair",
  "blend.color-dodge": "dodge",
  "blend.color-burn": "brul\xE9",
  "blend.hard-light": "dur",
  "blend.soft-light": "doux",
  "blend.difference": 'diff"rence',
  "blend.exclusion": "exclusion",
  "blend.hue": "teinte",
  "blend.saturation": "saturation",
  "blend.color": "couleur",
  "blend.luminosity": "luminosit\xE9",
  "background.image.property.title": "Remplissage",
  "border.property.title": "Bordure",
  "border.radius.property.title": "Rayon de bordure",
  "boxshadow.property.title": "Ombres",
  "filter.property.title": "Filtre",
  "filter.property.blur": "Flou",
  "filter.property.grayscale": "Echelle de gris",
  "filter.property.hue-rotate": "Rotation teinte",
  "filter.property.invert": "Invertir",
  "filter.property.brightness": "Luminosit\xE9",
  "filter.property.contrast": "Contraste",
  "filter.property.drop-shadow": "Ombre port\xE9e",
  "filter.property.drop-shadow.color": "Couleur",
  "filter.property.drop-shadow.offsetX": "D\xE9calage X",
  "filter.property.drop-shadow.offsetY": "D\xE9calage Y",
  "filter.property.drop-shadow.blurRadius": "Flou",
  "filter.property.opacity": "Opacit\xE9",
  "filter.property.saturate": "Saturation",
  "filter.property.sepia": "S\xE9pia",
  "filter.property.svg": "SVG",
  "font.property.title": "Police",
  "font.property.color": "Couleur",
  "font.property.size": "Taille",
  "font.property.stretch": "Etirement",
  "font.property.weight": "Poids",
  "font.property.style": "Style",
  "font.property.family": "Famille",
  "font.spacing.property.title": "Espaces du texte",
  "font.spacing.property.lineHeight": "Hauteur de ligne",
  "font.spacing.property.letterSpacing": "Espace inter-caract\xE8res",
  "font.spacing.property.wordSpacing": "Espace inter-mots",
  "font.spacing.property.indent": "Identation",
  "backdrop.filter.property.title": "Filtre Backdrop",
  "clippath.property.title": "Chemin du Clip",
  "export.property.title": "Exporter",
  "export.property.download": "T\xE9l\xE9charger",
  "iframe.property.title": "IFrame",
  "image.property.title": "Image",
  "image.property.origin": "Origine",
  "image.property.size": "Taille",
  "image.property.width": "Largeur",
  "image.property.height": "Hauteur",
  "video.property.title": "Video",
  "video.property.play": "Jouer",
  "video.property.pause": "Pause",
  "video.property.volume": "Volume",
  "video.property.playbackRate": "Vitesse de lecture",
  "video.property.currentTime": "Temps actuel",
  "video.property.playTime": "Temps de lecture",
  "motion.property.title": "Mouvement",
  "text.property.title": "Style Texte",
  "text.property.align": "Alignement",
  "text.property.transform": "Transformation",
  "text.property.decoration": "D\xE9coration",
  "text.clip.property.title": "Clip Texte",
  "text.shadow.property.title": "Ombres Texte",
  "text.fill.property.title": "Remplissage Texte",
  "text.fill.property.fill": "Remplissage",
  "text.fill.property.stroke": "Trait",
  "text.fill.property.strokeWidth": "Largeur",
  "transform.property.title": "Transformation",
  "transform.origin.property.title": "Origine Transformation",
  "transition.property.title": "Transition CSS",
  "keyframe.property.title": "Image cl\xE9 CSS",
  "selector.property.title": "S\xE9l\xE9cteur",
  "selector.property.none": "Aucun s\xE9l\xE9cteur",
  "path.data.property.title": "Information Chemin",
  "polygon.data.property.title": "Information Polygone",
  "perspective.property.title": "Perspective",
  "perspective.origin.property.title": "Origine Perspective",
  "svg.item.property.title": "Appearance",
  "svg.item.property.isMotionPath": "Chemin de mouvement",
  "svg.item.property.fill": "Remplissage",
  "svg.item.property.fillOpacity": "Opacit\xE9",
  "svg.item.property.path": "Chemin",
  "svg.item.property.polygon": "Polygone",
  "svg.item.property.totalLength": "Longueur totale",
  "svg.item.property.fillRule": "R\xE8gle remplissage",
  "svg.item.property.stroke": "Trait",
  "svg.item.property.strokeWidth": "Largeur de trait",
  "svg.item.property.dashArray": "Suite tiret",
  "svg.item.property.dashOffset": "D\xE9calage tiret",
  "svg.item.property.lineCap": "Chapeau Ligne",
  "svg.item.property.lineJoin": "Jonction ligne",
  "svg.item.property.filter": "Filtre",
  "svg.item.property.blend": "Blend Mode",
  "border.editor.all": "Tout",
  "border.editor.width": "Largeur",
  "border.editor.style": "Style",
  "border.editor.color": "Couleur",
  "border.editor.top": "Haut",
  "border.editor.left": "Gauche",
  "border.editor.right": "Droite",
  "border.editor.bottom": "Bas",
  "border.radius.editor.topLeft": "Haut gauche",
  "border.radius.editor.topRight": "Haut droite",
  "border.radius.editor.bottomLeft": "Bas gauche",
  "border.radius.editor.bottomRight": "Bas droite",
  "boxshadow.editor.blur": "Flou",
  "boxshadow.editor.spread": "Etalement",
  "css.property.editor.properties": "Propri\xE9t\xE9s",
  "offset.path.list.editor.path": "Chemin",
  "offset.path.list.editor.totalLength": "Longueur totale",
  "offset.path.list.editor.distance": "Distance",
  "offset.path.list.editor.direction": "Direction",
  "offset.path.list.editor.rotate": "Rotation",
  "svgfilter.select.editor.message.create": "Cr\xE9er un filtre svg",
  "svgfilter.select.editor.message.select": "S\xE9lection filtre",
  "fill.editor.message.click.image": "Cliquez sur aper\xE7u si vous souhaitez s\xE9lectionner une image",
  "fill.editor.message.drag.position": "Prendre pour changer la position centrale",
  "fill.editor.x1": "D\xE9but X",
  "fill.editor.x2": "Fin X",
  "fill.editor.y1": "D\xE9but Y",
  "fill.editor.y2": "Fin Y",
  "fill.editor.spread": "Etalement",
  "fill.editor.offset": "D\xE9calage",
  "fill.editor.cx": "Centre X",
  "fill.editor.cy": "Centre Y",
  "fill.editor.r": "Rayon de fin",
  "fill.editor.fx": "D\xE9part X",
  "fill.editor.fy": "D\xE9part Y",
  "fill.editor.fr": "Rayon de d\xE9part",
  "perspective.origin.editor.originX": "Origine X",
  "perspective.origin.editor.originY": "Origine Y",
  "path.manager.msg": "Appuyer ESC ou Entr\xE9z keypour fermer Edition",
  "path.manager.mode.done": "Done",
  "path.manager.mode.modify": "Modifier",
  "path.manager.mode.path": "Chemin",
  "path.manager.mode.warp": "Warp",
  "path.manager.mode.transform": "Transformer",
  "path.manager.mode.reverse": "Reverse",
  "path.manager.mode.flipX": "Retouner X",
  "path.manager.mode.flipY": "Retouner Y",
  "path.manager.mode.flipOrigin": "Retouner Origine",
  "colorpicker.popup.title": "Pipette",
  "selector.popup.title": "Propi\xE9t\xE9 de S\xE9lecteur",
  "selector.popup.selector": "S\xE9lecteur",
  "background.image.position.popup.title": "Motif de fond",
  "background.image.position.popup.size": "Taille",
  "background.image.position.popup.width": "Largeur",
  "background.image.position.popup.height": "Hauteur",
  "background.image.position.popup.repeat": "Rep\xE8te",
  "background.image.position.popup.blend": "M\xE9lange",
  "background.image.position.popup.type.repeat": "rep\xE8te",
  "background.image.position.popup.type.no-repeat": "sans rep\xE9tition",
  "background.image.position.popup.type.repeat-x": "rep\xE8te-x",
  "background.image.position.popup.type.repeat-y": "rep\xE8te-y",
  "background.image.position.popup.type.space": "espace",
  "background.image.position.popup.type.round": "rond",
  "gradient.picker.popup.title": "S\xE9lection Gradient & Image",
  "image.asset.property.title": "Image",
  "video.asset.property.title": "Vid\xE9o",
  "color.asset.property.title": "Couleur",
  "gradient.asset.property.title": "Gradient",
  "pattern.asset.property.title": "Motif",
  "svgfilter.asset.property.title": "Filtre SVG",
  "inspector.tab.title.design": "Design",
  "inspector.tab.title.component": "Composant",
  "inspector.tab.title.transition": "Animation",
  "inspector.tab.title.asset": "El\xE9ments",
  "inspector.tab.title.text": "Texte",
  "inspector.tab.title.code": "Code",
  "inspector.tab.title.history": "History",
  "inspector.tab.title.history": "History",
  "timeline.property.title": "Chronologie",
  "timeline.property.resize": "Drag if you want to resize timeline height.",
  "timeline.animation.property.title": "Animations",
  "timeline.play.control.play": "Jouer",
  "timeline.play.control.pause": "Pause",
  "timeline.play.control.first": "Premier",
  "timeline.play.control.prev": "Pr\xE9c\xE9dent",
  "timeline.play.control.next": "Suivant",
  "timeline.play.control.last": "Dernier",
  "timeline.play.control.direction": "Direction",
  "timeline.play.control.speed": "Vitesse",
  "timeline.play.control.repeat": "R\xE9p\xE9ter",
  "timeline.play.control.infinite": "Infini",
  "timeline.play.control.normal": "normal",
  "timeline.play.control.alternate": "alternatif",
  "timeline.play.control.reverse": "inverse",
  "timeline.play.control.alternate.reverse": "inverse alternatif",
  "timeline.value.editor.value": "Valeur",
  "timeline.value.editor.time": "Temps",
  "timeline.value.editor.timing": "Calage temps",
  "timeline.value.editor.offset.message": "Please input enter key to change time offset.",
  "svgfilter.popup.title": "Filtre SVG",
  "css.item.rotate": "Rotation",
  "css.item.rotateX": "Rotation X",
  "css.item.rotateY": "Rotation Y",
  "css.item.rotateZ": "Rotation Z",
  "css.item.rotate3d": "Rotation 3D",
  "css.item.skewX": "Oblique X",
  "css.item.skewY": "Oblique Y",
  "css.item.translate": "Translation",
  "css.item.translateX": "Translation X",
  "css.item.translateY": "Translation Y",
  "css.item.translateZ": "Translation Z",
  "css.item.translate3d": "Translation 3D",
  "css.item.perspective": "Persp\xE9ctive",
  "css.item.scale": "Echelle",
  "css.item.scaleX": "Echelle X",
  "css.item.scaleY": "Echelle Y",
  "css.item.scaleZ": "Echelle Z",
  "css.item.scale3d": "Echelle 3D",
  "css.item.matrix": "Matrice",
  "css.item.matrix3d": "Matrice 3D",
  "animation.property.title": "Animation CSS",
  "animation.property.direction": "Direction",
  "animation.property.play.state": "Etat lecture",
  "animation.property.fill.mode": "Mode remplissage",
  "animation.property.delay": "D\xE9lais",
  "animation.property.duration": "Dur\xE9e",
  "animation.property.iteration.count": "Nombre It\xE9rations",
  "animation.property.Select a keyframe": "Selectionner une image cl\xE9",
  "animation.property.popup.title": "Animation",
  "animation.property.popup.timing.function": "Fonction temps",
  "animation.property.popup.keyframe": "image cl\xE9",
  "animation.property.popup.direction": "Direction",
  "animation.property.popup.play.state": "Etat lecture",
  "animation.property.popup.fill.mode": "Mode remplissage",
  "animation.property.popup.delay": "D\xE9lais",
  "animation.property.popup.duration": "Dur\xE9\xE9",
  "animation.property.popup.iteration": "It\xE9ration",
  "animation.property.popup.normal": "normal",
  "animation.property.popup.reverse": "inverse",
  "animation.property.popup.alternate": "alternatif",
  "animation.property.popup.alternate-reverse": "inverse alternatif",
  "animation.property.popup.none": "Aucun",
  "animation.property.popup.forwards": "en avant",
  "animation.property.popup.backwards": "en arri\xE8re",
  "animation.property.popup.both": "les deux",
  "animation.property.popup.Select a keyframe": "Selectionner une image cl\xE9",
  "keyframe.popup.title": "image cl\xE9",
  "code.view.property.title": "Vue code",
  "svg.filter.editor.tab.filter": "Filtrer",
  "svg.filter.editor.tab.preset": "Pre-rempli",
  "svg.filter.editor.tab.asset": "El\xE9ments",
  "svg.filter.editor.GRAPHIC REFERENCES": "REFERENCES GRAPHIQUES",
  "svg.filter.editor.SOURCES": "SOURCES",
  "svg.filter.editor.MODIFIER": "MODIFIER",
  "svg.filter.editor.LIGHTING": "ECLAIRAGE",
  "svg.filter.editor.COMBINERS": "COMBINER",
  "svg.filter.editor.Template": "Mod\xE8le",
  "layout.property.title": "Disposition",
  "layout.property.flex": "Bo\xEEte Flex",
  "layout.property.grid": "Grille",
  "layout.property.default": "D\xE9faut",
  "default.layout.item.property.title.constraints": "Constraints",
  "flex.layout.editor.row": "Ligne",
  "flex.layout.editor.column": "Colonne",
  "flex.layout.editor.row-reverse": "Inverse ligne",
  "flex.layout.editor.column-reverse": "Inverse Colonne",
  "flex.layout.editor.nowrap": "Non-emball\xE9",
  "flex.layout.editor.wrap": "Emball\xE9 (wrap)",
  "flex.layout.editor.wrap-reverse": "Inverse emball\xE9",
  "flex.layout.editor.flex-start": "D\xE9but",
  "flex.layout.editor.flex-end": "Fin",
  "flex.layout.editor.center": "Centrer",
  "flex.layout.editor.space-between": "Entre",
  "flex.layout.editor.space-around": "Autour",
  "flex.layout.editor.baseline": "Base",
  "flex.layout.editor.stretch": "Etirement",
  "flex.layout.editor.direction": "Direction",
  "flex.layout.editor.justify-content": "Justifier",
  "flex.layout.editor.align-items": "Aligner objets",
  "flex.layout.editor.align-content": "Aligner contenu",
  "flex.layout.item.property.title": "D\xE9tail Disposition objet",
  "flex.layout.item.property.grow": "Augmenter Flex",
  "flex.layout.item.property.shrink": "R\xE9duire Flex",
  "flex.layout.item.property.basis": "Base Flex",
  "flex.layout.item.property.none": "Aucun",
  "flex.layout.item.property.auto": "auto",
  "flex.layout.item.property.value": "valeur",
  "grid.layout.editor.template.columns": "Colonne",
  "grid.layout.editor.column.gap": "Espace Colonne",
  "grid.layout.editor.template.rows": "Lignes",
  "grid.layout.editor.row.gap": "Espace lignes",
  "grid.box.editor.box.title": "Bo\xEEte",
  "grid.box.editor.type": "Type",
  "grid.box.editor.repeat": "R\xE9p\xE9ter",
  "grid.box.editor.length": "Longueur",
  "grid.box.editor.none": "Aucun",
  "grid.box.editor.auto": "Auto",
  "grid.box.editor.count": "Compte",
  "grid.box.editor.value": "Taille",
  "grid.layout.item.property.title": "D\xE9tail disposition objets",
  "grid.layout.item.property.column": "Colonne",
  "grid.layout.item.property.row": "Ligne",
  "grid.layout.item.property.start": "D\xE9but",
  "grid.layout.item.property.end": "Fin",
  "grid.layout.item.property.none": "Aucun",
  "grid.layout.item.property.value": "valeur",
  "box.model.property.title": "Mod\xE8le",
  "box.model.property.margin": "Marge",
  "box.model.property.padding": "Espace",
  "component.items.canvas": "Toile",
  "component.items.layer": "Objet",
  "component.items.3dlayer": "Objet 3D",
  "component.items.drawing": "Dessin",
  "component.items.custom": "Composant personnalis\xE9",
  "component.items.chart": "Chart",
  "component.items.plugin": "Plugin",
  "svg.text.property.title": "Style SVG Texte",
  "svg.text.property.textarea": "Zone Texte",
  "svg.text.property.size": "Taille",
  "svg.text.property.weight": "Poids",
  "svg.text.property.style": "Style",
  "svg.text.property.anchor": "Ancre Texte",
  "svg.text.property.family": "Famille",
  "svg.text.property.length.adjust": "Ajusteement longueur",
  "svg.text.property.text.length": "Ajusteement Texte",
  "svg.text.property.start.offset": "D\xE9callage d\xE9part",
  "fill.picker.popup.title": "S\xE9lection Fragment SVG",
  "gradient.editor.drag.message": "Glisser pour d\xE9placer centre.",
  "draw.manager.tolerance": "Tol\xE9rance",
  "pattern.property.title": "Motif",
  "pattern.info.popup.title": "Info Motif",
  "pattern.info.popup.width": "Largeur",
  "pattern.info.popup.height": "Hauteur",
  "pattern.info.popup.lineWidth": "Largeur ligne",
  "pattern.info.popup.lineHeight": "Hauteur de ligne",
  "pattern.info.popup.rotate": "Rotatation",
  "pattern.info.popup.blend": "M\xE9lange",
  "pattern.info.popup.foreColor": "Avant",
  "pattern.info.popup.backColor": "Arri\xE8re",
  "stroke.dasharray.editor.add": "Ajout tiret",
  "viewport.panning.enable": "You can move the area by holding down space and dragging the screen."
};
var locales = {
  en_US,
  fr_FR,
  ko_KR
};
function defaultMessages(editor) {
  Object.keys(locales).forEach(function(locale) {
    editor.registerI18nMessage(locale, locales[locale]);
  });
}
var texture = `
<svg xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 0 24 24" width="24px" fill="#000000">
    <path d="M19.51 3.08L3.08 19.51c.09.34.27.65.51.9.25.24.56.42.9.51L20.93 4.49c-.19-.69-.73-1.23-1.42-1.41zM11.88 3L3 11.88v2.83L14.71 3h-2.83zM5 3c-1.1 0-2 .9-2 2v2l4-4H5zm14 18c.55 0 1.05-.22 1.41-.59.37-.36.59-.86.59-1.41v-2l-4 4h2zm-9.71 0h2.83L21 12.12V9.29L9.29 21z"/>
</svg>
`;
var TextureView$1 = "";
class TextureView extends EditorElement {
  components() {
    return {
      Tabs
    };
  }
  template() {
    const isItemMode = this.$config.get("editor.design.mode") === "item";
    return `<div class='elf--texture'>
      <object refClass="Tabs" 
        ref="$tab" 
        ${variable$4({
      selectedValue: isItemMode ? "svg" : "css",
      onchange: (value) => {
        this.$config.set("inspector.selectedValue", value);
      }
    })}
      >

        ${isItemMode ? "" : `
          <object refClass="TabPanel" value="css" title="CSS">
            <object refClass="CSSTextureView" />
          </object>
        `}


        <object refClass="TabPanel" value="svg" title="SVG">
          <object refClass="SVGTextureView" />
        </object>            
      </object>
    </div>`;
  }
}
const cssPatterns = [
  {
    itemType: "circle",
    name: "base",
    attrs: {
      "background-color": "#ececec"
    }
  },
  {
    itemType: "circle",
    name: "base",
    attrs: {
      "background-color": "black"
    }
  },
  {
    itemType: "circle",
    name: "base",
    attrs: {
      "background-color": "red"
    }
  },
  {
    itemType: "circle",
    name: "base",
    attrs: {
      "background-image": `
      background-image: linear-gradient(to right, #ececec, black 100%);
    `
    }
  },
  {
    itemType: "circle",
    name: "base",
    attrs: {
      "background-image": `
      background-image: linear-gradient(to right, #ececec, black 100%);
    `,
      "border": `
      border:10px solid black;
    `
    }
  }
];
class CSSTextureView extends EditorElement {
  template() {
    return `
      <div class="pattern-list css-pattern-list" ref="$css-list"></div>
    `;
  }
  [LOAD("$css-list")]() {
    return cssPatterns.map((it, index2) => {
      const svg = this.$editor.svg.render(this.$model.createModel(__spreadValues({
        itemType: it.itemType,
        width: 70,
        height: 70
      }, it.attrs), false));
      return `
        <div class="pattern-item" data-index="${index2}">
          <div class="preview">${svg}</div>
        </div>
      `;
    });
  }
  [CLICK("$css-list .pattern-item")](e2) {
    const index2 = +e2.$dt.data("index");
    const pattern = cssPatterns[index2];
    e2.$dt.onlyOneClass("selected");
    this.emit("addLayerView", pattern.itemType, pattern.attrs);
  }
}
const svgPatterns = [
  {
    itemType: "svg-path",
    name: "path",
    attrs: {
      "background-color": "transparent",
      stroke: "black",
      "stroke-width": 2,
      d: PathParser.makeRect(0, 0, 80, 80).d
    }
  },
  {
    itemType: "svg-path",
    name: "line",
    attrs: {
      "background-color": "transparent",
      stroke: "black",
      "stroke-width": 2,
      d: PathParser.makeLine(0, 0, 80, 80).d
    }
  },
  {
    itemType: "svg-path",
    name: "line 2",
    attrs: {
      "background-color": "transparent",
      stroke: "black",
      "stroke-width": 2,
      fill: "#ececec",
      d: PathParser.makeLine(0, 80, 80, 0).d
    }
  },
  {
    itemType: "svg-path",
    name: "circle",
    attrs: {
      "background-color": "transparent",
      stroke: "black",
      "stroke-width": 2,
      fill: "#ececec",
      originWidth: 80,
      originHeight: 80,
      d: PathParser.makeCircle(0, 0, 80, 80).d
    }
  },
  {
    itemType: "polygon",
    name: "polygon - 3",
    attrs: {
      "background-color": "transparent",
      stroke: "black",
      "stroke-width": 2,
      fill: "#ececec",
      count: 3,
      originWidth: 80,
      originHeight: 80,
      d: PathParser.makePolygon(80, 80, 3).d
    }
  },
  {
    itemType: "polygon",
    name: "polygon - 4",
    attrs: {
      "background-color": "transparent",
      stroke: "black",
      "stroke-width": 2,
      fill: "#ececec",
      count: 4,
      originWidth: 80,
      originHeight: 80,
      d: PathParser.makePolygon(80, 80, 4).d
    }
  },
  {
    itemType: "polygon",
    name: "polygon - 4",
    attrs: {
      "background-color": "transparent",
      stroke: "black",
      "stroke-width": 2,
      fill: "#ececec",
      count: 5,
      originWidth: 80,
      originHeight: 80,
      d: PathParser.makePolygon(80, 80, 5).d
    }
  },
  {
    itemType: "polygon",
    name: "polygon - 4",
    attrs: {
      "background-color": "transparent",
      stroke: "black",
      "stroke-width": 2,
      fill: "#ececec",
      count: 6,
      originWidth: 80,
      originHeight: 80,
      d: PathParser.makePolygon(80, 80, 6).d
    }
  },
  {
    itemType: "polygon",
    name: "polygon - 4",
    attrs: {
      "background-color": "transparent",
      stroke: "black",
      "stroke-width": 2,
      fill: "#ececec",
      count: 7,
      originWidth: 80,
      originHeight: 80,
      d: PathParser.makePolygon(80, 80, 7).d
    }
  },
  {
    itemType: "polygon",
    name: "polygon - 4",
    attrs: {
      "background-color": "transparent",
      stroke: "black",
      "stroke-width": 2,
      fill: "#ececec",
      count: 12,
      originWidth: 80,
      originHeight: 80,
      d: PathParser.makePolygon(80, 80, 12).d
    }
  },
  {
    itemType: "star",
    name: "star - 5",
    attrs: {
      "background-color": "transparent",
      stroke: "black",
      "stroke-width": 2,
      fill: "#ececec",
      originWidth: 80,
      originHeight: 80,
      count: 5,
      radius: 0.5,
      d: PathParser.makeStar(80, 80, 5, 0.5).d
    }
  },
  {
    itemType: "star",
    name: "curved star - 5",
    attrs: {
      "background-color": "transparent",
      stroke: "black",
      "stroke-width": 2,
      fill: "#ececec",
      originWidth: 80,
      originHeight: 80,
      count: 5,
      radius: 0.5,
      d: PathParser.makeCurvedStar(80, 80, 5, 0.5).d
    }
  }
];
class SVGTextureView extends EditorElement {
  template() {
    return `
      <div class="pattern-list svg-pattern-list" ref="$svg-list"></div>
    `;
  }
  [LOAD("$svg-list")]() {
    return svgPatterns.map((it, index2) => {
      let d = it.attrs.d;
      if (d) {
        const path = PathParser.fromSVGString(d);
        if (it.attrs.originWidth) {
          path.rect();
          path.scale(60 / it.attrs.originWidth, 60 / it.attrs.originHeight);
        } else {
          const rect2 = path.rect();
          path.scale(70 / rect2.width, 70 / rect2.height);
        }
        d = path.d;
      }
      const svg = this.$editor.svg.render(this.$model.createModel(__spreadProps(__spreadValues({
        itemType: it.itemType,
        width: 80,
        height: 80
      }, it.attrs), {
        d
      }), false));
      return `
        <div class="pattern-item" data-index="${index2}">
          <div class="preview">${svg}</div>
        </div>
      `;
    });
  }
  [CLICK("$svg-list .pattern-item")](e2) {
    const index2 = +e2.$dt.data("index");
    const pattern = svgPatterns[index2];
    e2.$dt.onlyOneClass("selected");
    this.emit("addLayerView", pattern.itemType, pattern.attrs);
  }
}
function defaultPatterns(editor) {
  editor.registerElement({
    TextureView,
    CSSTextureView,
    SVGTextureView
  });
  editor.registerMenuItem("leftbar.tab", {
    TextureView: {
      value: "texture",
      title: "Texture",
      icon: texture,
      designMode: ["design", "item"]
    }
  });
  editor.registerMenuItem("leftbar.tab.texture", {
    TextureView
  });
}
class OrderDown extends MenuItem {
  getIconString() {
    return "to_back";
  }
  getTitle() {
    return "To Back";
  }
  clickButton(e2) {
    this.emit("item.move.depth.down");
  }
}
class OrderFirst extends MenuItem {
  getIconString() {
    return "to_front";
  }
  getTitle() {
    return "To First";
  }
  clickButton(e2) {
    this.emit("item.move.depth.first");
  }
}
class OrderLast extends MenuItem {
  getIconString() {
    return "to_back";
  }
  getTitle() {
    return "To Last";
  }
  clickButton(e2) {
    this.emit("item.move.depth.last");
  }
}
class OrderTop extends MenuItem {
  getIconString() {
    return "to_front";
  }
  getTitle() {
    return "To Front";
  }
  clickButton(e2) {
    this.emit("item.move.depth.up");
  }
}
var DepthProperty$1 = "";
class DepthProperty extends BaseProperty {
  components() {
    return {
      OrderTop,
      OrderDown,
      OrderFirst,
      OrderLast,
      OrderTop,
      OrderDown
    };
  }
  getTitle() {
    return this.$i18n("alignment.property.title");
  }
  isHideHeader() {
    return true;
  }
  getBody() {
    return `
      <div class="elf--depth-item">
        <object refClass="OrderTop" />
        <object refClass="OrderDown" />
        <object refClass="OrderFirst" />
        <object refClass="OrderLast" />        
      </div>
    `;
  }
}
function depth(editor) {
  editor.registerMenuItem("inspector.tab.style", {
    DepthProperty
  });
}
var ExportProperty$1 = "";
class ExportProperty extends BaseProperty {
  getTitle() {
    return this.$i18n("export.property.title");
  }
  isFirstShow() {
    return true;
  }
  getClassName() {
    return "elf--export-property";
  }
  getBody() {
    return `
        <div class='export-item svg'>
          <label>SVG</label>
          <button ref='$svg'>${iconUse$1("archive")} ${this.$i18n("export.property.download")}</button>
        </div>
        <div class='export-item png'>
          <label>PNG</label>
          <button ref='$png'>${iconUse$1("archive")} ${this.$i18n("export.property.download")}</button>
        </div> 
      `;
  }
  [CLICK("$svg")]() {
    this.emit("downloadSVG");
  }
  [CLICK("$png")]() {
    this.emit("downloadPNG");
  }
}
function exportResource(editor) {
  editor.registerMenuItem("inspector.tab.style", {
    ExportProperty
  });
}
const filter_list = [
  "blur",
  "grayscale",
  "hue-rotate",
  "invert",
  "brightness",
  "contrast",
  "drop-shadow",
  "opacity",
  "saturate",
  "sepia",
  "svg"
];
var FilterProperty$1 = "";
class FilterProperty extends BaseProperty {
  initialize() {
    super.initialize();
    this.notEventRedefine = true;
  }
  getTitle() {
    return this.$i18n("filter.property.title");
  }
  hasKeyframe() {
    return true;
  }
  isFirstShow() {
    return true;
  }
  afterRender() {
    this.show();
  }
  getKeyframeProperty() {
    return "filter";
  }
  getTitleClassName() {
    return "filter";
  }
  getBodyClassName() {
    return "no-padding";
  }
  getBody() {
    return `<div class='full filter-property' ref='$body'></div>`;
  }
  getTools() {
    return `
      <select class='filter-select' ref="$filterSelect">      
      </select>
      <button type="button" ref="$add" title="add Filter">${iconUse$1("add")}</button>
    `;
  }
  [CLICK("$add")]() {
    var filterType = this.refs.$filterSelect.value;
    this.children.$filterEditor.trigger("add", filterType);
  }
  [LOAD("$filterSelect")]() {
    var list2 = filter_list.map((it) => {
      return { title: this.$i18n(`filter.property.${it}`), value: it };
    });
    var svgFilterList = this.getSVGFilterList();
    var totalList = [];
    if (svgFilterList.length) {
      totalList = [
        ...list2,
        { title: "-------", value: "" },
        ...svgFilterList
      ];
    } else {
      totalList = [
        ...list2
      ];
    }
    return totalList.map((it) => {
      var { title: title2, value } = it;
      return `<option value='${value}'>${title2}</option>`;
    });
  }
  getSVGFilterList() {
    var current = this.$selection.currentProject;
    var arr = [];
    if (current) {
      arr = current.svgfilters.map((it) => {
        var id = it.id;
        return {
          title: `svg - #${id}`,
          value: id
        };
      });
    }
    return arr;
  }
  [LOAD("$body")]() {
    var current = this.$selection.current || {};
    var value = current.filter;
    return createComponent("FilterEditor", {
      ref: "$filterEditor",
      key: "filter",
      value,
      onchange: "changeFilterEditor"
    });
  }
  [SUBSCRIBE_SELF("changeFilterEditor")](key, filter2) {
    this.command("setAttributeForMulti", "change filter", this.$selection.packByValue({
      [key]: filter2
    }));
  }
  get editableProperty() {
    return "filter";
  }
  [SUBSCRIBE("refreshSelection") + IF("checkShow") + DEBOUNCE(1e3)]() {
    this.refresh();
  }
  [SUBSCRIBE("refreshSVGArea") + DEBOUNCE(1e3)]() {
    this.load("$filterSelect");
  }
}
function filter(editor) {
  editor.registerMenuItem("inspector.tab.style", {
    FilterProperty
  });
}
function font(editor) {
  editor.registerMenuItem("inspector.tab.style", {
    FontProperty: ObjectProperty.create({
      title: editor.$i18n("font.property.title"),
      editableProperty: "font",
      preventUpdate: true
    })
  });
  editor.registerInspector("font", (current) => {
    return [
      {
        key: "font-family",
        editor: "SelectEditor",
        editorOptions: {
          compact: true,
          label: "font_download",
          options: [
            "",
            "Arial",
            "Arial Black",
            "Times New Roman",
            "Times",
            "Courier New",
            "Courier",
            "Verdana",
            "Georgia",
            "Palatino",
            "Garamond",
            "Bookman",
            "Tahoma",
            "Trebuchet MS",
            "Impact",
            "Comic Sans MS",
            "serif",
            "sans-serif",
            "monospace",
            "cursive",
            "fantasy",
            "system-ui"
          ]
        },
        defaultValue: current["font-family"] || ""
      },
      {
        type: "column",
        size: [2, 1, 1],
        columns: [
          {
            key: "color",
            editor: "ColorViewEditor",
            editorOptions: {
              compact: true
            },
            defaultValue: current["color"] || "#000"
          },
          {
            key: "font-size",
            editor: "NumberInputEditor",
            editorOptions: {
              label: "format_size",
              compact: true,
              min: 8,
              max: 100,
              step: 1
            },
            defaultValue: Length.parse(current["font-size"]).value,
            convert: (key, value) => Length.px(value)
          },
          {
            key: "font-weight",
            editor: "NumberInputEditor",
            editorOptions: {
              label: "format_bold",
              compact: true,
              min: 100,
              max: 900,
              step: 100
            },
            defaultValue: current["font-weight"] || 400
          }
        ]
      },
      {
        type: "column",
        size: [1, 1, 1],
        gap: 10,
        columns: [
          {
            key: "text-indent",
            editor: "NumberInputEditor",
            editorOptions: {
              label: "format_indent",
              min: -100,
              max: 100,
              step: 1,
              compact: true
            },
            defaultValue: Length.parse(current["text-indent"]).value,
            convert: (key, value) => Length.px(value)
          },
          {
            key: "line-height",
            editor: "NumberInputEditor",
            editorOptions: {
              label: "format_line_spacing",
              min: 0,
              max: 10,
              step: 0.01,
              compact: true
            },
            defaultValue: current["line-height"] || 1.2
          },
          {
            key: "letter-spacing",
            editor: "NumberInputEditor",
            editorOptions: {
              label: "space",
              min: -100,
              max: 100,
              step: 1,
              compact: true
            },
            defaultValue: Length.parse(current["letter-spacing"]).value,
            convert: (key, value) => Length.px(value)
          }
        ]
      }
    ];
  });
}
class SVGGradient extends Gradient {
  toString() {
    return "";
  }
  toSVGString(id) {
    return "";
  }
  toFillValue(id) {
    return "";
  }
}
class SVGLinearGradient extends SVGGradient {
  getDefaultObject(obj2) {
    return super.getDefaultObject(__spreadValues({
      type: "linear-gradient",
      x1: "0%",
      y1: "0%",
      x2: "100%",
      y2: "0%",
      spreadMethod: "pad"
    }, obj2));
  }
  toCloneObject() {
    return __spreadValues(__spreadValues({}, super.toCloneObject()), this.attrs("x1", "y1", "x2", "y2", "spreadMethod"));
  }
  toString() {
    if (this.colorsteps.length === 0)
      return "";
    var colorString = this.getColorString();
    var { x1, y1, x2, y2, spreadMethod } = this.json;
    var opt = [x1, y1, x2, y2, spreadMethod].join(" ");
    var result = `${this.json.type}(${opt}, ${colorString})`;
    return result;
  }
  toSVGString(id) {
    var { x1, y1, x2, y2, spreadMethod } = this.json;
    return `
        <linearGradient 
            id="${id}"
            x1="${x1}"
            x2="${x2}"
            y1="${y1}"
            y2="${y2}"
            spreadMethod="${spreadMethod}"
          >
          ${this.colorsteps.map((it) => {
      return `<stop offset="${it.percent}%"  stop-color="${it.color}" ></stop>`;
    }).join("\n")}
        </linearGradient>
      `;
  }
  toFillValue(id) {
    return `url(#${id})`;
  }
  static toLinearGradient(colorsteps) {
    if (colorsteps.length === 0) {
      return "none";
    }
    var gradient2 = new LinearGradient({
      angle: "to right",
      colorsteps
    });
    return gradient2 + "";
  }
  static parse(str) {
    var results = convertMatches(str);
    var opt = {};
    var colorsteps = [];
    results.str.split("(")[1].split(")")[0].split(",").map((it) => it.trim()).forEach((newValue, index2) => {
      if (newValue.includes("@")) {
        newValue = reverseMatches(newValue, results.matches);
        colorsteps.push.apply(colorsteps, ColorStep.parse(newValue));
      } else {
        var [x1, y1, x2, y2, spreadMethod] = newValue.split(" ");
        opt.x1 = Length.parse(x1);
        opt.y1 = Length.parse(y1);
        opt.x2 = Length.parse(x2);
        opt.y2 = Length.parse(y2);
        opt.spreadMethod = spreadMethod || "pad";
      }
    });
    return new SVGLinearGradient(__spreadProps(__spreadValues({}, opt), { colorsteps }));
  }
}
class SVGRadialGradient extends SVGGradient {
  getDefaultObject(obj2 = {}) {
    return super.getDefaultObject(__spreadValues({
      type: "radial-gradient",
      cx: "50%",
      cy: "50%",
      r: "50%",
      fx: "50%",
      fy: "50%",
      fr: "0%",
      spreadMethod: "pad"
    }, obj2));
  }
  toCloneObject() {
    return __spreadValues(__spreadValues({}, super.toCloneObject()), this.attrs("cx", "cy", "r", "fx", "fy", "fr", "spreadMethod"));
  }
  toString() {
    if (this.colorsteps.length === 0)
      return "";
    var colorString = this.getColorString();
    var { cx, cy, r, fx, fy, fr, spreadMethod } = this.json;
    var opt = [cx, cy, r, fx, fy, fr, spreadMethod].join(" ");
    var result = `${this.json.type}(${opt}, ${colorString})`;
    return result;
  }
  toSVGString(id) {
    var { cx, cy, r, fx, fy, fr, spreadMethod } = this.json;
    return `
<radialGradient ${OBJECT_TO_PROPERTY$1({ id, cx, cy, r, fx, fy, fr, spreadMethod })} >
  ${this.colorsteps.map((it) => {
      return `<stop offset="${it.percent}%"  stop-color="${it.color}" />`;
    }).join("\n")}
</radialGradient>
`;
  }
  toFillValue(id) {
    return `url(#${id})`;
  }
  static parse(str) {
    var results = convertMatches(str);
    var opt = {};
    var colorsteps = [];
    results.str.split("(")[1].split(")")[0].split(",").map((it) => it.trim()).forEach((newValue, index2) => {
      if (newValue.includes("@")) {
        newValue = reverseMatches(newValue, results.matches);
        colorsteps.push.apply(colorsteps, ColorStep.parse(newValue));
      } else {
        var [cx, cy, r, fx, fy, fr, spreadMethod] = newValue.split(" ");
        opt.cx = cx;
        opt.cy = cy;
        opt.r = r;
        opt.fx = fx;
        opt.fy = fy;
        opt.fr = fr;
        opt.spreadMethod = spreadMethod || "pad";
      }
    });
    return new SVGRadialGradient(__spreadProps(__spreadValues({}, opt), { colorsteps }));
  }
}
class SVGStaticGradient extends SVGGradient {
  getDefaultObject() {
    return super.getDefaultObject({
      type: "static-gradient",
      static: true,
      colorsteps: [
        new ColorStep({ color: "red", percent: 0, index: 0 }),
        new ColorStep({ color: "red", percent: 100, index: 1 })
      ]
    });
  }
  toCloneObject() {
    return __spreadProps(__spreadValues({}, super.toCloneObject()), {
      static: true
    });
  }
  static create(color2 = "transparent") {
    return new SVGStaticGradient({
      colorsteps: [
        new ColorStep({ color: color2, percent: 0, index: 0 }),
        new ColorStep({ color: color2, percent: 100, index: 0 })
      ]
    });
  }
  setColor(color2) {
    this.colorsteps.forEach((it) => {
      it.color = color2;
    });
  }
  toString() {
    var color2 = this.json.colorsteps[0].color;
    return color2;
  }
  toSVGString() {
    return "";
  }
  toFillValue() {
    return this.toString();
  }
  isStatic() {
    return true;
  }
}
const IMAGE_LIST = ["jpg", "jpeg", "png", "gif", "svg"];
class SVGImageResource extends ImageResource {
  getDefaultObject(obj2 = {}) {
    return super.getDefaultObject(__spreadValues({
      type: "url",
      url: "",
      datauri: "",
      patternUnits: "userSpaceOnUse",
      patternWidth: "100%",
      patternHeight: "100%",
      imageX: "0%",
      imageY: "0%",
      imageWidth: "100%",
      imageHeight: "100%"
    }, obj2));
  }
  toCloneObject() {
    return __spreadValues(__spreadValues({}, super.toCloneObject()), this.attrs("url", "datauri", "patternUnits", "patternWidth", "patternHeight", "imageX", "imageY", "imageWidth", "imageHeight"));
  }
  static parse(str) {
    var content2 = str.split("(")[1].split(")")[0];
    var [url, props2] = content2.trim().split("#");
    if (!props2) {
      return new SVGImageResource({ url });
    }
    var [patternUnits, patternWidth, patternHeight, imageX, imageY, imageWidth, imageHeight] = props2.split(",");
    return new SVGImageResource({ patternUnits, patternWidth, patternHeight, imageX, imageY, imageWidth, imageHeight, url });
  }
  isUrl() {
    return true;
  }
  static isImageFile(fileExt) {
    return IMAGE_LIST.includes(fileExt);
  }
  toString() {
    var json = this.json;
    var {
      patternUnits,
      patternWidth,
      patternHeight,
      imageX,
      imageY,
      imageWidth,
      imageHeight,
      url
    } = json;
    var string = [
      patternUnits,
      patternWidth,
      patternHeight,
      imageX,
      imageY,
      imageWidth,
      imageHeight
    ].join(",").trim();
    return `url(${url}#${string})`;
  }
  toSVGString(id, item2 = {}) {
    var {
      patternUnits,
      patternWidth,
      patternHeight,
      imageX,
      imageY,
      imageWidth,
      imageHeight
    } = this.json;
    const localPatternWidth = Length.parse(patternWidth);
    const localPatternHeight = Length.parse(patternHeight);
    const localImageX = Length.parse(imageX);
    const localImageY = Length.parse(imageY);
    const localImageWidth = Length.parse(imageWidth);
    const localImageHeight = Length.parse(imageHeight);
    const width2 = item2.width ? localPatternWidth.toPx(item2.width).value : localPatternWidth;
    const height2 = item2.height ? localPatternHeight.toPx(item2.height).value : localPatternHeight;
    return `
  <pattern ${OBJECT_TO_PROPERTY$1({ id, patternUnits, width: width2, height: height2 })} >
    <image xlink:href="${this.json.datauri || this.json.url}" ${OBJECT_TO_PROPERTY$1({
      x: localImageX.toPx(item2.width).value,
      y: localImageY.toPx(item2.height).value,
      width: localImageWidth.toPx(item2.width).value,
      height: localImageHeight.toPx(item2.height).value,
      preserveAspectRatio: "none"
    })} />
  </pattern>
      `;
  }
  toFillValue(id) {
    return `url(#${id})`;
  }
}
const reg = /((linear\-gradient|radial\-gradient|url)\(([^\)]*)\))/gi;
class SVGFill extends PropertyItem {
  addImageResource(imageResource) {
    this.clear("image-resource");
    return this.addItem("image-resource", imageResource);
  }
  addGradient(gradient2) {
    return this.addImageResource(gradient2);
  }
  setImageUrl(data) {
    if (!data.images)
      return;
    if (!data.images.length)
      return;
    this.reset({
      type: "image",
      image: SVGFill.createImage(data.images[0])
    });
  }
  static createImage(url) {
    return new SVGLImageResource({ url });
  }
  setGradient(data) {
    this.reset({
      type: data.type,
      image: SVGFill.createGradient(data, this.json.image)
    });
  }
  static createGradient(data, gradient2) {
    const colorsteps = data.colorsteps || gradient2.colorsteps;
    let json = gradient2.toJSON();
    delete json.itemType;
    delete json.type;
    switch (data.type) {
      case "linear-gradient":
        return new SVGLinearGradient(__spreadProps(__spreadValues({}, json), { colorsteps }));
      case "radial-gradient":
        return new SVGRadialGradient(__spreadProps(__spreadValues({}, json), { colorsteps }));
      default:
        return new SVGStaticGradient(__spreadProps(__spreadValues({}, json), { colorsteps }));
    }
  }
  get image() {
    return this.json.image;
  }
  set image(image2) {
    this.json.image = image2;
  }
  static parse(obj2) {
    return new SVGFill(obj2);
  }
  static parseImage(str) {
    var results = convertMatches(str);
    let image2 = null;
    var matchResult = results.str.match(reg);
    if (!matchResult) {
      return SVGStaticGradient.create(str || "transparent");
    }
    matchResult.forEach((value, index2) => {
      value = reverseMatches(value, results.matches);
      if (value.includes("linear")) {
        image2 = SVGLinearGradient.parse(value);
      } else if (value.includes("radial")) {
        image2 = SVGRadialGradient.parse(value);
      } else if (value.includes("url")) {
        image2 = SVGImageResource.parse(value);
      } else {
        image2 = SVGStaticGradient.parse(value);
      }
    });
    return image2;
  }
  static changeImageType(options2) {
    switch (options2.type) {
      case "linear-gradient":
        return new SVGLinearGradient(options2);
      case "radial-gradient":
        return new SVGRadialGradient(options2);
      case "image-resource":
      case "url":
        return new SVGImageResource(options2);
      default:
        return new SVGStaticGradient(options2);
    }
  }
}
var FillEditor$1 = "";
const imageTypeList$1 = [
  "static-gradient",
  "linear-gradient",
  "radial-gradient",
  "image-resource"
];
const iconList$1 = {
  "image-resource": iconUse$1("photo")
};
const presetPosition$1 = {
  top: { x1: "0%", y1: "100%", x2: "0%", y2: "0%" },
  "top left": { x1: "100%", y1: "100%", x2: "0%", y2: "0%" },
  "top right": { x1: "0%", y1: "100%", x2: "100%", y2: "0%" },
  left: { x1: "100%", y1: "0%", x2: "0%", y2: "0%" },
  right: { x1: "0%", y1: "0%", x2: "100%", y2: "0%" },
  bottom: { x1: "0%", y1: "0%", x2: "0%", y2: "100%" },
  "bottom left": { x1: "100%", y1: "0%", x2: "0%", y2: "100%" },
  "bottom right": { x1: "0%", y1: "0%", x2: "100%", y2: "100%" }
};
const props = [
  "x1",
  "y1",
  "x2",
  "y2",
  "cx",
  "cy",
  "r",
  "fx",
  "fy",
  "fr",
  "spreadMethod",
  "patternUnits",
  "patternWidth",
  "patternHeight",
  "imageX",
  "imageY",
  "imageWidth",
  "imageHeight"
];
const rangeEditorList = [
  "x1",
  "y1",
  "x2",
  "y2",
  "cx",
  "cy",
  "r",
  "fx",
  "fy",
  "fr",
  "patternWidth",
  "patternHeight",
  "imageX",
  "imageY",
  "imageWidth",
  "imageHeight"
];
class FillEditor extends EditorElement {
  initState() {
    return {
      cachedRect: null,
      index: +(this.props.index || 0),
      value: this.props.value,
      image: SVGFill.parseImage(this.props.value || "transparent") || SVGStaticGradient.create()
    };
  }
  setValue(value) {
    this.setState({
      cachedRect: null,
      image: SVGFill.parseImage(value)
    }, false);
    this.refresh();
    this.parent.trigger("changeTabType", this.state.image.type);
  }
  template() {
    var { image: image2 } = this.state;
    image2 = image2 || {};
    var type = image2.type || "static-gradient";
    if (type === "url")
      type = "image-resource";
    return `
        <div class='elf--fill-editor' data-selected-editor='${type}'>
            <div class='gradient-preview'>
              <div class='gradient-view' ref='$gradientView'>
                <div class='drag-pointer' ref='$dragPosition'></div>
              </div>
              <svg class='pointer-draw' ref='$pointerDrawArea'>
                <line data-type='line' ref='$line' />
                <circle r='5' data-type='start' ref='$startPoint' />
                <circle r='5' data-type='end' ref='$endPoint' />
                <circle r='5' data-type='center' ref='$centerPoint' />
                <circle r='5' data-type='f' ref='$fPoint' />
              </svg>              
              <div class='preset-position'>
                <div data-value='top' title='top'>${iconUse$1("chevron_right")}</div>
                <div data-value='right' title='right'>${iconUse$1("chevron_right")}</div>
                <div data-value='left' title='left'>${iconUse$1("chevron_right")}</div>
                <div data-value='bottom' title='bottom'>${iconUse$1("chevron_right")}</div>
                <div data-value='top left' title='top left'>${iconUse$1("chevron_right")}</div>
                <div data-value='top right' title='top right'>${iconUse$1("chevron_right")}</div>
                <div data-value='bottom left' title='bottom left'>${iconUse$1("chevron_right")}</div>
                <div data-value='bottom right' title='bottom right'>${iconUse$1("chevron_right")}</div>                
              </div>
              <div data-editor='image-loader'>
                <input type='file' accept="image/*" ref='$file' />
              </div>              
            </div>
            <div class="picker-tab">
              <div class="picker-tab-list" ref="$tab">
                ${imageTypeList$1.map((it) => {
      return `<span class='picker-tab-item ${it}' data-editor='${it}'><span class='icon'>${iconList$1[it] || ""}</span></span>`;
    }).join("")}
              </div>
            </div>
            <div class='gradient-steps' data-editor='gradient'>
                <div class="hue-container" ref="$back"></div>            
                <div class="hue" ref="$steps">
                    <div class='step-list' ref="$stepList" ></div>
                </div>
            </div>
            <div class='tools' data-editor='tools'>
              <object refClass="RangeEditor"  label='${this.$i18n("fill.editor.offset")}' ref='$range' key='length' onchange='changeColorStepOffset' />
            </div>
            <div class='sub-editor' ref='$subEditor'> 
                <div data-editor='spreadMethod'>
                  <object refClass="SelectIconEditor" label='${this.$i18n("fill.editor.spread")}' ref='$spreadMethod' value="pad" options='pad,reflect,repeat' key='spreadMethod' onchange='changeKeyValue' />
                </div>  
                <div data-editor='patternUnits'>
                  <object refClass="SelectEditor"  label='Pattern' ref='$patternUnits' options='userSpaceOnUse' key='patternUnits' onchange='changeKeyValue' />
                </div>                  
                ${rangeEditorList.map((field) => {
      const label = this.$i18n("fill.editor." + field);
      return `
                    <div data-editor='${field}'>
                      <object refClass="RangeEditor"  label='${label}' ref='$${field}' value="${this.getImageFieldValue(image2, field)}" key='${field}' onchange='changeKeyValue' />
                    </div>
                  `;
    }).join("")}
                                                                                                                                
            </div>            
        </div>
      `;
  }
  getImageFieldValue(image2, field) {
    var value = image2[field];
    if (isUndefined(value)) {
      switch (field) {
        case "cx":
        case "cy":
        case "r":
        case "fx":
        case "fy":
          return "50%";
        case "x1":
        case "y1":
        case "y2":
        case "fr":
        case "imageX":
        case "imageY":
          return "0%";
        case "x2":
        case "patternWidth":
        case "patternHeight":
        case "imageWidth":
        case "imageHeight":
          return "100%";
      }
    }
    return value;
  }
  [CHANGE("$file")](e2) {
    var project2 = this.$selection.currentProject;
    if (project2) {
      [...e2.target.files].forEach((item2) => {
        this.emit("updateImageAssetItem", item2, (imageId) => {
          this.trigger("setImageUrl", project2.getImageValueById(imageId), project2.getImageDataURIById(imageId));
        });
      });
    }
  }
  [CLICK("$el .preset-position [data-value]")](e2) {
    var type = e2.$dt.attr("data-value");
    if (presetPosition$1[type]) {
      this.state.image.reset(presetPosition$1[type]);
      this.refresh();
      this.refreshFieldValue();
      this.updateData();
    }
  }
  refreshFieldValue() {
    this.children.$x1.setValue(this.state.image.x1);
    this.children.$y1.setValue(this.state.image.y1);
    this.children.$x2.setValue(this.state.image.x2);
    this.children.$y2.setValue(this.state.image.y2);
    this.children.$cx.setValue(this.state.image.cx);
    this.children.$cy.setValue(this.state.image.cy);
    this.children.$r.setValue(this.state.image.r);
    this.children.$fx.setValue(this.state.image.fx);
    this.children.$fy.setValue(this.state.image.fy);
    this.children.$fr.setValue(this.state.image.fr);
    this.children.$spreadMethod.setValue(this.state.image.spreadMethod);
    this.children.$patternUnits.setValue(this.state.image.patternUnits);
    this.children.$patternWidth.setValue(this.state.image.patternWidth);
    this.children.$patternHeight.setValue(this.state.image.patternHeight);
    this.children.$imageX.setValue(this.state.image.imageX);
    this.children.$imageY.setValue(this.state.image.imageY);
    this.children.$imageWidth.setValue(this.state.image.imageWidth);
    this.children.$imagenHeight.setValue(this.state.image.imageHeight);
  }
  getDrawAreaRect() {
    return { width: 224, height: 150 };
  }
  getFieldValue(field) {
    return Length.parse(this.getImageFieldValue(this.state.image, field));
  }
  [BIND("$line")]() {
    var { width: width2, height: height2 } = this.getDrawAreaRect();
    var x1 = this.getFieldValue("x1").toPx(width2);
    var y1 = this.getFieldValue("y1").toPx(height2);
    var x2 = this.getFieldValue("x2").toPx(width2);
    var y2 = this.getFieldValue("y2").toPx(height2);
    return { x1, y1, x2, y2 };
  }
  [BIND("$startPoint")]() {
    var { width: width2, height: height2 } = this.getDrawAreaRect();
    var cx = this.getFieldValue("x1").toPx(width2);
    var cy = this.getFieldValue("y1").toPx(height2);
    return { cx, cy };
  }
  [BIND("$endPoint")]() {
    var { width: width2, height: height2 } = this.getDrawAreaRect();
    var cx = this.getFieldValue("x2").toPx(width2);
    var cy = this.getFieldValue("y2").toPx(height2);
    return { cx, cy };
  }
  [BIND("$centerPoint")]() {
    var { width: width2, height: height2 } = this.getDrawAreaRect();
    var cx = this.getFieldValue("cx").toPx(width2);
    var cy = this.getFieldValue("cy").toPx(height2);
    return { cx, cy };
  }
  [BIND("$fPoint")]() {
    var { width: width2, height: height2 } = this.getDrawAreaRect();
    var cx = this.getFieldValue("fx").toPx(width2);
    var cy = this.getFieldValue("fy").toPx(height2);
    return { cx, cy };
  }
  [POINTERSTART("$pointerDrawArea circle[data-type]") + MOVE("moveDragPointer")](e2) {
    this.containerRect = this.refs.$pointerDrawArea.rect();
    this.startXY = e2.xy;
    this.type = e2.$dt.attr("data-type");
    this.state.cachedRect = null;
  }
  getRectRate(rect2, x2, y2) {
    var { width: width2, height: height2, x: rx, y: ry } = rect2;
    if (rx > x2) {
      x2 = rx;
    } else if (rx + width2 < x2) {
      x2 = rx + width2;
    }
    if (ry > y2) {
      y2 = ry;
    } else if (ry + height2 < y2) {
      y2 = ry + height2;
    }
    var left2 = Length.percent((x2 - rx) / width2 * 100);
    var top2 = Length.percent((y2 - ry) / height2 * 100);
    return { left: left2, top: top2 };
  }
  moveDragPointer(dx, dy) {
    var x2 = this.startXY.x + dx;
    var y2 = this.startXY.y + dy;
    var { left: left2, top: top2 } = this.getRectRate(this.containerRect, x2, y2);
    if (this.type == "start") {
      this.state.image.reset({ x1: left2, y1: top2 });
      this.children.$x1.setValue(left2);
      this.children.$y1.setValue(top2);
      this.bindData("$startPoint");
      this.bindData("$line");
    } else if (this.type == "end") {
      this.state.image.reset({ x2: left2, y2: top2 });
      this.children.$x2.setValue(left2);
      this.children.$y2.setValue(top2);
      this.bindData("$endPoint");
      this.bindData("$line");
    } else if (this.type == "center") {
      this.state.image.reset({ cx: left2, cy: top2 });
      this.children.$cx.setValue(left2);
      this.children.$cy.setValue(top2);
      this.bindData("$centerPoint");
    } else if (this.type == "f") {
      this.state.image.reset({ fx: left2, fy: top2 });
      this.children.$fx.setValue(left2);
      this.children.$fy.setValue(top2);
      this.bindData("$fPoint");
    }
    this.bindData("$gradientView");
    this.updateData();
  }
  [CLICK("$tab .picker-tab-item")](e2) {
    var type = e2.$dt.attr("data-editor");
    this.$el.attr("data-selected-editor", type);
    this.parent.trigger("changeTabType", type);
    var url = type === "image-resource" ? this.state.image.url : this.state.url;
    var opt = {};
    props.forEach((it) => {
      opt[it] = this.children[`$${it}`].getValue();
    });
    this.state.image = SVGFill.changeImageType(__spreadValues({
      type,
      url,
      colorsteps: this.state.image.colorsteps || []
    }, opt));
    this.refresh();
    this.updateData();
    this.sendMessage();
  }
  sendMessage(type) {
    var type = this.$el.attr("data-selected-editor");
    if (type === "linear-gradient") {
      this.emit("addStatusBarMessage", "");
    } else if (type === "url" || type === "image-resource") {
      this.emit("addStatusBarMessage", this.$i18n("fill.editor.message.click.image"));
    } else {
      this.emit("addStatusBarMessage", this.$i18n("fill.editor.message.drag.position"));
    }
  }
  [SUBSCRIBE_SELF("changeKeyValue")](key, value) {
    this.state.image.reset({
      [key]: value
    });
    this.bindData("$gradientView");
    this.bindData("$line");
    this.bindData("$startPoint");
    this.bindData("$endPoint");
    this.bindData("$centerPoint");
    this.bindData("$fPoint");
    this.updateData();
  }
  [SUBSCRIBE("changeColorStepOffset")](key, value) {
    if (this.currentStep) {
      this.currentStep.percent = value.value;
      this.state.image.sortColorStep();
      this.refresh();
      this.updateData();
    }
  }
  [CLICK("$back")](e2) {
    var rect2 = this.refs.$stepList.rect();
    var minX = rect2.x;
    var maxX = rect2.right;
    var x2 = e2.xy.x;
    if (x2 < minX)
      x2 = minX;
    else if (x2 > maxX)
      x2 = maxX;
    var percent = (x2 - minX) / rect2.width * 100;
    this.state.image.insertColorStep(percent);
    this.state.image.sortColorStep();
    this.refresh();
    this.updateData();
  }
  [BIND("$el")]() {
    var type = this.state.image.type;
    if (type === "url") {
      type = "image-resource";
    }
    this.parent.trigger("changeTabType", type);
    return {
      "data-selected-editor": type
    };
  }
  [BIND("$stepList")]() {
    return {
      "data-selected-index": this.state.index.toString(),
      "style": {
        "background-image": this.getLinearGradient()
      }
    };
  }
  get fillId() {
    return this.id + "fill";
  }
  [BIND("$gradientView")]() {
    if (this.refs.$gradientView.html() !== "") {
      return false;
    }
    return {
      innerHTML: `
        <svg x="0" y="0" width="100%" height="100%">
          <defs>
            ${this.state.image.toSVGString(this.fillId)}
          </defs>
          <rect x="0" y="0" width="100%" height="100%" fill="${this.state.image.toFillValue(this.fillId)}" />
        </svg>
      `
    };
  }
  [LOAD("$stepList")]() {
    var colorsteps = this.state.image.colorsteps || [];
    return colorsteps.map((it, index2) => {
      var selected = this.$selection.isSelectedColorStep(it.id) ? "selected" : "";
      return `
      <div class='step ${selected}' data-id='${it.id}' style='left: ${it.percent}%;'>
        <div class='color-view' style="background-color: ${it.color}"></div>
        <div class='arrow' style="background-color: ${it.color}"></div>
      </div>`;
    });
  }
  removeStep(id) {
    this.state.image.removeColorStep(id);
    this.refresh();
    this.updateData();
  }
  selectStep(id) {
    this.state.id = id;
    this.$selection.selectColorStep(id);
    if (this.state.image.colorsteps) {
      this.currentStep = this.state.image.colorsteps.find((it) => this.$selection.isSelectedColorStep(it.id));
      this.children.$range.setValue(Length.percent(this.currentStep.percent));
      this.parent.trigger("selectColorStep", this.currentStep.color);
    }
    this.refresh();
  }
  [POINTERSTART("$stepList .step") + MOVE()](e2) {
    var id = e2.$dt.attr("data-id");
    if (e2.altKey) {
      this.removeStep(id);
      return false;
    } else {
      this.selectStep(id);
      this.startXY = e2.xy;
      this.cachedStepListRect = this.refs.$stepList.rect();
    }
  }
  getStepListRect() {
    return this.cachedStepListRect;
  }
  move(dx, dy) {
    var rect2 = this.getStepListRect();
    var minX = rect2.x;
    var maxX = rect2.right;
    var x2 = this.startXY.x + dx;
    if (x2 < minX)
      x2 = minX;
    else if (x2 > maxX)
      x2 = maxX;
    var percent = (x2 - minX) / rect2.width * 100;
    this.currentStep.percent = percent;
    this.children.$range.setValue(Length.percent(percent));
    this.state.image.sortColorStep();
    this.refresh();
    this.updateData();
  }
  getLinearGradient() {
    var { image: image2 } = this.state;
    return `linear-gradient(to right, ${Gradient.toColorString(image2.colorsteps)})`;
  }
  [SUBSCRIBE("setColorStepColor")](color2) {
    if (this.state.image.type === "static-gradient") {
      this.state.image.setColor(color2);
      this.refresh();
      this.updateData();
    } else {
      if (this.currentStep) {
        this.currentStep.color = color2;
        this.refresh();
        this.updateData();
      }
    }
  }
  [SUBSCRIBE("setImageUrl")](url, datauri) {
    if (this.state.image) {
      this.state.url = url;
      this.state.image.reset({ url, datauri });
      this.refresh();
      this.updateData();
    }
  }
  updateData(data = {}) {
    this.setState(data, false);
    this.parent.trigger(this.props.onchange, this.state.image.toString());
  }
}
var GradientPickerPopup$1 = "";
class GradientPickerPopup extends BasePopup {
  getTitle() {
    return this.$i18n("gradient.picker.popup.title");
  }
  initialize() {
    super.initialize();
    this.selectedTab = "static-gradient";
  }
  getClassName() {
    return "fill-picker-popup";
  }
  getBody() {
    return `
      <div class="elf--gradient-picker-popup" ref='$body' data-selected-editor=''>
        <div class='box'>
          <div ref='$gradientEditor'></div>
        </div>
        <div class='box'>
          <div class='colorpicker'>
            <object refClass="EmbedColorPicker" ref='$color' onchange='changeColor' />                    
          </div>
          <div class='assetpicker'>
            <object refClass="ImageAssetPicker" ref='$asset' onchange='changeImageUrl' />
          </div>
        </div>
      </div>
     
    `;
  }
  [SUBSCRIBE("changeTabType")](type) {
    this.refs.$body.attr("data-selected-editor", type);
  }
  getColorString() {
    var value = "";
    if (this.state.image instanceof Gradient) {
      value = this.state.image.getColorString();
    }
    return value;
  }
  getCurrentColor() {
    return this.state.image.colorsteps[this.state.selectColorStepIndex || 0].color;
  }
  [LOAD("$gradientEditor")]() {
    return `<object refClass="GradientEditor" 
      ref="$g" 
      value="${this.state.image}" 
      selectedIndex="${this.state.selectColorStepIndex}" 
      onchange='changeGradientEditor'
    />`;
  }
  [SUBSCRIBE_SELF("changeGradientEditor")](data) {
    this.state.image = data;
    this.updateData();
  }
  [SUBSCRIBE_SELF("changeColor")](color2) {
    this.children.$g.trigger("setColorStepColor", color2);
  }
  [SUBSCRIBE_SELF("changeImageUrl")](url) {
    this.children.$g.trigger("setImageUrl", url);
  }
  [SUBSCRIBE("showGradientPickerPopup")](data, params) {
    data.changeEvent = data.changeEvent || "changeFillPopup";
    data.image = data.gradient;
    data.params = params;
    this.setState(data);
    this.show(432);
  }
  [SUBSCRIBE("selectColorStep")](color2) {
    this.children.$color.setValue(color2);
  }
  [SUBSCRIBE("changeColorStep")](data = {}) {
    this.state.image.reset(__spreadValues({}, data));
    this.updateData();
  }
  updateData() {
    this.state.instance.trigger(this.state.changeEvent, this.state.image, this.state.params);
  }
}
class FillPickerPopup extends BasePopup {
  getTitle() {
    return this.$i18n("fill.picker.popup.title");
  }
  initState() {
    return {
      image: SVGStaticGradient.create()
    };
  }
  initialize() {
    super.initialize();
    this.selectedTab = "static-gradient";
  }
  getClassName() {
    return "fill-picker-popup";
  }
  getBody() {
    return html`
      <div class="elf--gradient-picker-popup" ref='$body' data-selected-editor=''>
        <div class='box'>
          <div ref='$gradientEditor'></div>
        </div>
        <div class='box'>
          <div class='colorpicker'>
            <object refClass="EmbedColorPicker" ${variable$4({
      ref: "$color",
      onchange: (color2) => {
        this.trigger("changeColor", color2);
      }
    })}/>                    
          </div>
          <div class='assetpicker'>
            <object refClass="ImageAssetPicker" ref='$asset' onchange='changeImageUrl' />
          </div>
        </div>
      </div>
     
    `;
  }
  [SUBSCRIBE("changeTabType")](type) {
    this.refs.$body.attr("data-selected-editor", type);
  }
  getColorString() {
    var value = "";
    if (this.state.image instanceof Gradient) {
      value = this.state.image.getColorString();
    }
    return value;
  }
  getCurrentColor() {
    return this.state.image.colorsteps[this.state.selectColorStepIndex || 0].color;
  }
  [LOAD("$gradientEditor")]() {
    return `<object refClass="FillEditor" 
      ref="$g" 
      value="${this.state.image}" 
      selectedIndex="${this.state.selectColorStepIndex}" 
      onchange='changeFillEditor'
    />`;
  }
  [SUBSCRIBE_SELF("changeFillEditor")](data) {
    this.state.image = data;
    this.updateData();
  }
  [SUBSCRIBE_SELF("changeColor")](color2) {
    this.children.$g.trigger("setColorStepColor", color2);
  }
  [SUBSCRIBE_SELF("changeImageUrl")](url) {
    this.children.$g.trigger("setImageUrl", url);
  }
  [SUBSCRIBE("showFillPickerPopup")](data, params) {
    this.show(240);
    data.changeEvent = data.changeEvent || "changeFillPopup";
    data.params = params;
    this.setState(data);
    if (data.image.isGradient()) {
      this.trigger("selectColorStep", data.image.colorsteps[0].color);
    }
  }
  [SUBSCRIBE("selectColorStep")](color2) {
    this.children.$color.setValue(color2);
  }
  [SUBSCRIBE("changeColorStep")](data = {}) {
    this.state.image.reset(__spreadValues({}, data));
    this.updateData();
  }
  updateData() {
    this.state.instance.trigger(this.state.changeEvent, this.state.image, this.state.params);
  }
}
var FillSingleEditor$1 = "";
class FillSingleEditor extends EditorElement {
  initialize() {
    super.initialize();
    this.notEventRedefine = true;
  }
  initState() {
    return {
      index: this.props.index,
      label: this.props.label,
      simple: this.props.simple === "true" ? true : false,
      image: SVGFill.parseImage(this.props.value || this.props.image || "transparent")
    };
  }
  get fillId() {
    return this.id + "fill";
  }
  updateData(opt = {}) {
    this.setState(opt, false);
    this.modifyValue(opt);
  }
  modifyValue(value) {
    this.parent.trigger(this.props.onchange, this.props.key, this.getValue(), this.state.index);
  }
  getValue() {
    return this.state.image.toString();
  }
  setValue(value) {
    this.setState({
      image: SVGFill.parseImage(value)
    });
  }
  [BIND("$fillView")]() {
    var image2 = this.state.image;
    if (!image2)
      return { innerHTML: "" };
    return {
      innerHTML: image2.toSVGString(this.fillId)
    };
  }
  [BIND("$fillColor")]() {
    var image2 = this.state.image;
    if (!image2)
      return { fill: "transparent" };
    return {
      fill: image2.toFillValue(this.fillId)
    };
  }
  [BIND("$colors")]() {
    var image2 = this.state.image;
    if (!image2)
      return { fill: "transparent" };
    var colors2 = image2.type != "url" ? `${image2.colorsteps[0].color}` : "transparent";
    if (image2.type.includes("linear") || image2.type.includes("radial")) {
      colors2 = image2.colorsteps.map((it) => {
        return `<span class='color' style='background-color: ${it.color}' title='${it.color}'></span>`;
      }).join("");
    }
    return {
      innerHTML: `<div> ${colors2} </div>`
    };
  }
  template() {
    var { label, removable, simple } = this.state;
    var hasLabel = !!label ? "has-label" : "";
    return `
            <div class='elf--fill-single-editor ${hasLabel}'>
                ${label ? `<label>${label}</label>` : ""}            
                <div class="area">
                    <div class='preview' ref='$preview'>
                        <div class='mini-view'>

                            <svg class='color-view' ref='$miniView'>
                                <defs ref='$fillView'></defs>
                                <rect x="0" y="0" width="100%" height="100%" ref='$fillColor' fill='url(#${this.fillId})' />
                            </svg>
                        </div>
                    </div>
                    <div class='colors ${simple ? "simple" : ""}' ref='$colors'></div>
                </div>
            </div>
        `;
  }
  [CLICK()](e2) {
    this.viewGradientPopup();
  }
  viewGradientPopup() {
    this.emit("showFillPickerPopup", {
      instance: this,
      changeEvent: "changeFillSingle",
      image: this.state.image
    });
  }
  [SUBSCRIBE("changeFillSingle")](image2, params) {
    this.updateData({ image: SVGFill.parseImage(image2) });
    this.refresh();
  }
}
var GradientSingleEditor$1 = "";
class GradientSingleEditor extends EditorElement {
  initState() {
    return {
      index: this.props.index,
      image: this.props.image,
      color: "rgba(0, 0, 0, 1)"
    };
  }
  updateData(opt = {}) {
    this.setState(opt, false);
    this.modifyValue(opt);
  }
  modifyValue(value) {
    this.parent.trigger(this.props.onchange, this.props.key, value, this.state.index);
  }
  setValue(obj2) {
    this.setState(__spreadValues({}, obj2));
  }
  [BIND("$miniView")]() {
    return {
      style: {
        "background-image": this.state.image,
        "background-size": "cover",
        "color": this.props.color
      }
    };
  }
  template() {
    return `
            <div class='elf--gradient-single-editor'>
                <div class='preview' ref='$preview'>
                    <div class='mini-view'>
                        <div class='color-view' style="background-color: ${this.state.color}" ref='$miniView'></div>
                    </div>
                </div>
            </div>
        `;
  }
  [CLICK("$preview")](e2) {
    this.viewGradientPopup();
  }
  viewGradientPopup() {
    this.emit("showGradientPickerPopup", {
      instance: this,
      changeEvent: "changeGradientSingle",
      gradient: this.state.image
    });
  }
  [SUBSCRIBE("changeGradientSingle")](image2, params) {
    this.updateData({ image: image2 });
    this.refresh();
  }
}
function gradient(editor) {
  editor.registerElement({
    FillSingleEditor,
    FillEditor,
    GradientSingleEditor
  });
  editor.registerAlias({
    "fill-single": "FillSingleEditor",
    "fill": "FillEditor",
    "gradient-single": "GradientSingleEditor"
  });
  editor.registerMenuItem("popup", {
    FillPickerPopup,
    GradientPickerPopup
  });
}
const angle_list$2 = ["0deg", "45deg", "90deg"];
var linear = {
  title: "Linear",
  key: "linear",
  execute: function(count = 42) {
    return repeat$1(count).map((it) => {
      return {
        gradient: `linear-gradient(${randomItem(...angle_list$2)}, ${ColorStep.createColorStep(2)})`
      };
    });
  }
};
var radial = {
  title: "Radial",
  key: "radial",
  execute: function(count = 42) {
    return repeat$1(count).map((it) => {
      var shape2 = "circle";
      return {
        gradient: `radial-gradient(${shape2}, ${ColorStep.createColorStep(2)})`
      };
    });
  }
};
var conic = {
  title: "Conic",
  key: "conic",
  execute: function(count = 42) {
    return repeat$1(count).map((it) => {
      var x2 = randomNumber(45, 55);
      var y2 = randomNumber(45, 55);
      var angle2 = randomNumber(0, 360);
      return {
        gradient: `conic-gradient(from ${angle2}deg at ${x2}% ${y2}%, ${ColorStep.createColorStep(2, 360, "deg")})`
      };
    });
  }
};
const angle_list$1 = ["0deg", "45deg", "90deg"];
var randomLinear = {
  title: "Random Linear",
  key: "random-linear",
  execute: function(count = 42) {
    return repeat$1(count).map((it) => {
      return {
        gradient: `linear-gradient(${randomItem(...angle_list$1)}, ${ColorStep.createColorStep(10)})`
      };
    });
  }
};
var randomRadial = {
  title: "Random Radial",
  key: "random-radial",
  execute: function(count = 42) {
    return repeat$1(count).map((it) => {
      return {
        gradient: `radial-gradient(circle, ${ColorStep.createColorStep(10)})`
      };
    });
  }
};
var randomConic = {
  title: "Random Conic",
  key: "random-conic",
  execute: function(count = 42) {
    return repeat$1(count).map((it) => {
      return {
        gradient: `conic-gradient(from 0deg at 50% 50%, ${ColorStep.createColorStep(10, 360, "deg")})`
      };
    });
  }
};
const angle_list = ["0deg", "45deg", "90deg"];
var repeatLinear = {
  title: "Repeat Linear",
  key: "repeat-linear",
  execute: function(count = 42) {
    return repeat$1(count).map((it) => {
      return {
        gradient: `repeating-linear-gradient(${randomItem(...angle_list)}, ${ColorStep.createRepeatColorStep(2, "10px")})`
      };
    });
  }
};
var repeatRadial = {
  title: "Repeat Radial",
  key: "repeat-radial",
  execute: function(count = 42) {
    return repeat$1(count).map((it) => {
      var shape2 = "circle";
      return {
        gradient: `repeating-radial-gradient(${shape2}, ${ColorStep.createRepeatColorStep(3, "6px")})`
      };
    });
  }
};
var repeatConic = {
  title: "Repeat Conic",
  key: "repeat-conic",
  execute: function(count = 42) {
    return repeat$1(count).map((it) => {
      return {
        gradient: `repeating-conic-gradient(from 0deg at 0% 50%, ${ColorStep.createRepeatColorStep(10, "10deg")})`
      };
    });
  }
};
var gradients = [
  linear,
  randomLinear,
  repeatLinear,
  radial,
  randomRadial,
  repeatRadial,
  conic,
  randomConic,
  repeatConic
];
var GradientAssetsProperty$1 = "";
const options = gradients.map((it) => {
  return { value: it.key, text: it.title };
});
class GradientAssetsProperty extends BaseProperty {
  getTitle() {
    return this.$i18n("gradient.asset.property.title");
  }
  initState() {
    return {
      mode: "grid",
      preset: "linear"
    };
  }
  getTools() {
    return `<div ref="$tools"></div>`;
  }
  [LOAD("$tools")]() {
    return `
      <object refClass="SelectEditor" ref='$preset'  key="preset" value="${this.state.preset}" options=${variable$4(options)} onchange="changePreset"  />
    `;
  }
  [SUBSCRIBE_SELF("changePreset")](key, value) {
    this.setState({
      [key]: value
    });
  }
  getClassName() {
    return "elf--gradient-assets-property";
  }
  [SUBSCRIBE("refreshSelection") + DEBOUNCE(100)]() {
    this.show();
  }
  getBody() {
    return `
      <div class='property-item gradient-assets'>
        <div class='gradient-list' ref='$gradientList' data-view-mode='${this.state.mode}'></div>
      </div>
    `;
  }
  [DRAGSTART("$gradientList .gradient-item")](e2) {
    const gradient2 = e2.$dt.attr("data-gradient");
    e2.dataTransfer.effectAllowed = "copy";
    e2.dataTransfer.setData("text/gradient", gradient2);
  }
  [LOAD("$gradientList")]() {
    var preset = gradients.find((it) => it.key === this.state.preset);
    if (!preset) {
      return "";
    }
    var results = preset.execute().map((item2, index2) => {
      return `
        <div class='gradient-item' data-index="${index2}" data-gradient='${item2.gradient}' data-custom="${item2.custom}">
          <div class='preview' title="${item2.gradient}" draggable="true">
            <div class='gradient-view' style='background-image: ${item2.gradient};'></div>
          </div>
        </div>
      `;
    });
    if (preset.edit) {
      results.push(`<div class='add-gradient-item'><butto type="button">${iconUse$1("add")}</button></div>`);
    }
    return results;
  }
  executeGradient(callback, isRefresh = true, isEmit = true) {
    var project2 = this.$selection.currentProject;
    if (project2) {
      callback && callback(project2);
      if (isRefresh)
        this.refresh();
      if (isEmit)
        this.emit("refreshGradientAssets");
    } else {
      alert("Please select a project.");
    }
  }
  [CLICK("$gradientList .add-gradient-item")]() {
    this.executeGradient((project2) => {
      project2.createGradient({
        gradient: Gradient.random(),
        name: "",
        variable: ""
      });
    });
  }
  [CLICK("$gradientList .preview")](e2) {
    var $item = e2.$dt.closest("gradient-item");
    var gradient2 = $item.attr("data-gradient");
    this.emit("drop.asset", { gradient: gradient2 });
  }
}
function gradientAsset(editor) {
  editor.registerElement({
    GradientAssetsProperty
  });
}
var HistoryProperty$1 = "";
class HistoryProperty extends BaseProperty {
  afterRender() {
    this.show();
  }
  getTitle() {
    return "History";
  }
  getBody() {
    return `
      <div class="elf--history-list-view" ref='$body'></div>
    `;
  }
  [LOAD("$body") + DOMDIFF]() {
    return this.$editor.history.map((it, index2) => {
      if (it === "-") {
        return `<div class='divider'>-</div>`;
      }
      return `
        <div class='history-item'>
          <span>${index2 === this.$editor.history.currentIndex ? obj.arrowRight : ""}</span>
          <span>${it.message}</span>
        </div>
      `;
    });
  }
  [SUBSCRIBE("refreshHistory")]() {
    this.refresh();
  }
}
function history(editor) {
  editor.registerMenuItem("inspector.tab.history", {
    HistoryProperty
  });
}
const image_size = [
  "",
  "100x100",
  "200x200",
  "300x300",
  "400x300",
  "900x600",
  "1024x762"
];
class ImageProperty extends BaseProperty {
  getClassName() {
    return "item";
  }
  getTitle() {
    return this.$i18n("image.property.title");
  }
  getBody() {
    return `<div ref='$body' style='padding-top: 3px;'></div>`;
  }
  getFooter() {
    return `
      <div>
        <label> ${this.$i18n("image.property.origin")} </label> 
        <span ref='$sizeInfo'></span> 
        <button type="button" ref='$resize'>${iconUse$1("size")}</button>
      </div>
      <div>
        <object refClass="SelectEditor"  ref='$select' label="${this.$i18n("image.property.size")}" key='size' value='' options='${image_size.join(",")}' onchange='changeImageSize' />
      </div>
    `;
  }
  [SUBSCRIBE_SELF("changeImageSize")](key, value) {
    var [width2, height2] = value.split("x").map((it) => it);
    this.command("setAttributeForMulti", "resize image", this.$selection.packByValue({
      width: width2,
      height: height2
    }));
  }
  [CLICK("$resize")]() {
    var current = this.$selection.current;
    if (current) {
      this.command("setAttributeForMulti", "resize image", this.$selection.packByValue({
        width: (item2) => item2.naturalWidth.clone(),
        height: (item2) => item2.naturalHeight.clone()
      }));
    }
  }
  [BIND("$sizeInfo")]() {
    var current = this.$selection.current || {};
    return {
      innerHTML: `${this.$i18n("image.property.width")}: ${current.naturalWidth}, ${this.$i18n("image.property.height")}: ${current.naturalHeight}`
    };
  }
  [LOAD("$body")]() {
    var current = this.$selection.current || {};
    var src = current.src || "";
    return `<object refClass="ImageSelectEditor" 
              ref='$1' 
              key='src' 
              value="${src}" 
              onchange="changeSelect" />`;
  }
  [SUBSCRIBE_SELF("changeSelect")](key, value, info) {
    var current = this.$selection.current;
    if (current) {
      current.reset(__spreadValues({
        src: value
      }, info));
      this.bindData("$sizeInfo");
      this.command("setAttributeForMulti", "change image", this.$selection.packByValue(__spreadValues({
        src: value
      }, info)));
    }
  }
  [SUBSCRIBE("refreshSelection") + DEBOUNCE(100)]() {
    this.refreshShow(["image"]);
  }
}
var ImageSelectEditor$1 = "";
class ImageSelectEditor extends EditorElement {
  initState() {
    return {
      value: this.props.value
    };
  }
  template() {
    return `
            <div class='elf--image-select-editor' ref='$body'></div>
        `;
  }
  getValue() {
    return this.state.value;
  }
  setValue(value) {
    this.setState({ value });
  }
  [LOAD("$body")]() {
    const project2 = this.$selection.currentProject;
    if (!project2)
      return;
    return `
            <div class='preview-container'>
                <img src="${project2.getImageValueById(this.state.value) || this.state.value}" />
                <input type='file' ref='$file' accept="image/*" />
            </div>
            <div class='select-container'>
                <button type="button" ref='$select'>Select a image</button>
            <div>
        `;
  }
  [CHANGE("$file")](e2) {
    var files = [...e2.target.files];
    if (files.length) {
      this.emit("updateImageAssetItem", files[0], (imageId) => {
        this.trigger("changeImageSelectEditor", imageId);
      });
    }
  }
  [CLICK("$select")]() {
    this.emit("showImageSelectPopup", {
      context: this,
      changeEvent: "changeImageSelectEditor",
      value: this.state.value
    });
  }
  [SUBSCRIBE("changeImageSelectEditor")](value) {
    this.updateData({ value });
    this.refresh();
  }
  updateData(data) {
    this.setState(data, false);
    this.parent.trigger(this.props.onchange, this.props.key, this.state.value, this.props.params);
  }
}
var ImageSelectPopup$1 = "";
class ImageSelectPopup extends BasePopup {
  getTitle() {
    return "Select a image";
  }
  getClassName() {
    return "compact";
  }
  initState() {
    return {
      value: ""
    };
  }
  updateData(opt = {}) {
    this.setState(opt, false);
    this.state.context.trigger(this.state.changeEvent, this.state.value, {
      width: this.state.width,
      height: this.state.height,
      naturalWidth: this.state.naturalWidth,
      naturalHeight: this.state.naturalHeight
    });
  }
  getBody() {
    return `
      <div class="elf--image-select-popup">
        <div class='box' ref='$imageBox'>
          
        </div>
      </div>
    `;
  }
  [LOAD("$imageBox") + DOMDIFF]() {
    this.$selection.currentProject || { images: [] };
    return "";
  }
  [CLICK("$imageBox .image-item")](e2) {
    var $img = e2.$dt.$("img");
    this.updateData({
      value: $img.attr("data-id"),
      naturalWidth: $img.naturalWidth,
      naturalHeight: $img.naturalHeight,
      width: $img.naturalWidth,
      height: $img.naturalHeight
    });
    this.trigger("hideImageSelectPopup");
  }
  [SUBSCRIBE("showImageSelectPopup")](data, params) {
    this.setState({
      context: data.context,
      changeEvent: data.changeEvent,
      value: data.value,
      params
    }, false);
    this.refresh();
    this.show(500);
  }
  [SUBSCRIBE("hideImageSelectPopup")]() {
    this.hide();
  }
}
function image(editor) {
  editor.registerElement({
    ImageSelectEditor
  });
  editor.registerMenuItem("inspector.tab.style", {
    ImageProperty
  });
  editor.registerMenuItem("popup", {
    ImageSelectPopup
  });
}
var KeyframePopup$1 = "";
class KeyframePopup extends BasePopup {
  getTitle() {
    return this.$i18n("keyframe.popup.title");
  }
  initState() {
    return {
      name: "none",
      offsets: []
    };
  }
  updateData(opt) {
    this.setState(opt, false);
    this.emit("changeKeyframePopup", this.state);
  }
  getBody() {
    return `
    <div class='elf--keyframe-popup' ref='$popup'>
      <div class="box">
        ${this.templateForName()}
        ${this.templateForOffset()}
      </div>
    </div>`;
  }
  templateForOffset() {
    return `
      <div>
        <object refClass="OffsetEditor" ref='$offsetEditor' />
      </div>
    `;
  }
  templateForName() {
    return `
      <div class='name'>
        <label>Name</label>
        <div class='input grid-1'>
          <input type='text' value='${this.state.name}' ref='$name'/>
        </div>
      </div>
    `;
  }
  [INPUT("$name")](e2) {
    if (this.refs.$name.value.match(/^[a-zA-Z0-9\b]+$/)) {
      this.updateData({ name: this.refs.$name.value });
    } else {
      e2.preventDefault();
      e2.stopPropagation();
      return false;
    }
  }
  getOffsetData() {
    var offsets = this.state.offsets.map((it) => it);
    return { offsets };
  }
  refresh() {
    this.refs.$name.val(this.state.name);
    this.emit("showOffsetEditor", this.getOffsetData());
  }
  [SUBSCRIBE("changeOffsetEditor")](data) {
    this.updateData(data);
  }
  [SUBSCRIBE("showKeyframePopup")](data) {
    this.setState(data);
    this.refresh();
    this.show(240);
  }
  [SUBSCRIBE("hideKeyframePopup")]() {
    this.$el.hide();
  }
}
var KeyframeProperty$1 = "";
class KeyframeProperty extends BaseProperty {
  getTitle() {
    return this.$i18n("keyframe.property.title");
  }
  getBody() {
    return `<div class='elf--keyframe-list' ref='$keyframeList'></div>`;
  }
  getTools() {
    return `
      <button type="button" ref="$add" title="add Filter">${obj.add}</button>
    `;
  }
  makeProperty(property) {
    var key = property.key;
    if (key === "x")
      key = "left";
    else if (key === "y")
      key = "top";
    return `
      <div class='offset-property-item'>
        <label>${key}:</label>
        <div class='value'>${property.value}</div>
      </div>
    `;
  }
  makeOffset(offset) {
    return `
      <div class='offset'>
        <label>${offset.offset}</label>
        <div class='properties'>
          ${offset.properties.map((p) => {
      return this.makeProperty(p);
    }).join("")}
        </div>        
      </div>
    `;
  }
  makeKeyframeTemplate(keyframe2, index2) {
    index2 = index2.toString();
    return `
      <div class='keyframe-item' data-selected-value='${keyframe2.selectedType}' ref='$keyframeIndex${index2}' data-index='${index2}'>
        <div class='title'>
          <div class='name'>${keyframe2.name}</div>
          <div class='tools'>
            <div class='group'>
              <button type="button" data-type='list'>${obj.list}</button>
              <button type="button" data-type='code'>${obj.code}</button>
            </div>
            <button type="button" class="del" data-index="${index2}">${obj.remove2}</button>
          </div>
        </div>
        <div class='offset-list'>
          <div class='container'>
            ${keyframe2.offsets.map((o) => {
      return `
              <div class='offset' style='left: ${o.offset}; background-color: ${o.color}'></div>
              `;
    }).join("")}
          </div>
        </div>
        <div class='keyframe-code' data-type='list'>
          ${keyframe2.offsets.map((offset) => {
      return this.makeOffset(offset);
    }).join("")}
        </div>
        <div class='keyframe-code' data-type='code'>
          <pre>${keyframe2.toString().trim()}</pre>
        </div>        
      </div>
    `;
  }
  [CLICK("$keyframeList .keyframe-item .title .group button[data-type]")](e2) {
    var $keyframeItem = e2.$dt.closest("keyframe-item");
    var index2 = +$keyframeItem.attr("data-index");
    var type = e2.$dt.attr("data-type");
    var current = this.$selection.currentProject;
    if (!current)
      return;
    var currentKeyframe = current.keyframes[index2];
    if (currentKeyframe) {
      currentKeyframe.reset({
        selectedType: type
      });
    }
    $keyframeItem.attr("data-selected-value", type);
  }
  [CLICK("$keyframeList .keyframe-item .offset-list")](e2) {
    var index2 = +e2.$dt.closest("keyframe-item").attr("data-index");
    var current = this.$selection.currentProject;
    if (!current)
      return;
    this.viewKeyframePicker(index2);
  }
  [CLICK("$keyframeList .del") + PREVENT](e2) {
    var removeIndex = e2.$dt.attr("data-index");
    var current = this.$selection.currentProject;
    if (!current)
      return;
    current.removeKeyframe(removeIndex);
    this.emit("refreshProject", current);
    this.refresh();
  }
  [SUBSCRIBE("refreshSelection") + DEBOUNCE(100)]() {
    const current = this.$selection.current;
    if (current && current.hasChangedField("keyframes")) {
      this.refresh();
    }
  }
  [LOAD("$keyframeList")]() {
    var current = this.$selection.currentProject;
    if (!current)
      return "";
    var keyframes = current.keyframe ? Keyframe.parseStyle(current) : current.keyframes;
    current.keyframe = "";
    current.keyframes = keyframes;
    return keyframes.map((keyframe2, index2) => {
      return this.makeKeyframeTemplate(keyframe2, index2);
    });
  }
  [CLICK("$add")]() {
    var current = this.$selection.currentProject;
    if (current) {
      current.createKeyframe();
      this.refresh();
      this.emit("refreshProject", current);
    } else {
      alert("Please select a project.");
    }
  }
  viewKeyframePicker(index2) {
    if (typeof this.selectedIndex === "number") {
      this.selectItem(this.selectedIndex, false);
    }
    this.selectedIndex = +index2;
    this.selectItem(this.selectedIndex, true);
    this.current = this.$selection.currentProject;
    if (!this.current)
      return;
    this.currentKeyframe = this.current.keyframes[this.selectedIndex];
    this.viewKeyframePropertyPopup();
  }
  selectItem(selectedIndex, isSelected = true) {
    if (isSelected) {
      this.getRef("$keyframeIndex", selectedIndex).addClass("selected");
    } else {
      this.getRef("$keyframeIndex", selectedIndex).removeClass("selected");
    }
    if (this.current) {
      this.current.keyframes.forEach((it, index2) => {
        it.selected = index2 === selectedIndex;
      });
    }
  }
  viewKeyframePropertyPopup(position2) {
    this.current = this.$selection.currentProject;
    if (!this.current)
      return;
    this.currentKeyframe = this.current.keyframes[this.selectedIndex];
    const back = this.currentKeyframe;
    const name2 = back.name;
    const offsets = back.offsets;
    this.emit("showKeyframePopup", {
      position: position2,
      name: name2,
      offsets
    });
  }
  [SUBSCRIBE("changeKeyframePopup")](data) {
    var project2 = this.$selection.currentProject;
    if (!project2)
      return;
    this.currentKeyframe = project2.keyframes[this.selectedIndex];
    if (this.currentKeyframe) {
      this.currentKeyframe.reset(data);
    }
    this.refresh();
    this.emit("refreshProject", project2);
  }
}
class OffsetEditor extends EditorElement {
  initState() {
    return {
      offsets: []
    };
  }
  updateData(opt) {
    this.setState(opt, false);
    this.modifyOffset();
  }
  modifyOffset() {
    this.emit("changeOffsetEditor", this.state);
  }
  template() {
    return `
    <div class='editor offset-editor' ref='$editor'>
        ${this.templateForOffset()}
        ${this.templateForOffsetInput()}
        ${this.templateForProperty()}        
    </div>`;
  }
  templateForOffsetInput() {
    return `
      <div class='offset-input' >
        <div class='title'>
          <label>Offset</label>
          <div class='tools'>
            <object refClass="InputRangeEditor" 
              key='offset' 
              min='0' 
              max='100' 
              step="0.01" 
              value="${Length.percent(0)}" 
              ref='$offsetInput' 
              units="%" 
              onchange='changeRangeEditor' 
            />
          </div>
        </div>
      </div>
    `;
  }
  [SUBSCRIBE("changeRangeEditor")](key, value) {
    var offset = this.state.offsets[this.selectedIndex];
    if (offset) {
      offset.offset = value.clone();
      this.refresh();
      this.modifyOffset();
    }
  }
  templateForProperty() {
    return `<object refClass="CSSPropertyEditor" ref='$offsetPropertyEditor' hide-refresh="true" onchange='changeCSSPropertyEditor' />`;
  }
  templateForOffset() {
    return `<div class='offset' ref='$offset' data-selected-value="-1"></div>`;
  }
  makeOffset(offset, index2) {
    return `<div class='offset-item' style='left: ${offset.offset};' data-offset-index='${index2.toString()}'></div>`;
  }
  selectItem(selectedIndex, isSelected = true) {
    if (isUndefined(selectedIndex)) {
      selectedIndex = -1;
      for (var i = 0, len2 = this.state.offsets.length; i < len2; i++) {
        if (this.state.offsets[i].selected) {
          selectedIndex = i;
          break;
        }
      }
      if (selectedIndex === -1) {
        selectedIndex = 0;
      }
    }
    this.getRef("$offset").attr("data-selected-value", selectedIndex);
    this.selectedIndex = selectedIndex;
    this.state.offsets.forEach((it, index2) => {
      it.selected = index2 === selectedIndex;
    });
    var selectedList = this.state.offsets.filter((it) => it.selected);
    this.selectedOffsetItem = selectedList.length ? selectedList[0] : {};
    this.refreshOffsetInput();
  }
  refreshOffsetInput() {
    var offset = this.state.offsets[this.selectedIndex];
    if (offset) {
      this.children.$offsetInput.setValue(offset.offset);
    }
  }
  [LOAD("$offset")]() {
    return this.state.offsets.map((it, index2) => {
      return this.makeOffset(it, index2);
    });
  }
  isNotOffsetItem(e2) {
    return !Dom.create(e2.target).hasClass("offset-item") && !this.currentOffset;
  }
  [CLICK("$offset") + IF("isNotOffsetItem") + PREVENT](e2) {
    this.baseOffsetWidth = this.refs.$offset.width();
    this.baseOffsetArea = this.refs.$offset.offset();
    var currentX = e2.xy.x;
    var newOffset = Length.percent((currentX - this.baseOffsetArea.left) / this.baseOffsetWidth * 100).round(100);
    this.state.offsets.push(new Offset({
      offset: newOffset
    }));
    this.selectItem(this.state.offsets.length - 1, true);
    this.refresh();
    this.modifyOffset();
  }
  refreshOffsetProperty() {
    this.emit("showCSSPropertyEditor", this.selectedOffsetItem.properties);
  }
  [POINTERSTART("$offset .offset-item") + MOVE("moveOffset") + END("endOffset")](e2) {
    this.baseOffsetWidth = this.refs.$offset.width();
    this.baseOffsetArea = this.refs.$offset.offset();
    this.currentOffsetleft = Length.parse(e2.$dt.css("left"));
    this.currentOffset = e2.$dt;
    this.currentOffsetIndex = +e2.$dt.attr("data-offset-index");
    this.currentOffsetXY = e2.xy;
    this.baseOffsetMin = this.baseOffsetArea.left;
    this.baseOffsetMax = this.baseOffsetArea.left + this.baseOffsetWidth;
    this.isRemoveOffset = false;
    if (e2.altKey) {
      this.isRemoveOffset = true;
    } else {
      this.selectItem(this.currentOffsetIndex, true);
      this.refreshOffsetInput();
    }
  }
  moveOffset(dx, dy) {
    if (this.isRemoveOffset)
      return;
    var currentX = this.currentOffsetXY.x + dx;
    if (currentX < this.baseOffsetMin) {
      currentX = this.baseOffsetMin;
    }
    if (currentX > this.baseOffsetMax) {
      currentX = this.baseOffsetMax;
    }
    var newOffset = Length.percent((currentX - this.baseOffsetMin) / this.baseOffsetWidth * 100).round(100);
    this.state.offsets[this.currentOffsetIndex].offset.set(newOffset.value);
    this.currentOffset.css("left", newOffset);
    this.refreshOffsetInput();
    this.modifyOffset();
  }
  removeOffset(index2) {
    this.state.offsets.splice(index2, 1);
    this.selectItem(0);
    this.refresh();
    this.modifyOffset();
  }
  endOffset(dx, dy) {
    if (this.isRemoveOffset) {
      setTimeout(() => {
        this.currentOffset = null;
        this.removeOffset(this.currentOffsetIndex);
      }, 10);
    } else {
      setTimeout(() => {
        this.currentOffset = null;
        this.refreshOffsetInput();
        this.refreshOffsetProperty();
        this.modifyOffset();
      }, 10);
    }
  }
  refresh() {
    this.load();
    this.refreshOffsetProperty();
  }
  [SUBSCRIBE("showOffsetEditor")](data) {
    this.setState(data);
    this.selectItem();
    this.refresh();
  }
  [SUBSCRIBE("changeCSSPropertyEditor")](properties = []) {
    var offset = this.state.offsets[this.selectedIndex];
    if (offset) {
      offset.properties = [...properties];
    }
    this.modifyOffset();
  }
}
function keyframe(editor) {
  editor.registerElement({
    OffsetEditor
  });
  editor.registerMenuItem("inspector.tab.transition", {
    KeyframeProperty
  });
  editor.registerMenuItem("popup", {
    KeyframePopup
  });
}
var LayerTreeProperty$1 = "";
const DRAG_START_CLASS = "drag-start";
class LayerTreeProperty extends BaseProperty {
  initialize() {
    super.initialize();
    this.notEventRedefine = true;
  }
  getTitle() {
    return this.$i18n("layer.tree.property.title");
  }
  getClassName() {
    return "full";
  }
  initState() {
    return {
      hideDragPointer: true,
      lastDragOverPosition: 0,
      lastDragOverOffset: 0,
      rootRect: { top: 0 },
      itemRect: { height: 0 }
    };
  }
  getBody() {
    return `
      <div class="elf--layer-list scrollbar" ref="$layerList"></div>
      <div class='drag-point' ref='$dragPointer'></div>
    `;
  }
  [BIND("$dragPointer")]() {
    var offset = this.state.lastDragOverOffset;
    var dist2 = this.state.itemRect.height / 3;
    var bound = {};
    if (this.state.lastDragOverOffset < dist2) {
      offset = 0;
      var top2 = this.state.lastDragOverPosition + offset - this.state.rootRect.top;
      bound = {
        top: top2,
        height: "1px",
        width: "100%",
        left: "0px"
      };
      this.state.lastDragOverItemDirection = "before";
    } else if (this.state.lastDragOverOffset > this.state.itemRect.height - dist2) {
      offset = this.state.itemRect.height;
      var top2 = this.state.lastDragOverPosition + offset - this.state.rootRect.top;
      bound = {
        top: top2,
        height: "1px",
        width: "100%",
        left: "0px"
      };
      this.state.lastDragOverItemDirection = "after";
    } else {
      const targetItem = this.$model.get(this.state.lastDragOverItemId);
      if (targetItem == null ? void 0 : targetItem.enableHasChildren()) {
        offset = 0;
        var top2 = this.state.lastDragOverPosition + offset - this.state.rootRect.top;
        bound = {
          top: top2,
          height: this.state.itemRect.height,
          width: "100%",
          left: "0px"
        };
        this.state.lastDragOverItemDirection = "self";
      }
    }
    bound.display = this.state.hideDragPointer ? "none" : "block";
    return {
      style: bound
    };
  }
  getIcon(item2) {
    if (item2.d) {
      const path = PathParser.fromSVGString(item2.absolutePath().d);
      return iconUseForPath(path.scaleWith(24, 24).d, { width: 24, height: 24, fill: "currentColor", stroke: "currentColor" });
    }
    if (item2.hasChildren()) {
      if (item2.isLayout("flex")) {
        return iconUse$1("layout_flex");
      } else if (item2.isLayout("grid")) {
        return iconUse$1("layout_grid");
      }
      return iconUse$1("layout_default");
    }
    return this.$icon.get(item2.itemType, item2);
  }
  makeLayerList(parentObject, depth2 = 0) {
    if (!parentObject.layers)
      return "";
    const layers2 = parentObject.layers;
    const data = [];
    for (var last2 = layers2.length - 1; last2 > -1; last2--) {
      var layer2 = layers2[last2];
      var selectedPathClass = this.$selection.hasPathOf(layer2) ? "selected-path" : "";
      var selectedClass = this.$selection.check(layer2) ? "selected" : "";
      var hovered = this.$selection.checkHover(layer2) ? "hovered" : "";
      var name2 = layer2.is("boolean-path") ? layer2["boolean-operation"] : layer2.name;
      if (layer2.is("text")) {
        name2 = layer2.text || layer2.name;
      }
      var title2 = "";
      if (layer2.hasLayout()) {
        title2 = this.$i18n("layer.tree.property.layout.title." + layer2.layout);
      }
      const isHide = layer2.isTreeItemHide();
      const depthPadding = depth2 * 20;
      const hasChildren = layer2.hasChildren();
      const lock2 = this.$lockManager.get(layer2.id);
      const visible2 = this.$visibleManager.get(layer2.id);
      data[data.length] = `        
        <div class='layer-item ${selectedClass} ${selectedPathClass} ${hovered}' data-is-group="${hasChildren}" data-depth="${depth2}" data-layout='${layer2.layout}' data-layer-id='${layer2.id}' data-is-hide="${isHide}"  draggable="true">
          <div class='detail'>
            <label data-layout-title='${title2}' style='padding-left: ${Length.px(depthPadding)}' > 
              <div class='folder ${layer2.collapsed ? "collapsed" : ""}'>${hasChildren ? iconUse$1("arrow_right") : ""}</div>
              <span class='icon' data-item-type="${layer2.itemType}">${this.getIcon(layer2)}</span> 
              <span class='name'>${name2}</span>
            </label>
            <div class="tools">
              <button type="button" class="lock" data-lock="${lock2}" title='Lock'>${lock2 ? iconUse$1("lock") : iconUse$1("lock_open")}</button>
              <button type="button" class="visible" data-visible="${visible2}" title='Visible'>${iconUse$1("visible")}</button>
              <button type="button" class="remove" title='Remove'>${iconUse$1("remove2")}</button>                          
            </div>
          </div>
        </div>

        ${this.makeLayerList(layer2, depth2 + 1)}
      `;
    }
    return data.join(" ");
  }
  [SUBSCRIBE("refreshContent")](arr) {
    this.refresh();
  }
  [LOAD("$layerList") + DOMDIFF]() {
    var project2 = this.$selection.currentProject;
    if (!project2)
      return "";
    return [
      this.makeLayerList(project2, 0),
      `
        <div class='layer-item ' data-depth="0" data-is-last="true">
        </div>
      `
    ];
  }
  [DRAGSTART("$layerList .layer-item")](e2) {
    var layerId = e2.$dt.attr("data-layer-id");
    e2.$dt.addClass(DRAG_START_CLASS);
    e2.dataTransfer.setData("layer/id", layerId);
    this.state.rootRect = this.refs.$layerList.rect();
    this.state.itemRect = e2.$dt.rect();
    this.setState({
      hideDragPointer: false
    }, false);
    this.bindData("$dragPointer");
  }
  [DRAGEND("$layerList .layer-item")](e2) {
    this.setState({
      hideDragPointer: true
    }, false);
    this.bindData("$dragPointer");
    this.refs.$layerList.$$(`.${DRAG_START_CLASS}`).forEach((it) => {
      it.removeClass(DRAG_START_CLASS);
    });
  }
  [DRAGOVER(`$layerList .layer-item:not(.${DRAG_START_CLASS})`) + PREVENT](e2) {
    var targetLayerId = e2.$dt.attr("data-layer-id");
    this.state.lastDragOverItemId = targetLayerId;
    this.state.lastDragOverPosition = e2.$dt.rect().top;
    this.state.lastDragOverOffset = e2.offsetY;
    this.bindData("$dragPointer");
  }
  [DROP(`$layerList .layer-item:not(.${DRAG_START_CLASS})`)](e2) {
    var targetLayerId = e2.$dt.attr("data-layer-id");
    var sourceLayerId = e2.dataTransfer.getData("layer/id");
    if (targetLayerId === sourceLayerId)
      return;
    var targetItem = this.$model.get(targetLayerId);
    var sourceItem = this.$model.get(sourceLayerId);
    if ((targetItem == null ? void 0 : targetItem.enableHasChildren()) === false)
      return;
    if (targetItem && targetItem.hasParent(sourceItem.id))
      return;
    switch (this.state.lastDragOverItemDirection) {
      case "self":
        targetItem.appendChild(sourceItem);
        break;
      case "before":
        targetItem.appendBefore(sourceItem);
        break;
      case "after":
        targetItem.appendAfter(sourceItem);
        break;
    }
    this.$selection.select(sourceItem);
    this.setState({
      hideDragPointer: true
    });
    this.emit("refreshAll");
    this.nextTick(() => {
      this.emit("recoverBooleanPath");
    }, 10);
  }
  [DOUBLECLICK("$layerList .layer-item")](e2) {
    this.startInputEditing(e2.$dt.$(".name"));
  }
  modifyDoneInputEditing(input2, event) {
    if (KEY_CODE.enter === event.keyCode) {
      this.endInputEditing(input2, () => {
        var id2 = input2.closest("layer-item").attr("data-layer-id");
        var text3 = input2.text();
        this.emit("refreshItemName", id2, text3);
      });
    } else {
      var id = input2.closest("layer-item").attr("data-layer-id");
      var text2 = input2.text();
      this.emit("refreshItemName", id, text2);
    }
  }
  [KEYDOWN("$layerList .layer-item .name") + STOP](e2) {
    this.modifyDoneInputEditing(e2.$dt, e2);
  }
  [FOCUSOUT("$layerList .layer-item .name") + PREVENT + STOP](e2) {
    this.modifyDoneInputEditing(e2.$dt, { keyCode: KEY_CODE.enter });
  }
  selectLayer(layer2) {
    if (layer2) {
      this.$selection.select(layer2);
    }
    this.refresh();
    this.emit("refreshSelection");
  }
  addLayer(layer2) {
    if (layer2) {
      this.$selection.select(layer2);
      this.emit("refreshArtboard");
    }
  }
  [CLICK("$add")](e2) {
    this.emit("newComponent", "rect", {
      "background-color": "#ececec",
      width: 200,
      height: 100
    });
  }
  [CLICK("$layerList .layer-item label .name")](e2) {
    var $item = e2.$dt.closest("layer-item");
    $item.onlyOneClass("selected");
    var id = $item.attr("data-layer-id");
    this.$selection.select(id);
    this.command("refreshSelection");
  }
  [CLICK("$layerList .layer-item label .folder")](e2) {
    var $item = e2.$dt.closest("layer-item");
    var id = $item.attr("data-layer-id");
    var item2 = this.$model.get(id);
    item2.reset({
      collapsed: !item2.collapsed
    });
    this.refresh();
  }
  [CLICK("$layerList .layer-item .visible")](e2) {
    var $item = e2.$dt.closest("layer-item");
    var id = $item.attr("data-layer-id");
    this.$visibleManager.toggle(id);
    var visible2 = this.$visibleManager.get(id);
    e2.$dt.attr("data-visible", visible2);
    this.emit("refreshVisibleView");
  }
  [CLICK("$layerList .layer-item .remove")](e2) {
    var $item = e2.$dt.closest("layer-item");
    var id = $item.attr("data-layer-id");
    this.command("removeLayer", "remove a layer", [id]);
    this.nextTick(() => {
      this.refresh();
    }, 1e3);
  }
  [CLICK("$layerList .layer-item .lock")](e2) {
    var $item = e2.$dt.closest("layer-item");
    var id = $item.attr("data-layer-id");
    this.$lockManager.toggle(id);
    var lastLock = this.$lockManager.get(id);
    e2.$dt.attr("data-lock", lastLock);
    if (lastLock) {
      this.$selection.removeById(id);
      this.emit("refreshSelection");
    }
  }
  [SUBSCRIBE("changeHoverItem")]() {
    this.refs.$layerList.$$(".hovered").forEach((it) => {
      it.removeClass("hovered");
    });
    if (this.$selection.hoverItems.length) {
      var selector2 = this.$selection.hoverItems.map((it) => {
        return `[data-layer-id="${it.id}"]`;
      }).join(",");
      this.refs.$layerList.$$(selector2).forEach((it) => {
        it.addClass("hovered");
      });
    }
  }
  [SUBSCRIBE_SELF("changeSelection")](isSelection = false) {
    if (isSelection && this.refs.$layerList) {
      this.refs.$layerList.$$(".selected").forEach((it) => {
        it.removeClass("selected");
      });
      this.refs.$layerList.$$(".selected-path").forEach((it) => {
        it.removeClass("selected-path");
      });
      var selector2 = this.$selection.items.map((it) => {
        return `[data-layer-id="${it.id}"]`;
      }).join(",");
      if (selector2) {
        this.refs.$layerList.$$(selector2).forEach((it) => {
          it.addClass("selected");
          var item2 = this.$selection.itemKeys[it.attr("data-layer-id")];
          if (item2.is("svg-path", "svg-polygon")) {
            it.$(".icon").html(this.getIcon(item2));
          }
        });
      }
    }
  }
  [SUBSCRIBE("refreshSelection")]() {
    this.refresh();
  }
  [SUBSCRIBE("refreshStylePosition")]() {
    this.trigger("changeSelection");
  }
  [SUBSCRIBE("refreshLayerTreeView") + THROTTLE(100)]() {
    this.refresh();
  }
  [SUBSCRIBE("changeItemLayout")]() {
    this.refresh();
  }
  [CONFIG("bodyEvent")]() {
    const $target = Dom.create(this.$config.get("bodyEvent").target);
    const $layerItem = $target.closest("layer-item");
    if ($layerItem) {
      this.emit("refreshHoverView", $layerItem.data("layer-id"));
    }
  }
}
function layerTree(editor) {
  editor.registerElement({
    LayerTreeProperty
  });
}
var FlexLayoutEditor$1 = "";
class FlexLayoutEditor extends EditorElement {
  getDirectionOptions() {
    return this.makeOptionsFunction("row,column");
  }
  getWrapOptions() {
    return this.makeOptionsFunction("nowrap,wrap");
  }
  getJustifyContentOptions() {
    return this.makeOptionsFunction("flex-start,flex-end,center,space-between,space-around");
  }
  getAlignItemsOptions() {
    return this.makeOptionsFunction("flex-start,flex-end,center,baseline,stretch");
  }
  getAlignContentOptions() {
    return this.makeOptionsFunction("flex-start,flex-end,center,space-between,space-around,stretch");
  }
  makeOptionsFunction(options2) {
    return variable$4(options2.split(",").map((it) => {
      return { value: it, text: this.$i18n("flex.layout.editor." + it) };
    }));
  }
  initState() {
    return __spreadValues({}, this.props.value);
  }
  setValue(value) {
    this.setState(__spreadValues({}, value));
  }
  getValue() {
    return this.state;
  }
  modifyData(key, value) {
    this.parent.trigger(this.props.onchange, key, value);
  }
  [LOAD("$body")]() {
    return `
            <div class='flex-layout-item'>
                <div class="grid-2">
                    <div>
                        <object refClass="SelectIconEditor" 
                            key='flex-direction'
                            ref='$flexDirection'
                            value="${this.state["flex-direction"] || "row"}"
                            options="${this.getDirectionOptions()}"
                            icons=${variable$4(["east", "south"])}
                            onchange='changeKeyValue'
                        />
                    </div>
                    <div>
                        <object refClass="NumberInputEditor" ${variable$4({
      compact: true,
      ref: "$flex-gap",
      label: iconUse$1("space"),
      key: "gap",
      value: this.state.gap,
      min: 0,
      max: 100,
      step: 1,
      onchange: "changeKeyValue"
    })}

                        />
                    </div>
                    <div>
                        <object refClass="NumberInputEditor" ${variable$4({
      compact: true,
      label: iconUse$1("padding"),
      key: "padding",
      ref: "$padding",
      value: this.state.gap,
      min: 0,
      max: 100,
      step: 1,
      onchange: "changePadding"
    })}

                        />
                    </div>


                    <div>
                        <object refClass="ToggleButton" ${variable$4({
      compact: true,
      key: "flex-wrap",
      ref: "$wrap",
      checkedValue: "wrap",
      value: this.state["flex-wrap"] || FlexWrap.NOWRAP,
      toggleLabels: ["wrap", "wrap"],
      toggleValues: [FlexWrap.NOWRAP, FlexWrap.WRAP],
      onchange: "changeKeyValue"
    })}

                        />
                    </div>
                </div>

            </div>

            <div class="select-flex-direction">
                <div class="padding-top"></div>
                <div class="padding-left"></div>
                <div class="padding-right"></div>
                <div class="padding-bottom"></div>

                <div class="flex-group">

                    <div class="flex-row">
                        <div class="flex-direction" data-value="row">
                            <div class="flex-direction-item" data-index="1"></div>
                            <div class="flex-direction-item" data-index="2"></div>
                            <div class="flex-direction-item" data-index="3"></div>
                        </div>

                        <div class="flex-direction" data-value="row">
                            <div class="flex-direction-item" data-index="1"></div>
                            <div class="flex-direction-item" data-index="2"></div>
                            <div class="flex-direction-item" data-index="3"></div>
                        </div>

                        <div class="flex-direction" data-value="row">
                            <div class="flex-direction-item" data-index="1"></div>
                            <div class="flex-direction-item" data-index="2"></div>
                            <div class="flex-direction-item" data-index="3"></div>
                        </div>
                    </div>
                </div>

                <div class="flex-direction" data-value="column"></div>
            </div>

            <div class='flex-layout-item'>
                <div class="title">${this.$i18n("flex.layout.editor.justify-content")}</div>
                <object refClass="SelectIconEditor" 
                    key='justify-content'
                    ref='$justify'
                    value="${this.state["justify-content"] || "flex-start"}"
                    options="${this.getJustifyContentOptions()}"
                    icons=${variable$4(["start", "end", "center", "horizontal_distribute", "justify_content_space_around"])}
                    onchange='changeKeyValue'
                />
            </div>
            <div class='flex-layout-item'>
                <div class="title">${this.$i18n("flex.layout.editor.align-items")}</div>            
                <object refClass="SelectIconEditor" 
                    key='align-items'
                    ref='$alignItems'
                    value="${this.state["align-items"] || "flex-start"}"
                    options="${this.getAlignItemsOptions()}"
                    icons=${variable$4(["vertical_align_top", "vertical_align_bottom", "vertical_align_center", "vertical_align_baseline", "vertical_align_stretch"])}
                    onchange='changeKeyValue'
                />
            </div>
            <div class='flex-layout-item'>
                <div class="title">${this.$i18n("flex.layout.editor.align-content")}</div>                        
                <object refClass="SelectIconEditor" 
                    key='align-content'
                    ref='$alignContent'
                    value="${this.state["align-content"] || "flex-start"}"
                    options="${this.getAlignContentOptions()}"
                    icons=${variable$4(["vertical_align_top", "vertical_align_bottom", "vertical_align_center", "horizontal_distribute", "justify_content_space_around", "vertical_align_stretch"])}                    
                    onchange='changeKeyValue'
                />
            </div>    
        `;
  }
  template() {
    return `
            <div class='flex-layout-editor' ref='$body' ></div>
        `;
  }
  [SUBSCRIBE_SELF("changeKeyValue")](key, value, params) {
    this.setState({
      [key]: value
    }, false);
    this.modifyData(key, value);
  }
  [SUBSCRIBE_SELF("changePadding")](key, value) {
    this.setState({
      [key]: value
    }, false);
    this.modifyData(key, {
      "padding-top": value,
      "padding-left": value,
      "padding-right": value,
      "padding-bottom": value
    });
  }
  [CLICK("$wrap")]() {
    const checked = !this.refs.$wrap.checked();
    this.setState({
      "flex-wrap": checked ? "wrap" : "nowrap"
    }, false);
    this.modifyData("flex-wrap", checked ? "wrap" : "nowrap");
  }
}
class FlexLayoutItemEditor extends EditorElement {
  initState() {
    return __spreadValues({}, STRING_TO_CSS(this.props.value));
  }
  setValue(value) {
    this.setState(STRING_TO_CSS(value));
  }
  getValue() {
    return CSS_TO_STRING$1(this.state);
  }
  modifyData() {
    this.parent.trigger(this.props.onchange, this.props.key, this.getValue());
  }
  [LOAD("$body")]() {
    return `
            <div class='flex-layout-item'>
                <div class='label'><label>${this.$i18n("flex.layout.item.editor.direction")}</label></div>
                <object refClass="SelectIconEditor" 
                    key='flex-direction'
                    ref='$flexDirection'
                    value="${this.state["flex-direction"] || "row"}"
                    options="${getDirectionOptions()}"
                    onchange='changeKeyValue'
                />
            </div>
            <div class='flex-layout-item'>
                <div class='label'><label>${this.$i18n("flex.layout.item.editor.wrap")}</label></div>
                <object refClass="SelectIconEditor" 
                    key='flex-wrap'
                    ref='$flex-wrap'
                    value="${this.state["flex-wrap"] || "wrap"}"
                    options="${getWrapOptions()}"
                    onchange='changeKeyValue'
                />
            </div>
            <div class='flex-layout-item'>
                <div class='label'><label>${this.$i18n("flex.layout.item.editor.justify-content")}</label></div>
                <object refClass="SelectIconEditor" 
                    key='justify-content'
                    ref="$justifyContent"
                    value="${this.state["justify-content"]}"
                    options="${getJustifyContentOptions()}"
                    onchange='changeKeyValue'
                />
            </div>
            <div class='flex-layout-item'>
                <div class='label'><label>${this.$i18n("flex.layout.item.editor.align-items")}</label></div>
                <object refClass="SelectIconEditor" 
                    key='align-items'
                    ref='$alignItems'
                    value="${this.state["align-items"]}"
                    options="${getAlignItemsOptions()}"
                    onchange='changeKeyValue'
                />
            </div>
            <div class='flex-layout-item'>
                <div class='label'><label>${this.$i18n("flex.layout.item.editor.align-content")}</label></div>
                <object refClass="SelectIconEditor" 
                    key='align-content'
                    ref='$alignContent'
                    value="${this.state["align-content"]}"
                    options="${getAlignContentOptions()}"
                    onchange='changeKeyValue'
                />
            </div>    
        `;
  }
  template() {
    return `
            <div class='flex-layout-editor' ref='$body' ></div>
        `;
  }
  [SUBSCRIBE_SELF("changeKeyValue")](key, value, params) {
    this.setState({
      [key]: value
    }, false);
    this.modifyData();
  }
}
var FlexLayoutItemProperty$1 = "";
class FlexLayoutItemProperty extends BaseProperty {
  getTitle() {
    return this.$i18n("flex.layout.item.property.title");
  }
  getClassName() {
    return "elf--flex-layout-item-property";
  }
  getLayoutOptions() {
    return ["none", "auto", "value"].map((it) => {
      return { value: it, text: this.$i18n(`flex.layout.item.property.${it}`) };
    });
  }
  getBody() {
    return `
        <div class='property-item' ref='$body'></div>
      `;
  }
  [LOAD("$body")]() {
    var current = this.$selection.current || { "flex-layout-item": "none" };
    const valueType2 = "value";
    return `
      <div class='layout-select'>
        ${createComponent("SelectIconEditor", {
      ref: "$layout",
      key: "layout",
      icon: true,
      value: valueType2,
      options: this.getLayoutOptions(),
      onchange: "changeLayoutType"
    })}
      </div>
      <div class='layout-list' ref='$layoutList' data-selected-value='${valueType2}'>
        <div data-value='none'></div>
        <div data-value='auto'></div>
        <div data-value='value'>
          <div class='value-item'>
            ${createComponent({
      ref: "$grow",
      label: this.$i18n("flex.layout.item.property.grow"),
      key: "flex-grow",
      value: current["flex-grow"],
      min: 0,
      max: 1,
      step: 0.01,
      units: ["", "auto"],
      onchange: "changeFlexItem"
    })}
          </div>
          <div class='value-item'>
            ${createComponent({
      ref: "$shrink",
      label: this.$i18n("flex.layout.item.property.shrink"),
      key: "flex-shrink",
      value: current["flex-shrink"],
      min: 0,
      max: 1,
      step: 0.01,
      units: ["", "auto"],
      onchange: "changeFlexItem"
    })}
          </div>
          <div class='value-item'>
            ${createComponent("RangeEditor", {
      ref: "$basis",
      label: this.$i18n("flex.layout.item.property.basis"),
      key: "flex-basis",
      value: current["flex-basis"],
      min: 0,
      max: 1,
      step: 0.01,
      units: ["px", "em", "%", "auto"],
      onchange: "changeFlexItem"
    })}          
          </div>                    
        </div>
      </div>
    `;
  }
  getFlexItemValue(value) {
    if ((value == null ? void 0 : value.isString()) && value.unit === "" && value.value !== "auto") {
      return 0;
    }
    return value.unit === "auto" ? "auto" : value;
  }
  getFlexValue() {
    var grow = this.children.$grow.getValue();
    var shrink = this.children.$shrink.getValue();
    var basis = this.children.$basis.getValue();
    grow = this.getFlexItemValue(grow);
    shrink = this.getFlexItemValue(shrink);
    basis = this.getFlexItemValue(basis);
    return {
      "flex-grow": grow,
      "flex-shrink": shrink,
      "flex-basis": basis
    };
  }
  [SUBSCRIBE_SELF("changeFlexItem")](key, value) {
    this.command("setAttributeForMulti", "change flex layout", this.$selection.packByValue({
      [key]: value
    }));
    this.nextTick(() => {
      this.emit("refreshAllElementBoundSize");
      this.emit("refreshSelectionTool", true);
    });
  }
  [SUBSCRIBE_SELF("changeLayoutType")](key, value) {
    this.command("setAttributeForMulti", "change flex layout", this.$selection.packByValue({
      "flex": value
    }));
    this.refs.$layoutList.attr("data-selected-value", valueType);
    this.nextTick(() => {
      this.emit("refreshAllElementBoundSize");
    });
  }
  [SUBSCRIBE("refreshSelection") + DEBOUNCE(100)]() {
    this.refreshShow(() => {
      var current = this.$selection.current;
      return current && current.isInFlex();
    });
  }
}
var GridBoxEditor$1 = "";
const REG_CSS_UNIT = /(auto)|(repeat\([^\)]*\))|(([\d.]+)(px|pt|fr|r?em|deg|vh|vw|%))/gi;
class GridBoxEditor extends EditorElement {
  getLayoutItemOptions() {
    return variable$4("none,auto,repeat,length".split(",").map((it) => {
      return { value: it, text: this.$i18n(`grid.box.editor.${it}`) };
    }));
  }
  initState() {
    return {
      label: this.props.label,
      list: this.parseValue(this.props.value)
    };
  }
  setValue(value) {
    this.setState({
      list: this.parseValue(value)
    });
  }
  parseValue(value) {
    let arr = null;
    var target = [];
    while ((arr = REG_CSS_UNIT.exec(value)) !== null) {
      var text2 = arr[0];
      if (text2 === "auto") {
        target.push({ type: "auto", count: 0, value: "0px" });
      } else if (text2.includes("repeat")) {
        var tempArray = text2.split("repeat(")[1].split(")");
        tempArray.pop();
        let [count, ...size2] = tempArray.join("").split(",");
        target.push({ type: "repeat", count, value: size2.join(", ") });
      } else {
        target.push({ type: "length", count: 1, value: text2 });
      }
    }
    return target;
  }
  getValue() {
    return this.state.list.map((it) => {
      if (it.type === "repeat") {
        return `repeat(${it.count}, ${it.value})`;
      } else if (it.type === "auto" || it.type === "none") {
        return it.type;
      } else {
        return it.value;
      }
    }).join(" ");
  }
  modifyData() {
    this.parent.trigger(this.props.onchange, this.props.key, this.getValue());
  }
  makeItem(it, index2) {
    return `
            <div class='item' data-repeat-type='${it.type}' data-index='${index2}' >
                <div class='repeat'>
                    <object refClass="SelectEditor" 
                        ref='$${index2}-type' 
                        options="${this.getLayoutItemOptions()}" 
                        key="type" 
                        value="${it.type || "auto"}" 
                        params="${index2}" 
                        onchange="changeKeyValue" />
                </div>
                <div class='count'>
                    <object refClass="NumberInputEditor" 
                        ref='$${index2}-count' 
                        key="count" 
                        value="${it.count}" 
                        params="${index2}" 
                        max='1000'
                        onchange="changeKeyValue" />
                </div>                
                <div class='value'>
                    <object refClass="InputRangeEditor" 
                        ref='$${index2}-value' 
                        key="value" 
                        value="${it.value}" 
                        params="${index2}" 
                        units='auto,fr,px,em,%'
                        onchange="changeKeyValue" />
                </div>
                <div class='tools'>
                    <button type="button" class='copy'>${iconUse$1("copy")}</button>                
                    <button type="button" class='remove'>${iconUse$1("remove2")}</button>
                </div>
            </div>
        `;
  }
  [LOAD("$list")]() {
    return this.state.list.map((it, index2) => {
      return this.makeItem(it, index2);
    });
  }
  template() {
    return `
            <div class='elf--grid-box-editor' ref='$body' >
                <div class='grid-box-editor-item'>
                    <div class='item header'>
                        <div class='repeat'>
                            <label>${this.state.label} </label>
                            <button type='button' ref='$add'>${obj.add}</button>
                        </div>
                        <div class='count'>${this.$i18n("grid.box.editor.count")}</div>
                        <div class='value'>${this.$i18n("grid.box.editor.value")}</div>
                        <div class='tools'></div>
                    </div>
                    <div ref='$list'></div>
                </div>
            </div>
        `;
  }
  [CLICK("$list .remove")](e2) {
    var index2 = +e2.$dt.closest("item").attr("data-index");
    this.state.list.splice(index2, 1);
    this.refresh();
    this.modifyData();
  }
  [CLICK("$list .copy")](e2) {
    var index2 = +e2.$dt.closest("item").attr("data-index");
    var newObj = clone$1(this.state.list[index2]);
    this.state.list.splice(index2, 0, newObj);
    this.refresh();
    this.modifyData();
  }
  [CLICK("$add")]() {
    this.trigger("add");
  }
  [SUBSCRIBE("add")]() {
    this.state.list.push({ type: "auto", count: 0, value: "0px" });
    this.refresh();
    this.modifyData();
  }
  [SUBSCRIBE_SELF("changeKeyValue")](key, value, params) {
    var index2 = +params;
    var item2 = this.state.list[index2];
    if (item2) {
      if (key === "type") {
        this.refs.$list.$(`[data-index="${index2}"]`).attr("data-repeat-type", value);
      }
      item2[key] = value;
    }
    this.modifyData();
  }
}
class GridGapEditor extends EditorElement {
  initState() {
    return {
      label: this.props.label,
      value: this.parseValue(this.props.value)
    };
  }
  setValue(value) {
    this.setState({
      list: this.parseValue(value)
    });
  }
  parseValue(value) {
    return Length.parse(value);
  }
  getValue() {
    return this.state.value;
  }
  modifyData() {
    this.parent.trigger(this.props.onchange, this.props.key, this.getValue());
  }
  makeItem() {
    return `
            <div class='item'>
                <div class='value'>
                    ${createComponent("RangeEditor", {
      label: this.state.label,
      ref: "$value",
      key: "value",
      value: this.state.value,
      units: ["px", "em", "%"],
      onchange: "changeKeyValue"
    })}
                </div>
            </div>
        `;
  }
  [LOAD("$list")]() {
    return this.makeItem();
  }
  template() {
    return `
            <div class='grid-gap-editor' ref='$body' >
                <div class='grid-gap-editor-item'>
                    <div ref='$list'></div>
                </div>
            </div>
        `;
  }
  [SUBSCRIBE_SELF("changeKeyValue")](key, value) {
    this.state.value = value;
    this.modifyData();
  }
}
var GridLayoutEditor$1 = "";
class GridLayoutEditor extends EditorElement {
  initState() {
    return __spreadValues({}, STRING_TO_CSS(this.props.value));
  }
  setValue(value) {
    this.setState(__spreadValues({}, STRING_TO_CSS(value)));
  }
  getValue() {
    return CSS_TO_STRING$1(this.state);
  }
  modifyData() {
    this.parent.trigger(this.props.onchange, this.props.key, this.getValue());
  }
  template() {
    return `
            <div class='elf--grid-layout-editor' ref='$body' ></div>
        `;
  }
  [LOAD("$body")]() {
    return `
            <div class='grid-layout-item'>
                <object refClass="GridBoxEditor" 
                    label='${this.$i18n("grid.layout.editor.template.columns")}'
                    ref='$columnBox'
                    key='grid-template-columns'
                    value="${this.state["grid-template-columns"] || ""}"
                    onchange='changeKeyValue'
                />
            </div>
            <div class='grid-layout-item'>
                <object refClass="GridGapEditor" 
                    label='${this.$i18n("grid.layout.editor.column.gap")}'
                    ref='$columnGap'
                    key='grid-column-gap'
                    value="${this.state["grid-column-gap"] || ""}"
                    onchange='changeKeyValue'
                />
            </div>            
            <div class='grid-layout-item'>
                <object refClass="GridBoxEditor" 
                    label='${this.$i18n("grid.layout.editor.template.rows")}'
                    ref='$rowBox'
                    key='grid-template-rows'
                    value="${this.state["grid-template-rows"] || ""}"
                    onchange='changeKeyValue'
                />
            </div>            
            <div class='grid-layout-item'>
                <object refClass="GridGapEditor" 
                    label='${this.$i18n("grid.layout.editor.row.gap")}'      
                    ref='$rowGap'          
                    key='grid-row-gap'
                    value="${this.state["grid-row-gap"] || ""}"
                    onchange='changeKeyValue'
                />
            </div>
        `;
  }
  [SUBSCRIBE_SELF("changeKeyValue")](key, value, params) {
    this.setState({
      [key]: value
    }, false);
    this.modifyData();
  }
}
class GridLayoutItemEditor extends EditorElement {
  initState() {
    return __spreadValues({}, STRING_TO_CSS(this.props.value));
  }
  setValue(value) {
    this.setState(STRING_TO_CSS(value));
  }
  getValue() {
    return CSS_TO_STRING$1(this.state);
  }
  modifyData() {
    this.parent.trigger(this.props.onchange, this.props.key, this.getValue());
  }
  [LOAD("$body")]() {
    return `
            <div class='grid-layout-item'>
                <div class='label'><label>${this.$i18n("grid.layout.item.editor.direction")}</label></div>
                <object refClass="SelectIconEditor" 
                    key='grid-direction'
                    ref='$gridDirection'
                    value="${this.state["grid-direction"] || "row"}"
                    options="${getDirectionOptions()}"
                    onchange='changeKeyValue'
                />
            </div>
            <div class='grid-layout-item'>
                <div class='label'><label>${this.$i18n("grid.layout.item.editor.wrap")}</label></div>
                <object refClass="SelectIconEditor" 
                    key='grid-wrap'
                    ref='$grid-wrap'
                    value="${this.state["grid-wrap"] || "wrap"}"
                    options="${getWrapOptions()}"
                    onchange='changeKeyValue'
                />
            </div>
            <div class='grid-layout-item'>
                <div class='label'><label>${this.$i18n("grid.layout.item.editor.justify-content")}</label></div>
                <object refClass="SelectIconEditor" 
                    key='justify-content'
                    ref="$justifyContent"
                    value="${this.state["justify-content"]}"
                    options="${getJustifyContentOptions()}"
                    onchange='changeKeyValue'
                />
            </div>
            <div class='grid-layout-item'>
                <div class='label'><label>${this.$i18n("grid.layout.item.editor.align-items")}</label></div>
                <object refClass="SelectIconEditor" 
                    key='align-items'
                    ref='$alignItems'
                    value="${this.state["align-items"]}"
                    options="${getAlignItemsOptions()}"
                    onchange='changeKeyValue'
                />
            </div>
            <div class='grid-layout-item'>
                <div class='label'><label>${this.$i18n("grid.layout.item.editor.align-content")}</label></div>
                <object refClass="SelectIconEditor" 
                    key='align-content'
                    ref="$alignContent"
                    value="${this.state["align-content"]}"
                    options="${getAlignContentOptions()}"
                    onchange='changeKeyValue'
                />
            </div>    
        `;
  }
  template() {
    return `
            <div class='grid-layout-editor' ref='$body' ></div>
        `;
  }
  [SUBSCRIBE_SELF("changeKeyValue")](key, value, params) {
    this.setState({
      [key]: value
    }, false);
    this.modifyData();
  }
}
var GridLayoutItemProperty$1 = "";
class GridLayoutItemProperty extends BaseProperty {
  getTitle() {
    return this.$i18n("grid.layout.item.property.title");
  }
  getLayoutOptions() {
    return variable$4(["none", "value"].map((it) => {
      return { value: it, text: this.$i18n(`grid.layout.item.property.${it}`) };
    }));
  }
  getClassName() {
    return "elf--grid-layout-item-property";
  }
  getBody() {
    return `
        <div class='property-item' ref='$body'></div>
      `;
  }
  [LOAD("$body")]() {
    var current = this.$selection.current || { "grid-layout-item": "none" };
    var valueType2 = current["grid-layout-item"] || "none";
    var obj2 = {};
    if (["none"].includes(valueType2) === false) {
      obj2 = STRING_TO_CSS(current["grid-layout-item"]);
    }
    if (Object.keys(obj2).length > 0) {
      valueType2 = "value";
    }
    return `
      <div class='layout-select'>
        <object refClass="SelectIconEditor" 
        ref='$layout' 
        key='layout' 
        icon="true" 
        value="${valueType2}"
        options="${this.getLayoutOptions()}"  
        onchange="changeLayoutType" />
      </div>
      <div class='layout-list' ref='$layoutList' data-selected-value='${valueType2}'>
        <div data-value='none'></div>
        <div data-value='value'>
          <div class='value-item'>
            <label></label>
            <div>${this.$i18n("grid.layout.item.property.start")}</div>
            <div>${this.$i18n("grid.layout.item.property.end")}</div>
          </div>
          <div class='value-item'>
            <label>${this.$i18n("grid.layout.item.property.column")}</label>
            <div>
              <object refClass="NumberInputEditor"  ref='$columnStart' key="grid-column-start" value="${obj2["grid-column-start"] || "0"}" min='0' onchange='changeGridItem' />
            </div>
            <div>
              <object refClass="NumberInputEditor"  ref='$columnEnd' key="grid-column-end" value="${obj2["grid-column-end"] || "0"}" min='0' onchange='changeGridItem' />
            </div>            
          </div>
          <div class='value-item'>
            <label>${this.$i18n("grid.layout.item.property.row")}</label>
            <div>
              <object refClass="NumberInputEditor"  ref='$rowStart' key="grid-row-start" value="${obj2["grid-row-start"] || "0"}" min='0' onchange='changeGridItem' />
            </div>
            <div>
              <object refClass="NumberInputEditor"  ref='$rowEnd' key="grid-row-end" value="${obj2["grid-row-end"] || "0"}" min='0' onchange='changeGridItem' />
            </div>            
          </div>          
        </div>
      </div>
    `;
  }
  getGridValue() {
    var obj2 = {
      "grid-column-start": this.children.$columnStart.getValue(),
      "grid-column-end": this.children.$columnEnd.getValue(),
      "grid-row-start": this.children.$rowStart.getValue(),
      "grid-row-end": this.children.$rowEnd.getValue()
    };
    return CSS_TO_STRING$1(obj2);
  }
  [SUBSCRIBE_SELF("changeGridItem")](key, value) {
    this.command("setAttributeForMulti", "change grid layout item", this.$selection.packByValue({
      "grid-layout-item": this.getGridValue()
    }));
    this.nextTick(() => {
      this.emit("refreshAllElementBoundSize");
    });
  }
  [SUBSCRIBE_SELF("changeLayoutType")](key, value) {
    var valueType2 = this.children.$layout.getValue();
    var value = valueType2;
    if (valueType2 === "value") {
      value = this.getGridValue();
    }
    this.command("setAttributeForMulti", "change grid layout item", this.$selection.packByValue({
      "grid-layout-item": value
    }));
    this.refs.$layoutList.attr("data-selected-value", valueType2);
    this.nextTick(() => {
      this.emit("refreshAllElementBoundSize");
    });
  }
  [SUBSCRIBE("refreshSelection") + DEBOUNCE(100)]() {
    this.refreshShow(() => {
      var current = this.$selection.current;
      return current && current.isInGrid();
    });
  }
}
var LayoutProperty$1 = "";
class LayoutProperty extends BaseProperty {
  getTitle() {
    return this.$i18n("layout.property.title");
  }
  getClassName() {
    return "elf--layout-property";
  }
  getBody() {
    return `
        <div ref='$layoutProperty'></div>
      `;
  }
  getTools() {
    return `
      <div ref='$layoutType'></div>
    `;
  }
  [LOAD("$layoutType")]() {
    const current = this.$selection.current;
    if (!current)
      return "";
    return `
      <object refClass="SelectIconEditor" ${variable$4({
      ref: "$layout",
      key: "layout",
      value: current.layout,
      options: ["default", "flex", "grid"],
      icons: ["layout_default", "layout_flex", "layout_grid"],
      onchange: "changeLayoutType"
    })}
      />
    `;
  }
  [LOAD("$layoutProperty")]() {
    var current = this.$selection.current || { layout: "default" };
    return `
      <div class='layout-list' ref='$layoutList'>
        <div data-value='default' class='${current.layout === "default" ? "selected" : ""}'></div>
        <div data-value='flex' class='${current.layout === "flex" ? "selected" : ""}'>
          <object refClass="FlexLayoutEditor" ${variable$4({
      ref: "$flex",
      key: "flex-layout",
      value: {
        "flex-direction": current["flex-direction"],
        "flex-wrap": current["flex-wrap"],
        "justify-content": current["justify-content"],
        "align-items": current["align-items"],
        "align-content": current["align-content"],
        gap: current.gap
      },
      onchange: "changeLayoutInfo"
    })}  />
        </div>
        <div data-value='grid' class='${current.layout === "grid" ? "selected" : ""}'>
          <object refClass="GridLayoutEditor" ref='$grid' key='grid-layout' value="${current["grid-layout"] || ""}" onchange='changeLayoutInfo' />
        </div>
      </div>
    `;
  }
  [SUBSCRIBE_SELF("changeLayoutInfo")](key, value) {
    if (key === "padding") {
      this.command("setAttributeForMulti", "change padding", this.$selection.packByValue(value));
    } else {
      this.command("setAttributeForMulti", "change layout info", this.$selection.packByValue({
        [key]: value
      }));
    }
    this.nextTick(() => {
      this.emit("refreshAllElementBoundSize");
    });
  }
  [SUBSCRIBE_SELF("changeLayoutType")](key, value) {
    this.$selection.reset(this.$selection.packByValue({
      [key]: value
    }));
    this.updateTitle();
    this.command("setAttributeForMulti", "change layout type", this.$selection.packByValue({
      [key]: value
    }));
    this.nextTick(() => {
      this.refresh();
      this.emit("refreshAllElementBoundSize");
      this.emit("changeItemLayout");
      this.emit("refreshSelection");
    });
  }
  get editableProperty() {
    return "layout";
  }
  enableHasChildren() {
    return this.$selection.current.enableHasChildren();
  }
  updateTitle() {
    this.setTitle(this.$selection.current.layout + " Layout");
  }
  [SUBSCRIBE("refreshSelection") + IF("checkShow") + IF("enableHasChildren")]() {
    this.updateTitle();
    this.refresh();
  }
}
var DefaultLayoutItemProperty$1 = "";
class DefaultLayoutItemProperty extends BaseProperty {
  getTitle() {
    return this.$i18n("default.layout.item.property.title.constraints");
  }
  getClassName() {
    return "elf--default-layout-item-property";
  }
  getBody() {
    return `
        <div class='property-item' ref='$body'>
          <div class="constraints">
            <div ref="$constraintsInfo"></div>
            <div ref="$constraintsInfoInput"></div>
          </div>
        </div>
      `;
  }
  [LOAD("$constraintsInfo") + DOMDIFF]() {
    var current = this.$selection.current;
    current == null ? void 0 : current.hasLayout();
    const h = (current == null ? void 0 : current["constraints-horizontal"]) || Constraints.MIN;
    const v = (current == null ? void 0 : current["constraints-vertical"]) || Constraints.MIN;
    return `
      <div class="constraints-box">

        <!-- Horizontal -->
        <div class='item' data-value='min' data-selected="${h === Constraints.MIN || h === Constraints.STRETCH}" data-key='${ConstraintsDirection.HORIZONTAL}'></div>
        <div class='item' data-value='max' data-selected="${h === Constraints.MAX || h === Constraints.STRETCH}" data-key='${ConstraintsDirection.HORIZONTAL}'></div>
        <div class='item' data-value='center' data-selected="${h === Constraints.CENTER}" data-key='${ConstraintsDirection.HORIZONTAL}'></div>

        <!-- Vertical -->
        <div class='item' data-value='min' data-selected="${v === Constraints.MIN || v === Constraints.STRETCH}" data-key='${ConstraintsDirection.VERTICAL}'></div>
        <div class='item' data-value='max' data-selected="${v === Constraints.MAX || v === Constraints.STRETCH}" data-key='${ConstraintsDirection.VERTICAL}'></div>
        <div class='item' data-value='center' data-selected="${v === Constraints.CENTER}" data-key='${ConstraintsDirection.VERTICAL}'></div>            
        <div class="rect"></div>
      </div>
    `;
  }
  [LOAD("$constraintsInfoInput")]() {
    var current = this.$selection.current;
    const hasLayout = current == null ? void 0 : current.hasLayout();
    (current == null ? void 0 : current["constraints-horizontal"]) || Constraints.MIN;
    (current == null ? void 0 : current["constraints-vertical"]) || Constraints.MIN;
    return `
      <div>
        <object refClass="SelectEditor" ${variable$4({
      ref: "$constraintsHorizontal",
      key: "constraints-horizontal",
      value: (current == null ? void 0 : current["constraints-horizontal"]) || "min",
      label: iconUse$1("width"),
      compact: true,
      options: [
        { value: "min", "text": "Left" },
        { value: "max", "text": "Right" },
        { value: "stretch", "text": "Left and Right", disabled: hasLayout },
        { value: "center", "text": "Center" },
        { value: "scale", "text": "Scale", disabled: hasLayout }
      ],
      onchange: "changeConstraints"
    })} />
      </div>

      <div>
        <object refClass="SelectEditor" ${variable$4({
      ref: "$constraintsVertical",
      key: "constraints-vertical",
      value: (current == null ? void 0 : current["constraints-vertical"]) || "min",
      label: iconUse$1("height"),
      compact: true,
      options: [
        { value: "min", "text": "Top" },
        { value: "max", "text": "Bottom" },
        { value: "stretch", "text": "Top and Bottom", disabled: hasLayout },
        { value: "center", "text": "Center" },
        { value: "scale", "text": "Scale", disabled: hasLayout }
      ],
      onchange: "changeConstraints"
    })} />          
      </div>
    `;
  }
  [CLICK("$constraintsInfo .item")](e2) {
    const [value, key] = e2.$dt.attrs("data-value", "data-key");
    const current = this.$selection.current;
    if (!current)
      return;
    current.changeConstraints(key, value);
    this.trigger("changeConstraints", key, current[key]);
  }
  [SUBSCRIBE_SELF("changeConstraints")](key, value) {
    this.command("setAttributeForMulti", "apply constraints", this.$selection.packByValue({
      [key]: value
    }));
    this.nextTick(() => {
      this.refresh();
    }, 100);
  }
  [SUBSCRIBE("refreshSelection") + DEBOUNCE(100)]() {
    this.refreshShow(() => {
      var current = this.$selection.current;
      return current && current.isInDefault() && current.parent.isNot("project");
    });
  }
}
var ResizingProperty$1 = "";
class ResizingProperty extends BaseProperty {
  getTitle() {
    return this.$i18n("layout.property.resizing.title");
  }
  getClassName() {
    return "elf--resizing-property";
  }
  getBody() {
    return `
        <div ref='$body'>
          <div class="resizing-mode">
            <div class="resizing-box" ref="$resizingModeInfo"></div>
            <div ref="$resizingModeInfoInput"></div>
          </div>
        </div>
      `;
  }
  [LOAD("$resizingModeInfo") + DOMDIFF]() {
    var current = this.$selection.current || {};
    const h = current.resizingHorizontal || ResizingMode.FIXED;
    const v = current.resizingVertical || ResizingMode.FIXED;
    return `
      <div class="resizing-mode-box" data-horizontal="${h}" data-vertical="${v}">
        <div class="rect">
          <div class="vertical" data-key="resizingVertical">
            <div class="vertical-top">${iconUse$1("keyboard_arrow_down")}</div>
            <div class="vertical-bottom">${iconUse$1("keyboard_arrow_up")}</div>
          </div>
          <div class="horizontal" data-key="resizingHorizontal">
            <div class="horizontal-left">${iconUse$1("keyboard_arrow_right")}</div>
            <div class="horizontal-right">${iconUse$1("keyboard_arrow_left")}</div>
          </div>
          <div class="inner-rect"></div>
          <div class="inner-horizontal-rect"></div>
          <div class="inner-vertical-rect"></div>
        </div>
      </div>
    `;
  }
  makeOptionsForHorizontal() {
    const options2 = [
      { value: ResizingMode.FIXED, "text": "Fixed Width" },
      { value: ResizingMode.HUG_CONTENT, "text": "Hug Content" }
    ];
    return options2;
  }
  makeOptionsForVertical() {
    const options2 = [
      { value: ResizingMode.FIXED, "text": "Fixed Height" },
      { value: ResizingMode.HUG_CONTENT, "text": "Hug Content" }
    ];
    return options2;
  }
  [LOAD("$resizingModeInfoInput")]() {
    var current = this.$selection.current || {};
    current.resizingHorizontal;
    current.reisizngModeVertical;
    return `
      <div class="has-label-grid">
        <label data-direction="horizontal"></label>
        <object refClass="SelectEditor" ${variable$4({
      ref: "$resizingHorizontal",
      key: "resizingHorizontal",
      value: (current == null ? void 0 : current.resizingHorizontal) || ResizingMode.FIXED,
      options: this.makeOptionsForHorizontal(),
      onchange: "changeResizingMode"
    })} />
      </div>

      <div class="has-label-grid">
      <label data-direction="vertical"></label>
        <object refClass="SelectEditor" ${variable$4({
      ref: "$resizingVertical",
      key: "resizingVertical",
      value: (current == null ? void 0 : current.resizingVertical) || ResizingMode.FIXED,
      options: this.makeOptionsForVertical(),
      onchange: "changeResizingMode"
    })} />          
      </div>
    `;
  }
  [CLICK("$resizingModeInfo [data-key]")](e2) {
    const key = e2.$dt.data("key");
    const current = this.$selection.current;
    if (current[key] === ResizingMode.FIXED) {
      this.trigger("changeResizingMode", key, ResizingMode.HUG_CONTENT);
    } else {
      this.trigger("changeResizingMode", key, ResizingMode.FIXED);
    }
  }
  [SUBSCRIBE_SELF("changeResizingMode")](key, value) {
    this.command("setAttributeForMulti", "apply constraints", this.$selection.packByValue({
      [key]: value
    }));
    this.nextTick(() => {
      this.refresh();
    }, 100);
  }
  [SUBSCRIBE("refreshSelection") + DEBOUNCE(100)]() {
    this.refreshShow(() => {
      var current = this.$selection.current;
      const isFlexLayout = current.isLayout(Layout.FLEX);
      const isGridLayout = current.isLayout(Layout.GRID);
      const hasLayout = isFlexLayout || isGridLayout;
      return current && hasLayout && current.hasChildren();
    });
  }
}
function layout(editor) {
  editor.registerElement({
    FlexLayoutEditor,
    FlexLayoutItemEditor,
    GridLayoutEditor,
    GridLayoutItemEditor,
    GridBoxEditor,
    GridGapEditor
  });
  editor.registerMenuItem("inspector.tab.style", {
    LayoutProperty,
    ResizingProperty,
    DefaultLayoutItemProperty,
    GridLayoutItemProperty,
    FlexLayoutItemProperty
  });
}
var check = {
  key: "check",
  title: "Check",
  execute: function() {
    return [
      { pattern: `check(20px 20px, 10px 10px, black, transparent)` },
      { pattern: `check(40px 40px, 20px 20px, black, transparent)` },
      { pattern: `check(60px 60px, 30px 30px, #DDB104, rgba(254,240,188,0))` },
      { pattern: `check(80px 80px, 40px 40px, #DDB104, rgba(254,240,188,0))` },
      { pattern: `check(100px 100px, 50px 50px, #DCF3DC, transparent)` },
      { pattern: `check(200px 200px, 100px 100px, #102C45, transparent)` }
    ];
  }
};
var grid = {
  key: "grid",
  title: "Grid",
  execute: function() {
    return [
      { pattern: `grid(20px 20px, 10px 10px, black, transparent)` },
      { pattern: `grid(40px 40px, 20px 20px, black, transparent)` },
      { pattern: `grid(60px 60px, 30px 30px, #DDB104, rgba(254,240,188,0))` },
      { pattern: `grid(80px 80px, 40px 40px, #DDB104, rgba(254,240,188,0))` },
      { pattern: `grid(100px 100px, 50px 50px, #DCF3DC, transparent)` },
      { pattern: `grid(200px 200px, 100px 100px, #102C45, transparent)` }
    ];
  }
};
var dot = {
  key: "dot",
  title: "Dot",
  execute: function() {
    return [
      { pattern: `dot(20px 20px, 10px 10px, #B7C4CD, white, normal, 1px)` },
      { pattern: `dot(40px 40px, 20px 20px, #E7393F, #FEF0BC, normal, 2px)` },
      { pattern: `dot(60px 60px, 30px 30px, #E7393F, black, normal, 3px)` },
      { pattern: `dot(80px 80px, 40px 40px, #B7C4CD, white, normal, 4px)` }
    ];
  }
};
var crossdot = {
  key: "cross-dot",
  title: "Cross Dot",
  execute: function() {
    return [
      { pattern: `cross-dot(20px 20px, 10px 10px, #B7C4CD, white, normal, 1px)` },
      { pattern: `cross-dot(40px 40px, 20px 20px, #DDB104, #FEF0BC, normal, 4px)` },
      { pattern: `cross-dot(60px 60px, 30px 30px, #35DB92, #DCF9EC, normal, 6px)` }
    ];
  }
};
var diagonalLine = {
  key: "diagonal-line",
  title: "Diagonal Line",
  execute: function() {
    return [
      { pattern: `diagonal-line(10px 10px, 45deg, #B7C4CD, white, normal, 1px)` },
      { pattern: `diagonal-line(25px 25px, 90deg, #DDB104, #FEF0BC, normal, 2px)` },
      { pattern: `diagonal-line(50px 50px, 135deg, #35DB92, #DCF9EC, normal, 3px)` }
    ];
  }
};
var verticalLine = {
  key: "vertical-line",
  title: "Vertical Line",
  execute: function() {
    return [
      { pattern: `vertical-line(10px 10px, 0px, #B7C4CD, white, normal, 1px)` },
      { pattern: `vertical-line(25px 25px, 0px, #DDB104, #FEF0BC, normal, 2px)` },
      { pattern: `vertical-line(50px 50px, 0px, black, rgba(231,57,63,0.9), normal, 1px)` }
    ];
  }
};
var horizontalLine = {
  key: "horizontal-line",
  title: "Horizontal Line",
  execute: function() {
    return [
      { pattern: `horizontal-line(10px 10px, 0, #B7C4CD, white, normal, 1px)` },
      { pattern: `horizontal-line(25px 25px, 0, #DDB104, #FEF0BC, normal, 2px)` },
      { pattern: `horizontal-line(50px 50px, 0, #35DB92, #DCF9EC, normal, 3px)` }
    ];
  }
};
var patterns = [
  check,
  grid,
  dot,
  crossdot,
  diagonalLine,
  verticalLine,
  horizontalLine
];
var PatternAssetsProperty$1 = "";
class PatternAssetsProperty extends BaseProperty {
  getTitle() {
    return this.$i18n("pattern.asset.property.title");
  }
  initState() {
    return {
      mode: "grid",
      preset: "check"
    };
  }
  getTools() {
    const options2 = variable$4(patterns.map((it) => {
      return { value: it.key, text: it.title };
    }));
    return `
      <object refClass="SelectEditor" ref="$assets"  key="preset" value="${this.state.preset}" options="${options2}" onchange="changePreset"  />
    `;
  }
  [SUBSCRIBE_SELF("changePreset")](key, value) {
    this.setState({
      [key]: value
    });
  }
  getClassName() {
    return "elf--pattern-assets-property";
  }
  get editableProperty() {
    return "pattern";
  }
  [SUBSCRIBE("refreshSelection") + DEBOUNCE(100) + IF("checkShow")]() {
  }
  getBody() {
    return `
      <div class='property-item pattern-assets'>
        <div class='pattern-list' ref='$patternList' data-view-mode='${this.state.mode}'></div>
      </div>
    `;
  }
  [DRAGSTART("$patternList .pattern-item")](e2) {
    const pattern = e2.$dt.attr("data-pattern");
    e2.dataTransfer.effectAllowed = "copy";
    e2.dataTransfer.setData("text/pattern", pattern);
  }
  [LOAD("$patternList")]() {
    var preset = patterns.find((it) => it.key === this.state.preset);
    if (!preset) {
      return "";
    }
    var results = preset.execute().map((item2, index2) => {
      const cssText = CSS_TO_STRING$1(Pattern.toCSS(item2.pattern));
      return `
        <div class='pattern-item' data-index="${index2}" data-pattern="${item2.pattern}">
          <div class='preview' title="${item2.title}" draggable="true">
            <div class='pattern-view' style='${cssText}'></div>
          </div>
        </div>
      `;
    });
    return results;
  }
  [CLICK("$patternList .pattern-item")](e2) {
    const pattern = e2.$dt.attr("data-pattern");
    if (this.$modeView.isCurrentMode("CanvasView")) {
      this.emit("addBackgroundImagePattern", pattern);
    } else {
      this.emit("setPatternAsset", pattern);
    }
  }
}
var PatternEditor$1 = "";
class PatternEditor extends EditorElement {
  initState() {
    return {
      hideLabel: this.props.hideLabel,
      value: this.props.value,
      patterns: this.parsePattern(this.props.value)
    };
  }
  parsePattern(str) {
    return Pattern.parseStyle(str);
  }
  setValue(value) {
    this.setState({
      value,
      patterns: this.parsePattern(value)
    });
  }
  template() {
    this.state.hideLabel ? "hide" : "";
    return `
            <div class='elf--pattern-editor' >
                <div class='pattern-list' ref='$patternList'></div>
            </div>
        `;
  }
  [LOAD("$patternList")]() {
    return this.state.patterns.map((it, index2) => {
      const selectedClass = it.selected ? "selected" : "";
      if (it.selected) {
        this.selectedIndex = index2;
      }
      return `
            <div class='pattern-item ${selectedClass}' data-index='${index2}' ref="fillIndex${index2}"  draggable='true'>
                ${createComponent("PatternSizeEditor", {
        key: "pattern-size",
        ref: `$bp${index2}`,
        type: it.type,
        x: it.x,
        y: it.y,
        width: it.width,
        height: it.height,
        index: index2,
        foreColor: it.foreColor,
        backColor: it.backColor,
        blendMode: it.blendMode,
        lineWidth: it.lineWidth,
        lineHeight: it.lineHeight,
        onchange: "changePatternSizeInfo"
      })}
                <div class='tools'>
                    <button type="button" class='remove' title='Remove a pattern' data-index='${index2}'>${iconUse$1("remove")}</button>
                </div>
            </div>
            `;
    });
  }
  modifyPattern() {
    var value = Pattern.join(this.state.patterns);
    this.parent.trigger(this.props.onchange, this.props.key, value);
  }
  [SUBSCRIBE("add")](type = "check") {
    var pattern = patterns.find((it) => it.key === type);
    if (pattern) {
      const data = Pattern.parseStyle(pattern.execute()[0].pattern);
      this.state.patterns.push.apply(this.state.patterns, data);
      this.refresh();
      this.modifyPattern();
    }
  }
  [CLICK("$add")]() {
    this.trigger("add");
  }
  [DRAGSTART("$patternList .pattern-item")](e2) {
    this.startIndex = +e2.$dt.attr("data-index");
  }
  [DRAGOVER("$patternList .pattern-item") + PREVENT](e2) {
  }
  sortItem(arr, startIndex, targetIndex) {
    arr.splice(targetIndex + (startIndex < targetIndex ? -1 : 0), 0, ...arr.splice(startIndex, 1));
  }
  sortPattern(startIndex, targetIndex) {
    this.sortItem(this.state.patterns, startIndex, targetIndex);
  }
  [DROP("$patternList .pattern-item") + PREVENT](e2) {
    var targetIndex = +e2.$dt.attr("data-index");
    this.selectItem(this.startIndex, true);
    this.sortPattern(this.startIndex, targetIndex);
    this.modifyPattern();
    this.refresh();
  }
  getCurrentPattern() {
    return this.state.patterns[this.selectedIndex];
  }
  [CLICK("$patternList .tools .remove")](e2) {
    var removeIndex = +e2.$dt.attr("data-index");
    this.state.patterns.splice(removeIndex, 1);
    this.modifyPattern();
    this.refresh();
  }
  selectItem(selectedIndex, isSelected = true) {
    if (isSelected) {
      this.refs[`fillIndex${selectedIndex}`].addClass("selected");
    } else {
      this.refs[`fillIndex${selectedIndex}`].removeClass("selected");
    }
    this.state.patterns.forEach((it, index2) => {
      it.selected = index2 === selectedIndex;
    });
  }
  [SUBSCRIBE("changePatternSizeInfo") + DEBOUNCE(10)](key, value, index2) {
    var pattern = this.state.patterns[index2];
    pattern.reset(value);
    this.modifyPattern();
    this.refresh();
  }
}
var PatternInfoPopup$1 = "";
class PatternInfoPopup extends BasePopup {
  getClassName() {
    return "pattern-info-popup";
  }
  getTitle() {
    return this.$i18n("pattern.info.popup.title");
  }
  initState() {
    return {
      type: this.props.type || "grid",
      x: this.props.x || 0,
      y: this.props.y || 0,
      width: this.props.width || 0,
      height: this.props.height || 0,
      lineWidth: this.props.lineWidth || 1,
      lineHeight: this.props.lineHeight || 1,
      foreColor: this.props.foreColor || "black",
      backColor: this.props.backColor || "transparent",
      blendMode: this.props.blendMode || "normal"
    };
  }
  updateData(opt = {}) {
    this.setState(opt, false);
    const { x: x2, y: y2, width: width2, height: height2, foreColor, backColor, blendMode, lineWidth, lineHeight } = this.state;
    this.state.instance.trigger(this.state.changeEvent, {
      x: x2,
      y: y2,
      width: width2,
      height: height2,
      foreColor,
      backColor,
      blendMode,
      lineWidth,
      lineHeight
    });
  }
  [SUBSCRIBE_SELF("changeRangeEditor")](key, value) {
    this.updateData({ [key]: value });
  }
  templateForX() {
    if (this.hasNotX())
      return "";
    let label = "X";
    let units = "";
    if (this.state.type === "diagonal-line") {
      label = this.$i18n("pattern.info.popup.rotate");
      units = ["deg"];
    }
    return createComponent("InputRangeEditor", {
      label,
      ref: "$x",
      key: "x",
      value: this.state.x,
      min: 0,
      max: 1e3,
      step: 1,
      units,
      onchange: "changeRangeEditor"
    });
  }
  templateForY() {
    if (this.hasNotY())
      return "<div></div>";
    return createComponent("InputRangeEditor", {
      label: "Y",
      ref: "$y",
      key: "y",
      value: this.state.y,
      min: 0,
      max: 1e3,
      step: 1,
      onchange: "changeRangeEditor"
    });
  }
  templateForLabel() {
    return `<label>${this.state.type}</label>`;
  }
  templateForWidth() {
    return createComponent("InputRangeEditor", {
      label: this.$i18n("pattern.info.popup.width"),
      ref: "$width",
      key: "width",
      value: this.state.width,
      min: 0,
      max: 500,
      step: 1,
      onchange: "changeRangeEditor"
    });
  }
  templateForHeight() {
    return createComponent("InputRangeEditor", {
      label: this.$i18n("pattern.info.popup.height"),
      ref: "$height",
      key: "height",
      value: this.state.height,
      min: 0,
      max: 500,
      step: 1,
      onchange: "changeRangeEditor"
    });
  }
  hasNotLineWidth() {
    return ["check"].includes(this.state.type);
  }
  hasNotLineHeight() {
    return ["cross-dot", "dot", "check", "diagonal-line", "horizontal-line"].includes(this.state.type);
  }
  hasNotX() {
    return ["grid", "dot", "horizontal-line"].includes(this.state.type);
  }
  hasNotY() {
    return ["grid", "dot", "diagonal-line", "vertical-line"].includes(this.state.type);
  }
  templateForLineWidth() {
    if (this.hasNotLineWidth())
      return "<div></div>";
    return createComponent("InputRangeEditor", {
      label: this.$i18n("pattern.info.popup.lineWidth"),
      ref: "$lineWidth",
      key: "lineWidth",
      value: this.state.lineWidth,
      min: 0,
      max: 500,
      step: 1,
      onchange: "changeRangeEditor"
    });
  }
  templateForLineHeight() {
    if (this.hasNotLineHeight())
      return "<div></div>";
    return createComponent("InputRangeEditor", {
      label: this.$i18n("pattern.info.popup.lineHeight"),
      ref: "$lineHeight",
      key: "lineHeight",
      value: this.state.lineHeight,
      min: 0,
      max: 500,
      step: 1,
      onchange: "changeRangeEditor"
    });
  }
  templateForForeColor() {
    return createComponent("ColorViewEditor", {
      ref: "$foreColor",
      label: this.$i18n("pattern.info.popup.foreColor"),
      key: "foreColor",
      value: this.state.foreColor,
      onchange: "changeRangeEditor"
    });
  }
  templateForBackColor() {
    return createComponent("ColorViewEditor", {
      ref: "$backColor",
      label: this.$i18n("pattern.info.popup.backColor"),
      key: "backColor",
      value: this.state.backColor,
      onchange: "changeRangeEditor"
    });
  }
  templateForBlendMode() {
    return `
    <div class=''>
      <object refClass="BlendSelectEditor" 
            ref='$blend' 
            key='blendMode' 
            label="${this.$i18n("pattern.info.popup.blend")}"
            value="${this.state.blendMode}" 
            onchange="changeRangeEditor" 
        />
    </div>
    `;
  }
  getBody() {
    return `
      <div class="background-image-position-picker" ref='$picker'></div>
    `;
  }
  [LOAD("$picker")]() {
    return `
      
      <div class='box'>
          <div>
            ${this.templateForLabel()}
          </div>
          <div>
            ${this.templateForWidth()}
            ${this.templateForHeight()}        
          </div>
          <div>
            ${this.templateForLineWidth()}
            ${this.templateForLineHeight()}                  
          </div>
          <div>
            ${this.templateForX()}
            ${this.templateForY()}
          </div>
          <div>
            ${this.templateForForeColor()}
            ${this.templateForBackColor()}
          </div>
          <div>
            ${this.templateForBlendMode()}
          </div>
      </div>
    `;
  }
  [SUBSCRIBE("showPatternInfoPopup")](data, rect2) {
    this.state.changeEvent = data.changeEvent || "changePatternInfoPopup";
    this.state.instance = data.instance;
    this.setState(data.data);
    this.showByRect(rect2);
  }
}
var PatternProperty$1 = "";
class PatternProperty extends BaseProperty {
  getTitle() {
    return this.$i18n("pattern.property.title");
  }
  getClassName() {
    return "el--pattern-property";
  }
  getTitleClassName() {
    return "pattern";
  }
  getBody() {
    return `<div class='pattern-property' ref='$body'></div>`;
  }
  getTools() {
    return `
      <div ref='$tools' class='add-tools'>
        <button type="button" data-pattern='check' data-tooltip="Check">${iconUse$1("pattern_check")}</button>
        <button type="button" data-pattern='grid' data-tooltip="Grid">${iconUse$1("pattern_grid")}</button>
        <button type="button" data-pattern='dot' data-tooltip="Dot">${iconUse$1("pattern_dot")}</button>
        <button type="button" data-pattern='cross-dot' data-tooltip="Cross Dot">${iconUse$1("pattern_cross_dot", "rotate(45 12 12)")}</button>
        <button type="button" data-pattern='diagonal-line' data-tooltip="Diagonal Line">${iconUse$1("texture")}</button>
        <button type="button" data-pattern='vertical-line' data-tooltip="Vertical Line" data-direction="bottom right">${iconUse$1("pattern_horizontal_line", "rotate(90 12 12)")}</button>
        <button type="button" data-pattern='horizontal-line' data-tooltip="Horizontal Line" data-direction="bottom right">${iconUse$1("pattern_horizontal_line")}</button>
      </div>
    `;
  }
  [CLICK("$tools button")](e2) {
    var patternType = e2.$dt.data("pattern");
    this.children.$patternEditor.trigger("add", patternType);
  }
  [LOAD("$body")]() {
    var current = this.$selection.current || {};
    var value = current.pattern;
    return `<object refClass="PatternEditor" ref='$patternEditor' value='${value}' hide-label='true' onchange='changePatternEditor' />`;
  }
  [SUBSCRIBE_SELF("changePatternEditor")](key, pattern) {
    this.command("setAttributeForMulti", "change pattern", this.$selection.packByValue({
      pattern
    }));
  }
  get editableProperty() {
    return "pattern";
  }
  [SUBSCRIBE("refreshSelection") + IF("checkShow")]() {
    this.refresh();
  }
  [SUBSCRIBE("refreshSVGArea") + DEBOUNCE(1e3)]() {
    this.load("$patternSelect");
  }
}
var PatternSizeEditor$1 = "";
class PatternSizeEditor extends EditorElement {
  initState() {
    return {
      index: this.props.index,
      x: Length.parse(this.props.x),
      y: Length.parse(this.props.y),
      width: Length.parse(this.props.width),
      height: Length.parse(this.props.height),
      lineWidth: Length.parse(this.props.lineWidth),
      lineHeight: Length.parse(this.props.lineHeight),
      backColor: this.props.backColor,
      foreColor: this.props.foreColor,
      blendMode: this.props.blendMode,
      type: this.props.type
    };
  }
  updateData(opt = {}) {
    this.setState(opt, false);
    this.modifyValue(opt);
  }
  modifyValue(value) {
    this.parent.trigger(this.props.onchange, this.props.key, value, this.state.index);
  }
  setValue(obj2) {
    this.setState(__spreadValues({}, obj2));
  }
  [BIND("$miniView")]() {
    const {
      type,
      x: x2,
      y: y2,
      width: width2,
      height: height2,
      lineWidth,
      lineHeight,
      backColor,
      foreColor,
      blendMode
    } = this.state;
    let obj2 = {
      type,
      x: x2,
      y: y2,
      width: width2,
      height: height2,
      lineWidth,
      lineHeight,
      backColor,
      foreColor,
      blendMode
    };
    if (this.state.width > 80) {
      obj2.width = 80;
      obj2.x = obj2.x.value / this.state.width / 80;
    }
    if (this.state.height > 80) {
      obj2.height = 80;
      obj2.y = this.state.y.value / this.state.height / 80;
    }
    const pattern = Pattern.parse(obj2);
    return {
      cssText: pattern.toCSS()
    };
  }
  template() {
    return `
            <div class='elf--pattern-size-editor'>
                <div class='preview' ref='$preview'>
                    <div class='mini-view'>
                        <div class='color-view' style="background-color: ${this.state.color}" ref='$miniView'></div>
                    </div>
                </div>
            </div>
        `;
  }
  [CLICK("$preview")](e2) {
    this.viewBackgroundPositionPopup();
  }
  viewBackgroundPositionPopup() {
    this.emit("getLayoutElement", (layoutElement) => {
      const bodyRect = layoutElement.$bodyPanel.rect();
      const rect2 = this.$el.rect();
      const newRect = {
        left: bodyRect.left + bodyRect.width - 240,
        top: rect2.top,
        width: 240,
        height: 300
      };
      this.emit("showPatternInfoPopup", {
        changeEvent: (pattern) => {
          this.updateData(__spreadValues({}, pattern));
        },
        data: this.state,
        instance: this
      }, newRect);
    });
  }
}
function patternAsset(editor) {
  editor.registerElement({
    PatternEditor,
    PatternSizeEditor,
    PatternAssetsProperty
  });
  editor.registerMenuItem("inspector.tab.style", {
    PatternProperty
  });
  editor.registerMenuItem("popup", {
    PatternInfoPopup
  });
}
class PerspectiveProperty extends BaseProperty {
  getTitle() {
    return this.$i18n("perspective.property.title");
  }
  getKeyframeProperty() {
    return "perspective";
  }
  getTools() {
    return `
        <button type="button" class="remove" ref='$remove'>${obj.remove}</button>
    `;
  }
  [CLICK("$remove")]() {
    this.trigger("changePerspective", "perspective", "");
  }
  getBody() {
    return `<div class='property-item' ref='$perspective'></div>`;
  }
  [LOAD("$perspective")]() {
    var current = this.$selection.current || {};
    var perspective2 = current["perspective"] || "";
    return `
        <object refClass="RangeEditor"  ref='$1' key='perspective' value="${perspective2}" max="2000px" onchange="changePerspective" />
    `;
  }
  [SUBSCRIBE_SELF("changePerspective")](key, value) {
    this.command("setAttributeForMulti", "change perspective", this.$selection.packByValue({
      [key]: value
    }));
  }
  get editableProperty() {
    return "perspective";
  }
  [SUBSCRIBE("refreshSelection") + DEBOUNCE(100) + IF("checkShow")]() {
    this.refresh();
  }
}
function perspective(editor) {
  editor.registerMenuItem("inspector.tab.style", {
    PerspectiveProperty
  });
}
var PerspectiveOriginEditor$1 = "";
const typeList$1 = [
  { key: "perspective-origin-x", title: "X" },
  { key: "perspective-origin-y", title: "Y" }
];
const keyList = typeList$1.map((it) => it.key);
const origin = {
  top: "50% 0%",
  "top left": "0% 0%",
  "top right": "100% 0%",
  left: "0% 50%",
  center: "50% 50%",
  right: "100% 50%",
  bottom: "50% 100%",
  "bottom left": "0% 100%",
  "bottom right": "100% 100%"
};
class PerspectiveOriginEditor extends EditorElement {
  initState() {
    var arr = this.props.value.split(" ");
    var obj2 = {
      isAll: true,
      "perspective-origin": 0,
      "perspective-origin-x": 0,
      "perspective-origin-y": 0
    };
    if (this.props.value) {
      if (arr.length === 1) {
        obj2["isAll"] = true;
        obj2["perspective-origin"] = Length.parse(arr[0]);
        obj2["perspective-origin-x"] = Length.parse(arr[0]);
        obj2["perspective-origin-y"] = Length.parse(arr[0]);
      } else if (arr.length == 2) {
        obj2["isAll"] = false;
        obj2["perspective-origin-x"] = Length.parse(arr[0]);
        obj2["perspective-origin-y"] = Length.parse(arr[1]);
      }
    }
    return obj2;
  }
  template() {
    return `
      <div class='elf--perspective-origin-editor' ref='$body'>
        <div class='direction' ref='$direction'>
          <div class='pos' data-value='top'></div>
          <div class='pos' data-value='top left'></div>
          <div class='pos' data-value='top right'></div>
          <div class='pos' data-value='bottom'></div>
          <div class='pos' data-value='bottom left'></div>
          <div class='pos' data-value='bottom right'></div>
          <div class='pos' data-value='left'></div>
          <div class='pos' data-value='right'></div>
          <div class='pos' data-value='center'></div>
        </div>
        <div ref='$body'></div>
      </div>
    `;
  }
  [CLICK("$direction .pos")](e2) {
    var direct = e2.$dt.attr("data-value");
    this.state.isAll = false;
    var [x2, y2] = origin[direct].split(" ");
    this.state["perspective-origin-x"] = Length.parse(x2);
    this.state["perspective-origin-y"] = Length.parse(y2);
    this.refresh();
    this.modifyPerspectiveOrigin();
  }
  [SUBSCRIBE_SELF("changePerspectiveOrigin")](key, value) {
    if (key === "perspective-origin") {
      keyList.forEach((type) => {
        this.children[`$${type}`].setValue(value.toString());
      });
    }
    this.setPerspectiveOrigin();
  }
  [LOAD("$body")]() {
    var selectedValue = this.state.isAll ? "all" : "partitial";
    var perspectiveOrigin2 = this.state["perspective-origin"];
    return `
      <div class="property-item perspective-origin-item">
        <div class="radius-selector" data-selected-value="${selectedValue}" ref="$selector">
          <button type="button" data-value="all">${obj.border_all}</button>
          <button type="button" data-value="partitial">
            ${obj.border_inner}
          </button>
        </div>
        <div class="radius-value">
          <object refClass="RangeEditor"  ref='$all' key='perspective-origin' value="${perspectiveOrigin2}" onchange='changePerspectiveOrigin' />
        </div>
      </div>
      <div
        class="property-item full perspective-origin-item"
        ref="$partitialSetting"
        style="display: none;"
      >
        <div class="radius-setting-box" ref="$radiusSettingBox">
          ${typeList$1.map((it) => {
      var label = this.$i18n(it.title);
      return `
              <div>
                  <object refClass="RangeEditor"  ref='$${it.key}' label='${label}' key='${it.key}' value="${this.state[it.key]}" onchange='changePerspectiveOrigin' />
              </div>  
            `;
    }).join("")}
        </div>
      </div>
    `;
  }
  setPerspectiveOrigin() {
    var type = this.refs.$selector.attr("data-selected-value");
    if (type === "all") {
      this.state.isAll = true;
      this.state["perspective-origin"] = this.children[`$all`].getValue();
    } else {
      this.state.isAll = false;
      keyList.forEach((key) => {
        this.state[key] = this.children[`$${key}`].getValue();
      });
    }
    this.modifyPerspectiveOrigin();
  }
  modifyPerspectiveOrigin() {
    var value = "";
    if (this.state.isAll) {
      value = `${this.state["perspective-origin"]}`;
    } else {
      value = `${this.state["perspective-origin-x"]} ${this.state["perspective-origin-y"]}`;
    }
    this.parent.trigger(this.props.onchange, value);
  }
  [CLICK("$selector button")](e2) {
    var type = e2.$dt.attr("data-value");
    this.refs.$selector.attr("data-selected-value", type);
    if (type === "all") {
      this.refs.$partitialSetting.hide();
    } else {
      this.refs.$partitialSetting.show("grid");
    }
    this.setPerspectiveOrigin();
  }
}
class PerspectiveOriginProperty extends BaseProperty {
  getTitle() {
    return this.$i18n("perspective.origin.property.title");
  }
  getKeyframeProperty() {
    return "perspective-origin";
  }
  getTools() {
    return `
        <button type="button" class="remove" ref='$remove'>${obj.remove}</button>
    `;
  }
  [CLICK("$remove")]() {
    this.trigger("changePerspectiveOrigin", "");
  }
  getBody() {
    return `
      <div class="property-item full perspective-origin-item" ref='$body'></div>
    `;
  }
  [LOAD("$body")]() {
    var current = this.$selection.current || {};
    var value = current["perspective-origin"] || "";
    return `<object refClass="PerspectiveOriginEditor" 
              ref='$1' 
              value='${value}' 
              onchange='changePerspectiveOrigin' 
            />`;
  }
  get editableProperty() {
    return "perspective-origin";
  }
  [SUBSCRIBE("refreshSelection") + DEBOUNCE(100) + IF("checkShow")]() {
    this.refresh();
  }
  [SUBSCRIBE_SELF("changePerspectiveOrigin")](value) {
    this.command("setAttributeForMulti", "change perspective origin", this.$selection.packByValue({
      "perspective-origin": value
    }));
  }
}
function perspectiveOrigin(editor) {
  editor.registerElement({
    PerspectiveOriginEditor
  });
  editor.registerMenuItem("inspector.tab.style", {
    PerspectiveOriginProperty
  });
}
var PositionProperty$1 = "";
const DEFAULT_SIZE = 0;
class PositionProperty extends BaseProperty {
  getTitle() {
    return this.$i18n("position.property.title");
  }
  afterRender() {
    this.show();
  }
  [SUBSCRIBE("refreshSelection")]() {
    this.refreshShowIsNot(["project"]);
  }
  checkChangedValue() {
    var current = this.$selection.current;
    if (!current)
      return false;
    return current.hasChangedField("x", "y", "right", "bottom", "width", "height", "transform", "rotateZ", "rotate", "opacity", "constraints-horizontal", "constriants-vertical");
  }
  [SUBSCRIBE("refreshSelectionStyleView") + IF("checkChangedValue") + THROTTLE(10)]() {
    var current = this.$selection.current;
    if (!current)
      return "";
    this.children.$x.setValue(current.offsetX || DEFAULT_SIZE);
    this.children.$y.setValue(current.offsetY || DEFAULT_SIZE);
    this.children.$width.setValue(current.width || DEFAULT_SIZE);
    this.children.$height.setValue(current.height || DEFAULT_SIZE);
    this.children.$opacity.setValue(current["opacity"] || "1");
    const rotateZ2 = Transform.get(current.transform, "rotateZ");
    if (rotateZ2) {
      this.children.$rotate.setValue(rotateZ2[0]);
    } else {
      this.children.$rotate.setValue(Length.deg(0));
    }
  }
  isHideHeader() {
    return true;
  }
  getBodyClassName() {
    return "no-padding";
  }
  getBody() {
    return `
      <div class="position-item" ref="$positionItem" style='padding: 5px 10px;'>
        <div class="grid-layout">
          ${createComponent("NumberInputEditor", {
      ref: "$x",
      compact: true,
      label: "X",
      key: "x",
      min: -1e5,
      max: 1e5,
      trigger: "enter",
      onchange: "changRangeEditor"
    })}
          ${createComponent("NumberInputEditor", {
      ref: "$y",
      compact: true,
      trigger: "enter",
      label: "Y",
      key: "y",
      min: -1e4,
      max: 1e4,
      onchange: "changRangeEditor"
    })}
        </div>
        <div class="grid-layout">          
          ${createComponent("NumberInputEditor", {
      ref: "$width",
      compact: true,
      trigger: "enter",
      label: "W",
      key: "width",
      min: 0,
      max: 3e3,
      onchange: "changRangeEditor"
    })}
          ${createComponent("NumberInputEditor", {
      ref: "$height",
      compact: true,
      trigger: "enter",
      label: "H",
      key: "height",
      min: 0,
      max: 3e3,
      onchange: "changRangeEditor"
    })}
        </div> 
        <div class="grid-layout">
          ${createComponent("InputRangeEditor", {
      ref: "$rotate",
      key: "rotateZ",
      compact: true,
      label: "rotate_left",
      min: -360,
      max: 360,
      step: 1,
      units: ["deg"],
      onchange: "changeRotate"
    })}
          ${createComponent("NumberInputEditor", {
      ref: "$opacity",
      key: "opacity",
      compact: true,
      label: "opacity",
      min: 0,
      max: 1,
      step: 0.01,
      onchange: "changeSelect"
    })}
        </div>                
      </div>
    `;
  }
  refresh() {
    const current = this.$selection.current;
    if (current) {
      this.children.$x.setValue(current.offsetX);
      this.children.$y.setValue(current.offsetY);
      this.children.$width.setValue(current.width);
      this.children.$height.setValue(current.height);
      this.children.$opacity.setValue(current["opacity"] || "1");
      const rotateZ2 = Transform.get(current.transform, "rotateZ");
      if (rotateZ2) {
        this.children.$rotate.setValue(rotateZ2[0]);
      }
    }
  }
  [CLICK("$positionItem button[data-command]")](e2) {
    const command = e2.$dt.data("command");
    console.log(command);
  }
  [SUBSCRIBE_SELF("changRangeEditor")](key, value) {
    this.command("setAttributeForMulti", "change position or size", this.$selection.packByValue({
      [key]: value
    }));
    this.nextTick(() => {
      this.emit("refreshAllElementBoundSize");
      this.emit("refreshSelectionTool", true);
    });
  }
  [SUBSCRIBE_SELF("changeRotate")](key, rotate2) {
    this.command("setAttributeForMulti", "change rotate", this.$selection.packByValue({
      angle: rotate2.value
    }));
  }
  [SUBSCRIBE_SELF("changeSelect")](key, value) {
    this.command("setAttributeForMulti", `change ${key}`, this.$selection.packByValue({
      [key]: value
    }));
  }
}
function position(editor) {
  editor.registerMenuItem("inspector.tab.style", {
    PositionProperty
  });
}
var ProjectProperty$1 = "";
class ProjectProperty extends BaseProperty {
  getTitle() {
    return this.$i18n("project.property.title");
  }
  getClassName() {
    return "full";
  }
  getTools() {
    return `
      <button type='button' ref='$add' data-tooltip="Add a project" data-direction="bottom right">${obj.add}</button>
    `;
  }
  [CLICK("$add")]() {
    this.emit("addProject");
  }
  getBody() {
    return `
      <div class="elf--project-list scrollbar" ref="$projectList"></div>
    `;
  }
  [LOAD("$projectList") + DOMDIFF]() {
    var projects = this.$model.projects || [];
    return projects.map((projectId, index2) => {
      var selected = projectId === this.$selection.currentProject.id ? "selected" : "";
      const project2 = this.$model.get(projectId);
      return `
        <div class='project-item ${selected}'>
          <div class='detail'>
            <label data-id='${projectId}'>${project2.name || "New Project"}</label>
            <div class="tools">
              <button type="button" class="remove" data-id="${projectId}" title='Remove'>${obj.remove2}</button>
            </div>
          </div>
        </div>
      `;
    });
  }
  [DOUBLECLICK("$projectList .project-item")](e2) {
    this.startInputEditing(e2.$dt.$("label"));
  }
  modifyDoneInputEditing(input2) {
    this.endInputEditing(input2, (index2, text2) => {
      var project2 = this.$editor.projects[index2];
      if (project2) {
        project2.reset({
          name: text2
        });
      }
    });
  }
  [KEYDOWN("$projectList .project-item label") + ENTER + PREVENT + STOP](e2) {
    this.modifyDoneInputEditing(e2.$dt);
    return false;
  }
  [FOCUSOUT("$projectList .project-item label") + PREVENT + STOP](e2) {
    this.modifyDoneInputEditing(e2.$dt);
  }
  [CLICK("$projectList .project-item label")](e2) {
    var id = e2.$dt.attr("data-id");
    this.command("refreshSelectionPorject", "change project", id);
    this.nextTick(() => {
      this.refresh();
    });
  }
  [CLICK("$projectList .project-item .remove")](e2) {
    var id = e2.$dt.attr("data-id");
    this.command("removeProject", "remove project", id);
    this.nextTick(() => {
      this.refresh();
    });
  }
  [SUBSCRIBE("refreshProjectList", "refreshAll")]() {
    this.refresh();
  }
}
function project(editor) {
  editor.registerElement({
    ProjectProperty
  });
}
var SelectEditor$1 = "";
class SelectEditor extends EditorElement {
  initialize() {
    super.initialize();
    this.notEventRedefine = true;
  }
  initState() {
    var splitChar = this.props.split || ",";
    var options2 = Array.isArray(this.props.options) ? this.props.options.map((it) => {
      if (typeof it === "string") {
        return { value: it, text: it };
      }
      return it;
    }) : (this.props.options || "").split(splitChar).map((it) => it.trim()).map((it) => {
      const [value2, text2] = it.split(":");
      return { value: value2, text: text2 || value2 };
    });
    var value = this.props.value;
    var tabIndex = this.props.tabindex;
    var title2 = this.props.title;
    return {
      splitChar,
      label: this.props.label || "",
      title: title2,
      options: options2,
      value,
      tabIndex
    };
  }
  template() {
    var { label, title: title2, tabIndex, value = BlendMode.NORMAL } = this.state;
    var hasLabel = !!label ? "has-label" : "";
    var hasTabIndex = !!tabIndex ? 'tabIndex="1"' : "";
    var compact = !!this.props.compact ? "compact" : "";
    if (obj[label]) {
      label = iconUse$1(label);
    }
    return `
            <div class='elf--select-editor ${hasLabel} ${compact}'>
                ${label ? `<label title="${title2}">${label}</label>` : ""}
                <div class="editor-view">
                    <select ref='$options' ${hasTabIndex}></select>
                    <div class='selected-value'>
                        <span class='value' ref="$selectedValue">${value}</span>
                        <span class='expand' ref='$expand'>${iconUse$1("expand_more")}</span>
                    </div>
                </div>
            </div>
        `;
  }
  getValue() {
    return this.refs.$options.value;
  }
  setValue(value) {
    this.state.value = value + "";
    this.refs.$options.val(this.state.value);
    this.refresh();
  }
  [BIND("$options")]() {
    return {
      "data-count": this.state.options.length.toString()
    };
  }
  [BIND("$selectedValue")]() {
    var _a;
    return {
      text: (_a = this.state.options.find((it) => it.value === this.state.value)) == null ? void 0 : _a.text
    };
  }
  [LOAD("$options")]() {
    var arr = this.state.options.map((it) => {
      var value = it.value;
      var label = it.text || it.value;
      if (label === "") {
        label = this.props["none-value"] ? this.props["none-value"] : "";
      } else if (label === "-") {
        label = "----------";
        value = "";
      }
      var selected = value === this.state.value ? "selected" : "";
      const disabled = it.disabled ? "disabled" : "";
      return `<option ${selected} value="${value}" ${disabled}>${label}</option>`;
    });
    return arr;
  }
  [CHANGE("$options")]() {
    this.updateData({
      value: this.refs.$options.value
    });
    this.bindData("$selectedValue");
  }
  updateData(data) {
    this.setState(data, false);
    this.parent.trigger(this.props.onchange, this.props.key, this.state.value, this.props.params);
  }
}
const blend_list = [
  BlendMode.NORMAL,
  BlendMode.MULTIPLY,
  BlendMode.SCREEN,
  BlendMode.OVERLAY,
  BlendMode.DARKEN,
  BlendMode.LIGHTEN,
  BlendMode.COLOR_DODGE,
  BlendMode.COLOR_BURN,
  BlendMode.HARD_LIGHT,
  BlendMode.SOFT_LIGHT,
  BlendMode.DIFFERENCE,
  BlendMode.EXCLUSION,
  BlendMode.HUE,
  BlendMode.SATURATION,
  BlendMode.COLOR,
  BlendMode.LUMINOSITY
];
class BlendSelectEditor extends SelectEditor {
  getBlendList() {
    return blend_list.map((it) => {
      return { value: it, text: this.$i18n(`blend.${it}`) };
    });
  }
  initState() {
    return __spreadProps(__spreadValues({}, super.initState()), {
      options: this.getBlendList()
    });
  }
}
var ClipPathEditor$1 = "";
class ClipPathEditor extends EditorElement {
  initState() {
    return {
      clippath: this.props.value
    };
  }
  updateData(opt = {}) {
    this.setState(opt);
    this.modifyClipPath();
  }
  getValue() {
    return this.state.clippath;
  }
  setValue(clippath) {
    this.setState({ clippath });
  }
  modifyClipPath() {
    this.parent.trigger(this.props.onchange, this.state.clippath, this.props.params);
  }
  template() {
    return `
            <div class='elf--clip-path-editor'></div>
        `;
  }
  [LOAD()]() {
    var clippath = this.state.clippath;
    return `
        <div class='clippath-item'>
            <div class='name'>${clippath}</div>
        </div>
        `;
  }
  [CLICK()](e2) {
    this.viewClipPathPicker();
  }
  viewClipPathPicker() {
    this.emit("showClipPathPopup", {
      changeEvent: (data) => {
        this.updateData({
          clippath: data["clip-path"]
        });
      },
      "clip-path": this.state.clippath
    });
  }
}
const colors$k = [
  "#FFF8E1",
  "#FFECB3",
  "#FFE082",
  "#FFD54F",
  "#FFCA28",
  "#FFC107",
  "#FFB300",
  "#FFA000",
  "#FF8F00",
  "#FF6F00",
  "#FFE57F",
  "#FFD740",
  "#FFC400",
  "#FFAB00"
].map((color2) => {
  return { color: color2 };
});
var materialAmber = {
  title: "material amber",
  key: "material-amber",
  execute: function() {
    return colors$k;
  }
};
var __glob_0_0 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": materialAmber
});
const colors$j = [
  "#e3f2fd",
  "#bbdefb",
  "#90caf9",
  "#64b5f6",
  "#42a5f5",
  "#2196f3",
  "#1e88e5",
  "#1976d2",
  "#1565c0",
  "#0d47a1",
  "#2196f3",
  "#82b1ff",
  "#448aff",
  "#2979ff",
  "#2962ff"
].map((color2) => {
  return { color: color2 };
});
var materialBlue = {
  title: "material blue",
  key: "material-blue",
  execute: function() {
    return colors$j;
  }
};
var __glob_0_1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": materialBlue
});
const colors$i = [
  "#ECEFF1",
  "#CFD8DC",
  "#B0BEC5",
  "#90A4AE",
  "#78909C",
  "#607D8B",
  "#546E7A",
  "#455A64",
  "#37474F",
  "#263238"
].map((color2) => {
  return { color: color2 };
});
var materialBluegray = {
  title: "material bluegray",
  key: "material-bluegray",
  execute: function() {
    return colors$i;
  }
};
var __glob_0_2 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": materialBluegray
});
const colors$h = [
  "#EFEBE9",
  "#D7CCC8",
  "#BCAAA4",
  "#A1887F",
  "#8D6E63",
  "#795548",
  "#6D4C41",
  "#5D4037",
  "#4E342E",
  "#3E2723"
].map((color2) => {
  return { color: color2 };
});
var materialBrown = {
  title: "material brown",
  key: "material-brown",
  execute: function() {
    return colors$h;
  }
};
var __glob_0_3 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": materialBrown
});
const colors$g = [
  "#e0f7fa",
  "#b2ebf2",
  "#80deea",
  "#4dd0e1",
  "#26c6da",
  "#00bcd4",
  "#00acc1",
  "#0097a7",
  "#00838f",
  "#006064",
  "#00bcd4",
  "#84ffff",
  "#18ffff",
  "#00e5ff",
  "#00b8d4"
].map((color2) => {
  return { color: color2 };
});
var materialCyan = {
  title: "material cyan",
  key: "material-cyan",
  execute: function() {
    return colors$g;
  }
};
var __glob_0_4 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": materialCyan
});
const colors$f = [
  "#FBE9E7",
  "#FFCCBC",
  "#FFAB91",
  "#FF8A65",
  "#FF7043",
  "#FF5722",
  "#F4511E",
  "#E64A19",
  "#D84315",
  "#BF360C",
  "#FF9E80",
  "#FF6E40",
  "#FF3D00",
  "#DD2C00"
].map((color2) => {
  return { color: color2 };
});
var materialDeeporange = {
  title: "material deep orange",
  key: "material-deeporange",
  execute: function() {
    return colors$f;
  }
};
var __glob_0_5 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": materialDeeporange
});
const colors$e = [
  "#ede7f6",
  "#d1c4e9",
  "#b39ddb",
  "#9575cd",
  "#7e57c2",
  "#673ab7",
  "#5e35b1",
  "#512da8",
  "#4527a0",
  "#311b92",
  "#673ab7",
  "#b388ff",
  "#7c4dff",
  "#651fff",
  "#6200ea"
].map((color2) => {
  return { color: color2 };
});
var materialDeeppurple = {
  title: "material deep purple",
  key: "material-deeppurple",
  execute: function() {
    return colors$e;
  }
};
var __glob_0_6 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": materialDeeppurple
});
const colors$d = [
  "#FAFAFA",
  "#F5F5F5",
  "#EEEEEE",
  "#E0E0E0",
  "#BDBDBD",
  "#9E9E9E",
  "#757575",
  "#616161",
  "#424242",
  "#212121"
].map((color2) => {
  return { color: color2 };
});
var materialGray = {
  title: "material gray",
  key: "material-gray",
  execute: function() {
    return colors$d;
  }
};
var __glob_0_7 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": materialGray
});
const colors$c = [
  "#E8F5E9",
  "#C8E6C9",
  "#A5D6A7",
  "#81C784",
  "#66BB6A",
  "#4CAF50",
  "#43A047",
  "#388E3C",
  "#2E7D32",
  "#1B5E20",
  "#B9F6CA",
  "#69F0AE",
  "#00E676",
  "#00C853"
].map((color2) => {
  return { color: color2 };
});
var materialGreen = {
  title: "material green",
  key: "material-green",
  execute: function() {
    return colors$c;
  }
};
var __glob_0_8 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": materialGreen
});
const colors$b = [
  "#e8eaf6",
  "#c5cae9",
  "#9fa8da",
  "#7986cb",
  "#5c6bc0",
  "#3f51b5",
  "#3949ab",
  "#303f9f",
  "#283593",
  "#1a237e",
  "#3f51b5",
  "#8c9eff",
  "#536dfe",
  "#3d5afe",
  "#304ffe"
].map((color2) => {
  return { color: color2 };
});
var materialIndigo = {
  title: "material indigo",
  key: "material-indigo",
  execute: function() {
    return colors$b;
  }
};
var __glob_0_9 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": materialIndigo
});
const colors$a = [
  "#e1f5fe",
  "#b3e5fc",
  "#81d4fa",
  "#4fc3f7",
  "#29b6f6",
  "#03a9f4",
  "#039be5",
  "#0288d1",
  "#0277bd",
  "#01579b",
  "#03a9f4",
  "#80d8ff",
  "#40c4ff",
  "#00b0ff",
  "#0091ea"
].map((color2) => {
  return { color: color2 };
});
var materialLightblue = {
  title: "material light blue",
  key: "material-lightblue",
  execute: function() {
    return colors$a;
  }
};
var __glob_0_10 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": materialLightblue
});
const colors$9 = [
  "#F1F8E9",
  "#DCEDC8",
  "#C5E1A5",
  "#AED581",
  "#9CCC65",
  "#8BC34A",
  "#7CB342",
  "#689F38",
  "#558B2F",
  "#33691E",
  "#CCFF90",
  "#B2FF59",
  "#76FF03",
  "#64DD17"
].map((color2) => {
  return { color: color2 };
});
var materialLightgreen = {
  title: "material lightgreen",
  key: "material-lightgreen",
  execute: function() {
    return colors$9;
  }
};
var __glob_0_11 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": materialLightgreen
});
const colors$8 = [
  "#F9FBE7",
  "#F0F4C3",
  "#E6EE9C",
  "#DCE775",
  "#D4E157",
  "#CDDC39",
  "#C0CA33",
  "#AFB42B",
  "#9E9D24",
  "#827717",
  "#F4FF81",
  "#EEFF41",
  "#C6FF00",
  "#AEEA00"
].map((color2) => {
  return { color: color2 };
});
var materialLime = {
  title: "material lime",
  key: "material-lime",
  execute: function() {
    return colors$8;
  }
};
var __glob_0_12 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": materialLime
});
const colors$7 = [
  "#FFF3E0",
  "#FFE0B2",
  "#FFCC80",
  "#FFB74D",
  "#FFA726",
  "#FF9800",
  "#FB8C00",
  "#F57C00",
  "#EF6C00",
  "#E65100",
  "#FFD180",
  "#FFAB40",
  "#FF9100",
  "#FF6D00"
].map((color2) => {
  return { color: color2 };
});
var materialOrange = {
  title: "material orange",
  key: "material-orange",
  execute: function() {
    return colors$7;
  }
};
var __glob_0_13 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": materialOrange
});
const colors$6 = [
  "#fce4ec",
  "#f8bbd0",
  "#f48fb1",
  "#f06292",
  "#ec407a",
  "#e91e63",
  "#d81b60",
  "#c2185b",
  "#ad1457",
  "#880e4f",
  "#e91e63",
  "#ff80ab",
  "#ff4081",
  "#f50057",
  "#c51162"
].map((color2) => {
  return { color: color2 };
});
var materialPink = {
  title: "material pink",
  key: "material-pink",
  execute: function() {
    return colors$6;
  }
};
var __glob_0_14 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": materialPink
});
const colors$5 = [
  "#f3e5f5",
  "#e1bee7",
  "#ce93d8",
  "#ba68c8",
  "#ab47bc",
  "#9c27b0",
  "#8e24aa",
  "#7b1fa2",
  "#6a1b9a",
  "#4a148c",
  "#9c27b0",
  "#ea80fc",
  "#e040fb",
  "#d500f9",
  "#aa00ff"
].map((color2) => {
  return { color: color2 };
});
var materialPurple = {
  title: "material purple",
  key: "material-purple",
  execute: function() {
    return colors$5;
  }
};
var __glob_0_15 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": materialPurple
});
const colors$4 = [
  "#ffebee",
  "#ffcdd2",
  "#ef9a9a",
  "#e57373",
  "#ef5350",
  "#f44336",
  "#e53935",
  "#d32f2f",
  "#c62828",
  "#b71c1c",
  "#f44336",
  "#ff8a80",
  "#ff5252",
  "#ff1744",
  "#d50000"
].map((color2) => {
  return { color: color2 };
});
var materialRed = {
  title: "material red",
  key: "material-red",
  execute: function() {
    return colors$4;
  }
};
var __glob_0_16 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": materialRed
});
const colors$3 = [
  "#e0f2f1",
  "#b2dfdb",
  "#80cbc4",
  "#4db6ac",
  "#26a69a",
  "#009688",
  "#00897b",
  "#00796b",
  "#00695c",
  "#004d40",
  "#009688",
  "#a7ffeb",
  "#64ffda",
  "#1de9b6",
  "#00bfa5"
].map((color2) => {
  return { color: color2 };
});
var materialTeal = {
  title: "material teal",
  key: "material-teal",
  execute: function() {
    return colors$3;
  }
};
var __glob_0_17 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": materialTeal
});
const colors$2 = [
  "#FFFDE7",
  "#FFF9C4",
  "#FFF59D",
  "#FFF176",
  "#FFEE58",
  "#FFEB3B",
  "#FDD835",
  "#FBC02D",
  "#F9A825",
  "#F57F17",
  "#FFFF8D",
  "#FFFF00",
  "#FFEA00",
  "#FFD600"
].map((color2) => {
  return { color: color2 };
});
var materialYellow = {
  title: "material yellow",
  key: "material-yellow",
  execute: function() {
    return colors$2;
  }
};
var __glob_0_18 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": materialYellow
});
const colors$1 = [
  "#f8f9fa",
  "#f1f3f5",
  "#e9ecef",
  "#dee2e6",
  "#ced4da",
  "#adb5bd",
  "#868e96",
  "#495057",
  "#343a40",
  "#212529"
].map((color2) => {
  return { color: color2 };
});
var opencolorGray = {
  title: "opencolor gray",
  resource: "https://yeun.github.io/open-color/",
  key: "opencolor-gray",
  execute: function() {
    return colors$1;
  }
};
var __glob_0_19 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": opencolorGray
});
var random = {
  title: "random",
  key: "random",
  execute: function(count = 42) {
    const colorList = Color.randomByCount(count).map((color2) => {
      return { color: color2 };
    });
    colorList.sort((a, b) => {
      const localA = Color.parse(a.color);
      const localB = Color.parse(b.color);
      return localA.h > localB.h ? 1 : -1;
    });
    return colorList;
  }
};
var __glob_0_20 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": random
});
const modules = { "./colors_list/material-amber.js": __glob_0_0, "./colors_list/material-blue.js": __glob_0_1, "./colors_list/material-bluegray.js": __glob_0_2, "./colors_list/material-brown.js": __glob_0_3, "./colors_list/material-cyan.js": __glob_0_4, "./colors_list/material-deeporange.js": __glob_0_5, "./colors_list/material-deeppurple.js": __glob_0_6, "./colors_list/material-gray.js": __glob_0_7, "./colors_list/material-green.js": __glob_0_8, "./colors_list/material-indigo.js": __glob_0_9, "./colors_list/material-lightblue.js": __glob_0_10, "./colors_list/material-lightgreen.js": __glob_0_11, "./colors_list/material-lime.js": __glob_0_12, "./colors_list/material-orange.js": __glob_0_13, "./colors_list/material-pink.js": __glob_0_14, "./colors_list/material-purple.js": __glob_0_15, "./colors_list/material-red.js": __glob_0_16, "./colors_list/material-teal.js": __glob_0_17, "./colors_list/material-yellow.js": __glob_0_18, "./colors_list/opencolor-gray.js": __glob_0_19, "./colors_list/random.js": __glob_0_20 };
var colors = Object.values(modules).map((it) => it.default);
var ColorAssetsEditor$1 = "";
class ColorAssetsEditor extends EditorElement {
  initState() {
    return {
      mode: "grid",
      preset: "random",
      isLoaded: false,
      colors
    };
  }
  getTools() {
    return `<div ref="$tools"></div>`;
  }
  [LOAD("$tools")]() {
    const options2 = variable$4(this.state.colors.map((it) => {
      return { value: it.key, text: it.title };
    }));
    return `
      <object refClass="SelectEditor"  key="preset" value="${this.state.preset}" options="${options2}" onchange="changePreset"  />
    `;
  }
  [SUBSCRIBE("changePreset")](key, value) {
    this.setState({
      [key]: value
    });
  }
  template() {
    return `
      <div class='elf--color-assets-editor'>
        <div class='color-assets-head'>
          <div class='tools'>${this.getTools()}</div>
        </div>
        <div class='color-list' ref='$colorList' data-view-mode='${this.state.mode}'></div>
      </div>
    `;
  }
  [CLICK("$title")]() {
    this.$el.toggleClass("is-open");
  }
  [LOAD("$colorList")]() {
    var preset = this.state.colors.find((it) => it.key === this.state.preset);
    if (!preset) {
      return "";
    }
    var results = preset.execute().map((item2, index2) => {
      return `
        <div class='color-item' data-index="${index2}" data-color="${item2.color}">
          <div class='preview' title="${item2.color}" data-index="${index2}">
            <div class='color-view' style='background-color: ${item2.color};'></div>
          </div>
        </div>
      `;
    });
    return results;
  }
  executeColor(callback, isRefresh = true, isEmit = true) {
    var project2 = this.$selection.currentProject;
    if (project2) {
      callback && callback(project2);
      if (isRefresh)
        this.refresh();
      if (isEmit)
        this.emit("refreshColorAssets");
    } else {
      alert("Please select a project.");
    }
  }
  [CLICK("$colorList .preview")](e2) {
    const color2 = e2.$dt.$(".color-view").css("background-color");
    this.modifyColorPicker(color2);
  }
  modifyColorPicker(color2) {
    this.parent.trigger(this.props.onchange, this.props.key, color2, this.props.params);
  }
}
var ColorSingleEditor$1 = "";
class ColorSingleEditor extends EditorElement {
  initState() {
    return {
      params: this.props.params,
      color: this.props.color || "rgba(0, 0, 0, 1)"
    };
  }
  updateData(opt = {}) {
    this.setState(opt, false);
    this.modifyColor();
  }
  modifyColor() {
    this.parent.trigger(this.props.onchange, this.props.key, this.state.color, this.state.params);
  }
  changeColor(color2) {
    this.setState({ color: color2 });
  }
  setValue(color2) {
    this.changeColor(color2);
  }
  [BIND("$miniView")]() {
    return {
      style: {
        "background-color": this.state.color
      }
    };
  }
  template() {
    return `
            <div class='elf--color-single-editor'>
                <div class='preview' ref='$preview'>
                    <div class='mini-view'>
                        <div class='color-view' style="background-color: ${this.state.color}" ref='$miniView'></div>
                    </div>
                </div>
            </div>
        `;
  }
  [CLICK("$preview")](e2) {
    this.viewColorPicker();
  }
  viewColorPicker() {
    this.emit("showColorPickerPopup", {
      target: this,
      changeEvent: (color2) => {
        this.refs.$miniView.cssText(`background-color: ${color2}`);
        this.updateData({ color: color2 });
      },
      color: this.state.color
    });
  }
}
var ColorViewEditor$1 = "";
class ColorViewEditor extends EditorElement {
  initState() {
    const value = this.props.value || "rgba(0, 0, 0, 1)";
    const compact = isBoolean(this.props.compact) ? this.props.compact : this.props.compact === "true";
    const mini = isBoolean(this.props.mini) ? this.props.mini : this.props.mini === "true";
    return {
      label: this.props.label,
      value,
      compact,
      mini,
      color: Color.parse(value),
      colorFocus: false,
      opacityFocus: false
    };
  }
  updateData(opt = {}) {
    this.setState(opt);
    this.modifyColor();
  }
  updateEndData(opt = {}) {
    this.setState(opt);
    this.modifyEndColor();
  }
  getValue() {
    return this.state.value;
  }
  setValue(value) {
    this.changeColor(value);
  }
  modifyColor() {
    this.parent.trigger(this.props.onchange, this.props.key, this.state.value, this.props.params);
  }
  modifyEndColor() {
    this.parent.trigger(this.props.onchangeend, this.props.key, this.state.value, this.props.params);
  }
  changeColor(value) {
    this.setState({
      value,
      color: Color.parse(value)
    });
  }
  get alpha() {
    return this.state.color.a * 100;
  }
  get hexColor() {
    return Color.formatWithoutAlpha(this.state.color, "hex");
  }
  get fullColor() {
    return Color.format(this.state.color, this.state.color.type);
  }
  refresh() {
    this.refreshColorView();
    this.refs.$colorCode.val(this.state.value);
    this.refs.$opacityCode.val(this.alpha);
  }
  refreshColorView() {
    this.bindData("$miniView1");
    this.bindData("$miniView2");
  }
  template() {
    var { label, compact, mini } = this.state;
    var hasLabel = !!label ? "has-label" : "";
    var hasCompact = !!compact ? "compact" : "";
    var hasMini = !!mini ? "mini" : "";
    return `
            <div class='elf--color-view-editor ${hasLabel} ${hasCompact} ${hasMini}'>
                ${label ? `<label>${label}</label>` : ""}            
                <div class='color-code' ref="$container">
                    <div class='preview' ref='$preview'>
                        <div class='mini-view'>
                            <div class='color-view' ref='$miniView1'></div>
                            <div class='color-view' ref='$miniView2'></div>
                        </div>
                    </div>                
                    <div class="color-input">
                        <input type="text" ref='$colorCode' value='${this.state.value}' tabIndex="1" />
                    </div>
                    <div class="opacity-input">                    
                        <input type="number" ref='$opacityCode' value='${this.alpha}' tabIndex="2" max="100" min="0" step="0.1" />
                    </div>                    
                </div>
            </div>
        `;
  }
  [BIND("$el")]() {
    return {
      class: {
        "focused": this.state.colorFocus || this.state.opacityFocus
      }
    };
  }
  [BIND("$miniView1")]() {
    return {
      style: {
        "background-color": this.hexColor
      }
    };
  }
  [BIND("$miniView2")]() {
    return {
      style: {
        "background-color": this.fullColor
      }
    };
  }
  [BIND("$colorCode")]() {
    return {
      value: this.props.format ? this.hexColor : this.state.value
    };
  }
  [BIND("$opacityCode")]() {
    return {
      value: this.alpha
    };
  }
  [FOCUSIN("$colorCode")](e2) {
    this.setState({
      colorFocus: true
    });
    this.refs.$colorCode.select();
  }
  [FOCUSOUT("$colorCode")](e2) {
    this.setState({
      colorFocus: false
    });
  }
  [FOCUSIN("$opacityCode")](e2) {
    this.setState({
      opacityFocus: true
    });
    this.refs.$opacityCode.select();
  }
  [FOCUSOUT("$opacityCode")](e2) {
    this.setState({
      opacityFocus: false
    });
  }
  [CLICK("$preview")](e2) {
    this.viewColorPicker();
  }
  viewColorPicker() {
    this.emit("showColorPickerPopup", {
      target: this,
      changeEvent: (color2) => {
        this.updateData({ value: color2, color: Color.parse(color2) });
      },
      changeEndEvent: (color2) => {
        this.updateEndData({ value: color2, color: Color.parse(color2) });
      },
      color: this.state.value
    }, null, this.$el.rect());
  }
  [CLICK("$remove")](e2) {
    this.updateData({ value: "" });
  }
  [INPUT("$el .color-input input")](e2) {
    var color2 = e2.$dt.value;
    this.updateData({
      value: color2,
      color: Color.parse(color2)
    });
    this.refreshColorView();
  }
  [INPUT("$el .opacity-input input")](e2) {
    var opacity2 = +e2.$dt.value;
    opacity2 = Math.max(0, Math.min(100, opacity2));
    const color2 = Color.parse(this.state.value);
    color2.a = opacity2 / 100;
    const value = Color.format(color2, color2.type);
    this.updateData({
      value,
      color: color2
    });
    this.refreshColorView();
  }
}
var CSSPropertyEditor$1 = "";
class CSSPropertyEditor extends EditorElement {
  initState() {
    return {
      hideTitle: this.props["hide-title"] === "true",
      hideRefresh: this.props["hide-refresh"] === "true",
      properties: []
    };
  }
  updateData(opt) {
    this.setState(opt, false);
    this.modifyProperty();
  }
  modifyProperty() {
    this.parent.trigger(this.props.onchange, this.state.properties);
  }
  template() {
    const hideTitleClass = this.state.hideTitle ? "hide-title" : "";
    const hideRefreshClass = this.state.hideRefresh ? "hide-refresh" : "";
    return `
      <div class='elf--css-property-editor ${hideTitleClass} ${hideRefreshClass}'>
        <div class='title'>
          <label>${this.$i18n("css.property.editor.properties")}</label>
          <div class='tools'>
            ${this.makePropertySelect()}
            <button type="button" ref='$addProperty'>${obj.add}</button>
          </div>
        </div>
        <div class='input grid-1 css-property-list' ref='$property'></div>
      </div>
    `;
  }
  getPropertyDefaultValue(key) {
    switch (key) {
      case "animation-timing-function":
      case "box-shadow":
      case "text-shadow":
      case "color":
      case "background-image":
      case "background-color":
      case "text-fill-color":
      case "text-stroke-color":
      case "filter":
      case "backdrop-filter":
      case "var":
      case "transform":
      case "transform-origin":
      case "perspective-origin":
      case "playTime":
        return Length.string("");
      case "offset-distance":
        return Length.percent(0);
      case "rotate":
        return Length.deg(0);
      case "mix-blend-mode":
        return "normal";
      case "clip-path":
        return "";
      case "opacity":
        return 1;
      default:
        return 0;
    }
  }
  [CLICK("$addProperty")](e2) {
    var key = this.getRef("$propertySelect").value;
    var searchItem = this.state.properties.find((it) => {
      return it.key === key;
    });
    if (searchItem) {
      alert(`${key} is already added.`);
      return;
    }
    var value = this.getPropertyDefaultValue(key);
    var current = this.$selection.current;
    if (current) {
      value = current[key];
    }
    this.state.properties.push({ key, value });
    this.refresh();
    this.modifyProperty();
  }
  makeIndivisualPropertyColorEditor(property, index2) {
    var key = property.key.split("-").join("");
    return `
      <div class='property-editor'>
        <object refClass="ColorViewEditor" ref='$${key}${index2}' value="${property.value}" key="${property.key}" onChange="changeColorProperty" />
      </div>
    `;
  }
  makeCustomePropertyEditor(property, index2) {
    return `
      <div class='property-editor'>
        <${property.editor} 
          onchange="changeSelect"
          ref="$customProperty${index2}"
          key="${property.key}"
          value="${property.value}"
        />
      </div>
    `;
  }
  makeIndivisualPropertyEditor(property, index2) {
    if (property.key === "background-image") {
      return `
        <div class='property-editor'>
          <object refClass="BackgroundImageEditor" ref='$backgroundImage${index2}' key="${property.key}" hide-title="${this.state.hideTitle}" value="${property.value}" onChange="changeKeyValue" />
        </div>
      `;
    } else if (property.key === "filter") {
      return `
        <div class='property-editor'>
          <object refClass="FilterEditor" ref='$filter${index2}' key="${property.key}" value="${property.value}" onChange="changeKeyValue" />
        </div>
      `;
    } else if (property.key === "backdrop-filter") {
      return `
        <div class='property-editor'>
          <object refClass="FilterEditor" ref='$backdropFilter${index2}' key="${property.key}" value="${property.value}" onChange="changeKeyValue" />
        </div>
      `;
    } else if (property.key === "box-shadow") {
      return `
        <div class='property-editor'>
          <object refClass="BoxShadowEditor" ref='$boxshadow${index2}' value="${property.value}" hide-label="false" onChange="changeBoxShadowProperty" />
        </div>
      `;
    } else if (property.key === "text-shadow") {
      return `
        <div class='property-editor'>
          <object refClass="TextShadowEditor" ref='$textshadow${index2}' value="${property.value}" hide-label="false" onChange="changeTextShadowProperty" />
        </div>
      `;
    } else if (property.key === "var") {
      return `
        <div class='property-editor'>
          <object refClass="VarEditor" ref='$var${index2}' value="${property.value}" onChange="changeVar" />
        </div>
      `;
    } else if (property.key === "transform") {
      return `
        <div class='property-editor'>
          <object refClass="TransformEditor" ref='$transform${index2}' value="${property.value}" onChange="changeTransform" />
        </div>
      `;
    } else if (property.key === "transform-origin") {
      return `
        <div class='property-editor'>
          <object refClass="TransformOriginEditor" ref='$transformOrigin${index2}' value="${property.value}" onChange="changeTransformOrigin" />
        </div>
      `;
    } else if (property.key === "perspective-origin") {
      return `
        <div class='property-editor'>
          <object refClass="PerspectiveOriginEditor" ref='$perspectiveOrigin${index2}' value="${property.value}" onChange="changePerspectiveOrigin" />
        </div>
      `;
    } else if (property.key === "fill-rule") {
      return `
        <div class='property-editor'>
          <object refClass="SelectEditor"  
          ref='$fillRule${index2}' 
          key='fill-rule' 
          icon="true" 
          options=${variable$4(["nonzero", "evenodd"])}
          value="${property.value}"
          onchange="changeSelect" />
        </div>
      `;
    } else if (property.key === "stroke-linecap") {
      return `
        <div class='property-editor'>
          <object refClass="SelectEditor"  
          ref='$strokeLinecap${index2}' 
          key='stroke-linecap' 
          icon="true" 
          options=${variable$4(["butt", "round", "square"])}          
          value="${property.value}"
          onchange="changeSelect" />
        </div>
      `;
    } else if (property.key === "stroke-linejoin") {
      return `
        <div class='property-editor'>
          <object refClass="SelectEditor"  
          ref='$strokeLinejoin${index2}' 
          key='stroke-linejoin' 
          icon="true" 
          options=${variable$4(["miter", "arcs", "bevel", "miter-clip", "round"])}                    
          value="${property.value}"
          onchange="changeSelect" />
        </div>
      `;
    } else if (property.key === "mix-blend-mode") {
      return `
        <div class='property-editor'>
          <object refClass="BlendSelectEditor" 
          ref='$mixBlendMode${index2}' 
          key='mix-blend-mode' 
          icon="true" 
          value="${property.value}"
          onchange="changeSelect" />
        </div>
      `;
    } else if (property.key === "stroke-dasharray") {
      return `
        <object refClass="StrokeDashArrayEditor" 
          ref='$strokeDashArray${index2}' 
          key='stroke-dasharray'
          value='${property.value}' 
          onchange='changeSelect' 
        />
      `;
    } else if (property.key === "border-radius") {
      return `
        <object refClass="BorderRadiusEditor"
          ref='$borderRadius${index2}' 
          key='border-radius'
          value='${property.value}' 
          onchange='changeBorderRadius' 
        />
      `;
    } else if (property.key === "border") {
      return `
        <object refClass="BorderEditor"
          ref='$border${index2}' 
          key='border'
          value='${property.value}' 
          onchange='changeKeyValue' 
        />
      `;
    } else if (property.key === "clip-path") {
      return `
        <object refClass="ClipPathEditor"
          ref='$clipPath${index2}' 
          key='clip-path'
          value='${property.value}' 
          onchange='changeClipPath' 
        />
      `;
    } else if (property.key === "d") {
      return `
        <object refClass="PathDataEditor" ref='$pathData${index2}' key='d' value='${property.value}' onchange='changeSelect' />
      `;
    } else if (property.key === "points") {
      return `
        <object refClass="PolygonDataEditor" ref='$polygonData${index2}' key='points' value='${property.value}' onchange='changeSelect' />
      `;
    } else if (property.key === "playTime") {
      return `
        <object refClass="MediaProgressEditor" ref='$playTime${index2}'  key='playTime' value="${property.value}" onchange="changeSelect" />      
      `;
    }
    return `
      <div class='property-editor'>
        ???

      </div>
    `;
  }
  [SUBSCRIBE_SELF("changeKeyValue")](key, value) {
    this.modifyPropertyValue(key, value);
  }
  [SUBSCRIBE_SELF("changeBorderRadius")](value) {
    this.modifyPropertyValue("border-radius", value);
  }
  [SUBSCRIBE_SELF("changeClipPath")](value) {
    this.modifyPropertyValue("clip-path", value);
  }
  [SUBSCRIBE_SELF("changeColorProperty")](key, color2) {
    this.modifyPropertyValue(key, color2);
  }
  [SUBSCRIBE_SELF("changeBackgroundImageProperty")](key, backgroundImage2) {
    this.modifyPropertyValue(key, backgroundImage2);
  }
  [SUBSCRIBE_SELF("changeFilterProperty")](filter2) {
    this.modifyPropertyValue("filter", filter2);
  }
  [SUBSCRIBE_SELF("changeBackdropFilterProperty")](filter2) {
    this.modifyPropertyValue("backdrop-filter", filter2);
  }
  [SUBSCRIBE_SELF("changeBoxShadowProperty")](boxshadow) {
    this.modifyPropertyValue("box-shadow", boxshadow);
  }
  [SUBSCRIBE_SELF("changeTextShadowProperty")](textShadow2) {
    this.modifyPropertyValue("text-shadow", textShadow2);
  }
  [SUBSCRIBE_SELF("changeVar")](value) {
    this.modifyPropertyValue("var", value);
  }
  [SUBSCRIBE_SELF("changeTransform")](value) {
    this.modifyPropertyValue("transform", value);
  }
  [SUBSCRIBE_SELF("changeTransformOrigin")](value) {
    this.modifyPropertyValue("transform-origin", value);
  }
  [SUBSCRIBE_SELF("changePerspectiveOrigin")](value) {
    this.modifyPropertyValue("perspective-origin", value);
  }
  [SUBSCRIBE_SELF("changeSelect")](key, value) {
    this.modifyPropertyValue(key, value);
  }
  makePropertyEditor(property, index2) {
    if (property.editor) {
      return this.makeCustomePropertyEditor(property, index2);
    }
    switch (property.key) {
      case "animation-timing-function":
      case "box-shadow":
      case "text-shadow":
      case "background-image":
      case "filter":
      case "backdrop-filter":
      case "var":
      case "transform":
      case "transform-origin":
      case "perspective-origin":
      case "mix-blend-mode":
      case "border":
      case "border-radius":
      case "clip-path":
      case "fill-rule":
      case "stroke-linecap":
      case "stroke-linejoin":
      case "stroke-dasharray":
      case "d":
      case "points":
      case "offset-path":
      case "playTime":
        return this.makeIndivisualPropertyEditor(property, index2);
      case "color":
      case "background-color":
      case "text-fill-color":
      case "text-stroke-color":
      case "stroke":
      case "fill":
        return this.makeIndivisualPropertyColorEditor(property, index2);
      case "opacity":
      case "fill-opacity":
      case "stroke-dashoffset":
      case "offset-distance":
        let min = 0;
        let max = 1;
        let step2 = 0.01;
        return `
          <div class='property-editor'>
            <object refClass="NumberRangeEditor"  
              ref='$opacity${index2}' 
              key='${property.key}' 
              min="${min}"
              max="${max}"
              step="${step2}"
              value="${property.value || 1}"
              selected-unit='number'
              removable="true"
              onchange="changeRangeEditor" />
          </div>
        `;
      case "rotate":
        return `
          <div class='property-editor'>
            <object refClass="RangeEditor"  
              ref='rangeEditor${index2}' 
              key='${property.key}' 
              value='${property.value}'  
              min="-2000"
              max="2000"
              units="deg" 
              onChange="changeRangeEditor" />
          </div>
        `;
      case "left":
      case "margin-top":
      case "margin-bottom":
      case "margin-left":
      case "margin-right":
      case "padding-top":
      case "padding-bottom":
      case "padding-left":
      case "padding-right":
      case "font-size":
      case "width":
      case "height":
      case "perspective":
      case "offset-distance":
      case "text-stroke-width":
      default:
        return `
          <div class='property-editor'>
            <object refClass="RangeEditor"  ref='rangeEditor${index2}' key='${property.key}' value='${property.value}' max="1000" onChange="changeRangeEditor" />
          </div>
        `;
    }
  }
  [SUBSCRIBE_SELF("changeRangeEditor")](key, value) {
    this.modifyPropertyValue(key, value + "");
  }
  searchKey(key, callback) {
    this.state.properties.filter((it) => it.key === key).forEach(callback);
  }
  modifyPropertyValue(key, value) {
    this.searchKey(key, (it) => {
      it.value = value;
    });
    this.modifyProperty();
  }
  makePropertySelect() {
    return `
      <select class='property-select' ref='$propertySelect'>
        <optgroup label='Position'>
          <option value='x'>x</option>
          <option value='y'>y</option>        
        </optgroup>
        <optgroup label='Size'>
          <option value='width'>width</option>
          <option value='height'>height</option>
        </optgroup>      
        <optgroup label='Box Model'>
          <option value='margin-left'>margin-left</option>
          <option value='margin-right'>margin-right</option>
          <option value='margin-bottom'>margin-bottom</option>
          <option value='margin-top'>margin-top</option>
          <option value='padding-left'>padding-left</option>
          <option value='padding-right'>padding-right</option>
          <option value='padding-bottom'>padding-bottom</option>
          <option value='padding-top'>padding-top</option>       
        </optgroup>
        <optgroup label='Border'>
          <option value='border'>border</option>
          <option value='border-radius'>border-radius</option>
        </optgroup>        
        <optgroup label='Style'>
          <option value='background-color'>background-color</option>
          <option value='background-image'>background-image</option>
          <option value='box-shadow'>box-shadow</option>
          <option value='text-shadow'>text-shadow</option>
          <option value='filter'>filter</option>      
          <option value='backdrop-filter'>backdrop-filter</option>
          <option value='mix-blend-mode'>mix-blend-mode</option>
        </optgroup>            
        <optgroup label='Transform'>
          <option value='transform'>transform</option>
          <option value='transform-origin'>transform-origin</option>
          <option value='perspective'>perspective</option>
          <option value='perspective-origin'>perspective-origin</option>
        </optgroup>
        <optgroup label='Font'>
          <option value='font-size'>font-size</option>
          <option value='font-weight'>font-weight</option>          
        </optgroup>
        <optgroup label='Animation'>
          <option value='animation-timing-function'>timing-function</option>
        </optgroup>        
      </select>
    `;
  }
  [LOAD("$property")]() {
    return this.state.properties.map((it, index2) => {
      return `
        <div class='css-property-item'>
          <div class='title'>
            <label>${it.key}</label>
            <div class='tools'>
              <button type="button" class='remove' data-index="${index2}">${obj.remove2}</button>
            </div>
          </div>
          <div class='title-2'>
            <div class='tools'>
              <label><button type="button" class='refresh' data-index="${index2}">${obj.refresh}</button> Refresh</label>
            </div>
          </div>
          <div class='value-editor'>
            ${this.makePropertyEditor(it, index2)}
          </div>
        </div>
      `;
    });
  }
  [SUBSCRIBE("showCSSPropertyEditor")](properties = []) {
    this.setState({ properties });
    this.refresh();
  }
  [CLICK("$property .remove")](e2) {
    var index2 = +e2.$dt.attr("data-index");
    this.state.properties.splice(index2, 1);
    this.refresh();
    this.modifyProperty();
  }
  [CLICK("$property .refresh")](e2) {
    this.parent.trigger("refreshPropertyValue");
  }
}
var CubicBezierEditor$1 = "";
class CubicBezierEditor extends EditorElement {
  initState() {
    return {
      key: this.props.key,
      currentBezier: getPredefinedCubicBezier(this.props.value || "linear"),
      currentBezierIndex: 0,
      selectedColor: "#609de2",
      animatedColor: "#609de266",
      curveColor: "#609de2",
      baseLineColor: "rgba(117, 117, 117, 0.46)"
    };
  }
  template() {
    const linearCurve = curveToPath(this.state.currentBezier, 150, 150);
    const linearCurvePoint = curveToPointLine(this.state.currentBezier, 150, 150);
    const easeCurve = curveToPath("ease", 30, 30);
    const easeCurvePoint = curveToPointLine("ease", 30, 30);
    const easeInCurve = curveToPath("ease-in", 30, 30);
    const easeInCurvePoint = curveToPointLine("ease-in", 30, 30);
    const easeOutCurve = curveToPath("ease-out", 30, 30);
    const easeOutCurvePoint = curveToPointLine("ease-out", 30, 30);
    return `
            <div class='elf--cubic-bezier-editor'>
                <div class='predefined'>
                    <div class='left' ref='$left'>${obj.chevron_left}</div>
                    <div class='predefined-text' ref='$text'></div>
                    <div class='right' ref='$right'>${obj.chevron_right}</div>
                </div>
                <div class='animation'>
                    <canvas 
                        class='animation-canvas' 
                        ref='$animationCanvas' 
                        title='Click and Replay point animation' 
                        width='230px' 
                        height='20px'
                    ></canvas>
                </div>
                <div class='item-list' ref='$itemList' data-selected-value=''>
                    <div class='item' data-bezier='ease' title='ease'>
                        <svg class='item-canvas' width="30" height="30" viewBox="0 0 30 30">
                            <path d="${easeCurve}" stroke="white" stroke-width="1" fill='none' />
                            <path d="${easeCurvePoint}" stroke="gray" stroke-width="1" fill='none' />
                        </svg>
                    </div>
                    <div class='item' data-bezier='ease-in' title='ease-in'>
                        <svg class='item-canvas' width="30" height="30" viewBox="0 0 30 30">
                            <path d="${easeInCurve}" stroke="white" stroke-width="1" fill='none' />
                            <path d="${easeInCurvePoint}" stroke="gray" stroke-width="1" fill='none' /> 
                        </svg>
                    </div>
                    <div class='item' data-bezier='ease-out' title='ease-out'>
                        <svg class='item-canvas' width="30" height="30" viewBox="0 0 30 30">
                            <path d="${easeOutCurve}" stroke="white" stroke-width="1" fill='none' />
                            <path d="${easeOutCurvePoint}" stroke="gray" stroke-width="1" fill='none' />
                        </svg>
                    </div>
                </div>
                <div class='bezier'>
                    <svg class='bezier-canvas' width="150" height="150" viewBox="0 0 150 150" overflow="visible">
                        <path d="${linearCurve}" stroke="white" stroke-width="1" fill='none' ref='$bezierCanvas' />
                        <path d="${linearCurvePoint}" stroke="gray" stroke-width="1" fill='none' ref='$bezierCanvasPoint' />
                    </svg>                
                    <div class='control' ref='$control'>
                        <div class='pointer1' ref='$pointer1'></div>
                        <div class='pointer2' ref='$pointer2'></div>
                    </div>
                </div>
            </div>
        `;
  }
  [BIND("$bezierCanvas")]() {
    return {
      d: curveToPath(this.state.currentBezier, 150, 150)
    };
  }
  [BIND("$bezierCanvasPoint")]() {
    return {
      d: curveToPointLine(this.state.currentBezier, 150, 150)
    };
  }
  updateData(opt = {}) {
    this.setState(opt);
    this.modifyCubicBezier();
  }
  modifyCubicBezier() {
    this.parent.trigger(this.props.onchange, this.state.key, formatCubicBezier(this.state.currentBezier));
  }
  [CLICK("$left")]() {
    var { currentBezier, currentBezierIndex } = this.state;
    if (currentBezierIndex == 0) {
      currentBezierIndex = bezierList.length - 1;
    } else {
      --currentBezierIndex;
    }
    var currentBezier = bezierList[currentBezierIndex];
    this.updateData({ currentBezierIndex, currentBezier });
    this.refresh();
  }
  [CLICK("$right")]() {
    var { currentBezier, currentBezierIndex } = this.state;
    currentBezierIndex = ++currentBezierIndex % bezierList.length;
    currentBezier = bezierList[currentBezierIndex];
    this.updateData({ currentBezierIndex, currentBezier });
    this.refresh();
  }
  [CLICK("$text")]() {
    var currentBezier = [...bezierList[this.state.currentBezierIndex]];
    this.updateData({ currentBezier });
    this.refresh();
  }
  [CLICK("$itemList .item")](e2) {
    var bezierString = e2.$dt.attr("data-bezier");
    this.refs.$itemList.attr("data-selected-value", bezierString);
    var currentBezier = getPredefinedCubicBezier(bezierString);
    this.updateData({
      currentBezier
    });
    this.refresh();
  }
  refresh() {
    this.refreshEasingText();
    this.refreshBezierCanvas();
  }
  refreshBezierCanvas() {
    this.bindData("$bezierCanvas");
    this.bindData("$bezierCanvasPoint");
    this.refreshPointer();
    this.drawPoint();
  }
  refreshEasingText() {
    this.refs.$text.html(this.state.currentBezier[4] || "ease");
  }
  refreshPointer() {
    var currentBezier = getPredefinedCubicBezier(this.state.currentBezier);
    var width2 = this.refs.$control.width();
    var height2 = this.refs.$control.height();
    var left2 = currentBezier[0] * width2;
    var top2 = (1 - currentBezier[1]) * height2;
    this.refs.$pointer1.css({
      left: Length.px(left2).round(),
      top: Length.px(top2).round()
    });
    left2 = currentBezier[2] * width2;
    top2 = (1 - currentBezier[3]) * height2;
    this.refs.$pointer2.css({
      left: Length.px(left2).round(),
      top: Length.px(top2).round()
    });
  }
  drawPoint() {
    if (this.timer)
      clearTimeout(this.timer);
    if (this.animationTimer)
      clearTimeout(this.animationTimer);
    this.timer = setTimeout(() => {
      this.animationPoint();
    }, 100);
  }
  start(i) {
    var pos = this.animationCanvasData.func(i);
    var x2 = 10 + (this.animationCanvasData.width - 20) * pos.y;
    var y2 = 10;
    var context = this.animationCanvasData.context;
    context.beginPath();
    context.arc(x2, y2, 5, 0, 2 * Math.PI);
    context.fill();
    context.stroke();
    context.closePath();
    if (i >= 1) {
      return;
    }
    this.animationTimer = setTimeout(() => {
      this.start(i + 0.05);
    }, 50);
  }
  animationPoint() {
    const currentBezier = getPredefinedCubicBezier(this.state.currentBezier);
    var func2 = createBezierForPattern(formatCubicBezier(currentBezier));
    this.refs.$animationCanvas.clear();
    var width2 = this.refs.$animationCanvas.width();
    var height2 = this.refs.$animationCanvas.height();
    var context = this.refs.$animationCanvas.context();
    context.fillStyle = this.state.animatedColor;
    context.strokeStyle = this.state.selectedColor;
    context.lineWidth = 1;
    this.animationCanvasData = {
      func: func2,
      width: width2,
      height: height2,
      context
    };
    this.start(0);
  }
  setPosition(e2) {
    var width2 = this.refs.$control.width();
    var height2 = this.refs.$control.height();
    var minX = this.refs.$control.offset().left;
    var minY = this.refs.$control.offset().top;
    var p = e2;
    var x2 = p.x;
    if (0 > x2) {
      x2 = 0;
    } else if (p.x > document.body.clientWidth) {
      x2 = document.body.clientWidth;
    }
    x2 -= minX;
    if (x2 < 0) {
      x2 = 0;
    }
    if (width2 < x2) {
      x2 = width2;
    }
    var y2 = p.y;
    y2 -= minY;
    return {
      x: div(x2, width2),
      y: y2 == height2 ? 0 : div(height2 - y2, height2)
    };
  }
  [POINTERSTART("$pointer1") + MOVE("movePointer1") + END("drawPoint")](e2) {
    this.clientX = e2.clientX;
    this.clientY = e2.clientY;
  }
  movePointer1(dx, dy) {
    var pos = this.setPosition({
      x: this.clientX + dx,
      y: this.clientY + dy
    });
    this.state.currentBezier[0] = pos.x;
    this.state.currentBezier[1] = pos.y;
    this.refreshBezierCanvas();
    this.modifyCubicBezier();
  }
  [POINTERSTART("$pointer2") + MOVE("movePointer2") + END("drawPoint")](e2) {
    this.clientX = e2.clientX;
    this.clientY = e2.clientY;
  }
  movePointer2(dx, dy) {
    var pos = this.setPosition({
      x: this.clientX + dx,
      y: this.clientY + dy
    });
    this.state.currentBezier[2] = pos.x;
    this.state.currentBezier[3] = pos.y;
    this.refreshBezierCanvas();
    this.modifyCubicBezier();
  }
  [SUBSCRIBE("showCubicBezierEditor")](timingFunction) {
    var currentBezier = getPredefinedCubicBezier(timingFunction || this.state.currentBezier);
    this.setState({ currentBezier });
    this.refresh();
  }
}
var DirectionEditor$1 = "";
const typeList = [
  { key: "top", title: "Top" },
  { key: "right", title: "Right" },
  { key: "bottom", title: "Bottom" },
  { key: "left", title: "Left" }
];
class DirectionEditor extends EditorElement {
  initState() {
    var [count, top2, right2, bottom2, left2] = DirectionLength.parse(this.props.value);
    return {
      isAll: count === 1,
      all: top2.clone(),
      top: top2.clone(),
      right: right2.clone(),
      bottom: bottom2.clone(),
      left: left2.clone()
    };
  }
  template() {
    return `<div class='elf--direction-editor' ref='$body'></div>`;
  }
  [SUBSCRIBE("changeBorderRadius")](key, value) {
    if (key === "all") {
      typeList.forEach((it) => {
        this.state[it.key] = value.clone();
        this.children[`$${it.key}`].setValue(value.clone());
      });
    }
    this.updateData({
      [key]: value
    });
  }
  [LOAD("$body")]() {
    var selectedValue = this.state.isAll ? "all" : "partitial";
    var direction = this.state.all;
    var display = selectedValue === "all" ? "display:none" : "display:block";
    return `
      <div class="property-item direction-item">
        <div class="radius-selector" data-selected-value="${selectedValue}" ref="$selector">
          <button type="button" data-value="all">${obj.border_all}</button>
          <button type="button" data-value="partitial">
            ${obj.border_inner}
          </button>
        </div>
        <div class="radius-value">
          <object refClass="RangeEditor"  ref='$all' key='all' value="${direction}" onchange='changeBorderRadius' />
        </div>
      </div>
      <div
        class="property-item full direction-item"
        ref="$partitialSetting"
        style="${display}"
      >
        <div class="radius-setting-box">
          ${typeList.map((it) => {
      var value = this.state[it.key];
      return `
              <div>
                  <object refClass="RangeEditor"  ref='$${it.key}' label='${it.title}' key='${it.key}' value="${value}" onchange='changeBorderRadius' />
              </div>  
            `;
    }).join("")}
        </div>
      </div>
    `;
  }
  updateData(opt = {}) {
    this.setState(opt, false);
    var value = [];
    if (this.state.isAll) {
      value = [1, this.state.all, this.state.all, this.state.all, this.state.all];
    } else {
      value = [4, this.state.top, this.state.right, this.state.bottom, this.state.left];
    }
    this.parent.trigger(this.props.onchange, value);
  }
  [CLICK("$selector button")](e2) {
    var type = e2.$dt.attr("data-value");
    this.refs.$selector.attr("data-selected-value", type);
    if (type === "all") {
      this.refs.$partitialSetting.hide();
    } else {
      this.refs.$partitialSetting.show("grid");
    }
    this.updateData({
      isAll: type === "all"
    });
  }
}
var FilterEditor$1 = "";
var specList = {
  blur: BlurFilter.spec,
  grayscale: GrayscaleFilter.spec,
  "hue-rotate": HueRotateFilter.spec,
  invert: InvertFilter.spec,
  brightness: BrightnessFilter.spec,
  contrast: ContrastFilter.spec,
  "drop-shadow": DropshadowFilter.spec,
  opacity: OpacityFilter.spec,
  saturate: SaturateFilter.spec,
  sepia: SepiaFilter.spec,
  svg: URLSvgFilter.spec
};
class FilterEditor extends EditorElement {
  initialize() {
    super.initialize();
    this.notEventRedefine = true;
  }
  initState() {
    return {
      hideLabel: this.props.hideLabel === "true" ? true : false,
      filters: Filter.parseStyle(this.props.value)
    };
  }
  template() {
    return `
      <div class='elf--filter-editor filter-list'>
          <div class='filter-list' ref='$filterList'></div>
      </div>`;
  }
  [LOAD("$filterSelect")]() {
    var list2 = filter_list$2.map((it) => {
      return { title: it, value: it };
    });
    var svgFilterList = this.getSVGFilterList();
    var totalList = [];
    if (svgFilterList.length) {
      totalList = [
        ...list2,
        { title: "-------", value: "" },
        ...svgFilterList
      ];
    } else {
      totalList = [
        ...list2
      ];
    }
    return totalList.map((it) => {
      var { title: title2, value } = it;
      return `<option value='${value}'>${title2}</option>`;
    });
  }
  getSpec(filterType) {
    return specList[filterType];
  }
  makeDropShadowFilterTemplate(spec, filter2, index2) {
    return `
      <div class="filter-item">
        <div class="title drop-shadow">
          <label draggable="true"  data-index="${index2}">${iconUse$1("drag_indicator")}</label>
          <span class='sub-title'>${this.$i18n("filter.property.drop-shadow")}</span>
          <div class="filter-menu">
            <button type="button" class="del" data-index="${index2}">${iconUse$1("remove2")}</button>
          </div>
        </div>
        <div class="filter-ui-list">
          ${createComponentList(["ColorViewEditor", {
      ref: `$dropShadowColorView${index2}`,
      params: index2,
      compact: true,
      value: filter2.color,
      onchange: "changeDropShadowColor"
    }], ...["offsetX", "offsetY", "blurRadius"].map((key) => {
      return [
        "InputRangeEditor",
        {
          ref: `$${key}${index2}`,
          label: this.$i18n(`filter.property.drop-shadow.${key}`),
          key: index2,
          min: spec[key].min,
          max: spec[key].max,
          step: spec[key].step,
          params: key,
          value: filter2[key].value || spec[key].defaultValue,
          units: spec[key].units,
          onchange: "changeRangeEditor"
        }
      ];
    }))}
        </div>

      </div>
    `;
  }
  getSVGFilterList() {
    var current = this.$selection.current;
    var arr = [];
    if (current) {
      arr = current.svgfilters.map((it) => {
        return {
          title: `svg - #${it.id}`,
          value: it.id
        };
      });
    }
    return arr;
  }
  makeOneFilterEditor(index2, filter2, spec) {
    if (filter2.type === "svg") {
      var options2 = "";
      var current = this.$selection.current;
      if (current) {
        options2 = current.svgfilters.map((it) => {
          return { value: it.id };
        });
      }
      return createComponent("SelectEditor", {
        ref: `$select${index2}`,
        key: index2,
        label: "SVG Filter",
        value: filter2.value,
        options: ["", ...options2],
        onchange: "changeRangeEditor"
      });
    }
    return createComponent("InputRangeEditor", {
      ref: `$range${index2}_${filter2.type}`,
      label: this.$i18n("filter.property." + filter2.type),
      key: index2,
      min: spec.min,
      max: spec.max,
      value: filter2.value,
      units: spec.units,
      onchange: "changeRangeEditor"
    });
  }
  makeOneFilterTemplate(spec, filter2, index2) {
    return `
      <div class="filter-item" data-index="${index2}">
        <div class="title" >
          <label draggable="true" data-index="${index2}">${iconUse$1("drag_indicator")}</label>
          ${filter2.type != "svg" ? `
          <div class="filter-ui">
            ${this.makeOneFilterEditor(index2, filter2, spec)}
          </div>
        ` : `
          <div>
            <span class='svg-filter-edit' data-index="${index2}">${filter2.value}</span>
          </div>
        `}          
          <div class="filter-menu">
            <button type="button" class="del" data-index="${index2}">
              ${iconUse$1("remove2")}
            </button>
          </div>
        </div>
      </div>
    `;
  }
  makeFilterTemplate(filter2, index2) {
    if (filter2.type === "drop-shadow") {
      return this.makeDropShadowFilterTemplate(this.getSpec(filter2.type), filter2, index2);
    } else {
      return this.makeOneFilterTemplate(this.getSpec(filter2.type), filter2, index2);
    }
  }
  [LOAD("$filterList")]() {
    return this.state.filters.map((filter2, index2) => {
      return this.makeFilterTemplate(filter2, index2.toString());
    });
  }
  [DRAGSTART("$filterList .filter-item > .title > label")](e2) {
    this.startIndex = +e2.$dt.attr("data-index");
  }
  [DRAGOVER("$filterList .filter-item > .title > label") + PREVENT](e2) {
  }
  sortItem(arr, startIndex, targetIndex) {
    arr.splice(targetIndex + (startIndex < targetIndex ? -1 : 0), 0, ...arr.splice(startIndex, 1));
  }
  sortFilter(startIndex, targetIndex) {
    this.sortItem(this.state.filters, startIndex, targetIndex);
  }
  [DROP("$filterList .filter-item") + PREVENT](e2) {
    var targetIndex = +e2.$dt.attr("data-index");
    var current = this.$selection.current;
    if (!current)
      return;
    this.sortFilter(this.startIndex, targetIndex);
    this.refresh();
    this.modifyFilter();
  }
  modifyFilter() {
    var value = this.state.filters.join(" ");
    this.parent.trigger(this.props.onchange, this.props.key, value, this.props.params);
  }
  makeFilter(type, opt = {}) {
    return Filter.parse(__spreadProps(__spreadValues({}, opt), { type }));
  }
  [CLICK("$filterList .svg-filter-edit")](e2) {
    var _a, _b;
    var index2 = +e2.$dt.attr("data-index");
    var filter2 = this.state.filters[index2];
    var current = this.$selection.current;
    if (current) {
      var svgfilterIndex = current.getSVGFilterIndex((_b = (_a = filter2.value) == null ? void 0 : _a.value) == null ? void 0 : _b.replace("#", ""));
      this.trigger("openSVGFilterPopup", svgfilterIndex);
    }
  }
  [SUBSCRIBE("openSVGFilterPopup")](index2) {
    const current = this.$selection.current || { svgfilters: [] };
    const svgfilter = current.svgfilters[index2];
    this.emit("showSVGFilterPopup", {
      changeEvent: (params) => {
        var current2 = this.$selection.current;
        if (current2) {
          current2.setSVGFilterValue(params.index, {
            filters: params.filters
          });
          this.command("setAttributeForMulti", "change filter", this.$selection.pack("svgfilters", "filter"));
        }
      },
      index: index2,
      preview: false,
      filters: svgfilter.filters
    });
  }
  [SUBSCRIBE("add")](filterType) {
    if (filterType === "svg") {
      const index2 = this.$selection.current.createSVGFilter({
        filters: []
      });
      const filter2 = this.$selection.current.svgfilters[index2];
      this.state.filters.push(this.makeFilter(filterType, {
        value: filter2.id
      }));
      this.refresh();
      this.modifyFilter();
      this.trigger("openSVGFilterPopup", index2);
    } else {
      this.state.filters.push(this.makeFilter(filterType));
      this.refresh();
      this.modifyFilter();
    }
  }
  [CLICK("$add")]() {
    var filterType = this.refs.$filterSelect.value;
    this.trigger("add", filterType);
  }
  [CLICK("$filterList .filter-menu .del")](e2) {
    var index2 = +e2.$dt.attr("data-index");
    this.state.filters.splice(index2, 1);
    this.refresh();
    this.modifyFilter();
  }
  [SUBSCRIBE_SELF("changeDropShadowColor")](key, color2, params) {
    var index2 = +params;
    this.state.filters[index2].reset({
      color: color2
    });
    this.modifyFilter();
  }
  [SUBSCRIBE_SELF("changeRangeEditor")](key, value, params) {
    if (params) {
      this.state.filters[+key].reset({
        [params]: value
      });
    } else {
      this.state.filters[+key].reset({
        value
      });
    }
    this.modifyFilter();
  }
}
const font_list = [
  "",
  "Arial",
  "Arial Black",
  "Times New Roman",
  "Times",
  "Courier New",
  "Courier",
  "Verdana",
  "Georgia",
  "Palatino",
  "Garamond",
  "Bookman",
  "Tahoma",
  "Trebuchet MS",
  "Impact",
  "Comic Sans MS",
  "serif",
  "sans-serif",
  "monospace",
  "cursive",
  "fantasy",
  "system-ui"
];
class FontSelectEditor extends SelectEditor {
  getFontList() {
    return font_list.map((it) => {
      return { value: it };
    });
  }
  initState() {
    return __spreadProps(__spreadValues({}, super.initState()), {
      options: this.getFontList()
    });
  }
}
var GradientEditor$1 = "";
var radialTypeList = [
  "circle",
  "circle closest-side",
  "circle closest-corner",
  "circle farthest-side",
  "circle farthest-corner",
  "ellipse",
  "ellipse closest-side",
  "ellipse closest-corner",
  "ellipse farthest-side",
  "ellipse farthest-corner"
];
var imageTypeList = [
  "static-gradient",
  "linear-gradient",
  "repeating-linear-gradient",
  "radial-gradient",
  "repeating-radial-gradient",
  "conic-gradient",
  "repeating-conic-gradient",
  "image-resource"
];
var iconList = {
  "image-resource": iconUse$1("photo")
};
var hasRadialPosition = {
  "radial-gradient": true,
  "repeating-radial-gradient": true,
  "conic-gradient": true,
  "repeating-conic-gradient": true
};
var presetPosition = {
  top: ["50%", "0%"],
  "top left": ["0%", "0%"],
  "top right": ["100%", "0%"],
  left: ["0%", "50%"],
  right: ["100%", "50%"],
  bottom: ["50%", "100%"],
  "bottom left": ["0%", "100%"],
  "bottom right": ["100%", "100%"]
};
class GradientEditor extends EditorElement {
  initState() {
    return {
      index: +(this.props.index || 0),
      value: this.props.value,
      image: BackgroundImage.parseImage(this.props.value || "") || { type: "", colorsteps: [] }
    };
  }
  setValue(value) {
    this.setState({
      image: BackgroundImage.parseImage(value)
    }, false);
    this.refresh();
    this.parent.trigger("changeTabType", this.state.image.type);
  }
  template() {
    var { image: image2 } = this.state;
    image2 = image2 || {};
    var type = image2.type || "static-gradient";
    if (type === "url")
      type = "image-resource";
    return `
        <div class='elf--gradient-editor' data-selected-editor='${type}'>
            <div class='gradient-preview'>
              <div class='gradient-view' ref='$gradientView' title='${this.$i18n("gradient.editor.drag.message")}'></div>
              <div class='drag-pointer' ref='$dragPosition'></div>
              <div class='preset-position'>
                <div data-value='top' title='top'>${iconUse$1("chevron_right")}</div>
                <div data-value='right' title='right'>${iconUse$1("chevron_right")}</div>
                <div data-value='left' title='left'>${iconUse$1("chevron_right")}</div>
                <div data-value='bottom' title='bottom'>${iconUse$1("chevron_right")}</div>
                <div data-value='top left' title='top left'>${iconUse$1("chevron_right")}</div>
                <div data-value='top right' title='top right'>${iconUse$1("chevron_right")}</div>
                <div data-value='bottom left' title='bottom left'>${iconUse$1("chevron_right")}</div>
                <div data-value='bottom right' title='bottom right'>${iconUse$1("chevron_right")}</div>                
              </div>
              <div data-editor='image-loader'>
                <input type='file' accept="image/*" ref='$file' />
              </div>              
            </div>
            <div class="picker-tab">
              <div class="picker-tab-list" ref="$tab">
                ${imageTypeList.map((it) => {
      return `<span class='picker-tab-item ${it}' data-editor='${it}'><span class='icon'>${iconList[it] || ""}</span></span>`;
    }).join("")}
              </div>
            </div>
            <div class='gradient-steps' data-editor='gradient'>
                <div class="hue-container" ref="$back"></div>            
                <div class="hue" ref="$steps">
                    <div class='step-list' ref="$stepList" ></div>
                </div>
            </div>
            <div class='tools' data-editor='tools'>
                <label for='gradientConnected${this.id}'>Connected <input type='checkbox'  id='gradientConnected${this.id}' ref='$cut' checked /></label>
            </div>            
            <div class='tools' data-editor='tools'>
                ${createComponent("InputRangeEditor", {
      label: "Offset",
      ref: "$range",
      key: "length",
      onchange: "changeColorStepOffset"
    })}
            </div>
            <div class='sub-editor' ref='$subEditor'> 
              <div data-editor='angle'>
                ${createComponent("InputRangeEditor", {
      label: "Angle",
      ref: "$angle",
      units: "deg",
      min: -720,
      max: 720,
      key: "angle",
      onchange: "changeKeyValue"
    })}
              </div>
              <div data-editor='centerX'>
                <object refClass="RangeEditor" label='Center X' ref='$radialPositionX' calc="false" value="50%"  key='radialPositionX' onchange='changeKeyValue' />
              </div>                
              <div data-editor='centerY'>                      
                <object refClass="RangeEditor" label='Center Y' ref='$radialPositionY' calc="false" value="50%" key='radialPositionY' onchange='changeKeyValue' />
              </div>                
              <div data-editor='radialType'>              
                <object refClass="SelectEditor" label='Radial Type' ref='$radialType' value="" options="${variable$4(radialTypeList)}" key='radialType' onchange='changeKeyValue' />
              </div>

            </div>            
        </div>
      `;
  }
  [CHANGE("$file")](e2) {
    var project2 = this.$selection.currentProject;
    if (project2) {
      [...e2.target.files].forEach((item2) => {
        this.emit("updateImageAssetItem", item2, (local) => {
          this.trigger("setImageUrl", local);
        });
      });
    }
  }
  [CLICK("$el .preset-position [data-value]")](e2) {
    var type = e2.$dt.attr("data-value");
    if (presetPosition[type]) {
      this.state.image.radialPosition = clone$1(presetPosition[type]);
      this.refresh();
      this.updateData();
    }
  }
  [DOUBLECLICK("$gradientView") + PREVENT](e2) {
    this.state.image.radialPosition = ["50%", "50%"];
    this.refresh();
    this.updateData();
  }
  [POINTERSTART("$gradientView") + MOVE("moveDragPosition") + END("moveEndDragPosition")](e2) {
    var parent = this.refs.$dragPosition.parent();
    this.containerRect = parent.rect();
    this.startXY = e2.xy;
    this.$config.set("set.move.control.point", true);
  }
  moveEndDragPosition(dx, dy) {
    this.$config.set("set.move.control.point", false);
  }
  moveDragPosition(dx, dy) {
    var x2 = this.startXY.x + dx;
    var y2 = this.startXY.y + dy;
    if (this.containerRect.x > x2) {
      x2 = this.containerRect.x;
    } else if (this.containerRect.x + this.containerRect.width < x2) {
      x2 = this.containerRect.x + this.containerRect.width;
    }
    if (this.containerRect.y > y2) {
      y2 = this.containerRect.y;
    } else if (this.containerRect.y + this.containerRect.height < y2) {
      y2 = this.containerRect.y + this.containerRect.height;
    }
    var left2 = Length.percent((x2 - this.containerRect.x) / this.containerRect.width * 100);
    var top2 = Length.percent((y2 - this.containerRect.y) / this.containerRect.height * 100);
    this.state.image.radialPosition = [left2, top2];
    this.bindData("$dragPosition");
    this.bindData("$gradientView");
    this.children.$radialPositionX.setValue(left2);
    this.children.$radialPositionY.setValue(top2);
    this.updateData();
  }
  [CLICK("$tab .picker-tab-item")](e2) {
    var type = e2.$dt.attr("data-editor");
    this.$el.attr("data-selected-editor", type);
    this.parent.trigger("changeTabType", type);
    var url = type === "image-resource" ? this.state.image.url : this.state.url;
    this.state.image = BackgroundImage.changeImageType({
      type,
      url,
      colorsteps: this.state.image.colorsteps || [],
      angle: Length.parse(this.children.$angle.getValue()).value,
      radialType: this.children.$radialType.getValue(),
      radialPosition: [
        this.children.$radialPositionX.getValue(),
        this.children.$radialPositionY.getValue()
      ]
    });
    this.refresh();
    this.updateData();
    this.sendMessage();
  }
  sendMessage(type) {
    var type = this.$el.attr("data-selected-editor");
    if (type === "linear-gradient" || type === "repeating-linear-gradient") {
      this.emit("addStatusBarMessage", "");
    } else {
      this.emit("addStatusBarMessage", "Drag if you want to move center position");
    }
  }
  [SUBSCRIBE_SELF("changeKeyValue")](key, value) {
    if (key === "angle") {
      value = value.value;
    }
    this.state.image[key] = value;
    if (key === "radialPositionX" || key === "radialPositionY") {
      this.state.image["radialPosition"] = [
        this.state.image.radialPositionX || "50%",
        this.state.image.radialPositionY || "50%"
      ];
    }
    this.bindData("$gradientView");
    this.updateData();
  }
  [SUBSCRIBE("changeColorStepOffset")](key, value) {
    if (this.currentStep) {
      this.currentStep.percent = value.value;
      this.state.image.sortColorStep();
      this.refresh();
      this.updateData();
    }
  }
  [CLICK("$back")](e2) {
    var rect2 = this.refs.$stepList.rect();
    var minX = rect2.x;
    var maxX = rect2.right;
    var x2 = e2.xy.x;
    if (x2 < minX)
      x2 = minX;
    else if (x2 > maxX)
      x2 = maxX;
    var percent = (x2 - minX) / rect2.width * 100;
    this.state.image.insertColorStep(percent);
    this.state.image.sortColorStep();
    this.refresh();
    this.updateData();
  }
  [BIND("$el")]() {
    var type = this.state.image.type;
    if (type === "url") {
      type = "image-resource";
    }
    this.parent.trigger("changeTabType", type);
    return {
      "data-selected-editor": type
    };
  }
  [BIND("$stepList")]() {
    return {
      "data-selected-index": this.state.index.toString(),
      "style": {
        "background-image": this.getLinearGradient()
      }
    };
  }
  [BIND("$gradientView")]() {
    var type = this.state.image.type;
    var size2 = "auto";
    if (type === "url" || type === "image-resource") {
      size2 = "cover";
    }
    return {
      style: {
        "background-image": this.state.image.toString(),
        "background-size": size2,
        "background-repeat": "no-repeat"
      }
    };
  }
  [BIND("$dragPosition")]() {
    var left2 = "50%";
    var top2 = "50%";
    if (hasRadialPosition[this.state.image.type]) {
      var [left2, top2] = this.state.image.radialPosition;
    }
    return {
      style: {
        left: left2,
        top: top2
      }
    };
  }
  [LOAD("$stepList")]() {
    var colorsteps = this.state.image.colorsteps || [];
    return colorsteps.map((it, index2) => {
      var selected = this.$selection.isSelectedColorStep(it.id) ? "selected" : "";
      return `
      <div class='step ${selected}' data-id='${it.id}' data-cut='${it.cut}' style='left: ${it.toLength()};'>
        <div class='color-view' style="background-color: ${it.color}"></div>
        <div class='arrow' style="background-color: ${it.color}"></div>
      </div>`;
    });
  }
  [CLICK("$cut")]() {
    if (this.currentStep) {
      this.currentStep.cut = this.refs.$cut.checked();
      this.refresh();
      this.updateData();
    }
  }
  removeStep(id) {
    this.state.image.removeColorStep(id);
    this.refresh();
    this.updateData();
  }
  selectStep(id) {
    this.state.id = id;
    this.$selection.selectColorStep(id);
    if (this.state.image.colorsteps) {
      this.currentStep = this.state.image.colorsteps.find((it) => this.$selection.isSelectedColorStep(it.id));
      this.refs.$cut.checked(this.currentStep.cut);
      this.children.$range.setValue(Length.percent(this.currentStep.percent));
      this.parent.trigger("selectColorStep", this.currentStep.color);
    }
    this.refresh();
  }
  [POINTERSTART("$stepList .step") + MOVE()](e2) {
    var id = e2.$dt.attr("data-id");
    if (e2.altKey) {
      this.removeStep(id);
      return false;
    } else {
      this.selectStep(id);
      this.startXY = e2.xy;
      this.cachedStepListRect = this.refs.$stepList.rect();
    }
  }
  getStepListRect() {
    return this.cachedStepListRect;
  }
  move(dx, dy) {
    var rect2 = this.getStepListRect();
    var minX = rect2.x;
    var maxX = rect2.right;
    var x2 = this.startXY.x + dx;
    if (x2 < minX)
      x2 = minX;
    else if (x2 > maxX)
      x2 = maxX;
    var percent = (x2 - minX) / rect2.width * 100;
    this.currentStep.setValue(percent, rect2.width);
    this.children.$range.setValue(Length.percent(percent));
    this.state.image.sortColorStep();
    this.refresh();
    this.updateData();
  }
  refresh() {
    this.load();
  }
  getLinearGradient() {
    var { image: image2 } = this.state;
    return `linear-gradient(to right, ${Gradient.toColorString(image2.colorsteps)})`;
  }
  [SUBSCRIBE("setColorStepColor")](color2) {
    if (this.state.image.type === "static-gradient") {
      this.state.image.colorsteps[0].color = color2;
      this.refresh();
      this.updateData();
    } else {
      if (this.currentStep) {
        this.currentStep.color = color2;
        this.refresh();
        this.updateData();
      }
    }
  }
  [SUBSCRIBE("setImageUrl")](url) {
    if (this.state.image) {
      this.state.url = url;
      this.state.image.reset({ url });
      this.refresh();
      this.updateData();
    }
  }
  updateData(data = {}) {
    this.setState(data, false);
    this.parent.trigger(this.props.onchange, this.state.image.toString());
  }
}
var IconListViewEditor$1 = "";
class IconListViewEditor extends EditorElement {
  initState() {
    return {
      value: this.props.value
    };
  }
  template() {
    return `<div class='select-editor elf--list-view-editor' ref='$body'></div>`;
  }
  [BIND("$body")]() {
    return {
      "data-column": this.props.column || 1
    };
  }
  [LOAD("$body")]() {
    return Object.keys(obj).map((key) => {
      var html2 = obj[key];
      var selected = key === this.state.value ? "selected" : "";
      return `<div class='list-view-item ${selected}'  data-key='${key}'>${html2}</div>`;
    });
  }
  getValue() {
    return this.state.value;
  }
  setValue(value) {
    this.state.value = value;
    this.refresh();
  }
  [CLICK("$body .list-view-item")](e2) {
    var key = e2.$dt.attr("data-key");
    e2.$dt.onlyOneClass("selected");
    this.updateData({
      value: key
    });
  }
  updateData(data) {
    this.setState(data, false);
    this.parent.trigger(this.props.onchange, this.props.key, this.state.value, this.props.params);
  }
}
class InputArrayEditor extends EditorElement {
  initState() {
    var values = this.props.values.split(" ").map((it) => +it);
    return {
      values,
      column: this.props.column
    };
  }
  template() {
    return `<div class='small-editor input-array-editor' ref='$body' ></div>`;
  }
  [BIND("$body")]() {
    return {
      cssText: `
                display: grid;
                grid-template-columns: repeat(${this.state.column}, 1fr);
                grid-column-gap: 2px;
                grid-row-gap: 2px;
            `
    };
  }
  [LOAD("$body")]() {
    var { values } = this.state;
    return values.map((value, index2) => {
      return `
                <div class='number-editor'>
                    <input type="number" value="${value}" step="0.01" data-index="${index2}" />
                </div>
            `;
    });
  }
  updateData(data) {
    this.setState(data, false);
    this.parent.trigger(this.props.onchange, this.props.key, this.state.values, this.props.params);
  }
  [INPUT("$body input")](e2) {
    var $el = e2.$dt;
    var index2 = +$el.attr("data-index");
    var value = +$el.value;
    this.state.values[index2] = value;
    this.updateData();
  }
}
var InputRangeEditor$1 = "";
class InputRangeEditor extends EditorElement {
  initialize() {
    super.initialize();
    this.notEventRedefine = true;
  }
  initState() {
    var units = this.props.units || ["px", "em", "%", "auto"];
    var value = Length.parse(this.props.value || "0px");
    let label = this.props.label || "";
    if (obj[label]) {
      label = obj[label];
    }
    return {
      removable: this.props.removable,
      label,
      compact: this.props.compact,
      wide: this.props.wide,
      min: +this.props.min || 0,
      max: +this.props.max || 100,
      step: +this.props.step || 1,
      key: this.props.key,
      params: this.props.params || "",
      layout: this.props.layout || "",
      disabled: this.props.disabled,
      title: this.props.title || "",
      units,
      value
    };
  }
  template() {
    return `<div class='small-editor' ref='$body'></div>`;
  }
  [LOAD("$body")]() {
    var { min, max, step: step2, label, title: title2, compact, wide, removable, layout: layout2, disabled } = this.state;
    var value = +this.state.value.value.toString();
    if (isNaN(value)) {
      value = 0;
    }
    var layoutClass = layout2;
    var realValue = (+value).toString();
    const units = this.state.units;
    return `
        <div 
            ref="$range",
            class="${OBJECT_TO_CLASS$1({
      "elf--input-range-editor": true,
      "has-label": !!label,
      "compact": !!compact,
      "wide": !!wide,
      "is-removable": removable,
      "disabled": disabled,
      [layoutClass]: true
    })}"
        >
            ${label ? `<label title="${title2}">${label}</label>` : ""}
            <div class='range--editor-type' data-type='range'>
                <div class='area'>
                    <input type='number' class='property-number' ref='$propertyNumber' value="${realValue}" min="${min}" max="${max}" step="${step2}" tabIndex="1" />
                    
                    ${units.length === 1 ? `<span class='unit'>${units[0]}</span>` : createComponent("SelectEditor", {
      ref: "$unit",
      key: "unit",
      compact: true,
      value: this.state.selectedUnit || this.state.value.unit,
      options: this.state.units,
      onchange: "changeUnit"
    })}
                    
                    
                </div>
            </div>
            <button type='button' class='remove' ref='$remove' title='Remove'>${obj.remove}</button>
        </div>
    `;
  }
  getValue() {
    return this.state.value.clone();
  }
  setValue(value) {
    var _a;
    this.setState({
      value: Length.parse(value)
    }, false);
    this.refs.$propertyNumber.val(this.state.value.value);
    (_a = this.children.$unit) == null ? void 0 : _a.setValue(this.state.value.unit);
  }
  disabled() {
    this.setState({
      disabled: true
    });
  }
  enabled() {
    this.setState({
      disabled: false
    });
  }
  [CLICK("$remove")](e2) {
    this.updateData({
      value: ""
    });
  }
  getUnit() {
    var _a;
    return ((_a = this.children.$unit) == null ? void 0 : _a.getValue()) || this.state.value.unit;
  }
  updateData(data) {
    this.setState(data, false);
    this.parent.trigger(this.props.onchange, this.props.key, this.state.value, this.props.params);
  }
  initValue() {
    if (this.state.value == "") {
      this.state.value = new Length(0, this.getUnit());
    }
  }
  [INPUT("$body .property-number")](e2) {
    var value = +e2.$dt.value;
    this.initValue();
    this.updateData({
      value: new Length(value, this.getUnit())
    });
  }
  [SUBSCRIBE_SELF("changeUnit")](key, value) {
    this.initValue();
    this.updateData({
      value: this.state.value.toUnit(value)
    });
  }
  [FOCUSIN("$body input[type=number]")](e2) {
    this.refs.$range.addClass("focused");
    e2.$dt.select();
  }
  [FOCUSOUT("$body input[type=number]")](e2) {
    this.refs.$range.removeClass("focused");
  }
  [POINTERSTART("$body .elf--input-range-editor label") + MOVE("moveDrag") + END("moveDragEnd")](e2) {
    this.refs.$range.addClass("drag");
    this.initNumberValue = +this.refs.$propertyNumber.value;
    this.initUnit = this.state.value.unit;
    this.initUnits = this.state.units;
    this.refs.$propertyNumber.focus();
    this.refs.$propertyNumber.select();
  }
  moveDrag(dx, dy) {
    let newValue = Math.floor(round$1(this.initNumberValue + dx * this.state.step, 100));
    newValue = Math.min(this.state.max, Math.max(this.state.min, newValue));
    this.updateData({
      value: new Length(newValue, this.getUnit())
    });
    this.refs.$propertyNumber.val(this.state.value.value);
  }
  moveDragEnd() {
    this.refs.$range.removeClass("drag");
  }
}
var RangeEditor$1 = "";
class RangeEditor extends EditorElement {
  initialize() {
    super.initialize();
    this.notEventRedefine = true;
  }
  initState() {
    var units = this.props.units || ["px", "em", "%"];
    var value = Length.parse(this.props.value || 0);
    return {
      removable: this.props.removable === "true",
      calc: this.props.calc === "true" ? true : false,
      compact: this.props.compact === "true" ? true : false,
      label: this.props.label || "",
      min: +this.props.min || 0,
      max: +this.props.max || 100,
      step: +this.props.step || 1,
      key: this.props.key,
      params: this.props.params || "",
      layout: this.props.layout || "",
      units,
      value
    };
  }
  template() {
    return `<div class='small-editor' ref='$body'></div>`;
  }
  [LOAD("$body")]() {
    var { min, max, step: step2, label, removable, layout: layout2, compact } = this.state;
    var value = +this.state.value.value.toString();
    if (isNaN(value)) {
      value = 0;
    }
    var layoutClass = layout2;
    var realValue = (+value).toString();
    if (this.state.units === "%") {
      throw new Error("%");
    }
    var units = this.state.units.map((it) => {
      let description = it;
      if (description === "number") {
        description = "";
      }
      return { value: it, text: description };
    });
    return `
        <div 
            ref="$range"
            class="${OBJECT_TO_CLASS$1({
      "elf--range--editor": true,
      "has-label": !!label,
      "compact": !!compact,
      "is-removable": removable,
      [layoutClass]: true
    })}"
        >
            ${label ? `<label title="${label}">${label}</label>` : ""}
            <div class='range--editor-type' data-type='range'>
                <input type='range' ref='$property' value="${realValue}" min="${min}" max="${max}" step="${step2}" /> 
                <div class='area' ref='$rangeArea'>
                    <input type='number' ref='$propertyNumber' value="${realValue}" min="${min}" max="${max}" step="${step2}" tabIndex="1" />
                    ${createComponent("SelectEditor", {
      ref: "$unit",
      key: "unit",
      value: this.state.value.unit,
      options: units,
      onchange: "changeUnit"
    })}
                </div>
            </div>
            <button type='button' class='remove thin' ref='$remove' title='Remove'>${obj.remove}</button>
        </div>
    `;
  }
  getValue() {
    return this.state.value.clone();
  }
  setValue(value) {
    this.setState({
      value: Length.parse(value)
    });
  }
  [FOCUS('$body input[type="number"]')](e2) {
    this.refs.$rangeArea.addClass("focused");
  }
  [BLUR('$body input[type="number"]')](e2) {
    this.refs.$rangeArea.removeClass("focused");
  }
  updateData(data) {
    this.setState(data, false);
    this.parent.trigger(this.props.onchange, this.props.key, this.state.value, this.props.params);
  }
  initValue() {
    if (this.state.value == "") {
      this.state.value = new Length(0, this.children.$unit.getValue());
    }
  }
  [INPUT('$body input[type="number"]')](e2) {
    var value = +this.refs.$propertyNumber.value;
    this.getRef("$property").val(value);
    this.initValue();
    this.updateData({
      value: new Length(value, this.children.$unit.getValue())
    });
  }
  [INPUT('$body input[type="range"]')](e2) {
    this.trigger("changeRangeValue");
  }
  [POINTERSTART('$body input[type="range"]') + END()]() {
  }
  end() {
    this.trigger("changeRangeValue");
  }
  [SUBSCRIBE_SELF("changeRangeValue")]() {
    var value = +this.getRef("$property").value;
    this.refs.$propertyNumber.val(value);
    this.initValue();
    this.updateData({
      value: new Length(value, this.children.$unit.getValue())
    });
  }
  [SUBSCRIBE_SELF("changeUnit")](key, value) {
    this.initValue();
    this.updateData({
      value: this.state.value.toUnit(value)
    });
  }
}
class IterationCountEditor extends RangeEditor {
  initState() {
    var value = this.props.value;
    if (value === "infinite") {
      value = new Length(0, "infinite");
    } else {
      value = Length.number(value);
    }
    var units = this.props.units || ["px", "em", "%"];
    return __spreadValues(__spreadValues({}, super.initState()), {
      key: this.props.key,
      params: this.props.params || "",
      units,
      value
    });
  }
}
var MediaProgressEditor$1 = "";
class MediaProgressEditor extends EditorElement {
  initState() {
    const [start2, end2, duration] = (this.props.value || "").split(":");
    return {
      start: +(start2 || 0),
      end: +(end2 || 1),
      duration: +(duration || 1)
    };
  }
  refresh() {
    this.load();
    this.children.$s.setValue(this.state.start * this.state.duration);
    this.children.$e.setValue(this.state.end * this.state.duration);
    this.children.$s.setMax(this.state.duration);
    this.children.$e.setMax(this.state.duration);
  }
  template() {
    const { start: start2, end: end2, duration } = this.state;
    return `
            <div class='elf--media-progress-editor'>
                <div class='drag-area'>
                    <div class='progress-bar' ref='$progress'></div>
                    <div class='bar' ref='$bar'></div>                
                    <div class='drag-item start' ref='$start'></div>
                    <div class='drag-item end' ref='$end'></div>
                </div>
                <div class='item'>
                    ${createComponent("NumberRangeEditor", {
      ref: "$s",
      label: "Start",
      key: "start",
      min: 0,
      max: duration,
      step: 1e-3,
      value: start2 * duration,
      onchange: "changeValue"
    })}
                </div>
                <div class='item'>
                    ${createComponent("NumberRangeEditor", {
      ref: "$e",
      label: "End",
      key: "end",
      min: 0,
      max: duration,
      step: 1e-3,
      value: end2 * duration,
      onchange: "changeValue"
    })}
                </div>                
            </div>
        `;
  }
  [SUBSCRIBE_SELF("changeValue")](key, value) {
    this.updateData({
      [key]: value / this.state.duration
    }, true);
  }
  [POINTERSTART("$start") + MOVE("moveStart")](e2) {
    this.rect = this.refs.$progress.rect();
    this.pos = Length.parse(this.refs.$start.css("left")).toPx(this.rect.width);
    this.max = Length.parse(this.refs.$end.css("left")).toPx(this.rect.width);
  }
  moveStart(dx, dy) {
    var realPos = Math.min(this.max.value, Math.max(0, this.pos.value + dx));
    this.state.start = realPos / this.rect.width;
    this.children.$s.setValue(this.state.start * this.state.duration);
    this.refresh();
    this.updateData();
  }
  [BIND("$start")]() {
    return {
      "data-info": this.state.start,
      style: {
        left: Length.percent((this.state.start || 0) * 100)
      }
    };
  }
  [POINTERSTART("$end") + MOVE("moveStartForEnd")](e2) {
    this.rect = this.refs.$progress.rect();
    this.pos = Length.parse(this.refs.$end.css("left")).toPx(this.rect.width);
    this.min = Length.parse(this.refs.$start.css("left")).toPx(this.rect.width);
    this.max = this.rect.width;
  }
  moveStartForEnd(dx, dy) {
    var realPos = Math.max(this.min.value, Math.min(this.max.value, this.pos.value + dx));
    this.state.end = realPos / this.rect.width;
    this.children.$e.setValue(this.state.end * this.state.duration);
    this.refresh();
    this.updateData();
  }
  [BIND("$end")]() {
    return {
      "data-info": this.state.end,
      style: {
        left: Length.percent((this.state.end || 1) * 100)
      }
    };
  }
  [BIND("$bar")]() {
    const start2 = this.state.start || 0;
    const end2 = this.state.end || 1;
    return {
      style: {
        left: Length.percent(start2 * 100),
        width: Length.percent((end2 - start2) * 100)
      }
    };
  }
  getValue() {
    const { start: start2, end: end2, duration } = this.state;
    return `${start2}:${end2}:${duration}`;
  }
  setValue(value) {
    const [start2, end2, duration] = value.split(":");
    this.setState({
      start: Number(start2),
      end: Number(end2),
      duration: Number(duration)
    });
  }
  updateData(data = {}, isRefresh = false) {
    this.setState(data, isRefresh);
    this.parent.trigger(this.props.onchange, this.props.key, this.getValue(), this.props.params);
  }
}
var NumberInputEditor$1 = "";
class NumberInputEditor extends EditorElement {
  initState() {
    var value = +this.props.value;
    let label = this.props.label || "";
    if (obj[label]) {
      label = obj[label];
    }
    const compact = isBoolean(this.props.compact) ? this.props.compact : this.props.compact === "true";
    const wide = isBoolean(this.props.wide) ? this.props.wide : this.props.wide === "true";
    const mini = isBoolean(this.props.mini) ? this.props.mini : this.props.mini === "true";
    const trigger = this.props.trigger || "input";
    return {
      label,
      compact,
      wide,
      mini,
      trigger,
      min: +this.props.min || 0,
      max: +this.props.max || 100,
      step: +this.props.step || 1,
      key: this.props.key,
      params: this.props.params || "",
      layout: this.props.layout || "",
      value
    };
  }
  template() {
    return `<div class='small-editor' ref='$body'></div>`;
  }
  [LOAD("$body")]() {
    var { min, max, step: step2, label, type, layout: layout2, mini, compact, wide, disabled, removable } = this.state;
    var value = this.state.value;
    if (isNaN(value)) {
      value = 0;
    }
    var layoutClass = layout2;
    var realValue = (+value).toString();
    return `
        <div 
            class="${OBJECT_TO_CLASS$1({
      "elf--number-input-editor": true,
      "has-label": !!label,
      "compact": !!compact,
      "wide": !!wide,
      "mini": !!mini,
      "is-removable": removable,
      "disabled": disabled,
      [layoutClass]: true
    })}"
            ref="$range"
            data-selected-type='${type}'>
            ${label ? `<label>${label}</label>` : ""}
            <div class='range--editor-type' data-type='range'>
                <div class='area'>
                    <input type='number' ref='$propertyNumber' value="${realValue}" min="${min}" max="${max}" step="${step2}" />
                </div>
            </div>
        </div>
    `;
  }
  getValue() {
    return this.state.value || 0;
  }
  setValue(value) {
    this.setState({
      value
    }, false);
    this.refs.$propertyNumber.val(this.state.value);
  }
  updateData(data) {
    this.setState(data, false);
    this.parent.trigger(this.props.onchange, this.props.key, this.state.value, this.props.params);
  }
  [FOCUSIN("$body input[type=number]")](e2) {
    this.refs.$range.addClass("focused");
    e2.$dt.select();
  }
  [FOCUSOUT("$body input[type=number]")](e2) {
    this.refs.$range.removeClass("focused");
  }
  updateValue(e2) {
    var value = +e2.$dt.value;
    this.updateData({
      value
    });
  }
  isTriggerInput() {
    return this.state.trigger === "input";
  }
  isTriggerEnter() {
    return this.state.trigger === "enter";
  }
  [INPUT("$body input[type=number]") + IF("isTriggerInput")](e2) {
    this.updateValue(e2);
  }
  [KEYUP("$body input[type=number]") + IF("isTriggerEnter") + ENTER](e2) {
    this.updateValue(e2);
    e2.$dt.select();
  }
  [POINTERSTART("$body label") + MOVE("moveDrag") + END("moveDragEnd")](e2) {
    this.refs.$range.addClass("drag");
    this.initValue = +this.refs.$propertyNumber.value;
  }
  moveDrag(dx, dy) {
    let newValue = round$1(this.initValue + dx * this.state.step, 1 / this.state.step);
    newValue = Math.min(this.state.max, Math.max(this.state.min, newValue));
    this.updateData({
      value: newValue
    });
    this.refs.$propertyNumber.val(this.state.value);
  }
  moveDragEnd() {
    this.refs.$range.removeClass("drag");
  }
}
var NumberRangeEditor$1 = "";
class NumberRangeEditor extends EditorElement {
  initialize() {
    super.initialize();
    this.notEventRedefine = true;
  }
  initState() {
    var value = Length.parse(this.props.value || Length.number(0));
    value = value.toUnit("number");
    return {
      removable: this.props.removable === "true",
      compact: this.props.compact === "true",
      wide: this.props.wide === "true",
      clamp: this.props.clamp === "true",
      label: this.props.label || "",
      min: +this.props.min || 0,
      max: +this.props.max || 100,
      step: +this.props.step || 1,
      key: this.props.key,
      params: this.props.params || "",
      layout: this.props.layout || "",
      value
    };
  }
  template() {
    return `<div class='small-editor' ref='$body'></div>`;
  }
  [LOAD("$body")]() {
    var { min, max, step: step2, label, removable, layout: layout2, compact, wide, disabled } = this.state;
    var value = +this.state.value.value.toString();
    if (isNaN(value)) {
      value = 0;
    }
    var layoutClass = layout2;
    var realValue = (+value).toString();
    return `
        <div 
            class="${OBJECT_TO_CLASS$1({
      "elf--number-range-editor": true,
      "has-label": !!label,
      "compact": !!compact,
      "wide": !!wide,
      "is-removable": removable,
      "disabled": disabled,
      [layoutClass]: true
    })}"
        >
            ${label ? `<label title="${label}">${label}</label>` : ""}
            <div class='range--editor-type' data-type='range'>
                <div class='area'>
                    <div>
                        <input type='range' ref='$property' value="${realValue}" min="${min}" max="${max}" step="${step2}" />
                    </div>
                    <div>
                        <input type='number' ref='$propertyNumber' value="${realValue}" min="${min}" max="${max}" step="${step2}" tabIndex="1" />
                    </div>
                </div>
            </div>
            <button type='button' class='remove' ref='$remove' title='Remove'>${obj.remove}</button>
        </div>
    `;
  }
  setMin(value) {
    this.setState({
      min: Length.parse(value)
    });
  }
  setMax(value) {
    this.setState({
      max: Length.parse(value)
    });
  }
  getValue() {
    if (this.state.clamp) {
      return this.state.value.clamp(this.state.min, this.state.max);
    }
    return this.state.value;
  }
  setValue(value) {
    console.log(value);
    this.setState({
      value: Length.parse(value)
    });
  }
  [FOCUS('$body input[type="number"]')](e2) {
    this.refs.$propertyNumber.addClass("focused");
  }
  [BLUR('$body input[type="number"]')](e2) {
    this.refs.$propertyNumber.removeClass("focused");
  }
  [CLICK("$remove")](e2) {
    this.updateData({
      value: ""
    });
  }
  updateData(data) {
    this.setState(data, false);
    this.parent.trigger(this.props.onchange, this.props.key, this.getValue(), this.props.params);
  }
  [INPUT('$body input[type="number"]')](e2) {
    var value = +this.refs.$propertyNumber.value;
    this.getRef("$property").val(value);
    this.updateData({
      value: this.state.value.set(value)
    });
  }
  [INPUT('$body input[type="range"]')]() {
    this.trigger("changeRangeValue");
  }
  [POINTERSTART('$body input[type="range"]') + END()]() {
  }
  end() {
    this.trigger("changeRangeValue");
  }
  [SUBSCRIBE_SELF("changeRangeValue")]() {
    var value = +this.getRef("$property").value;
    this.getRef("$propertyNumber").val(value);
    if (this.state.value === "") {
      this.state.value = Length.number(0);
    }
    this.updateData({
      value: this.state.value.set(value)
    });
  }
}
var PathDataEditor$1 = "";
class PathDataEditor extends EditorElement {
  initState() {
    var parser2 = new PathParser(this.props.value || "");
    return {
      parser: parser2
    };
  }
  makeSegments() {
    return this.refs.$data.$$(".segment").map(($segment) => {
      var $command = $segment.$(".command");
      var command = $command.attr("data-command");
      if (command === "Z" && $command.attr("data-toggle") === "false") {
        return null;
      }
      var values = $segment.$$(".values input[type=number]").map((it) => {
        return +it.value;
      });
      return {
        command,
        values
      };
    }).filter((it) => it);
  }
  updateData() {
    var segments2 = this.makeSegments();
    this.state.parser.resetSegments(segments2);
    this.modifyPathData();
  }
  modifyPathData() {
    this.parent.trigger(this.props.onchange, this.props.key, this.getValue(), this.props.params);
  }
  setValue(value) {
    this.setState({
      parser: new PathParser(value)
    });
  }
  getValue() {
    return this.state.parser.joinPath();
  }
  template() {
    return `
            <div class='elf--path-data-editor'>
                <div class='data' ref='$data'></div>
            </div>
        `;
  }
  [LOAD("$data")]() {
    var segments2 = [];
    this.state.parser.segments.forEach((it, index2) => {
      var s = __spreadValues({}, it);
      segments2.push(s);
      var next = this.state.parser.segments[index2 + 1];
      if (next && next.command === "M") {
        if (s.command !== "Z") {
          segments2.push({ command: "Z", toggle: false, values: [] });
        } else {
          s.toggle = true;
        }
      }
    });
    var last2 = this.state.parser.segments[this.state.parser.segments.length - 1];
    if (last2 && last2.command !== "Z") {
      segments2.push({ command: "Z", toggle: false, values: [] });
    }
    var arr = segments2.map((it) => {
      var cls = it.command === "M" ? "m" : "";
      return `
                <div class='segment ${cls}'>
                    <div class='command' data-command='${it.command}' data-toggle="${it.toggle}" title='Toggle'>${it.command}</div>
                    <div class='values'>
                        ${it.values.map((v) => {
        return `<input type="number" value="${v}" />`;
      }).join("")}

                        ${it.command === "Z" ? it.toggle === false ? "opened" : "closed" : ""}
                    </div>
                </div>
            `;
    });
    arr.unshift(`
            <div class='segment-empty'>
                <div class='command'></div>
                <div class='values'>
                    <span>X</span>
                    <span>Y</span>
                </div>
            </div>
        `);
    return arr;
  }
  [INPUT("$data input[type=number]") + DEBOUNCE(300)](e2) {
    this.updateData();
  }
  [CLICK("$data .command[data-toggle]")](e2) {
    var [command, toggle] = e2.$dt.attrs("data-command", "data-toggle");
    if (command === "Z") {
      if (toggle !== "false") {
        toggle = "false";
      } else {
        toggle = "true";
      }
      e2.$dt.attr("data-toggle", toggle);
      this.updateData();
    }
  }
}
var PolygonDataEditor$1 = "";
class PolygonDataEditor extends EditorElement {
  initState() {
    var parser2 = new PolygonParser(this.props.value || "");
    return {
      parser: parser2
    };
  }
  makeSegments() {
    return this.refs.$data.$$(".segment").map(($segment) => {
      var x2 = +$segment.$('[data-key="x"]').value;
      var y2 = +$segment.$('[data-key="y"]').value;
      return { x: x2, y: y2 };
    });
  }
  updateData() {
    var segments2 = this.makeSegments();
    this.state.parser.resetSegments(segments2);
    this.modifyPolygonData();
  }
  modifyPolygonData() {
    this.parent.trigger(this.props.onchange, this.props.key, this.getValue(), this.props.params);
  }
  setValue(value) {
    this.setState({
      parser: new PolygonParser(value || "")
    });
  }
  getValue() {
    return this.state.parser.joinPoints();
  }
  template() {
    return `
            <div class='elf--polygon-data-editor'>
                <div class='data' ref='$data'></div>
            </div>
        `;
  }
  [LOAD("$data")]() {
    return this.state.parser.segments.map((it) => {
      return `
                <div class='segment'>
                    <div class='values'>
                        <label>X <input type="number" data-key="x" value="${it.x}" /></label>
                        <label>Y <input type="number" data-key="y" value="${it.y}" /></label>
                    </div>
                </div>
            `;
    });
  }
  [INPUT("$data input[type=number]") + DEBOUNCE(300)](e2) {
    this.updateData();
  }
}
var SelectIconEditor$1 = "";
class SelectIconEditor extends EditorElement {
  initialize() {
    super.initialize();
    this.notEventRedefine = true;
  }
  initState() {
    var splitChar = this.props.split || ",";
    var options2 = Array.isArray(this.props.options) ? this.props.options.map((it) => {
      if (isString(it)) {
        return { value: it, text: it };
      }
      return it;
    }) : (this.props.options || "").split(splitChar).map((it) => it.trim()).map((it) => {
      const [value2, text2] = it.split(":");
      return { value: value2, text: text2 };
    });
    var icons = this.props.icons || [];
    var colors2 = this.props.colors || [];
    var value = this.props.value || "";
    return {
      label: this.props.label || "",
      compact: this.props.compact === "true",
      options: options2,
      icons,
      colors: colors2,
      value
    };
  }
  template() {
    var { label, compact } = this.state;
    var hasLabel = !!label ? "has-label" : "";
    var hasCompact = !!compact ? "compact" : "";
    return `
            <div class='elf--select-icon-editor ${hasLabel}'>
                ${label ? `<label title="${label}">${label}</label>` : ""}
                <div class='items ${hasCompact}' ref='$options'></div>
            </div>
        `;
  }
  [CLICK("$close")]() {
    this.updateData({
      value: ""
    });
    this.refresh();
  }
  getValue() {
    return this.state.value || "";
  }
  setValue(value) {
    this.setState({
      value
    });
  }
  [LOAD("$options") + DOMDIFF]() {
    return this.state.options.map((it, index2) => {
      var value = it.value;
      var label = it.text;
      var title2 = it.text;
      var iconClass = "";
      var isSelected = value === this.state.value;
      var selected = isSelected ? "selected" : "";
      if (it.value === "") {
        var label = "";
        title2 = "close";
        if (isNotUndefined(this.state.icons[index2])) {
          iconClass = "icon";
          label = iconBlank();
          value = "__blank__";
        }
      } else {
        var iconKey = this.state.icons[index2];
        if (obj[iconKey]) {
          iconClass = "icon";
        }
        title2 = label;
        label = obj[iconKey] || label || iconKey || it.text || it.value;
      }
      var color2 = this.state.colors[index2];
      var css = {};
      if (isSelected && color2) {
        css["background-color"] = color2;
      }
      return `
                <div class='select-icon-item ${selected} ${iconClass}' 
                    style='${CSS_TO_STRING$1(css)}' 
                    data-value="${value}" 
                    data-tooltip='${title2}'
                >${label}</div>`;
    });
  }
  [CLICK("$options .select-icon-item")](e2) {
    var value = e2.$dt.attr("data-value");
    if (!value || value === "__blank__")
      return;
    this.updateData({
      value
    });
    this.refresh();
  }
  updateData(data) {
    this.setState(data, false);
    this.parent.trigger(this.props.onchange, this.props.key, this.getValue(), this.props.params);
  }
}
var StrokeDashArrayEditor$1 = "";
const dash_list = [
  [10, 5],
  [5, 1],
  [1, 5],
  [0.9],
  [15, 10, 5],
  [15, 10, 5, 10],
  [15, 10, 5, 10, 15],
  [5, 5, 1, 5]
];
class StrokeDashArrayEditor extends EditorElement {
  initialize() {
    super.initialize();
    this.notEventRedefine = true;
  }
  initState() {
    var value = isArray(this.props.value) ? this.props.value : this.generateValue(this.props.value || "");
    return {
      label: this.props.label || "",
      value,
      count: 1
    };
  }
  template() {
    const { label } = this.state;
    const hasLabel = !!label;
    return `
      <div class='elf--stroke-dasharray-editor'>
        <div class='tools ${hasLabel ? "has-label" : ""}'>
          ${hasLabel ? `<label class='label'>${label}</label>` : ""}
          <div class="buttons">
            <label ref='$add'>${obj.add}</label>          
          </div>
        </div>      
        <div ref='$body' class='dash-list'></div>
        <div ref='$list' class='dash-sample-list'></div>
      </div>
    `;
  }
  [CLICK("$el .tools label")]() {
    this.refs.$list.toggle();
  }
  getValue() {
    return this.state.value;
  }
  generateValue(value) {
    return value.split(" ").filter(Boolean).map((it) => +it);
  }
  setValue(value) {
    if (Array.isArray(value))
      ;
    else {
      value = this.generateValue(value);
    }
    this.setState({
      value
    });
  }
  [LOAD("$list")]() {
    return dash_list.map((value, index2) => {
      return `
        <div class='dash-sample' data-index='${index2}'>
          <div class='dash-sample-value'>
            <svg width="100" height="2">
              <line x1="5" y1="0" x2="95" y2="0" stroke-dasharray="${value.join(",")}" stroke-width="2" stroke="black" />
            </svg>
          </div>
        </div>
      `;
    });
  }
  [LOAD("$body")]() {
    this.state.count++;
    return this.state.value.map((value, index2) => {
      var num = index2 + 1;
      return `
        <div class='dasharray-item'>
          ${createComponent("NumberInputEditor", {
        ref: `$dash-${this.state.count}-${num}`,
        compact: true,
        key: index2,
        value,
        min: 0,
        max: 100,
        step: 1,
        onchange: "changeRangeEditor"
      })}  
          <button type="button" data-index="${index2}" class='delete'>${iconUse$1("close")}</button>
        </div>
      `;
    });
  }
  [SUBSCRIBE_SELF("changeRangeEditor")](key, value) {
    var index2 = +key;
    this.state.value[index2] = value;
    this.modifyStrokeDashArray();
  }
  [CLICK("$list .dash-sample")](e2) {
    const value = dash_list[+e2.$dt.data("index")];
    this.setState({ value }, false);
    this.refresh();
    this.modifyStrokeDashArray();
    this.refs.$list.toggle();
  }
  [CLICK("$add")]() {
    this.setState({
      value: [...this.state.value, 0]
    }, false);
    this.refresh();
    this.modifyStrokeDashArray();
  }
  [CLICK("$body .delete")](e2) {
    const index2 = +e2.$dt.attr("data-index");
    this.state.value.splice(index2, 1);
    this.refresh();
    this.modifyStrokeDashArray();
  }
  modifyStrokeDashArray() {
    this.parent.trigger(this.props.onchange, this.props.key, this.getValue(), this.props.params);
  }
  [POINTERSTART("document")](e2) {
    const $target = Dom.create(e2.target);
    const parent = $target.closest("elf--stroke-dasharray-editor");
    if (!parent) {
      this.refs.$list.hide();
    }
  }
}
var TextAreaEditor$1 = "";
class TextAreaEditor extends EditorElement {
  initState() {
    var value = this.props.value;
    return {
      label: this.props.label || "",
      height: 100,
      value
    };
  }
  template() {
    var { label, height: height2, value } = this.state;
    var hasLabel = !!label ? "has-label" : "";
    return `
            <div class='elf--text-area-editor ${hasLabel}'>
                ${label ? `<label>${label}</label>` : ""}
                <textarea ref='$text' style='height:${height2}'>${value}</textarea>
            </div>
        `;
  }
  getValue() {
    return this.refs.$options.value;
  }
  setValue(value, height2) {
    this.setState({ value }, false);
    if (height2) {
      this.setState({ height: height2 }, false);
    }
    this.refresh();
  }
  [BIND("$text")]() {
    return {
      "text": this.state.value || "",
      style: {
        height: this.state.height
      }
    };
  }
  [INPUT("$text")]() {
    this.updateData({
      value: this.refs.$text.value
    });
  }
  updateData(data) {
    this.setState(data);
    this.parent.trigger(this.props.onchange, this.props.key, this.state.value, this.props.params);
  }
}
var TextEditor$1 = "";
class TextEditor extends EditorElement {
  initState() {
    var value = this.props.value;
    return {
      label: this.props.label || "",
      value
    };
  }
  template() {
    var { label, value } = this.state;
    var hasLabel = !!label ? "has-label" : "";
    return `
            <div class='elf--text-editor ${hasLabel}'>
                ${label ? `<label>${label}</label>` : ""}
                <div>
                    <input type='text' ref='$text' value="${value}" />
                </div>
            </div>
        `;
  }
  getValue() {
    return this.refs.$text.value;
  }
  setValue(value) {
    this.refs.$text.val(value);
    this.setState({
      value
    }, false);
  }
  [BIND("$text")]() {
    return {
      "value": this.state.value
    };
  }
  [INPUT("$text")]() {
    this.updateData({
      value: this.refs.$text.value
    });
  }
  updateData(data) {
    this.setState(data, false);
    this.parent.trigger(this.props.onchange, this.props.key, this.getValue(), this.props.params);
  }
}
var VarEditor$1 = "";
class VarEditor extends EditorElement {
  initState() {
    var values = this.props.value.split(";").filter((it) => it.trim()).map((it) => {
      let [key, value] = it.split(":");
      key = key.replace("--", "");
      return { key, value };
    });
    return {
      hideLabel: this.props.hideLabel == "true" ? true : false,
      params: this.props.params || "",
      values
    };
  }
  template() {
    var labelClass = this.state.hideLabel ? "hide" : "";
    return `
        <div class='elf--var-editor var-list'>
            <div class='label ${labelClass}' >
                <label>${this.props.title || ""}</label>
                <div class='tools'>
                    <button type="button" ref="$add" title="add Var">${obj.add}</button>
                </div>
            </div>
            <div class='var-list' ref='$varList'></div>
        </div>`;
  }
  [SUBSCRIBE("add")]() {
    this.state.values.push({
      key: "",
      value: ""
    });
    this.refresh();
    this.updateData();
  }
  [CLICK("$add")]() {
    this.trigger("add");
  }
  [LOAD("$varList")]() {
    return this.state.values.map((it, index2) => {
      return `
                <div class='var-item' >
                    <div>
                        <input type="text" data-type="key" value="${it.key}" data-index="${index2}"  placeholder="variable" />
                    </div>
                    <div>
                        <input type="text" data-type="value" value="${it.value}" data-index="${index2}"  placeholder="value" />
                    </div>
                    <div class="tools">
                        <button type="button" class="del" data-index="${index2}">
                        ${obj.remove2}
                        </button>
                    </div>
                </div>
            `;
    });
  }
  [CLICK("$varList .del")](e2) {
    var index2 = +e2.$dt.attr("data-index");
    this.state.values.splice(index2, 1);
    this.refresh();
    this.updateData();
  }
  [INPUT("$varList input")](e2) {
    var index2 = +e2.$dt.attr("data-index");
    var type = e2.$dt.attr("data-type");
    this.state.values[index2][type] = e2.$dt.value;
    this.updateData();
  }
  updateData(data) {
    var value = this.state.values.map((it) => {
      return `${it.key}:${it.value}`;
    }).join(";");
    this.parent.trigger(this.props.onchange, value, this.props.params);
  }
}
function propertyEditor(editor) {
  editor.registerElement({
    IconListViewEditor,
    TextAreaEditor,
    TextEditor,
    ColorSingleEditor,
    CubicBezierEditor,
    ClipPathEditor,
    ColorViewEditor,
    VarEditor,
    PathDataEditor,
    PolygonDataEditor,
    InputArrayEditor,
    StrokeDashArrayEditor,
    NumberInputEditor,
    NumberRangeEditor,
    MediaProgressEditor,
    SelectIconEditor,
    CSSPropertyEditor,
    DirectionEditor,
    IterationCountEditor,
    GradientEditor,
    FilterEditor,
    SelectEditor,
    BlendSelectEditor,
    RangeEditor,
    InputRangeEditor,
    ColorAssetsEditor,
    FontSelectEditor
  });
  editor.registerAlias({
    "icon-list-view": "IconListViewEditor",
    "text-area": "TextAreaEditor",
    "text": "TextEditor",
    "color-single": "ColorSingleEditor",
    "cubic-bezier": "CubicBezierEditor",
    "clip-path": "ClipPathEditor",
    "color-view": "ColorViewEditor",
    "var": "VarEditor",
    "path-data": "PathDataEditor",
    "polygon-data": "PolygonDataEditor",
    "input-array": "InputArrayEditor",
    "stroke-dash-array": "StrokeDashArrayEditor",
    "number-input": "NumberInputEditor",
    "number-range": "NumberRangeEditor",
    "media-progress": "MediaProgressEditor",
    "select-icon": "SelectIconEditor",
    "css-property": "CSSPropertyEditor",
    "direction": "DirectionEditor",
    "iteration-count": "IterationCountEditor",
    "gradient": "GradientEditor",
    "filter": "FilterEditor",
    "select": "SelectEditor",
    "blend-select": "BlendSelectEditor",
    "range": "RangeEditor",
    "input-range": "InputRangeEditor",
    "color-assets": "ColorAssetsEditor",
    "font-select": "FontSelectEditor"
  });
}
const char_list = [
  /\(/gi,
  /\)/gi
];
const function_list = "grayscale,matrix,rotateZ,blur,sepia,linear-gradient,radial-gradient,conic-gradient,circle,inset,polygon,rgb".split(",").map((it) => {
  return new RegExp(it, "gi");
});
const keyword_list = "butt,miter,start,at,black,repeat,lighten,multiply,solid,border-box,visible,absolute,relative,auto".split(",").map((it) => {
  return new RegExp(it, "gi");
});
function replaceKeyword(str) {
  keyword_list.forEach((ke) => {
    str = str.replace(ke, (str2) => {
      return `<span class="keyword">${str2}</span>`;
    });
  });
  function_list.forEach((ke) => {
    str = str.replace(ke, (str2) => {
      return `<span class="function">${str2}</span>`;
    });
  });
  char_list.forEach((ke) => {
    str = str.replace(ke, (str2) => {
      return `<span class="char">${str2}</span>`;
    });
  });
  return str;
}
function filterKeyName(str, prefixPadding = "") {
  return str.split(";").filter((it) => it.trim()).map((it) => {
    it = it.trim();
    var [key, value] = it.split(":").map((it2) => it2.trim());
    if (value === "") {
      return "";
    }
    return `<div class="block"><strong>${key}</strong><span>:&nbsp;</span><span class="value">${replaceKeyword(value)}</span><span>;</span></div>`;
  }).join("").trim();
}
function modifyNewLine(str) {
  return str.replace(/;/gi, ";\n").trim();
}
class HTMLRenderer {
  constructor(editor) {
    this.editor = editor;
  }
  get id() {
    return this.editor.EDITOR_ID;
  }
  getDefaultRendererInstance() {
    return this.editor.getRendererInstance("html", "rect");
  }
  getRendererInstance(item2) {
    return this.editor.getRendererInstance("html", item2.itemType) || this.getDefaultRendererInstance() || item2;
  }
  render(item2, renderer) {
    if (!item2)
      return;
    const currentRenderer = this.getRendererInstance(item2);
    if (currentRenderer) {
      return currentRenderer.render(item2, renderer || this);
    }
  }
  renderSVG(item2, renderer) {
    const currentRenderer = this.getRendererInstance(item2);
    if (isFunction(currentRenderer.renderSVG)) {
      return currentRenderer.renderSVG(item2, renderer || this);
    }
    return this.getDefaultRendererInstance().renderSVG(item2, renderer || this);
  }
  to(type, item2) {
    const currentRenderer = this.getRendererInstance(item2);
    if (isFunction(currentRenderer[type])) {
      return currentRenderer[type].call(currentRenderer, item2);
    }
    const defaultInstance = this.getDefaultRendererInstance();
    if (isFunction(defaultInstance[type])) {
      return defaultInstance[type].call(defaultInstance, item2);
    }
  }
  toCSS(item2, omit = {}) {
    const css = this.to("toCSS", item2);
    Object.keys(omit).forEach((key) => {
      delete css[key];
    });
    return css;
  }
  toNestedCSS(item2) {
    return this.to("toNestedCSS", item2);
  }
  toTransformCSS(item2) {
    return this.to("toTransformCSS", item2);
  }
  toGridLayoutCSS(item2) {
    return this.to("toGridLayoutCSS", item2);
  }
  toLayoutItemCSS(item2) {
    return this.to("toLayoutItemCSS", item2);
  }
  toLayoutBaseModelCSS(item2) {
    return this.to("toLayoutBaseModelCSS", item2);
  }
  toStyle(item2, renderer) {
    const currentRenderer = this.getRendererInstance(item2);
    if (isFunction(currentRenderer.toStyle)) {
      return currentRenderer.toStyle(item2, renderer || this);
    }
    return this.getDefaultRendererInstance().toStyle(item2, renderer || this);
  }
  toStyleData(item2, renderer) {
    const currentRenderer = this.getRendererInstance(item2);
    if (isFunction(currentRenderer.toStyleData)) {
      return currentRenderer.toStyleData(item2, renderer || this);
    }
    return this.getDefaultRendererInstance().toStyleData(item2, renderer || this);
  }
  toExportStyle(item2, renderer) {
    const currentRenderer = this.getRendererInstance(item2);
    if (isFunction(currentRenderer.toExportStyle)) {
      return currentRenderer.toExportStyle(item2, renderer || this);
    }
    return this.getDefaultRendererInstance().toExportStyle(item2, renderer || this);
  }
  update(item2, currentElement, editor) {
    const currentRenderer = this.getRendererInstance(item2);
    if (isFunction(currentRenderer.update)) {
      return currentRenderer.update(item2, currentElement, editor);
    }
    return this.getDefaultRendererInstance().update(item2, currentElement, editor);
  }
  codeview(item2) {
    if (!item2) {
      return "";
    }
    const currentProject = item2.top;
    let keyframeCode = modifyNewLine(filterKeyName(currentProject ? currentProject.toKeyframeString() : ""));
    let rootVariable = currentProject ? CSS_TO_STRING$1(currentProject.toRootVariableCSS()) : "";
    const current = item2;
    const cssCode = filterKeyName(current ? TAG_TO_STRING(CSS_TO_STRING$1(this.toCSS(current))) : "");
    const nestedCssCode = current ? this.toNestedCSS(current).map((it) => {
      var cssText = it.cssText ? it.cssText : CSS_TO_STRING$1(it.css);
      return `${it.selector} { 
    ${filterKeyName(TAG_TO_STRING(cssText), "&nbsp;&nbsp;")}
    }`;
    }) : [];
    const selectorCode = current ? current.selectors : [];
    return `
<div >

${cssCode && `<div><pre title='CSS'>${cssCode}</pre></div>`}

${nestedCssCode.map((it) => {
      return `<div><pre title='CSS'>${it}</pre></div>`;
    }).join("")}

${(selectorCode || []).length ? `<div>
    ${selectorCode.map((selector2) => {
      return `<pre title='${selector2.selector}'>${selector2.toPropertyString()}</pre>`;
    }).join("")}
    
    </div>` : ""}

${keyframeCode && `<div><pre title='Keyframe'>${keyframeCode}</pre></div>`}

${rootVariable ? `<div>
    <label>:root</label>
    <pre>${rootVariable}</pre>
    </div>` : ""}

</div>
        `;
  }
}
class ItemRender$1 {
  getInnerId(item2, postfix = "") {
    return item2.id + postfix;
  }
}
const Primitive = "SourceGraphic,SourceAlpha,BackgroundImage,BackgroundAlpha,FillPaint,StrokePaint".split(",");
const DEFAULT_ATTRIBUTES = {
  xChannelSelector: true,
  yChannelSelector: true
};
class BaseSVGFilter extends PropertyItem {
  static parse(obj2) {
    var FilterClass = SVGFilterClassName[obj2.type];
    return new FilterClass(obj2);
  }
  hasLight() {
    return false;
  }
  isLight() {
    return false;
  }
  isSource() {
    return false;
  }
  getDefaultObject(obj2 = {}) {
    var id = uuidShort$1();
    return super.getDefaultObject(__spreadValues({
      itemType: "svgfilter",
      id,
      in: [],
      bound: { x: 100, y: 100, targetX: 0, targetY: 0 },
      connected: []
    }, obj2));
  }
  getInCount() {
    return 0;
  }
  setIn(index2, target) {
    this.json.in[index2] = { id: target.id, type: target.type };
  }
  setConnected(target) {
    var f = this.json.connected.filter((c2) => c2.id === target.id);
    if (f.length === 0) {
      this.json.connected.push({ id: target.id });
    }
  }
  convert(json) {
    if (typeof json.in === "string") {
      json.in = JSON.parse(json.in);
    }
    if (typeof json.bound === "string") {
      json.bound = JSON.parse(json.bound);
    }
    if (typeof json.connected === "string") {
      json.connected = JSON.parse(json.connected);
    }
    return json;
  }
  toCloneObject() {
    return __spreadValues(__spreadValues({}, super.toCloneObject()), this.attrs("id", "in", "bound", "connected"));
  }
  getDefaultAttribute() {
    var list2 = [];
    if (this.json.connected.length) {
      list2.push(`result="${this.json.id}result"`);
    }
    Object.keys(DEFAULT_ATTRIBUTES).filter((key) => {
      return !!this.json[key];
    }).forEach((key) => {
      list2.push(`${key}="${this.json[key]}"`);
    });
    return list2.join(" ") + " " + this.getSourceInAttribute();
  }
  hasInIndex() {
    return false;
  }
  getSourceInAttribute(inList) {
    return (inList || this.json.in).map((it, index2) => {
      if (!it)
        return "";
      var indexString = index2 === 0 ? "" : index2 + 1 + "";
      if (!this.hasInIndex()) {
        indexString = "";
      }
      if (Primitive.includes(it.type)) {
        return `in${indexString}="${it.type}"`;
      }
      return `in${indexString}="${it.id}result"`;
    }).join(" ");
  }
  toString() {
    var { type, value } = this.json;
    return `<fe${type} value="${value}" ${this.getDefaultAttribute()} />`;
  }
}
class RotaMatrixSVGFilter extends BaseSVGFilter {
  getDefaultObject() {
    return super.getDefaultObject({
      type: "RotaMatrix",
      hueRotate: RotaMatrixSVGFilter.spec.hueRotate.defaultValue
    });
  }
  convert(json) {
    json.hueRotate = Length.parse(json.hueRotate);
    return json;
  }
  toString() {
    var { id, hueRotate } = this.json;
    return `
      <feColorMatrix type="hueRotate" result="romatrix-${id}"  values="${hueRotate}"/>
      <feColorMatrix type="matrix" in="romatrix-${id}" in2="SourceGraphic"  ${this.getDefaultAttribute()} values="-1 2 -3 0 -.5 2 1 0 0 0 0 3 1 0 0 0 0 1 1 0"/>
    `;
  }
}
RotaMatrixSVGFilter.spec = {
  hueRotate: {
    title: "hue-rotate",
    inputType: "number-range",
    min: 0,
    max: 360,
    step: 1,
    defaultValue: Length.number(0)
  }
};
class MergeSVGFilter extends BaseSVGFilter {
  getDefaultObject() {
    return super.getDefaultObject({
      type: "Merge"
    });
  }
  getInCount() {
    return 3;
  }
  getDefaultAttribute() {
    var list2 = [];
    if (this.json.connected.length) {
      list2.push(`result="${this.json.id}result"`);
    }
    return list2.join(" ");
  }
  toString() {
    var { in: inList } = this.json;
    return `
    <feMerge  ${this.getDefaultAttribute()} >
      ${inList.map((it) => {
      return `<feMergeNode ${this.getSourceInAttribute([it])} />`;
    }).join("")}
    </feMerge>`;
  }
}
MergeSVGFilter.spec = {};
class CompositeSVGFilter extends BaseSVGFilter {
  getDefaultObject() {
    return super.getDefaultObject({
      type: "Composite",
      operator: CompositeSVGFilter.spec.operator.defaultValue,
      k1: CompositeSVGFilter.spec.k1.defaultValue,
      k2: CompositeSVGFilter.spec.k2.defaultValue,
      k3: CompositeSVGFilter.spec.k3.defaultValue,
      k4: CompositeSVGFilter.spec.k4.defaultValue
    });
  }
  getInCount() {
    return 2;
  }
  toString() {
    var { operator, k1, k2, k3, k4 } = this.json;
    var kNumbers = "";
    if (operator === "arithmetic") {
      kNumbers = ` k1="${k1}" k2="${k2}" k3="${k3}" k4="${k4}" `;
    }
    return `<feComposite operator="${operator}" ${kNumbers}  ${this.getDefaultAttribute()} />`;
  }
  hasInIndex() {
    return true;
  }
}
CompositeSVGFilter.spec = {
  operator: {
    title: "operator",
    inputType: "select",
    options: "over,in,out,atop,xor,arithmetic",
    defaultValue: "over"
  },
  k1: {
    title: "k1",
    inputType: "number-range",
    min: 0,
    max: 1,
    step: 0.01,
    defaultValue: Length.number(0)
  },
  k2: {
    title: "k2",
    inputType: "number-range",
    min: 0,
    max: 1,
    step: 0.01,
    defaultValue: Length.number(0)
  },
  k3: {
    title: "k3",
    inputType: "number-range",
    min: 0,
    max: 1,
    step: 0.01,
    defaultValue: Length.number(0)
  },
  k4: {
    title: "k4",
    inputType: "number-range",
    min: 0,
    max: 1,
    step: 0.01,
    defaultValue: Length.number(0)
  }
};
class MorphologySVGFilter extends BaseSVGFilter {
  getDefaultObject() {
    return super.getDefaultObject({
      type: "Morphology",
      operator: MorphologySVGFilter.spec.operator.defaultValue,
      radius: MorphologySVGFilter.spec.radius.defaultValue
    });
  }
  getInCount() {
    return 1;
  }
  toString() {
    var { operator, radius } = this.json;
    return `<feMorphology operator="${operator}" radius="${radius}"  ${this.getDefaultAttribute()} />`;
  }
}
MorphologySVGFilter.spec = {
  operator: {
    title: "Operator",
    inputType: "select",
    options: "erode,dilate",
    defaultValue: "erode"
  },
  radius: {
    title: "Radius",
    inputType: "number-range",
    min: 0,
    max: 100,
    step: 1,
    defaultValue: Length.number(0)
  }
};
class TurbulenceSVGFilter extends BaseSVGFilter {
  getDefaultObject() {
    return super.getDefaultObject({
      type: "Turbulence",
      filterType: TurbulenceSVGFilter.spec.filterType.defaultValue,
      baseFrequency: TurbulenceSVGFilter.spec.baseFrequency.defaultValue,
      numOctaves: TurbulenceSVGFilter.spec.numOctaves.defaultValue,
      seed: TurbulenceSVGFilter.spec.seed.defaultValue
    });
  }
  convert(obj2) {
    obj2.baseFrequency = Length.parse(obj2.baseFrequency);
    obj2.numOctaves = Length.parse(obj2.numOctaves);
    obj2.seed = Length.parse(obj2.seed);
    return obj2;
  }
  toString() {
    var { filterType, baseFrequency, numOctaves, seed } = this.json;
    return `<feTurbulence ${OBJECT_TO_PROPERTY$1({
      type: filterType,
      baseFrequency,
      numOctaves,
      seed
    })}   ${this.getDefaultAttribute()} />`;
  }
}
TurbulenceSVGFilter.spec = {
  filterType: {
    title: "Type",
    inputType: "select",
    options: "fractalNoise,turbulence",
    defaultValue: "turbulence"
  },
  baseFrequency: {
    title: "Frequency",
    inputType: "number-range",
    min: 0,
    max: 1,
    step: 0.01,
    defaultValue: Length.number(0)
  },
  numOctaves: {
    title: "Octaves",
    inputType: "number-range",
    min: 1,
    max: 10,
    step: 1,
    defaultValue: Length.number(1)
  },
  seed: {
    title: "Seed",
    inputType: "number-range",
    min: 0,
    max: 1e4,
    step: 1,
    defaultValue: Length.number(0)
  }
};
class DisplacementMapSVGFilter extends BaseSVGFilter {
  getDefaultObject() {
    return super.getDefaultObject({
      type: "DisplacementMap",
      scale: DisplacementMapSVGFilter.spec.scale.defaultValue
    });
  }
  getInCount() {
    return 2;
  }
  convert(obj2) {
    obj2.scale = Length.parse(obj2.scale);
    return obj2;
  }
  toString() {
    var { scale: scale2 } = this.json;
    var scaleOption = scale2.value ? `scale="${scale2}"` : "";
    return `<feDisplacementMap ${scaleOption}  ${this.getDefaultAttribute()} />`;
  }
  hasInIndex() {
    return true;
  }
}
DisplacementMapSVGFilter.spec = {
  scale: {
    title: "scale",
    inputType: "number-range",
    min: 0,
    max: 5e3,
    step: 1,
    defaultValue: Length.number(0)
  }
};
class ColorMatrixSVGFilter extends BaseSVGFilter {
  getDefaultObject() {
    return super.getDefaultObject({
      type: "ColorMatrix",
      values: ColorMatrixSVGFilter.spec.values.defaultValue
    });
  }
  getInCount() {
    return 1;
  }
  toString() {
    var { values } = this.json;
    var valueString = values.join(" ");
    return `<feColorMatrix type="matrix" values="${valueString}"  ${this.getDefaultAttribute()} />`;
  }
}
ColorMatrixSVGFilter.spec = {
  values: {
    title: "values",
    inputType: "color-matrix",
    column: 5,
    defaultValue: [
      1,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ]
  }
};
class ConvolveMatrixSVGFilter extends BaseSVGFilter {
  getDefaultObject() {
    return super.getDefaultObject({
      type: "ConvolveMatrix",
      kernelMatrix: ConvolveMatrixSVGFilter.spec.kernelMatrix.defaultValue
    });
  }
  getInCount() {
    return 1;
  }
  toString() {
    var { kernelMatrix } = this.json;
    var valueString = kernelMatrix.join(" ");
    return `<feConvolveMatrix kernelMatrix="${valueString}"  ${this.getDefaultAttribute()} />`;
  }
}
ConvolveMatrixSVGFilter.spec = {
  kernelMatrix: {
    title: "kernelMatrix",
    inputType: "input-array",
    column: 3,
    defaultValue: [
      1,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1
    ]
  }
};
class GaussianBlurSVGFilter extends BaseSVGFilter {
  getDefaultObject() {
    return super.getDefaultObject({
      type: "GaussianBlur",
      stdDeviationX: GaussianBlurSVGFilter.spec.stdDeviationX.defaultValue,
      stdDeviationY: GaussianBlurSVGFilter.spec.stdDeviationY.defaultValue,
      edgeMode: GaussianBlurSVGFilter.spec.edgeMode.defaultValue
    });
  }
  getInCount() {
    return 1;
  }
  convert(obj2) {
    obj2.stdDeviationX = Length.parse(obj2.stdDeviationX);
    obj2.stdDeviationY = Length.parse(obj2.stdDeviationY);
    return obj2;
  }
  toString() {
    var { stdDeviationX, stdDeviationY, edgeMode } = this.json;
    var stdDeviation = `${stdDeviationX} ${stdDeviationY}`;
    if (stdDeviationX === stdDeviationY) {
      stdDeviation = stdDeviationX;
    }
    return `<feGaussianBlur  stdDeviation="${stdDeviation}" edgeMode="${edgeMode}"  ${this.getDefaultAttribute()} />`;
  }
}
GaussianBlurSVGFilter.spec = {
  stdDeviationX: {
    title: "X",
    inputType: "number-range",
    min: 0,
    max: 100,
    step: 1,
    defaultValue: Length.number(0)
  },
  stdDeviationY: {
    title: "Y",
    inputType: "number-range",
    min: 0,
    max: 100,
    step: 1,
    defaultValue: Length.number(0)
  },
  edgeMode: {
    title: "edge",
    inputType: "select",
    options: "none,duplicate,wrap",
    defaultValue: "none"
  }
};
class FloodSVGFilter extends BaseSVGFilter {
  getDefaultObject() {
    return super.getDefaultObject({
      type: "Flood",
      x: FloodSVGFilter.spec.x.defaultValue,
      y: FloodSVGFilter.spec.y.defaultValue,
      width: FloodSVGFilter.spec.width.defaultValue,
      height: FloodSVGFilter.spec.height.defaultValue,
      color: FloodSVGFilter.spec.color.defaultValue,
      opacity: FloodSVGFilter.spec.opacity.defaultValue
    });
  }
  convert(json) {
    json.x = Length.parse(json.x);
    json.y = Length.parse(json.y);
    json.width = Length.parse(json.width);
    json.height = Length.parse(json.height);
    return json;
  }
  toString() {
    const { opacity: opacity2, color: color2, x: x2, y: y2, width: width2, height: height2 } = this.json;
    return `<feFlood ${OBJECT_TO_PROPERTY$1({
      x: x2,
      y: y2,
      width: width2,
      height: height2
    })} flood-opacity="${opacity2}" flood-color="${color2}" ${this.getDefaultAttribute()} />`;
  }
}
FloodSVGFilter.spec = {
  x: {
    title: "X",
    inputType: "number-range",
    min: 0,
    max: 1e3,
    step: 1,
    defaultValue: Length.number(0)
  },
  y: {
    title: "Y",
    inputType: "number-range",
    min: 0,
    max: 1e3,
    step: 1,
    defaultValue: Length.number(0)
  },
  width: {
    title: "width",
    inputType: "number-range",
    min: 0,
    max: 1e3,
    step: 1,
    defaultValue: Length.number(0)
  },
  height: {
    title: "height",
    inputType: "number-range",
    min: 0,
    max: 1e3,
    step: 1,
    defaultValue: Length.number(0)
  },
  opacity: {
    title: "opacity",
    inputType: "number-range",
    min: 0,
    max: 1,
    step: 0.01,
    defaultValue: Length.number(0)
  },
  color: {
    title: "color",
    inputType: "color",
    defaultValue: "rgba(0, 0, 0, 1)"
  }
};
class ComponentTransferSVGFilter extends BaseSVGFilter {
  getDefaultObject() {
    return super.getDefaultObject({
      type: "ComponentTransfer",
      r: ComponentTransferSVGFilter.spec.r.defaultValue,
      g: ComponentTransferSVGFilter.spec.g.defaultValue,
      b: ComponentTransferSVGFilter.spec.b.defaultValue,
      a: ComponentTransferSVGFilter.spec.a.defaultValue
    });
  }
  getInCount() {
    return 1;
  }
  parse(value) {
    var [type, ...values] = value.split(" ");
    if (type === "table" || type === "discrete") {
      return { type, tableValues: values.join(" ") };
    }
    if (type === "linear") {
      var [slop, intercept] = values;
      return { type, slop, intercept };
    } else if (type === "gamma") {
      var [amplitude, exponent, offset] = values;
      return { type, amplitude, exponent, offset };
    }
    return { type };
  }
  toString() {
    var { r, g, b, a } = this.json;
    r = this.parse(r);
    g = this.parse(g);
    b = this.parse(b);
    a = this.parse(a);
    return `<feComponentTransfer ${this.getDefaultAttribute()} >
      ${r && `<feFuncR ${OBJECT_TO_PROPERTY$1(r)} />`}
      ${g && `<feFuncG ${OBJECT_TO_PROPERTY$1(g)} />`}
      ${b && `<feFuncB ${OBJECT_TO_PROPERTY$1(b)} />`}
      ${a && `<feFuncA ${OBJECT_TO_PROPERTY$1(a)} />`}
    </feComponentTransfe>`;
  }
}
ComponentTransferSVGFilter.spec = {
  r: {
    title: "R",
    inputType: "FuncFilter",
    defaultValue: "identity"
  },
  g: {
    title: "G",
    inputType: "FuncFilter",
    defaultValue: "identity"
  },
  b: {
    title: "B",
    inputType: "FuncFilter",
    defaultValue: "identity"
  },
  a: {
    title: "A",
    inputType: "FuncFilter",
    defaultValue: "identity"
  }
};
class DistantLightSVGFilter extends BaseSVGFilter {
  getDefaultObject() {
    return super.getDefaultObject({
      type: "DistantLight",
      azimuth: DistantLightSVGFilter.spec.azimuth.defaultValue,
      elevation: DistantLightSVGFilter.spec.elevation.defaultValue
    });
  }
  isLight() {
    return true;
  }
  toString() {
    return "";
  }
  toLightString() {
    var { azimuth, elevation } = this.json;
    return `<feDistantLight ${OBJECT_TO_PROPERTY$1({
      azimuth,
      elevation
    })} />`;
  }
}
DistantLightSVGFilter.spec = {
  azimuth: {
    title: "azimuth",
    inputType: "number-range",
    min: 0,
    max: 1e3,
    step: 1,
    defaultValue: Length.number(0)
  },
  elevation: {
    title: "elevation",
    inputType: "number-range",
    min: 0,
    max: 1e3,
    step: 1,
    defaultValue: Length.number(0)
  }
};
class PointLightSVGFilter extends BaseSVGFilter {
  getDefaultObject() {
    return super.getDefaultObject({
      type: "PointLight",
      x: PointLightSVGFilter.spec.x.defaultValue,
      y: PointLightSVGFilter.spec.y.defaultValue,
      z: PointLightSVGFilter.spec.z.defaultValue
    });
  }
  isLight() {
    return true;
  }
  toString() {
    return "";
  }
  toLightString() {
    var { x: x2, y: y2, z } = this.json;
    return `<fePointLight ${OBJECT_TO_PROPERTY$1({
      x: x2,
      y: y2,
      z
    })} />`;
  }
}
PointLightSVGFilter.spec = {
  x: {
    title: "x",
    inputType: "number-range",
    min: 0,
    max: 1e3,
    step: 1,
    defaultValue: Length.number(0)
  },
  y: {
    title: "y",
    inputType: "number-range",
    min: 0,
    max: 1e3,
    step: 1,
    defaultValue: Length.number(0)
  },
  z: {
    title: "z",
    inputType: "number-range",
    min: 0,
    max: 1e3,
    step: 1,
    defaultValue: Length.number(0)
  }
};
class SpotLightSVGFilter extends BaseSVGFilter {
  getDefaultObject() {
    return super.getDefaultObject({
      type: "SpotLight",
      x: SpotLightSVGFilter.spec.x.defaultValue,
      y: SpotLightSVGFilter.spec.x.defaultValue,
      z: SpotLightSVGFilter.spec.x.defaultValue,
      pointsAtX: SpotLightSVGFilter.spec.pointsAtX.defaultValue,
      pointsAtY: SpotLightSVGFilter.spec.pointsAtY.defaultValue,
      pointsAtZ: SpotLightSVGFilter.spec.pointsAtZ.defaultValue,
      specularExponent: SpotLightSVGFilter.spec.specularExponent.defaultValue,
      limitingConeAngle: SpotLightSVGFilter.spec.limitingConeAngle.defaultValue
    });
  }
  isLight() {
    return true;
  }
  toString() {
  }
  toLightString() {
    var { x: x2, y: y2, z, pointsAtX, pointsAtY, pointsAtZ, specularExponent, limitingConeAngle } = this.json;
    return `<feSpotLight ${OBJECT_TO_PROPERTY$1({
      x: x2,
      y: y2,
      z,
      pointsAtX,
      pointsAtY,
      pointsAtZ,
      specularExponent,
      limitingConeAngle
    })} />`;
  }
}
SpotLightSVGFilter.spec = {
  x: {
    title: "x",
    inputType: "number-range",
    min: 0,
    max: 1e3,
    step: 1,
    defaultValue: Length.number(0)
  },
  y: {
    title: "y",
    inputType: "number-range",
    min: 0,
    max: 1e3,
    step: 1,
    defaultValue: Length.number(0)
  },
  z: {
    title: "z",
    inputType: "number-range",
    min: 0,
    max: 1e3,
    step: 1,
    defaultValue: Length.number(0)
  },
  pointsAtX: {
    title: "pointsAtX",
    inputType: "number-range",
    min: 0,
    max: 1e3,
    step: 1,
    defaultValue: Length.number(0)
  },
  pointsAtY: {
    title: "pointsAtY",
    inputType: "number-range",
    min: 0,
    max: 1e3,
    step: 1,
    defaultValue: Length.number(0)
  },
  pointsAtZ: {
    title: "pointsAtZ",
    inputType: "number-range",
    min: 0,
    max: 1e3,
    step: 1,
    defaultValue: Length.number(0)
  },
  specularExponent: {
    title: "specularExponent",
    inputType: "number-range",
    min: 0,
    max: 100,
    step: 1,
    defaultValue: Length.number(1)
  },
  limitingConeAngle: {
    title: "limitingConeAngle",
    inputType: "number-range",
    min: 0,
    max: 100,
    step: 1,
    defaultValue: Length.number(1)
  }
};
class DiffuseLightingSVGFilter extends BaseSVGFilter {
  getDefaultObject() {
    return super.getDefaultObject({
      type: "DiffuseLighting",
      surfaceScale: DiffuseLightingSVGFilter.spec.surfaceScale.defaultValue,
      lightingColor: DiffuseLightingSVGFilter.spec.lightingColor.defaultValue,
      diffuseConstant: DiffuseLightingSVGFilter.spec.diffuseConstant.defaultValue,
      lightInfo: ""
    });
  }
  toCloneObject() {
    return __spreadValues(__spreadValues({}, super.toCloneObject()), this.attrs("surfaceScale", "lightingColor", "diffuseConstant", "lightInfo"));
  }
  hasLight() {
    return true;
  }
  getInCount() {
    return 1;
  }
  toString() {
    var { surfaceScale, diffuseConstant, lightingColor } = this.json;
    return `<feDiffuseLighting ${OBJECT_TO_PROPERTY$1({
      surfaceScale,
      diffuseConstant,
      "lighting-color": lightingColor
    })}  ${this.getDefaultAttribute()} >
      ${this.json.lightInfo}
    </feDiffuseLighting>`;
  }
}
DiffuseLightingSVGFilter.spec = {
  surfaceScale: {
    title: "surfaceScale",
    inputType: "number-range",
    min: 0,
    max: 100,
    step: 1,
    defaultValue: Length.number(1)
  },
  diffuseConstant: {
    title: "diffuseConstant",
    inputType: "number-range",
    min: 0,
    max: 100,
    step: 1,
    defaultValue: Length.number(1)
  },
  lightingColor: {
    title: "Lighting Color",
    inputType: "color",
    defaultValue: "rgba(0, 0, 0, 1)"
  }
};
class SpecularLightingSVGFilter extends BaseSVGFilter {
  getDefaultObject() {
    return super.getDefaultObject({
      type: "SpecularLighting",
      surfaceScale: SpecularLightingSVGFilter.spec.surfaceScale.defaultValue,
      lightingColor: SpecularLightingSVGFilter.spec.lightingColor.defaultValue,
      specularConstant: SpecularLightingSVGFilter.spec.specularConstant.defaultValue,
      specularExponent: SpecularLightingSVGFilter.spec.specularExponent.defaultValue,
      lightInfo: ""
    });
  }
  toCloneObject() {
    return __spreadValues(__spreadValues({}, super.toCloneObject()), this.attrs("surfaceScale", "lightingColor", "specularConstant", "specularExponent", "lightInfo"));
  }
  hasLight() {
    return true;
  }
  getInCount() {
    return 1;
  }
  toString() {
    var { surfaceScale, specularConstant, specularExponent, lightingColor } = this.json;
    return `<feSpecularLighting ${OBJECT_TO_PROPERTY$1({
      surfaceScale,
      specularConstant,
      specularExponent,
      "lighting-color": lightingColor
    })}  ${this.getDefaultAttribute()} >
      ${this.json.lightInfo}
    </feSpecularLighting>`;
  }
  getSourceInAttribute() {
    return "";
  }
}
SpecularLightingSVGFilter.spec = {
  surfaceScale: {
    title: "surfaceScale",
    inputType: "number-range",
    min: 0,
    max: 100,
    step: 1,
    defaultValue: Length.number(1)
  },
  specularConstant: {
    title: "Constant",
    inputType: "number-range",
    min: 0,
    max: 100,
    step: 1,
    defaultValue: Length.number(1)
  },
  specularExponent: {
    title: "Exponent",
    inputType: "number-range",
    min: 0,
    max: 100,
    step: 1,
    defaultValue: Length.number(1)
  },
  lightingColor: {
    title: "Lighting Color",
    inputType: "color",
    defaultValue: "rgba(0, 0, 0, 1)"
  }
};
class OffsetSVGFilter extends BaseSVGFilter {
  getDefaultObject() {
    return super.getDefaultObject({
      type: "Offset",
      dx: OffsetSVGFilter.spec.dx.defaultValue,
      dy: OffsetSVGFilter.spec.dy.defaultValue
    });
  }
  getInCount() {
    return 1;
  }
  toString() {
    var { dx, dy } = this.json;
    return `<feOffset 
      ${OBJECT_TO_PROPERTY$1({
      dx,
      dy
    })}  ${this.getDefaultAttribute()} />`;
  }
}
OffsetSVGFilter.spec = {
  dx: {
    title: "dx",
    inputType: "number-range",
    min: 0,
    max: 1e3,
    step: 1,
    defaultValue: Length.number(0)
  },
  dy: {
    title: "dy",
    inputType: "number-range",
    min: 0,
    max: 1e3,
    step: 1,
    defaultValue: Length.number(0)
  }
};
class BlendSVGFilter extends BaseSVGFilter {
  getDefaultObject() {
    return super.getDefaultObject({
      type: "Blend",
      mode: BlendSVGFilter.spec.mode.defaultValue
    });
  }
  getInCount() {
    return 2;
  }
  toString() {
    var { mode } = this.json;
    return `<feBlend ${OBJECT_TO_PROPERTY$1({
      mode
    })} ${this.getDefaultAttribute()} />`;
  }
  hasInIndex() {
    return true;
  }
}
BlendSVGFilter.spec = {
  mode: {
    title: "mode",
    inputType: "blend",
    defaultValue: "normal"
  }
};
class SourceSVGFilter extends BaseSVGFilter {
  getDefaultObject(obj2 = {}) {
    return super.getDefaultObject(__spreadValues({
      type: "Source"
    }, obj2));
  }
  isSource() {
    return true;
  }
  toString() {
    return "";
  }
}
class SourceGraphicSVGFilter extends SourceSVGFilter {
  getDefaultObject() {
    return super.getDefaultObject({
      type: "SourceGraphic"
    });
  }
}
class SourceAlphaSVGFilter extends SourceSVGFilter {
  getDefaultObject() {
    return super.getDefaultObject({
      type: "SourceAlpha"
    });
  }
}
class BackgroundImageSVGFilter extends SourceSVGFilter {
  getDefaultObject() {
    return super.getDefaultObject({
      type: "BackgroundImage"
    });
  }
}
class BackgroundAlphaSVGFilter extends SourceSVGFilter {
  getDefaultObject() {
    return super.getDefaultObject({
      type: "BackgroundAlpha"
    });
  }
}
class FillPaintSVGFilter extends SourceSVGFilter {
  getDefaultObject() {
    return super.getDefaultObject({
      type: "FillPaint"
    });
  }
}
class StrokePaintSVGFilter extends SourceSVGFilter {
  getDefaultObject() {
    return super.getDefaultObject({
      type: "StrokePaint"
    });
  }
}
class DropShadowSVGFilter extends BaseSVGFilter {
  getDefaultObject() {
    return super.getDefaultObject({
      type: "DropShadow",
      dx: DropShadowSVGFilter.spec.dx.defaultValue,
      dy: DropShadowSVGFilter.spec.dy.defaultValue,
      stdDeviation: DropShadowSVGFilter.spec.stdDeviation.defaultValue,
      color: DropShadowSVGFilter.spec.color.defaultValue,
      opacity: DropShadowSVGFilter.spec.opacity.defaultValue
    });
  }
  getInCount() {
    return 1;
  }
  toString() {
    var { dx, dy, stdDeviation, color: color2, opacity: opacity2 } = this.json;
    return `<feDropShadow ${OBJECT_TO_PROPERTY$1({
      dx,
      dy,
      stdDeviation,
      "flood-color": color2,
      "flood-opacity": opacity2
    })}  ${this.getDefaultAttribute()} />`;
  }
}
DropShadowSVGFilter.spec = {
  dx: {
    title: "dx",
    inputType: "number-range",
    min: 0,
    max: 1e3,
    step: 1,
    defaultValue: Length.number(0)
  },
  dy: {
    title: "dy",
    inputType: "number-range",
    min: 0,
    max: 1e3,
    step: 1,
    defaultValue: Length.number(0)
  },
  stdDeviation: {
    title: "stdDeviation",
    inputType: "number-range",
    min: 0,
    max: 1e3,
    step: 0.1,
    defaultValue: Length.number(0)
  },
  opacity: {
    title: "opacity",
    inputType: "number-range",
    min: 0,
    max: 1,
    step: 0.01,
    defaultValue: Length.number(1)
  },
  color: {
    title: "color",
    inputType: "color",
    defaultValue: "rgba(0, 0, 0, 1)"
  }
};
class SaturateSVGFilter extends BaseSVGFilter {
  getDefaultObject() {
    return super.getDefaultObject({
      type: "Saturate",
      values: SaturateSVGFilter.spec.values.defaultValue
    });
  }
  getInCount() {
    return 1;
  }
  toString() {
    var { values } = this.json;
    return `<feColorMatrix type="saturate" values="${values}"  ${this.getDefaultAttribute()} />`;
  }
}
SaturateSVGFilter.spec = {
  values: {
    title: "values",
    inputType: "number-range",
    min: -1,
    max: 1,
    step: 0.01,
    defaultValue: Length.number(0)
  }
};
class HueRotateSVGFilter extends BaseSVGFilter {
  getDefaultObject() {
    return super.getDefaultObject({
      type: "HueRotate",
      values: HueRotateSVGFilter.spec.values.defaultValue
    });
  }
  getInCount() {
    return 1;
  }
  toString() {
    var { values } = this.json;
    return `<feColorMatrix type="hueRotate" values="${values}"  ${this.getDefaultAttribute()} />`;
  }
}
HueRotateSVGFilter.spec = {
  values: {
    title: "values",
    inputType: "number-range",
    min: 0,
    max: 360,
    step: 0.1,
    defaultValue: Length.number(0)
  }
};
class LuminanceAlphaSVGFilter extends BaseSVGFilter {
  getDefaultObject() {
    return super.getDefaultObject({
      type: "LuminanceAlpha"
    });
  }
  getInCount() {
    return 1;
  }
  toString() {
    return `<feColorMatrix type="luminanceToAlpha" ${this.getDefaultAttribute()} />`;
  }
}
LuminanceAlphaSVGFilter.spec = {};
class TileSVGFilter extends BaseSVGFilter {
  getDefaultObject() {
    return super.getDefaultObject({
      type: "Tile",
      x: TileSVGFilter.spec.x.defaultValue,
      y: TileSVGFilter.spec.y.defaultValue,
      width: TileSVGFilter.spec.width.defaultValue,
      height: TileSVGFilter.spec.height.defaultValue
    });
  }
  getInCount() {
    return 1;
  }
  convert(json) {
    json.x = Length.parse(json.x);
    json.y = Length.parse(json.y);
    json.width = Length.parse(json.width);
    json.height = Length.parse(json.height);
    return json;
  }
  toString() {
    const { x: x2, y: y2, width: width2, height: height2 } = this.json;
    return `<feTile ${OBJECT_TO_PROPERTY$1({
      x: x2,
      y: y2,
      width: width2,
      height: height2
    })} ${this.getDefaultAttribute()} />`;
  }
}
TileSVGFilter.spec = {
  x: {
    title: "X",
    inputType: "number-range",
    min: 0,
    max: 1e3,
    step: 1,
    defaultValue: Length.number(0)
  },
  y: {
    title: "Y",
    inputType: "number-range",
    min: 0,
    max: 1e3,
    step: 1,
    defaultValue: Length.number(0)
  },
  width: {
    title: "width",
    inputType: "number-range",
    min: 0,
    max: 1e3,
    step: 1,
    defaultValue: Length.number(0)
  },
  height: {
    title: "height",
    inputType: "number-range",
    min: 0,
    max: 1e3,
    step: 1,
    defaultValue: Length.number(0)
  }
};
class ImageSVGFilter extends BaseSVGFilter {
  getDefaultObject() {
    return super.getDefaultObject({
      type: "Image",
      x: ImageSVGFilter.spec.x.defaultValue,
      y: ImageSVGFilter.spec.y.defaultValue,
      width: ImageSVGFilter.spec.width.defaultValue,
      height: ImageSVGFilter.spec.height.defaultValue,
      src: ImageSVGFilter.spec.src.defaultValue,
      alignment: ImageSVGFilter.spec.alignment.defaultValue,
      scaleing: ImageSVGFilter.spec.scaleing.defaultValue
    });
  }
  convert(json) {
    json.x = Length.parse(json.x);
    json.y = Length.parse(json.y);
    json.width = Length.parse(json.width);
    json.height = Length.parse(json.height);
    return json;
  }
  toString() {
    const { src, x: x2, y: y2, width: width2, height: height2, alignment: alignment2, scaleing } = this.json;
    return `<feImage ${OBJECT_TO_PROPERTY$1({
      x: x2,
      y: y2,
      width: width2,
      height: height2,
      "xlink:href": src,
      preserveAspectRatio: `${alignment2} ${scaleing}`
    })} ${this.getDefaultAttribute()} />`;
  }
}
ImageSVGFilter.spec = {
  x: {
    title: "X",
    inputType: "number-range",
    min: 0,
    max: 1e3,
    step: 1,
    defaultValue: Length.number(0)
  },
  y: {
    title: "Y",
    inputType: "number-range",
    min: 0,
    max: 1e3,
    step: 1,
    defaultValue: Length.number(0)
  },
  width: {
    title: "width",
    inputType: "number-range",
    min: 0,
    max: 1e3,
    step: 1,
    defaultValue: Length.number(0)
  },
  height: {
    title: "height",
    inputType: "number-range",
    min: 0,
    max: 1e3,
    step: 1,
    defaultValue: Length.number(0)
  },
  alignment: {
    title: "alignment",
    inputType: "select",
    options: "xMinYMin,xMidYMin,xMaxYMin,xMinYMid,xMidYMid,xMaxYMid,xMinYMax,xMidYMax,xMaxYMax",
    defaultValue: "xMidYMid"
  },
  scaleing: {
    title: "scaleing",
    inputType: "select",
    options: "meet,slice",
    defaultValue: "meet"
  },
  src: {
    title: "Image",
    inputType: "ImageSelectEditor",
    defaultValue: ""
  }
};
const SVG_FILTER_COMMON_ATTRIBUTES = [
  "result"
];
class SVGFilter extends PropertyItem {
  static parse(obj2) {
    var FilterClass = SVGFilterClassName[obj2.type];
    return new FilterClass(obj2);
  }
  getDefaultObject(obj2 = {}) {
    return super.getDefaultObject(__spreadValues({
      itemType: "svgfilter",
      result: ""
    }, obj2));
  }
  getDefaultAttribute() {
    return SVG_FILTER_COMMON_ATTRIBUTES.map((key) => {
      return `${key}="${this.json[key]}"`;
    }).join(" ");
  }
  toString() {
    var { type, value } = this.json;
    return `<fe${type} value="${value}" ${this.getDefaultAttribute()} />`;
  }
}
const SVGFilterClassName = {
  Image: ImageSVGFilter,
  Tile: TileSVGFilter,
  Saturate: SaturateSVGFilter,
  HueRotate: HueRotateSVGFilter,
  LuminanceAlpha: LuminanceAlphaSVGFilter,
  DropShadow: DropShadowSVGFilter,
  SourceGraphic: SourceGraphicSVGFilter,
  SourceAlpha: SourceAlphaSVGFilter,
  BackgroundImage: BackgroundImageSVGFilter,
  BackgroundAlpha: BackgroundAlphaSVGFilter,
  FillPaint: FillPaintSVGFilter,
  StrokePaint: StrokePaintSVGFilter,
  ComponentTransfer: ComponentTransferSVGFilter,
  DistantLight: DistantLightSVGFilter,
  PointLight: PointLightSVGFilter,
  SpotLight: SpotLightSVGFilter,
  DiffuseLighting: DiffuseLightingSVGFilter,
  SpecularLighting: SpecularLightingSVGFilter,
  Blend: BlendSVGFilter,
  Offset: OffsetSVGFilter,
  RotaMatrix: RotaMatrixSVGFilter,
  GaussianBlur: GaussianBlurSVGFilter,
  Flood: FloodSVGFilter,
  Merge: MergeSVGFilter,
  Composite: CompositeSVGFilter,
  Morphology: MorphologySVGFilter,
  Turbulence: TurbulenceSVGFilter,
  DisplacementMap: DisplacementMapSVGFilter,
  ColorMatrix: ColorMatrixSVGFilter,
  ConvolveMatrix: ConvolveMatrixSVGFilter
};
const SVGFilterSpecList = {
  Image: ImageSVGFilter.spec,
  Tile: TileSVGFilter.spec,
  DropShadow: DropShadowSVGFilter.spec,
  Saturate: SaturateSVGFilter.spec,
  HueRotate: HueRotateSVGFilter.spec,
  LuminanceAlpha: LuminanceAlphaSVGFilter.spec,
  Offset: OffsetSVGFilter.spec,
  ComponentTransfer: ComponentTransferSVGFilter.spec,
  SpecularLighting: SpecularLightingSVGFilter.spec,
  SpotLight: SpotLightSVGFilter.spec,
  PointLight: PointLightSVGFilter.spec,
  DistantLight: DistantLightSVGFilter.spec,
  DiffuseLighting: DiffuseLightingSVGFilter.spec,
  Blend: BlendSVGFilter.spec,
  RotaMatrix: RotaMatrixSVGFilter.spec,
  Merge: MergeSVGFilter.spec,
  GaussianBlur: GaussianBlurSVGFilter.spec,
  Flood: FloodSVGFilter.spec,
  Morphology: MorphologySVGFilter.spec,
  Composite: CompositeSVGFilter.spec,
  Turbulence: TurbulenceSVGFilter.spec,
  DisplacementMap: DisplacementMapSVGFilter.spec,
  ColorMatrix: ColorMatrixSVGFilter.spec,
  ConvolveMatrix: ConvolveMatrixSVGFilter.spec
};
const WEBKIT_ATTRIBUTE_FOR_CSS = [
  "text-fill-color",
  "text-stroke-color",
  "text-stroke-width",
  "background-clip"
];
class DomRender$1 extends ItemRender$1 {
  toStringPropertyCSS(item2, field) {
    return STRING_TO_CSS(item2[field]);
  }
  toBackgroundImageCSS(item2) {
    if (!item2.cacheBackgroundImage) {
      item2.setBackgroundImageCache();
    }
    return item2.cacheBackgroundImage;
  }
  toLayoutCSS(item2) {
    item2.layout;
    if (item2.hasLayout()) {
      if (item2.isLayout(Layout.FLEX)) {
        return this.toFlexLayoutCSS(item2);
      } else if (item2.isLayout(Layout.GRID)) {
        return this.toGridLayoutCSS(item2);
      }
    }
    return {};
  }
  toLayoutItemCSS(item2) {
    var _a;
    var parentLayout = (_a = item2.parent) == null ? void 0 : _a["layout"];
    var obj2 = {};
    if (parentLayout === Layout.FLEX) {
      obj2 = {
        position: "static",
        left: "auto !important",
        top: "auto !important"
      };
    } else if (parentLayout === Layout.GRID) {
      obj2 = {
        position: "static",
        left: "auto !important",
        top: "auto !important",
        width: "auto !important",
        height: "auto !important"
      };
    } else if (parentLayout === Layout.DEFAULT) {
      obj2 = this.toDefaultLayoutItemCSS(item2);
    }
    if (parentLayout === Layout.FLEX) {
      obj2 = __spreadValues(__spreadValues({}, obj2), item2.attrs("flex-basis", "flex-grow", "flex-shrink"));
      if (item2.resizingHorizontal === ResizingMode.FILL_CONTAINER || item2.resizingVertical === ResizingMode.FILL_CONTAINER) {
        obj2["flex-grow"] = 1;
      }
    } else if (parentLayout === Layout.GRID) {
      obj2 = __spreadValues(__spreadValues({}, obj2), item2.attrs("grid-column-start", "grid-column-end", "grid-row-start", "grid-row-end"));
    }
    return obj2;
  }
  toDefaultLayoutItemCSS(item2) {
    var _a;
    const obj2 = {};
    if ((_a = item2.parent) == null ? void 0 : _a.is("project")) {
      return obj2;
    }
    const parentWidth = item2.parent.screenWidth;
    switch (item2[ConstraintsDirection.HORIZONTAL]) {
      case Constraints.MIN:
        obj2.left = Length.px(item2.x);
        obj2.right = "auto !important";
        break;
      case Constraints.MAX:
        obj2.right = Length.px(parentWidth - item2.offsetX - item2.screenWidth);
        obj2.left = "auto !important";
        break;
      case Constraints.STRETCH:
        obj2.left = Length.px(item2.x);
        obj2.right = Length.px(parentWidth - item2.offsetX - item2.screenWidth);
        break;
      case Constraints.CENTER:
        obj2.left = Length.px(item2.x);
        break;
      case Constraints.SCALE:
        obj2.left = Length.px(item2.x).toPercent(parentWidth);
        obj2.right = Length.px(parentWidth - item2.offsetX - item2.screenWidth).toPercent(parentWidth);
        break;
    }
    const parentHeight = item2.parent.screenHeight;
    switch (item2[ConstraintsDirection.VERTICAL]) {
      case Constraints.MIN:
        obj2.top = Length.px(item2.y);
        obj2.bottom = "auto !important";
        break;
      case Constraints.MAX:
        obj2.top = "auto !important";
        obj2.bottom = Length.px(parentHeight - item2.offsetY - item2.screenHeight);
        break;
      case Constraints.STRETCH:
        obj2.top = Length.px(item2.y);
        obj2.bottom = Length.px(parentHeight - item2.offsetY - item2.screenHeight);
        break;
      case Constraints.CENTER:
        obj2.top = Length.px(item2.y);
        break;
      case Constraints.SCALE:
        obj2.top = Length.px(item2.y).toPercent(parentHeight);
        obj2.bottom = Length.px(parentHeight - item2.offsetY - item2.screenHeight).toPercent(parentHeight);
        break;
    }
    return obj2;
  }
  toFlexLayoutCSS(item2) {
    if (item2.parent.isNot("project"))
      ;
    return __spreadProps(__spreadValues({
      display: "inline-flex"
    }, item2.attrs("flex-direction", "flex-wrap", "justify-content", "align-items", "align-content")), {
      gap: Length.px(item2.gap)
    });
  }
  toGridLayoutCSS(item2) {
    return __spreadProps(__spreadValues({
      display: "grid"
    }, item2.attrs("grid-template-columns", "grid-template-rows", "grid-template-areas", "grid-auto-columns", "grid-auto-rows", "grid-auto-flow")), {
      gap: Length.px(item2.gap)
    });
  }
  toBorderCSS(item2) {
    const obj2 = __spreadValues({}, STRING_TO_CSS(item2["border"]));
    return obj2;
  }
  toKeyCSS(key) {
    if (!item[key])
      return {};
    return {
      [key]: item[key]
    };
  }
  toBoxModelCSS(item2) {
    let obj2 = {};
    if (item2["margin-top"])
      obj2["margin-top"] = Length.px(item2["margin-top"]);
    if (item2["margin-bottom"])
      obj2["margin-bottom"] = Length.px(item2["margin-bottom"]);
    if (item2["margin-left"])
      obj2["margin-left"] = Length.px(item2["margin-left"]);
    if (item2["margin-right"])
      obj2["margin-right"] = Length.px(item2["margin-right"]);
    if (item2["padding-top"])
      obj2["padding-top"] = Length.px(item2["padding-top"]);
    if (item2["padding-bottom"])
      obj2["padding-bottom"] = Length.px(item2["padding-bottom"]);
    if (item2["padding-left"])
      obj2["padding-left"] = Length.px(item2["padding-left"]);
    if (item2["padding-right"])
      obj2["padding-right"] = Length.px(item2["padding-right"]);
    return obj2;
  }
  toKeyListCSS(item2, args2 = []) {
    let obj2 = {};
    args2.filter((it) => isNotUndefined(item2.json[it])).forEach((it) => {
      obj2[it] = item2.json[it];
    });
    return obj2;
  }
  toSizeCSS(item2) {
    var _a, _b;
    const obj2 = {};
    if (item2.isLayout(Layout.FLEX)) {
      switch (item2.resizingHorizontal) {
        case ResizingMode.FIXED:
          obj2.width = Length.px(item2.screenWidth);
          break;
      }
      switch (item2.resizingVertical) {
        case ResizingMode.FIXED:
          obj2.height = Length.px(item2.screenHeight);
          break;
      }
    } else if (item2.isInDefault()) {
      obj2.width = Length.px(item2.screenWidth);
      obj2.height = Length.px(item2.screenHeight);
    } else if (item2.isInFlex()) {
      const direction = item2.parent["flex-direction"];
      if (direction === FlexDirection.ROW || direction === FlexDirection.ROW_REVERSE) {
        obj2.width = Length.px(item2.screenWidth);
        obj2.height = Length.px(item2.screenHeight);
        if (item2.parent["align-items"] === AlignItems.STRETCH) {
          obj2.height = "auto";
        }
      } else {
        obj2.width = Length.px(item2.screenWidth);
        obj2.height = Length.px(item2.screenHeight);
        if (item2.parent["align-items"] === AlignItems.STRETCH) {
          obj2.width = "auto";
        }
      }
    } else if (item2.isInGrid())
      ;
    else {
      if ((_a = item2.right) == null ? void 0 : _a.isNotAuto) {
        if (!item2.x) {
          obj2.width = Length.px(item2.width);
        }
      } else {
        obj2.width = Length.px(item2.width);
      }
      if ((_b = item2.bottom) == null ? void 0 : _b.isNotAuto) {
        if (!item2.y) {
          obj2.height = Length.px(item2.height);
        }
      } else {
        obj2.height = Length.px(item2.height);
      }
    }
    return __spreadValues({}, obj2);
  }
  toDefaultCSS(item2) {
    let obj2 = {};
    if (item2.isAbsolute) {
      obj2.left = Length.px(item2.x);
      obj2.top = Length.px(item2.y);
    }
    let result = {};
    result = Object.assign(result, obj2);
    result = Object.assign(result, this.toKeyListCSS(item2, [
      "position",
      "overflow",
      "z-index",
      "box-sizing",
      "background-color",
      "color",
      "opacity",
      "mix-blend-mode",
      "transform-origin",
      "transform-style",
      "perspective",
      "perspective-origin",
      "font-size",
      "line-height",
      "font-weight",
      "font-family",
      "font-style",
      "text-align",
      "text-transform",
      "text-decoration",
      "letter-spacing",
      "word-spacing",
      "text-indent",
      "border-radius",
      "filter",
      "backdrop-filter",
      "box-shadow",
      "text-shadow",
      "offset-path",
      "animation",
      "transition"
    ]));
    return result;
  }
  toVariableCSS(item2) {
    const v = item2.computed("variable", (v2) => {
      let obj2 = {};
      v2.split(";").filter((it) => it.trim()).forEach((it) => {
        const [key, value] = it.split(":");
        obj2[`--${key}`] = value;
      });
      return obj2;
    });
    return v;
  }
  toRootVariableCSS(item2) {
    let obj2 = {};
    item2.rootVariable.split(";").filter((it) => it.trim()).forEach((it) => {
      const [key, value] = it.split(":");
      obj2[`--${key}`] = value;
    });
    return obj2;
  }
  toRootVariableString(item2) {
    return CSS_TO_STRING$1(this.toRootVariableCSS(item2));
  }
  toWebkitCSS(item2) {
    var results = {};
    WEBKIT_ATTRIBUTE_FOR_CSS.forEach((key) => {
      results[`-webkit-${key}`] = item2[key];
    });
    return results;
  }
  toTextClipCSS(item2) {
    let results = {};
    if (item2["text-clip"] === "text") {
      results["-webkit-background-clip"] = "text";
      results["-webkit-text-fill-color"] = "transparent";
      results["color"] = "transparent";
    }
    return results;
  }
  toTransformCSS(item2) {
    const results = {
      transform: item2["transform"]
    };
    if (results.transform === "rotateZ(0deg)") {
      delete results.transform;
    }
    return {
      transform: results.transform
    };
  }
  toDefInnerString(item2) {
    return `
      ${this.toClipPath(item2)}
      ${this.toSVGFilter(item2)}
    `.trim();
  }
  toClipPath(item2) {
    if (item2["clip-path"] === "")
      return "";
    if (!item2.cacheClipPathObject) {
      item2.setClipPathCache();
    }
    var obj2 = item2.cacheClipPathObject;
    var value = obj2.value;
    switch (obj2.type) {
      case "path":
        return `<clipPath id="${this.clipPathId(item2)}"><path d="${item2.clipPathString}" /></clipPath>`;
      case "svg":
        return `<clipPath id="${this.clipPathId(item2)}">${value}</clipPath>`;
    }
    return ``;
  }
  toClipPathCSS(item2) {
    let str = item2["clip-path"];
    if (Boolean(str) === false) {
      return null;
    }
    if (!item2.cacheClipPathObject) {
      item2.setClipPathCache();
    }
    var obj2 = item2.cacheClipPathObject;
    switch (obj2.type) {
      case "path":
        if (obj2.value) {
          str = `url(#${this.clipPathId(item2)})`;
        }
        break;
      case "svg":
        str = `url(#${this.clipPathId(item2)})`;
        break;
    }
    return {
      "clip-path": str
    };
  }
  innerSVGId(item2) {
    return item2.id + "inner-svg";
  }
  booleanId(item2) {
    return item2.id + "boolean";
  }
  clipPathId(item2) {
    return item2.id + "clip-path";
  }
  toDefString(item2) {
    var str = this.toDefInnerString(item2).trim();
    return str ? `
    <svg class='inner-svg-element' style="display:block" data-id="${this.innerSVGId(item2)}" width="0" height="0">
      <defs>
        ${str}
      </defs>
    </svg>
    ` : "";
  }
  toSelectorString(item2, prefix = "") {
    return item2.selectors.map((selector2) => selector2.toString(prefix)).join("\n\n");
  }
  generateView(item2, prefix = "", appendCSS = "") {
    var cssString = `
  ${prefix} {  /* ${item2.itemType} */
      ${CSS_TO_STRING$1(this.toCSS(item2), "\n    ")}; 
      ${appendCSS}
  }
  ${this.toNestedCSS(item2).map((it) => {
      return `${prefix} ${it.selector} { 
        ${it.cssText ? it.cssText : CSS_TO_STRING$1(it.css || {}, "\n		")}; 
    }`;
    }).join("\n")}
  ${this.toSelectorString(item2, prefix)}
    `;
    return cssString;
  }
  toCSS(item2) {
    return Object.assign({}, this.toVariableCSS(item2), this.toDefaultCSS(item2), this.toSizeCSS(item2), this.toClipPathCSS(item2), this.toWebkitCSS(item2), this.toTextClipCSS(item2), this.toBoxModelCSS(item2), this.toBorderCSS(item2), this.toBackgroundImageCSS(item2), this.toLayoutCSS(item2), this.toTransformCSS(item2), this.toLayoutItemCSS(item2));
  }
  toStyle(item2, renderer) {
    const cssString = this.generateView(item2, `[data-renderer-id='${renderer.id}'] .element-item[data-id='${item2.id}']`);
    return `
<style type='text/css' data-renderer-type="html" data-id='${item2.id}'>
${cssString}
</style>
    ` + item2.layers.map((it) => {
      return renderer.toStyle(it, renderer);
    }).join("");
  }
  toStyleData(item2, renderer) {
    const cssString = this.generateView(item2, `[data-renderer-id='${renderer.id}'] .element-item[data-id='${item2.id}']`);
    return {
      styleTag: `<style type='text/css' data-renderer-type="html" data-id='${item2.id}'>${cssString}</style>`,
      cssString
    };
  }
  toExportStyle(item2, renderer) {
    const cssString = this.generateView(item2, `.element-item[data-id='${item2.id}']`);
    return `
<style type='text/css' data-renderer-type="html" data-id='${item2.id}' data-timestamp='${item2.timestamp}'>
${cssString}
</style>
    ` + item2.layers.map((it) => {
      return renderer.toExportStyle(it, renderer);
    }).join("");
  }
  render(item2, renderer) {
    var { elementType, id, name: name2, itemType, isBooleanItem } = item2;
    const tagName = elementType || "div";
    return `<${tagName} class="element-item ${itemType}" data-is-boolean-item="${isBooleanItem}" data-id="${id}" data-title="${name2}">
  ${this.toDefString(item2)}
  ${item2.layers.map((it) => {
      return renderer.render(it, renderer);
    }).join("")}
</${tagName}>`;
  }
  toSVGFilter(item2) {
    var filterString = item2.computedValue("svgfilters");
    if (item2.hasChangedField("svgfilters") || !filterString) {
      filterString = item2.computed("svgfilters", (svgfilters) => {
        var filterString2 = svgfilters.map((svgfilter) => {
          return `
              <filter id='${svgfilter.id}'>
                ${svgfilter.filters.map((filter2) => SVGFilter.parse(filter2)).join("\n")}
              </filter>`;
        }).join("");
        return filterString2;
      }, true);
    }
    return filterString;
  }
  renderSVG(item2, renderer) {
  }
  toNestedCSS(item2) {
    const result = [];
    return result;
  }
  update(item2, currentElement) {
    if (!currentElement)
      return;
    let $svg = currentElement.el.$svg;
    currentElement.el.$booleanSvg;
    if (!$svg) {
      currentElement.el.$svg = currentElement.$(`[data-id="${this.innerSVGId(item2)}"]`);
      $svg = currentElement.el.$svg;
      currentElement.el.$booleanSvg = currentElement.$(`[data-id="${this.booleanId(item2)}"]`);
      currentElement.el.$booleanSvg;
    }
    if (currentElement.data("is-boolean-item") !== `${item2.isBooleanItem}`) {
      currentElement.attr("data-is-boolean-item", item2.isBooleanItem);
    }
    if ($svg) {
      const defString = this.toDefInnerString(item2);
      if (defString) {
        var $defs = $svg.$("defs");
        $defs.updateSVGDiff(`<defs>${defString}</defs>`);
      }
    } else {
      const defString = this.toDefString(item2);
      if (defString) {
        var a = Dom.createByHTML(defString);
        if (a) {
          currentElement.prepend(a);
        }
      }
    }
  }
}
class ArtBoardRender$2 extends DomRender$1 {
  render(item2, renderer) {
    var { id } = item2;
    return `    
      <div class="element-item artboard" data-id="${id}">
        ${this.toDefString(item2)}
        ${item2.layers.map((it) => {
      return renderer.render(it, renderer);
    }).join("\n	")}
      </div>
    `;
  }
  toBorderCSS(item2) {
    return {};
  }
}
class LayerRender$1 extends DomRender$1 {
}
class CircleRender$2 extends LayerRender$1 {
}
const faceKeys = [
  "front",
  "back",
  "left",
  "right",
  "top",
  "bottom"
];
class CubeRender extends LayerRender$1 {
  toDefaultCSS(item2) {
    let obj2 = {};
    if (item2.x)
      obj2.left = item2.x;
    if (item2.y)
      obj2.top = item2.y;
    obj2.visibility = item2.visible ? "visible" : "hidden";
    return __spreadValues(__spreadValues({}, obj2), this.toKeyListCSS(item2, [
      "position",
      "right",
      "bottom",
      "width",
      "height",
      "transform-origin",
      "transform",
      "transform-style",
      "perspective",
      "perspective-origin",
      "animation",
      "transition"
    ]));
  }
  toCSS(item2) {
    return __spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues({}, this.toVariableCSS(item2)), this.toDefaultCSS(item2)), this.toWebkitCSS(item2)), this.toBoxModelCSS(item2)), this.toLayoutItemCSS(item2));
  }
  toNestedCSS(item2) {
    var rate = item2.rate.value;
    var width2 = item2.width;
    var height2 = item2.height;
    var halfWidth = width2 / 2;
    var halfHeight = height2 / 2;
    var backfaceVisibility = item2["backface-visibility"];
    var css = __spreadValues(__spreadValues(__spreadValues(__spreadValues({}, this.toKeyListCSS(item2, [
      "filter",
      "mix-blend-mode",
      "border-radius",
      "background-color",
      "opacity",
      "color"
    ])), this.toClipPathCSS(item2)), this.toBackgroundImageCSS(item2)), this.toBorderCSS(item2));
    return [
      {
        selector: "div",
        cssText: `
          position: absolute;
          left: 0px;
          top: 0px;
          bottom: 0px;
          right: 0px;
          opacity: 1;
          pointer-events: none;
          ${CSS_TO_STRING$1(css)}
        `.trim()
      },
      {
        selector: ".front",
        cssText: `
          transform:rotateY(0deg) translateZ(${halfWidth * rate}px);
          width: ${width2};
          height: ${height2};     
          backface-visibility: ${backfaceVisibility};          
          ${item2["front.color"] ? `background-color: ${item2["front.color"]};` : ""}
          ${item2["front.background"] ? `${item2["front.background"]};` : ""}

        `.trim()
      },
      {
        selector: ".back",
        cssText: `
          transform: rotateY(180deg) translateZ(${halfWidth * rate}px);
          width: ${width2};
          height: ${height2};        
          backface-visibility: ${backfaceVisibility};              
          ${item2["back.color"] ? `background-color: ${item2["back.color"]};` : ""}                  
          ${item2["back.background"] ? `${item2["back.background"]};` : ""}
        `.trim()
      },
      {
        selector: ".left",
        cssText: `
          transform: rotateY(-90deg) translateZ(${halfWidth * rate}px);
          width: ${width2};
          height: ${height2};    
          backface-visibility: ${backfaceVisibility};          
          ${item2["left.color"] ? `background-color: ${item2["left.color"]};` : ""}                          
          ${item2["left.background"] ? `${item2["left.background"]};` : ""}
        `.trim()
      },
      {
        selector: ".right",
        cssText: `
          transform: rotateY(90deg) translateZ(${halfWidth * rate}px);
          width: ${width2};
          height: ${height2};      
          backface-visibility: ${backfaceVisibility};          
          ${item2["right.color"] ? `background-color: ${item2["right.color"]};` : ""}                        
          ${item2["right.background"] ? `${item2["right.background"]};` : ""}          
        `.trim()
      },
      {
        selector: ".top",
        cssText: `
          transform: rotateX(90deg) translateZ(${halfHeight * rate}px);
          top: ${halfHeight - halfWidth}px;
          width: ${width2};
          height: ${width2};
          backface-visibility: ${backfaceVisibility};          
          ${item2["top.color"] ? `background-color: ${item2["top.color"]};` : ""}      
          ${item2["top.background"] ? `${item2["top.background"]};` : ""}              
        `.trim()
      },
      {
        selector: ".bottom",
        cssText: `
          transform: rotateX(-90deg) translateZ(${halfHeight * rate}px);
          top: ${halfHeight - halfWidth}px;          
          width: ${width2};
          height: ${width2};    
          backface-visibility: ${backfaceVisibility};          
          ${item2["bottom.color"] ? `background-color: ${item2["bottom.color"]};` : ""}
          ${item2["bottom.background"] ? `${item2["bottom.background"]};` : ""}                          
        `.trim()
      }
    ];
  }
  render(item2) {
    var { id } = item2;
    return `
      <div class='element-item cube' data-id="${id}">
        ${this.toDefString(item2)}
        ${faceKeys.map((key) => {
      return `<div class='${key}'></div>`;
    }).join("")}
      </div>`;
  }
}
class ImageRender$2 extends LayerRender$1 {
  toNestedCSS(item2) {
    return [
      {
        selector: "img",
        cssText: `
                width: 100%;
                height: 100%;
                pointer-events: none;
                `.trim()
      }
    ];
  }
  getUrl(item2) {
    var { src } = item2;
    var project2 = item2.project;
    return project2.getImageValueById(src) || src;
  }
  render(item2) {
    var { id } = item2;
    return `
          <div class='element-item image' data-id="${id}">
            ${this.toDefString(item2)}
            <img src='${this.getUrl(item2)}' />
          </div>`;
  }
  update(item2, currentElement) {
    const $image = currentElement.$("img");
    if ($image) {
      $image.attr("src", this.getUrl(item2));
    }
    super.update(item2, currentElement);
  }
}
class ProjectRender$2 extends DomRender$1 {
  toRootVariableCSS(item2) {
    let obj2 = {};
    item2.rootVariable.split(";").filter((it) => it.trim()).forEach((it) => {
      var [key, value] = it.split(":");
      obj2[`--${key}`] = value;
    });
    return obj2;
  }
  toCSS(item2) {
    return Object.assign({}, ...this.toRootVariableCSS(item2));
  }
  toStyle(item2) {
    const keyframeString = item2.toKeyframeString();
    const rootVariable = this.toRootVariableCSS(item2);
    return `
<style type='text/css' data-renderer-type="html" data-id='${item2.id}'>
    :root {
        ${CSS_TO_STRING$1(rootVariable)}
    }
    /* keyframe */
    ${keyframeString}
</style>
        `;
  }
  toExportStyle(item2) {
    const keyframeString = item2.toKeyframeString();
    const rootVariable = this.toRootVariableCSS(item2);
    return `
<style type='text/css' data-renderer-type="html" data-id='${item2.id}'>
    :root {
        ${CSS_TO_STRING$1(rootVariable)}
    }
    /* keyframe */
    ${keyframeString}
</style>
        `;
  }
  render(item2, renderer) {
    return item2.layers.map((it) => {
      return renderer.render(it);
    }).join("");
  }
  renderSVG(item2, renderer) {
    return "";
  }
}
class RectRender$2 extends LayerRender$1 {
}
class SVGItemRender$2 extends LayerRender$1 {
  update(item2, currentElement) {
    this.updateElementCache(item2, currentElement);
    super.update(item2, currentElement);
  }
  updateElementCache(item2, currentElement) {
    if (item2.getCache("element") !== currentElement) {
      item2.addCache("element", currentElement);
      const $path = currentElement.$("path");
      item2.addCache("svgElement", $path.parent().el);
      item2.addCache("pathElement", $path.el);
    }
  }
  updateDefString(item2, currentElement) {
    var $defs = currentElement.$("defs");
    if ($defs) {
      $defs.updateSVGDiff(`<defs>${this.toDefInnerString(item2)}</defs>`);
    } else {
      var str = this.toDefString(item2).trim();
      currentElement.prepend(Dom.createByHTML(str));
    }
  }
  toDefInnerString(item2) {
    return `
            ${this.toFillSVG(item2)}
            ${this.toStrokeSVG(item2)}
        `;
  }
  fillId(item2) {
    return this.getInnerId(item2, "fill");
  }
  strokeId(item2) {
    return this.getInnerId(item2, "stroke");
  }
  cachedStroke(item2) {
    return item2.computed("stroke", (value) => {
      if (item2.isBooleanItem) {
        return SVGFill.parseImage("transparent");
      } else {
        return SVGFill.parseImage(value || "black");
      }
    });
  }
  cachedFill(item2) {
    return item2.computed("fill", (value) => {
      if (item2.isBooleanItem) {
        return SVGFill.parseImage("transparent");
      } else {
        return SVGFill.parseImage(value || "black");
      }
    });
  }
  toFillSVG(item2) {
    var _a;
    const fillValue = this.cachedFill(item2);
    return (_a = fillValue == null ? void 0 : fillValue.toSVGString) == null ? void 0 : _a.call(fillValue, this.fillId(item2), {
      width: item2.width,
      height: item2.height
    });
  }
  toStrokeSVG(item2) {
    var _a;
    const strokeValue = this.cachedStroke(item2);
    return (_a = strokeValue == null ? void 0 : strokeValue.toSVGString) == null ? void 0 : _a.call(strokeValue, this.strokeId(item2), {
      width: item2.width,
      height: item2.height
    });
  }
  toFillValue(item2) {
    var _a;
    const fillValue = this.cachedFill(item2);
    return (_a = fillValue == null ? void 0 : fillValue.toFillValue) == null ? void 0 : _a.call(fillValue, this.fillId(item2));
  }
  toFillOpacityValue(item2) {
    return Color.parse(item2.fill || "transparent").a;
  }
  toStrokeValue(item2) {
    var _a;
    const strokeValue = this.cachedStroke(item2);
    return (_a = strokeValue == null ? void 0 : strokeValue.toFillValue) == null ? void 0 : _a.call(strokeValue, this.strokeId(item2));
  }
  toFilterValue(item2) {
    if (!item2.svgfilter) {
      return "";
    }
    return `url(#${item2.svgfilter})`;
  }
  toLayoutCSS(item2) {
    return {};
  }
  toDefaultCSS(item2) {
    var _a;
    return Object.assign({}, super.toDefaultCSS(item2), this.toKeyListCSS(item2, [
      "stroke-width",
      "stroke-linecap",
      "stroke-linejoin",
      "stroke-dashoffset",
      "fill-opacity",
      "fill-rule",
      "text-anchor"
    ]), {
      "stroke-dasharray": (_a = item2["stroke-dasharray"]) == null ? void 0 : _a.join(" ")
    });
  }
  toSVGAttribute(item2) {
    return this.toDefaultCSS(item2);
  }
}
class SVGPathRender$2 extends SVGItemRender$2 {
  update(item2, currentElement) {
    if (!currentElement)
      return;
    const $path = currentElement.$("path");
    if ($path) {
      if (item2.hasChangedField("width", "height", "d")) {
        $path.setAttrNS({
          "d": item2.d
        });
      }
      if (item2.hasChangedField("fill")) {
        $path.setAttrNS({
          "fill": this.toFillValue(item2)
        });
      }
      if (item2.hasChangedField("stroke")) {
        $path.setAttrNS({
          "stroke": this.toStrokeValue(item2)
        });
      }
      if (item2.hasChangedField("filter")) {
        $path.setAttrNS({
          "filter": this.toFilterValue(item2)
        });
      }
      if (item2.hasChangedField("fill-rule")) {
        $path.setAttrNS({
          "fill-rule": item2["fill-rule"] || "nonezero"
        });
      }
      if (item2.hasChangedField("stroke-linejoin")) {
        $path.setAttrNS({
          "stroke-linejoin": item2["stroke-linejoin"]
        });
      }
      if (item2.hasChangedField("stroke-linecap")) {
        $path.setAttrNS({
          "stroke-linecap": item2["stroke-linecap"]
        });
      }
    }
    super.update(item2, currentElement);
  }
  render(item2) {
    var { id, name: name2, itemType } = item2;
    return `    
<div class="element-item ${itemType}" data-id="${id}" data-title="${name2}">
  ${this.toDefString(item2)}
  <svg xmlns="http://www.w3.org/2000/svg" class="view-path-item" width="100%" height="100%" overflow="visible">
    <path 
      class="svg-path-item"
      d="${item2.d}"
      fill-rule="${item2["fill-rule"]}"
      filter="${this.toFilterValue(item2)}"
      fill="${this.toFillValue(item2)}"
      stroke="${this.toStrokeValue(item2)}"
      stroke-linejoin="${item2["stroke-linejoin"]}"
      stroke-linecap="${item2["stroke-linecap"]}"
    />
  </svg>
</div>
    `;
  }
}
class SplineRender$2 extends SVGPathRender$2 {
  update(item2, currentElement) {
    if (!currentElement)
      return;
    var $path = currentElement.$("path");
    if ($path) {
      if (item2.hasChangedField("points", "boundary")) {
        $path.setAttrNS({
          "d": item2.d
        });
      }
    }
    super.update(item2, currentElement);
  }
}
class SVGPolygonRender$2 extends SVGItemRender$2 {
  update(item2, currentElement) {
    if (!currentElement)
      return;
    var $path = currentElement.$("path");
    if ($path) {
      if (item2.hasChangedField("width", "height", "count")) {
        $path.setAttrNS({
          "d": item2.d
        });
      }
      if (item2.hasChangedField("fill")) {
        $path.setAttrNS({
          "fill": this.toFillValue(item2)
        });
      }
      if (item2.hasChangedField("stroke")) {
        $path.setAttrNS({
          "stroke": this.toStrokeValue(item2)
        });
      }
      if (item2.hasChangedField("filter")) {
        $path.setAttrNS({
          "filter": this.toFilterValue(item2)
        });
      }
      if (item2.hasChangedField("fill-rule")) {
        $path.setAttrNS({
          "fill-rule": item2["fill-rule"] || "nonezero"
        });
      }
      if (item2.hasChangedField("stroke-linejoin")) {
        $path.setAttrNS({
          "stroke-linejoin": item2["stroke-linejoin"]
        });
      }
      if (item2.hasChangedField("stroke-linecap")) {
        $path.setAttrNS({
          "stroke-linecap": item2["stroke-linecap"]
        });
      }
    }
    super.update(item2, currentElement);
  }
  render(item2) {
    var { id, name: name2, itemType } = item2;
    return `    
<div class="element-item ${itemType}" data-id="${id}" data-title="${name2}">
  ${this.toDefString(item2)}
  <svg xmlns="http://www.w3.org/2000/svg" class="view-path-item" width="100%" height="100%" overflow="visible">
    <path 
      class="svg-path-item"
      d="${item2.d}"
      fill-rule="${item2["fill-rule"]}"
      filter="${this.toFilterValue(item2)}"
      fill="${this.toFillValue(item2)}"
      stroke="${this.toStrokeValue(item2)}"
      stroke-linejoin="${item2["stroke-linejoin"]}"
      stroke-linecap="${item2["stroke-linecap"]}"
    />
  </svg>
</div>
    `;
  }
}
class SVGStarRender$2 extends SVGItemRender$2 {
  update(item2, currentElement) {
    if (!currentElement)
      return;
    var $path = currentElement.$("path");
    if ($path) {
      if (item2.hasChangedField("width", "height", "count", "radius", "isCurve", "tension")) {
        $path.setAttrNS({
          "d": item2.d
        });
      }
      if (item2.hasChangedField("fill")) {
        $path.setAttrNS({
          "fill": this.toFillValue(item2)
        });
      }
      if (item2.hasChangedField("stroke")) {
        $path.setAttrNS({
          "stroke": this.toStrokeValue(item2)
        });
      }
      if (item2.hasChangedField("filter")) {
        $path.setAttrNS({
          "filter": this.toFilterValue(item2)
        });
      }
      if (item2.hasChangedField("fill-rule")) {
        $path.setAttrNS({
          "fill-rule": item2["fill-rule"] || "nonezero"
        });
      }
      if (item2.hasChangedField("stroke-linejoin")) {
        $path.setAttrNS({
          "stroke-linejoin": item2["stroke-linejoin"]
        });
      }
      if (item2.hasChangedField("stroke-linecap")) {
        $path.setAttrNS({
          "stroke-linecap": item2["stroke-linecap"]
        });
      }
    }
    super.update(item2, currentElement);
  }
  render(item2) {
    var { id, name: name2, itemType } = item2;
    return `    
<div class="element-item ${itemType}" data-id="${id}" data-title="${name2}">
  ${this.toDefString(item2)}
  <svg xmlns="http://www.w3.org/2000/svg" class="view-path-item" width="100%" height="100%" overflow="visible">
    <path 
      class="svg-path-item"
      d="${item2.d}"
      fill-rule="${item2["fill-rule"]}"
      filter="${this.toFilterValue(item2)}"
      fill="${this.toFillValue(item2)}"
      stroke="${this.toStrokeValue(item2)}"
      stroke-linejoin="${item2["stroke-linejoin"]}"
      stroke-linecap="${item2["stroke-linecap"]}"
    />
  </svg>
</div>
    `;
  }
}
class SVGTextPathRender$2 extends SVGItemRender$2 {
  update(item2, currentElement) {
    var $path = currentElement.$("path.svg-path-item");
    if ($path) {
      if (item2.hasChangedField("width", "height", "d")) {
        $path.attr("d", item2.d);
      }
    }
    var $guidePath = currentElement.$("path.guide");
    if ($guidePath) {
      if (item2.hasChangedField("width", "height", "d")) {
        $guidePath.attr("d", item2.d);
      }
    }
    var $textPath2 = currentElement.$("textPath");
    if ($textPath2) {
      if (item2.hasChangedField("text")) {
        $textPath2.text(item2.text);
      }
      if (item2.hasChangedField("textLength", "lengthAdjust", "startOffset")) {
        $textPath2.setAttrNS({
          textLength: item2.textLength,
          lengthAdjust: item2.lengthAdjust,
          startOffset: item2.startOffset
        });
      }
      if (item2.hasChangedField("fill")) {
        $textPath2.setAttrNS({
          fill: this.toFillValue(item2)
        });
      }
      if (item2.hasChangedField("stroke")) {
        $textPath2.setAttrNS({
          stroke: this.toStrokeValue(item2)
        });
      }
      if (item2.hasChangedField("filter")) {
        $textPath2.setAttrNS({
          filter: this.toFilterValue(item2)
        });
      }
    }
    super.update(item2, currentElement);
    item2.totalLength = $path.totalLength;
  }
  toDefInnerString(item2) {
    return `
        ${this.toPathSVG(item2)}
        ${this.toFillSVG(item2)}
        ${this.toStrokeSVG(item2)}
    `;
  }
  toPathId(item2) {
    return this.getInnerId(item2, "path");
  }
  toPathSVG(item2) {
    return `
    <path class="svg-path-item" id="${this.toPathId(item2)}" d="${item2.d}" fill="none" />
    `;
  }
  render(item2) {
    var { id, textLength, lengthAdjust, startOffset } = item2;
    const pathId = `#${this.toPathId(item2)}`;
    return `
      <svg class='element-item textpath' data-id="${id}">
        ${this.toDefString(item2)}
        <text class="svg-textpath-item">
          <textPath 
            xlink:href="${pathId}"
            textLength="${textLength}"
            lengthAdjust="${lengthAdjust}"
            startOffset="${startOffset}"
          >${item2.text}</textPath>
          <use href="${pathId}" stroke-width="1" stroke="black" />
        </text>
        <path class="guide" d="${item2.d}" stroke="rgba(0, 0, 0, 0.5)" fill="none"/>
      </svg>
    `;
  }
}
class SVGTextRender$2 extends SVGItemRender$2 {
  update(item2, currentElement) {
    var $text = currentElement.$("text");
    if ($text) {
      if (item2.hasChangedField("text")) {
        $textPath.text(item2.text);
      }
      if (item2.hasChangedField("textLength", "lengthAdjust", "startOffset")) {
        $textPath.setAttrNS({
          textLength: item2.textLength,
          lengthAdjust: item2.lengthAdjust,
          startOffset: item2.startOffset
        });
      }
      if (item2.hasChangedField("fill")) {
        $textPath.setAttrNS({
          fill: this.toFillValue(item2)
        });
      }
      if (item2.hasChangedField("stroke")) {
        $textPath.setAttrNS({
          stroke: this.toStrokeValue(item2)
        });
      }
      if (item2.hasChangedField("filter")) {
        $textPath.setAttrNS({
          filter: this.toFilterValue(item2)
        });
      }
    }
    super.update(item2, currentElement);
  }
  shapeInsideId(item2) {
    return this.getInnerId(item2, "shape-inside");
  }
  render(item2) {
    var { id, textLength, lengthAdjust } = item2;
    return `
  <svg class='element-item textpath' data-id="${id}">
    ${this.toDefString(item2)}
      <text class="svg-text-item" textLength="${textLength}" lengthAdjust="${lengthAdjust}">${item2.text}</text>
  </svg>`;
  }
}
class DomTemplateEngine {
  static compile(template, params = []) {
    return template;
  }
}
const EngineList = {
  "dom": DomTemplateEngine
};
class TemplateEngine {
  static compile(engine, template, params = []) {
    const currentEngine = EngineList[engine] || EngineList["dom"];
    return currentEngine.compile(template, params);
  }
}
class TemplateRender$2 extends LayerRender$1 {
  update(item2, currentElement) {
    if (item2.hasChangedField("x", "y", "width", "height") === false) {
      const compiledTemplate = this.compile(item2);
      let $innerHTML = currentElement.$(".inner-html");
      if ($innerHTML) {
        $innerHTML.updateDiff(compiledTemplate);
      }
    }
    super.update(item2, currentElement);
  }
  compile(item2) {
    return TemplateEngine.compile("dom", item2.template, item2.params);
  }
  render(item2) {
    var { id } = item2;
    const compiledTemplate = this.compile(item2);
    return `
      <div class='element-item template' data-id="${id}">
        ${this.toDefString(item2)}
        <style id="style-${id}">
          [data-id="${id}"] .inner-html {
            width: 100%; 
            height: 100%;
            position:relative;
            display:block;
            pointer-events: none; 
          }

          [data-id="${id}"] .inner-html > * {
            width: 100%; 
            height: 100%;
          }          
        </style>
        <div class="inner-html" data-domdiff-pass="true">
          ${compiledTemplate}
        </div>
      </div>`;
  }
}
class TextRender$2 extends LayerRender$1 {
  toCSS(item2) {
    let css = super.toCSS(item2);
    css.margin = css.margin || "0px";
    if (item2.parent.is("project")) {
      css.height = Length.px(item2.screenHeight);
    } else {
      if (item2.overflow !== Overflow.SCROLL) {
        css.height = "auto";
      }
    }
    return css;
  }
  update(item2, currentElement) {
    const $textElement = currentElement.$(`.text-content`);
    if ($textElement) {
      var { content: content2 } = item2;
      $textElement.updateDiff(content2);
    }
    super.update(item2, currentElement);
  }
  render(item2) {
    var { id, content: content2 } = item2;
    return `
            <div class='element-item text' data-id="${id}">
                ${this.toDefString(item2)}
                <div class="text-content" tabIndex="-1" data-id="${id}">${content2}</div>
            </div>
        `;
  }
}
class VideoRender$2 extends LayerRender$1 {
  toNestedCSS(item2) {
    return [
      {
        selector: "video",
        cssText: `
                width: 100%;
                height: 100%;
                pointer-events: none;
                `.trim()
      }
    ];
  }
  getUrl(item2) {
    var { src } = item2;
    var project2 = item2.project;
    return project2.getVideoValueById(src);
  }
  render(item2) {
    var {
      id,
      controls,
      muted,
      poster,
      loop,
      crossorigin,
      autoplay
    } = item2;
    return `
        <div class='element-item video' data-id="${id}">
            ${this.toDefString(item2)}
            <video 
                controls="${controls}"
                src="${this.getUrl(item2)}
                muted="${muted}"
                poster="${poster}"
                loop="${loop}"
                crossorigin="${crossorigin}"
                autoplay="${autoplay}"
            >
                Sorry, your browser doesn't support embedded videos.
            </video>
        </div>`;
  }
  update(item2, currentElement) {
    const { currentTime, playbackRate, volume } = item2;
    const $video = currentElement.$("video");
    if ($video) {
      $video.setProp({
        currentTime,
        playbackRate,
        volume
      });
    }
    super.update(item2, currentElement);
  }
}
class BooleanPathRender$2 extends SVGItemRender$2 {
  toFillSVG(item2) {
    const layers2 = item2.layers;
    const op = item2["boolean-operation"];
    switch (op) {
      case BooleanOperation.DIFFERENCE:
        return SVGFill.parseImage(layers2[1].fill || "transparent").toSVGString(this.fillId(item2));
    }
    return SVGFill.parseImage(layers2[0].fill || "transparent").toSVGString(this.fillId(item2));
  }
  toStrokeSVG(item2) {
    const layers2 = item2.layers;
    const op = item2["boolean-operation"];
    switch (op) {
      case BooleanOperation.DIFFERENCE:
        return SVGFill.parseImage(layers2[1].stroke || "transparent").toSVGString(this.strokeId(item2));
    }
    return SVGFill.parseImage(layers2[0].stroke || "black").toSVGString(this.strokeId(item2));
  }
  toFillValue(item2) {
    var _a, _b;
    const layers2 = item2.layers;
    const op = item2["boolean-operation"];
    switch (op) {
      case BooleanOperation.DIFFERENCE:
        return SVGFill.parseImage(layers2[1].fill || "transparent").toSVGString(this.fillId(item2));
    }
    return (_b = (_a = SVGFill.parseImage(layers2[0].fill || "transparent")).toFillValue) == null ? void 0 : _b.call(_a, this.fillId(item2));
  }
  toFillOpacityValue(item2) {
    return Color.parse(item2.fill || "transparent").a;
  }
  toStrokeValue(item2) {
    var _a, _b, _c, _d;
    const layers2 = item2.layers;
    const op = item2["boolean-operation"];
    switch (op) {
      case BooleanOperation.DIFFERENCE:
        return (_b = (_a = SVGFill.parseImage(layers2[1].stroke || "transparent")).toFillValue) == null ? void 0 : _b.call(_a, this.strokeId(item2));
    }
    return (_d = (_c = SVGFill.parseImage(layers2[0].stroke || "black")).toFillValue) == null ? void 0 : _d.call(_c, this.strokeId(item2));
  }
  update(item2, currentElement) {
    if (!currentElement)
      return;
    const $path = currentElement.$(`[data-boolean-path-id="${item2.id}"]`);
    if ($path) {
      if (item2.hasChangedField("changedChildren", "d", "boolean-operation", "width", "height")) {
        $path.setAttrNS({
          "d": item2.d
        });
      }
      if (item2.hasChangedField("fill")) {
        $path.setAttrNS({
          "fill": this.toFillValue(item2)
        });
      }
      if (item2.hasChangedField("stroke")) {
        $path.setAttrNS({
          "stroke": this.toStrokeValue(item2)
        });
      }
      if (item2.hasChangedField("filter")) {
        $path.setAttrNS({
          "filter": this.toFilterValue(item2)
        });
      }
      if (item2.hasChangedField("fill-rule")) {
        $path.setAttrNS({
          "fill-rule": item2["fill-rule"] || "nonezero"
        });
      }
      if (item2.hasChangedField("stroke-linejoin")) {
        $path.setAttrNS({
          "stroke-linejoin": item2["stroke-linejoin"]
        });
      }
      if (item2.hasChangedField("stroke-linecap")) {
        $path.setAttrNS({
          "stroke-linecap": item2["stroke-linecap"]
        });
      }
    }
    super.update(item2, currentElement);
  }
  updateElementCache(item2, currentElement) {
    if (item2.getCache("element") !== currentElement) {
      item2.addCache("element", currentElement);
      const $path = currentElement.$(`[data-boolean-path-id="${item2.id}"]`);
      item2.addCache("svgElement", $path.parent().el);
      item2.addCache("pathElement", $path.el);
    }
  }
  render(item2, renderer) {
    var { id, name: name2, itemType } = item2;
    return `    
<div class="element-item ${itemType}" data-id="${id}" data-title="${name2}">
  ${this.toDefString(item2)}
  ${item2.layers.map((it) => {
      return renderer.render(it, renderer);
    }).join("")}
  <svg xmlns="http://www.w3.org/2000/svg" class="boolean-path-item" width="100%" height="100%" overflow="visible">
    <path 
      class="svg-path-item"
      d="${item2.d}"
      data-boolean-path-id="${id}" 
      fill-rule="${item2["fill-rule"]}"
      filter="${this.toFilterValue(item2)}"
      fill="${this.toFillValue(item2)}"
      stroke="${this.toStrokeValue(item2)}"
      stroke-linejoin="${item2["stroke-linejoin"]}"
      stroke-linecap="${item2["stroke-linecap"]}"
    />
  </svg>
</div>
    `;
  }
}
function rendererHtml(editor) {
  editor.registerRendererType("html", new HTMLRenderer(editor));
  editor.registerRenderer("html", "project", new ProjectRender$2());
  editor.registerRenderer("html", "artboard", new ArtBoardRender$2());
  editor.registerRenderer("html", "rect", new RectRender$2());
  editor.registerRenderer("html", "circle", new CircleRender$2());
  editor.registerRenderer("html", "image", new ImageRender$2());
  editor.registerRenderer("html", "text", new TextRender$2());
  editor.registerRenderer("html", "video", new VideoRender$2());
  editor.registerRenderer("html", "boolean-path", new BooleanPathRender$2());
  editor.registerRenderer("html", "svg-path", new SVGPathRender$2());
  editor.registerRenderer("html", "polygon", new SVGPolygonRender$2());
  editor.registerRenderer("html", "star", new SVGStarRender$2());
  editor.registerRenderer("html", "spline", new SplineRender$2());
  editor.registerRenderer("html", "svg-text", new SVGTextRender$2());
  editor.registerRenderer("html", "svg-textpath", new SVGTextPathRender$2());
  editor.registerRenderer("html", "cube", new CubeRender());
  editor.registerRenderer("html", "template", new TemplateRender$2());
}
class JSONRenderer {
  constructor(editor) {
    this.editor = editor;
  }
  getDefaultRendererInstance() {
    return this.editor.getRendererInstance("json", "rect");
  }
  getRendererInstance(item2) {
    return this.editor.getRendererInstance("json", item2.itemType) || this.getDefaultRendererInstance() || item2;
  }
  async render(item2, renderer) {
    if (!item2)
      return;
    const currentRenderer = this.getRendererInstance(item2);
    if (currentRenderer) {
      return await currentRenderer.render(item2, renderer || this);
    }
  }
  async renderAll(items, renderer) {
    return await Promise.all(items.map(async (it) => {
      return await this.render(it, renderer);
    }));
  }
  async getResourceDataURI(item2, renderer) {
  }
}
class ItemRender {
  async render(item2, renderer) {
    return await this.toCloneObject(item2, renderer);
  }
  async toCloneObject(item2, renderer) {
    var json = item2.attrs("itemType", "name", "elementType", "type", "visible", "lock", "selected");
    if (item2.parent && item2.parent.isNot("project")) {
      json.parentId = item2.parentId;
    }
    json.referenceId = item2.id;
    json.newTargetId = uuid$1();
    let layers2 = [];
    for (var i = 0, len2 = item2.layers.length; i < len2; i++) {
      layers2.push(await renderer.render(item2.layers[i], renderer));
    }
    json.layers = layers2;
    return json;
  }
}
class BaseAssetRender extends ItemRender {
  async toCloneObject(item2, renderer) {
    return __spreadValues(__spreadValues({}, await super.toCloneObject(item2, renderer)), item2.attrs("svgfilters", "keyframes"));
  }
}
class GroupRender extends BaseAssetRender {
  async toCloneObject(item2, renderer) {
    return __spreadValues(__spreadValues({}, await super.toCloneObject(item2, renderer)), item2.attrs("layout", "constraints-horizontal", "constraints-vertical", "resizingMode", "flex-direction", "flex-wrap", "flex-flow", "justify-content", "align-items", "align-content", "order", "flex-basis", "flex-grow", "flex-shrink", "gap", "grid-template-rows", "grid-template-columns", "grid-template-areas", "grid-auto-rows", "grid-auto-columns", "grid-auto-flow", "animation", "transition", "padding-top", "padding-right", "padding-left", "padding-bottom"));
  }
}
class MovableRender extends GroupRender {
  async toCloneObject(item2, renderer) {
    return __spreadValues(__spreadValues({}, await super.toCloneObject(item2, renderer)), item2.attrs("x", "y", "right", "bottom", "width", "height", "angle", "transform-origin"));
  }
}
class DomRender extends MovableRender {
  async toCloneObject(item2, renderer) {
    return __spreadProps(__spreadValues(__spreadValues({}, await super.toCloneObject(item2, renderer)), item2.attrs("position", "rootVariable", "variable", "filter", "backdrop-filter", "background-color", "background-image", "text-clip", "border-radius", "border", "box-shadow", "text-shadow", "clip-path", "color", "font-size", "line-height", "text-align", "text-transform", "text-decoration", "letter-spacing", "word-spacing", "text-indent", "perspective-origin", "transform-style", "perspective", "mix-blend-mode", "overflow", "opacity", "animation", "transition")), {
      selectors: item2.selectors.map((selector2) => selector2.clone()),
      svg: item2.svg.map((svg) => svg.clone())
    });
  }
}
class ArtBoardRender$1 extends DomRender {
  async toCloneObject(item2, renderer) {
    return __spreadValues(__spreadValues({}, await super.toCloneObject(item2, renderer)), item2.attrs("name"));
  }
}
class LayerRender extends DomRender {
  async toCloneObject(item2, renderer) {
    return __spreadValues(__spreadValues({}, await super.toCloneObject(item2, renderer)), item2.attrs("tagName"));
  }
}
class CircleRender$1 extends LayerRender {
}
class IFrameRender$1 extends LayerRender {
  async toCloneObject(item2, renderer) {
    return __spreadValues(__spreadValues({}, await super.toCloneObject(item2, renderer)), item2.attrs("src"));
  }
}
class ImageRender$1 extends LayerRender {
  async toCloneObject(item2, renderer) {
    const project2 = item2.project;
    const image2 = project2.imageKeys[item2.src];
    const src = image2.original;
    return __spreadProps(__spreadValues({}, await super.toCloneObject(item2, renderer)), {
      src
    });
  }
}
class AssetRender extends ItemRender {
  async toCloneObject(item2, renderer) {
    return __spreadValues(__spreadValues({}, await super.toCloneObject(item2, renderer)), item2.attrs("colors", "gradients", "svgfilters", "svgimages", "images", "keyframes"));
  }
}
class TimelineRender extends AssetRender {
  async toCloneObject(item2, renderer) {
    return __spreadValues(__spreadValues({}, await super.toCloneObject(item2, renderer)), item2.attrs("timeline"));
  }
}
class ProjectRender$1 extends TimelineRender {
  async toCloneObject(item2, renderer) {
    return __spreadValues(__spreadValues({}, await super.toCloneObject(item2, renderer)), item2.attrs("name", "description", "rootVariable"));
  }
}
class RectRender$1 extends LayerRender {
}
class SVGItemRender$1 extends LayerRender {
  async toCloneObject(item2, renderer) {
    return __spreadValues(__spreadValues({}, await super.toCloneObject(item2, renderer)), item2.attrs("overflow", "stroke", "stroke-width", "svgfilter", "fill", "fill-rule", "fill-opacity", "stroke-linecap", "stroke-linejoin", "stroke-dashoffset", "stroke-dasharray", "text-anchor"));
  }
}
class SVGPathRender$1 extends SVGItemRender$1 {
  async toCloneObject(item2, renderer) {
    return __spreadValues(__spreadValues({}, await super.toCloneObject(item2, renderer)), item2.attrs("d"));
  }
}
class SVGTextPathRender$1 extends SVGItemRender$1 {
  async toCloneObject(item2, renderer) {
    return __spreadValues(__spreadValues({}, await super.toCloneObject(item2, renderer)), item2.attrs("totalLength", "d", "text", "textLength", "lengthAdjust", "startOffset"));
  }
}
class SVGTextRender$1 extends SVGItemRender$1 {
  async toCloneObject(item2, renderer) {
    return __spreadValues(__spreadValues({}, await super.toCloneObject(item2, renderer)), item2.attrs("totalLength", "text", "textLength", "lengthAdjust", "shape-inside"));
  }
}
class TemplateRender$1 extends LayerRender {
  async toCloneObject(item2, renderer) {
    return __spreadValues(__spreadValues({}, await super.toCloneObject(item2, renderer)), item2.attrs("engine", "template", "params"));
  }
}
class TextRender$1 extends LayerRender {
  async toCloneObject(item2, renderer) {
    return __spreadValues(__spreadValues({}, await super.toCloneObject(item2, renderer)), item2.attrs("content"));
  }
}
class VideoRender$1 extends LayerRender {
  async toCloneObject(item2, renderer) {
    return __spreadValues(__spreadValues({}, await super.toCloneObject(item2, renderer)), item2.attrs("src"));
  }
}
class SVGPolygonRender$1 extends SVGItemRender$1 {
  async toCloneObject(item2, renderer) {
    return __spreadValues(__spreadValues({}, await super.toCloneObject(item2, renderer)), item2.attrs("count"));
  }
}
class SVGStarRender$1 extends SVGItemRender$1 {
  async toCloneObject(item2, renderer) {
    return __spreadValues(__spreadValues({}, await super.toCloneObject(item2, renderer)), item2.attrs("count", "radius"));
  }
}
class SplineRender$1 extends SVGItemRender$1 {
  async toCloneObject(item2, renderer) {
    return __spreadValues(__spreadValues({}, await super.toCloneObject(item2, renderer)), item2.attrs("points", "boundary"));
  }
}
class BooleanPathRender$1 extends SVGItemRender$1 {
  async toCloneObject(item2, renderer) {
    return __spreadValues(__spreadValues({}, await super.toCloneObject(item2, renderer)), item2.attrs("d", "boolean-operation"));
  }
}
function rendererJson(editor) {
  editor.registerRendererType("json", new JSONRenderer(editor));
  editor.registerRenderer("json", "project", new ProjectRender$1());
  editor.registerRenderer("json", "artboard", new ArtBoardRender$1());
  editor.registerRenderer("json", "rect", new RectRender$1());
  editor.registerRenderer("json", "circle", new CircleRender$1());
  editor.registerRenderer("json", "image", new ImageRender$1());
  editor.registerRenderer("json", "template", new TemplateRender$1());
  editor.registerRenderer("json", "iframe", new IFrameRender$1());
  editor.registerRenderer("json", "text", new TextRender$1());
  editor.registerRenderer("json", "video", new VideoRender$1());
  editor.registerRenderer("json", "svg-path", new SVGPathRender$1());
  editor.registerRenderer("json", "boolean-path", new BooleanPathRender$1());
  editor.registerRenderer("json", "polygon", new SVGPolygonRender$1());
  editor.registerRenderer("json", "star", new SVGStarRender$1());
  editor.registerRenderer("json", "spline", new SplineRender$1());
  editor.registerRenderer("json", "svg-text", new SVGTextRender$1());
  editor.registerRenderer("json", "svg-textpath", new SVGTextPathRender$1());
}
class SVGRenderer {
  constructor(editor) {
    this.editor = editor;
  }
  getDefaultRendererInstance() {
    return this.editor.getRendererInstance("svg", "rect");
  }
  getRendererInstance(item2) {
    return this.editor.getRendererInstance("svg", item2.itemType) || this.getDefaultRendererInstance() || item2;
  }
  render(item2, renderer) {
    if (!item2)
      return "";
    const currentRenderer = this.getRendererInstance(item2);
    if (currentRenderer) {
      return currentRenderer.render(item2, renderer || this);
    }
  }
  toCSS(item2) {
    const currentRenderer = this.getRendererInstance(item2);
    if (currentRenderer) {
      return currentRenderer.toCSS(item2);
    }
  }
  toTransformCSS(item2) {
    const currentRenderer = this.getRendererInstance(item2);
    if (currentRenderer) {
      return currentRenderer.toTransformCSS(item2);
    }
  }
  toStyle(item2, renderer) {
    const currentRenderer = this.getRendererInstance(item2);
    if (currentRenderer) {
      return currentRenderer.toStyle(item2, renderer || this);
    }
  }
  update(item2, currentElement) {
    const currentRenderer = this.getRendererInstance(item2);
    if (currentRenderer) {
      return currentRenderer.update(item2, currentElement);
    }
  }
  codeview(item2) {
    if (!item2) {
      return "";
    }
    let svgCode = this.render(item2);
    svgCode = svgCode.replace(/\</g, "&lt;").replace(/\>/g, "&gt;");
    return `
<div class='svg-code'>
${svgCode && `<div><pre title='SVG'>${svgCode}</pre></div>`}
</div>
        `;
  }
}
class SVGRender extends DomRender$1 {
  toDefaultCSS(item2) {
    return __spreadValues({
      overflow: "visible"
    }, this.toKeyListCSS(item2, [
      "font-size",
      "line-height",
      "font-weight",
      "font-family",
      "font-style",
      "text-align",
      "text-transform",
      "text-decoration",
      "letter-spacing",
      "word-spacing",
      "text-indent",
      "background-color",
      "border-radius",
      "transform-style",
      "filter",
      "filter",
      "backdrop-filter",
      "box-shadow",
      "text-shadow",
      "animation",
      "transition"
    ]));
  }
  toCSS(item2) {
    const css = Object.assign({}, this.toVariableCSS(item2), this.toDefaultCSS(item2), this.toClipPathCSS(item2), this.toWebkitCSS(item2), this.toTextClipCSS(item2), this.toTransformCSS(item2), this.toLayoutItemCSS(item2), this.toBorderCSS(item2), this.toBackgroundImageCSS(item2), this.toLayoutCSS(item2));
    delete css.left;
    delete css.top;
    delete css.width;
    delete css.height;
    delete css.position;
    return css;
  }
  toSVGAttribute(item2) {
    var _a;
    return __spreadValues(__spreadValues(__spreadValues({}, this.toDefaultCSS(item2)), this.toKeyListCSS(item2, [
      "stroke-width",
      "stroke-linecap",
      "stroke-linejoin",
      "stroke-dashoffset",
      "fill-opacity",
      "fill-rule",
      "text-anchor"
    ])), {
      "stroke-dasharray": (_a = item2["stroke-dasharray"]) == null ? void 0 : _a.join(" ")
    });
  }
  wrappedRender(item2, callback) {
    const { id, x: x2, y: y2, width: width2, height: height2, itemType } = item2;
    return `

<svg class='svg-element-item ${itemType}'
    xmlns="http://www.w3.org/2000/svg"
    data-id="${id}"
    x="${x2}"
    y="${y2}"
    width="${width2}"
    height="${height2}"
    viewBox="0 0 ${width2} ${height2}"
    overflow="visible"
>
    ${this.toDefString(item2)}
    ${isFunction(callback) && callback()}
</svg>
        `;
  }
  render(item2, renderer) {
    const { width: width2, height: height2, elementType } = item2;
    const tagName = elementType || "div";
    let css = this.toCSS(item2);
    return this.wrappedRender(item2, () => {
      return `
<foreignObject 
    width="${width2}"
    height="${height2}"
    overflow="visible"
>
    <${tagName} xmlns="http://www.w3.org/1999/xhtml" style="${CSS_TO_STRING$1(css)};width:100%;height:100%;"></${tagName}>
</foreignObject>    
${item2.layers.map((it) => {
        return renderer.render(it, renderer);
      }).join("")}
            `;
    });
  }
}
class ArtBoardRender extends SVGRender {
  toCSS(item2) {
    const css = Object.assign({}, this.toDefaultCSS(item2), this.toClipPathCSS(item2), this.toWebkitCSS(item2), this.toTextClipCSS(item2), this.toBackgroundImageCSS(item2));
    delete css.left;
    delete css.top;
    delete css.width;
    delete css.height;
    delete css.position;
    return css;
  }
  render(item2, renderer, encoding = true) {
    const { x: x2, y: y2, width: width2, height: height2 } = item2;
    let css = this.toCSS(item2);
    return `
${encoding ? `<?xml version="1.0"?>` : ""}
<svg 
    xmlns="http://www.w3.org/2000/svg"
    width="${width2}"
    height="${height2}"
    viewBox="0 0 ${width2} ${height2}"
    style="${CSS_TO_STRING$1(css)}"
>
    ${this.toDefString(item2)}
    ${item2.layers.map((it) => {
      return renderer.render(it, renderer);
    }).join("")}
</svg>      
        `;
  }
}
class SVGLayerRender extends SVGRender {
}
class CircleRender extends SVGLayerRender {
}
class IFrameRender extends SVGLayerRender {
  update(item2, currentElement) {
    let $iframe = currentElement.$("iframe");
    if ($iframe) {
      $iframe.attr("src", item2.url || "about:blank");
    }
    super.update(item2, currentElement);
  }
  render(item2) {
    const { width: width2, height: height2, id, url = "about:blank" } = item2;
    let css = this.toCSS(item2);
    return this.wrappedRender(item2, () => {
      return `
  <foreignObject
      width="${width2}"
      height="${height2}"
  >
      <iframe 
          xmlns="http://www.w3.org/1999/xhtml"
          width="100%" 
          height="100%" 
          style="border:0px;width:100%;height:100%;pointer-events:none; ${CSS_TO_STRING$1(css)}" 
          src="${url}"
      ></iframe>
  </foreignObject>              
          `;
    });
  }
}
class ImageRender extends SVGLayerRender {
  getUrl(item2) {
    var { src } = item2;
    var project2 = item2.project;
    return project2.getImageValueById(src);
  }
  render(item2) {
    const { width: width2, height: height2 } = item2;
    let css = this.toCSS(item2);
    return this.wrappedRender(item2, () => {
      return `
            <foreignObject
                width="${width2}"
                height="${height2}"
            >
                <div xmlns="http://www.w3.org/1999/xhtml">
                    <img src='${this.getUrl(item2)}' style="width:100%;height:100%; ${CSS_TO_STRING$1(css)}"  />
                </div>
            </foreignObject>              
          `;
    });
  }
  update(item2, currentElement) {
    const $image = currentElement.$("img");
    if ($image) {
      $image.attr("src", this.getUrl(item2));
    }
    super.update(item2, currentElement);
  }
}
class ProjectRender extends SVGRender {
  render(item2, renderer) {
    return item2.artboards.map((it) => {
      return renderer.render(it, renderer);
    });
  }
}
class RectRender extends SVGLayerRender {
}
class SVGItemRender extends SVGLayerRender {
  updateDefString(item2, currentElement) {
    var $defs = currentElement.$("defs");
    if ($defs) {
      $defs.html(this.toDefInnerString(item2));
    } else {
      var str = this.toDefString(item2).trim();
      currentElement.prepend(Dom.createByHTML(str));
    }
  }
  toDefInnerString(item2) {
    return `
            ${this.toFillSVG(item2)}
            ${this.toStrokeSVG(item2)}
        `;
  }
  toDefString(item2) {
    const str = this.toDefInnerString(item2).trim();
    return `
            <defs>
            ${str}
            </defs>
        `;
  }
  fillId(item2) {
    return this.getInnerId(item2, "fill");
  }
  strokeId(item2) {
    return this.getInnerId(item2, "stroke");
  }
  toFillSVG(item2) {
    return SVGFill.parseImage(item2.fill || "transparent").toSVGString(this.fillId(item2));
  }
  toStrokeSVG(item2) {
    return SVGFill.parseImage(item2.stroke || "black").toSVGString(this.strokeId(item2));
  }
  toFillValue(item2) {
    return SVGFill.parseImage(item2.fill || "transparent").toFillValue(this.fillId(item2));
  }
  toFillOpacityValue(item2) {
    return Color.parse(item2.fill || "transparent").a;
  }
  toStrokeValue(item2) {
    return SVGFill.parseImage(item2.stroke || "black").toFillValue(this.strokeId(item2));
  }
  toFilterValue(item2) {
    if (!item2.svgfilter) {
      return "";
    }
    return `url(#${item2.svgfilter})`;
  }
  toLayoutCSS(item2) {
    return {};
  }
}
class SplineRender extends SVGItemRender {
  update(item2, currentElement) {
    if (!currentElement)
      return;
    var $path = currentElement.$("path");
    if ($path) {
      $path.setAttr({
        "d": item2.d,
        "filter": this.toFilterValue(item2),
        "fill": this.toFillValue(item2),
        "stroke": this.toStrokeValue(item2)
      });
    }
    this.updateDefString(item2, currentElement);
  }
  render(item2) {
    var { d } = item2;
    return this.wrappedRender(item2, () => {
      return `
<path ${OBJECT_TO_PROPERTY$1(__spreadProps(__spreadValues({
        "class": "spline-item",
        d,
        filter: this.toFilterValue(item2),
        fill: this.toFillValue(item2),
        stroke: this.toStrokeValue(item2)
      }, this.toSVGAttribute(item2)), {
        style: CSS_TO_STRING$1(this.toCSS(item2))
      }))} />
    `;
    });
  }
}
class SVGPathRender extends SVGItemRender {
  update(item2, currentElement) {
    if (!currentElement)
      return;
    var $path = currentElement.$("path");
    if ($path) {
      $path.setAttr({
        "d": item2.d,
        "filter": this.toFilterValue(item2),
        "fill": this.toFillValue(item2),
        "stroke": this.toStrokeValue(item2)
      });
      item2.totalLength = $path.totalLength;
    }
    this.updateDefString(item2, currentElement);
  }
  render(item2) {
    var { d } = item2;
    return this.wrappedRender(item2, () => {
      return `
<path ${OBJECT_TO_PROPERTY$1(__spreadProps(__spreadValues({
        "class": "svg-path-item",
        d,
        filter: this.toFilterValue(item2),
        fill: this.toFillValue(item2),
        stroke: this.toStrokeValue(item2)
      }, this.toSVGAttribute(item2)), {
        style: CSS_TO_STRING$1(this.toCSS(item2))
      }))} />
    `;
    });
  }
}
class SVGPolygonRender extends SVGItemRender {
  update(item2, currentElement) {
    if (!currentElement)
      return;
    var $path = currentElement.$("path");
    if ($path) {
      $path.setAttr({
        "d": item2.d,
        "filter": this.toFilterValue(item2),
        "fill": this.toFillValue(item2),
        "stroke": this.toStrokeValue(item2)
      });
    }
    this.updateDefString(item2, currentElement);
  }
  render(item2) {
    var { d } = item2;
    return this.wrappedRender(item2, () => {
      return `
<path ${OBJECT_TO_PROPERTY$1(__spreadProps(__spreadValues({
        "class": "polygon-item",
        d,
        filter: this.toFilterValue(item2),
        fill: this.toFillValue(item2),
        stroke: this.toStrokeValue(item2)
      }, this.toSVGAttribute(item2)), {
        style: CSS_TO_STRING$1(this.toCSS(item2))
      }))} />
    `;
    });
  }
}
class SVGStarRender extends SVGItemRender {
  update(item2, currentElement) {
    if (!currentElement)
      return;
    var $path = currentElement.$("path");
    if ($path) {
      $path.setAttr({
        "d": item2.d,
        "filter": this.toFilterValue(item2),
        "fill": this.toFillValue(item2),
        "stroke": this.toStrokeValue(item2)
      });
    }
    this.updateDefString(item2, currentElement);
  }
  render(item2) {
    var { d } = item2;
    return this.wrappedRender(item2, () => {
      return `
<path ${OBJECT_TO_PROPERTY$1(__spreadProps(__spreadValues({
        "class": "star-item",
        d,
        filter: this.toFilterValue(item2),
        fill: this.toFillValue(item2),
        stroke: this.toStrokeValue(item2)
      }, this.toSVGAttribute(item2)), {
        style: CSS_TO_STRING$1(this.toCSS(item2))
      }))} />
    `;
    });
  }
}
class SVGTextPathRender extends SVGItemRender {
  update(item2, currentElement) {
    var $path = currentElement.$("path");
    if ($path) {
      $path.attr("d", item2.d);
    }
    var $textPath2 = currentElement.$("textPath");
    if ($textPath2) {
      $textPath2.text(item2.text);
      $textPath2.setAttr({
        filter: this.toFilterValue(item2),
        fill: this.toFillValue(item2),
        stroke: this.toStrokeValue(item2),
        textLength: item2.textLength,
        lengthAdjust: item2.lengthAdjust,
        startOffset: item2.startOffset
      });
    }
    this.updateDefString(item2, currentElement);
    item2.totalLength = $path.totalLength;
  }
  toDefInnerString(item2) {
    return `
      ${this.toPathSVG(item2)}
      ${this.toFillSVG(item2)}
      ${this.toStrokeSVG(item2)}
    `;
  }
  toPathId(item2) {
    return this.getInnerId(item2, "path");
  }
  toPathSVG(item2) {
    return `
      <path 
        class="svg-path-item"
        id="${this.toPathId(item2)}"
        d="${item2.d}"
        fill="none"
      />
    `;
  }
  render(item2) {
    return this.wrappedRender(item2, () => {
      const { textLength, lengthAdjust, startOffset } = item2;
      return `
        <textPath ${OBJECT_TO_PROPERTY$1(__spreadProps(__spreadValues({
        "xlink:href": `#${this.toPathId(item2)}`,
        textLength,
        lengthAdjust,
        startOffset,
        filter: this.toFilterValue(item2),
        fill: this.toFillValue(item2),
        stroke: this.toStrokeValue(item2)
      }, this.toSVGAttribute(item2)), {
        style: CSS_TO_STRING$1(this.toCSS(item2))
      }))} >${item2.text}</textPath>
      `;
    });
  }
}
class SVGTextRender extends SVGItemRender {
  update(item2, currentElement) {
    var $text = currentElement.$("text");
    if ($text) {
      $text.text(item2.text);
      $text.setAttr({
        filter: this.toFilterValue(item2),
        fill: this.toFillValue(item2),
        stroke: this.toStrokeValue(item2),
        textLength: item2.textLength,
        lengthAdjust: item2.lengthAdjust
      });
    }
    this.updateDefString(item2, currentElement);
  }
  shapeInsideId(item2) {
    return this.getInnerId(item2, "shape-inside");
  }
  render(item2) {
    var { id, textLength, lengthAdjust } = item2;
    return this.wrappedRender(item2, () => {
      return `
        <text ${OBJECT_TO_PROPERTY$1(__spreadProps(__spreadValues({
        "class": "svg-text-item",
        textLength,
        lengthAdjust,
        filter: this.toFilterValue(item2),
        fill: this.toFillValue(item2),
        stroke: this.toStrokeValue(item2)
      }, this.toSVGAttribute(item2)), {
        style: CSS_TO_STRING$1(this.toCSS(item2))
      }))} >${item2.text}</text>
      `;
    });
  }
}
class TemplateRender extends SVGLayerRender {
  update(item2, currentElement) {
    const compiledTemplate = this.compile(item2);
    let $innerHTML = currentElement.$(".inner-html");
    if ($innerHTML) {
      $innerHTML.updateDiff(compiledTemplate);
    }
    super.update(item2, currentElement);
  }
  compile(item2) {
    return TemplateEngine.compile("dom", item2.template, item2.params);
  }
  render(item2) {
    const { id, width: width2, height: height2 } = item2;
    const compiledTemplate = this.compile(item2);
    return this.wrappedRender(item2, () => {
      return `
            <foreignObject
                width="${width2}"
                height="${height2}"
            >
                <div  xmlns="http://www.w3.org/1999/xhtml" style="width: 100%;height:100%;">
                    <style id="style-${id}">
                    [data-id="${id}"] .inner-html {
                        width: 100%; 
                        height: 100%;
                        position:relative;
                        display:block;
                        pointer-events: none; 
                    }

                    [data-id="${id}"] .inner-html > * {
                        width: 100%; 
                        height: 100%;
                    }          
                    </style>
                    <div class="inner-html">
                    ${compiledTemplate}
                    </div>
                </div>
            </foreignObject>              
          `;
    });
  }
}
class TextRender extends SVGLayerRender {
  toCSS(item2) {
    let css = super.toCSS(item2);
    css.margin = css.margin || "0px";
    return css;
  }
  render(item2) {
    const { content: content2, width: width2, height: height2 } = item2;
    let css = this.toCSS(item2);
    return this.wrappedRender(item2, () => {
      return `
            <foreignObject width="${width2}" height="${height2}">
                <p xmlns="http://www.w3.org/1999/xhtml" style="${CSS_TO_STRING$1(css)}">${content2}</p>
            </foreignObject>              
          `;
    });
  }
  update(item2, currentElement) {
    var { content: content2 } = item2;
    currentElement.updateDiff(content2);
  }
}
class VideoRender extends SVGLayerRender {
  getUrl(item2) {
    var { src } = item2;
    var project2 = item2.project;
    return project2.getVideoValueById(src);
  }
  render(item2, renderer) {
    var {
      width: width2,
      height: height2,
      controls,
      muted,
      poster,
      loop,
      crossorigin,
      autoplay
    } = item2;
    let css = this.toCSS(item2);
    return this.wrappedRender(item2, () => {
      return `
            <foreignObject 
                width="${width2}"
                height="${height2}"
                overflow="visible"
            >
                <video 
                    xmlns="http://www.w3.org/1999/xhtml"
                    controls="${controls}"
                    src="${this.getUrl(item2)}"
                    muted="${muted}"
                    poster="${poster}"
                    loop="${loop}"
                    crossorigin="${crossorigin}"
                    autoplay="${autoplay}"
                    style="${CSS_TO_STRING$1(css)};width:100%;height:100%;"></video>
            </foreignObject>    
            `;
    });
  }
}
class BooleanPathRender extends SVGItemRender {
  update(item2, currentElement) {
    if (!currentElement)
      return;
    const $path = currentElement.$(`[data-boolean-path-id="${item2.id}"]`);
    if ($path) {
      $path.setAttr({
        "d": item2.d,
        "filter": this.toFilterValue(item2),
        "fill": this.toFillValue(item2),
        "stroke": this.toStrokeValue(item2)
      });
      item2.totalLength = $path.totalLength;
    }
    this.updateDefString(item2, currentElement);
  }
  render(item2) {
    var { d } = item2;
    return this.wrappedRender(item2, () => {
      return `
<path ${OBJECT_TO_PROPERTY$1(__spreadProps(__spreadValues({
        "class": "boolean-path-item",
        "data-boolean-path-id": item2.id,
        d,
        filter: this.toFilterValue(item2),
        fill: this.toFillValue(item2),
        stroke: this.toStrokeValue(item2)
      }, this.toSVGAttribute(item2)), {
        style: CSS_TO_STRING$1(this.toCSS(item2))
      }))} />
    `;
    });
  }
}
function rendererSvg(editor) {
  editor.registerRendererType("svg", new SVGRenderer(editor));
  editor.registerRenderer("svg", "project", new ProjectRender());
  editor.registerRenderer("svg", "artboard", new ArtBoardRender());
  editor.registerRenderer("svg", "rect", new RectRender());
  editor.registerRenderer("svg", "circle", new CircleRender());
  editor.registerRenderer("svg", "image", new ImageRender());
  editor.registerRenderer("svg", "template", new TemplateRender());
  editor.registerRenderer("svg", "iframe", new IFrameRender());
  editor.registerRenderer("svg", "video", new VideoRender());
  editor.registerRenderer("svg", "text", new TextRender());
  editor.registerRenderer("svg", "boolean-path", new BooleanPathRender());
  editor.registerRenderer("svg", "svg-path", new SVGPathRender());
  editor.registerRenderer("svg", "polygon", new SVGPolygonRender());
  editor.registerRenderer("svg", "star", new SVGStarRender());
  editor.registerRenderer("svg", "spline", new SplineRender());
  editor.registerRenderer("svg", "svg-text", new SVGTextRender());
  editor.registerRenderer("svg", "svg-textpath", new SVGTextPathRender());
}
var SelectorPopup$1 = "";
class SelectorPopup extends BasePopup {
  getTitle() {
    return this.$i18n("selector.popup.title");
  }
  initState() {
    return {
      selector: "",
      properties: []
    };
  }
  updateData(opt) {
    this.setState(opt, false);
    this.emit("changeSelectorPopup", this.state);
  }
  getBody() {
    return `
    <div class='elf--selector-popup' ref='$popup'>
      <div class="box">
        ${this.templateForSelector()}
        ${this.templateForProperty()}        
      </div>
    </div>`;
  }
  templateForProperty() {
    return createComponent("CSSPropertyEditor", {
      ref: "$propertyEditor",
      onchange: "changePropertyEditor"
    });
  }
  templateForSelector() {
    return `
      <div class='name'>
        <label>${this.$i18n("selector.popup.selector")}</label>
        <div class='input grid-1'>
          <input type='text' value='${this.state.selector}' ref='$selector'/>
        </div>
      </div>
    `;
  }
  [INPUT("$selector")](e2) {
    if (this.refs.$selector.value.match(/^[a-zA-Z0-9\:\_\-\.\b]+$/)) {
      this.updateData({ selector: this.refs.$selector.value });
    } else {
      e2.preventDefault();
      e2.stopPropagation();
      return false;
    }
  }
  refresh() {
    super.refresh();
    this.refs.$selector.val(this.state.selector);
    this.children.$propertyEditor.trigger("showCSSPropertyEditor", this.state.properties);
  }
  [SUBSCRIBE("changePropertyEditor")](properties) {
    this.updateData({
      properties
    });
  }
  [SUBSCRIBE("showSelectorPopup")](data) {
    this.setState(data);
    this.refresh();
    this.show(250);
  }
}
var SelectorProperty$1 = "";
const selectorList = [
  "",
  ":hover",
  ":active",
  ":before",
  ":after",
  ":first-child",
  ":last-child",
  ":link",
  ":active",
  ":focus"
].map((value) => ({ value }));
class SelectorProperty extends BaseProperty {
  getTitle() {
    return this.$i18n("selector.property.title");
  }
  getBody() {
    return `<div class='elf--selector-list' ref='$selectorList'></div>`;
  }
  getTools() {
    return `
      <div style='display:inline-block;'>
        ${createComponent("SelectEditor", {
      ref: "$select",
      key: "selector",
      "none-value": "selector",
      options: selectorList
    })}
      </div>
      <button type="button" ref="$add" title="add Selector">${obj.add}</button>
    `;
  }
  makeSelectorTemplate(selector2, index2) {
    index2 = index2.toString();
    return `
      <div class='selector-item' draggable='true' ref='$selectorIndex${index2}' data-index='${index2}'>
        <div class='title'>
          <div class='name'>
            <span>${selector2.selector || `&lt;${this.$i18n("selector.property.none")}&gt;`}</span>
          </div>
          <div class='tools'>
              <button type="button" class="del" data-index="${index2}">${obj.remove2}</button>
          </div>
        </div>
      </div>
    `;
  }
  [CLICK("$selectorList .selector-item .name")](e2) {
    var index2 = +e2.$dt.closest("selector-item").attr("data-index");
    var current = this.$selection.current;
    if (!current)
      return;
    this.viewSelectorPicker(index2);
  }
  [CLICK("$selectorList .selector-item .del") + PREVENT + STOP](e2) {
    var removeIndex = e2.$dt.attr("data-index");
    var current = this.$selection.current;
    if (!current)
      return;
    current.removeSelector(removeIndex);
    this.emit("refreshElement", current);
    this.refresh();
  }
  [SUBSCRIBE("refreshSelection") + DEBOUNCE(100)]() {
    this.refreshShowIsNot(["project", "svg-path", "svg-brush", "svg-textpath", "svg-text"]);
  }
  [LOAD("$selectorList")]() {
    var current = this.$selection.current;
    if (!current)
      return "";
    var selectors = current.selector ? Selector.parseStyle(current) : current.selectors;
    current.selector = "";
    current.selectors = selectors;
    return (selectors || []).map((selector2, index2) => {
      return this.makeSelectorTemplate(selector2, index2);
    });
  }
  [DRAGSTART("$selectorList .selector-item .title")](e2) {
    this.startIndex = +e2.$dt.attr("data-index");
  }
  [DRAGOVER("$selectorList .selector-item") + PREVENT](e2) {
  }
  [DROP("$selectorList .selector-item") + PREVENT](e2) {
    var targetIndex = +e2.$dt.attr("data-index");
    var current = this.$selection.current;
    if (!current)
      return;
    current.sortSelector(this.startIndex, targetIndex);
    this.emit("refreshElement", current);
    this.refresh();
  }
  [CLICK("$add")]() {
    var current = this.$selection.current;
    if (current) {
      current.createSelector({
        selector: this.children.$select.getValue()
      });
      this.emit("refreshElement", current);
    }
    this.refresh();
  }
  viewSelectorPicker(index2) {
    if (typeof this.selectedIndex === "number") {
      this.selectItem(this.selectedIndex, false);
    }
    this.selectedIndex = +index2;
    this.selectItem(this.selectedIndex, true);
    this.current = this.$selection.current;
    if (!this.current)
      return;
    this.currentSelector = this.current.selectors[this.selectedIndex];
    this.viewSelectorPropertyPopup();
  }
  selectItem(selectedIndex, isSelected = true) {
    if (isSelected) {
      this.getRef("$selectorIndex", selectedIndex).addClass("selected");
    } else {
      this.getRef("$selectorIndex", selectedIndex).removeClass("selected");
    }
    if (this.current) {
      this.current.selectors.forEach((it, index2) => {
        it.selected = index2 === selectedIndex;
      });
    }
  }
  viewSelectorPropertyPopup(position2) {
    this.current = this.$selection.current;
    if (!this.current)
      return;
    this.currentSelector = this.current.selectors[this.selectedIndex];
    const back = this.currentSelector;
    const selector2 = back.selector;
    const properties = back.properties;
    this.emit("showSelectorPopup", {
      position: position2,
      selector: selector2,
      properties
    });
  }
  [SUBSCRIBE("changeSelectorPopup")](data) {
    this.current = this.$selection.current;
    if (!this.current)
      return;
    this.currentselector = this.current.selectors[this.selectedIndex];
    if (this.currentSelector) {
      this.currentSelector.reset(data);
    }
    this.refresh();
    this.emit("refreshElement", this.current);
  }
}
function selector(editor) {
  editor.registerMenuItem("inspector.tab.transition", {
    SelectorProperty
  });
  editor.registerMenuItem("popup", {
    SelectorPopup
  });
}
var SVGFilterAssetsProperty$1 = "";
class SVGFilterAssetsProperty extends BaseProperty {
  getTitle() {
    return this.$i18n("svgfilter.asset.property.title");
  }
  initState() {
    return {
      mode: "grid"
    };
  }
  getClassName() {
    return "elf--svgfilter-assets-property";
  }
  [SUBSCRIBE("refreshSelection") + DEBOUNCE(100)]() {
    this.show();
  }
  getBody() {
    return `
      <div class='property-item svgfilter-assets'>
        <div class='svgfilter-list' ref='$svgfilterList' data-view-mode='${this.state.mode}'></div>
      </div>
    `;
  }
  [LOAD("$svgfilterList")]() {
    var current = this.$selection.currentProject || { svgfilters: [] };
    var svgfilters = current.svgfilters;
    var results = svgfilters.map((svgfilter, index2) => {
      var filters = svgfilter.filters.map((filter2) => {
        return SVGFilter.parse(filter2);
      });
      return `
        <div class='svgfilter-item' data-index="${index2}">
          <div class='preview' data-index="${index2}">
            <svg width="0" height="0">
              <filter id="svgfilter-${index2}">
                ${filters.join("")} 
              </filter>
            </svg>
            <div class='svgfilter-view' style='filter: url(#svgfilter-${index2});'></div>
          </div>
          <div class='title'>
            <div>
              <input type='text' class='id' data-key='id' value='${svgfilter.id}' placeholder="id" />
            </div>
          </div>
          <div class='tools'>
            <button type="button" class='copy'>${obj.copy}</button>          
            <button type="button" class='remove'>${obj.remove}</button>
          </div>
        </div>
      `;
    });
    results.push(`<div class='add-svgfilter-item'><button type="button">${obj.add}</button></div>`);
    return results;
  }
  executeSVGFilter(callback, isRefresh = true, isEmit = true) {
    var project2 = this.$selection.currentProject;
    if (project2) {
      callback && callback(project2);
      if (isRefresh)
        this.refresh();
      if (isEmit)
        this.emit("refreshSVGFilterAssets");
    } else {
      alert("Please select a project.");
    }
  }
  [CLICK("$svgfilterList .add-svgfilter-item")]() {
    this.executeSVGFilter((project2) => {
      project2.createSVGFilter({
        id: uuidShort$1(),
        filters: []
      });
    });
  }
  [CLICK("$svgfilterList .remove")](e2) {
    var $item = e2.$dt.closest("svgfilter-item");
    var index2 = +$item.attr("data-index");
    this.executeSVGFilter((project2) => {
      project2.removeSVGFilter(index2);
    });
  }
  [CLICK("$svgfilterList .copy")](e2) {
    var $item = e2.$dt.closest("svgfilter-item");
    var index2 = +$item.attr("data-index");
    this.executeSVGFilter((project2) => {
      project2.copySVGFilter(index2);
    });
  }
  [INPUT("$svgfilterList input")](e2) {
    var $item = e2.$dt.closest("svgfilter-item");
    var index2 = +$item.attr("data-index");
    var obj2 = e2.$dt.attrKeyValue("data-key");
    this.executeSVGFilter((project2) => {
      project2.setSVGFilterValue(index2, obj2);
      this.emit("refreshSVGArea");
    }, false);
  }
  [CLICK("$svgfilterList .preview")](e2) {
    var $item = e2.$dt.closest("svgfilter-item");
    var index2 = +$item.attr("data-index");
    this.state.$item = $item;
    this.state.$el = e2.$dt.$(".svgfilter-view");
    var currentProject = this.$selection.currentProject || { svgfilters: [] };
    var svgfilter = currentProject.svgfilters[index2];
    this.emit("showSVGFilterPopup", {
      changeEvent: "changeSVGFilterAssets",
      id: this.id,
      index: index2,
      filters: svgfilter.filters
    });
  }
  [SUBSCRIBE("updateSVGFilterAssets")](params) {
    this.executeSVGFilter((project2) => {
      project2.setSVGFilterValue(params.index, {
        filters: params.filters
      });
      this.state.$item.$("filter").html(params.filters.join("\n"));
      this.emit("refreshSVGArea");
    }, false);
  }
  [SUBSCRIBE("changeSVGFilterAssets")](params) {
    if (params.id === this.id) {
      this.trigger("updateSVGFilterAssets", params);
    }
  }
  [SUBSCRIBE("refreshSVGFilterAssets")]() {
    this.refresh();
  }
}
function svgFilterAsset(editor) {
  editor.registerElement({
    SVGFilterAssetsProperty
  });
}
var red = `
1   0   0   0   0
0   0   0   0   0
0   0   0   0   0
0   0   0   1   0
`;
var green = `
0   0   0   0   0
0   1   0   0   0
0   0   0   0   0
0   0   0   1   0 
`;
var blue = `
0   0   0   0   0
0   0   0   0   0
0   0   1   0   0
0   0   0   1   0 
`;
var yellow = `
1   0   0   0   0
0   1   0   0   0
0   0   0   0   0
0   0   0   1   0 
`;
var magenta = `
1   0   0   0   0
0   0   0   0   0
0   0   1   0   0
0   0   0   1   0 
`;
var cyan = `
0   0   0   0   0
0   1   0   0   0
0   0   1   0   0
0   0   0   1   0 
`;
var alpha = `
1   0   0   0   0
0   1   0   0   0
0   0   1   0   0
0   0   0   .5  0 
`;
var BlueMagenta2 = `
1   0   0   0   0
0   0   0   0   0
0   0   1  .5   0
0   0   0   1   0 
`;
var BlueShadowMagentHightlight = `
1   0   0   0   0
0   0   0   0   0
0   0   1   1   0
0   0   0   1   0 
`;
var darken = `
.5   0   0   0   0
0  .5   0   0   0
0   0  .5   0   0
0   0   0   1   0 
`;
var ElimBlue = `
1   0   0   0   0
0   1   0   0   0
0   0   1   0   0
0   0   -2   1   0 
`;
var GrayOnDark = `
0   0   1   0   0
0   0   1   0   0
0   0   1   0   0
0   0   0   1   0  
`;
var GrayOnLight = `
1   0   0   0   0
1   0   0   0   0
1   0   0   0   0
0   0   0   1   0 
`;
var GrayOnMid = `
0   1   0   0   0
0   1   0   0   0
0   1   0   0   0
0   0   0   1   0 
`;
var HardGreen = `
1   0   0   0   0
0   1   0   1   0
0   0   1   0   0
0   0   0   1   0 
`;
var HardYellow = `
1   0   0   1   0
0   1   0   1   0
0   0   1   0   0
0   0   0   1   0 
`;
var IdenticalRedOverlay = `
1   0   0   0   0
0   0   0   0   0
0   0   0   0   0
0   0   0   1   0 
`;
var lighten = `
1.5   0   0   0   0
0   1.5   0   0   0
0   0   1.5   0   0
0   0   0   1   0 
`;
var lime = `
1   0   0   0   0
0   2   0   0   0
0   0   0  .5   0
0   0   0   1   0 
`;
var NoGreenMagenta = `
1   1   0   0   0
0   0   0   0   0
0   1   1   0   0
0   0   0   1   0 
`;
var NoGreenRed = `
1   1   0   0   0
0   0   0   0   0
0   0   1   0   0
0   0   0   1   0 
`;
var peachy = `
1   0   0   0   0
0  .5   0   0   0
0   0   0  .5   0
0   0   0   1   0 
`;
var RedOverlay = `
1   0   0   0   0
0   0   0   0   0
0   0   1  -1   0
0   0   0   1   0 
`;
var YesGreenColorizedMagenta = `
1   1   0   0   0
0   1   0   0   0
0   1   1   0   0
0   0   0   1   0 
`;
var colormatrix = {
  red,
  green,
  blue,
  yellow,
  magenta,
  cyan,
  alpha,
  BlueMagenta2,
  BlueShadowMagentHightlight,
  darken,
  ElimBlue,
  GrayOnDark,
  GrayOnLight,
  GrayOnMid,
  HardGreen,
  HardYellow,
  IdenticalRedOverlay,
  lighten,
  lime,
  NoGreenMagenta,
  NoGreenRed,
  peachy,
  RedOverlay,
  YesGreenColorizedMagenta
};
var ColorMatrixEditor$1 = "";
const COLUMN = 6;
const sampleList = Object.keys(colormatrix).map((it) => {
  return { title: it, values: colormatrix[it] };
});
class ColorMatrixEditor extends EditorElement {
  initState() {
    return {
      values: normalize(this.props.values)
    };
  }
  template() {
    return `
            <div class='elf--color-matrix-editor' >
                <div ref='$body'></div>
                <div class='title'> Mix Color Template </div>
                <div class='color-matrix-template' ref='$sample'></div>
            </div>
        `;
  }
  [BIND("$body")]() {
    return {
      cssText: `
                display: grid;
                grid-template-columns: repeat(${COLUMN}, 1fr);
                grid-column-gap: 2px;
                grid-row-gap: 2px;
                text-align: left; 
            `
    };
  }
  [LOAD("$sample")]() {
    return sampleList.map((it, index2) => {
      return `<div class='sample-item' title='${it.title}' data-index="${index2}">${it.title}</div>`;
    });
  }
  [CLICK("$sample .sample-item")](e2) {
    var index2 = +e2.$dt.attr("data-index");
    var sample = sampleList[index2];
    this.updateData({
      values: normalize(sample.values)
    });
    this.load("$body");
  }
  [LOAD("$body")]() {
    var { values } = this.state;
    var text2 = ["R", "G", "B", "A"];
    var a = values.map((value, index2) => {
      var h = "";
      if (index2 % (COLUMN - 1) === 0) {
        h = `<div>${text2[Math.floor(index2 / (COLUMN - 1))]}</div>`;
      }
      var result = `
                ${h}
                <div class='number-editor'>
                    <input type="number" value="${value}" step="0.01" data-index="${index2}" />
                </div>
            `;
      return result;
    });
    var header = `
            <div></div>
            <div>R</div>
            <div>G</div>
            <div>B</div>
            <div>A</div>
            <div>M</div>
        `;
    return header + a;
  }
  updateData(data) {
    this.setState(data, false);
    this.parent.trigger(this.props.onchange, this.props.key, this.state.values, this.props.params);
  }
  [INPUT("$body input")](e2) {
    var $el = e2.$dt;
    var index2 = +$el.attr("data-index");
    var value = +$el.value;
    this.state.values[index2] = value;
    this.updateData();
  }
}
var FuncFilterEditor$1 = "";
class FuncFilterEditor extends EditorElement {
  initState() {
    return __spreadValues({
      label: this.props.label || ""
    }, this.parse(this.props.value));
  }
  parse(value) {
    var [type, ...values] = value.split(" ");
    if (type === "linear") {
      var [slop, intercept] = values;
    } else if (type === "gamma") {
      var [amplitude, exponent, offset] = values;
    }
    return {
      type,
      values,
      slop,
      intercept,
      amplitude,
      exponent,
      offset
    };
  }
  template() {
    return `<div class='small-editor func-filter' ref='$body'></div>`;
  }
  [LOAD("$body")]() {
    var { type, label } = this.state;
    var hasLabel = !!label ? "has-label" : "";
    return `
            ${createComponent("SelectEditor", {
      label,
      ref: "$type",
      key: "type",
      value: this.state.type,
      options: ["identity", "table", "discrete", "linear", "gamma"],
      onchange: "changeType"
    })}
        <div class='elf--func-filter-editor ${hasLabel}' ref='$container' data-selected-type='${type}'>
            ${label ? `<label></label>` : ""}
            <div data-type='identity'>
            </div>
            <div data-type='table'>
                ${createComponent("TextEditor", {
      label: "tableValues",
      ref: "$values",
      key: "values",
      value: this.state.values.join(" "),
      onchange: (key, value) => {
        this.updateData({
          [key]: value.split(" ")
        });
      }
    })}
            </div>
            <div data-type='linear'>
                ${["slop", "intercept"].map((it) => {
      return `
                        <div>
                            ${createComponent("NumberRangeEditor", {
        label: it,
        ref: `$${it}`,
        key: it,
        value: this.state[it],
        onchange: (key, value) => {
          this.updateData({
            [key]: value
          });
        }
      })}
                        </div>                    
                    `;
    }).join("")}
            </div>
            <div data-type='gamma'>
                ${["amplitude", "exponent", "offset"].map((it) => {
      return `
                        <div>
                            ${createComponent("NumberRangeEditor", {
        label: it,
        ref: `$${it}`,
        key: it,
        value: this.state[it],
        onchange: (key, value) => {
          this.updateData({
            [key]: value
          });
        }
      })}
                        </div>                    
                    `;
    }).join("")}            
            </div>                                                
        </div>
    `;
  }
  [SUBSCRIBE("changeType")](key, type) {
    this.updateData({ type });
    this.refresh();
  }
  getValue() {
    switch (this.state.type) {
      case "table":
      case "discrete":
        return [this.state.type, ...this.state.values].join(" ");
      case "linear":
        return [this.state.type, this.state.slop, this.state.intercept].join(" ");
      case "gamma":
        return [this.state.type, this.state.amplitude, this.state.exponent, this.state.offset].join(" ");
    }
    return "identity";
  }
  setValue(value) {
    this.setState(__spreadValues({}, this.parse(value)));
  }
  updateData(data) {
    this.setState(data, false);
    this.parent.trigger(this.props.onchange, this.props.key, this.getValue(), this.props.params);
  }
}
var grayscale = [{
  type: "Saturate",
  values: "0"
}];
var shadow = [
  {
    type: "SourceAlpha",
    id: "shadowSource",
    bound: { x: 100, y: 100 },
    connected: [{
      id: "offset"
    }]
  },
  {
    type: "Offset",
    id: "offset",
    bound: { x: 200, y: 100 },
    dx: 10,
    dy: 10,
    in: [{ id: "shadowSource" }],
    connected: [
      { id: "blur" }
    ]
  },
  {
    type: "GaussianBlur",
    id: "blur",
    bound: { x: 300, y: 100 },
    stdDeviationX: 5,
    stdDeviationY: 5,
    in: [{ id: "offset" }],
    connected: [{
      id: "composite"
    }]
  },
  {
    type: "Flood",
    id: "flood",
    bound: { x: 100, y: 200 },
    color: "black",
    opacity: 0.7,
    connected: [
      { id: "composite" }
    ]
  },
  {
    type: "Composite",
    id: "composite",
    bound: { x: 400, y: 150 },
    in: [
      { id: "flood" },
      { id: "blur" }
    ],
    operator: "in",
    connected: [{
      id: "merge"
    }]
  },
  {
    type: "SourceAlpha",
    id: "shadowSource2",
    bound: { x: 400, y: 200 },
    connected: [{
      id: "merge"
    }]
  },
  {
    type: "Merge",
    id: "merge",
    bound: { x: 500, y: 150 },
    in: [{ id: "composite" }, { id: "shadowSource2" }]
  }
];
var innerShadow = [
  {
    type: "Flood",
    id: "flood",
    bound: { x: 100, y: 200 },
    color: "black",
    opacity: 1,
    connected: [
      { id: "composite1" }
    ]
  },
  {
    type: "SourceAlpha",
    id: "shadowSource",
    bound: { x: 100, y: 100 },
    connected: [{
      id: "composite1"
    }]
  },
  {
    type: "Composite",
    id: "composite1",
    bound: { x: 200, y: 150 },
    in: [
      { id: "flood" },
      { id: "shadowSource" }
    ],
    operator: "out",
    connected: [{
      id: "offset"
    }]
  },
  {
    type: "Offset",
    id: "offset",
    bound: { x: 300, y: 150 },
    dx: 4,
    dy: 4,
    in: [
      { id: "composite1" }
    ],
    connected: [
      { id: "blur" }
    ]
  },
  {
    type: "GaussianBlur",
    id: "blur",
    bound: { x: 400, y: 150 },
    stdDeviationX: 4,
    stdDeviationY: 4,
    edge: "none",
    in: [
      { id: "offset" }
    ],
    connected: [{
      id: "composite2"
    }]
  },
  {
    type: "SourceAlpha",
    id: "shadowSource2",
    bound: { x: 400, y: 250 },
    connected: [{
      id: "composite2"
    }]
  },
  {
    type: "Composite",
    id: "composite2",
    bound: { x: 500, y: 150 },
    in: [
      { id: "blur" },
      { id: "shadowSource2" }
    ],
    operator: "out",
    connected: [{
      id: "merge"
    }]
  },
  {
    type: "SourceGraphic",
    id: "shadowSource3",
    bound: { x: 500, y: 250 },
    connected: [{
      id: "merge"
    }]
  },
  {
    type: "Merge",
    id: "merge",
    bound: { x: 600, y: 150 },
    in: [
      { id: "composite2" },
      { id: "shadowSource3" }
    ]
  }
];
var stroke = [
  {
    type: "SourceAlpha",
    id: "strokeSource",
    bound: { x: 100, y: 100 },
    connected: [{
      id: "morphology"
    }]
  },
  {
    type: "Morphology",
    id: "morphology",
    operator: "dilate",
    radius: "3 3",
    bound: { x: 100, y: 200 },
    in: [
      { id: "strokeSource" }
    ],
    connected: [
      { id: "composite" }
    ]
  },
  {
    type: "Flood",
    id: "flood",
    bound: { x: 100, y: 200 },
    color: "#30597E",
    opacity: 1,
    connected: [
      { id: "composite" }
    ]
  },
  {
    type: "Composite",
    id: "composite",
    bound: { x: 400, y: 150 },
    in: [
      { id: "flood" },
      { id: "morphology" }
    ],
    operator: "in",
    connected: [{
      id: "merge"
    }]
  },
  {
    type: "SourceGraphic",
    id: "strokeSourceGraphic",
    bound: { x: 400, y: 200 },
    connected: [{
      id: "merge"
    }]
  },
  {
    type: "Merge",
    id: "merge",
    bound: { x: 500, y: 150 },
    in: [{ id: "composite" }, { id: "strokeSourceGraphic" }]
  }
];
var dancingStroke = [
  {
    type: "SourceAlpha",
    id: "strokeSource",
    bound: { x: 100, y: 100 },
    connected: [{
      id: "morphology"
    }]
  },
  {
    type: "Morphology",
    id: "morphology",
    operator: "dilate",
    radius: "3 3",
    bound: { x: 100, y: 200 },
    in: [
      { id: "strokeSource" }
    ],
    connected: [
      { id: "composite" }
    ]
  },
  {
    type: "Flood",
    id: "flood",
    bound: { x: 100, y: 200 },
    color: "#30597E",
    opacity: 1,
    connected: [
      { id: "composite" }
    ]
  },
  {
    type: "Composite",
    id: "composite",
    bound: { x: 400, y: 150 },
    in: [
      { id: "flood" },
      { id: "morphology" }
    ],
    operator: "in",
    connected: [{
      id: "composite2"
    }]
  },
  {
    type: "SourceAlpha",
    id: "strokeSourceAlpha2",
    bound: { x: 400, y: 200 },
    connected: [{
      id: "composite2"
    }]
  },
  {
    type: "Composite",
    id: "composite2",
    bound: { x: 400, y: 150 },
    in: [
      { id: "composite" },
      { id: "strokeSourceAlpha2" }
    ],
    operator: "out",
    connected: [{
      id: "displacementMap"
    }]
  },
  {
    type: "Turbulence",
    id: "turbulence",
    filterType: "fractalNoise",
    baseFrequency: "0.01 0.02",
    numOctaves: 1,
    seed: 0,
    stitchTiles: "stitch",
    bound: { x: 400, y: 200 },
    connected: [{
      id: "displacementMap"
    }]
  },
  {
    type: "DisplacementMap",
    id: "displacementMap",
    scale: 17,
    xChannelSelector: "A",
    yChannelSelector: "A",
    bound: { x: 400, y: 200 },
    in: [
      { id: "composite2" },
      { id: "turbulence" }
    ],
    connected: [{
      id: "merge"
    }]
  },
  {
    type: "SourceGraphic",
    id: "strokeSourceGraphic",
    bound: { x: 400, y: 200 },
    connected: [{
      id: "merge"
    }]
  },
  {
    type: "Merge",
    id: "merge",
    bound: { x: 500, y: 150 },
    in: [{ id: "strokeSourceGraphic" }, { id: "displacementMap" }]
  }
];
var svgFilterPreset = {
  dancingStroke,
  stroke,
  grayscale,
  shadow,
  innerShadow
};
var SVGFilterEditor$1 = "";
const filterTypes = [
  { label: "GRAPHIC REFERENCES", items: [
    { label: "Source Graphic", value: "SourceGraphic" },
    { label: "Source Alpha", value: "SourceAlpha" },
    { label: "Background Image", value: "BackgroundImage" },
    { label: "Background Alpha", value: "BackgroundAlpha" },
    { label: "Fill Paint", value: "FillPaint" },
    { label: "Stroke Paint", value: "StrokePaint" }
  ] },
  { label: "SOURCES", items: [
    { label: "Flood", value: "Flood" },
    { label: "Turbulence", value: "Turbulence" },
    { label: "Image", value: "Image" }
  ] },
  { label: "MODIFIER", items: [
    { label: "Color Matrix", value: "ColorMatrix" },
    { label: "Saturate", value: "Saturate" },
    { label: "HueRotate", value: "HueRotate" },
    { label: "LuminanceToAlpha", value: "LuminanceAlpha" },
    { label: "Drop Shadow", value: "DropShadow" },
    { label: "Morphology", value: "Morphology" },
    { label: "Convolve Matrix", value: "ConvolveMatrix" },
    { label: "Offset", value: "Offset" },
    { label: "Gaussian Blur", value: "GaussianBlur" },
    { label: "Tile", value: "Tile" }
  ] },
  { label: "LIGHTING", items: [
    { label: "Specular Lighting", value: "SpecularLighting" },
    { label: "Diffuse Lighting", value: "DiffuseLighting" },
    { label: "Point Light", value: "PointLight" },
    { label: "Spot Light", value: "SpotLight" },
    { label: "Distant Light", value: "DistantLight" }
  ] },
  { label: "COMBINERS", items: [
    { label: "Blend", value: "Blend" },
    { label: "Composite", value: "Composite" },
    { label: "Merge", value: "Merge" },
    { label: "DisplacementMap", value: "DisplacementMap" }
  ] }
];
const SVGFilterTemplateList = [
  {
    label: "Template",
    items: [
      { label: "Grayscale", value: "grayscale" },
      { label: "Shadow", value: "shadow" },
      { label: "Inner Shadow", value: "innerShadow" },
      { label: "Stroke", value: "stroke" },
      { label: "Dancing Stroke", value: "dancingStroke" }
    ]
  }
];
function getIcon(type) {
  switch (type) {
    case "SpecularLighting":
      return iconUse$1("specular");
    case "DiffuseLighting":
      return iconUse$1("diffuse");
    case "SourceGraphic":
    case "SourceAlpha":
      return iconUse$1("image");
    case "BackgroundImage":
    case "BackgroundAlpha":
      return iconUse$1("outline_image");
    case "Flood":
      return iconUse$1("palette");
    case "Image":
      return iconUse$1("landscape");
    case "GaussianBlur":
      return iconUse$1("blur");
    case "ColorMatrix":
      return iconUse$1("blur_linear");
    case "Turbulence":
      return iconUse$1("waves");
    case "Saturate":
      return iconUse$1("vintage");
    case "HueRotate":
      return iconUse$1("looks");
    case "LuminanceAlpha":
      return iconUse$1("opacity");
    case "DropShadow":
      return iconUse$1("shadow");
    case "Morphology":
      return iconUse$1("broken_image");
    case "ConvolveMatrix":
      return iconUse$1("camera_roll");
    case "Offset":
      return iconUse$1("transform");
    case "Tile":
      return iconUse$1("view_comfy");
    case "Blend":
      return iconUse$1("gradient");
    case "Composite":
      return iconUse$1("merge");
    case "Merge":
      return iconUse$1("settings_input_component");
    case "DisplacementMap":
      return iconUse$1("texture");
  }
  return "";
}
function getSourceTypeString(type) {
  switch (type) {
    case "SourceGraphic":
    case "SourceAlpha":
    case "BackgroundImage":
    case "BackgroundAlpha":
    case "FillPaint":
    case "StrokePaint":
      return "graphic";
    case "Flood":
    case "Turbulence":
    case "Image":
      return "source";
    case "GaussianBlur":
    case "ColorMatrix":
    case "Saturate":
    case "HueRotate":
    case "LuminanceAlpha":
    case "DropShadow":
    case "Morphology":
    case "ConvolveMatrix":
    case "Offset":
    case "Tile":
      return "modifier";
    case "SpecularLighting":
    case "DiffuseLighting":
    case "SpotLight":
    case "PointLight":
    case "DistantLight":
      return "lighting";
    case "Blend":
    case "Composite":
    case "Merge":
    case "DisplacementMap":
      return "combiner";
  }
  return "";
}
const width = 40;
const half_height = 20;
const connectedXAxis = {
  "1": [width + 5]
};
const connectedYAxis = {
  "1": [half_height]
};
const inXAxis = {
  "1": [-7],
  "2": [-7],
  "3": [-7],
  "4": [-7],
  "5": [-7]
};
let inYAxis = {
  "1": [0],
  "2": [-7, 7],
  "3": [-14, 0, 14],
  "4": [-21, -7, 7, 21],
  "5": [-28, -14, 0, 14, 28]
};
Object.keys(inYAxis).forEach((len2) => {
  inYAxis[len2] = inYAxis[len2].map((it) => it + half_height);
});
class SVGFilterEditor extends EditorElement {
  makeFilterSelect() {
    return `
  
    <div class='filter-item-list' ref="$filterSelect">
  
      ${mapjoin(filterTypes, (f) => {
      return `
          <div class='group' label="${this.$i18n(f.label)}">
            ${mapjoin(f.items, (i) => {
        return `
                <div class='item' draggable="true" value="${i.value}">
                  <span class='icon'>${getIcon(i.value)}</span>
                  ${this.$i18n(i.label)}
                </div>
                `;
      })}
          </div>
        `;
    })}
    </div>
    `;
  }
  makeFilterTemplateSelect() {
    return `
  
    <div class='filter-item-list' ref="$filterTemplateSelect">
  
      ${mapjoin(SVGFilterTemplateList, (f) => {
      return `
          <div class='group' label="${this.$i18n(f.label)}">
            ${mapjoin(f.items, (i) => {
        return ` <div class='item' draggable="true" value="${i.value}">${this.$i18n(i.label)}</div>`;
      })}
          </div>
        `;
    })}
    </div>
    `;
  }
  initState() {
    var filters = this.parseFilter(this.props.value || []);
    return {
      filters,
      selectedTabIndex: 1,
      selectedIndex: -1,
      selectedFilter: null
    };
  }
  template() {
    return `
      <div class='elf--svg-filter-editor filter-list'>
        <div class='left'>
          <div class="tab number-tab" ref="$tab">
            <div class="tab-header full" ref="$header">
              <div class="tab-item selected" data-value="1" title='Item'>
                <label class='icon'>${this.$i18n("svg.filter.editor.tab.filter")}</label>
              </div>
              <div class="tab-item" data-value="2" title="Preset">
                <label class='icon'>${this.$i18n("svg.filter.editor.tab.preset")}</label>
              </div>
              <div class="tab-item" data-value="3" title="Asset">
                <label class='icon'>${this.$i18n("svg.filter.editor.tab.asset")}</label>
              </div>
            </div>
            <div class="tab-body">
              <div class="tab-content scrollbar selected" data-value="1">
                ${this.makeFilterSelect()}
              </div>
              <div class="tab-content  scrollbar" data-value="2">
                ${this.makeFilterTemplateSelect()}
              </div>
                     
            </div>
          </div>
        </div>
        <div  class='center'>
          <div class='graph'>
            <div class='drag-line-panel' ref='$dragLinePanel'></div>          
            <div class='connected-line-panel' ref='$connectedLinePanel'></div>
            <div class='graph-panel' ref='$graphPanel' droppable="true"></div>
          </div>
        </div>
        <div class='right'>
          <div class='filter-list' ref='$filterList'></div>
        </div>
      </div>`;
  }
  [CLICK("$header .tab-item:not(.empty-item)")](e2) {
    var selectedTabIndex = +e2.$dt.attr("data-value");
    if (this.state.selectedTabIndex === selectedTabIndex) {
      return;
    }
    this.$el.$$(`[data-value="${this.state.selectedTabIndex}"]`).forEach((it) => it.removeClass("selected"));
    this.$el.$$(`[data-value="${selectedTabIndex}"]`).forEach((it) => it.addClass("selected"));
    this.setState({ selectedTabIndex }, false);
  }
  [DRAGSTART("$filterSelect .item")](e2) {
    var filter2 = e2.$dt.attr("value");
    e2.dataTransfer.setData("filter/type", filter2);
  }
  [DRAGOVER("$connectedLinePanel") + PREVENT]() {
  }
  [DROP("$connectedLinePanel") + PREVENT](e2) {
    var offset = { x: e2.offsetX, y: e2.offsetY };
    var filterType = e2.dataTransfer.getData("filter/type");
    this.makeFilterNode(filterType, { bound: offset });
  }
  makeFilterNode(filterType, opt = {}) {
    this.state.filters.push(this.makeFilter(filterType, opt));
    this.state.selectedIndex = this.state.filters.length - 1;
    this.state.selectedFilter = this.state.filters[this.state.selectedIndex];
    this.refresh();
    this.modifyFilter();
  }
  applyTemplate(templateType) {
    var template = svgFilterPreset[templateType];
    if (template) {
      this.setState({
        selectedIndex: -1,
        selectedFilter: null,
        filters: this.parseFilter(template)
      }, false);
      this.refresh();
      this.modifyFilter();
    }
  }
  getSpec(filterType) {
    return SVGFilterSpecList[filterType];
  }
  makeFilterEditorTemplate(s, filter2, key) {
    var objectId = `${filter2.type}${key}${this.state.selectedIndex}${Date.now()}`;
    if (s.inputType === "color-matrix") {
      return createComponent("ColorMatrixEditor", {
        ref: `$colorMatrix${objectId}`,
        label: s.title,
        key,
        column: s.column,
        values: filter2[key].join(" "),
        onchange: "changeRangeEditor"
      });
    } else if (s.inputType === "input-array") {
      return createComponent("InputArrayEditor", {
        ref: `$inputArray${objectId}`,
        label: s.title,
        key,
        "column-label": "R,G,B,A,M",
        "row-label": "R,G,B,A",
        column: s.column,
        values: filter2[key].join(" "),
        onchange: "changeRangeEditor"
      });
    } else if (s.inputType === "blend") {
      return createComponent("BlendSelectEditor", {
        ref: `$blend${objectId}`,
        label: s.title,
        key,
        value: filter2[key].toString(),
        onchange: "changeRangeEditor"
      });
    } else if (s.inputType === "select") {
      var options2 = s.options;
      if (isFunction(s.options)) {
        options2 = s.options(this.state.filters);
      }
      return createComponent("SelectEditor", {
        ref: `$select${objectId}`,
        label: s.title,
        options: options2,
        key,
        value: filter2[key].toString(),
        onchange: "changeRangeEditor"
      });
    } else if (s.inputType === "text") {
      return createComponent("TextEditor", {
        ref: `$text${objectId}`,
        label: s.title,
        key,
        value: filter2[key].toString(),
        onchange: "changeTextEditor"
      });
    } else if (s.inputType === "number-range") {
      return createComponent("NumberRangeEditor", {
        ref: `$numberrange${objectId}`,
        label: s.title,
        layout: "block",
        min: s.min,
        max: s.max,
        step: s.step,
        key,
        value: filter2[key].toString(),
        onchange: "changeRangeEditor"
      });
    } else if (s.inputType === "color") {
      return createComponent("ColorViewEditor", {
        ref: `$colorview${objectId}`,
        label: s.title,
        key,
        value: filter2[key].toString(),
        onchange: "changeRangeEditor"
      });
    } else if (s.inputType === "FuncFilter") {
      return createComponent("FuncFilterEditor", {
        ref: `$funcFilter${objectId}`,
        label: s.title,
        key,
        value: filter2[key].toString(),
        onchange: "changeFuncFilterEditor"
      });
    } else if (s.inputType === "ImageSelectEditor") {
      return createComponent("ImageSelectEditor", {
        ref: `$imageSelect${objectId}`,
        label: s.title,
        key,
        value: filter2[key].toString(),
        onchange: "changeRangeEditor"
      });
    }
    return createComponent("RangeEditor", {
      ref: `$range${objectId}`,
      layout: "block",
      label: s.title,
      min: s.min,
      max: s.max,
      step: s.step,
      key,
      value: filter2[key].toString(),
      units: s.units,
      onchange: "changeRangeEditor"
    });
  }
  makeOneFilterTemplate(spec, filter2) {
    return `
    <div class="filter-item">
      <div class="title">
        <label>${filter2.type}</label>
        <div class="filter-menu">
          <button type="button" class="del">${iconUse$1("remove")}</button>
        </div>
      </div>
      <div class="filter-ui">
        ${keyMapJoin(spec, (key, value) => {
      return this.makeFilterEditorTemplate(value, filter2, key);
    })}

      </div>
    </div>
  `;
  }
  makeFilterTemplate(filter2) {
    return this.makeOneFilterTemplate(this.getSpec(filter2.type), filter2);
  }
  [LOAD("$filterList")]() {
    if (this.state.selectedFilter && this.state.selectedFilter.isSource() === false) {
      return this.makeFilterTemplate(this.state.selectedFilter);
    }
    return "";
  }
  modifyFilter() {
    this.state.filters.forEach((f) => {
      if (f.isLight() && f.connected.length) {
        f.connected.forEach((c2) => {
          this.state.filters.filter((s) => s.id === c2.id).forEach((lightManager) => {
            lightManager.reset({
              lightInfo: f.toLightString()
            });
          });
        });
      }
    });
    this.parent.trigger(this.props.onchange, this.props.key, this.state.filters);
  }
  parseFilter(list2 = []) {
    return list2.map((it) => SVGFilter.parse(it));
  }
  makeFilter(type, opt = {}) {
    return SVGFilter.parse(__spreadProps(__spreadValues({}, opt), { type }));
  }
  [CLICK("$filterSelect .item[value]")](e2) {
    var filterType = e2.$dt.attr("value");
    this.makeFilterNode(filterType);
  }
  [CLICK("$filterTemplateSelect .item[value]")](e2) {
    var templateType = e2.$dt.attr("value");
    this.applyTemplate(templateType);
  }
  [CLICK("$filterList .filter-menu .del")](e2) {
    this.removeFilter(this.state.selectedFilter.id);
  }
  [LOAD("$graphPanel")]() {
    return this.makeGraphPanel();
  }
  selectFilter(index2) {
    this.setState({
      selectedIndex: index2,
      selectedFilter: this.state.filters[index2]
    }, false);
    this.load("$filterList");
  }
  [POINTERSTART("$graphPanel .filter-node") + MOVE() + END()](e2) {
    this.$target = e2.$dt;
    this.$point = null;
    this.pointType = "object";
    this.pointIndex = 0;
    var rect2 = this.refs.$graphPanel.rect();
    this.rect = rect2;
    var index2 = +this.$target.attr("data-index");
    this.selectFilter(index2);
    this.$target.onlyOneClass("selected");
    var pointer = Dom.create(e2.target);
    if (pointer.hasClass("out")) {
      this.$point = pointer;
      this.pointType = "out";
      this.pointIndex = 0;
    } else if (pointer.hasClass("in")) {
      this.$point = pointer;
      this.pointType = "in";
      this.pointIndex = +pointer.attr("data-index");
    } else {
      var filter2 = this.state.selectedFilter;
      this.startXY = clone$1(filter2.bound);
    }
    if (this.pointType === "in" || this.pointType === "out") {
      var inRect = pointer.rect();
      var x2 = inRect.x - rect2.x;
      var y2 = inRect.y - rect2.y;
      var centerX = x2 + inRect.width / 2;
      var centerY = y2 + inRect.height / 2;
      this.startXY = { x: centerX, y: centerY };
    }
    this.startXY.dx = 0;
    this.startXY.dy = 0;
    this.load("$dragLinePanel");
  }
  [LOAD("$dragLinePanel")]() {
    if (this.pointType === "in" || this.pointType === "out") {
      var { x: x2, y: y2, dx, dy } = this.startXY;
      return `
      <svg>
        <path 
          class="drag-line"
          fill="transparent"
          stroke-width="1"
          d="
            M${x2},${y2}
            L${x2 + dx},${y2 + dy} 
            Z
          "
        />
      </svg>
      `;
    } else {
      return "";
    }
  }
  makeConnectedPath(points2) {
    var manager = new PathStringManager();
    var first = points2[0];
    var last2 = points2[points2.length - 1];
    if (!first)
      return "";
    if (!last2)
      return "";
    var dist2 = Math.abs(first.x - last2.x) / 2;
    manager.M(first).C({ x: first.x + dist2, y: first.y }, { x: last2.x - dist2, y: last2.y }, last2);
    return manager.d;
  }
  createPath(sourceItem, connectedInfo) {
    if (connectedInfo.path) {
      return connectedInfo.path;
    }
    var sourceX = sourceItem.bound.x + connectedXAxis["1"][0];
    var sourceY = sourceItem.bound.y + connectedYAxis["1"][0];
    var target = this.state.filters.map((it, index3) => {
      return { it, index: index3 };
    }).find((it) => {
      if (!it)
        return false;
      if (!it.it)
        return false;
      return it && it.it.id === connectedInfo.id;
    });
    var len2 = `${target.it.getInCount()}`;
    var source2 = target.it.in.map((it, index3) => {
      return { it, index: index3 };
    }).find((it) => {
      if (!it)
        return false;
      if (!it.it)
        return false;
      return it.it.id === sourceItem.id;
    });
    if (!source2) {
      return [];
    }
    var index2 = source2.index;
    var targetX = target.it.bound.x + inXAxis[len2][0];
    var targetY = target.it.bound.y + inYAxis[len2][index2];
    return [{ x: sourceX, y: sourceY }, { x: targetX, y: targetY }];
  }
  [LOAD("$connectedLinePanel")]() {
    return `
      <svg>
        ${this.state.filters.map((it) => {
      return it.connected.map((connectedItem) => {
        var path = this.createPath(it, connectedItem);
        var sourceType = getSourceTypeString(it.type);
        return `
              <path 
                class="connected-line"
                data-source-type="${sourceType}"
                d="${this.makeConnectedPath(path)}"
              />

              ${path.length && `
                <circle 
                  data-source-type="${sourceType}"
                  data-target-id="${connectedItem.id}"
                  data-source-id="${it.id}"
                  class="connected-remove-circle"
                  cx="${(path[0].x + path[1].x) / 2}"
                  cy="${(path[0].y + path[1].y) / 2}"
                />
              `}
              
            `;
      }).join("");
    }).join("")}
      </svg>
    `;
  }
  [CLICK("$connectedLinePanel .connected-remove-circle")](e2) {
    var [tid, sid] = e2.$dt.attrs("data-target-id", "data-source-id");
    var filters = this.state.filters;
    filters.filter((it) => it.id === sid).forEach((it) => {
      it.connected = it.connected.filter((c2) => c2.id != tid);
    });
    filters.filter((it) => it.id === tid).forEach((it) => {
      it.in = it.in.map((inObject) => {
        if (inObject && inObject.id == sid) {
          return null;
        }
        return inObject;
      });
    });
    this.refresh();
    this.modifyFilter();
  }
  getCenterXY($target) {
    var inRect = $target.rect();
    var x2 = inRect.x - this.rect.x;
    var y2 = inRect.y - this.rect.y;
    var centerX = x2 + inRect.width / 2;
    var centerY = y2 + inRect.height / 2;
    return { x: centerX, y: centerY };
  }
  end(dx, dy) {
    if (this.pointType === "in" || this.pointType === "out") {
      this.startXY.dx = dx;
      this.startXY.dy = dy;
      var filter2 = this.state.selectedFilter;
      var e2 = this.$config.get("bodyEvent");
      var $target = Dom.create(e2.target);
      var $targetNode = $target.closest("filter-node");
      if (this.pointType === "out") {
        if ($target.hasClass("in")) {
          var targetFilter = this.state.filters[+$targetNode.attr("data-index")];
          if (targetFilter) {
            if (!targetFilter.hasLight() && filter2.isLight())
              ;
            else {
              var targetIndex = +$target.attr("data-index");
              if (!targetFilter.in[targetIndex]) {
                targetFilter.setIn(targetIndex, filter2);
                filter2.setConnected(targetFilter);
              }
            }
          }
        }
      } else if (this.pointType === "in") {
        if ($target.hasClass("out")) {
          var targetFilter = this.state.filters[+$targetNode.attr("data-index")];
          if (targetFilter) {
            if (filter2.hasLight() && !targetFilter.isLight())
              ;
            else {
              if (!filter2.in[this.pointIndex]) {
                filter2.setIn(this.pointIndex, targetFilter);
                targetFilter.setConnected(filter2);
              }
            }
          }
        }
      }
      this.pointType = "";
    }
    this.load("$dragLinePanel");
    this.load("$connectedLinePanel");
    this.modifyFilter();
  }
  move(dx, dy) {
    var filter2 = this.state.selectedFilter;
    if (filter2) {
      this.startXY.dx = dx;
      this.startXY.dy = dy;
      if (this.pointType === "in") {
        this.load("$dragLinePanel");
      } else if (this.pointType === "out") {
        this.load("$dragLinePanel");
      } else {
        filter2.reset({
          bound: { x: this.startXY.x + dx, y: this.startXY.y + dy }
        });
        this.$target.css({
          left: filter2.bound.x,
          top: filter2.bound.y
        });
        this.load("$connectedLinePanel");
      }
    }
  }
  makeGraphPanel() {
    return this.state.filters.map((it, index2) => {
      const selectedClass = index2 === this.state.selectedIndex ? "selected" : "";
      return `
        <div class='filter-node ${selectedClass}' data-type="${it.type}" data-index="${index2}" data-filter-id="${it.id}" style='left: ${it.bound.x}px;top: ${it.bound.y}px;'>
          <div class='label'>${this.$i18n(it.type)}</div>
          <div class='remove'>${iconUse$1("close")}</div>
          <div class='preview' data-source-type="${getSourceTypeString(it.type)}" data-filter-type='${it.type}'>${getIcon(it.type)}</div>
          <div class='in-list'>
            ${repeat$1(it.getInCount()).map((itIn, inIndex) => {
        return `<div class='in' data-index='${inIndex}'></div>`;
      }).join("")}
          </div>
          
          <div class='out' data-index="0">${iconUse$1("chevron_right")}</div>
          ${it.hasLight() ? `<div class='light'  data-index="0"></div>` : ""}
        </div>
      `;
    });
  }
  [SUBSCRIBE_SELF("changeFuncFilterEditor")](key, value) {
    var filter2 = this.state.selectedFilter;
    if (filter2) {
      filter2.reset({
        [key]: value
      });
    }
    this.modifyFilter();
  }
  [SUBSCRIBE_SELF("changeRangeEditor")](key, value) {
    var filter2 = this.state.selectedFilter;
    if (filter2) {
      filter2.reset({
        [key]: value
      });
    }
    this.modifyFilter();
  }
  [SUBSCRIBE_SELF("changeTextEditor")](key, value) {
    var filter2 = this.state.selectedFilter;
    if (filter2) {
      filter2.reset({
        [key]: value
      });
    }
    this.modifyFilter();
  }
  removeFilter(id) {
    var filters = this.state.filters.filter((it) => it.id != id);
    filters.forEach((it) => {
      it.connected = it.connected.filter((c2) => c2.id != id);
      it.in = it.in.filter((c2) => c2.id != id);
    });
    if (this.state.selectedFilter.id === id) {
      this.state.selectedFilter = null;
      this.state.selectedIndex = -1;
    }
    this.setState({
      filters
    });
    this.modifyFilter();
  }
  [CLICK("$graphPanel .filter-node .remove")](e2) {
    var $target = e2.$dt.closest("filter-node");
    var index2 = +$target.attr("data-index");
    var f = this.state.filters[index2];
    this.removeFilter(f.id);
  }
}
var SVGFilterPopup$1 = "";
class SVGFilterPopup extends BasePopup {
  getTitle() {
    return this.$i18n("svgfilter.popup.title");
  }
  getClassName() {
    return "transparent";
  }
  initState() {
    return {
      changeEvent: "changeSVGFilterPopup",
      id: "",
      preview: true,
      filters: []
    };
  }
  updateData(opt) {
    this.setState(opt, false);
    this.emit(this.state.changeEvent, this.state);
  }
  getBody() {
    return `
    <div class='elf--svg-filter-popup' ref='$popup'>
      <div class="box">
        <div class='editor' ref='$editor'></div>
      </div>
    </div>`;
  }
  [LOAD("$editor")]() {
    return createComponent("SVGFilterEditor", {
      ref: "$filter",
      title: "Filter Type",
      key: "filter",
      value: this.state.filters,
      onchange: (key, filters) => {
        this.updateData({
          filters
        });
      }
    });
  }
  [SUBSCRIBE("showSVGFilterPopup")](data) {
    data.filters = data.filters.map((it) => {
      return SVGFilter.parse(it);
    });
    data.preview = isNotUndefined(data.preview) ? data.preview : true;
    this.setState(data);
    this.show(1e3);
  }
  [SUBSCRIBE("hideSVGFilterPopup")]() {
    this.$el.hide();
  }
}
var SVGFilterSelectEditor$1 = "";
class SVGFilterSelectEditor extends EditorElement {
  initState() {
    var value = this.props.value;
    return {
      options: [],
      label: this.props.label || "",
      value
    };
  }
  template() {
    var { label } = this.state;
    var hasLabel = !!label ? "has-label" : "";
    return `
            <div class='elf--svg-filter-select-editor ${hasLabel}'>
                ${label ? `<label>${label}</label>` : ""}
                <select ref='$options'></select>
                <button type='button' class='open thin' ref='$open' title='Open SVG Filter Editor'>${obj.fullscreen}</button>
                <button type='button' class='remove thin' ref='$remove' title='Remove'>${obj.remove}</button>
            </div>
        `;
  }
  [CLICK("$remove")](e2) {
    this.updateData({
      value: ""
    });
  }
  [CLICK("$open")](e2) {
    var value = this.state.value;
    if (value.includes("id")) {
      var currentProject = this.$selection.currentProject;
      var index2 = currentProject.getSVGFilterIndex(value);
      if (index2 > -1) {
        this.trigger("openSVGFilterPopup", index2);
      }
    }
  }
  getValue() {
    return this.state.value;
  }
  setValue(value) {
    this.setState({ value });
  }
  refresh(reload = false) {
    this.load();
  }
  [BIND("$options")]() {
    return {
      "data-count": this.state.options.length.toString()
    };
  }
  [LOAD("$options")]() {
    var current = this.$selection.currentProject;
    var options2 = "";
    if (current) {
      options2 = current.svgfilters.map((it) => it.id);
      options2 = options2.length ? "," + options2.join(",") : "";
    }
    options2 += ",-,new";
    options2 = options2.split(",");
    var arr = options2.map((it) => {
      var value = it;
      var label = it;
      if (value.includes(":")) {
        var [value, label] = value.split(":");
      }
      if (label === "") {
        label = this.props["none-value"] ? this.props["none-value"] : "";
      } else if (label === "-") {
        label = "----------";
        value = "";
      }
      var selected = value === this.state.value ? "selected" : "";
      return `<option ${selected} value="${value}">${label}</option>`;
    });
    return arr;
  }
  setOptions(options2 = "") {
    this.setState({
      options: options2.split(this.state.splitChar).map((it) => it.trim())
    });
  }
  sendMessage(type) {
    if (type === "new") {
      this.emit("addStatusBarMessage", this.$i18n("svgfilter.select.editor.message.create"));
    } else if (type === "-") {
      this.emit("addStatusBarMessage", this.$i18n("svgfilter.select.editor.message.select"));
    } else {
      this.emit("addStatusBarMessage", "");
    }
  }
  [CHANGE("$options")]() {
    var value = this.refs.$options.value;
    if (value == "new") {
      this.emit("addSVGFilterAssetItem", (index2, id) => {
        this.updateData({ value: id });
        this.refresh();
        this.trigger("openSVGFilterPopup", index2);
      });
    } else if (value === "-")
      ;
    else {
      this.updateData({ value });
    }
  }
  updateData(data) {
    this.setState(data, false);
    this.parent.trigger(this.props.onchange, this.props.key, this.state.value, this.props.params);
  }
  [SUBSCRIBE("refreshSVGArea") + DEBOUNCE(1e3)]() {
    this.load("$options");
  }
  [SUBSCRIBE("openSVGFilterPopup")](index2) {
    this.emit("refreshSVGFilterAssets");
    this.emit("refreshSVGArea");
    var currentProject = this.$selection.currentProject || { svgfilters: [] };
    var svgfilter = currentProject.svgfilters[index2];
    this.emit("showSVGFilterPopup", {
      changeEvent: "changeSVGFilterEditorRealUpdate",
      preview: false,
      index: index2,
      filters: svgfilter.filters
    });
  }
  [SUBSCRIBE("changeSVGFilterEditorRealUpdate")](params) {
    var project2 = this.$selection.currentProject;
    if (project2) {
      project2.setSVGFilterValue(params.index, {
        filters: params.filters
      });
      this.emit("refreshSVGFilterAssets");
      this.emit("refreshSVGArea");
    }
  }
}
function svgItem(editor) {
  editor.registerElement({
    ColorMatrixEditor,
    FuncFilterEditor,
    SVGFilterSelectEditor,
    SVGFilterEditor
  });
  editor.registerMenuItem("inspector.tab.style", {
    SVGItemProperty: ObjectProperty.create({
      title: editor.$i18n("svg.item.property.title"),
      editableProperty: "svg-item",
      preventUpdate: true
    })
  });
  editor.registerMenuItem("popup", {
    SVGFilterPopup
  });
  editor.registerInspector("svg-item", (current) => {
    return [
      {
        key: "edit",
        editor: "Button",
        editorOptions: {
          text: "Edit",
          action: ["open.editor", current]
        }
      },
      {
        type: "column",
        size: [2, 1],
        columns: [
          { type: "label", label: editor.$i18n("svg.item.property.fill") },
          {
            key: "fill-rule",
            editor: "ToggleCheckBox",
            editorOptions: {
              toggleLabels: ["join_full", "join_right"],
              toggleValues: ["nonzero", "evenodd"]
            },
            defaultValue: current["fill-rule"] || "nonzero"
          }
        ]
      },
      {
        type: "column",
        size: [2, 1],
        columns: [
          {
            key: "fill",
            editor: "FillSingleEditor",
            editorOptions: {
              wide: true
            },
            defaultValue: current["fill"]
          },
          {
            key: "fill-opacity",
            editor: "number-input",
            editorOptions: {
              compact: true,
              label: "opacity",
              min: 0,
              max: 1,
              step: 0.01
            },
            defaultValue: current["fill-opacity"]
          }
        ]
      },
      {
        type: "column",
        size: [2, 1],
        columns: [
          { type: "label", label: editor.$i18n("svg.item.property.stroke") }
        ]
      },
      {
        type: "column",
        size: [2, 1],
        columns: [
          {
            key: "stroke",
            editor: "fill-single",
            editorOptions: {
              wide: true
            },
            defaultValue: current["stroke"]
          },
          {
            key: "stroke-width",
            editor: "number-input",
            editorOptions: {
              compact: true,
              label: "line_weight"
            },
            defaultValue: current["stroke-width"]
          }
        ]
      },
      {
        type: "column",
        size: [2, 1],
        columns: [
          {
            key: "stroke-dasharray",
            editor: "StrokeDashArrayEditor",
            editorOptions: {
              label: editor.$i18n("svg.item.property.dashArray")
            },
            defaultValue: current["stroke-dasharray"] || ""
          },
          {
            key: "stroke-dashoffset",
            editor: "number-input",
            editorOptions: {
              compact: true,
              label: "power_input",
              min: -1e3,
              max: 1e3,
              step: 1
            },
            defaultValue: current["stroke-dashoffset"]
          }
        ]
      },
      {
        key: "stroke-linecap",
        editor: "ToggleCheckBox",
        editorOptions: {
          label: editor.$i18n("svg.item.property.lineCap"),
          toggleLabels: ["line_cap_butt", "line_cap_round", "line_cap_square"],
          toggleValues: [StrokeLineCap.BUTT, StrokeLineJoin.ROUND, StrokeLineCap.SQUARE]
        },
        defaultValue: current["stroke-linecap"] || StrokeLineCap.BUTT
      },
      {
        key: "stroke-linejoin",
        editor: "ToggleCheckBox",
        editorOptions: {
          label: editor.$i18n("svg.item.property.lineJoin"),
          toggleLabels: ["line_join_miter", "line_join_round", "line_join_bevel"],
          toggleValues: [StrokeLineJoin.MITER, StrokeLineJoin.ROUND, StrokeLineJoin.BEVEL]
        },
        defaultValue: current["stroke-linejoin"] || StrokeLineJoin.MITER
      },
      {
        key: "mix-blend-mode",
        editor: "BlendSelectEditor",
        editorOptions: {
          label: editor.$i18n("svg.item.property.blend")
        },
        defaultValue: current["mix-blend-mode"]
      }
    ];
  });
  editor.registerInspector("polygon", (item2) => {
    return [
      {
        key: "count",
        editor: "NumberInputEditor",
        editorOptions: {
          label: "Count",
          min: 3,
          max: 100,
          step: 1
        },
        defaultValue: item2.count
      },
      {
        key: "button",
        editor: "Button",
        editorOptions: {
          label: "Copy ",
          text: "as path",
          action: "copy.path"
        }
      },
      {
        key: "button2",
        editor: "Button",
        editorOptions: {
          label: "Test Popup",
          action: [
            "showComponentPopup",
            {
              title: "Sample Test Popup",
              width: 400,
              inspector: [
                {
                  key: "test",
                  editor: "Button",
                  editorOptions: {
                    label: "Test",
                    text: "text",
                    onClick: () => {
                      alert("yellow");
                    }
                  }
                }
              ]
            }
          ]
        }
      }
    ];
  });
  editor.registerInspector("spline", (item2) => {
    return [
      {
        key: "boundary",
        editor: "SelectIconEditor",
        editorOptions: {
          label: "Boundary",
          options: ["clamped", "open", "closed"]
        }
      },
      {
        key: "button",
        editor: "Button",
        editorOptions: {
          label: "Copy ",
          text: "as path",
          action: "copy.path"
        }
      }
    ];
  });
  editor.registerInspector("star", (item2) => {
    return [
      {
        key: "isCurve",
        editor: "ToggleCheckBox",
        editorOptions: {
          label: "Curve",
          defaultValue: item2.isCurve
        }
      },
      {
        key: "count",
        editor: "NumberInputEditor",
        editorOptions: {
          label: "Count",
          min: 1,
          max: 100,
          step: 1,
          wide: "true"
        }
      },
      {
        key: "radius",
        editor: "NumberInputEditor",
        editorOptions: {
          label: "Inner Radius",
          min: -1,
          max: 1,
          step: 0.01,
          wide: "true"
        }
      },
      {
        key: "tension",
        editor: "NumberInputEditor",
        editorOptions: {
          label: "Tension",
          min: 0,
          max: 1,
          step: 0.01,
          wide: "true"
        }
      },
      {
        key: "button",
        editor: "Button",
        editorOptions: {
          label: "Copy ",
          text: "as path",
          action: "copy.path"
        }
      }
    ];
  });
}
class SVGTextProperty extends BaseProperty {
  getTitle() {
    return this.$i18n("svg.text.property.title");
  }
  [SUBSCRIBE("refreshSelection")]() {
    this.refreshShow(["svg-textpath", "svg-text", "svg-tspan"]);
  }
  refresh() {
    var current = this.$selection.current;
    if (current) {
      this.setAllValue([
        "lengthAdjust",
        "textLength",
        "startOffset",
        "text-anchor",
        "text"
      ]);
    }
  }
  setAllValue(list2 = []) {
    var current = this.$selection.current;
    if (!current)
      return;
    list2.forEach((key) => {
      this.children[`$${key}`].setValue(current[key]);
    });
  }
  getBody() {
    return `
      <div class='property-item '>
        ${createComponent("TextAreaEditor", {
      ref: "$text",
      label: this.$i18n("svg.text.property.textarea"),
      key: "text",
      onchange: "changeTextValue"
    })}
      </div>        
      <div class='property-item'>
        ${createComponent("SelectIconEditor", {
      ref: "$text-anchor",
      label: this.$i18n("svg.text.property.anchor"),
      key: "text-anchor",
      options: ["start", "middle", "end"],
      onchange: "changeTextValue"
    })}
          
      </div>            
      <div class='property-item '>
        ${createComponent("SelectEditor", {
      ref: "$lengthAdjust",
      label: this.$i18n("svg.text.property.length.adjust"),
      key: "lengthAdjust",
      value: "spacing",
      options: ["spacing", "spacingAndGlyphs"],
      onchange: "changeTextValue"
    })}
          
      </div>        
      <div class='property-item '>
        ${createComponent("RangeEditor", {
      ref: "$textLength",
      label: this.$i18n("svg.text.property.text.length"),
      key: "textLength",
      min: 0,
      max: 1e3,
      step: 0.1,
      onchange: "changeTextValue"
    })}
          
      </div>        
      <div class='property-item '>
        ${createComponent("RangeEditor", {
      ref: "$startOffset",
      label: this.$i18n("svg.text.property.start.offset"),
      key: "startOffset",
      min: 0,
      max: 1e3,
      step: 0.1,
      onchange: "changeTextValue"
    })}
          
      </div>                    
    `;
  }
  [SUBSCRIBE_SELF("changeTextValue")](key, value) {
    this.command("setAttributeForMulti", `change svg text property: ${key}`, this.$selection.packByValue({
      [key]: value
    }));
  }
}
function svgText(editor) {
  editor.registerMenuItem("inspector.tab.style", {
    SVGTextProperty
  });
}
function text$1(editor) {
  editor.registerMenuItem("inspector.tab.style", {
    TextProperty: ObjectProperty.create({
      title: editor.$i18n("text.property.title"),
      editableProperty: "text-style",
      preventUpdate: true
    })
  });
  editor.registerInspector("text-style", (current) => {
    return [
      {
        type: "column",
        size: [2, 1, 1],
        columns: [
          {
            key: "text-align",
            editor: "SelectIconEditor",
            editorOptions: {
              compact: true,
              options: ["left", "center", "right", "justify"],
              icons: ["align_left", "align_center", "align_right", "align_justify"]
            },
            defaultValue: current["text-align"] || "left"
          },
          "-",
          {
            key: "text-transform",
            editor: "SelectIconEditor",
            editorOptions: {
              options: [
                { value: TextTransform.CAPITALIZE, text: "Ag" },
                { value: TextTransform.UPPERCASE, text: "AG" },
                { value: TextTransform.LOWERCASE, text: "ag" }
              ],
              compact: true,
              icons: ["horizontal_rule"]
            }
          }
        ]
      },
      {
        type: "column",
        size: [3, 2, 1],
        gap: 20,
        columns: [
          {
            key: "text-decoration",
            editor: "SelectIconEditor",
            editorOptions: {
              options: [
                { value: TextDecoration.NONE, text: "None" },
                { value: TextDecoration.UNDERLINE, text: "Underline" },
                { value: TextDecoration.LINE_THROUGH, text: "LineThrough" }
              ],
              icons: ["horizontal_rule", "underline", "strikethrough"],
              onchange: "changeTextValue"
            },
            defaultValue: current["text-tranform"]
          },
          {
            key: "font-style",
            editor: "SelectIconEditor",
            editorOptions: {
              compact: true,
              options: ["normal", "italic"],
              icons: ["title", "italic"]
            },
            defaultValue: current["font-style"]
          },
          {
            key: "text-clip",
            editor: "ToggleButton",
            editorOptions: {
              checkedValue: TextClip.TEXT,
              toggleLabels: ["vignette", "vignette"],
              toggleTitles: ["", "Text Clip"],
              toggleValues: [TextClip.NONE, TextClip.TEXT]
            },
            defaultValue: current["text-clip"] || TextClip.NONE
          }
        ]
      }
    ];
  });
}
var TextShadowEditor$1 = "";
class TextShadowEditor extends EditorElement {
  initState() {
    return {
      textShadows: TextShadow.parseStyle(this.props.value)
    };
  }
  template() {
    return `
      <div class="elf--text-shadow-editor" >
        <div class='text-shadow-list' ref='$shadowList'></div>
      </div>
    `;
  }
  [LOAD("$shadowList")]() {
    var arr = this.state.textShadows.map((shadow2, index2) => {
      return `
        <div class="shadow-item real" data-index="${index2}">
          <label draggable="true" data-index="${index2}">${iconUse$1("drag_indicator")}</label>
          ${createComponent("ColorViewEditor", {
        mini: true,
        key: "color",
        value: shadow2.color,
        params: index2,
        onchange: "changeKeyValue"
      })}
          ${createComponent("NumberInputEditor", {
        mini: true,
        key: "offsetX",
        label: "X",
        value: shadow2.offsetX,
        params: index2,
        onchange: "changeKeyValue"
      })}          
          ${createComponent("NumberInputEditor", {
        mini: true,
        key: "offsetY",
        label: "Y",
        value: shadow2.offsetY,
        params: index2,
        onchange: "changeKeyValue"
      })}                    
          ${createComponent("NumberInputEditor", {
        mini: true,
        label: "B",
        key: "blurRadius",
        value: shadow2.blurRadius,
        params: index2,
        onchange: "changeKeyValue"
      })}                    
          <div class="tools">
            <button type="button" class="remove" data-index="${index2}">
              ${iconUse$1("remove2")}
            </button>
          </div>
        </div>
      `;
    });
    return arr.join("");
  }
  modifyTextShadow() {
    var value = this.state.textShadows.join(", ");
    this.parent.trigger(this.props.onchange, this.props.key, value);
  }
  [SUBSCRIBE("add")](shadow2 = "") {
    if (shadow2) {
      this.state.textShadows = TextShadow.parseStyle(shadow2);
    } else {
      this.state.textShadows.push(new TextShadow());
    }
    this.refresh();
    this.modifyTextShadow();
  }
  [CLICK("$add")]() {
    this.trigger("add");
  }
  [DRAGSTART("$shadowList .shadow-item > label")](e2) {
    this.startIndex = +e2.$dt.attr("data-index");
  }
  [DRAGOVER("$shadowList .shadow-item") + PREVENT](e2) {
  }
  sortItem(arr, startIndex, targetIndex) {
    arr.splice(targetIndex + (startIndex < targetIndex ? -1 : 0), 0, ...arr.splice(startIndex, 1));
  }
  sortTextShadow(startIndex, targetIndex) {
    this.sortItem(this.state.textShadows, startIndex, targetIndex);
  }
  [DROP("$shadowList .shadow-item") + PREVENT](e2) {
    var targetIndex = +e2.$dt.attr("data-index");
    this.sortTextShadow(this.startIndex, targetIndex);
    this.refresh();
    this.modifyTextShadow();
  }
  [CLICK("$shadowList .remove")](e2) {
    var index2 = +e2.$dt.attr("data-index");
    this.state.textShadows.splice(index2, 1);
    this.refresh();
    this.modifyTextShadow();
  }
  [SUBSCRIBE("changeKeyValue")](key, value, index2) {
    var shadow2 = this.state.textShadows[index2];
    shadow2.reset({
      [key]: value
    });
    this.modifyTextShadow();
  }
}
var textShadow$1 = [
  { name: "Mystic", shadow: `20px 0px 10px rgb(0, 0, 0)` },
  { name: "Monoton", shadow: `0px -78px rgb(255, 196, 0)` },
  { name: "Radioactive", shadow: `-18px -18px 20px rgb(87, 255, 9);` },
  { name: "Bungee", shadow: `-18px 18px 0 rgb(66, 45, 45)` },
  { name: "Sprint", shadow: `-20px -108px 0px rgba(255, 255, 255, 0.445)` },
  { name: "Prickly", shadow: `-18px -18px 2px #777` },
  { name: "Codystar", shadow: `1px 1px 10px rgb(16, 72, 255), 1px 1px 10px rgb(0, 195, 255)` },
  { name: "Elegant", shadow: `-18px 8px 18px #b4bbbb` },
  { name: "Playful", shadow: `
        -2px -2px 0px #888,
        4px 4px 0px #888,
        7px 7px 0px #888
    ` }
];
var TextShadowProperty$1 = "";
class TextShadowProperty extends BaseProperty {
  getTitle() {
    return this.$i18n("text.shadow.property.title");
  }
  getBody() {
    return `
      <div class="full text-shadow-item" ref="$shadowList"></div>
    `;
  }
  getTools() {
    return `
      <select class='text-shadow-samples' ref="$select">
      ${textShadow$1.map((item2, index2) => {
      return `
          <option value="${index2}">${item2.name}</option>
        `;
    }).join("")}
      </select>
      <button type="button" ref='$add'>${obj.add}</button>
    `;
  }
  [CLICK("$add")]() {
    const index2 = +this.refs.$select.value;
    this.children.$textshadow.trigger("add", textShadow$1[index2].shadow);
  }
  [LOAD("$shadowList")]() {
    var current = this.$selection.current || {};
    return createComponent("TextShadowEditor", {
      ref: "$textshadow",
      key: "text-shadow",
      value: current["text-shadow"],
      onchange: (key, value) => {
        this.command("setAttributeForMulti", "change text shadow", this.$selection.packByValue({
          [key]: value
        }));
      }
    });
  }
  get editableProperty() {
    return "text-shadow";
  }
  [SUBSCRIBE("refreshSelection") + IF("checkShow") + DEBOUNCE(100)]() {
    this.refresh();
  }
}
function textShadow(editor) {
  editor.registerElement({
    TextShadowEditor
  });
  editor.registerMenuItem("inspector.tab.style", {
    TextShadowProperty
  });
}
const TRANSITION_TIMING_REG = /((cubic-bezier|steps)\(([^\)]*)\))/gi;
class Transition extends PropertyItem {
  static parse(obj2) {
    return new Transition(obj2);
  }
  getDefaultObject() {
    return {
      name: "all",
      duration: Length.second(0),
      timingFunction: "linear",
      delay: Length.second(0)
    };
  }
  toCloneObject() {
    return {
      name: this.json.name,
      duration: this.json.duration + "",
      timingFunction: this.json.timingFunction,
      delay: this.json.delay + ""
    };
  }
  toCSS() {
    return {
      "transition": this.toString()
    };
  }
  toString() {
    var json = this.json;
    return [
      json.name,
      json.duration,
      json.timingFunction,
      json.delay
    ].join(" ");
  }
  static join(list2) {
    return list2.map((it) => new Transition(it).toString()).join(",");
  }
  static add(transition2, item2 = {}) {
    const list2 = Transition.parseStyle(transition2);
    list2.push(Transition.parse(item2));
    return Transition.join(list2);
  }
  static remove(transition2, removeIndex) {
    return Transition.filter(transition2, (it, index2) => {
      return removeIndex != index2;
    });
  }
  static filter(transition2, filterFunction) {
    return Transition.join(Transition.parseStyle(transition2).filter((it) => filterFunction(it)));
  }
  static replace(transition2, replaceIndex, valueObject) {
    var list2 = Transition.parseStyle(transition2);
    if (list2[replaceIndex]) {
      list2[replaceIndex] = valueObject;
    } else {
      list2.push(valueObject);
    }
    return Transition.join(list2);
  }
  static get(transition2, index2) {
    var arr = Transition.parseStyle(transition2);
    return arr[index2];
  }
  static parseStyle(transition2) {
    var list2 = [];
    if (!transition2)
      return list2;
    const result = customParseConvertMatches(transition2, TRANSITION_TIMING_REG);
    list2 = result.str.split(",").map((it) => {
      const fields2 = it.split(" ").filter(Boolean);
      if (fields2.length >= 4) {
        return {
          name: fields2[0],
          duration: Length.parse(fields2[1]),
          timingFunction: customParseReverseMatches(fields2[2], result.matches),
          delay: Length.parse(fields2[3])
        };
      } else if (fields2.length >= 3) {
        return {
          name: fields2[0],
          duration: Length.parse(fields2[1]),
          delay: Length.parse(fields2[2])
        };
      } else if (fields2.length >= 1) {
        return {
          name: fields2[0],
          duration: Length.parse(fields2[1])
        };
      } else {
        return {};
      }
    });
    return list2.map((it) => Transition.parse(it));
  }
}
var TransitionProperty$1 = "";
class TransitionProperty extends BaseProperty {
  initialize() {
    super.initialize();
    this.notEventRedefine = true;
  }
  getTitle() {
    return this.$i18n("transition.property.title");
  }
  getBody() {
    return `<div class='elf--transition-list' ref='$transitionList'></div>`;
  }
  getTools() {
    return `
        <button type="button" ref="$add" title="add Transition">${iconUse$1("add")}</button>
    `;
  }
  isFirstShow() {
    return true;
  }
  [LOAD("$transitionList") + DOMDIFF]() {
    var current = this.$selection.current;
    if (!current)
      return "";
    return Transition.parseStyle(current.transition).map((it, index2) => {
      const selectedClass = this.state.selectedIndex === index2 ? "selected" : "";
      const path = curveToPath(it.timingFunction, 30, 30);
      return `
      <div class='transition-group-item'>
        <div class='transition-item ${selectedClass}' data-index='${index2}' ref="transitionIndex${index2}">
            <div class='timing preview' data-index='${index2}' ref='$preview${index2}'>
              <svg class='item-canvas' width="30" height="30" viewBox="0 0 30 30">
                <path d="${path}" stroke="white" stroke-width="1" fill='none' />
              </svg>
            </div>
            <div class='name'>
              <div class='labels'>
                <span class='property-name' title='Property'>${it.name}</span>
                <span class='duration' title='Duration'><small>Duration: ${it.duration}</small></span>
                <span class='delay' title='Delay'><small>Delay: ${it.delay}</small></span>
              </div>
            </div>
            <div class='tools'>
                <button type="button" class="del" data-index="${index2}">
                  ${iconUse$1("remove2")}
                </button>
            </div>
        </div>
      </div>        
      `;
    });
  }
  [SUBSCRIBE("refreshSelection")]() {
    this.refreshShowIsNot([]);
  }
  [CLICK("$add")](e2) {
    var current = this.$selection.current;
    if (current) {
      this.command("setAttributeForMulti", "add transition", this.$selection.packByValue({
        transition: (item2) => Transition.add(item2.transition)
      }));
      this.nextTick(() => {
        setTimeout(() => {
          this.refresh();
        }, 100);
      });
    } else {
      alert("Select a layer");
    }
  }
  getCurrentTransition() {
    return this.current.transitions[this.selectedIndex];
  }
  [CLICK("$transitionList .tools .del")](e2) {
    var removeIndex = e2.$dt.attr("data-index");
    var current = this.$selection.current;
    if (!current)
      return;
    current.reset({
      transition: Transition.remove(current.transition, removeIndex)
    });
    this.emit("refreshElement", current);
    this.refresh();
  }
  selectItem(selectedIndex, isSelected = true) {
    if (isSelected) {
      this.refs[`transitionIndex${selectedIndex}`].addClass("selected");
    } else {
      this.refs[`transitionIndex${selectedIndex}`].removeClass("selected");
    }
  }
  viewTransitionPicker($preview) {
    if (typeof this.selectedIndex === "number") {
      this.selectItem(this.selectedIndex, false);
    }
    this.selectedIndex = +$preview.attr("data-index");
    this.current = this.$selection.current;
    if (!this.current)
      return;
    this.currentTransition = Transition.get(this.current.transition, this.selectedIndex);
    this.viewTransitionPropertyPopup();
  }
  viewTransitionPropertyPopup() {
    if (!this.currentTransition)
      return;
    const transition2 = this.currentTransition;
    this.emit("showTransitionPropertyPopup", {
      changeEvent: "changeTransitionPropertyPopup",
      data: transition2.toCloneObject(),
      instance: this
    });
  }
  [CLICK("$transitionList .preview")](e2) {
    this.viewTransitionPicker(e2.$dt);
  }
  getRef(...args2) {
    return this.refs[args2.join("")];
  }
  [SUBSCRIBE("changeTransitionPropertyPopup")](data) {
    if (this.currentTransition) {
      this.currentTransition.reset(__spreadValues({}, data));
      if (this.current) {
        this.current.reset({
          transition: Transition.replace(this.current.transition, this.selectedIndex, this.currentTransition)
        });
        this.emit("refreshElement", this.current);
        this.refresh();
      }
    }
  }
}
var TransitionPropertyPopup$1 = "";
const property_list = [
  "none",
  "all",
  "background-color",
  "background-position",
  "background-size",
  "border",
  "border-color",
  "border-width",
  "border-bottom",
  "border-bottom-color",
  "border-bottom-left-radius",
  "border-bottom-right-radius",
  "border-bottom-width",
  "border-left",
  "border-left-color",
  "border-left-width",
  "border-radius",
  "border-right",
  "border-right-color",
  "border-right-width",
  "border-spacing",
  "border-top",
  "border-top-color",
  "border-top-left-radius",
  "border-top-right-radius",
  "border-top-width",
  "bottom",
  "box-shadow",
  "color",
  "filter",
  "font-size",
  "font-size-adjust",
  "font-weight",
  "height",
  "left",
  "letter-spacing",
  "line-height",
  "margin",
  "margin-bottom",
  "margin-left",
  "margin-right",
  "margin-top",
  "max-height",
  "max-width",
  "min-height",
  "min-width",
  "opacity",
  "padding",
  "padding-bottom",
  "padding-left",
  "padding-right",
  "padding-top",
  "perspective",
  "perspective-origin",
  "right",
  "text-decoration",
  "text-decoration-color",
  "text-indent",
  "text-shadow",
  "top",
  "transform",
  "vertical-align",
  "visibility",
  "width",
  "word-spacing",
  "z-index"
].map((it) => ({
  value: it,
  text: it
}));
class TransitionPropertyPopup extends BasePopup {
  getTitle() {
    return "Transition";
  }
  initState() {
    return {
      changeEvent: "",
      instance: {},
      data: {
        timingFunction: "linear",
        duration: "0s",
        delay: "0s",
        name: "all"
      }
    };
  }
  updateData(opt) {
    this.state.data = __spreadValues(__spreadValues({}, this.state.data), opt);
    if (this.state.instance) {
      this.state.instance.trigger(this.state.changeEvent, this.state.data);
    }
  }
  getBody() {
    return `<div class='elf--transition-property-popup' ref='$popup'></div>`;
  }
  [LOAD("$popup")]() {
    return `
      <div class="box">
        ${this.templateForProperty()}
        ${this.templateForTimingFunction()}
        ${this.templateForDelay()}
        ${this.templateForDuration()}
      </div>
    `;
  }
  templateForTimingFunction() {
    return `
    <div class='timing-function'>
      <label>Timing function</label>
      ${createComponent("CubicBezierEditor", {
      ref: "$cubicBezierEditor",
      key: "timingFunction",
      value: this.state.data.timingFunction || "linear",
      onChange: "changeCubicBezier"
    })}
    </div>
    `;
  }
  [SUBSCRIBE_SELF("changeTransition")](key, value) {
    this.updateData({
      [key]: value
    });
  }
  templateForProperty() {
    return `
      <div class='name'>
        ${createComponent("SelectEditor", {
      ref: "$property",
      icon: true,
      label: "Property",
      key: "name",
      value: this.state.data.name,
      options: property_list,
      onChange: "changeTransition"
    })}
      </div>
    `;
  }
  templateForDelay() {
    return `
    <div class='delay'>
      ${createComponent("RangeEditor", {
      ref: "$delay",
      label: "Delay",
      key: "delay",
      value: this.state.data.delay,
      units: ["s", "ms"],
      onChange: "changeRangeEditor"
    })}
    </div>
    `;
  }
  templateForDuration() {
    return `
    <div class='duration'>
      ${createComponent("RangeEditor", {
      ref: "$duration",
      label: "Duration",
      key: "duration",
      value: this.state.data.duration,
      units: ["s", "ms"],
      onChange: "changeRangeEditor"
    })}
    </div>
    `;
  }
  [SUBSCRIBE_SELF("changeRangeEditor")](key, value) {
    this.updateData({ [key]: value });
  }
  [SUBSCRIBE_SELF("changeCubicBezier")](key, value) {
    this.updateData({ [key]: value });
  }
  [SUBSCRIBE("showTransitionPropertyPopup")](data) {
    this.setState(data);
    this.show(250);
    this.children.$cubicBezierEditor.trigger("showCubicBezierEditor", data.data.timingFunction);
  }
  [SUBSCRIBE("hideTransitionPropertyPopup")]() {
    this.$el.hide();
  }
}
function transition(editor) {
  editor.registerMenuItem("inspector.tab.transition", {
    TransitionProperty
  });
  editor.registerMenuItem("popup", {
    TransitionPropertyPopup
  });
}
var VideoProperty$1 = "";
class VideoProperty extends BaseProperty {
  getClassName() {
    return "item elf--video-property";
  }
  getTitle() {
    return this.$i18n("video.property.title");
  }
  initState() {
    return {
      $video: { el: {} },
      status: "play",
      volume: 1
    };
  }
  getBody() {
    return `<div ref='$body' style='padding-top: 3px;'></div>`;
  }
  get video() {
    return this.state.$video.el;
  }
  get volumeStatus() {
    if (this.state.volume === 0)
      return "muted";
    if (this.state.volume > 0.5)
      return "up";
    return "down";
  }
  play() {
    if (this.video)
      this.video.play();
  }
  pause() {
    if (this.video)
      this.video.pause();
  }
  [LOAD("$body")]() {
    var current = this.$selection.current || { playTime: "0:1:1" };
    var currentTime = current.currentTime || 0;
    var duration = (current.playTime || "0:1:1").split(":").pop();
    return `
        <div ref='$tools' class='play-control' data-selected-value="${this.state.status}">
          <button type="button" data-value="play" >${obj.play} ${this.$i18n("video.property.play")}</button>
          <button type="button" data-value="pause">${obj.pause}  ${this.$i18n("video.property.pause")}</button>      
          <div>
            ${createComponent("NumberRangeEditor", {
      ref: "$currentTime",
      min: 0,
      max: duration,
      value: currentTime,
      step: 1e-3,
      onchange: "changeCurrentTime"
    })}
          </div>
        </div>    
        <div class='property-item animation-property-item has-label'>        
          <div class='group'>
            <span class='add-timeline-property' data-property='volume'></span>
            ${this.$i18n("video.property.volume")}
          </div>
          <div ref='$volume_control' class='volume-control' data-selected-value='${this.volumeStatus}'>
            <span data-value='muted'>${obj.volume_off}</span>
            <span data-value='down'>${obj.volume_down}</span>
            <span data-value='up'>${obj.volume_up}</span>
            <input type="range" ref='$volume' min="0" max="1" step="0.001" value="${this.state.volume}" />
          </div>          
        </div>
        <div class='property-item animation-property-item has-label'>        
          <div class='group'>
            <span class='add-timeline-property' data-property='playbackRate'></span>
            ${this.$i18n("video.property.playbackRate")}
          </div>
          <div>
            ${createComponent("NumberRangeEditor", {
      ref: "$playbackRate",
      min: 0.1,
      max: 10,
      clamp: true,
      value: this.state.playbackRate,
      step: 1e-3,
      onchange: "changePlaybackRate"
    })}
          </div>
        </div>        
        <div class='property-item animation-property-item full'>
          <div class='group'>
            <span class='add-timeline-property' data-property='playTime'></span>
            ${this.$i18n("video.property.playTime")}
          </div>
          ${createComponent("MediaProgressEditor", {
      ref: "$progress",
      key: "playTime",
      value: current.playTime,
      onchange: "changeSelect"
    })}
        </div>
      `;
  }
  [SUBSCRIBE("changeCurrentTime")](key, currentTime) {
    this.setState({ currentTime }, false);
    this.command("setAttributeForMulti", "change video property", this.$selection.packByValue({ currentTime }));
  }
  [SUBSCRIBE("changePlaybackRate")](key, playbackRate) {
    this.setState({ playbackRate }, false);
    this.command("setAttributeForMulti", "change video property", this.$selection.packByValue({ playbackRate }));
  }
  [CHANGEINPUT("$volume")](e2) {
    const volume = Number(this.refs.$volume.value);
    this.setState({ volume }, false);
    this.bindData("$volume_control");
    this.command("setAttributeForMulti", "change video property", this.$selection.packByValue({ volume }));
  }
  [BIND("$volume_control")]() {
    return {
      "data-selected-value": this.volumeStatus
    };
  }
  [BIND("$tools")]() {
    return {
      "data-selected-value": this.state.status
    };
  }
  [CLICK("$tools button")](e2) {
    var playType = e2.$dt.attr("data-value");
    switch (playType) {
      case "play":
        this.setState({ status: "pause" }, false);
        this.play();
        break;
      case "pause":
        this.setState({ status: "play" }, false);
        this.pause();
        break;
    }
    this.bindData("$tools");
  }
  [SUBSCRIBE_SELF("changeValue") + DEBOUNCE(100)](key, value) {
    if (!this.state.$video)
      return;
    this.command("setAttributeForMulti", "change video property", this.$selection.packByValue({ [key]: value }));
  }
  [SUBSCRIBE_SELF("changeSelect")](key, value) {
    this.command("setAttributeForMulti", "change video property", this.$selection.packByValue({ [key]: value }));
  }
  [SUBSCRIBE_SELF("updateVideoEvent")](e2) {
    if (this.video.paused) {
      this.setState({
        status: "play",
        currentTime: this.video.currentTime
      }, false);
      this.bindData("$tools");
    }
    this.children.$currentTime.setValue(this.video.currentTime);
  }
  [SUBSCRIBE("refreshSelection") + DEBOUNCE(100)]() {
    const current = this.$selection.current;
    this.refreshShow(["video"]);
    if (current && current.is("video")) {
      this.emit("refElement", current.id, ($el) => {
        const $video = $el.$("video");
        this.state.$video = $video;
        this.setState({
          volume: current.volume,
          currentTime: current.currentTime,
          playbackRate: current.playbackRate
        }, false);
        this.video.ontimeupdate = (e2) => {
          this.trigger("updateVideoEvent", e2);
        };
        this.video.onprogress = (e2) => {
          this.trigger("updateVideoEvent", e2);
        };
        this.load("$body");
      });
    }
  }
}
function video(editor) {
  editor.registerMenuItem("inspector.tab.style", {
    VideoProperty
  });
}
class SegmentManager {
  constructor(viewport) {
    this.viewport = viewport;
    this.segmentList = [];
  }
  reset() {
    this.segmentList = [];
    return this;
  }
  checkInViewport(point2) {
    const vertext = this.viewport.applyVertexInverse([point2.x, point2.y, 0]);
    return this.viewport.checkInViewport(vertext);
  }
  addLine(a, b) {
    if (getDist(a.x, a.y, b.x, b.y) < 1)
      return this;
    if (this.checkInViewport(a) || this.checkInViewport(b)) {
      this.segmentList.push({
        line: true,
        x1: a.x,
        y1: a.y,
        x2: b.x,
        y2: b.y
      });
    }
    return this;
  }
  addGuideLine(a, b) {
    if (getDist(a.x, a.y, b.x, b.y) < 1)
      return this;
    if (this.checkInViewport(a) || this.checkInViewport(b)) {
      this.segmentList.push({
        line: true,
        guide: true,
        x1: a.x,
        y1: a.y,
        x2: b.x,
        y2: b.y
      });
    }
    return this;
  }
  addDistanceLine(a, b) {
    if (getDist(a.x, a.y, b.x, b.y) < 1)
      return this;
    this.segmentList.push({
      line: true,
      distance: true,
      x1: a.x,
      y1: a.y,
      x2: b.x,
      y2: b.y
    });
    return this;
  }
  addDistanceAngle(center2, rx, ry, degree, last2, line2) {
    this.segmentList.push({
      angle: true,
      rx,
      ry,
      line: line2,
      degree,
      center: center2,
      last: last2
    });
    return this;
  }
  addPoint(obj2, point2, index2, segment, selected = false) {
    if (this.checkInViewport(point2)) {
      this.segmentList.push(__spreadProps(__spreadValues({}, obj2), {
        cx: point2.x,
        cy: point2.y,
        selected,
        index: index2,
        segment,
        isFirst: point2.isFirst,
        isLast: point2.isLast,
        isSecond: point2.isSecond
      }));
    }
    return this;
  }
  addStartPoint(obj2, point2) {
    if (this.checkInViewport(point2)) {
      this.segmentList.push(__spreadProps(__spreadValues({}, obj2), {
        cx: point2.x,
        cy: point2.y,
        start: true
      }));
    }
    return this;
  }
  addCurvePoint(point2, index2, segment, selected = false) {
    if (this.checkInViewport(point2)) {
      this.segmentList.push({
        curve: true,
        cx: point2.x,
        cy: point2.y,
        index: index2,
        selected,
        segment,
        isFirst: point2.isFirst,
        isLast: point2.isLast,
        isSecond: point2.isSecond
      });
    }
    return this;
  }
  addText(point2, text2) {
    this.segmentList.push({
      type: "text",
      cx: point2.x,
      cy: point2.y,
      text: text2 + ""
    });
    return this;
  }
  toString() {
    this.segmentList.sort((a, b) => {
      if (a.line && !b.line) {
        return -1;
      } else if (!a.line && b.line) {
        return 1;
      }
      return 0;
    });
    return this.segmentList.map((it) => {
      if (it.angle) {
        return `
                <path stroke-width='1' 
                    data-distance='true'
                    fill="rgba(0,0,0,0.5)"
                    d="M ${it.center.x},${it.center.y} A ${it.rx} ${it.ry},${it.degree},0,0,${it.last.x} ${it.last.y} L${it.line.x} ${it.line.y} Z"
                />`;
      } else if (it.line) {
        return `
                <line stroke-width='1' 
                    data-segment="true"
                    data-is-last="${it.isLast}"                
                    data-guide='${it.guide}'
                    data-distance='${it.distance}'
                    x1='${it.x1}' x2='${it.x2}' y1='${it.y1}' y2='${it.y2}' 
                />`;
      } else if (it.text) {
        return "";
      } else if (it.curve && it.segment !== "startPoint") {
        return `
                <path stroke-width='1'
                    class='curve' 
                    ${it.selected && `data-selected="true"`}
                    ${it.isLast && `data-is-last="true"`}
                    ${it.isFirst && `data-is-first="true"`}
                    ${it.isSecond && `data-is-second="true"`}
                    title="${it.segment} curve"  
                    data-index='${it.index}'
                    data-segment-point='${it.segment}'
                    data-segment="true" 
                    d="M ${it.cx} ${it.cy - 4}L ${it.cx + 4} ${it.cy} L ${it.cx} ${it.cy + 4} L ${it.cx - 4} ${it.cy} Z"
                />`;
      } else if (it.start) {
        return `
                <circle 
                    cx='${it.cx}' 
                    cy='${it.cy}' 
                    r='4'                    
                    class='segment'
                    data-selected='${it.selected}'
                    title="Center"
                    data-start="true" 
                />`;
      } else {
        return `
                <circle 
                    cx='${it.cx}' 
                    cy='${it.cy}' 
                    r='4'                    
                    class='segment'
                    data-selected='${it.selected}'
                    title="${it.segment}"
                    data-is-last="${it.isLast}"
                    data-is-first="${it.isFirst}"
                    data-is-second="${it.isSecond}"
                    data-index='${it.index}' 
                    data-segment-point='${it.segment}' 
                    data-segment="true" 
                />`;
      }
    }).join("");
  }
}
const SEGMENT_DIRECTION = ["startPoint", "endPoint", "reversePoint"];
function calculateSnapPoint(points2, sourceKey, target, distanceValue, dist2) {
  var checkedPointList = points2.filter((p) => {
    if (!p)
      return false;
    return Math.abs(p[sourceKey] - target) <= dist2;
  }).map((p) => {
    return { dist: Math.abs(p[sourceKey] - target), point: p };
  });
  checkedPointList.sort((a, b) => {
    return a.dist < b.dist ? -1 : 1;
  });
  var point2 = null;
  if (checkedPointList.length) {
    point2 = checkedPointList[0].point;
    distanceValue += point2[sourceKey] - target;
  }
  return { point: point2, distanceValue };
}
function calculateMovePointSnap(points2, moveXY, dist2 = 1) {
  var snapPointX = calculatePointDist(points2, "x", moveXY.x, dist2);
  var snapPointY = calculatePointDist(points2, "y", moveXY.y, dist2);
  var snapEndPoint = __spreadValues({}, moveXY);
  if (snapPointX) {
    snapEndPoint.x = snapPointX.x;
  }
  if (snapPointY) {
    snapEndPoint.y = snapPointY.y;
  }
  var snapPointList = [];
  if (snapPointX) {
    snapPointList.push({ startPoint: snapPointX, endPoint: snapEndPoint });
  }
  if (snapPointY) {
    snapPointList.push({ startPoint: snapPointY, endPoint: snapEndPoint });
  }
  return { snapPointList, moveXY: snapEndPoint };
}
function calculatePointDist(points2, sourceKey, target, dist2) {
  var checkedPointList = [];
  var arr = SEGMENT_DIRECTION;
  points2.filter((p) => p).forEach((p) => {
    arr.filter((key) => p[key]).forEach((key) => {
      var point2 = p[key];
      var tempDist = Math.abs(point2[sourceKey] - target);
      if (tempDist <= dist2) {
        checkedPointList.push({ dist: tempDist, point: point2 });
      }
    });
  });
  checkedPointList.sort((a, b) => {
    return a.dist > b.dist ? 1 : -1;
  });
  return checkedPointList.length ? checkedPointList[0].point : null;
}
function toPath(points2, minX, minY, scale2 = 1) {
  var d = [];
  for (var index2 = 0, len2 = points2.length; index2 < len2; index2++) {
    var currentIndex = index2;
    var current = points2[currentIndex];
    if (!current)
      continue;
    if (current.command === "M") {
      d.push({ command: "M", values: [current.startPoint] });
    } else {
      var prevPoint = Point.getPrevPoint(points2, index2);
      if (current.curve === false) {
        if (prevPoint.curve === false) {
          d.push({ command: "L", values: [current.startPoint] });
        } else {
          d.push({ command: "Q", values: [prevPoint.endPoint, current.startPoint] });
        }
      } else {
        if (prevPoint.curve === false) {
          if (Point.isEqual(current.reversePoint, current.startPoint)) {
            d.push({ command: "L", values: [current.startPoint] });
          } else {
            d.push({ command: "Q", values: [current.reversePoint, current.startPoint] });
          }
        } else {
          d.push({ command: "C", values: [prevPoint.endPoint, current.reversePoint, current.startPoint] });
        }
      }
    }
    if (current.close) {
      d.push({ command: "Z" });
    }
  }
  var dString = d.map((segment) => {
    return calculateRelativePosition(minX, minY, segment, scale2);
  }).join(" ");
  return {
    d: dString
  };
}
function calculateRelativePosition(minX, minY, segment, scale2 = 1) {
  var { command, values } = segment;
  switch (command) {
    case "Z":
      return "Z";
    default:
      var str = values.map((v) => {
        var tx = v.x - minX === 0 ? 0 : (v.x - minX) / scale2;
        var ty = v.y - minY === 0 ? 0 : (v.y - minY) / scale2;
        return `${tx} ${ty}`;
      }).join(" ");
      return `${command} ${str}`;
  }
}
function checkInArea(area2, point2) {
  if (area2.x2.value < point2.x) {
    return false;
  }
  if (area2.y2.value < point2.y) {
    return false;
  }
  if (area2.x.value > point2.x) {
    return false;
  }
  if (area2.y.value > point2.y) {
    return false;
  }
  return true;
}
class PathGenerator {
  static generatorPathString(points2, minX = 0, minY = 0, scale2 = 1) {
    return toPath(points2, minX, minY, scale2).d;
  }
  constructor(pathEditor) {
    this.pathEditor = pathEditor;
    this.pathStringManager = new PathStringManager();
    this.guideLineManager = new PathStringManager();
    this.segmentManager = new SegmentManager(this.pathEditor.$viewport);
    this.points = [];
    this.cachedSegmentKeys = {};
    this.initialize();
    this.initializeSelect();
  }
  initialize() {
    this.splitLines = [];
    this.guideLineManager.reset();
    this.segmentManager.reset();
    this.pathStringManager.reset();
  }
  initializeSelect(initPointList = []) {
    this.selectedPointKeys = {};
    this.selectedPointList = [];
    if (initPointList.length) {
      this.select(...initPointList.map((p) => {
        const checkedPoint = this.points[p.index][p.key];
        if (!checkedPoint)
          return void 0;
        return { x: checkedPoint.x, y: checkedPoint.y, key: p.key, index: checkedPoint.index };
      }).filter(Boolean));
    }
  }
  get state() {
    return this.pathEditor.state;
  }
  get clonePoints() {
    return [...this.points];
  }
  get length() {
    return this.points.length;
  }
  setPoints(points2 = []) {
    this.points = points2;
    this.snapPointList = [];
    if (this.points.length === 0) {
      this.select();
      this.selectGroup(-1);
    }
  }
  selectInBox(box, isToggle = false) {
    var list2 = [];
    this.points.forEach((point2, index2) => {
      SEGMENT_DIRECTION.forEach((key) => {
        const p = point2[key];
        if (checkInArea(box, p)) {
          list2.push({ x: p.x, y: p.y, key, index: index2 });
        }
      });
    });
    if (isToggle) {
      list2 = list2.map((it) => {
        const selectedKey = this.makeSegmentKey(it);
        return __spreadProps(__spreadValues({}, it), { included: Boolean(this.selectedPointKeys[selectedKey]) });
      });
      const includedList = list2.filter((it) => it.included);
      const notIncludedList = list2.filter((it) => !it.included);
      let uniqueList = [...this.selectedPointList];
      if (includedList.length) {
        uniqueList = this.selectedPointList.filter((it) => {
          const oldKey = this.makeSegmentKey(it);
          return Boolean(includedList.find((includeNode) => {
            return oldKey === this.makeSegmentKey(includeNode);
          })) === false;
        });
      }
      this.select(...uniqueList, ...notIncludedList);
    } else {
      this.select(...list2);
    }
  }
  makeSegmentKey(p) {
    return `${p.key}_${p.index}`;
  }
  select(...list2) {
    this.selectedPointKeys = {};
    this.selectedPointList = list2.map(({ x: x2, y: y2, key, index: index2 }) => ({
      x: x2,
      y: y2,
      key,
      index: +index2
    }));
    list2.forEach((it) => {
      var key = this.makeSegmentKey(it);
      this.selectedPointKeys[key] = true;
    });
  }
  convertPointsToSelectionList(points2) {
    var list2 = [];
    points2.forEach((point2) => {
      SEGMENT_DIRECTION.forEach((key) => {
        const { x: x2, y: y2 } = point2[key];
        list2.push({ x: x2, y: y2, key, index: point2.index });
      });
    });
    return list2;
  }
  selectGroup(groupIndex) {
    const group2 = this.splitedGroupList[groupIndex];
    if (group2) {
      this.select(...this.convertPointsToSelectionList(group2.points));
    } else {
      this.select();
    }
  }
  getCacheSegmentKey(segmentKey, index2) {
    if (!this.cachedSegmentKeys[segmentKey]) {
      this.cachedSegmentKeys[segmentKey] = {};
    }
    if (!this.cachedSegmentKeys[segmentKey][index2]) {
      this.cachedSegmentKeys[segmentKey][index2] = this.makeSegmentKey({ key: segmentKey, index: index2 });
    }
    return this.cachedSegmentKeys[segmentKey][index2];
  }
  toggleSelect(key, index2) {
    if (this.points[index2]) {
      var point2 = this.points[index2][key];
      if (point2 && !this.isSelectedSegment(key, index2)) {
        this.select(...this.selectedPointList, { x: point2.x, y: point2.y, key, index: index2 });
      } else {
        this.select(...this.selectedPointList.filter((it) => {
          return it.key !== key || it.index !== index2;
        }));
      }
    }
  }
  selectKeyIndex(key, index2) {
    if (this.points[index2]) {
      var point2 = this.points[index2][key];
      if (point2 && !this.isSelectedSegment(key, index2)) {
        this.select({ x: point2.x, y: point2.y, key, index: index2 });
      }
    }
  }
  reselect() {
    this.selectedPointList.filter(Boolean).forEach((it) => {
      var _a;
      var point2 = (_a = this.points[it.index]) == null ? void 0 : _a[it.key];
      if (point2) {
        it.x = point2.x;
        it.y = point2.y;
      }
    });
  }
  isSelectedSegment(segment, index2) {
    var key = this.getCacheSegmentKey(segment, index2);
    return this.selectedPointKeys[key];
  }
  commitTransformMatrix(point2, transformMatrix) {
    var result = transformMat4([], [point2.x, point2.y, 0], transformMatrix);
    return { x: result[0], y: result[1] };
  }
  transformMat4(transformMatrix) {
    this.transformPoints.forEach((p, index2) => {
      var realPoint = this.points[index2];
      Object.assign(realPoint.startPoint, this.commitTransformMatrix(p.startPoint, transformMatrix));
      Object.assign(realPoint.endPoint, this.commitTransformMatrix(p.endPoint, transformMatrix));
      Object.assign(realPoint.reversePoint, this.commitTransformMatrix(p.reversePoint, transformMatrix));
    });
  }
  transform(type, dx = 0, dy = 0) {
    var { x: x2, y: y2, width: width2, height: height2 } = this.transformRect;
    var view = create$5();
    translate(view, view, [x2, y2, 0]);
    switch (type) {
      case "flipX":
        scale$1(view, view, [-1, 1, 1]);
        translate(view, view, [-width2, 0, 0]);
        break;
      case "flipY":
        scale$1(view, view, [1, -1, 1]);
        translate(view, view, [0, -height2, 0]);
        break;
      case "flip":
        scale$1(view, view, [-1, -1, 1]);
        translate(view, view, [-width2, -height2, 0]);
        break;
    }
    translate(view, view, [-x2, -y2, 0]);
    this.transformMat4(view);
  }
  initTransform(rect2) {
    this.transformRect = clone$1(rect2);
    this.transformPoints = this.clonePoints.map((p) => {
      return {
        startPoint: clone$1(p.startPoint),
        endPoint: clone$1(p.endPoint),
        reversePoint: clone$1(p.reversePoint)
      };
    });
  }
  setConnectedPoint(dx, dy) {
    var state = this.state;
    var x2 = state.dragXY.x + dx;
    var y2 = state.dragXY.y + dy;
    var endPoint = { x: x2, y: y2 };
    var reversePoint2 = { x: x2, y: y2 };
    if (state.dragPoints) {
      state.reversePoint = Point.getReversePoint(state.startPoint, endPoint);
    }
    var point2 = {
      startPoint: state.startPoint,
      endPoint,
      curve: !!state.dragPoints,
      reversePoint: reversePoint2,
      connected: true,
      close: true
    };
    this.points.push(point2);
  }
  setLastPoint(startPoint) {
    var endPoint = clone$1(startPoint);
    var reversePoint2 = clone$1(startPoint);
    var point2 = {
      startPoint,
      endPoint,
      curve: false,
      reversePoint: reversePoint2,
      connected: false,
      close: false
    };
    this.points.push(point2);
  }
  getPrevPoint(index2) {
    return Point.getPrevPoint(this.points, index2);
  }
  getIndexPoint(index2) {
    return Point.getIndexPoint(this.points, index2);
  }
  getNextPoint(index2) {
    return Point.getNextPoint(this.points, index2);
  }
  getConnectedPointList(index2) {
    return Point.getConnectedPointList(this.points, index2);
  }
  isFirst(segment) {
    return Point.isFirst(segment);
  }
  getLastPoint(index2) {
    return Point.getLastPoint(this.points, index2);
  }
  setCachePoint(index2, segmentKey, verties = []) {
    var state = this.state;
    this.snapPointList = [];
    this.selectedIndex = index2;
    state.connectedPoint = this.getPrevPoint(index2);
    state.connectedPointList = clone$1(Point.getConnectedPointList(this.points, this.selectedIndex));
    if (state.connectedPoint && !state.connectedPoint.connected) {
      state.connectedPoint = null;
    }
    state.segment = this.getIndexPoint(index2);
    if (state.segment.connected) {
      state.connectedPoint = this.getNextPoint(index2);
    }
    var isFirstSegment = this.isFirst(state.segment);
    if (isFirstSegment) {
      var lastPoint = this.getLastPoint(index2);
      if (lastPoint.connected) {
        state.connectedPoint = lastPoint;
      }
    }
    state.segmentKey = segmentKey;
    state.isCurveSegment = state.segment.curve && state.segmentKey != "startPoint";
    state.originalSegment = clone$1(state.segment);
    if (state.connectedPoint) {
      state.originalConnectedPoint = clone$1(state.connectedPoint);
    }
    state.cachedPoints = [];
    this.points.filter((p) => p && p != state.segment).forEach((p) => {
      state.cachedPoints.push(p.startPoint, p.reversePoint, p.endPoint);
    });
  }
  moveSegment(segmentKey, dx, dy, originSegment = void 0) {
    if (originSegment) {
      const segment = this.points[originSegment.index][segmentKey];
      segment.x = originSegment[segmentKey].x + dx;
      segment.y = originSegment[segmentKey].y + dy;
    } else {
      var state = this.state;
      var originPoint = state.originalSegment[segmentKey];
      var targetPoint = state.segment[segmentKey];
      if (originPoint) {
        targetPoint.x = originPoint.x + dx;
        targetPoint.y = originPoint.y + dy;
      }
    }
  }
  calculateToCurve(point2, nextPoint, prevPoint) {
    var centerX = (nextPoint.startPoint.x + prevPoint.startPoint.x) / 2;
    var centerY = (nextPoint.startPoint.y + prevPoint.startPoint.y) / 2;
    var dx = (nextPoint.startPoint.x - centerX) / 2;
    var dy = (nextPoint.startPoint.y - centerY) / 2;
    point2.endPoint = {
      x: point2.startPoint.x + dx,
      y: point2.startPoint.y + dy
    };
    point2.reversePoint = {
      x: point2.startPoint.x - dx,
      y: point2.startPoint.y - dy
    };
    return { dx, dy };
  }
  convertToCurve(index2) {
    var point2 = this.points[index2];
    if (point2.curve) {
      point2.curve = false;
      point2.reversePoint = clone$1(point2.startPoint);
      point2.endPoint = clone$1(point2.startPoint);
      if (point2.command === "M") {
        var lastPoint = Point.getPrevPoint(points, point2.index);
        if (lastPoint.connected) {
          lastPoint.curve = false;
          lastPoint.reversePoint = clone$1(lastPoint.startPoint);
          lastPoint.endPoint = clone$1(lastPoint.startPoint);
        }
      } else {
        var nextPoint = this.getNextPoint(index2);
        if (nextPoint && nextPoint.command === "M") {
          var firstPoint = nextPoint;
          firstPoint.curve = false;
          firstPoint.reversePoint = clone$1(firstPoint.startPoint);
          firstPoint.endPoint = clone$1(firstPoint.startPoint);
        }
      }
    } else {
      point2.curve = true;
      var prevPoint = this.getPrevPoint(index2);
      var nextPoint = this.getNextPoint(index2);
      if (nextPoint && nextPoint.index < index2 && nextPoint.command === "M") {
        var firstPoint = nextPoint;
        nextPoint = this.getNextPoint(firstPoint.index);
        this.calculateToCurve(point2, nextPoint, prevPoint);
        firstPoint.curve = true;
        firstPoint.endPoint = clone$1(point2.endPoint);
        firstPoint.reversePoint = clone$1(point2.reversePoint);
      } else if (nextPoint && nextPoint.index > index2 && nextPoint.command !== "M") {
        this.calculateToCurve(point2, nextPoint, prevPoint);
      } else if (!nextPoint && prevPoint) {
        var centerX = (point2.startPoint.x - prevPoint.startPoint.x) / 3;
        var centerY = (point2.startPoint.y - prevPoint.startPoint.y) / 3;
        point2.endPoint = { x: point2.startPoint.x + centerX, y: point2.startPoint.y + centerY };
        point2.reversePoint = Point.getReversePoint(point2.startPoint, point2.endPoint);
      } else if (!prevPoint && nextPoint) {
        var centerX = (point2.startPoint.x - nextPoint.startPoint.x) / 3;
        var centerY = (point2.startPoint.y - nextPoint.startPoint.y) / 3;
        point2.endPoint = { x: point2.startPoint.x + centerX, y: point2.startPoint.y + centerY };
        point2.reverse = Point.getReversePoint(point2.startPoint, point2.endPoint);
      }
    }
  }
  moveCurveSegment(segmentKey, dx, dy) {
    var state = this.state;
    this.moveSegment(segmentKey, dx, dy);
    var targetSegmentKey = segmentKey === "endPoint" ? "reversePoint" : "endPoint";
    state.segment[targetSegmentKey] = Point.getReversePoint(state.segment.startPoint, state.segment[segmentKey]);
  }
  rotateSegmentTarget(segmentKey, target) {
    var state = this.state;
    if (state.originalSegment && state.segment) {
      var { x: cx, y: cy } = state.originalSegment.startPoint;
      var { x: rx, y: ry } = state.segment[segmentKey];
      var { x: tx, y: ty } = state.originalSegment[target];
      var { x: x2, y: y2 } = getXYInCircle(calculateAngle360(rx - cx, ry - cy), getDist(tx, ty, cx, cy), cx, cy);
      state.segment[target] = { x: x2, y: y2 };
    }
  }
  rotateSegment(segmentKey) {
    this.rotateSegmentTarget(segmentKey, segmentKey === "endPoint" ? "reversePoint" : "endPoint");
  }
  calculateSnap(segmentKey, dx, dy, dist2 = 1) {
    var state = this.state;
    var cachedPoints = state.cachedPoints;
    var original = state.originalSegment[segmentKey];
    if (!segmentKey) {
      return { dx, dy, snapPointList: [] };
    }
    var realX = original.x + dx;
    var realY = original.y + dy;
    var { point: snapPointX, distanceValue: dx } = calculateSnapPoint(cachedPoints, "x", realX, dx, dist2);
    var { point: snapPointY, distanceValue: dy } = calculateSnapPoint(cachedPoints, "y", realY, dy, dist2);
    var snapEndPoint = {
      x: original.x + dx,
      y: original.y + dy
    };
    var snapPointList = [];
    if (snapPointX) {
      snapPointList.push({ startPoint: snapPointX, endPoint: snapEndPoint });
    }
    if (snapPointY) {
      snapPointList.push({ startPoint: snapPointY, endPoint: snapEndPoint });
    }
    return { dx, dy, snapPointList };
  }
  copySegment(from, to) {
    to.startPoint = clone$1(from.startPoint);
    to.endPoint = clone$1(from.endPoint);
    to.reversePoint = clone$1(from.reversePoint);
  }
  get selectedLength() {
    return this.selectedPointList.length;
  }
  moveSelectedSegment(dx, dy) {
    if (this.selectedPointList.length > 0) {
      this.selectedPointList.forEach((it) => {
        var target = this.points[it.index][it.key];
        target.x = it.x + dx;
        target.y = it.y + dy;
      });
    } else if (this.selectedGroup) {
      this.moveSelectedGroup(dx, dy);
    }
  }
  moveSelectedGroup(dx, dy) {
    this.selectedGroup.points.forEach((it) => {
      const target = this.points[it.index];
      target.startPoint.x = it.startPoint.x + dx;
      target.startPoint.y = it.startPoint.y + dy;
      target.endPoint.x = it.endPoint.x + dx;
      target.endPoint.y = it.endPoint.y + dy;
      target.reversePoint.x = it.reversePoint.x + dx;
      target.reversePoint.y = it.reversePoint.y + dy;
    });
  }
  get selectedGroup() {
    return this.splitedGroupList[this.state.selectedGroupIndex];
  }
  get splitedGroupList() {
    return Point.getSplitedGroupList(this.points);
  }
  get groupList() {
    return Point.getGroupList(this.points);
  }
  getGroup(groupList, pointIndex) {
    return Point.getGroup(groupList, pointIndex);
  }
  get selectedGroupIndexList() {
    const groupIndexList = new Set();
    const groupList = this.groupList;
    if (this.selectedPointList.length === 0 && this.state.selectedGroupIndex < 0) {
      return groupList.map((group2) => group2.groupIndex);
    }
    const points2 = this.selectedPointList;
    points2.forEach((it) => {
      const group2 = this.getGroup(groupList, it.index);
      if (group2) {
        groupIndexList.add(group2.groupIndex);
      }
    });
    return [...new Set([...groupIndexList, this.state.selectedGroupIndex])];
  }
  removeSelectedSegment() {
    this.selectedPointList.forEach((it) => {
      var target = this.points[it.index][it.key];
      target.removed = true;
    });
    const pointGroup = Point.splitPoints(this.points);
    const newPoints = Point.recoverPoints(pointGroup.map((points2) => {
      return points2.filter((p) => !p.startPoint.removed).map((p) => {
        if (p.endPoint.removed) {
          p.endPoint = clone$1(p.startPoint);
        }
        if (p.reversePoint.removed) {
          p.reversePoint = clone$1(p.startPoint);
        }
        if (Point.isEqual(p.endPoint, p.startPoint, p.reversePoint)) {
          p.command = "L";
          p.curve = false;
        }
        return p;
      });
    }));
    this.points = newPoints;
    this.select();
  }
  move(dx, dy, e2) {
    var state = this.state;
    var { isCurveSegment, segmentKey, connectedPoint } = state;
    if (this.selectedPointList.length > 1) {
      this.moveSelectedSegment(dx, dy);
    } else if (this.selectedPointList.length === 1) {
      var { dx, dy, snapPointList } = this.calculateSnap(segmentKey, dx, dy, 3);
      this.snapPointList = snapPointList || [];
      if (isCurveSegment) {
        if (e2.shiftKey) {
          this.moveSegment(segmentKey, dx, dy);
          var targetSegmentKey = segmentKey === "endPoint" ? "reversePoint" : "endPoint";
          state.segment[targetSegmentKey] = Point.getReversePoint(state.segment.startPoint, state.segment[segmentKey]);
        } else if (e2.altKey) {
          this.moveSegment(segmentKey, dx, dy);
          this.rotateSegment(segmentKey);
        } else {
          this.moveSegment(segmentKey, dx, dy);
        }
      } else {
        this.moveSegment("startPoint", dx, dy);
        this.moveSegment("endPoint", dx, dy);
        this.moveSegment("reversePoint", dx, dy);
        if (!e2.altKey) {
          state.connectedPointList.forEach((it) => {
            this.moveSegment("startPoint", dx, dy, it);
            this.moveSegment("endPoint", dx, dy, it);
            this.moveSegment("reversePoint", dx, dy, it);
          });
        }
      }
      connectedPoint && this.copySegment(state.segment, state.connectedPoint);
    } else if (this.state.selectedGroupIndex > -1) {
      this.moveSelectedGroup(dx, dy);
    }
  }
  moveEnd(dx, dy) {
    var state = this.state;
    var points2 = this.points;
    var x2 = state.dragXY.x + dx;
    var y2 = state.dragXY.y + dy;
    var endPoint = { x: x2, y: y2 };
    var reversePoint2 = { x: x2, y: y2 };
    if (state.dragPoints) {
      reversePoint2 = Point.getReversePoint(state.startPoint, endPoint);
    }
    points2.push({
      command: state.clickCount === 0 ? "M" : "",
      startPoint: state.startPoint,
      endPoint,
      curve: !!state.dragPoints,
      reversePoint: reversePoint2
    });
    state.startPoint = null;
    state.dragPoints = false;
    state.moveXY = null;
  }
  setPoint(obj2) {
    var p0 = obj2.first[0];
    var p1 = obj2.second[obj2.second.length - 1];
    var allPoints = this.clonePoints;
    var firstItem = Point.getPoint(allPoints, p0);
    var secondItem = Point.getPoint(allPoints, p1);
    var newPoints = [
      __spreadProps(__spreadValues({}, firstItem), { endPoint: obj2.first[1] }),
      { startPoint: obj2.first[3], reversePoint: obj2.first[2], curve: true, endPoint: obj2.second[1] },
      __spreadProps(__spreadValues({}, secondItem), { reversePoint: obj2.second[2] })
    ];
    var firstIndex = Point.getIndex(allPoints, p0);
    allPoints.splice(firstIndex, 2, ...newPoints);
    this.points = allPoints;
    return firstIndex + 1;
  }
  setPointQuard(obj2) {
    var p0 = obj2.first[0];
    var p1 = obj2.second[obj2.second.length - 1];
    var allPoints = this.clonePoints;
    var firstItem = Point.getPoint(allPoints, p0);
    var secondItem = Point.getPoint(allPoints, p1);
    if (firstItem.curve && secondItem.curve === false) {
      var newPoints = [
        __spreadProps(__spreadValues({}, firstItem), { endPoint: firstItem.startPoint }),
        { startPoint: obj2.first[2], reversePoint: obj2.first[1], curve: true, endPoint: obj2.second[1] }
      ];
      var firstIndex = Point.getIndex(allPoints, p0);
      allPoints.splice(firstIndex, 1, ...newPoints);
    } else {
      var newPoints = [
        __spreadValues({}, firstItem),
        { startPoint: obj2.first[2], reversePoint: obj2.first[1], curve: true, endPoint: obj2.second[1] },
        __spreadProps(__spreadValues({}, secondItem), { reversePoint: obj2.second[1], curve: true })
      ];
      var firstIndex = Point.getIndex(allPoints, p0);
      allPoints.splice(firstIndex, 2, ...newPoints);
    }
    this.points = allPoints;
    return firstIndex + 1;
  }
  setPointLine(obj2) {
    var p0 = obj2.first[0];
    var allPoints = this.clonePoints;
    var newPoints = [
      { command: "L", startPoint: obj2.first[1], curve: false, endPoint: obj2.first[1], reversePoint: obj2.first[1] }
    ];
    var firstIndex = Point.getIndex(allPoints, p0);
    allPoints.splice(firstIndex + 1, 0, ...newPoints);
    this.points = allPoints;
    return firstIndex + 1;
  }
  toPath(minX = 0, minY = 0, scale2 = 1) {
    return toPath(this.clonePoints, minX, minY, scale2);
  }
  makeSVGPath() {
    this.initialize();
    this.makePointGuide(this.points);
    this.makeMovePositionGuide();
    return this.toSVGString();
  }
  makeTriangleDistancePointGuide(first, second2) {
    var minX = Math.min(first.startPoint.x, second2.startPoint.x);
    var maxX = Math.max(first.startPoint.x, second2.startPoint.x);
    var minY = Math.min(first.startPoint.y, second2.startPoint.y);
    var maxY = Math.max(first.startPoint.y, second2.startPoint.y);
    if (first.startPoint.x < second2.startPoint.x && first.startPoint.y < second2.startPoint.y) {
      this.segmentManager.addDistanceLine({ x: minX, y: minY }, { x: maxX, y: minY }).addDistanceLine({ x: maxX, y: minY }, { x: maxX, y: maxY });
      var centerX = minX;
      var centerY = minY;
      var angle2 = calculateAngle360(maxX - minX, maxY - minY) - 180;
      var dist2 = 20;
      var { x: x2, y: y2 } = getXYInCircle(0, dist2, centerX, centerY);
      var last2 = getXYInCircle(angle2, dist2, centerX, centerY);
      this.segmentManager.addDistanceAngle(last2, dist2, dist2, angle2, { x: x2, y: y2 }, { x: x2 - dist2, y: y2 });
    } else if (first.startPoint.x < second2.startPoint.x && first.startPoint.y > second2.startPoint.y) {
      this.segmentManager.addDistanceLine({ x: minX, y: maxY }, { x: maxX, y: maxY }).addDistanceLine({ x: maxX, y: minY }, { x: maxX, y: maxY });
    } else if (first.startPoint.x > second2.startPoint.x && first.startPoint.y > second2.startPoint.y) {
      this.segmentManager.addDistanceLine({ x: minX, y: minY }, { x: minX, y: maxY }).addDistanceLine({ x: minX, y: maxY }, { x: maxX, y: maxY });
    } else if (first.startPoint.x > second2.startPoint.x && first.startPoint.y < second2.startPoint.y) {
      this.segmentManager.addDistanceLine({ x: minX, y: maxY }, { x: maxX, y: maxY }).addDistanceLine({ x: maxX, y: minY }, { x: maxX, y: maxY });
    }
  }
  makeDistancePointGuide(prevPoint, current, nextPoint, index2) {
    if (current.selected) {
      if (prevPoint) {
        this.makeTriangleDistancePointGuide(prevPoint, current);
      }
      if (nextPoint) {
        this.makeTriangleDistancePointGuide(current, nextPoint);
      }
    }
  }
  makeStartPointGuide(prevPoint, current, nextPoint, index2) {
    current.startPoint.isFirst = true;
    if (current.curve === false) {
      this.segmentManager.addPoint({}, current.startPoint, index2, "startPoint", this.isSelectedSegment("startPoint", index2));
    } else {
      this.segmentManager.addPoint({}, current.startPoint, index2, "startPoint", this.isSelectedSegment("startPoint", index2)).addGuideLine(current.startPoint, current.endPoint);
      if (Point.isEqual(current.startPoint, current.endPoint) === false) {
        this.segmentManager.addCurvePoint(current.endPoint, index2, "endPoint", this.isSelectedSegment("endPoint", index2));
      }
    }
  }
  makeMiddlePointGuideSegment(prevPoint, current, nextPoint, index2, isSiblingSelected) {
    var mng = this.segmentManager;
    if (current.curve === false) {
      if (prevPoint.curve === false) {
        mng.addPoint({}, current.startPoint, index2, "startPoint", this.isSelectedSegment("startPoint", index2));
      } else {
        if (isSiblingSelected === false) {
          mng.addCurvePoint(current.startPoint, index2, "startPoint", this.isSelectedSegment("startPoint", index2));
        } else {
          mng.addGuideLine(prevPoint.startPoint, prevPoint.endPoint).addCurvePoint(current.startPoint, index2, "startPoint", this.isSelectedSegment("startPoint", index2));
          if (Point.isEqual(prevPoint.startPoint, prevPoint.endPoint) === false) {
            mng.addCurvePoint(prevPoint.endPoint, prevPoint.index, "endPoint", this.isSelectedSegment("endPoint", prevPoint.index));
          }
        }
      }
    } else {
      if (prevPoint.curve === false) {
        if (isSiblingSelected === false) {
          if (Point.isEqual(current.reversePoint, current.startPoint)) {
            mng.addPoint({}, current.startPoint, index2, "startPoint", this.isSelectedSegment("startPoint", index2));
          } else {
            mng.addCurvePoint(current.startPoint, index2, "startPoint", this.isSelectedSegment("startPoint", index2));
          }
        } else {
          if (Point.isEqual(current.reversePoint, current.startPoint)) {
            mng.addPoint({}, current.startPoint, index2, "startPoint", this.isSelectedSegment("startPoint", index2));
          } else {
            mng.addGuideLine(current.startPoint, current.reversePoint).addCurvePoint(current.startPoint, index2, "startPoint", this.isSelectedSegment("startPoint", index2));
            if (Point.isEqual(current.startPoint, current.reversePoint) === false) {
              mng.addCurvePoint(current.reversePoint, index2, "reversePoint", this.isSelectedSegment("reversePoint", index2));
            }
          }
        }
      } else {
        if (current.connected) {
          if (isSiblingSelected === false)
            ;
          else {
            mng.addGuideLine(prevPoint.startPoint, prevPoint.endPoint).addGuideLine(current.startPoint, current.reversePoint);
            if (Point.isEqual(prevPoint.startPoint, prevPoint.endPoint) === false) {
              mng.addCurvePoint(prevPoint.endPoint, prevPoint.index, "endPoint", this.isSelectedSegment("endPoint", prevPoint.index));
            }
            if (Point.isEqual(current.startPoint, current.reversePoint) === false) {
              mng.addCurvePoint(current.reversePoint, index2, "reversePoint", this.isSelectedSegment("reversePoint", index2));
            }
          }
        } else {
          if (isSiblingSelected === false) {
            mng.addCurvePoint(current.startPoint, index2, "startPoint", this.isSelectedSegment("startPoint", index2));
          } else {
            mng.addGuideLine(prevPoint.startPoint, prevPoint.endPoint).addGuideLine(current.startPoint, current.reversePoint).addCurvePoint(current.startPoint, index2, "startPoint", this.isSelectedSegment("startPoint", index2));
            if (Point.isEqual(prevPoint.startPoint, prevPoint.endPoint) === false) {
              mng.addCurvePoint(prevPoint.endPoint, prevPoint.index, "endPoint", this.isSelectedSegment("endPoint", prevPoint.index));
            }
            if (Point.isEqual(current.startPoint, current.reversePoint) === false) {
              mng.addCurvePoint(current.reversePoint, index2, "reversePoint", this.isSelectedSegment("reversePoint", index2));
            }
          }
        }
      }
    }
  }
  checkInViewport(point2) {
    const vertext = this.pathEditor.$viewport.applyVertexInverse([point2.x, point2.y, 0]);
    return this.pathEditor.$viewport.checkInViewport(vertext);
  }
  makeMiddlePointGuideSplitLine(prevPoint, current, nextPoint, index2, isSiblingSelected) {
    const selected = isSiblingSelected ? "selected" : "";
    if (current.curve === false) {
      if (prevPoint.curve === false) {
        if ((this.checkInViewport(prevPoint.startPoint) || this.checkInViewport(current.startPoint)) === false) {
          return;
        }
        this.splitLines.push(new PathStringManager().M(prevPoint.startPoint).L(current.startPoint).toString(`split-path ${selected}`));
      } else {
        if ((this.checkInViewport(prevPoint.startPoint) || this.checkInViewport(prevPoint.endPoint) || this.checkInViewport(current.startPoint)) === false) {
          return;
        }
        this.splitLines.push(new PathStringManager().M(prevPoint.startPoint).Q(prevPoint.endPoint, current.startPoint).toString(`split-path ${selected}`));
      }
    } else {
      if (prevPoint.curve === false) {
        if (Point.isEqual(current.reversePoint, current.startPoint)) {
          if ((this.checkInViewport(prevPoint.startPoint) || this.checkInViewport(current.startPoint)) === false) {
            return;
          }
          this.splitLines.push(new PathStringManager().M(prevPoint.startPoint).L(current.startPoint).toString(`split-path ${selected}`));
        } else {
          if ((this.checkInViewport(prevPoint.startPoint) || this.checkInViewport(current.reversePoint) || this.checkInViewport(current.startPoint)) === false) {
            return;
          }
          this.splitLines.push(new PathStringManager().M(prevPoint.startPoint).Q(current.reversePoint, current.startPoint).toString(`split-path ${selected}`));
        }
      } else {
        if ((this.checkInViewport(prevPoint.startPoint) || this.checkInViewport(prevPoint.endPoint) || this.checkInViewport(current.reversePoint) || this.checkInViewport(current.startPoint)) === false) {
          return;
        }
        this.splitLines.push(new PathStringManager().M(prevPoint.startPoint).C(prevPoint.endPoint, current.reversePoint, current.startPoint).toString(`split-path ${selected}`));
      }
    }
  }
  makePointGuide(points2) {
    for (var index2 = 0, len2 = points2.length; index2 < len2; index2++) {
      var currentIndex = index2;
      var current = points2[currentIndex];
      if (!current)
        continue;
      var nextPoint = Point.getNextPoint(points2, index2);
      var prevPoint = Point.getPrevPoint(points2, index2);
      if (prevPoint && prevPoint.command === "M") {
        if (current.startPoint) {
          current.startPoint.isSecond = true;
        }
      }
      if (current.startPoint) {
        if (nextPoint) {
          current.startPoint.isLast = nextPoint.command === "M";
        } else {
          current.startPoint.isLast = index2 === len2 - 1;
        }
      }
      current.selected = this.selectedIndex === index2;
      if (current.command === "M") {
        this.makeStartPointGuide(prevPoint, current, nextPoint, index2);
      } else {
        var isSiblingSelected = Boolean(this.isSelectedSegment("endPoint", prevPoint == null ? void 0 : prevPoint.index) || this.isSelectedSegment("startPoint", prevPoint == null ? void 0 : prevPoint.index) || this.isSelectedSegment("reversePoint", prevPoint == null ? void 0 : prevPoint.index) || this.isSelectedSegment("endPoint", nextPoint == null ? void 0 : nextPoint.index) || this.isSelectedSegment("startPoint", nextPoint == null ? void 0 : nextPoint.index) || this.isSelectedSegment("reversePoint", nextPoint == null ? void 0 : nextPoint.index) || this.isSelectedSegment("endPoint", current == null ? void 0 : current.index) || this.isSelectedSegment("startPoint", current == null ? void 0 : current.index) || this.isSelectedSegment("reversePoint", current == null ? void 0 : current.index));
        this.makeMiddlePointGuideSplitLine(prevPoint, current, nextPoint, index2, isSiblingSelected);
        this.makeMiddlePointGuideSegment(prevPoint, current, nextPoint, index2, isSiblingSelected);
      }
      if (current.close) {
        this.pathStringManager.Z();
      }
    }
  }
  makeMovePositionGuide() {
    var state = this.state;
    var { startPoint, moveXY, dragPoints, altKey, snapPointList, isGroupSegment } = state;
    var points2 = this.points;
    if (moveXY) {
      snapPointList = snapPointList || [];
      var {
        snapPointList: movePointSnapPointList,
        moveXY: newMoveXY
      } = calculateMovePointSnap(points2, moveXY, 3);
      snapPointList.push.apply(snapPointList, movePointSnapPointList);
      state.moveXY = newMoveXY;
      moveXY = newMoveXY;
      this.snapPointList = snapPointList;
      var prev = points2[points2.length - 1];
      if (dragPoints && !isGroupSegment) {
        if (!prev) {
          var { x: x2, y: y2 } = Point.getReversePoint(startPoint, moveXY);
          this.guideLineManager.M(moveXY).L(startPoint).L({ x: x2, y: y2 });
          this.segmentManager.addCurvePoint(startPoint).addCurvePoint(moveXY).addCurvePoint({ x: x2, y: y2 });
        } else if (prev.curve) {
          var { x: x2, y: y2 } = Point.getReversePoint(startPoint, moveXY);
          this.guideLineManager.M(prev.startPoint).C(prev.endPoint, { x: x2, y: y2 }, startPoint);
          this.segmentManager.addGuideLine(prev.startPoint, prev.endPoint).addGuideLine(startPoint, { x: x2, y: y2 }).addGuideLine(startPoint, moveXY).addCurvePoint(prev.endPoint).addCurvePoint({ x: x2, y: y2 }).addCurvePoint(moveXY).addPoint(false, startPoint);
        } else if (prev.curve === false) {
          var { x: x2, y: y2 } = Point.getReversePoint(startPoint, moveXY);
          this.guideLineManager.M(prev.startPoint).Q({ x: x2, y: y2 }, startPoint);
          this.segmentManager.addGuideLine(moveXY, { x: x2, y: y2 }).addPoint(false, startPoint).addCurvePoint({ x: x2, y: y2 }).addCurvePoint(moveXY);
        }
      } else {
        if (!prev)
          ;
        else if (prev.curve) {
          this.guideLineManager.M(prev.startPoint).Q(prev.endPoint, moveXY);
          this.segmentManager.addGuideLine(prev.endPoint, prev.startPoint).addCurvePoint(prev.endPoint);
        } else {
          if (!prev.close) {
            this.guideLineManager.M(prev.startPoint).L(moveXY);
            this.segmentManager.addPoint(false, prev.startPoint);
          }
        }
      }
    }
  }
  makeSnapLines() {
    var snapLines = [];
    if (this.snapPointList) {
      var snapPath = new PathStringManager();
      snapLines = this.snapPointList.map((snapPoint) => {
        snapPath.reset();
        return snapPath.M(snapPoint.startPoint).L(snapPoint.endPoint).X(snapPoint.startPoint).toString("snap-path");
      });
    }
    return snapLines.join("");
  }
  makePathArea() {
    const pathList = this.splitedGroupList.map(({ startPointIndex, points: points2 }, groupIndex) => {
      const d = PathGenerator.generatorPathString(points2);
      const verties = toRectVerties(PathParser.fromSVGString(d).getBBox());
      return {
        points: points2,
        startPointIndex,
        groupIndex,
        center: verties[4],
        d
      };
    });
    const pathCount = pathList.length;
    return `
            <g>
               ${pathList.map((it) => {
      const { center: center2 } = it;
      const [x2, y2] = center2;
      const selected = this.state.selectedGroupIndex === it.groupIndex;
      return `
                        <path class="path-area ${selected ? "selected" : ""}" 
                            d="${it.d}" 
                            data-point-index="${it.startPointIndex}" 
                            data-group-index="${it.groupIndex}" 
                        />

                        ${pathCount > 1 && `
                            <text class="path-area-text" x="${x2}" y="${y2}" >${it.groupIndex + 1}</text>
                        `}
                    `;
    }).join("")}
            </g>
        `;
  }
  toSVGString() {
    return `
        <svg width="100%" height="100%" class='svg-editor-canvas'>
            ${this.guideLineManager.toString("guide")}
            ${this.splitLines.join("")}
            ${this.makeSnapLines()}
            ${this.makePathArea()}
            ${this.segmentManager.toString()}
        </svg>
        `;
  }
}
var PathDrawView$1 = "";
const FIELDS$1 = ["fill", "fill-opacity", "stroke", "stroke-width", "stroke-linecap", "stroke-linejoin"];
class PathDrawView extends EditorElement {
  initialize() {
    super.initialize();
    this.pathParser = new PathParser();
  }
  initState() {
    return {
      points: [],
      $target: null,
      fill: "transparent",
      stroke: "black",
      "fill-opacity": null,
      "stroke-width": 2,
      "stroke-linecap": "round",
      "stroke-linejoin": "round",
      tolerance: 1
    };
  }
  [SUBSCRIBE("changeDrawManager")](obj2) {
    this.setState(__spreadValues({}, obj2), false);
  }
  get scale() {
    return this.$viewport.scale;
  }
  template() {
    return `
        <div class='elf--path-draw-view' tabIndex="-1">
            <div class='path-draw-container' ref='$view'></div>
        </div>`;
  }
  initRect(isForce = false) {
    if (!this.state.rect || isForce) {
      this.state.rect = this.$el.rect();
    }
  }
  [KEYUP("document") + IF("isShow") + ESCAPE + ENTER + PREVENT + STOP]() {
    this.trigger("hidePathDrawEditor");
  }
  [SUBSCRIBE("DrawEditorDone")]() {
    this.trigger("hidePathDrawEditor");
  }
  get totalPathLength() {
    if (!this.refs.$view)
      return 0;
    var $obj = this.refs.$view.$("path.object");
    if (!$obj)
      return 0;
    return $obj.totalLength;
  }
  makePathLayer(pathRect) {
    var layer2;
    const newPath = PathParser.makePathByPoints(this.state.points).simplify(this.state.tolerance).smooth(30);
    newPath.transformMat4(this.$viewport.matrixInverse);
    const bbox = newPath.getBBox();
    const newWidth = distance$1(bbox[1], bbox[0]);
    const newHeight = distance$1(bbox[3], bbox[0]);
    newPath.translate(-bbox[0][0], -bbox[0][1]);
    const pathItem = {
      itemType: "svg-path",
      x: bbox[0][0],
      y: bbox[0][1],
      width: newWidth,
      height: newHeight,
      d: newPath.d,
      totalLength: this.totalPathLength
    };
    FIELDS$1.forEach((key) => {
      if (this.state[key])
        Object.assign(pathItem, { [key]: this.state[key] });
    });
    const containerItem = this.$selection.currentProject;
    layer2 = containerItem.appendChild(this.$editor.createModel(pathItem));
    return layer2;
  }
  addPathLayer() {
    var pathRect = this.getPathRect();
    if (pathRect.width !== 0 && pathRect.height !== 0) {
      var layer2 = this.makePathLayer(pathRect);
      if (layer2) {
        this.emit("refreshAll");
      }
    }
  }
  changeMode(obj2) {
    this.setState(__spreadValues(__spreadValues({}, this.initState()), obj2), false);
  }
  getCurrentObject() {
    var current = this.state.current;
    if (!current) {
      return null;
    }
    return {
      current,
      d: current.d
    };
  }
  [SUBSCRIBE("showPathDrawEditor")](obj2 = {}) {
    this.changeMode(obj2);
    this.$el.show();
    this.$el.focus();
    this.emit("showDrawManager", {
      instance: this,
      fill: this.state.fill,
      stroke: this.state.stroke,
      "fill-opacity": this.state["fill-opacity"],
      "stroke-width": this.state["stroke-width"],
      "stroke-linecap": this.state["stroke-linecap"],
      "stroke-linejoin": this.state["stroke-linejoin"]
    });
    this.emit("hidePathEditor");
    this.emit("push.mode.view", "PathDrawView");
  }
  [SUBSCRIBE("initPathDrawEditor")]() {
    this.pathParser.reset("");
    this.refs.$view.empty();
  }
  [SUBSCRIBE("hidePathDrawEditor")]() {
    if (this.$el.isShow()) {
      this.trigger("initPathDrawEditor");
      this.$el.hide();
      this.emit("hideDrawManager");
      this.emit("pop.mode.view", "PathDrawView");
    }
  }
  [SUBSCRIBE("hideAddViewLayer")]() {
    this.$el.hide();
    this.emit("hideDrawManager");
  }
  getInnerId(postfix = "") {
    return "draw-manager-" + postfix;
  }
  get toFillSVG() {
    return SVGFill.parseImage(this.state.fill || "transparent").toSVGString(this.fillId);
  }
  get toStrokeSVG() {
    return SVGFill.parseImage(this.state.stroke || "black").toSVGString(this.strokeId);
  }
  get toDefInnerString() {
    return `
            ${this.toFillSVG}
            ${this.toStrokeSVG}
        `;
  }
  get toDefString() {
    var str = this.toDefInnerString.trim();
    return `
            <defs>
            ${str}
            </defs>
        `;
  }
  get fillId() {
    return this.getInnerId("fill");
  }
  get strokeId() {
    return this.getInnerId("stroke");
  }
  get toFillValue() {
    return SVGFill.parseImage(this.state.fill || "transparent").toFillValue(this.fillId);
  }
  get toStrokeValue() {
    return SVGFill.parseImage(this.state.stroke || "black").toFillValue(this.strokeId);
  }
  [BIND("$view")]() {
    const newPath = PathParser.makePathByPoints(this.state.points).simplify(this.state.tolerance);
    return {
      innerHTML: `
            <svg width="100%" height="100%" class='svg-editor-canvas'>
                ${this.toDefString}
                <path 
                    class='object' 
                    fill="${this.toFillValue}"
                    stroke="${this.toStrokeValue}"
                    fill-opacity="${this.state["fill-opacity"]}"
                    stroke-width="${this.state["stroke-width"]}"
                    stroke-linecap="${this.state["stroke-linecap"]}"
                    stroke-linejoin="${this.state["stroke-linejoin"]}"
                    d="${newPath.d}" 
                />
            </svg>
            `
    };
  }
  renderPath() {
    this.bindData("$view");
  }
  [SUBSCRIBE("resizeEditor")]() {
    this.initRect(true);
  }
  getPathRect() {
    this.initRect(true);
    var $obj = this.refs.$view.$("path.object");
    var pathRect = { x: 0, y: 0, width: 0, height: 0 };
    if ($obj) {
      pathRect = $obj.rect();
      pathRect.x -= this.state.rect.x;
      pathRect.y -= this.state.rect.y;
    }
    return pathRect;
  }
  [POINTERSTART("$view") + MOVE() + END()](e2) {
    this.initRect();
    this.state.altKey = false;
    this.state.startXY = {
      x: e2.xy.x - this.state.rect.x,
      y: e2.xy.y - this.state.rect.y
    };
    this.state.points = [this.state.startXY];
  }
  move(dx, dy, eventType, pressure) {
    this.state.points.push({
      x: this.state.startXY.x + dx,
      y: this.state.startXY.y + dy,
      pressure
    });
    this.renderPath();
  }
  end(dx, dy) {
    this.addPathLayer();
    this.trigger("initPathDrawEditor");
  }
}
var DrawManager$1 = "";
class DrawManager extends EditorElement {
  initState() {
    return {
      tolerance: 1,
      stroke: "black",
      "stroke-width": 2,
      "stroke-linecap": "round",
      "stroke-linejoin": "round",
      msg: this.$i18n("path.manager.msg")
    };
  }
  [SUBSCRIBE("refreshSelection")]() {
    var _a, _b;
    var current = this.$selection.current;
    if (current) {
      (_a = this.children.$stroke) == null ? void 0 : _a.setValue(current["stroke"] || "rgba(0, 0, 0, 1)");
      (_b = this.children.$strokeWidth) == null ? void 0 : _b.setValue(current["stroke-width"] || Length.number(1));
    }
  }
  [SUBSCRIBE("setColorAsset")]({ color: color2 }) {
    if (this.$el.isShow()) {
      this.setState({
        stroke: color2
      }, false);
      this.children.$stroke.setValue(color2);
      this.updateData({
        stroke: color2
      });
    }
  }
  template() {
    return `
      <div class='elf--draw-manager'>
        <div class="tools left" ref="$left">
            <button type="button" class="primary" data-value='DrawEditorDone' title='${this.$i18n("draw.manager.mode.modify")}' >Done</button>
        </div>      
        <div class='tools'>   
          <div >        
            <label data-tooltip="${this.$i18n("draw.manager.tolerance")}">Tolerance</label>            
            <object refClass="NumberInputEditor"  
              ref='$tolerance' 
              key='tolerance' 
              value="1" 
              min="0"
              max="100"
              step="0.01"
              unit="number" 
              onchange="changeValue" 
            />
          </div>              
          <div >
            <label>${this.$i18n("svg.item.property.stroke")}</label>          
            <object refClass="FillSingleEditor" 
              ref='$stroke' 
              simple="true" 
              value="${this.state.stroke}" 
              key='stroke' 
              onchange="changeValue" 
            />
          </div>

          <div >
            <label>${this.$i18n("svg.item.property.strokeWidth")}</label>          
            <object refClass="NumberInputEditor"  
              ref='$strokeWidth' 
              key="stroke-width" 
              value="${this.state["stroke-width"]}"              
              onchange="changeValue" />
          </div>      
          

          <div>
            <label data-tooltip="${this.$i18n("svg.item.property.lineCap")}">Cap</label>          
            <object refClass="SelectEditor" 
              ref='$strokeLineCap' 
              key="stroke-linecap" 
              value="${this.state["stroke-linecap"]}"                   
              options=${variable$4(["butt", "round", "square"])} 
              onchange="changeValue" 
            />
          </div> 
          <div>
            <label data-tooltip="${this.$i18n("svg.item.property.lineJoin")}">Join</label>          
            <object refClass="SelectEditor"  
              ref='$strokeLineJoin' 
              key="stroke-linejoin" 
              value="${this.state["stroke-linejoin"]}"                                 
              options=${variable$4(["miter", "bevel", "round"])}
              onchange="changeValue" 
            />
          </div>
        </div>
      </div>    
    `;
  }
  [SUBSCRIBE_SELF("changeValue")](key, value, params) {
    this.updateData({
      [key]: value
    });
  }
  updateData(obj2 = {}) {
    this.setState(obj2, false);
    this.state.instance.trigger(this.state.changeEvent, obj2);
  }
  [SUBSCRIBE("changePathManager")](mode) {
    this.setState({ mode });
  }
  [SUBSCRIBE("showDrawManager")](obj2 = {}) {
    obj2.changeEvent = obj2.changeEvent || "changeDrawManager";
    this.setState(obj2);
    this.$el.show();
    this.emit("addStatusBarMessage", this.state.msg);
    this.emit("hidePathManager");
  }
  [SUBSCRIBE("hideDrawManager")]() {
    this.$el.hide();
  }
  [CLICK("$left button")](e2) {
    var message = e2.$dt.attr("data-value");
    this.emit(message);
  }
}
function pathDrawView(editor) {
  editor.registerMenuItem("canvas.view", {
    PathDrawView
  });
  editor.registerMenuItem("page.subeditor.view", {
    DrawManager
  });
}
var PathEditorView$1 = "";
function xy([x2, y2]) {
  return { x: x2, y: y2 };
}
const SegmentConvertor = class extends EditorElement {
  convertToCurve(index2) {
    this.pathGenerator.convertToCurve(index2);
    this.renderPath();
    this.refreshPathLayer();
  }
  isEditableSegment() {
    return this.state.disableCurve === false;
  }
  [DOUBLECLICK("$view [data-segment]") + IF("isEditableSegment") + PREVENT](e2) {
    var index2 = +e2.$dt.attr("data-index");
    this.convertToCurve(index2);
  }
  [DOUBLETAB("$view [data-segment]") + PREVENT + DELAY(300)](e2) {
    var index2 = +e2.$dt.attr("data-index");
    this.convertToCurve(index2);
  }
};
const PathCutter = class extends SegmentConvertor {
  calculatePointOnLine(d, clickPosition) {
    var parser2 = new PathParser(d);
    return parser2.getClosedPoint(clickPosition);
  }
  [POINTERSTART("$view .split-path") + MOVE() + END()](e2) {
    this.initRect();
    var parser2 = new PathParser(e2.$dt.attr("d"));
    var clickPosition = {
      x: e2.xy.x - this.state.rect.x,
      y: e2.xy.y - this.state.rect.y
    };
    var selectedSegmentIndex = -1;
    if (this.isMode("path")) {
      this.state.dragXY = clickPosition;
      this.state.startPoint = this.state.dragXY;
      this.pathGenerator.setLastPoint(this.state.startPoint);
      this.state.isSplitPath = true;
      this.renderPath();
      if (this.state.current) {
        this.refreshPathLayer();
      } else {
        this.addPathLayer();
        this.trigger("initPathEditorView");
      }
      return;
    } else {
      if (parser2.segments[1].command === "C") {
        var points2 = [
          xy(parser2.segments[0].values),
          xy(parser2.segments[1].values.slice(0, 2)),
          xy(parser2.segments[1].values.slice(2, 4)),
          xy(parser2.segments[1].values.slice(4, 6))
        ];
        var curve = recoverBezier(...points2, 20);
        var t = curve(clickPosition.x, clickPosition.y);
        selectedSegmentIndex = this.pathGenerator.setPoint(getBezierPoints(points2, t));
      } else if (parser2.segments[1].command === "Q") {
        var points2 = [
          xy(parser2.segments[0].values),
          xy(parser2.segments[1].values.slice(0, 2)),
          xy(parser2.segments[1].values.slice(2, 4))
        ];
        var curve = recoverBezierQuard(...points2, 20);
        var t = curve(clickPosition.x, clickPosition.y);
        selectedSegmentIndex = this.pathGenerator.setPointQuard(getBezierPointsQuard(points2, t));
      } else if (parser2.segments[1].command === "L") {
        var points2 = [
          xy(parser2.segments[0].values),
          xy(parser2.segments[1].values.slice(0, 2))
        ];
        var curve = recoverBezierLine(...points2, 20);
        var t = curve(clickPosition.x, clickPosition.y);
        selectedSegmentIndex = this.pathGenerator.setPointLine(getBezierPointsLine(points2, t));
        if (e2.altKey) {
          this.pathGenerator.convertToCurve(selectedSegmentIndex);
        }
      }
      this.renderPath();
      this.refreshPathLayer();
      this.changeMode("segment-move");
      this.pathGenerator.setCachePoint(selectedSegmentIndex, "startPoint");
      this.pathGenerator.selectKeyIndex("startPoint", selectedSegmentIndex);
    }
  }
};
const PathTransformEditor = class extends PathCutter {
  [SUBSCRIBE("changePathTransform")](transformMoveType) {
    this.resetTransformZone();
    var { width: width2, height: height2 } = this.state.transformZoneRect;
    this.pathGenerator.initTransform(this.state.transformZoneRect);
    switch (transformMoveType) {
      case "flipX":
        this.pathGenerator.transform("flipX", width2, 0);
        break;
      case "flipY":
        this.pathGenerator.transform("flipY", 0, height2);
        break;
      case "flip":
        this.pathGenerator.transform("flip", width2, height2);
    }
    this.renderPath();
    this.refreshPathLayer();
  }
  [SUBSCRIBE("changePathUtil")](utilType) {
    switch (utilType) {
      case "reverse":
        const { d } = this.pathGenerator.toPath();
        const pathParser = new PathParser(d);
        pathParser.reverse(...this.pathGenerator.selectedGroupIndexList);
        pathParser.transformMat4(this.state.cachedMatrixInverse);
        this.refreshEditorView({ d: pathParser.d });
        this.updatePathLayer();
        break;
    }
  }
  [SUBSCRIBE("divideSegmentsByCount")](count) {
    const { d } = this.pathGenerator.toPath();
    const pathParser = new PathParser(d);
    const newPath = pathParser.divideSegmentByCount(count);
    newPath.transformMat4(this.state.cachedMatrixInverse);
    this.refreshEditorView({ d: newPath.d });
  }
};
const FIELDS = ["fill", "fill-opacity", "stroke", "stroke-width"];
class PathEditorView extends PathTransformEditor {
  initialize() {
    super.initialize();
    this.pathParser = new PathParser();
    this.pathGenerator = new PathGenerator(this);
  }
  initState() {
    return {
      changeEvent: "updatePathItem",
      isShow: false,
      isControl: false,
      disableCurve: false,
      points: [],
      mode: "path",
      clickCount: 0,
      isSegment: false,
      isFirstSegment: false,
      current: null
    };
  }
  get scale() {
    return this.$viewport.scale;
  }
  template() {
    return `
        <div class='elf--path-editor-view' tabIndex="-1">
            <style type="text/css" ref="$styleView"></style>
            <svg id='patternId' width='100%' height='100%' xmlns='http://www.w3.org/2000/svg'>
                <defs>
                    <pattern id='stripe' patternUnits='userSpaceOnUse' width='20' height='33' patternTransform='scale(1) rotate(135)'>
                        <path d='M0 8h20z'   stroke-width='1' stroke='#07A3FB' fill='none'/>
                        <path d='M0 16h20z'   stroke-width='1' stroke='#07A3FB' fill='none'/>
                        <path d='M0 24h20z'   stroke-width='1' stroke='#07A3FB' fill='none'/>
                        <path d='M0 32h20z'   stroke-width='1' stroke='#07A3FB' fill='none'/>
                    </pattern>
                </defs>    
            </svg>
            <div class='path-container' ref='$view'></div>
            <div class='path-container split-panel'>
                <svg width="100%" height="100%">
                    <circle ref='$splitCircle' class='split-circle' />
                </svg>
            </div>
            <div class='segment-box' ref='$segmentBox'></div>
        </div>`;
  }
  isShow() {
    return this.state.isShow;
  }
  initRect(isForce = false) {
    if (!this.state.rect || isForce) {
      this.state.rect = this.$el.rect();
    }
  }
  [SUBSCRIBE("PathEditorDone")]() {
    if (this.state.current) {
      this.refreshPathLayer();
      this.trigger("hidePathEditor");
    } else {
      this.addPathLayer();
    }
    if (!this.state.current && this.pathGenerator.length) {
      this.trigger("initPathEditorView");
    } else {
      this.trigger("hidePathEditor");
    }
  }
  [KEYUP("document") + IF("isShow") + ENTER + PREVENT + STOP]() {
    this.trigger("PathEditorDone");
  }
  [KEYUP("document") + IF("isShow") + ESCAPE + PREVENT + STOP]() {
    if (this.state.current) {
      this.refreshPathLayer();
    } else {
      this.addPathLayer();
    }
    this.trigger("hidePathEditor");
  }
  makePathLayer() {
    var layer2;
    const newPath = new PathParser(this.pathGenerator.toPath().d);
    newPath.transformMat4(this.$viewport.matrixInverse);
    const bbox = newPath.getBBox();
    const newWidth = distance$1(bbox[1], bbox[0]);
    const newHeight = distance$1(bbox[3], bbox[0]);
    newPath.translate(-bbox[0][0], -bbox[0][1]);
    const pathItem = {
      itemType: "svg-path",
      x: bbox[0][0],
      y: bbox[0][1],
      width: newWidth,
      height: newHeight,
      d: newPath.d,
      fill: newPath.closed ? `#C4C4C4` : "transparent"
    };
    FIELDS.forEach((key) => {
      if (this.state[key]) {
        pathItem[key] = this.state[key];
      }
    });
    const containerItem = this.$selection.getArtboardByPoint(bbox[0]) || this.$selection.currentProject;
    layer2 = containerItem.appendChild(this.$editor.createModel(pathItem));
    return layer2;
  }
  updatePathLayer() {
    var { d } = this.pathGenerator.toPath();
    var parser2 = new PathParser(d);
    parser2.transformMat4(this.$viewport.matrixInverse);
    this.emit(this.state.changeEvent, {
      d: parser2.d,
      matrix: this.state.matrix,
      box: this.state.box
    });
  }
  addPathLayer() {
    this.changeMode("modify");
    var layer2 = this.makePathLayer();
    if (layer2) {
      this.$selection.select(layer2);
      this.trigger("hidePathEditor");
      this.emit("refreshAll");
    }
  }
  changeMode(mode, obj2) {
    this.setState(__spreadValues({
      mode,
      clickCount: 0,
      moveXY: null
    }, obj2), false);
    if (obj2 == null ? void 0 : obj2.points) {
      this.pathGenerator.setPoints(obj2.points || []);
    }
    this.emit("changePathManager", this.state.mode);
  }
  [SUBSCRIBE("changePathManager")](obj2) {
    this.setState(__spreadProps(__spreadValues({}, obj2), { clickCount: 0 }), false);
    this.renderPath();
  }
  isMode(mode) {
    return this.state.mode === mode;
  }
  afterRender() {
    this.$el.hide();
  }
  [SUBSCRIBE("updateViewport")]() {
    if (this.$el.isShow()) {
      const { d } = this.pathGenerator.toPath();
      const pathParser = new PathParser(d);
      pathParser.transformMat4(this.state.cachedMatrixInverse);
      this.refreshEditorView({ d: pathParser.d });
    }
  }
  refreshEditorView(obj2, removeCache = false) {
    if (obj2 && obj2.d) {
      this.pathParser.reset(obj2.d);
      this.pathParser.transformMat4(this.$viewport.matrix);
      this.state.cachedMatrixInverse = this.$viewport.matrixInverse;
      removeCache ? [] : this.pathGenerator.selectedPointList;
      this.pathGenerator.setPoints(this.pathParser.convertGenerator());
    }
    this.renderPath();
  }
  [SUBSCRIBE("showPathEditor")](mode = "path", obj2 = {}) {
    this.state.isShow = true;
    this.transformMode = mode;
    if (mode === "move") {
      obj2.current = null;
      obj2.points = [];
    }
    obj2.box = obj2.box || "canvas";
    this.changeMode(mode, obj2);
    this.refreshEditorView(obj2, true);
    this.$el.show();
    this.$el.focus();
    this.emit("showPathManager", { mode: this.state.mode });
    this.emit("hidePathDrawEditor");
    this.emit("push.mode.view", "PathEditorView");
  }
  [SUBSCRIBE("hidePathEditor")]() {
    if (this.$el.isShow()) {
      this.pathParser.reset("");
      this.pathGenerator.setPoints([]);
      this.setState(this.initState(), false);
      this.refs.$view.empty();
      this.$el.hide();
      this.emit("hidePathManager");
      this.emit("pop.mode.view", "PathEditorView");
      this.emit("refreshSelectionTool");
    }
  }
  [SUBSCRIBE("hideAddViewLayer")]() {
    this.state.isShow = false;
    this.state.isControl = false;
    this.pathParser.reset("");
    this.setState(this.initState(), false);
    this.refs.$view.empty();
    this.$el.hide();
    this.emit("hidePathManager");
  }
  [BIND("$view")]() {
    var _a;
    const path = this.state.isShow ? this.pathGenerator.makeSVGPath() : "";
    const strokeWidth = Length.parse((_a = this.state.current) == null ? void 0 : _a["stroke-width"]).value || 0;
    return {
      class: {
        "path": this.state.mode === "path",
        "modify": this.state.mode === "modify",
        "transform": this.state.mode === "transform",
        "box": this.state.box === "box",
        "canvas": this.state.box === "canvas",
        "segment-move": this.state.mode === "segment-move",
        "is-control": this.state.isControl,
        "has-one-stroke-width": strokeWidth === 1
      },
      htmlDiff: path
    };
  }
  [BIND("$splitCircle")]() {
    if (this.state.splitXY) {
      return {
        cx: this.state.splitXY.x,
        cy: this.state.splitXY.y,
        r: 5
      };
    } else {
      return {
        r: 0
      };
    }
  }
  refreshPathLayer() {
    this.updatePathLayer();
  }
  renderPath() {
    this.bindData("$view");
  }
  getPathRect() {
    this.initRect(true);
    const { d } = this.pathGenerator.toPath();
    return vertiesToRectangle(PathParser.fromSVGString(d).getBBox());
  }
  resetTransformZone() {
    var rect2 = this.getPathRect();
    this.state.transformZoneRect = rect2;
  }
  [POINTERMOVE("$view") + PREVENT](e2) {
    this.initRect();
    if (this.isMode("path") && this.state.rect) {
      this.state.moveXY = {
        x: e2.xy.x - this.state.rect.x,
        y: e2.xy.y - this.state.rect.y
      };
      this.state.altKey = e2.altKey;
      this.renderPath();
    } else {
      var $target = Dom.create(e2.target);
      var isSplitPath = $target.hasClass("split-path");
      if (isSplitPath) {
        this.state.splitXY = this.calculatePointOnLine($target.attr("d"), {
          x: e2.xy.x - this.state.rect.x,
          y: e2.xy.y - this.state.rect.y
        });
      } else {
        this.state.splitXY = null;
      }
      this.bindData("$splitCircle");
      this.state.altKey = false;
    }
  }
  [POINTERSTART("$view :not(.split-path)") + PREVENT + STOP + MOVE() + END()](e2) {
    this.initRect();
    this.state.altKey = false;
    var isPathMode = this.isMode("path");
    this.$config.set("set.move.control.point", true);
    this.state.dragXY = {
      x: e2.xy.x - this.state.rect.x,
      y: e2.xy.y - this.state.rect.y
    };
    this.$config.set("set.drag.path.area", false);
    var $target = Dom.create(e2.target);
    if ($target.hasClass("svg-editor-canvas") && !isPathMode) {
      this.$config.set("set.drag.path.area", true);
      this.state.isGroupSegment = false;
      this.state.selectedGroupIndex = -1;
      this.state.selectedPointIndex = -1;
    } else {
      this.pathGenerator.reselect();
      this.state.isSegment = $target.attr("data-segment") === "true";
      this.state.isFirstSegment = this.state.isSegment && $target.attr("data-is-first") === "true";
      this.state.isGroupSegment = $target.hasClass("path-area");
      if (this.state.isGroupSegment) {
        this.state.selectedGroupIndex = +$target.data("group-index");
        this.state.selectedPointIndex = +$target.data("point-index");
      } else {
        this.state.selectedGroupIndex = -1;
        this.state.selectedPointIndex = -1;
      }
    }
    if (isPathMode) {
      if (this.state.isFirstSegment) {
        var index2 = +$target.attr("data-index");
        this.state.startPoint = this.pathGenerator.points[index2].startPoint;
      } else {
        this.state.startPoint = this.state.dragXY;
      }
      this.state.dragPoints = false;
      this.state.endPoint = null;
    } else {
      if (this.state.isSegment) {
        this.changeMode("segment-move");
        var [index2, segmentKey] = $target.attrs("data-index", "data-segment-point");
        const localIndex = +index2;
        if (e2.shiftKey) {
          this.pathGenerator.toggleSelect(segmentKey, localIndex);
        } else {
          this.pathGenerator.setCachePoint(localIndex, segmentKey);
          this.pathGenerator.selectKeyIndex(segmentKey, localIndex);
        }
        this.renderPath();
      } else if (this.state.isGroupSegment) {
        this.changeMode("segment-move");
        this.pathGenerator.selectGroup(this.state.selectedGroupIndex);
        this.renderPath();
      }
    }
  }
  move(dx, dy) {
    var e2 = this.$config.get("bodyEvent");
    if (this.$config.true("set.drag.path.area")) {
      this.renderSelectBox(this.state.dragXY, dx, dy);
    } else if (this.isMode("segment-move")) {
      this.pathGenerator.move(dx, dy, e2);
      this.renderPath();
      this.updatePathLayer();
    } else if (this.isMode("path")) {
      const dist2 = getDist(dx, dy, 0, 0);
      if (dist2 >= 2) {
        this.state.dragPoints = e2.altKey ? false : true;
      }
    }
  }
  renderSegment(callback) {
    if (this.pathGenerator.selectedLength) {
      this.pathGenerator.reselect();
      if (isFunction(callback))
        callback();
      this.renderPath();
      this.updatePathLayer();
    }
  }
  end(dx, dy) {
    var e2 = this.$config.get("bodyEvent");
    this.$config.set("set.move.control.point", false);
    if (this.state.isGroupSegment) {
      this.pathGenerator.select();
    }
    if (this.$config.true("set.drag.path.area")) {
      if (dx === 0 && dy === 0) {
        this.changeMode("modify");
        this.trigger("hidePathEditor");
      } else {
        this.changeMode("segment-move");
        this.pathGenerator.selectInBox(this.getSelectBox(), e2.shiftKey);
        this.renderPath();
        this.hideSelectBox();
      }
    } else if (this.isMode("modify")) {
      this.pathGenerator.reselect();
    } else if (this.isMode("segment-move")) {
      this.changeMode("modify");
      this.pathGenerator.reselect();
      this.renderPath();
      this.updatePathLayer();
    } else if (this.isMode("path")) {
      if (this.state.isFirstSegment) {
        this.changeMode("modify");
        this.pathGenerator.setConnectedPoint(dx, dy);
        this.renderPath();
        if (this.state.current) {
          this.refreshPathLayer();
        } else {
          this.addPathLayer();
          this.trigger("initPathEditorView");
        }
      } else {
        if (this.state.isSplitPath)
          ;
        else {
          this.pathGenerator.moveEnd(dx, dy);
          this.state.clickCount++;
          this.renderPath();
          this.pathGenerator.reselect();
        }
      }
      this.state.isSplitPath = false;
    }
  }
  hideSelectBox() {
    this.refs.$segmentBox.css({
      left: -1e5
    });
  }
  renderSelectBox(startXY = null, dx = 0, dy = 0) {
    var obj2 = {
      left: startXY.x + (dx < 0 ? dx : 0),
      top: startXY.y + (dy < 0 ? dy : 0),
      width: Math.abs(dx),
      height: Math.abs(dy)
    };
    this.refs.$segmentBox.css(obj2);
  }
  getSelectBox() {
    var [x2, y2, width2, height2] = this.refs.$segmentBox.styles("left", "top", "width", "height").map((it) => Length.parse(it));
    var rect2 = {
      x: x2,
      y: y2,
      width: width2,
      height: height2
    };
    rect2.x2 = rect2.x.value + rect2.width;
    rect2.y2 = rect2.y.value + rect2.height;
    return rect2;
  }
  [SUBSCRIBE("deleteSegment")]() {
    this.pathGenerator.reselect();
    this.pathGenerator.removeSelectedSegment();
    this.renderPath();
    this.updatePathLayer();
  }
  [SUBSCRIBE("moveSegment")](dx, dy) {
    this.pathGenerator.reselect();
    this.pathGenerator.moveSelectedSegment(dx, dy);
    this.renderPath();
    this.updatePathLayer();
  }
  [SUBSCRIBE("initPathEditorView")]() {
    this.pathParser.reset("");
    this.setState(this.initState(), false);
    this.state.isShow = true;
    this.refs.$view.empty();
    this.$el.focus();
  }
}
var PathManager$1 = "";
const MODES = {
  "segment-move": "modify",
  "modify": "modify",
  "path": "path",
  "transform": "transform",
  "warp": "warp"
};
class PathManager extends EditorElement {
  initState() {
    return {
      mode: "move",
      fill: null,
      stroke: null,
      "fill-opacity": null,
      "stroke-width": null,
      msg: this.$i18n("path.manager.msg")
    };
  }
  template() {
    return `
      <div class='elf--path-manager'>
        <div class="tools left" ref="$left">
            <button type="button" class="primary" data-value='PathEditorDone' title='${this.$i18n("path.manager.mode.modify")}' >Done</button>
        </div>
        <div class='tools' ref='$mode' data-selected-value='${this.state.mode}'>
            <button type="button" data-value='modify' data-tooltip='${this.$i18n("path.manager.mode.modify")}' > ${iconUse$1("device_hub")}</button>
            <button type="button" data-value='path' data-tooltip='${this.$i18n("path.manager.mode.path")}' > ${iconUse$1("control_point")}</button>
            <button type="button" data-value='transform' data-tooltip='${this.$i18n("path.manager.mode.transform")}' > ${iconUse$1("transform")}</button>             
        </div>
        <div class="split"></div>        
        <div class='tools' ref='$util'>
            <button type="button" data-value='reverse' data-tooltip='${this.$i18n("path.manager.mode.reverse")}' >${iconUse$1("sync")}</button>
        </div>                        
        <div class='tools' ref='$flip'>
            <button type="button" data-value='flipX' data-tooltip='${this.$i18n("path.manager.mode.flipX")}'>${iconUse$1("flip")}</button>
            <button type="button" data-value='flipY' data-tooltip='${this.$i18n("path.manager.mode.flipY")}'>${iconUse$1("flip", "rotate(90 12 12)")}</button>
            <button type="button" data-value='flip' data-tooltip='${this.$i18n("path.manager.mode.flipOrigin")}'>${iconUse$1("flip", "rotate(45 12 12)")}</button>
            <div class="split"></div>            
            <button type="button" data-value='2x' data-tooltip="divide segment by 2 times">2x</button>
            <button type="button" data-value='3x' data-tooltip="divide segment by 3 times">3x</button>            
        </div>
        <div class="subpath" style="display:none">
          <button type="button" data-value="path" data-pathtype="rect">${iconUse$1("rect", "", { width: 24, height: 24 })}</button>
        </div>
      </div>    
    `;
  }
  [BIND("$mode")]() {
    return {
      "data-selected-value": MODES[this.state.mode]
    };
  }
  refresh() {
    this.bindData("$mode");
  }
  [CLICK("$flip button")](e2) {
    var transformType = e2.$dt.attr("data-value");
    if (transformType === "2x") {
      this.emit("divideSegmentsByCount", 2);
    } else if (transformType === "3x") {
      this.emit("divideSegmentsByCount", 3);
    } else {
      this.emit("changePathTransform", transformType);
    }
  }
  [CLICK("$util button")](e2) {
    var utilType = e2.$dt.attr("data-value");
    this.emit("changePathUtil", utilType);
  }
  [CLICK("$mode button")](e2) {
    var mode = e2.$dt.attr("data-value");
    this.updateData({
      mode
    });
    this.refresh();
  }
  [CLICK("$left button")](e2) {
    var message = e2.$dt.attr("data-value");
    this.emit(message);
  }
  updateData(obj2 = {}) {
    this.setState(obj2, false);
    this.emit(this.state.changeEvent, obj2);
  }
  [SUBSCRIBE("changePathManager")](mode) {
    this.setState({ mode });
  }
  [SUBSCRIBE("showPathManager")](obj2 = {}) {
    obj2.changeEvent = obj2.changeEvent || "changePathManager";
    this.setState(obj2);
    this.$el.show();
    this.emit("addStatusBarMessage", this.state.msg);
  }
  [SUBSCRIBE("hidePathManager")]() {
    this.$el.hide();
  }
}
function pathEditorView(editor) {
  editor.registerMenuItem("canvas.view", {
    PathEditorView
  });
  editor.registerMenuItem("page.subeditor.view", {
    PathManager
  });
}
var LayerAppendView$1 = "";
class LayerAppendView extends EditorElement {
  template() {
    return `
        <div class='elf--layer-append-view'>
            <div class='area' ref='$area'></div>
            <div class='area-rect' ref='$areaRect'></div>
            <div class='area-pointer' ref='$mousePointer'></div>
            <div class='area-pointer-view' ref='$mousePointerView'></div>            
            <input type='file' accept='image/*' multiple="true" ref='$file' class='embed-file-input'/>
            <input type='file' accept='video/*' multiple="true" ref='$video' class='embed-video-input'/>            
        </div>
        `;
  }
  initState() {
    return {
      dragStart: false,
      width: 0,
      height: 0,
      color: "black",
      fontSize: 30,
      showRectInfo: false,
      areaVerties: rectToVerties(0, 0, 0, 0),
      content: "Insert a text",
      pathManager: new PathStringManager(),
      rect: {},
      options: {},
      containerItem: void 0,
      patternInfo: {}
    };
  }
  get scale() {
    return this.$viewport.scale;
  }
  checkNotDragStart() {
    return Boolean(this.state.dragStart) === false;
  }
  [POINTERMOVE("$el") + IF("checkNotDragStart")](e2) {
    const vertex = this.$viewport.getWorldPosition(e2);
    const newVertex = this.$snapManager.checkPoint(vertex);
    if (equals$1(newVertex, vertex) === false) {
      this.state.target = newVertex;
      this.state.targetVertex = this.$viewport.applyVertex(this.state.target);
      this.state.targetPositionVertex = clone(this.state.target);
      this.state.targetGuides = this.$snapManager.findGuideOne([this.state.target]);
    } else {
      this.state.target = floor([], vertex);
      this.state.targetVertex = floor([], this.$viewport.applyVertex(this.state.target));
      this.state.targetGuides = [];
      this.state.targetPositionVertex = null;
    }
    this.bindData("$mousePointer");
    this.bindData("$mousePointerView");
  }
  [POINTERSTART("$el") + MOVE() + END() + PREVENT + STOP](e2) {
    this.initMousePoint = this.state.targetPositionVertex ? this.state.targetPositionVertex : this.$viewport.getWorldPosition(e2);
    this.state.dragStart = true;
    this.state.color = "#C4C4C4";
    this.state.text = "";
    const minX = this.initMousePoint[0];
    const minY = this.initMousePoint[1];
    const verties = rectToVerties(minX, minY, 0, 0);
    this.state.areaVerties = this.$viewport.applyVerties(verties);
    this.bindData("$area");
    this.bindData("$areaRect");
  }
  createLayerTemplate(width2, height2) {
    const { type, text: text2, color: color2, inlineStyle } = this.state;
    switch (type) {
      case "artboard":
        return `<div class='draw-item' style='background-color: white; ${inlineStyle}'></div>`;
      case "rect":
        return `<div class='draw-item' style='background-color: ${color2}; ${inlineStyle}'></div>`;
      case "circle":
        return `<div class='draw-item' style='background-color: ${color2}; border-radius: 100%; ${inlineStyle}'></div>`;
      case "text":
      case "svg-text":
        return `
                <div 
                    class='draw-item' 
                    
                    style='font-size: 30px;outline: 1px solid blue;white-space:nowrap'
                >
                    <p contenteditable="true" style="margin:0px;display: inline-block;outline:none;" ></p>
                </div>`;
      case "svg-rect":
        return `
            <div class='draw-item'>
                <svg width="${width2}" height="${height2}" style="width:100%; height:100%;" overflow="visible">
                    <path d="${PathParser.makeRect(0, 0, width2, height2).d}" stroke-width="1" stroke="black" fill="transparent" />
                </svg>
            </div>
            `;
      case "svg-circle":
        return `
            <div class='draw-item'>
                <svg width="${width2}" height="${height2}" style="width:100%; height:100%;" overflow="visible">
                    <path d="${PathParser.makeCircle(0, 0, width2, height2).d}" stroke-width="1" stroke="black" fill="transparent" />
                </svg>
            </div>
            `;
      case "svg-path":
        const newD = this.state.d.clone().scale(width2 / this.state.bboxRect.width, height2 / this.state.bboxRect.height).d;
        const options2 = this.state.options;
        return `
            <div class='draw-item'>
                <svg width="${width2}" height="${height2}" style="width:100%; height:100%;" overflow="visible">
                    <path   d="${newD}" 
                            stroke-width="${options2["stroke-width"] || 1}" 
                            stroke="${options2["stroke"] || "black"}" 
                            fill="${options2["fill"] || "transparent"}" 
                    />
                </svg>
            </div>
            `;
      case "polygon":
        const options22 = this.state.options;
        return `
                <div class='draw-item'>
                    <svg width="${width2}" height="${height2}" style="width:100%; height:100%;" overflow="visible">
                        <path   d="${PathParser.makePolygon(width2, height2, options22.count).d}" 
                                stroke-width="${options22["stroke-width"] || 1}" 
                                stroke="${options22["stroke"] || "black"}" 
                                fill="${options22["fill"] || "transparent"}" 
                        />
                    </svg>
                </div>
                `;
      case "star":
        const options3 = this.state.options;
        return `
                    <div class='draw-item'>
                        <svg width="${width2}" height="${height2}" style="width:100%; height:100%;" overflow="visible">
                            <path   d="${PathParser.makeStar(width2, height2, options3.count, options3.radius, options3.tension).d}" 
                                    stroke-width="${options3["stroke-width"] || 1}" 
                                    stroke="${options3["stroke"] || "black"}" 
                                    fill="${options3["fill"] || "transparent"}" 
                            />
                        </svg>
                    </div>
                    `;
      case "svg-textpath":
        return `
            <div class='draw-item' style='outline: 1px solid blue;'>
                <svg width="${width2}" height="${height2}" style="width:100%; height:100%;font-size: ${height2}px;" overflow="visible">
                    <defs>
                        <path id='layer-add-path' d="${PathStringManager.makeLine(0, height2, width2, height2)}" />
                    </defs>
                    <text>
                        <textPath 
                          xlink:href="#layer-add-path"
                          textLength="100%"
                          lengthAdjust="spacingAndGlyphs"
                          startOffset="0em"
                        >${text2}</textPath>
                    </text>
                </svg>
            </div>
            `;
      default:
        return `<div class='draw-item' style='outline: 1px solid blue; ${inlineStyle}'></div>`;
    }
  }
  [BIND("$area")]() {
    const { areaVerties } = this.state;
    const { left: left2, top: top2, width: width2, height: height2 } = vertiesToRectangle(areaVerties);
    return {
      style: {
        left: left2,
        top: top2,
        width: width2,
        height: height2
      },
      innerHTML: this.createLayerTemplate(width2, height2)
    };
  }
  [BIND("$areaRect")]() {
    const { areaVerties, showRectInfo } = this.state;
    const newVerties = this.$viewport.applyVertiesInverse(areaVerties);
    const { width: width2, height: height2 } = vertiesToRectangle(newVerties);
    return {
      style: {
        display: showRectInfo ? "inline-block" : "none",
        left: areaVerties[2][0],
        top: areaVerties[2][1]
      },
      innerHTML: `x: ${Math.round(newVerties[0][0])}, y: ${Math.round(newVerties[0][1])}, ${Math.round(width2)} x ${Math.round(height2)}`
    };
  }
  [BIND("$mousePointerView")]() {
    const { areaVerties, showRectInfo } = this.state;
    const { target = create$4(), targetVertex = create$4() } = this.state;
    return {
      style: {
        display: !showRectInfo ? "inline-block" : "none",
        left: targetVertex[0] || -1e4,
        top: targetVertex[1] || -1e4
      },
      innerHTML: `x: ${Math.round(target[0])}, y: ${Math.round(target[1])}`
    };
  }
  makeMousePointer() {
    if (this.state.dragStart)
      return "";
    const { target, targetVertex } = this.state;
    if (!target)
      return "";
    const guides = (this.state.targetGuides || []).filter(Boolean);
    return `
        <svg width="100%" height="100%">
            ${guides.map((guide) => {
      this.state.pathManager.reset();
      guide = this.$viewport.applyVerties([guide[0], guide[1]]);
      return this.state.pathManager.M({ x: guide[0][0], y: guide[0][1] }).L({ x: guide[1][0], y: guide[1][1] }).X({ x: guide[0][0], y: guide[0][1] }).X({ x: guide[1][0], y: guide[1][1] }).toString("layer-add-snap-pointer");
    }).join("\n")}
        </svg>
    `;
  }
  [BIND("$mousePointer")]() {
    const html2 = this.makeMousePointer();
    return {
      innerHTML: html2
    };
  }
  move() {
    const e2 = this.$config.get("bodyEvent");
    const targetMousePoint = this.$viewport.getWorldPosition();
    const newMousePoint = this.$snapManager.checkPoint(targetMousePoint);
    if (equals$1(newMousePoint, targetMousePoint) === false) {
      this.state.target = newMousePoint;
      this.state.targetVertex = this.$viewport.applyVertex(newMousePoint);
      this.state.targetGuides = this.$snapManager.findGuideOne([newMousePoint]).filter(Boolean);
    } else {
      this.state.target = void 0;
      this.state.targetGuides = [];
    }
    const isShiftKey = e2.shiftKey;
    const minX = Math.min(newMousePoint[0], this.initMousePoint[0]);
    const minY = Math.min(newMousePoint[1], this.initMousePoint[1]);
    const maxX = Math.max(newMousePoint[0], this.initMousePoint[0]);
    const maxY = Math.max(newMousePoint[1], this.initMousePoint[1]);
    let dx = maxX - minX;
    let dy = maxY - minY;
    if (isShiftKey) {
      dy = dx;
    }
    const verties = rectToVerties(minX, minY, dx, dy);
    this.state.areaVerties = this.$viewport.applyVerties(verties);
    this.state.showRectInfo = true;
    this.bindData("$area");
    this.bindData("$areaRect");
    this.bindData("$mousePointer");
    this.bindData("$mousePointerView");
  }
  end(dx, dy) {
    const isAltKey = this.$config.get("bodyEvent").altKey;
    let { color: color2, content: content2, fontSize, areaVerties, patternInfo } = this.state;
    const rectVerties = this.$viewport.applyVertiesInverse(areaVerties);
    const parentArtBoard = this.$selection.getArtboardByPoint(rectVerties[0]);
    let { x: x2, y: y2, width: width2, height: height2 } = vertiesToRectangle(rectVerties);
    let hasArea = true;
    if (width2 === 0 && height2 === 0) {
      switch (this.state.type) {
        case "text":
          content2 = "";
          height2.set(this.state.fontSize);
          hasArea = false;
          break;
        default:
          width2 = 100;
          height2 = 100;
          break;
      }
    }
    var rect2 = __spreadValues(__spreadValues({
      x: Math.floor(x2),
      y: Math.floor(y2),
      width: Math.floor(width2),
      height: Math.floor(height2),
      "background-color": color2,
      "content": content2,
      "font-size": fontSize
    }, patternInfo.attrs), this.state.options);
    switch (this.state.type) {
      case "text":
      case "svg-text":
      case "svg-textpath":
        delete rect2["background-color"];
        break;
      case "svg-path":
        rect2["d"] = this.state.d.clone().scale(width2 / this.state.bboxRect.width, height2 / this.state.bboxRect.height).d;
        break;
      default:
        delete rect2["content"];
        break;
    }
    switch (this.state.type) {
      case "image":
        this.trigger("openImage", rect2, parentArtBoard);
        break;
      case "video":
        this.trigger("openVideo", rect2, parentArtBoard);
        break;
      case "audio":
        this.trigger("openAudio", rect2, parentArtBoard);
        break;
      case "text":
        if (hasArea) {
          rect2["font-size"] = this.state.fontSize / this.$viewport.scale;
        } else {
          const scaledFontSize = this.state.fontSize / this.$viewport.scale;
          const $drawItem = this.refs.$area.$(".draw-item > p");
          $drawItem.parent().css("height", `${scaledFontSize}px`);
          $drawItem.parent().css("font-size", `${scaledFontSize}px`);
          $drawItem.select();
          $drawItem.focus();
          return;
        }
      default:
        this.emit("newComponent", this.state.type, rect2, true, parentArtBoard);
        break;
    }
    if (!isAltKey) {
      this.trigger("hideLayerAppendView");
    }
    this.state.dragStart = false;
    this.state.showRectInfo = false;
    this.state.target = void 0;
    this.bindData("$areaRect");
  }
  [SUBSCRIBE("showLayerAppendView")](type, options2 = {}) {
    this.state.type = type;
    this.state.options = options2;
    this.state.isShow = true;
    this.refs.$area.empty();
    this.$el.show();
    this.$el.focus();
    this.$snapManager.clear();
    const model = this.$model.createModel(__spreadValues({
      itemType: type
    }, options2), false);
    this.state.inlineStyle = CSS_TO_STRING$1(this.$editor.html.toCSS(model, {
      top: true,
      left: true,
      width: true,
      height: true,
      transform: true,
      "transform-origin": true
    }));
    if (options2.d) {
      this.state.d = new PathParser(options2.d);
      this.state.bboxRect = this.state.d.rect();
    }
    this.emit("push.mode.view", "LayerAppendView");
  }
  [SUBSCRIBE("hideLayerAppendView")]() {
    if (this.$el.isShow()) {
      this.state.isShow = false;
      this.$el.hide();
      this.emit("pop.mode.view", "LayerAppendView");
      this.$config.set("editing.mode", EditingMode.SELECT);
    }
  }
  [SUBSCRIBE("hideAddViewLayer")]() {
    this.state.isShow = false;
    this.$el.hide();
  }
  isShow() {
    return this.state.isShow;
  }
  [KEYDOWN("document") + IF("isShow") + ESCAPE + ENTER + PREVENT + STOP](e2) {
  }
  [KEYUP("document") + IF("isShow") + ESCAPE + ENTER + PREVENT + STOP](e2) {
    switch (this.state.type) {
      case "text":
        const $t = Dom.create(e2.target);
        let { fontSize, areaVerties } = this.state;
        const rectVerties = this.$viewport.applyVertiesInverse(areaVerties);
        const { x: x2, y: y2 } = vertiesToRectangle(rectVerties);
        const { width: width2, height: height2 } = $t.rect();
        const text2 = $t.text();
        if (text2.length === 0) {
          break;
        }
        const [
          [newWidth, newHeight, newFontSize]
        ] = this.$viewport.applyScaleVertiesInverse([
          [width2, height2, fontSize]
        ]);
        const rect2 = {
          x: x2,
          y: y2,
          width: newWidth,
          height: newHeight,
          "content": text2.trim(),
          "font-size": newFontSize
        };
        const parentArtBoard = this.$selection.getArtboardByPoint(rectVerties[0]);
        this.emit("newComponent", this.state.type, rect2, true, parentArtBoard);
        break;
    }
    this.state.dragStart = false;
    this.state.showRectInfo = false;
    this.state.target = null;
    this.bindData("$areaRect");
    this.trigger("hideLayerAppendView");
  }
  [KEYUP("$el") + IF("isShow")](e2) {
    switch (this.state.type) {
      case "text":
        const $t = Dom.create(e2.target);
        $t.rect();
        break;
    }
  }
  [CHANGE("$file")](e2) {
    this.refs.$file.files.forEach((item2) => {
      this.emit("updateImage", item2, this.state.rect, this.state.containerItem);
    });
  }
  [CHANGE("$video")](e2) {
    this.refs.$video.files.forEach((item2) => {
      this.emit("updateVideo", item2, this.state.rect, this.state.containerItem);
    });
  }
  [SUBSCRIBE("openImage")](rect2, containerItem) {
    this.state.rect = rect2;
    this.state.containerItem = containerItem;
    this.refs.$file.click();
  }
  [SUBSCRIBE("openVideo")](rect2, containerItem) {
    this.state.rect = rect2;
    this.state.containerItem = containerItem;
    this.refs.$video.click();
  }
  [SUBSCRIBE("setPatternInfo")](patternInfo) {
    this.state.patternInfo = patternInfo;
  }
  [SUBSCRIBE("updateViewport")]() {
    this.$snapManager.clear();
    this.bindData("$mousePointer");
    this.bindData("$mousePointerView");
  }
}
function layerAppendView(editor) {
  editor.registerMenuItem("canvas.view", {
    LayerAppendView
  });
}
var HoverView$1 = "";
class HoverView extends EditorElement {
  template() {
    return /* @__PURE__ */ createElementJsx("div", {
      class: "elf--hover-view sepia(0.2)"
    }, /* @__PURE__ */ createElementJsx("div", {
      class: "elf--hover-rect",
      ref: "$hoverRect"
    }));
  }
  checkModeView() {
    const e2 = this.$config.get("bodyEvent");
    if (!this.$viewport.checkInViewport(this.$viewport.getWorldPosition(e2))) {
      return false;
    }
    const canvas = Dom.create(e2.target).closest("elf--page-container");
    if (!canvas)
      return false;
    return this.$modeView.isCurrentMode("CanvasView");
  }
  [CONFIG("bodyEvent") + IF("checkModeView")]() {
    var _a, _b, _c;
    if (this.$config.true("set.move.control.point")) {
      this.$selection.setHoverId("");
      this.renderHoverLayer();
      return;
    }
    const filteredList = this.$selection.filteredLayers;
    const point2 = this.$viewport.getWorldPosition(this.$config.get("bodyEvent"));
    const items = filteredList.filter((it) => it.hasPoint(point2[0], point2[1])).filter((it) => it.isNot("artboard"));
    let hoverItems = items;
    let id = (_a = hoverItems[0]) == null ? void 0 : _a.id;
    if (this.$selection.isEmpty) {
      id = (_b = hoverItems[0]) == null ? void 0 : _b.id;
    } else if (this.$selection.isOne) {
      const pathIds = this.$selection.current.pathIds;
      hoverItems = hoverItems.filter((it) => pathIds.includes(it.id) === false || it.id === this.$selection.current.id);
      id = (_c = hoverItems[0]) == null ? void 0 : _c.id;
    }
    if (!id) {
      this.$selection.setHoverId("");
      this.renderHoverLayer();
    } else {
      if (this.$selection.setHoverId(id)) {
        this.renderHoverLayer();
      }
    }
  }
  [SUBSCRIBE("refreshHoverView")](id) {
    if (this.$selection.setHoverId(id)) {
      this.renderHoverLayer();
    }
  }
  [SUBSCRIBE("updateViewport")]() {
    this.$selection.setHoverId("");
    this.renderHoverLayer();
  }
  createVisiblePath(current) {
    if (!current.is("boolean-path")) {
      return "";
    }
    const newPath = current.absolutePath();
    newPath.transformMat4(this.$viewport.matrix);
    return `
        <svg overflow="visible">
            <path
                d="${newPath.d}"
                stroke="red"
                stroke-width="2"
                fill="none"
                />
        </svg>
        `;
  }
  renderHoverLayer() {
    const items = this.$selection.hoverItems;
    if (items.length === 0) {
      this.refs.$hoverRect.updateDiff("");
      this.emit("removeGuideLine");
    } else {
      const verties = items[0].verties;
      const title2 = items[0].is("boolean-path") ? items[0]["boolean-operation"] : items[0].itemType;
      const line2 = this.createPointerLine(this.$viewport.applyVerties(verties), title2);
      this.refs.$hoverRect.updateDiff(line2);
      this.emit("refreshGuideLineByTarget", [items[0].verties]);
    }
  }
  createPointerLine(pointers) {
    if (pointers.length === 0)
      return "";
    return `
        <svg overflow="visible">
            <path 
                class='line' 
                d="
                    M ${pointers[0][0]}, ${pointers[0][1]} 
                    L ${pointers[1][0]}, ${pointers[1][1]} 
                    L ${pointers[2][0]}, ${pointers[2][1]} 
                    L ${pointers[3][0]}, ${pointers[3][1]} 
                    L ${pointers[0][0]}, ${pointers[0][1]}
                    Z
                " 
            />
        </svg>`;
  }
}
function hoverView(editor) {
  editor.registerMenuItem("canvas.view", {
    HoverView
  });
}
var GuideLineView$1 = "";
const line = (source2, target, className = "base-line") => {
  return `<line x1="${source2[0]}" y1="${source2[1]}" x2="${target[0]}" y2="${target[1]}" class='${className}' />`;
};
const text = (t, target, className = "base-line") => {
  const text2 = `${Math.floor(t)}`;
  const unitWidth = 13;
  const unitHeight = 16;
  const width2 = text2.length * unitWidth;
  const height2 = unitHeight;
  return `
    
        <rect x="${target[0] - width2 / 4}" y="${target[1] - unitHeight - 2}" width="${width2}" height="${height2}" rx="2" ry="2" fill="#00a9f4" />
        <text x="${target[0]}" y="${target[1]}" dy="-5" font-size="16">${text2}</text>
    `;
};
const hLineByPoint = (target, source2) => {
  return line(target, source2);
};
const vLineByPoint = (target, source2) => {
  return line(target, source2);
};
const rect = (rectVerties) => {
  return `
    <path 
        class="base-rect"
        fill="none"
        stroke-width="1"
        stroke="red"
        stroke-dasharray="2 2"
        d="${PathParser.makeRect(rectVerties[0][0], rectVerties[0][1], dist(rectVerties[0], rectVerties[1]), dist(rectVerties[0], rectVerties[3])).d}
        " 
    />
`;
};
const point = (target, dist2 = 3, direction = "left") => {
  if (direction === "left") {
    return `
        <path 
            class="arrow"
            d="
                M ${target[0] + dist2} ${target[1] - dist2}
                L ${target[0]} ${target[1]}
                L ${target[0] + dist2} ${target[1] + dist2}
            " 
        />
    `;
  }
  if (direction === "right") {
    return `
        <path 
            class="arrow"
            d="
                M ${target[0] - dist2} ${target[1] - dist2}
                L ${target[0]} ${target[1]}
                L ${target[0] - dist2} ${target[1] + dist2}
            " 
        />
    `;
  }
  if (direction === "up") {
    return `
        <path 
            class="arrow"
            d="
                M ${target[0] - dist2} ${target[1] + dist2}
                L ${target[0]} ${target[1]}
                L ${target[0] + dist2} ${target[1] + dist2}
            " 
        />
    `;
  }
  if (direction === "down") {
    return `
        <path 
            class="arrow"
            d="
                M ${target[0] - dist2} ${target[1] - dist2}
                L ${target[0]} ${target[1]}
                L ${target[0] + dist2} ${target[1] - dist2}
            " 
        />
    `;
  }
  return `
        <path 
            stroke-width="1"
            d="
                M ${target[0] - dist2} ${target[1] - dist2}
                L ${target[0] + dist2} ${target[1] + dist2}
                M ${target[0] - dist2} ${target[1] + dist2}
                L ${target[0] + dist2} ${target[1] - dist2}
            " 
        />
    `;
};
class GuideLineView extends EditorElement {
  template() {
    return `
            <svg class='elf--guide-line-view' ref="$guide" width="100%" height="100%" ></svg>
            `;
  }
  initState() {
    return {
      list: []
    };
  }
  [BIND("$guide")]() {
    return {
      svgDiff: `<g>${this.createGuideLine(this.state.list)}</g>`
    };
  }
  createGuideLine(list2) {
    var images = [];
    var texts = [];
    list2 = list2.filter(Boolean);
    for (var i = 0, len2 = list2.length; i < len2; i++) {
      const [source2, target, axis, dist2, newTarget, sourceVerties, targetVerties, isInvert] = list2[i];
      const localDist = Math.floor(dist2);
      const localSourceVertex = this.$viewport.applyVertex(source2);
      const localTargetVertex = this.$viewport.applyVertex(target);
      let localNewTargetVertex;
      if (newTarget) {
        localNewTargetVertex = this.$viewport.applyVerties([newTarget])[0];
      }
      if (axis === "x") {
        if (localDist > 0) {
          images.push(line(localSourceVertex, localTargetVertex, "dash-line"));
        }
        if (localNewTargetVertex) {
          images.push(line(localTargetVertex, localNewTargetVertex, "dash-line"));
        }
        if (localDist > 0) {
          texts.push(text(localDist, lerp([], localSourceVertex, localTargetVertex, 0.5)));
        }
      }
      if (axis === "y") {
        if (localDist > 0) {
          images.push(line(localSourceVertex, localTargetVertex, "dash-line"));
        }
        if (localNewTargetVertex) {
          images.push(line(localTargetVertex, localNewTargetVertex, "dash-line"));
        }
        if (localDist > 0) {
          texts.push(text(localDist, add$1([], lerp([], localSourceVertex, localTargetVertex, 0.5), [20, 0, 0])));
        }
      }
      if (axis === "x") {
        images.push(hLineByPoint(localTargetVertex, localSourceVertex));
      }
      if (axis === "y") {
        images.push(vLineByPoint(localTargetVertex, localSourceVertex));
      }
      if (this.state.hasVerties) {
        images.push(point(localSourceVertex, 3, "vertex"));
        images.push(point(localTargetVertex, 3, "vertex"));
      }
      if (sourceVerties) {
        if (this.$selection.isOne && this.$editor.isPointerDown || this.$selection.isMany && !this.$editor.isPointerMove) {
          images.push(rect(this.$viewport.applyVerties(sourceVerties)));
        }
      }
      if (targetVerties) {
        images.push(rect(this.$viewport.applyVerties(targetVerties)));
      }
    }
    return [...images, ...texts].join("");
  }
  removeGuideLine() {
    this.setState({
      list: []
    });
  }
  setGuideLine(list2, hasVerties = false) {
    this.setState({
      list: list2,
      hasVerties
    });
  }
  [SUBSCRIBE("removeGuideLine", "refreshSelection")]() {
    this.removeGuideLine();
  }
  [SUBSCRIBE("refreshGuideLineByTarget")](targetVertiesList = []) {
    return this.refreshSmartGuides(targetVertiesList);
  }
  [SUBSCRIBE("updateViewport")]() {
    this.refresh();
  }
  refreshSmartGuides(targetVertiesList) {
    if (this.$selection.isEmpty)
      return;
    const sourceVerties = toRectVerties(this.$selection.verties);
    let targetList;
    if (targetVertiesList) {
      targetList = targetVertiesList.map((it) => toRectVerties(it));
    } else {
      const targets = this.$selection.snapTargetLayers.map((target) => {
        const rectVerties = toRectVerties(target.verties);
        return { targetVerties: rectVerties, dist: dist(rectVerties[4], sourceVerties[4]) };
      });
      targets.sort((a, b) => {
        return a.dist - b.dist;
      });
      targetList = targets.map((target) => target.targetVerties);
    }
    const xList = targetList.map((targetVerties) => makeGuidePoint(sourceVerties, targetVerties));
    xList.sort((a, b) => {
      return a[3] - b[3];
    });
    const list2 = [xList[0], xList[1]].filter(Boolean);
    this.setGuideLine(list2);
  }
  refreshSmartGuidesForVerties() {
    const guides = this.$snapManager.findGuide(this.$selection.verties);
    this.setGuideLine(guides, true);
  }
  [SUBSCRIBE("refreshSelectionStyleView")]() {
    if (this.$selection.isMany)
      return;
    const expect = this.$selection.hasChangedField("d", "clip-path");
    if (!expect && this.$selection.hasChangedField("x", "y", "width", "height", "transform", "transform-origin")) {
      this.refreshSmartGuidesForVerties();
    }
  }
}
function guideLineView(editor) {
  editor.registerMenuItem("canvas.view", {
    GuideLineView
  });
}
var SelectionInfoView$1 = "";
class SelectionInfoView extends EditorElement {
  initialize() {
    super.initialize();
    this.notEventRedefine = true;
  }
  template() {
    return /* @__PURE__ */ createElementJsx("div", {
      class: "elf--selection-info-view"
    });
  }
  [POINTERSTART("$el [data-artboard-title-id]") + LEFT_BUTTON + MOVE("calculateMovedElement") + END("calculateEndedElement")](e2) {
    this.startXY = e2.xy;
    this.initMousePoint = this.$viewport.getWorldPosition(e2);
    const id = e2.$dt.attr("data-artboard-title-id");
    this.$selection.select(id);
    if (e2.altKey) {
      this.$selection.selectAfterCopy();
      this.emit("refreshAllCanvas");
      this.emit("refreshLayerTreeView");
    }
    this.initializeDragSelection();
    this.emit("history.refreshSelection");
    this.$config.set("set.move.control.point", true);
  }
  initializeDragSelection() {
    this.$selection.reselect();
    this.$snapManager.clear();
    this.emit("refreshSelectionTool");
  }
  moveTo(dist2) {
    const snap = this.$snapManager.check(this.$selection.cachedRectVerties.map((v) => {
      return add$1([], v, dist2);
    }), 3);
    const localDist = add$1([], snap, dist2);
    const result = {};
    this.$selection.cachedItemMatrices.forEach((it) => {
      const newVerties = it.verties.map((v) => {
        return add$1([], v, localDist);
      });
      const newDist = subtract([], transformMat4([], newVerties[0], it.parentMatrixInverse), transformMat4([], it.verties[0], it.parentMatrixInverse));
      result[it.id] = {
        x: Math.floor(it.x + newDist[0]),
        y: Math.floor(it.y + newDist[1])
      };
    });
    this.$selection.reset(result);
  }
  calculateMovedElement() {
    const targetMousePoint = this.$viewport.getWorldPosition();
    const newDist = floor([], subtract([], targetMousePoint, this.initMousePoint));
    this.moveTo(newDist);
    this.emit("setAttributeForMulti", this.$selection.pack("x", "y"));
    this.emit("refreshSelectionStyleView");
    this.emit("refreshSelectionTool", false);
    this.refresh();
  }
  [SUBSCRIBE("refreshItemName")](id, title2) {
    var _a;
    this.emit("setAttributeForMulti", {
      [id]: { name: title2 }
    });
    (_a = this.$el.$(`[data-artboard-title-id='${id}']`)) == null ? void 0 : _a.text(title2);
  }
  calculateEndedElement(dx, dy) {
    this.command("setAttributeForMulti", "move item", this.$selection.pack("x", "y"));
    this.emit("refreshSelectionTool", true);
    this.$config.set("set.move.control.point", false);
  }
  [SUBSCRIBE("updateViewport")]() {
    this.refresh();
  }
  [SUBSCRIBE("refreshSelectionStyleView")]() {
    if (this.$selection.current) {
      if (this.$selection.current.is("artboard")) {
        if (this.$selection.hasChangedField("x", "y", "width", "height", "transform", "transform-origin")) {
          this.refresh();
        }
      }
    }
  }
  [LOAD("$el") + DOMDIFF]() {
    var _a;
    return (_a = this.$selection.currentProject) == null ? void 0 : _a.artboards.map((it) => {
      return { title: it.name, id: it.id, pointers: this.$viewport.applyVerties(it.verties) };
    }).map((it) => this.makeArtboardTitleArea(it));
  }
  createSize(pointers, artboardItem) {
    const newPointer = pointers[0];
    const diff = subtract([], pointers[0], pointers[3]);
    const angle2 = calculateAngle360(diff[0], diff[1]) - 90;
    return /* @__PURE__ */ createElementJsx("div", {
      class: "artboard-title is-not-drag-area",
      "data-artboard-title-id": artboardItem.id,
      style: {
        "transform-origin": "0% 0%",
        "transform": `translate3d( calc(${newPointer[0]}px), calc(${newPointer[1]}px), 0px) rotateZ(${angle2}deg)`
      }
    }, /* @__PURE__ */ createElementJsx("div", {
      style: "transform: translateY(-100%);"
    }, artboardItem.title));
  }
  makeArtboardTitleArea(it) {
    return this.createSize(it.pointers, it);
  }
  [SUBSCRIBE("refreshAll")]() {
    this.refresh();
  }
}
function selectionInfoView(editor) {
  editor.registerMenuItem("canvas.view", {
    SelectionInfoView
  });
}
var SelectionView = "";
var directionType$1 = {
  1: "to top left",
  2: "to top right",
  3: "to bottom right",
  4: "to bottom left",
  11: "to top",
  12: "to right",
  13: "to bottom",
  14: "to left"
};
const SelectionToolEvent$1 = class extends EditorElement {
  [SUBSCRIBE("refreshSelectionTool")](isShow = true) {
    this.initSelectionTool(isShow);
  }
  [SUBSCRIBE("updateViewport")]() {
    if (this.$selection.isOne && this.$modeView.isCurrentMode("CanvasView")) {
      this.initSelectionTool();
    }
  }
};
class SelectionToolView extends SelectionToolEvent$1 {
  template() {
    return `
            <div class='elf--selection-view one-selection-view' ref='$selectionView' style='display:none' >
                <div class='pointer-rect' ref='$pointerRect'></div>
            </div>
        `;
  }
  toggleEditingPath(isEditingPath) {
    this.$el.toggleClass("editing-path", isEditingPath);
  }
  [POINTERSTART("$pointerRect .rotate-pointer") + MOVE("rotateVertex") + END("rotateEndVertex")](e2) {
    this.state.moveType = "rotate";
    this.initMousePoint = this.$viewport.getWorldPosition(e2);
    this.$selection.reselect();
    this.verties = clone$1(this.$selection.verties);
    this.$snapManager.clear();
    this.rotateTargetNumber = +e2.$dt.attr("data-number");
    this.refreshRotatePointerIcon();
    this.state.dragging = true;
    this.state.isRotate = true;
    this.$config.set("set.move.control.point", true);
    this.initAngle = this.$selection.current.angle;
  }
  rotateVertex() {
    const targetMousePoint = this.$viewport.getWorldPosition();
    const distVector = subtract([], targetMousePoint, this.initMousePoint);
    const targetRotatePointer = this.rotateTargetNumber === 4 ? getRotatePointer(this.verties, 34) : this.verties[this.rotateTargetNumber];
    var distAngle = Math.floor(calculateAngleForVec3(targetRotatePointer, this.verties[4], distVector));
    const instance = this.$selection.current;
    let newAngle = this.initAngle + distAngle;
    if (instance) {
      if (this.$config.get("bodyEvent").shiftKey) {
        newAngle -= newAngle % this.$config.get("fixed.angle");
      }
      instance.angle = newAngle;
    }
    this.state.dragging = true;
    this.command("setAttributeForMulti", "change rotate", this.$selection.pack("angle"));
  }
  rotateEndVertex() {
    this.state.dragging = false;
    this.state.isRotate = false;
    this.emit("recoverCursor");
    this.$config.set("set.move.control.point", false);
    this.verties = null;
    this.nextTick(() => {
      this.command("setAttributeForMulti", "change rotate", this.$selection.pack("angle"));
    });
  }
  refreshRotatePointerIcon(e2) {
    this.emit("refreshCursor", "rotate");
  }
  refreshPointerIcon(e2) {
    const dataPointer = e2.$dt.data("pointer");
    if (dataPointer) {
      const pointer = dataPointer.split(",").map((it) => Number(it));
      const diff = subtract([], pointer, this.state.renderPointerList[0][4]);
      const angle2 = calculateAngle360(diff[0], diff[1]);
      let iconAngle = Math.floor(angle2);
      this.emit("refreshCursor", "open_in_full", `rotate(${iconAngle} 8 8)`);
    } else {
      this.emit("recoverCursor");
    }
  }
  checkPointerIsNotMoved(e2) {
    return Boolean(this.state.dragging) === false;
  }
  [POINTEROVER("$pointerRect .rotate-pointer") + IF("checkPointerIsNotMoved")](e2) {
    this.refreshRotatePointerIcon(e2);
  }
  [POINTEROVER("$pointerRect .pointer") + IF("checkPointerIsNotMoved")](e2) {
    this.refreshPointerIcon(e2);
  }
  [POINTEROUT("$pointerRect .pointer,.rotate-pointer") + IF("checkPointerIsNotMoved")](e2) {
    this.emit("recoverCursor");
  }
  [POINTERSTART("$pointerRect .pointer") + MOVE("moveVertex") + END("moveEndVertex")](e2) {
    this.refreshPointerIcon(e2);
    this.state.dragging = true;
    const num = +e2.$dt.attr("data-number");
    const direction = directionType$1[`${num}`];
    this.initMousePoint = this.$viewport.getWorldPosition(e2);
    this.state.moveType = direction;
    this.state.moveTarget = num;
    this.$selection.reselect();
    this.$snapManager.clear();
    this.verties = this.$selection.verties;
    this.hasRotate = this.$selection.current.angle !== 0;
    this.$config.set("set.move.control.point", true);
    this.$selection.startToCacheChildren();
  }
  calculateNewOffsetMatrixInverse(vertexOffset, width2, height2, origin2, itemMatrix) {
    const center2 = subtract([], TransformOrigin.scale(origin2, width2, height2), vertexOffset);
    return calculateMatrixInverse(fromTranslation([], vertexOffset), fromTranslation([], center2), itemMatrix, fromTranslation([], negate([], center2)));
  }
  calculateDistance(vertex, distVector, reverseMatrix) {
    const currentVertex = clone(vertex);
    const moveVertext = add$1([], currentVertex, distVector);
    const snap = this.$snapManager.check([
      moveVertext
    ]);
    const nextVertex = add$1([], moveVertext, snap);
    const [currentResult, nextResult] = vertiesMap([currentVertex, nextVertex], reverseMatrix);
    const realDist = subtract([], nextResult, currentResult);
    return realDist;
  }
  calculateRealDist(item2, vertexIndex, distVector) {
    return this.calculateDistance(item2.verties[vertexIndex], distVector, item2.absoluteMatrixInverse);
  }
  moveItem(instance, lastStartVertex, newWidth, newHeight, options2 = {}) {
    if (instance) {
      let data = {
        x: lastStartVertex[0] + (newWidth < 0 ? newWidth : 0),
        y: lastStartVertex[1] + (newHeight < 0 ? newHeight : 0),
        width: Math.abs(newWidth),
        height: Math.abs(newHeight)
      };
      if (this.hasRotate)
        ;
      else {
        data = objectFloor(data);
      }
      instance.reset(__spreadValues(__spreadValues({}, data), options2));
    }
  }
  moveDirectionVertex(item2, newWidth, newHeight, direction, directionNewVector, options2 = {}) {
    const view = calculateMatrix(item2.directionMatrix[direction], this.calculateNewOffsetMatrixInverse(directionNewVector, newWidth, newHeight, item2.originalTransformOrigin, item2.itemMatrix));
    const lastStartVertex = getTranslation([], view);
    this.moveItem(this.$model.get(item2.id), lastStartVertex, newWidth, newHeight, options2);
  }
  moveBottomRightVertex(distVector) {
    const { shiftKey, altKey, metaKey } = this.$config.get("bodyEvent");
    const item2 = this.$selection.cachedCurrentItemMatrix;
    if (item2) {
      let [realDx, realDy] = this.calculateRealDist(item2, 2, distVector);
      let directionNewVector = fromValues(0, 0, 0);
      if (altKey) {
        realDx = realDx * 2;
        realDy = realDy * 2;
      }
      if (shiftKey) {
        realDy = realDx * item2.height / item2.width;
      }
      const newWidth = item2.width + realDx;
      const newHeight = metaKey ? newWidth : item2.height + realDy;
      if (altKey) {
        directionNewVector = fromValues(realDx / 2, realDy / 2, 0);
      }
      this.moveDirectionVertex(item2, newWidth, newHeight, "to top left", directionNewVector, {
        resizingVertical: ResizingMode.FIXED,
        resizingHorizontal: ResizingMode.FIXED
      });
    }
  }
  moveTopRightVertex(distVector) {
    const { shiftKey, altKey, metaKey } = this.$config.get("bodyEvent");
    const item2 = this.$selection.cachedCurrentItemMatrix;
    if (item2) {
      let [realDx, realDy] = this.calculateRealDist(item2, 1, distVector);
      if (altKey) {
        realDx = realDx * 2;
        realDy = realDy * 2;
      }
      if (shiftKey) {
        realDy = -(realDx * item2.height / item2.width);
      }
      const newWidth = item2.width + realDx;
      const newHeight = metaKey ? newWidth : item2.height - realDy;
      let directionNewVector = fromValues(0, newHeight, 0);
      if (altKey) {
        directionNewVector = fromValues(realDx / 2, newHeight + realDy / 2, 0);
      }
      this.moveDirectionVertex(item2, newWidth, newHeight, "to bottom left", directionNewVector, {
        resizingVertical: ResizingMode.FIXED,
        resizingHorizontal: ResizingMode.FIXED
      });
    }
  }
  moveTopLeftVertex(distVector) {
    const { shiftKey, altKey, metaKey } = this.$config.get("bodyEvent");
    const item2 = this.$selection.cachedCurrentItemMatrix;
    if (item2) {
      let [realDx, realDy] = this.calculateRealDist(item2, 0, distVector);
      if (altKey) {
        realDx = realDx * 2;
        realDy = realDy * 2;
      }
      if (shiftKey) {
        realDy = realDx * item2.height / item2.width;
      }
      const newWidth = item2.width - realDx;
      const newHeight = metaKey ? newWidth : item2.height - realDy;
      let directionNewVector = fromValues(newWidth, newHeight, 0);
      if (altKey) {
        directionNewVector = fromValues(newWidth + realDx / 2, newHeight + realDy / 2, 0);
      }
      this.moveDirectionVertex(item2, newWidth, newHeight, "to bottom right", directionNewVector, {
        resizingHorizontal: ResizingMode.FIXED,
        resizingVertical: ResizingMode.FIXED
      });
    }
  }
  moveTopVertex(distVector) {
    const { altKey } = this.$config.get("bodyEvent");
    const item2 = this.$selection.cachedCurrentItemMatrix;
    if (item2) {
      let [realDx, realDy] = this.calculateRealDist(item2, 0, distVector);
      if (altKey) {
        realDy = realDy * 2;
      }
      const newWidth = item2.width;
      const newHeight = item2.height - realDy;
      let directionNewVector = fromValues(newWidth / 2, newHeight, 0);
      if (altKey) {
        directionNewVector = fromValues(newWidth / 2, newHeight + realDy / 2, 0);
      }
      this.moveDirectionVertex(item2, newWidth, newHeight, "to bottom", directionNewVector, {
        resizingVertical: ResizingMode.FIXED
      });
    }
  }
  moveBottomVertex(distVector) {
    const { altKey } = this.$config.get("bodyEvent");
    const item2 = this.$selection.cachedCurrentItemMatrix;
    if (item2) {
      let [realDx, realDy] = this.calculateRealDist(item2, 3, distVector);
      if (altKey) {
        realDy = realDy * 2;
      }
      const newWidth = item2.width;
      const newHeight = item2.height + realDy;
      let directionNewVector = fromValues(newWidth / 2, 0, 0);
      if (altKey) {
        directionNewVector = fromValues(newWidth / 2, realDy / 2, 0);
      }
      this.moveDirectionVertex(item2, newWidth, newHeight, "to top", directionNewVector, {
        resizingVertical: ResizingMode.FIXED
      });
    }
  }
  moveRightVertex(distVector) {
    const { altKey } = this.$config.get("bodyEvent");
    const item2 = this.$selection.cachedCurrentItemMatrix;
    if (item2) {
      let [realDx, realDy] = this.calculateRealDist(item2, 1, distVector);
      if (altKey) {
        realDx = realDx * 2;
      }
      const newWidth = item2.width + realDx;
      const newHeight = item2.height;
      let directionNewVector = fromValues(0, newHeight / 2, 0);
      if (altKey) {
        directionNewVector = fromValues(realDx / 2, newHeight / 2, 0);
      }
      this.moveDirectionVertex(item2, newWidth, newHeight, "to left", directionNewVector, {
        resizingHorizontal: ResizingMode.FIXED
      });
    }
  }
  moveLeftVertex(distVector) {
    const { altKey } = this.$config.get("bodyEvent");
    const item2 = this.$selection.cachedCurrentItemMatrix;
    if (item2) {
      let [realDx, realDy] = this.calculateRealDist(item2, 0, distVector);
      if (altKey) {
        realDx = realDx * 2;
      }
      const newWidth = item2.width - realDx;
      const newHeight = item2.height;
      let directionNewVector = fromValues(newWidth, newHeight / 2, 0);
      if (altKey) {
        directionNewVector = fromValues(newWidth + realDx / 2, newHeight / 2, 0);
      }
      this.moveDirectionVertex(item2, newWidth, newHeight, "to right", directionNewVector, {
        resizingHorizontal: ResizingMode.FIXED
      });
    }
  }
  moveBottomLeftVertex(distVector) {
    const { shiftKey, altKey, metaKey } = this.$config.get("bodyEvent");
    const item2 = this.$selection.cachedCurrentItemMatrix;
    if (item2) {
      let [realDx, realDy] = this.calculateRealDist(item2, 3, distVector);
      if (altKey) {
        realDx = realDx * 2;
        realDy = realDy * 2;
      }
      if (shiftKey) {
        realDy = -(realDx * item2.height / item2.width);
      }
      const newWidth = item2.width - realDx;
      const newHeight = metaKey ? newWidth : item2.height + realDy;
      let directionNewVector = fromValues(newWidth, 0, 0);
      if (altKey) {
        directionNewVector = fromValues(newWidth + realDx / 2, realDy / 2, 0);
      }
      this.moveDirectionVertex(item2, newWidth, newHeight, "to top right", directionNewVector, {
        resizingVertical: ResizingMode.FIXED,
        resizingHorizontal: ResizingMode.FIXED
      });
    }
  }
  moveVertex() {
    const targetMousePoint = this.$viewport.getWorldPosition();
    const distVector = subtract([], targetMousePoint, this.initMousePoint);
    if (this.state.moveType === "to top left") {
      this.moveTopLeftVertex(distVector);
    } else if (this.state.moveType === "to top") {
      this.moveTopVertex(distVector);
    } else if (this.state.moveType === "to right") {
      this.moveRightVertex(distVector);
    } else if (this.state.moveType === "to bottom") {
      this.moveBottomVertex(distVector);
    } else if (this.state.moveType === "to left") {
      this.moveLeftVertex(distVector);
    } else if (this.state.moveType === "to top right") {
      this.moveTopRightVertex(distVector);
    } else if (this.state.moveType === "to bottom right") {
      this.moveBottomRightVertex(distVector);
    } else if (this.state.moveType === "to bottom left") {
      this.moveBottomLeftVertex(distVector);
    }
    this.$selection.recoverChildren();
    this.emit("setAttributeForMulti", this.$selection.pack("x", "y", "width", "height", "resizingHorizontal", "resizingVertical"));
    this.state.dragging = true;
  }
  moveEndVertex() {
    this.state.dragging = false;
    this.emit("recoverCursor");
    this.$selection.reselect();
    this.$config.set("set.move.control.point", false);
    this.nextTick(() => {
      this.$selection.recoverChildren();
      this.command("setAttributeForMulti", "move selection pointer", this.$selection.pack("x", "y", "width", "height"));
      this.emit("recoverBooleanPath");
    });
  }
  show() {
    this.$el.show();
    this.state.show = true;
  }
  hide() {
    this.$el.hide();
    this.state.show = false;
  }
  initSelectionTool(isShow = true) {
    if (this.$el.isShow() && this.$selection.isOne === false) {
      this.hide();
    } else if (this.$el.isHide() && this.$selection.isOne) {
      this.show();
    }
    this.makeSelectionTool();
  }
  makeSelectionTool() {
    this.renderPointers();
  }
  renderPointers() {
    if (!this.$selection.cachedCurrentItemMatrix) {
      return;
    }
    if (this.$selection.isEmpty) {
      return;
    }
    const verties = this.$selection.verties;
    if (dist(verties[0], verties[1]) === 0) {
      return;
    }
    this.state.renderPointerList = [
      this.$viewport.applyVerties(verties)
    ];
    const pointers = this.createRenderPointers(this.state.renderPointerList[0]);
    if (pointers) {
      const { line: line2, parentRect, point: point2, size: size2, visiblePath } = pointers;
      this.refs.$pointerRect.updateDiff(line2 + parentRect + point2 + size2 + visiblePath);
    }
  }
  createPointer(pointer, number, rotate2) {
    return `
        <div class='pointer' data-number="${number}" data-pointer="${pointer}" style="transform: translate3d( calc(${pointer[0]}px - 50%), calc(${pointer[1]}px - 50%), 0px) rotateZ(${rotate2 || "0deg"})" ></div>
        `;
  }
  createPointerSide(pointer, number, rotate2, width2, height2) {
    return `
        <div class='pointer' data-number="${number}" data-pointer="${pointer}" style="width: ${width2}px; height: ${height2}px;transform: translate3d( calc(${pointer[0]}px - 50%), calc(${pointer[1]}px - 50%), 0px) rotateZ(${rotate2 || "0deg"})" ></div>
        `;
  }
  createRotatePointer(pointer, number, direction) {
    if (pointer.length === 0)
      return "";
    if (number < 4) {
      return `
            <div class='rotate-pointer no-fill' data-number="${number}" style="transform: translate3d( calc(${pointer[0]}px - 50%), calc(${pointer[1]}px - 50%), 0px) scale(1.8);" ></div>
            `;
    }
    return `
        <div class='rotate-pointer' data-number="${number}" style="transform: translate3d( calc(${pointer[0]}px - 50%), calc(${pointer[1]}px - 50%), 0px)" ></div>
        `;
  }
  createPointerRect(pointers, rotatePointer, parentVector) {
    if (pointers.length === 0)
      return "";
    const current = this.$selection.current;
    const isArtBoard = current && current.is("artboard");
    let line2 = "";
    if (!isArtBoard) {
      const centerPointer = lerp([], pointers[0], pointers[1], 0.5);
      line2 += `
                M ${centerPointer[0]},${centerPointer[1]} 
                L ${rotatePointer[0]},${rotatePointer[1]} 
            `;
    }
    return `
        <svg class='line' overflow="visible">
            <path 
                d="
                    M ${pointers[0][0]}, ${pointers[0][1]} 
                    L ${pointers[1][0]}, ${pointers[1][1]} 
                    L ${pointers[2][0]}, ${pointers[2][1]} 
                    L ${pointers[3][0]}, ${pointers[3][1]} 
                    L ${pointers[0][0]}, ${pointers[0][1]}
                    ${line2}
                    Z
                " />
        </svg>`;
  }
  createParentRect(pointers = []) {
    if (pointers.length === 0)
      return "";
    return `
        <svg class='line' overflow="visible">
            <path 
                d="
                    M ${pointers[0][0]}, ${pointers[0][1]} 
                    L ${pointers[1][0]}, ${pointers[1][1]} 
                    L ${pointers[2][0]}, ${pointers[2][1]} 
                    L ${pointers[3][0]}, ${pointers[3][1]} 
                    L ${pointers[0][0]}, ${pointers[0][1]}
                    Z
                " 
                stroke="red"
                />
        </svg>`;
  }
  createSize(pointers) {
    const top2 = lerp([], pointers[0], pointers[1], 0.5);
    const right2 = lerp([], pointers[1], pointers[2], 0.5);
    const bottom2 = lerp([], pointers[2], pointers[3], 0.5);
    const left2 = lerp([], pointers[3], pointers[0], 0.5);
    const list2 = [
      { start: top2, end: bottom2 },
      { start: right2, end: left2 },
      { start: bottom2, end: top2 },
      { start: left2, end: right2 }
    ].map((it, index2) => {
      return { index: index2, data: it };
    });
    list2.sort((a, b) => {
      return a.data.start[1] > b.data.start[1] ? -1 : 1;
    });
    const item2 = list2[0];
    const newPointer = lerp([], item2.data.end, item2.data.start, 1 + 16 / dist(item2.data.start, item2.data.end));
    const width2 = this.$selection.current.width;
    const height2 = this.$selection.current.height;
    const diff = subtract([], item2.data.start, item2.data.end);
    const angle2 = calculateAngle360(diff[0], diff[1]) + 90;
    const widthPx = round$1(width2, 100);
    const heightPx = round$1(height2, 100);
    let text2 = widthPx === heightPx ? `WH: ${widthPx}` : `${round$1(width2, 100)} x ${round$1(height2, 100)}`;
    if (this.state.isRotate) {
      const rotateZ2 = Transform.get(this.$selection.current.transform, "rotateZ");
      if (rotateZ2) {
        text2 = `${round$1(rotateZ2[0].value, 1e3)}\xB0`;
      }
    }
    return `
            <div 
                data-layout="${this.$selection.current.layout}"
                class='size-pointer' 
                style="transform: translate3d( calc(${newPointer[0]}px - 50%), calc(${newPointer[1]}px - 50%), 0px) rotateZ(${angle2}deg)" >
               ${text2}
            </div>
        `;
  }
  createVisiblePath() {
    const current = this.$selection.current;
    if (!current)
      return "";
    if (!current.isBooleanItem) {
      return "";
    }
    const newPath = current.absolutePath();
    newPath.transformMat4(this.$viewport.matrix);
    return `
        <svg class='line' overflow="visible">
            <path
                d="${newPath.d}"
                stroke="red"
                stroke-width="2"
                fill="none"
                />
        </svg>
        `;
  }
  removeNaN(value) {
    return value.replace(/NaN/g, "0");
  }
  createRenderPointers(pointers) {
    const current = this.$selection.current;
    if (current && current.is("text")) {
      if (current.width === 0 && current.height === 0) {
        return;
      }
    }
    const isArtBoard = current && current.is("artboard");
    const rotate2 = Length.deg(current.angle).round(1e3);
    const rotatePointer = getRotatePointer(pointers, 34);
    const dist$1 = dist(pointers[0], pointers[2]);
    const width2 = dist(pointers[0], pointers[1]);
    const height2 = dist(pointers[0], pointers[3]);
    return {
      line: this.createPointerRect(pointers, rotatePointer),
      size: this.createSize(pointers),
      parentRect: "",
      visiblePath: this.createVisiblePath(),
      point: [
        isArtBoard ? void 0 : this.createRotatePointer(rotatePointer, 4, "center center"),
        dist$1 < 20 ? void 0 : this.createPointerSide(lerp([], pointers[0], pointers[1], 0.5), 11, rotate2, width2, 5),
        dist$1 < 20 ? void 0 : this.createPointerSide(lerp([], pointers[1], pointers[2], 0.5), 12, rotate2, 5, height2),
        dist$1 < 20 ? void 0 : this.createPointerSide(lerp([], pointers[2], pointers[3], 0.5), 13, rotate2, width2, 5),
        dist$1 < 20 ? void 0 : this.createPointerSide(lerp([], pointers[3], pointers[0], 0.5), 14, rotate2, 5, height2),
        this.createPointer(pointers[0], 1, rotate2),
        this.createPointer(pointers[1], 2, rotate2),
        this.createPointer(pointers[2], 3, rotate2),
        this.createPointer(pointers[3], 4, rotate2),
        this.createPointer(pointers[4], 5, rotate2)
      ].join("")
    };
  }
  checkShow() {
    if (this.state.show && this.$selection.isOne) {
      if (this.$selection.hasChangedField("x", "y", "width", "height", "angle", "constraints-horizontal", "constraints-vertical", "resizingHorizontal", "resizingVertical", "transform-origin", "perspective", "perspective-origin")) {
        return true;
      }
    }
    return false;
  }
  [SUBSCRIBE("refreshSelectionStyleView") + IF("checkShow")]() {
    this.renderPointers();
  }
  [SUBSCRIBE("hideSelectionToolView")]() {
    this.hide();
  }
}
var directionType = {
  1: "to top left",
  2: "to top right",
  3: "to bottom right",
  4: "to bottom left",
  11: "to top",
  12: "to right",
  13: "to bottom",
  14: "to left"
};
const SelectionToolEvent = class extends EditorElement {
  [SUBSCRIBE("refreshSelectionTool")](isInitializeMatrix = true) {
    this.initSelectionTool(isInitializeMatrix);
  }
  [SUBSCRIBE("updateViewport")](isInitializeMatrix = true) {
    if (this.$selection.isMany) {
      this.initSelectionTool(isInitializeMatrix);
    }
  }
};
class GroupSelectionToolView extends SelectionToolEvent {
  template() {
    return `
            <div class='elf--selection-view group-selection-view' ref='$selectionView'  style='display:none' >
                <div class='pointer-rect' ref='$pointerRect'></div>        
            </div>
        `;
  }
  toggleEditingPath(isEditingPath) {
    this.refs.$selectionView.toggleClass("editing-path", isEditingPath);
  }
  [POINTERSTART("$pointerRect .rotate-pointer") + MOVE("rotateVertex") + END("rotateEndVertex")](e2) {
    this.state.moveType = "rotate";
    this.initMousePoint = this.$viewport.getWorldPosition(e2);
    this.verties = this.groupItem.verties;
    this.rotateTargetNumber = +e2.$dt.attr("data-number");
    this.refreshRotatePointerIcon();
    this.state.dragging = true;
    this.state.isRotate = true;
    this.$config.set("set.move.control.point", true);
  }
  rotateVertex() {
    const targetMousePoint = this.$viewport.getWorldPosition();
    const distVector = subtract([], targetMousePoint, this.initMousePoint);
    const targetRotatePointer = this.rotateTargetNumber === 4 ? getRotatePointer(this.verties, 34) : this.verties[this.rotateTargetNumber];
    var distAngle = Math.floor(calculateAngleForVec3(targetRotatePointer, this.verties[4], distVector));
    if (this.$config.get("bodyEvent").shiftKey) {
      distAngle = distAngle - distAngle % this.$config.get("fixed.angle");
    }
    this.localAngle = this.angle + distAngle;
    this.groupItem.reset({
      angle: this.localAngle
    });
    const selectionMatrix = calculateRotationOriginMat4(distAngle, this.verties[4]);
    let cachedItemMatrices = this.$selection.cachedItemMatrices;
    if (this.$selection.length === 1) {
      cachedItemMatrices = cachedItemMatrices.filter((it) => it.id === this.$selection.current.id);
    }
    cachedItemMatrices.forEach((item2) => {
      const newVerties = vertiesMap(item2.verties, multiply$1([], item2.parentMatrixInverse, selectionMatrix));
      const rotatePointer = getRotatePointer(newVerties, 34);
      var lastAngle = calculateAngle(rotatePointer[0] - newVerties[4][0], rotatePointer[1] - newVerties[4][1]) - 270;
      const newTranslate = transformMat4([], newVerties[0], calculateRotationOriginMat4(-lastAngle, newVerties[4]));
      const instance = this.$model.get(item2.id);
      if (instance) {
        instance.reset({
          x: newTranslate[0],
          y: newTranslate[1],
          angle: lastAngle
        });
      }
    });
    this.state.dragging = true;
    this.emit("setAttributeForMulti", this.$selection.pack("x", "y", "width", "height", "angle"));
  }
  rotateEndVertex() {
    this.state.dragging = false;
    this.state.isRotate = false;
    this.emit("recoverCursor");
    this.$config.set("set.move.control.point", false);
    this.$selection.reselect();
    this.initMatrix(true);
    this.nextTick(() => {
      this.command("setAttributeForMulti", "rotate selection pointer", this.$selection.pack("x", "y", "width", "height", "angle"));
    });
  }
  refreshRotatePointerIcon(e2) {
    this.emit("refreshCursor", "rotate");
  }
  refreshPointerIcon(e2) {
    const dataPointer = e2.$dt.data("pointer");
    if (dataPointer) {
      const pointer = dataPointer.split(",").map((it) => Number(it));
      const diff = subtract([], pointer, this.state.renderPointerList[0][4]);
      const angle2 = calculateAngle360(diff[0], diff[1]);
      let iconAngle = Math.floor(angle2);
      this.emit("refreshCursor", "open_in_full", `rotate(${iconAngle} 8 8)`);
    } else {
      this.emit("recoverCursor");
    }
  }
  checkPointerIsNotMoved(e2) {
    return Boolean(this.state.dragging) === false;
  }
  [POINTEROVER("$pointerRect .rotate-pointer") + IF("checkPointerIsNotMoved") + PREVENT](e2) {
    this.refreshRotatePointerIcon(e2);
  }
  [POINTEROVER("$pointerRect .pointer") + IF("checkPointerIsNotMoved") + PREVENT](e2) {
    this.refreshPointerIcon(e2);
  }
  [POINTEROUT("$pointerRect .pointer,.rotate-pointer") + IF("checkPointerIsNotMoved") + PREVENT](e2) {
    this.emit("recoverCursor");
  }
  [POINTERSTART("$pointerRect .pointer") + PREVENT + MOVE("moveVertex") + END("moveEndVertex")](e2) {
    this.refreshPointerIcon(e2);
    this.state.dragging = true;
    const num = +e2.$dt.attr("data-number");
    this.state.moveType = directionType[`${num}`];
    this.initMousePoint = this.$viewport.getWorldPosition(e2);
    this.$selection.reselect();
    this.initMatrix(true);
    this.cachedGroupItem = this.groupItem.matrix;
    this.$config.set("set.move.control.point", true);
    this.$selection.startToCacheChildren();
  }
  calculateNewOffsetMatrixInverse(vertextOffset, width2, height2, origin2, itemMatrix) {
    const center2 = add$1([], TransformOrigin.scale(origin2, width2, height2), negate([], vertextOffset));
    return calculateMatrixInverse(fromTranslation([], vertextOffset), fromTranslation([], center2), itemMatrix, fromTranslation([], negate([], center2)));
  }
  calculateDistance(vertext, distVector, reverseMatrix) {
    const currentVertex = clone(vertext);
    const snap = this.$snapManager.check([
      add$1([], currentVertex, distVector)
    ]);
    const nextVertex = add$1([], currentVertex, add$1([], distVector, snap));
    var currentResult = transformMat4([], currentVertex, reverseMatrix);
    var nextResult = transformMat4([], nextVertex, reverseMatrix);
    const realDist = floor([], add$1([], nextResult, negate([], currentResult)));
    return realDist;
  }
  calculateRealDist(item2, vertextIndex, distVector) {
    return this.calculateDistance(item2.verties[vertextIndex], distVector, item2.absoluteMatrixInverse);
  }
  moveGroupItem(lastStartVertex, newWidth, newHeight) {
    this.groupItem.reset({
      x: round$1(lastStartVertex[0] + (newWidth < 0 ? newWidth : 0), 1e3),
      y: round$1(lastStartVertex[1] + (newHeight < 0 ? newHeight : 0), 1e3),
      width: round$1(Math.abs(newWidth), 1e3),
      height: round$1(Math.abs(newHeight), 1e3)
    });
  }
  moveItemForGroup(it, newVerties, realDx = 0, realDy = 0) {
    const transformViewInverse = calculateMatrixInverse(fromTranslation([], newVerties[4]), it.itemMatrix, fromTranslation([], negate([], newVerties[4])));
    const [newX, newY] = transformMat4([], newVerties[0], transformViewInverse);
    const newWidth = distance$1(newVerties[0], newVerties[1]);
    const newHeight = distance$1(newVerties[0], newVerties[3]);
    const instance = this.$model.get(it.id);
    if (instance) {
      instance.reset({
        x: newX + realDx,
        y: newY + realDy,
        width: newWidth,
        height: newHeight
      });
    }
  }
  recoverItemForGroup(groupItem, scaleX, scaleY, realDx = 0, realDy = 0) {
    const absoluteMatrix = groupItem.absoluteMatrix;
    const absoluteMatrixInverse = groupItem.absoluteMatrixInverse;
    this.$selection.cachedItemMatrices.forEach((it) => {
      const localView = calculateMatrix(it.parentMatrixInverse, absoluteMatrix, fromTranslation([], [realDx, realDy, 0]), fromScaling([], [scaleX, scaleY, 1]), absoluteMatrixInverse);
      const newVerties = vertiesMap(it.verties, localView);
      this.moveItemForGroup(it, newVerties);
    });
  }
  moveBottomRightVertex(distVector) {
    const groupItem = this.cachedGroupItem;
    let [realDx, realDy] = this.calculateRealDist(groupItem, 2, distVector);
    if (this.$config.get("bodyEvent").shiftKey) {
      realDy = realDx * groupItem.height / groupItem.width;
    }
    const newWidth = groupItem.width + realDx;
    const newHeight = groupItem.height + realDy;
    this.moveDirectionVertex(groupItem, 0, 0, newWidth, newHeight, "to top left", [0, 0, 0]);
  }
  moveTopRightVertex(distVector) {
    const groupItem = this.cachedGroupItem;
    let [realDx, realDy] = this.calculateRealDist(groupItem, 1, distVector);
    if (this.$config.get("bodyEvent").shiftKey) {
      realDy = -(realDx * groupItem.height / groupItem.width);
    }
    const newWidth = groupItem.width + realDx;
    const newHeight = groupItem.height - realDy;
    this.moveDirectionVertex(groupItem, 0, realDy, newWidth, newHeight, "to bottom left", [0, newHeight, 0]);
  }
  moveDirectionVertex(groupItem, realDx, realDy, newWidth, newHeight, direction, directionNewVector) {
    const scaleX = newWidth / groupItem.width;
    const scaleY = newHeight / groupItem.height;
    if (scaleX >= 0 && scaleY >= 0) {
      const view = calculateMatrix(groupItem.directionMatrix[direction], this.calculateNewOffsetMatrixInverse(directionNewVector, newWidth, newHeight, groupItem.originalTransformOrigin, groupItem.itemMatrix));
      const lastStartVertex = getTranslation([], view);
      this.moveGroupItem(lastStartVertex, newWidth, newHeight);
      this.recoverItemForGroup(groupItem, scaleX, scaleY, realDx, realDy);
    }
  }
  moveTopVertex(distVector) {
    const groupItem = this.cachedGroupItem;
    const [realDx, realDy] = this.calculateRealDist(groupItem, 0, distVector);
    const newWidth = groupItem.width;
    const newHeight = groupItem.height - realDy;
    this.moveDirectionVertex(groupItem, 0, realDy, newWidth, newHeight, "to bottom", [newWidth / 2, newHeight, 0]);
  }
  moveBottomVertex(distVector) {
    const groupItem = this.cachedGroupItem;
    const [realDx, realDy] = this.calculateRealDist(groupItem, 2, distVector);
    const newWidth = groupItem.width;
    const newHeight = groupItem.height + realDy;
    this.moveDirectionVertex(groupItem, 0, 0, newWidth, newHeight, "to top", [newWidth / 2, 0, 0]);
  }
  moveTopLeftVertex(distVector) {
    const groupItem = this.cachedGroupItem;
    let [realDx, realDy] = this.calculateRealDist(groupItem, 0, distVector);
    if (this.$config.get("bodyEvent").shiftKey) {
      realDy = realDx * groupItem.height / groupItem.width;
    }
    const newWidth = groupItem.width - realDx;
    const newHeight = groupItem.height - realDy;
    this.moveDirectionVertex(groupItem, realDx, realDy, newWidth, newHeight, "to bottom right", [newWidth, newHeight, 0]);
  }
  moveLeftVertex(distVector) {
    const groupItem = this.cachedGroupItem;
    const [realDx, realDy] = this.calculateRealDist(groupItem, 0, distVector);
    const newWidth = groupItem.width - realDx;
    const newHeight = groupItem.height;
    this.moveDirectionVertex(groupItem, realDx, 0, newWidth, newHeight, "to right", [newWidth, newHeight / 2, 0]);
  }
  moveRightVertex(distVector) {
    const groupItem = this.cachedGroupItem;
    const [realDx, realDy] = this.calculateRealDist(groupItem, 2, distVector);
    const newWidth = groupItem.width + realDx;
    const newHeight = groupItem.height;
    this.moveDirectionVertex(groupItem, 0, 0, newWidth, newHeight, "to left", [0, newHeight / 2, 0]);
  }
  moveBottomLeftVertex(distVector) {
    const groupItem = this.cachedGroupItem;
    let [realDx, realDy] = this.calculateRealDist(groupItem, 3, distVector);
    if (this.$config.get("bodyEvent").shiftKey) {
      realDy = -(realDx * groupItem.height / groupItem.width);
    }
    const newWidth = groupItem.width - realDx;
    const newHeight = groupItem.height + realDy;
    this.moveDirectionVertex(groupItem, realDx, 0, newWidth, newHeight, "to top right", [newWidth, 0, 0]);
  }
  moveVertex() {
    const targetMousePoint = this.$viewport.getWorldPosition();
    const distVector = subtract([], targetMousePoint, this.initMousePoint);
    if (this.state.moveType === "to bottom right") {
      this.moveBottomRightVertex(distVector);
    } else if (this.state.moveType === "to top right") {
      this.moveTopRightVertex(distVector);
    } else if (this.state.moveType === "to top left") {
      this.moveTopLeftVertex(distVector);
    } else if (this.state.moveType === "to bottom left") {
      this.moveBottomLeftVertex(distVector);
    } else if (this.state.moveType === "to top") {
      this.moveTopVertex(distVector);
    } else if (this.state.moveType === "to left") {
      this.moveLeftVertex(distVector);
    } else if (this.state.moveType === "to right") {
      this.moveRightVertex(distVector);
    } else if (this.state.moveType === "to bottom") {
      this.moveBottomVertex(distVector);
    }
    this.emit("setAttributeForMulti", this.$selection.pack("x", "y", "width", "height"));
    this.state.dragging = true;
  }
  moveEndVertex(dx, dy) {
    this.state.dragging = false;
    this.emit("recoverCursor");
    this.$config.set("set.move.control.point", false);
    this.$selection.reselect();
    this.state.dragging = false;
    this.initMatrix(true);
    this.nextTick(() => {
      this.$selection.recoverChildren();
      this.command("setAttributeForMulti", "move selection pointer", this.$selection.pack("x", "y", "width", "height"));
      this.emit("recoverBooleanPath");
    });
  }
  show() {
    this.$el.show();
    this.state.show = true;
  }
  hide() {
    this.$el.hide();
    this.state.show = false;
  }
  initSelectionTool(isInitializeMatrix = false) {
    if (this.$el.isHide() && this.$selection.isMany) {
      this.show();
    } else {
      if (this.$el.isShow() && this.$selection.isMany === false)
        this.hide();
    }
    this.initMatrix(isInitializeMatrix);
    this.makeSelectionTool();
  }
  get item() {
    const verties = this.verties || rectToVerties(0, 0, 0, 0);
    if (!this.state.newArtBoard) {
      this.state.newArtBoard = this.$editor.createModel({ itemType: "artboard" }, false);
    }
    this.state.newArtBoard.reset({
      parentId: this.$selection.currentProject.id,
      x: verties[0][0],
      y: verties[0][1],
      width: dist(verties[0], verties[1]),
      height: dist(verties[0], verties[3])
    });
    return this.state.newArtBoard;
  }
  initMatrix(isInitializeMatrix = false) {
    if (isInitializeMatrix && this.$selection.isMany) {
      this.verties = clone$1(this.$selection.verties);
      this.angle = 0;
      this.localAngle = this.angle;
      this.groupItem = this.item;
      this.cachedGroupItem = this.item.matrix;
    }
  }
  makeSelectionTool() {
    this.renderPointers();
  }
  renderPointers() {
    if (!this.groupItem)
      return;
    const verties = this.state.dragging ? this.groupItem.verties : this.$selection.verties;
    if (verties.length === 0)
      return;
    this.state.renderPointerList = [
      this.$viewport.applyVerties(verties)
    ];
    const { line: line2, point: point2, size: size2, elementLine } = this.createRenderPointers(this.state.renderPointerList[0]);
    this.refs.$pointerRect.updateDiff(line2 + elementLine + point2 + size2);
  }
  createPointer(pointer, number, rotate2) {
    return `
        <div    
            class='pointer' 
            data-number="${number}" 
            data-pointer="${pointer}" 
            style="transform: translate3d( calc(${pointer[0]}px - 50%), calc(${pointer[1]}px - 50%), 0px) rotateZ(${rotate2 || "0deg"})" 
        ></div>
        `;
  }
  createPointerSide(pointer, number, rotate2, width2, height2) {
    return `
        <div class='pointer' data-number="${number}" data-pointer="${pointer}" style="width: ${width2}px; height: ${height2}px;transform: translate3d( calc(${pointer[0]}px - 50%), calc(${pointer[1]}px - 50%), 0px) rotateZ(${rotate2 || "0deg"})" ></div>
        `;
  }
  createRotatePointer(pointer, number, direction = "center center") {
    if (pointer.length === 0)
      return "";
    if (number < 4) {
      return `
            <div class='rotate-pointer no-fill' data-number="${number}" style="transform: translate3d( calc(${pointer[0]}px - 50%), calc(${pointer[1]}px - 50%), 0px) scale(1.8);" ></div>
            `;
    }
    return `
        <div class='rotate-pointer' data-number="${number}" style="transform: translate3d( calc(${pointer[0]}px - 50%), calc(${pointer[1]}px - 50%), 0px)" ></div>
        `;
  }
  createPointerRect(pointers, rotatePointer) {
    if (pointers.length === 0)
      return "";
    const centerPointer = lerp([], pointers[0], pointers[1], 0.5);
    const line2 = `
            M ${centerPointer[0]},${centerPointer[1]} 
            L ${rotatePointer[0]}, ${rotatePointer[1]} 
        `;
    return `
        <svg class='line' overflow="visible">
            <path 
                d="
                    M ${pointers[0][0]}, ${pointers[0][1]} 
                    L ${pointers[1][0]}, ${pointers[1][1]} 
                    L ${pointers[2][0]}, ${pointers[2][1]} 
                    L ${pointers[3][0]}, ${pointers[3][1]} 
                    L ${pointers[0][0]}, ${pointers[0][1]}
                    ${line2}
                    Z
                " />
        </svg>`;
  }
  createLine(pointers) {
    return `
            M ${pointers[0][0]}, ${pointers[0][1]} 
            L ${pointers[1][0]}, ${pointers[1][1]} 
            L ${pointers[2][0]}, ${pointers[2][1]} 
            L ${pointers[3][0]}, ${pointers[3][1]} 
            L ${pointers[0][0]}, ${pointers[0][1]}
            Z
        `;
  }
  createSize(pointers) {
    const top2 = lerp([], pointers[0], pointers[1], 0.5);
    const right2 = lerp([], pointers[1], pointers[2], 0.5);
    const bottom2 = lerp([], pointers[2], pointers[3], 0.5);
    const left2 = lerp([], pointers[3], pointers[0], 0.5);
    const list2 = [
      { start: top2, end: bottom2 },
      { start: right2, end: left2 },
      { start: bottom2, end: top2 },
      { start: left2, end: right2 }
    ].map((it, index2) => {
      return { index: index2, data: it };
    });
    list2.sort((a, b) => {
      return a.data.start[1] > b.data.start[1] ? -1 : 1;
    });
    const item2 = list2[0];
    const newPointer = lerp([], item2.data.end, item2.data.start, 1 + 16 / dist(item2.data.start, item2.data.end));
    const width2 = this.groupItem.width;
    const height2 = this.groupItem.height;
    const diff = subtract([], item2.data.start, item2.data.end);
    const angle2 = calculateAngle360(diff[0], diff[1]) + 90;
    let text2 = `${round$1(width2, 100)} x ${round$1(height2, 100)}`;
    if (this.state.isRotate) {
      const rotateZ2 = this.groupItem.angle;
      if (rotateZ2) {
        text2 = `${rotateZ2[0].value}\xB0`;
      }
    }
    return `
            <div 
                class='size-pointer' 
                style="transform: translate3d( calc(${newPointer[0]}px - 50%), calc(${newPointer[1]}px - 50%), 0px) rotateZ(${angle2}deg)" >
               ${text2}
            </div>
        `;
  }
  createRenderPointers(pointers) {
    const diff = subtract([], lerp([], pointers[0], pointers[1], 0.5), lerp([], pointers[0], pointers[2], 0.5));
    const rotate2 = Length.deg(calculateAngle360(diff[0], diff[1]) - 90).round(1e3);
    const rotatePointer = getRotatePointer(pointers, 30);
    const dist$1 = dist(pointers[0], pointers[2]);
    const width2 = dist(pointers[0], pointers[1]);
    const height2 = dist(pointers[0], pointers[3]);
    return {
      line: this.createPointerRect(pointers, rotatePointer),
      elementLine: `
                <svg class='line' overflow="visible">
                    <path 
                        d="${this.$selection.items.map((it, index2) => {
        return this.createLine(this.$viewport.applyVerties(it.originVerties));
      }).join("")}
                        " />
                </svg>
            `,
      size: this.createSize(pointers),
      point: [
        this.createRotatePointer(rotatePointer, 4, "center center"),
        dist$1 < 20 ? void 0 : this.createPointerSide(lerp([], pointers[0], pointers[1], 0.5), 11, rotate2, width2, 5),
        dist$1 < 20 ? void 0 : this.createPointerSide(lerp([], pointers[1], pointers[2], 0.5), 12, rotate2, 5, height2),
        dist$1 < 20 ? void 0 : this.createPointerSide(lerp([], pointers[2], pointers[3], 0.5), 13, rotate2, width2, 5),
        dist$1 < 20 ? void 0 : this.createPointerSide(lerp([], pointers[3], pointers[0], 0.5), 14, rotate2, 5, height2),
        this.createPointer(pointers[0], 1, rotate2),
        this.createPointer(pointers[1], 2, rotate2),
        this.createPointer(pointers[2], 3, rotate2),
        this.createPointer(pointers[3], 4, rotate2)
      ].join("")
    };
  }
  checkShow() {
    if (this.state.show && this.$selection.isMany) {
      if (this.$selection.hasChangedField("x", "y", "width", "height", "transform", "transform-origin", "perspective", "perspective-origin")) {
        return true;
      }
    }
    return false;
  }
  [SUBSCRIBE("refreshSelectionStyleView") + IF("checkShow")]() {
    this.renderPointers();
  }
  [SUBSCRIBE("hideSelectionToolView")]() {
    this.hide();
  }
}
function selectionToolView(editor) {
  editor.registerMenuItem("canvas.view", {
    SelectionToolView,
    GroupSelectionToolView
  });
}
function defaultIcons(editor) {
  editor.registerIcon("artboard", "artboard");
  editor.registerIcon("circle", "lens");
  editor.registerIcon("image", "image");
  editor.registerIcon("text", "title");
  editor.registerIcon("svg-text", "title");
  editor.registerIcon("boolean-path", "pentool");
  editor.registerIcon("svg-path", "pentool");
  editor.registerIcon("polygon", "polygon");
  editor.registerIcon("star", "star");
  editor.registerIcon("spline", "smooth");
  editor.registerIcon("rect", "rect");
}
var designEditorPlugins = [
  defaultConfigs,
  defaultIcons,
  defaultMessages,
  defaultItems,
  defaultPatterns,
  rendererHtml,
  rendererJson,
  rendererSvg,
  baseEditor,
  propertyEditor,
  color,
  gradient,
  depth,
  alignment,
  position,
  layout,
  boxModel,
  pathTool,
  artboard,
  svgText,
  font,
  text$1,
  textShadow,
  content,
  appearance,
  component,
  backgroundImage,
  patternAsset,
  border,
  borderRadius,
  video,
  image,
  perspective,
  perspectiveOrigin,
  svgFilterAsset,
  svgItem,
  layerTree,
  backgroundClip,
  borderImage,
  filter,
  backdropFilter,
  boxShadow,
  clipPath,
  gradientAsset,
  exportResource,
  transition,
  keyframe,
  animation,
  selector,
  codeview,
  history,
  project,
  selectionToolView,
  selectionInfoView,
  guideLineView,
  layerAppendView,
  hoverView,
  pathDrawView,
  pathEditorView
];
var ObjectItems$1 = "";
class ObjectItems extends EditorElement {
  template() {
    return `
        <div class="object-items">
          <div>
            ${createComponent("ProjectProperty")}
          </div>
          <div>
            ${createComponent("LayerTreeProperty")}
          </div>
        </div>
    `;
  }
}
var CustomAssets$1 = "";
class CustomAssets extends EditorElement {
  template() {
    return `
      <div class='elf--custom-assets'>
        <div class='custom-assets-tools'>
          <div class='title'><label>Custom Assets</label></div>
          <div class='tools'>
            <button type="button" ref='$addCustomAsset'>${iconUse$1("add")}</button>
          </div>
        </div>
        <div class='elf--asset-list' ref='$list'></div>
      </div>
    `;
  }
  async [LOAD("$list")]() {
    const data = await this.$storageManager.getCustomAssetList();
    return data.map((it) => {
      return `
        <div class='asset-preview' draggable="true" data-preview-id="${it.id}">
          <div class='thumbnail'><img src='${it.preview}' /></div>
          <div class='tools'>
            <div class='title'>${it.component.name}</div>
            <div class='buttons'>
              <button type="button" class='remove-asset-preview' title="remove asset" data-preview-id="${it.id}">${iconUse$1("remove")}</button>
            </div>
          </div>
        </div>
      `;
    });
  }
  async [CLICK("$list .remove-asset-preview")](e2) {
    if (confirm(this.$i18n("app.confirm.message.artboard.items.removeCustomAsset"))) {
      const id = e2.$dt.data("preview-id");
      await this.$storageManager.removeCustomAsset(id);
      this.refresh();
    }
  }
  [DRAGSTART("$list .asset-preview")](e2) {
    const id = e2.$dt.data("preview-id");
    e2.dataTransfer.effectAllowed = "copy";
    e2.dataTransfer.setData("text/asset", id);
  }
  [CLICK("$addCustomAsset")](e2) {
    this.emit("savePNG", async (datauri) => {
      await this.$storageManager.saveCustomAsset(datauri);
      this.refresh();
    });
  }
}
var LibraryItems$1 = "";
class LibraryItems extends EditorElement {
  template() {
    return `
      <div class='elf--library-items'>
        <div>
          ${createComponent("TextEditor", {
      label: "Search",
      key: "search",
      onchange: this.subscribe((key, value) => {
        this.broadcast("search", value);
      }, 300)
    })}
        </div>
        ${this.$injectManager.generate("library")}
      </div>
    `;
  }
}
class AssetItems extends EditorElement {
  template() {
    return `
      <div class='asset-items'>
        ${this.$injectManager.generate("asset")}
      </div>
    `;
  }
}
class LayerTab extends EditorElement {
  components() {
    return {
      AssetItems,
      LibraryItems,
      CustomAssets,
      ObjectItems
    };
  }
  initState() {
    return {
      selectedIndexValue: 2
    };
  }
  afterRender() {
    this.$el.toggle(this.$config.get("editor.design.mode") === "design");
  }
  [BIND("$el")]() {
    return {
      style: {
        display: this.$config.get("editor.design.mode") === "design" ? "block" : "none"
      }
    };
  }
  template() {
    return `
      <div class='layer-tab'>
        <div class="tab number-tab side-tab side-tab-left" data-selected-value="2" ref="$tab">
          <div class="tab-header" ref="$header">   
            <div class="tab-item selected" data-value="2" data-direction="right" data-tooltip="${this.$i18n("app.tab.title.layers")}">
              <label>${iconUse$1("layers")}</label>
            </div>            
            <div class='tab-item' data-value='3' data-direction="right"  data-tooltip="${this.$i18n("app.tab.title.libraries")}">
              <label>${iconUse$1("auto_awesome")}</label>
            </div>                     
            <div class='tab-item' data-value='5' data-direction="right"  data-tooltip="${this.$i18n("app.tab.title.assets")}">
              <label>${iconUse$1("apps")}</label>
            </div>   
            <div class='tab-item' data-value='6' data-direction="right"  data-tooltip="${this.$i18n("app.tab.title.components")}">
              <label>${iconUse$1("plugin")}</label>
            </div>            

            ${this.$injectManager.getTargetMenuItems("leftbar.tab").map((it) => {
      const { value, title: title2 } = it.class;
      let iconString = it.class.icon;
      if (obj[it.class.icon]) {
        iconString = iconUse$1(it.class.icon);
      }
      return `
                <div class='tab-item' data-value='${value}' data-direction="right"  data-tooltip="${title2}">
                  <label>${iconString || title2}</label>
                </div>
              `;
    })}

          </div>
          <div class="tab-body" ref="$body">
            <div class="tab-content selected" data-value="2">
              ${createComponent("ObjectItems")}
            </div>
            <div class='tab-content' data-value='3'>
              ${createComponent("LibraryItems")}
            </div>            
            <div class='tab-content' data-value='5'>
              ${createComponent("AssetItems")}            
              <div class='assets'>
                ${createComponent("GradientAssetsProperty")}
                ${createComponent("PatternAssetsProperty")}
                ${createComponent("ImageAssetsProperty")}
                ${createComponent("VideoAssetsProperty")}
                ${""}
              </div>
            </div>
            <div class='tab-content' data-value='6'>
              ${createComponent("CustomAssets")}
            </div>
            ${this.$injectManager.getTargetMenuItems("leftbar.tab").map((it) => {
      const { value } = it.class;
      return `
                <div class='tab-content' data-value='${value}'>
                  ${this.$injectManager.generate(`leftbar.tab.${value}`)}
                </div>
              `;
    })}
          </div>
        </div>
      </div>
    `;
  }
  [CLICK("$header .tab-item:not(.extra-item)")](e2) {
    var selectedIndexValue = e2.$dt.attr("data-value");
    if (this.state.selectedIndexValue === selectedIndexValue) {
      return;
    }
    this.$el.$$(`[data-value="${this.state.selectedIndexValue}"]`).forEach((it) => it.removeClass("selected"));
    this.$el.$$(`[data-value="${selectedIndexValue}"]`).forEach((it) => it.addClass("selected"));
    this.setState({ selectedIndexValue }, false);
  }
}
class IconManager extends EditorElement {
  template() {
    return `
      <svg viewBox="0 0 30 10" xmlns="http://www.w3.org/2000/svg" ref="$list" style="display:none;">
      </svg>
    `;
  }
  [LOAD("$list")]() {
    return Object.entries(obj).map(([key, value]) => {
      if (isString(value) === false)
        return "";
      return value.replace(/\<svg/g, `<svg id="icon-${key}"`);
    });
  }
}
var pathkit = { exports: {} };
var __viteBrowserExternal = {};
var __viteBrowserExternal$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": __viteBrowserExternal
});
var require$$0 = /* @__PURE__ */ getAugmentedNamespace(__viteBrowserExternal$1);
(function(module, exports) {
  var PathKitInit2 = function() {
    var _scriptDir = typeof document !== "undefined" && document.currentScript ? document.currentScript.src : void 0;
    if (typeof __filename !== "undefined")
      _scriptDir = _scriptDir || __filename;
    return function(PathKitInit3) {
      PathKitInit3 = PathKitInit3 || {};
      var d;
      d || (d = typeof PathKitInit3 !== "undefined" ? PathKitInit3 : {});
      var aa;
      d.ready = new Promise(function(a) {
        aa = a;
      });
      (function(a) {
        var b = {};
        a.loadCmdsTypedArray = function(h) {
          for (var k = 0, l = 0; l < h.length; l++)
            k += h[l].length;
          if (b[k])
            var n = b[k];
          else
            n = new Float32Array(k), b[k] = n;
          var p = 0;
          for (l = 0; l < h.length; l++)
            for (var q = 0; q < h[l].length; q++) {
              var t = h[l][q];
              typeof t === "string" && (t = a.SkBits2FloatUnsigned(parseInt(t)));
              n[p] = t;
              p++;
            }
          h = a._malloc(n.length * n.BYTES_PER_ELEMENT);
          a.HEAPF32.set(n, h / n.BYTES_PER_ELEMENT);
          return [h, k];
        };
        a.FromCmds = function(h) {
          h = a.loadCmdsTypedArray(h);
          var k = a._FromCmds(h[0], h[1]);
          a._free(h[0]);
          return k;
        };
        var c2, e2, f, g, m;
        a.cubicYFromX = function(h, k, l, n, p) {
          c2 && e2 === h && f === k && g === l && m === n || (c2 && c2.delete(), c2 = new a._SkCubicMap([h, k], [l, n]), e2 = h, f = k, g = l, m = n);
          return c2.computeYFromX(p);
        };
        a.cubicPtFromT = function(h, k, l, n, p) {
          c2 && e2 === h && f === k && g === l && m === n || (c2 && c2.delete(), c2 = new a._SkCubicMap([h, k], [l, n]), e2 = h, f = k, g = l, m = n);
          return c2.computePtFromT(p);
        };
      })(d);
      (function(a) {
        a.onRuntimeInitialized = function() {
          a.SkPath.prototype.addPath = function() {
            var b = arguments[0];
            if (arguments.length === 1)
              this._addPath(b, 1, 0, 0, 0, 1, 0, 0, 0, 1);
            else if (arguments.length === 2) {
              var c2 = arguments[1];
              this._addPath(b, c2.a, c2.c, c2.e, c2.b, c2.d, c2.f, 0, 0, 1);
            } else if (arguments.length === 7)
              c2 = arguments, this._addPath(b, c2[1], c2[3], c2[5], c2[2], c2[4], c2[6], 0, 0, 1);
            else if (arguments.length === 10)
              c2 = arguments, this._addPath(b, c2[1], c2[2], c2[3], c2[4], c2[5], c2[6], c2[7], c2[8], c2[9]);
            else
              return console.Fb("addPath expected to take 1, 2, 7, or 10 args. Got " + arguments.length), null;
            return this;
          };
          a.SkPath.prototype.arc = function(b, c2, e2, f, g, m) {
            this._arc(b, c2, e2, f, g, !!m);
            return this;
          };
          a.SkPath.prototype.arcTo = function(b, c2, e2, f, g) {
            this._arcTo(b, c2, e2, f, g);
            return this;
          };
          a.SkPath.prototype.bezierCurveTo = function(b, c2, e2, f, g, m) {
            this._cubicTo(b, c2, e2, f, g, m);
            return this;
          };
          a.SkPath.prototype.close = function() {
            this._close();
            return this;
          };
          a.SkPath.prototype.closePath = function() {
            this._close();
            return this;
          };
          a.SkPath.prototype.conicTo = function(b, c2, e2, f, g) {
            this._conicTo(b, c2, e2, f, g);
            return this;
          };
          a.SkPath.prototype.cubicTo = function(b, c2, e2, f, g, m) {
            this._cubicTo(b, c2, e2, f, g, m);
            return this;
          };
          a.SkPath.prototype.dash = function(b, c2, e2) {
            return this._dash(b, c2, e2) ? this : null;
          };
          a.SkPath.prototype.ellipse = function(b, c2, e2, f, g, m, h, k) {
            this._ellipse(b, c2, e2, f, g, m, h, !!k);
            return this;
          };
          a.SkPath.prototype.lineTo = function(b, c2) {
            this._lineTo(b, c2);
            return this;
          };
          a.SkPath.prototype.moveTo = function(b, c2) {
            this._moveTo(b, c2);
            return this;
          };
          a.SkPath.prototype.op = function(b, c2) {
            return this._op(b, c2) ? this : null;
          };
          a.SkPath.prototype.quadraticCurveTo = function(b, c2, e2, f) {
            this._quadTo(b, c2, e2, f);
            return this;
          };
          a.SkPath.prototype.quadTo = function(b, c2, e2, f) {
            this._quadTo(b, c2, e2, f);
            return this;
          };
          a.SkPath.prototype.rect = function(b, c2, e2, f) {
            this._rect(b, c2, e2, f);
            return this;
          };
          a.SkPath.prototype.simplify = function() {
            return this._simplify() ? this : null;
          };
          a.SkPath.prototype.stroke = function(b) {
            b = b || {};
            b.width = b.width || 1;
            b.miter_limit = b.miter_limit || 4;
            b.cap = b.cap || a.StrokeCap.BUTT;
            b.join = b.join || a.StrokeJoin.MITER;
            return this._stroke(b) ? this : null;
          };
          a.SkPath.prototype.transform = function() {
            if (arguments.length === 1)
              this._transform(arguments[0]);
            else if (arguments.length === 9) {
              var b = arguments;
              this._transform(b[0], b[1], b[2], b[3], b[4], b[5], b[6], b[7], b[8]);
            } else
              return console.Fb("transform expected to take 1 or 9 arguments. Got " + arguments.length), null;
            return this;
          };
          a.SkPath.prototype.trim = function(b, c2, e2) {
            return this._trim(b, c2, !!e2) ? this : null;
          };
        };
      })(d);
      var r = {}, v;
      for (v in d)
        d.hasOwnProperty(v) && (r[v] = d[v]);
      var ba = false, w = false, ca = false, da = false;
      ba = typeof window === "object";
      w = typeof importScripts === "function";
      ca = typeof process === "object" && typeof process.versions === "object" && typeof process.versions.node === "string";
      da = !ba && !ca && !w;
      var x2 = "", ea, fa, ha, ia;
      if (ca)
        x2 = w ? require$$0.dirname(x2) + "/" : __dirname + "/", ea = function(a, b) {
          ha || (ha = require$$0);
          ia || (ia = require$$0);
          a = ia.normalize(a);
          return ha.readFileSync(a, b ? null : "utf8");
        }, fa = function(a) {
          a = ea(a, true);
          a.buffer || (a = new Uint8Array(a));
          assert(a.buffer);
          return a;
        }, 1 < process.argv.length && process.argv[1].replace(/\\/g, "/"), process.argv.slice(2), process.on("uncaughtException", function(a) {
          throw a;
        }), process.on("unhandledRejection", y2), d.inspect = function() {
          return "[Emscripten Module object]";
        };
      else if (da)
        typeof read != "undefined" && (ea = function(a) {
          return read(a);
        }), fa = function(a) {
          if (typeof readbuffer === "function")
            return new Uint8Array(readbuffer(a));
          a = read(a, "binary");
          assert(typeof a === "object");
          return a;
        }, typeof print !== "undefined" && (typeof console === "undefined" && (console = {}), console.log = print, console.warn = console.error = typeof printErr !== "undefined" ? printErr : print);
      else if (ba || w)
        w ? x2 = self.location.href : document.currentScript && (x2 = document.currentScript.src), _scriptDir && (x2 = _scriptDir), x2.indexOf("blob:") !== 0 ? x2 = x2.substr(0, x2.lastIndexOf("/") + 1) : x2 = "", ea = function(a) {
          var b = new XMLHttpRequest();
          b.open("GET", a, false);
          b.send(null);
          return b.responseText;
        }, w && (fa = function(a) {
          var b = new XMLHttpRequest();
          b.open("GET", a, false);
          b.responseType = "arraybuffer";
          b.send(null);
          return new Uint8Array(b.response);
        });
      var ja = d.print || console.log.bind(console), z = d.printErr || console.warn.bind(console);
      for (v in r)
        r.hasOwnProperty(v) && (d[v] = r[v]);
      r = null;
      var ka;
      d.wasmBinary && (ka = d.wasmBinary);
      d.noExitRuntime && d.noExitRuntime;
      typeof WebAssembly !== "object" && z("no native wasm support detected");
      var la, ma = new WebAssembly.Table({ initial: 309, maximum: 309, element: "anyfunc" }), na = false;
      function assert(a, b) {
        a || y2("Assertion failed: " + b);
      }
      var oa = typeof TextDecoder !== "undefined" ? new TextDecoder("utf8") : void 0;
      function pa(a, b, c2) {
        var e2 = b + c2;
        for (c2 = b; a[c2] && !(c2 >= e2); )
          ++c2;
        if (16 < c2 - b && a.subarray && oa)
          return oa.decode(a.subarray(b, c2));
        for (e2 = ""; b < c2; ) {
          var f = a[b++];
          if (f & 128) {
            var g = a[b++] & 63;
            if ((f & 224) == 192)
              e2 += String.fromCharCode((f & 31) << 6 | g);
            else {
              var m = a[b++] & 63;
              f = (f & 240) == 224 ? (f & 15) << 12 | g << 6 | m : (f & 7) << 18 | g << 12 | m << 6 | a[b++] & 63;
              65536 > f ? e2 += String.fromCharCode(f) : (f -= 65536, e2 += String.fromCharCode(55296 | f >> 10, 56320 | f & 1023));
            }
          } else
            e2 += String.fromCharCode(f);
        }
        return e2;
      }
      function qa(a, b, c2) {
        var e2 = B;
        if (0 < c2) {
          c2 = b + c2 - 1;
          for (var f = 0; f < a.length; ++f) {
            var g = a.charCodeAt(f);
            if (55296 <= g && 57343 >= g) {
              var m = a.charCodeAt(++f);
              g = 65536 + ((g & 1023) << 10) | m & 1023;
            }
            if (127 >= g) {
              if (b >= c2)
                break;
              e2[b++] = g;
            } else {
              if (2047 >= g) {
                if (b + 1 >= c2)
                  break;
                e2[b++] = 192 | g >> 6;
              } else {
                if (65535 >= g) {
                  if (b + 2 >= c2)
                    break;
                  e2[b++] = 224 | g >> 12;
                } else {
                  if (b + 3 >= c2)
                    break;
                  e2[b++] = 240 | g >> 18;
                  e2[b++] = 128 | g >> 12 & 63;
                }
                e2[b++] = 128 | g >> 6 & 63;
              }
              e2[b++] = 128 | g & 63;
            }
          }
          e2[b] = 0;
        }
      }
      var ra = typeof TextDecoder !== "undefined" ? new TextDecoder("utf-16le") : void 0;
      function sa(a, b) {
        var c2 = a >> 1;
        for (var e2 = c2 + b / 2; !(c2 >= e2) && ta[c2]; )
          ++c2;
        c2 <<= 1;
        if (32 < c2 - a && ra)
          return ra.decode(B.subarray(a, c2));
        c2 = 0;
        for (e2 = ""; ; ) {
          var f = D[a + 2 * c2 >> 1];
          if (f == 0 || c2 == b / 2)
            return e2;
          ++c2;
          e2 += String.fromCharCode(f);
        }
      }
      function ua(a, b, c2) {
        c2 === void 0 && (c2 = 2147483647);
        if (2 > c2)
          return 0;
        c2 -= 2;
        var e2 = b;
        c2 = c2 < 2 * a.length ? c2 / 2 : a.length;
        for (var f = 0; f < c2; ++f)
          D[b >> 1] = a.charCodeAt(f), b += 2;
        D[b >> 1] = 0;
        return b - e2;
      }
      function va(a) {
        return 2 * a.length;
      }
      function wa(a, b) {
        for (var c2 = 0, e2 = ""; !(c2 >= b / 4); ) {
          var f = E[a + 4 * c2 >> 2];
          if (f == 0)
            break;
          ++c2;
          65536 <= f ? (f -= 65536, e2 += String.fromCharCode(55296 | f >> 10, 56320 | f & 1023)) : e2 += String.fromCharCode(f);
        }
        return e2;
      }
      function xa(a, b, c2) {
        c2 === void 0 && (c2 = 2147483647);
        if (4 > c2)
          return 0;
        var e2 = b;
        c2 = e2 + c2 - 4;
        for (var f = 0; f < a.length; ++f) {
          var g = a.charCodeAt(f);
          if (55296 <= g && 57343 >= g) {
            var m = a.charCodeAt(++f);
            g = 65536 + ((g & 1023) << 10) | m & 1023;
          }
          E[b >> 2] = g;
          b += 4;
          if (b + 4 > c2)
            break;
        }
        E[b >> 2] = 0;
        return b - e2;
      }
      function ya(a) {
        for (var b = 0, c2 = 0; c2 < a.length; ++c2) {
          var e2 = a.charCodeAt(c2);
          55296 <= e2 && 57343 >= e2 && ++c2;
          b += 4;
        }
        return b;
      }
      var za, Aa, B, D, ta, E, F, Ba, Ca, Da = d.INITIAL_MEMORY || 16777216;
      d.wasmMemory ? la = d.wasmMemory : la = new WebAssembly.Memory({ initial: Da / 65536, maximum: Da / 65536 });
      la && (za = la.buffer);
      Da = za.byteLength;
      var G = za;
      za = G;
      d.HEAP8 = Aa = new Int8Array(G);
      d.HEAP16 = D = new Int16Array(G);
      d.HEAP32 = E = new Int32Array(G);
      d.HEAPU8 = B = new Uint8Array(G);
      d.HEAPU16 = ta = new Uint16Array(G);
      d.HEAPU32 = F = new Uint32Array(G);
      d.HEAPF32 = Ba = new Float32Array(G);
      d.HEAPF64 = Ca = new Float64Array(G);
      E[3e3] = 5255040;
      function Ea(a) {
        for (; 0 < a.length; ) {
          var b = a.shift();
          if (typeof b == "function")
            b(d);
          else {
            var c2 = b.Jb;
            typeof c2 === "number" ? b.tb === void 0 ? d.dynCall_v(c2) : d.dynCall_vi(c2, b.tb) : c2(b.tb === void 0 ? null : b.tb);
          }
        }
      }
      var Fa = [], Ga = [], Ha = [], Ia = [];
      function Ja() {
        var a = d.preRun.shift();
        Fa.unshift(a);
      }
      var H = 0, La = null;
      d.preloadedImages = {};
      d.preloadedAudios = {};
      function y2(a) {
        if (d.onAbort)
          d.onAbort(a);
        ja(a);
        z(a);
        na = true;
        throw new WebAssembly.RuntimeError("abort(" + a + "). Build with -s ASSERTIONS=1 for more info.");
      }
      function Ma(a) {
        var b = I;
        return String.prototype.startsWith ? b.startsWith(a) : b.indexOf(a) === 0;
      }
      function Na() {
        return Ma("data:application/octet-stream;base64,");
      }
      var I = "pathkit.wasm";
      if (!Na()) {
        var Oa = I;
        I = d.locateFile ? d.locateFile(Oa, x2) : x2 + Oa;
      }
      function Pa() {
        try {
          if (ka)
            return new Uint8Array(ka);
          if (fa)
            return fa(I);
          throw "both async and sync fetching of the wasm failed";
        } catch (a) {
          y2(a);
        }
      }
      function Qa() {
        return ka || !ba && !w || typeof fetch !== "function" || Ma("file://") ? new Promise(function(a) {
          a(Pa());
        }) : fetch(I, { credentials: "same-origin" }).then(function(a) {
          if (!a.ok)
            throw "failed to load wasm binary file at '" + I + "'";
          return a.arrayBuffer();
        }).catch(function() {
          return Pa();
        });
      }
      Ga.push({ Jb: function() {
        Ra();
      } });
      var Sa = {};
      function Ta(a) {
        for (; a.length; ) {
          var b = a.pop();
          a.pop()(b);
        }
      }
      function J(a) {
        return this.fromWireType(F[a >> 2]);
      }
      var K = {}, L = {}, Ua = {};
      function Va(a) {
        if (a === void 0)
          return "_unknown";
        a = a.replace(/[^a-zA-Z0-9_]/g, "$");
        var b = a.charCodeAt(0);
        return 48 <= b && 57 >= b ? "_" + a : a;
      }
      function Wa(a, b) {
        a = Va(a);
        return new Function("body", "return function " + a + '() {\n    "use strict";    return body.apply(this, arguments);\n};\n')(b);
      }
      function Xa(a) {
        var b = Error, c2 = Wa(a, function(e2) {
          this.name = a;
          this.message = e2;
          e2 = Error(e2).stack;
          e2 !== void 0 && (this.stack = this.toString() + "\n" + e2.replace(/^Error(:[^\n]*)?\n/, ""));
        });
        c2.prototype = Object.create(b.prototype);
        c2.prototype.constructor = c2;
        c2.prototype.toString = function() {
          return this.message === void 0 ? this.name : this.name + ": " + this.message;
        };
        return c2;
      }
      var Ya = void 0;
      function Za(a) {
        throw new Ya(a);
      }
      function N(a, b, c2) {
        function e2(h) {
          h = c2(h);
          h.length !== a.length && Za("Mismatched type converter count");
          for (var k = 0; k < a.length; ++k)
            O(a[k], h[k]);
        }
        a.forEach(function(h) {
          Ua[h] = b;
        });
        var f = Array(b.length), g = [], m = 0;
        b.forEach(function(h, k) {
          L.hasOwnProperty(h) ? f[k] = L[h] : (g.push(h), K.hasOwnProperty(h) || (K[h] = []), K[h].push(function() {
            f[k] = L[h];
            ++m;
            m === g.length && e2(f);
          }));
        });
        g.length === 0 && e2(f);
      }
      var $a = {};
      function ab(a) {
        switch (a) {
          case 1:
            return 0;
          case 2:
            return 1;
          case 4:
            return 2;
          case 8:
            return 3;
          default:
            throw new TypeError("Unknown type size: " + a);
        }
      }
      var bb = void 0;
      function P(a) {
        for (var b = ""; B[a]; )
          b += bb[B[a++]];
        return b;
      }
      var Q = void 0;
      function R(a) {
        throw new Q(a);
      }
      function O(a, b, c2) {
        c2 = c2 || {};
        if (!("argPackAdvance" in b))
          throw new TypeError("registerType registeredInstance requires argPackAdvance");
        var e2 = b.name;
        a || R('type "' + e2 + '" must have a positive integer typeid pointer');
        if (L.hasOwnProperty(a)) {
          if (c2.Mb)
            return;
          R("Cannot register type '" + e2 + "' twice");
        }
        L[a] = b;
        delete Ua[a];
        K.hasOwnProperty(a) && (b = K[a], delete K[a], b.forEach(function(f) {
          f();
        }));
      }
      function cb(a) {
        return { count: a.count, lb: a.lb, nb: a.nb, bb: a.bb, cb: a.cb, gb: a.gb, ib: a.ib };
      }
      function db(a) {
        R(a.$a.cb.ab.name + " instance already deleted");
      }
      var eb = false;
      function fb() {
      }
      function gb(a) {
        --a.count.value;
        a.count.value === 0 && (a.gb ? a.ib.hb(a.gb) : a.cb.ab.hb(a.bb));
      }
      function hb(a) {
        if (typeof FinalizationGroup === "undefined")
          return hb = function(b) {
            return b;
          }, a;
        eb = new FinalizationGroup(function(b) {
          for (var c2 = b.next(); !c2.done; c2 = b.next())
            c2 = c2.value, c2.bb ? gb(c2) : console.warn("object already deleted: " + c2.bb);
        });
        hb = function(b) {
          eb.register(b, b.$a, b.$a);
          return b;
        };
        fb = function(b) {
          eb.unregister(b.$a);
        };
        return hb(a);
      }
      var ib = void 0, jb = [];
      function kb() {
        for (; jb.length; ) {
          var a = jb.pop();
          a.$a.lb = false;
          a["delete"]();
        }
      }
      function S() {
      }
      var lb = {};
      function mb(a, b, c2) {
        if (a[b].eb === void 0) {
          var e2 = a[b];
          a[b] = function() {
            a[b].eb.hasOwnProperty(arguments.length) || R("Function '" + c2 + "' called with an invalid number of arguments (" + arguments.length + ") - expects one of (" + a[b].eb + ")!");
            return a[b].eb[arguments.length].apply(this, arguments);
          };
          a[b].eb = [];
          a[b].eb[e2.qb] = e2;
        }
      }
      function nb(a, b, c2) {
        d.hasOwnProperty(a) ? ((c2 === void 0 || d[a].eb !== void 0 && d[a].eb[c2] !== void 0) && R("Cannot register public name '" + a + "' twice"), mb(d, a, a), d.hasOwnProperty(c2) && R("Cannot register multiple overloads of a function with the same number of arguments (" + c2 + ")!"), d[a].eb[c2] = b) : (d[a] = b, c2 !== void 0 && (d[a].Sb = c2));
      }
      function ob(a, b, c2, e2, f, g, m, h) {
        this.name = a;
        this.constructor = b;
        this.mb = c2;
        this.hb = e2;
        this.jb = f;
        this.Kb = g;
        this.pb = m;
        this.Hb = h;
        this.Pb = [];
      }
      function pb(a, b, c2) {
        for (; b !== c2; )
          b.pb || R("Expected null or instance of " + c2.name + ", got an instance of " + b.name), a = b.pb(a), b = b.jb;
        return a;
      }
      function qb(a, b) {
        if (b === null)
          return this.xb && R("null is not a valid " + this.name), 0;
        b.$a || R('Cannot pass "' + U(b) + '" as a ' + this.name);
        b.$a.bb || R("Cannot pass deleted object as a pointer of type " + this.name);
        return pb(b.$a.bb, b.$a.cb.ab, this.ab);
      }
      function rb(a, b) {
        if (b === null) {
          this.xb && R("null is not a valid " + this.name);
          if (this.sb) {
            var c2 = this.ob();
            a !== null && a.push(this.hb, c2);
            return c2;
          }
          return 0;
        }
        b.$a || R('Cannot pass "' + U(b) + '" as a ' + this.name);
        b.$a.bb || R("Cannot pass deleted object as a pointer of type " + this.name);
        !this.rb && b.$a.cb.rb && R("Cannot convert argument of type " + (b.$a.ib ? b.$a.ib.name : b.$a.cb.name) + " to parameter type " + this.name);
        c2 = pb(b.$a.bb, b.$a.cb.ab, this.ab);
        if (this.sb)
          switch (b.$a.gb === void 0 && R("Passing raw pointer to smart pointer is illegal"), this.Rb) {
            case 0:
              b.$a.ib === this ? c2 = b.$a.gb : R("Cannot convert argument of type " + (b.$a.ib ? b.$a.ib.name : b.$a.cb.name) + " to parameter type " + this.name);
              break;
            case 1:
              c2 = b.$a.gb;
              break;
            case 2:
              if (b.$a.ib === this)
                c2 = b.$a.gb;
              else {
                var e2 = b.clone();
                c2 = this.Qb(c2, V(function() {
                  e2["delete"]();
                }));
                a !== null && a.push(this.hb, c2);
              }
              break;
            default:
              R("Unsupporting sharing policy");
          }
        return c2;
      }
      function sb(a, b) {
        if (b === null)
          return this.xb && R("null is not a valid " + this.name), 0;
        b.$a || R('Cannot pass "' + U(b) + '" as a ' + this.name);
        b.$a.bb || R("Cannot pass deleted object as a pointer of type " + this.name);
        b.$a.cb.rb && R("Cannot convert argument of type " + b.$a.cb.name + " to parameter type " + this.name);
        return pb(b.$a.bb, b.$a.cb.ab, this.ab);
      }
      function tb(a, b, c2) {
        if (b === c2)
          return a;
        if (c2.jb === void 0)
          return null;
        a = tb(a, b, c2.jb);
        return a === null ? null : c2.Hb(a);
      }
      var ub = {};
      function vb(a, b) {
        for (b === void 0 && R("ptr should not be undefined"); a.jb; )
          b = a.pb(b), a = a.jb;
        return ub[b];
      }
      function wb(a, b) {
        b.cb && b.bb || Za("makeClassHandle requires ptr and ptrType");
        !!b.ib !== !!b.gb && Za("Both smartPtrType and smartPtr must be specified");
        b.count = { value: 1 };
        return hb(Object.create(a, { $a: { value: b } }));
      }
      function W(a, b, c2, e2) {
        this.name = a;
        this.ab = b;
        this.xb = c2;
        this.rb = e2;
        this.sb = false;
        this.hb = this.Qb = this.ob = this.Eb = this.Rb = this.Ob = void 0;
        b.jb !== void 0 ? this.toWireType = rb : (this.toWireType = e2 ? qb : sb, this.fb = null);
      }
      function xb(a, b, c2) {
        d.hasOwnProperty(a) || Za("Replacing nonexistant public symbol");
        d[a].eb !== void 0 && c2 !== void 0 ? d[a].eb[c2] = b : (d[a] = b, d[a].qb = c2);
      }
      function X(a, b) {
        a = P(a);
        var c2 = d["dynCall_" + a];
        for (var e2 = [], f = 1; f < a.length; ++f)
          e2.push("a" + f);
        f = "return function dynCall_" + (a + "_" + b) + "(" + e2.join(", ") + ") {\n";
        f += "    return dynCall(rawFunction" + (e2.length ? ", " : "") + e2.join(", ") + ");\n";
        c2 = new Function("dynCall", "rawFunction", f + "};\n")(c2, b);
        typeof c2 !== "function" && R("unknown function pointer with signature " + a + ": " + b);
        return c2;
      }
      var yb = void 0;
      function zb(a) {
        a = Ab(a);
        var b = P(a);
        Y(a);
        return b;
      }
      function Db(a, b) {
        function c2(g) {
          f[g] || L[g] || (Ua[g] ? Ua[g].forEach(c2) : (e2.push(g), f[g] = true));
        }
        var e2 = [], f = {};
        b.forEach(c2);
        throw new yb(a + ": " + e2.map(zb).join([", "]));
      }
      function Eb(a, b) {
        for (var c2 = [], e2 = 0; e2 < a; e2++)
          c2.push(E[(b >> 2) + e2]);
        return c2;
      }
      function Fb(a) {
        var b = Function;
        if (!(b instanceof Function))
          throw new TypeError("new_ called with constructor type " + typeof b + " which is not a function");
        var c2 = Wa(b.name || "unknownFunctionName", function() {
        });
        c2.prototype = b.prototype;
        c2 = new c2();
        a = b.apply(c2, a);
        return a instanceof Object ? a : c2;
      }
      function Gb(a, b, c2, e2, f) {
        var g = b.length;
        2 > g && R("argTypes array size mismatch! Must at least get return value and 'this' types!");
        var m = b[1] !== null && c2 !== null, h = false;
        for (c2 = 1; c2 < b.length; ++c2)
          if (b[c2] !== null && b[c2].fb === void 0) {
            h = true;
            break;
          }
        var k = b[0].name !== "void", l = "", n = "";
        for (c2 = 0; c2 < g - 2; ++c2)
          l += (c2 !== 0 ? ", " : "") + "arg" + c2, n += (c2 !== 0 ? ", " : "") + "arg" + c2 + "Wired";
        a = "return function " + Va(a) + "(" + l + ") {\nif (arguments.length !== " + (g - 2) + ") {\nthrowBindingError('function " + a + " called with ' + arguments.length + ' arguments, expected " + (g - 2) + " args!');\n}\n";
        h && (a += "var destructors = [];\n");
        var p = h ? "destructors" : "null";
        l = "throwBindingError invoker fn runDestructors retType classParam".split(" ");
        e2 = [R, e2, f, Ta, b[0], b[1]];
        m && (a += "var thisWired = classParam.toWireType(" + p + ", this);\n");
        for (c2 = 0; c2 < g - 2; ++c2)
          a += "var arg" + c2 + "Wired = argType" + c2 + ".toWireType(" + p + ", arg" + c2 + "); // " + b[c2 + 2].name + "\n", l.push("argType" + c2), e2.push(b[c2 + 2]);
        m && (n = "thisWired" + (0 < n.length ? ", " : "") + n);
        a += (k ? "var rv = " : "") + "invoker(fn" + (0 < n.length ? ", " : "") + n + ");\n";
        if (h)
          a += "runDestructors(destructors);\n";
        else
          for (c2 = m ? 1 : 2; c2 < b.length; ++c2)
            g = c2 === 1 ? "thisWired" : "arg" + (c2 - 2) + "Wired", b[c2].fb !== null && (a += g + "_dtor(" + g + "); // " + b[c2].name + "\n", l.push(g + "_dtor"), e2.push(b[c2].fb));
        k && (a += "var ret = retType.fromWireType(rv);\nreturn ret;\n");
        l.push(a + "}\n");
        return Fb(l).apply(null, e2);
      }
      var Hb = [], Z = [{}, { value: void 0 }, { value: null }, { value: true }, { value: false }];
      function Ib(a) {
        4 < a && --Z[a].yb === 0 && (Z[a] = void 0, Hb.push(a));
      }
      function V(a) {
        switch (a) {
          case void 0:
            return 1;
          case null:
            return 2;
          case true:
            return 3;
          case false:
            return 4;
          default:
            var b = Hb.length ? Hb.pop() : Z.length;
            Z[b] = { yb: 1, value: a };
            return b;
        }
      }
      function Jb(a, b, c2) {
        switch (b) {
          case 0:
            return function(e2) {
              return this.fromWireType((c2 ? Aa : B)[e2]);
            };
          case 1:
            return function(e2) {
              return this.fromWireType((c2 ? D : ta)[e2 >> 1]);
            };
          case 2:
            return function(e2) {
              return this.fromWireType((c2 ? E : F)[e2 >> 2]);
            };
          default:
            throw new TypeError("Unknown integer type: " + a);
        }
      }
      function Kb(a, b) {
        var c2 = L[a];
        c2 === void 0 && R(b + " has unknown type " + zb(a));
        return c2;
      }
      function U(a) {
        if (a === null)
          return "null";
        var b = typeof a;
        return b === "object" || b === "array" || b === "function" ? a.toString() : "" + a;
      }
      function Lb(a, b) {
        switch (b) {
          case 2:
            return function(c2) {
              return this.fromWireType(Ba[c2 >> 2]);
            };
          case 3:
            return function(c2) {
              return this.fromWireType(Ca[c2 >> 3]);
            };
          default:
            throw new TypeError("Unknown float type: " + a);
        }
      }
      function Mb(a, b, c2) {
        switch (b) {
          case 0:
            return c2 ? function(e2) {
              return Aa[e2];
            } : function(e2) {
              return B[e2];
            };
          case 1:
            return c2 ? function(e2) {
              return D[e2 >> 1];
            } : function(e2) {
              return ta[e2 >> 1];
            };
          case 2:
            return c2 ? function(e2) {
              return E[e2 >> 2];
            } : function(e2) {
              return F[e2 >> 2];
            };
          default:
            throw new TypeError("Unknown integer type: " + a);
        }
      }
      var Nb = {};
      function Ob(a) {
        var b = Nb[a];
        return b === void 0 ? P(a) : b;
      }
      var Pb = [];
      function Qb(a) {
        a || R("Cannot use deleted val. handle = " + a);
        return Z[a].value;
      }
      function Rb() {
        return typeof globalThis === "object" ? globalThis : Function("return this")();
      }
      function Sb(a) {
        var b = Pb.length;
        Pb.push(a);
        return b;
      }
      function Tb(a, b) {
        for (var c2 = Array(a), e2 = 0; e2 < a; ++e2)
          c2[e2] = Kb(E[(b >> 2) + e2], "parameter " + e2);
        return c2;
      }
      var Ub = {}, Vb = [null, [], []];
      Ya = d.InternalError = Xa("InternalError");
      for (var Wb = Array(256), Xb = 0; 256 > Xb; ++Xb)
        Wb[Xb] = String.fromCharCode(Xb);
      bb = Wb;
      Q = d.BindingError = Xa("BindingError");
      S.prototype.isAliasOf = function(a) {
        if (!(this instanceof S && a instanceof S))
          return false;
        var b = this.$a.cb.ab, c2 = this.$a.bb, e2 = a.$a.cb.ab;
        for (a = a.$a.bb; b.jb; )
          c2 = b.pb(c2), b = b.jb;
        for (; e2.jb; )
          a = e2.pb(a), e2 = e2.jb;
        return b === e2 && c2 === a;
      };
      S.prototype.clone = function() {
        this.$a.bb || db(this);
        if (this.$a.nb)
          return this.$a.count.value += 1, this;
        var a = hb(Object.create(Object.getPrototypeOf(this), { $a: { value: cb(this.$a) } }));
        a.$a.count.value += 1;
        a.$a.lb = false;
        return a;
      };
      S.prototype["delete"] = function() {
        this.$a.bb || db(this);
        this.$a.lb && !this.$a.nb && R("Object already scheduled for deletion");
        fb(this);
        gb(this.$a);
        this.$a.nb || (this.$a.gb = void 0, this.$a.bb = void 0);
      };
      S.prototype.isDeleted = function() {
        return !this.$a.bb;
      };
      S.prototype.deleteLater = function() {
        this.$a.bb || db(this);
        this.$a.lb && !this.$a.nb && R("Object already scheduled for deletion");
        jb.push(this);
        jb.length === 1 && ib && ib(kb);
        this.$a.lb = true;
        return this;
      };
      W.prototype.Lb = function(a) {
        this.Eb && (a = this.Eb(a));
        return a;
      };
      W.prototype.Cb = function(a) {
        this.hb && this.hb(a);
      };
      W.prototype.argPackAdvance = 8;
      W.prototype.readValueFromPointer = J;
      W.prototype.deleteObject = function(a) {
        if (a !== null)
          a["delete"]();
      };
      W.prototype.fromWireType = function(a) {
        function b() {
          return this.sb ? wb(this.ab.mb, { cb: this.Ob, bb: c2, ib: this, gb: a }) : wb(this.ab.mb, { cb: this, bb: a });
        }
        var c2 = this.Lb(a);
        if (!c2)
          return this.Cb(a), null;
        var e2 = vb(this.ab, c2);
        if (e2 !== void 0) {
          if (e2.$a.count.value === 0)
            return e2.$a.bb = c2, e2.$a.gb = a, e2.clone();
          e2 = e2.clone();
          this.Cb(a);
          return e2;
        }
        e2 = this.ab.Kb(c2);
        e2 = lb[e2];
        if (!e2)
          return b.call(this);
        e2 = this.rb ? e2.Gb : e2.pointerType;
        var f = tb(c2, this.ab, e2.ab);
        return f === null ? b.call(this) : this.sb ? wb(e2.ab.mb, { cb: e2, bb: f, ib: this, gb: a }) : wb(e2.ab.mb, { cb: e2, bb: f });
      };
      d.getInheritedInstanceCount = function() {
        return Object.keys(ub).length;
      };
      d.getLiveInheritedInstances = function() {
        var a = [], b;
        for (b in ub)
          ub.hasOwnProperty(b) && a.push(ub[b]);
        return a;
      };
      d.flushPendingDeletes = kb;
      d.setDelayFunction = function(a) {
        ib = a;
        jb.length && ib && ib(kb);
      };
      yb = d.UnboundTypeError = Xa("UnboundTypeError");
      d.count_emval_handles = function() {
        for (var a = 0, b = 5; b < Z.length; ++b)
          Z[b] !== void 0 && ++a;
        return a;
      };
      d.get_first_emval = function() {
        for (var a = 5; a < Z.length; ++a)
          if (Z[a] !== void 0)
            return Z[a];
        return null;
      };
      var Zb = {
        s: function(a) {
          var b = Sa[a];
          delete Sa[a];
          var c2 = b.elements, e2 = c2.length, f = c2.map(function(h) {
            return h.wb;
          }).concat(c2.map(function(h) {
            return h.Ab;
          })), g = b.ob, m = b.hb;
          N([a], f, function(h) {
            c2.forEach(function(k, l) {
              var n = h[l], p = k.ub, q = k.vb, t = h[l + e2], u = k.zb, M = k.Bb;
              k.read = function(A) {
                return n.fromWireType(p(q, A));
              };
              k.write = function(A, T) {
                var C = [];
                u(M, A, t.toWireType(C, T));
                Ta(C);
              };
            });
            return [{ name: b.name, fromWireType: function(k) {
              for (var l = Array(e2), n = 0; n < e2; ++n)
                l[n] = c2[n].read(k);
              m(k);
              return l;
            }, toWireType: function(k, l) {
              if (e2 !== l.length)
                throw new TypeError("Incorrect number of tuple elements for " + b.name + ": expected=" + e2 + ", actual=" + l.length);
              for (var n = g(), p = 0; p < e2; ++p)
                c2[p].write(n, l[p]);
              k !== null && k.push(m, n);
              return n;
            }, argPackAdvance: 8, readValueFromPointer: J, fb: m }];
          });
        },
        v: function(a) {
          var b = $a[a];
          delete $a[a];
          var c2 = b.ob, e2 = b.hb, f = b.Db, g = f.map(function(m) {
            return m.wb;
          }).concat(f.map(function(m) {
            return m.Ab;
          }));
          N([a], g, function(m) {
            var h = {};
            f.forEach(function(k, l) {
              var n = m[l], p = k.ub, q = k.vb, t = m[l + f.length], u = k.zb, M = k.Bb;
              h[k.Ib] = { read: function(A) {
                return n.fromWireType(p(q, A));
              }, write: function(A, T) {
                var C = [];
                u(M, A, t.toWireType(C, T));
                Ta(C);
              } };
            });
            return [{ name: b.name, fromWireType: function(k) {
              var l = {}, n;
              for (n in h)
                l[n] = h[n].read(k);
              e2(k);
              return l;
            }, toWireType: function(k, l) {
              for (var n in h)
                if (!(n in l))
                  throw new TypeError("Missing field");
              var p = c2();
              for (n in h)
                h[n].write(p, l[n]);
              k !== null && k.push(e2, p);
              return p;
            }, argPackAdvance: 8, readValueFromPointer: J, fb: e2 }];
          });
        },
        G: function(a, b, c2, e2, f) {
          var g = ab(c2);
          b = P(b);
          O(a, {
            name: b,
            fromWireType: function(m) {
              return !!m;
            },
            toWireType: function(m, h) {
              return h ? e2 : f;
            },
            argPackAdvance: 8,
            readValueFromPointer: function(m) {
              if (c2 === 1)
                var h = Aa;
              else if (c2 === 2)
                h = D;
              else if (c2 === 4)
                h = E;
              else
                throw new TypeError("Unknown boolean type size: " + b);
              return this.fromWireType(h[m >> g]);
            },
            fb: null
          });
        },
        k: function(a, b, c2, e2, f, g, m, h, k, l, n, p, q) {
          n = P(n);
          g = X(f, g);
          h && (h = X(m, h));
          l && (l = X(k, l));
          q = X(p, q);
          var t = Va(n);
          nb(t, function() {
            Db("Cannot construct " + n + " due to unbound types", [e2]);
          });
          N([a, b, c2], e2 ? [e2] : [], function(u) {
            u = u[0];
            if (e2) {
              var M = u.ab;
              var A = M.mb;
            } else
              A = S.prototype;
            u = Wa(t, function() {
              if (Object.getPrototypeOf(this) !== T)
                throw new Q("Use 'new' to construct " + n);
              if (C.kb === void 0)
                throw new Q(n + " has no accessible constructor");
              var Bb = C.kb[arguments.length];
              if (Bb === void 0)
                throw new Q("Tried to invoke ctor of " + n + " with invalid number of parameters (" + arguments.length + ") - expected (" + Object.keys(C.kb).toString() + ") parameters instead!");
              return Bb.apply(this, arguments);
            });
            var T = Object.create(A, { constructor: { value: u } });
            u.prototype = T;
            var C = new ob(n, u, T, q, M, g, h, l);
            M = new W(n, C, true, false);
            A = new W(n + "*", C, false, false);
            var Cb = new W(n + " const*", C, false, true);
            lb[a] = { pointerType: A, Gb: Cb };
            xb(t, u);
            return [M, A, Cb];
          });
        },
        h: function(a, b, c2, e2, f, g) {
          assert(0 < b);
          var m = Eb(b, c2);
          f = X(e2, f);
          var h = [g], k = [];
          N([], [a], function(l) {
            l = l[0];
            var n = "constructor " + l.name;
            l.ab.kb === void 0 && (l.ab.kb = []);
            if (l.ab.kb[b - 1] !== void 0)
              throw new Q("Cannot register multiple constructors with identical number of parameters (" + (b - 1) + ") for class '" + l.name + "'! Overload resolution is currently only performed using the parameter count, not actual type info!");
            l.ab.kb[b - 1] = function() {
              Db("Cannot construct " + l.name + " due to unbound types", m);
            };
            N([], m, function(p) {
              l.ab.kb[b - 1] = function() {
                arguments.length !== b - 1 && R(n + " called with " + arguments.length + " arguments, expected " + (b - 1));
                k.length = 0;
                h.length = b;
                for (var q = 1; q < b; ++q)
                  h[q] = p[q].toWireType(k, arguments[q - 1]);
                q = f.apply(null, h);
                Ta(k);
                return p[0].fromWireType(q);
              };
              return [];
            });
            return [];
          });
        },
        a: function(a, b, c2, e2, f, g, m, h) {
          var k = Eb(c2, e2);
          b = P(b);
          g = X(f, g);
          N([], [a], function(l) {
            function n() {
              Db("Cannot call " + p + " due to unbound types", k);
            }
            l = l[0];
            var p = l.name + "." + b;
            h && l.ab.Pb.push(b);
            var q = l.ab.mb, t = q[b];
            t === void 0 || t.eb === void 0 && t.className !== l.name && t.qb === c2 - 2 ? (n.qb = c2 - 2, n.className = l.name, q[b] = n) : (mb(q, b, p), q[b].eb[c2 - 2] = n);
            N([], k, function(u) {
              u = Gb(p, u, l, g, m);
              q[b].eb === void 0 ? (u.qb = c2 - 2, q[b] = u) : q[b].eb[c2 - 2] = u;
              return [];
            });
            return [];
          });
        },
        M: function(a, b, c2) {
          a = P(a);
          N([], [b], function(e2) {
            e2 = e2[0];
            d[a] = e2.fromWireType(c2);
            return [];
          });
        },
        E: function(a, b) {
          b = P(b);
          O(a, { name: b, fromWireType: function(c2) {
            var e2 = Z[c2].value;
            Ib(c2);
            return e2;
          }, toWireType: function(c2, e2) {
            return V(e2);
          }, argPackAdvance: 8, readValueFromPointer: J, fb: null });
        },
        g: function(a, b, c2, e2) {
          function f() {
          }
          c2 = ab(c2);
          b = P(b);
          f.values = {};
          O(a, { name: b, constructor: f, fromWireType: function(g) {
            return this.constructor.values[g];
          }, toWireType: function(g, m) {
            return m.value;
          }, argPackAdvance: 8, readValueFromPointer: Jb(b, c2, e2), fb: null });
          nb(b, f);
        },
        j: function(a, b, c2) {
          var e2 = Kb(a, "enum");
          b = P(b);
          a = e2.constructor;
          e2 = Object.create(e2.constructor.prototype, { value: { value: c2 }, constructor: { value: Wa(e2.name + "_" + b, function() {
          }) } });
          a.values[c2] = e2;
          a[b] = e2;
        },
        p: function(a, b, c2) {
          c2 = ab(c2);
          b = P(b);
          O(a, { name: b, fromWireType: function(e2) {
            return e2;
          }, toWireType: function(e2, f) {
            if (typeof f !== "number" && typeof f !== "boolean")
              throw new TypeError('Cannot convert "' + U(f) + '" to ' + this.name);
            return f;
          }, argPackAdvance: 8, readValueFromPointer: Lb(b, c2), fb: null });
        },
        f: function(a, b, c2, e2, f, g) {
          var m = Eb(b, c2);
          a = P(a);
          f = X(e2, f);
          nb(a, function() {
            Db("Cannot call " + a + " due to unbound types", m);
          }, b - 1);
          N([], m, function(h) {
            h = [h[0], null].concat(h.slice(1));
            xb(a, Gb(a, h, null, f, g), b - 1);
            return [];
          });
        },
        e: function(a, b, c2, e2, f) {
          function g(l) {
            return l;
          }
          b = P(b);
          f === -1 && (f = 4294967295);
          var m = ab(c2);
          if (e2 === 0) {
            var h = 32 - 8 * c2;
            g = function(l) {
              return l << h >>> h;
            };
          }
          var k = b.indexOf("unsigned") != -1;
          O(a, { name: b, fromWireType: g, toWireType: function(l, n) {
            if (typeof n !== "number" && typeof n !== "boolean")
              throw new TypeError('Cannot convert "' + U(n) + '" to ' + this.name);
            if (n < e2 || n > f)
              throw new TypeError('Passing a number "' + U(n) + '" from JS side to C/C++ side to an argument of type "' + b + '", which is outside the valid range [' + e2 + ", " + f + "]!");
            return k ? n >>> 0 : n | 0;
          }, argPackAdvance: 8, readValueFromPointer: Mb(b, m, e2 !== 0), fb: null });
        },
        b: function(a, b, c2) {
          function e2(g) {
            g >>= 2;
            return new f(za, F[g + 1], F[g]);
          }
          var f = [Int8Array, Uint8Array, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array][b];
          c2 = P(c2);
          O(a, { name: c2, fromWireType: e2, argPackAdvance: 8, readValueFromPointer: e2 }, { Mb: true });
        },
        q: function(a, b) {
          b = P(b);
          var c2 = b === "std::string";
          O(a, { name: b, fromWireType: function(e2) {
            var f = F[e2 >> 2];
            if (c2)
              for (var g = e2 + 4, m = 0; m <= f; ++m) {
                var h = e2 + 4 + m;
                if (B[h] == 0 || m == f) {
                  g = g ? pa(B, g, h - g) : "";
                  if (k === void 0)
                    var k = g;
                  else
                    k += String.fromCharCode(0), k += g;
                  g = h + 1;
                }
              }
            else {
              k = Array(f);
              for (m = 0; m < f; ++m)
                k[m] = String.fromCharCode(B[e2 + 4 + m]);
              k = k.join("");
            }
            Y(e2);
            return k;
          }, toWireType: function(e2, f) {
            f instanceof ArrayBuffer && (f = new Uint8Array(f));
            var g = typeof f === "string";
            g || f instanceof Uint8Array || f instanceof Uint8ClampedArray || f instanceof Int8Array || R("Cannot pass non-string to std::string");
            var m = (c2 && g ? function() {
              for (var l = 0, n = 0; n < f.length; ++n) {
                var p = f.charCodeAt(n);
                55296 <= p && 57343 >= p && (p = 65536 + ((p & 1023) << 10) | f.charCodeAt(++n) & 1023);
                127 >= p ? ++l : l = 2047 >= p ? l + 2 : 65535 >= p ? l + 3 : l + 4;
              }
              return l;
            } : function() {
              return f.length;
            })(), h = Yb(4 + m + 1);
            F[h >> 2] = m;
            if (c2 && g)
              qa(f, h + 4, m + 1);
            else if (g)
              for (g = 0; g < m; ++g) {
                var k = f.charCodeAt(g);
                255 < k && (Y(h), R("String has UTF-16 code units that do not fit in 8 bits"));
                B[h + 4 + g] = k;
              }
            else
              for (g = 0; g < m; ++g)
                B[h + 4 + g] = f[g];
            e2 !== null && e2.push(Y, h);
            return h;
          }, argPackAdvance: 8, readValueFromPointer: J, fb: function(e2) {
            Y(e2);
          } });
        },
        l: function(a, b, c2) {
          c2 = P(c2);
          if (b === 2) {
            var e2 = sa;
            var f = ua;
            var g = va;
            var m = function() {
              return ta;
            };
            var h = 1;
          } else
            b === 4 && (e2 = wa, f = xa, g = ya, m = function() {
              return F;
            }, h = 2);
          O(a, { name: c2, fromWireType: function(k) {
            for (var l = F[k >> 2], n = m(), p, q = k + 4, t = 0; t <= l; ++t) {
              var u = k + 4 + t * b;
              if (n[u >> h] == 0 || t == l)
                q = e2(q, u - q), p === void 0 ? p = q : (p += String.fromCharCode(0), p += q), q = u + b;
            }
            Y(k);
            return p;
          }, toWireType: function(k, l) {
            typeof l !== "string" && R("Cannot pass non-string to C++ string type " + c2);
            var n = g(l), p = Yb(4 + n + b);
            F[p >> 2] = n >> h;
            f(l, p + 4, n + b);
            k !== null && k.push(Y, p);
            return p;
          }, argPackAdvance: 8, readValueFromPointer: J, fb: function(k) {
            Y(k);
          } });
        },
        u: function(a, b, c2, e2, f, g) {
          Sa[a] = { name: P(b), ob: X(c2, e2), hb: X(f, g), elements: [] };
        },
        t: function(a, b, c2, e2, f, g, m, h, k) {
          Sa[a].elements.push({ wb: b, ub: X(c2, e2), vb: f, Ab: g, zb: X(m, h), Bb: k });
        },
        w: function(a, b, c2, e2, f, g) {
          $a[a] = { name: P(b), ob: X(c2, e2), hb: X(f, g), Db: [] };
        },
        i: function(a, b, c2, e2, f, g, m, h, k, l) {
          $a[a].Db.push({ Ib: P(b), wb: c2, ub: X(e2, f), vb: g, Ab: m, zb: X(h, k), Bb: l });
        },
        H: function(a, b) {
          b = P(b);
          O(a, { Nb: true, name: b, argPackAdvance: 0, fromWireType: function() {
          }, toWireType: function() {
          } });
        },
        d: function(a, b, c2, e2) {
          a = Pb[a];
          b = Qb(b);
          c2 = Ob(c2);
          a(b, c2, null, e2);
        },
        N: Ib,
        z: function(a) {
          if (a === 0)
            return V(Rb());
          a = Ob(a);
          return V(Rb()[a]);
        },
        c: function(a, b) {
          b = Tb(a, b);
          for (var c2 = b[0], e2 = c2.name + "_$" + b.slice(1).map(function(l) {
            return l.name;
          }).join("_") + "$", f = ["retType"], g = [c2], m = "", h = 0; h < a - 1; ++h)
            m += (h !== 0 ? ", " : "") + "arg" + h, f.push("argType" + h), g.push(b[1 + h]);
          e2 = "return function " + Va("methodCaller_" + e2) + "(handle, name, destructors, args) {\n";
          var k = 0;
          for (h = 0; h < a - 1; ++h)
            e2 += "    var arg" + h + " = argType" + h + ".readValueFromPointer(args" + (k ? "+" + k : "") + ");\n", k += b[h + 1].argPackAdvance;
          e2 += "    var rv = handle[name](" + m + ");\n";
          for (h = 0; h < a - 1; ++h)
            b[h + 1].deleteObject && (e2 += "    argType" + h + ".deleteObject(arg" + h + ");\n");
          c2.Nb || (e2 += "    return retType.toWireType(destructors, rv);\n");
          f.push(e2 + "};\n");
          a = Fb(f).apply(null, g);
          return Sb(a);
        },
        n: function(a) {
          4 < a && (Z[a].yb += 1);
        },
        x: function(a, b, c2, e2) {
          a = Qb(a);
          var f = Ub[b];
          if (!f) {
            f = "";
            for (var g = 0; g < b; ++g)
              f += (g !== 0 ? ", " : "") + "arg" + g;
            var m = "return function emval_allocator_" + b + "(constructor, argTypes, args) {\n";
            for (g = 0; g < b; ++g)
              m += "var argType" + g + " = requireRegisteredType(Module['HEAP32'][(argTypes >>> 2) + " + g + '], "parameter ' + g + '");\nvar arg' + g + " = argType" + g + ".readValueFromPointer(args);\nargs += argType" + g + "['argPackAdvance'];\n";
            f = new Function("requireRegisteredType", "Module", "__emval_register", m + ("var obj = new constructor(" + f + ");\nreturn __emval_register(obj);\n}\n"))(Kb, d, V);
            Ub[b] = f;
          }
          return f(a, c2, e2);
        },
        O: function() {
          return V([]);
        },
        F: function(a) {
          return V(Ob(a));
        },
        L: function(a, b) {
          a = Kb(a, "_emval_take_value");
          a = a.readValueFromPointer(b);
          return V(a);
        },
        m: function() {
          y2();
        },
        B: function(a, b, c2) {
          B.copyWithin(a, b, b + c2);
        },
        C: function() {
          y2("OOM");
        },
        D: function() {
          return 0;
        },
        y: function() {
        },
        o: function(a, b, c2, e2) {
          for (var f = 0, g = 0; g < c2; g++) {
            for (var m = E[b + 8 * g >> 2], h = E[b + (8 * g + 4) >> 2], k = 0; k < h; k++) {
              var l = B[m + k], n = Vb[a];
              l === 0 || l === 10 ? ((a === 1 ? ja : z)(pa(n, 0)), n.length = 0) : n.push(l);
            }
            f += h;
          }
          E[e2 >> 2] = f;
          return 0;
        },
        memory: la,
        K: function() {
        },
        r: function() {
        },
        J: function() {
        },
        I: function() {
        },
        A: function() {
        },
        table: ma
      }, $b = function() {
        function a(f) {
          d.asm = f.exports;
          H--;
          d.monitorRunDependencies && d.monitorRunDependencies(H);
          H == 0 && (La && (f = La, La = null, f()));
        }
        function b(f) {
          a(f.instance);
        }
        function c2(f) {
          return Qa().then(function(g) {
            return WebAssembly.instantiate(g, e2);
          }).then(f, function(g) {
            z("failed to asynchronously prepare wasm: " + g);
            y2(g);
          });
        }
        var e2 = { a: Zb };
        H++;
        d.monitorRunDependencies && d.monitorRunDependencies(H);
        if (d.instantiateWasm)
          try {
            return d.instantiateWasm(e2, a);
          } catch (f) {
            return z("Module.instantiateWasm callback failed with error: " + f), false;
          }
        (function() {
          if (ka || typeof WebAssembly.instantiateStreaming !== "function" || Na() || Ma("file://") || typeof fetch !== "function")
            return c2(b);
          fetch(I, { credentials: "same-origin" }).then(function(f) {
            return WebAssembly.instantiateStreaming(f, e2).then(b, function(g) {
              z("wasm streaming compile failed: " + g);
              z("falling back to ArrayBuffer instantiation");
              c2(b);
            });
          });
        })();
        return {};
      }();
      d.asm = $b;
      var Ra = d.___wasm_call_ctors = function() {
        return (Ra = d.___wasm_call_ctors = d.asm.P).apply(null, arguments);
      };
      d.__Z6ToCmdsRK6SkPath = function() {
        return (d.__Z6ToCmdsRK6SkPath = d.asm.Q).apply(null, arguments);
      };
      d.__Z8FromCmdsmi = function() {
        return (d.__Z8FromCmdsmi = d.asm.R).apply(null, arguments);
      };
      d.__Z7NewPathv = function() {
        return (d.__Z7NewPathv = d.asm.S).apply(null, arguments);
      };
      d.__Z8CopyPathRK6SkPath = function() {
        return (d.__Z8CopyPathRK6SkPath = d.asm.T).apply(null, arguments);
      };
      d.__Z6EqualsRK6SkPathS1_ = function() {
        return (d.__Z6EqualsRK6SkPathS1_ = d.asm.U).apply(null, arguments);
      };
      d.__Z11ToSVGStringRK6SkPath = function() {
        return (d.__Z11ToSVGStringRK6SkPath = d.asm.V).apply(null, arguments);
      };
      d.__Z13FromSVGStringNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEE = function() {
        return (d.__Z13FromSVGStringNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEE = d.asm.W).apply(null, arguments);
      };
      d.__Z13ApplySimplifyR6SkPath = function() {
        return (d.__Z13ApplySimplifyR6SkPath = d.asm.X).apply(null, arguments);
      };
      d.__Z11ApplyPathOpR6SkPathRKS_8SkPathOp = function() {
        return (d.__Z11ApplyPathOpR6SkPathRKS_8SkPathOp = d.asm.Y).apply(null, arguments);
      };
      d.__Z10MakeFromOpRK6SkPathS1_8SkPathOp = function() {
        return (d.__Z10MakeFromOpRK6SkPathS1_8SkPathOp = d.asm.Z).apply(null, arguments);
      };
      d.__Z14ResolveBuilderR11SkOpBuilder = function() {
        return (d.__Z14ResolveBuilderR11SkOpBuilder = d.asm._).apply(null, arguments);
      };
      d.__Z8ToCanvasRK6SkPathN10emscripten3valE = function() {
        return (d.__Z8ToCanvasRK6SkPathN10emscripten3valE = d.asm.$).apply(null, arguments);
      };
      d.__Z8ToPath2DRK6SkPath = function() {
        return (d.__Z8ToPath2DRK6SkPath = d.asm.aa).apply(null, arguments);
      };
      var Y = d._free = function() {
        return (Y = d._free = d.asm.ba).apply(null, arguments);
      }, Yb = d._malloc = function() {
        return (Yb = d._malloc = d.asm.ca).apply(null, arguments);
      }, Ab = d.___getTypeName = function() {
        return (Ab = d.___getTypeName = d.asm.da).apply(null, arguments);
      };
      d.___embind_register_native_and_builtin_types = function() {
        return (d.___embind_register_native_and_builtin_types = d.asm.ea).apply(null, arguments);
      };
      d.dynCall_vi = function() {
        return (d.dynCall_vi = d.asm.fa).apply(null, arguments);
      };
      d.dynCall_iiiii = function() {
        return (d.dynCall_iiiii = d.asm.ga).apply(null, arguments);
      };
      d.dynCall_ii = function() {
        return (d.dynCall_ii = d.asm.ha).apply(null, arguments);
      };
      d.dynCall_i = function() {
        return (d.dynCall_i = d.asm.ia).apply(null, arguments);
      };
      d.dynCall_viifffffffff = function() {
        return (d.dynCall_viifffffffff = d.asm.ja).apply(null, arguments);
      };
      d.dynCall_vifffffi = function() {
        return (d.dynCall_vifffffi = d.asm.ka).apply(null, arguments);
      };
      d.dynCall_vifffff = function() {
        return (d.dynCall_vifffff = d.asm.la).apply(null, arguments);
      };
      d.dynCall_viffffff = function() {
        return (d.dynCall_viffffff = d.asm.ma).apply(null, arguments);
      };
      d.dynCall_vifffffffi = function() {
        return (d.dynCall_vifffffffi = d.asm.na).apply(null, arguments);
      };
      d.dynCall_viff = function() {
        return (d.dynCall_viff = d.asm.oa).apply(null, arguments);
      };
      d.dynCall_viffff = function() {
        return (d.dynCall_viffff = d.asm.pa).apply(null, arguments);
      };
      d.dynCall_vii = function() {
        return (d.dynCall_vii = d.asm.qa).apply(null, arguments);
      };
      d.dynCall_iii = function() {
        return (d.dynCall_iii = d.asm.ra).apply(null, arguments);
      };
      d.dynCall_iifff = function() {
        return (d.dynCall_iifff = d.asm.sa).apply(null, arguments);
      };
      d.dynCall_iiffi = function() {
        return (d.dynCall_iiffi = d.asm.ta).apply(null, arguments);
      };
      d.dynCall_vifffffffff = function() {
        return (d.dynCall_vifffffffff = d.asm.ua).apply(null, arguments);
      };
      d.dynCall_iiii = function() {
        return (d.dynCall_iiii = d.asm.va).apply(null, arguments);
      };
      d.dynCall_viii = function() {
        return (d.dynCall_viii = d.asm.wa).apply(null, arguments);
      };
      d.dynCall_viiii = function() {
        return (d.dynCall_viiii = d.asm.xa).apply(null, arguments);
      };
      d.dynCall_fif = function() {
        return (d.dynCall_fif = d.asm.ya).apply(null, arguments);
      };
      d.dynCall_viif = function() {
        return (d.dynCall_viif = d.asm.za).apply(null, arguments);
      };
      d.dynCall_fi = function() {
        return (d.dynCall_fi = d.asm.Aa).apply(null, arguments);
      };
      d.dynCall_viiifffffffff = function() {
        return (d.dynCall_viiifffffffff = d.asm.Ba).apply(null, arguments);
      };
      d.dynCall_viifffffi = function() {
        return (d.dynCall_viifffffi = d.asm.Ca).apply(null, arguments);
      };
      d.dynCall_viifffff = function() {
        return (d.dynCall_viifffff = d.asm.Da).apply(null, arguments);
      };
      d.dynCall_viiffffff = function() {
        return (d.dynCall_viiffffff = d.asm.Ea).apply(null, arguments);
      };
      d.dynCall_viifffffffi = function() {
        return (d.dynCall_viifffffffi = d.asm.Fa).apply(null, arguments);
      };
      d.dynCall_viiff = function() {
        return (d.dynCall_viiff = d.asm.Ga).apply(null, arguments);
      };
      d.dynCall_viiffff = function() {
        return (d.dynCall_viiffff = d.asm.Ha).apply(null, arguments);
      };
      d.dynCall_iiifff = function() {
        return (d.dynCall_iiifff = d.asm.Ia).apply(null, arguments);
      };
      d.dynCall_iiiffi = function() {
        return (d.dynCall_iiiffi = d.asm.Ja).apply(null, arguments);
      };
      d.dynCall_fii = function() {
        return (d.dynCall_fii = d.asm.Ka).apply(null, arguments);
      };
      d.dynCall_iiffff = function() {
        return (d.dynCall_iiffff = d.asm.La).apply(null, arguments);
      };
      d.dynCall_fiif = function() {
        return (d.dynCall_fiif = d.asm.Ma).apply(null, arguments);
      };
      d.dynCall_iiif = function() {
        return (d.dynCall_iiif = d.asm.Na).apply(null, arguments);
      };
      d.dynCall_vifii = function() {
        return (d.dynCall_vifii = d.asm.Oa).apply(null, arguments);
      };
      d.dynCall_viifd = function() {
        return (d.dynCall_viifd = d.asm.Pa).apply(null, arguments);
      };
      d.dynCall_viid = function() {
        return (d.dynCall_viid = d.asm.Qa).apply(null, arguments);
      };
      d.dynCall_viddi = function() {
        return (d.dynCall_viddi = d.asm.Ra).apply(null, arguments);
      };
      d.dynCall_iidi = function() {
        return (d.dynCall_iidi = d.asm.Sa).apply(null, arguments);
      };
      d.dynCall_viffi = function() {
        return (d.dynCall_viffi = d.asm.Ta).apply(null, arguments);
      };
      d.dynCall_fffff = function() {
        return (d.dynCall_fffff = d.asm.Ua).apply(null, arguments);
      };
      d.dynCall_viiiii = function() {
        return (d.dynCall_viiiii = d.asm.Va).apply(null, arguments);
      };
      d.dynCall_viiiiiffii = function() {
        return (d.dynCall_viiiiiffii = d.asm.Wa).apply(null, arguments);
      };
      d.dynCall_iiiiii = function() {
        return (d.dynCall_iiiiii = d.asm.Xa).apply(null, arguments);
      };
      d.dynCall_iiiiiii = function() {
        return (d.dynCall_iiiiiii = d.asm.Ya).apply(null, arguments);
      };
      d.dynCall_iidiiii = function() {
        return (d.dynCall_iidiiii = d.asm.Za).apply(null, arguments);
      };
      d.dynCall_jiji = function() {
        return (d.dynCall_jiji = d.asm._a).apply(null, arguments);
      };
      d.asm = $b;
      var ac;
      La = function bc() {
        ac || cc();
        ac || (La = bc);
      };
      function cc() {
        function a() {
          if (!ac && (ac = true, d.calledRun = true, !na)) {
            Ea(Ga);
            Ea(Ha);
            aa(d);
            if (d.onRuntimeInitialized)
              d.onRuntimeInitialized();
            if (d.postRun)
              for (typeof d.postRun == "function" && (d.postRun = [d.postRun]); d.postRun.length; ) {
                var b = d.postRun.shift();
                Ia.unshift(b);
              }
            Ea(Ia);
          }
        }
        if (!(0 < H)) {
          if (d.preRun)
            for (typeof d.preRun == "function" && (d.preRun = [d.preRun]); d.preRun.length; )
              Ja();
          Ea(Fa);
          0 < H || (d.setStatus ? (d.setStatus("Running..."), setTimeout(function() {
            setTimeout(function() {
              d.setStatus("");
            }, 1);
            a();
          }, 1)) : a());
        }
      }
      d.run = cc;
      if (d.preInit)
        for (typeof d.preInit == "function" && (d.preInit = [d.preInit]); 0 < d.preInit.length; )
          d.preInit.pop()();
      cc();
      return PathKitInit3.ready;
    };
  }();
  module.exports = PathKitInit2;
})(pathkit);
var PathKitInit = pathkit.exports;
class SingleObjectItems extends EditorElement {
  template() {
    return `
        <div class="object-items single">
          <div>
            ${createComponent("LayerTreeProperty")}
          </div>
        </div>
    `;
  }
}
class ItemLayerTab extends EditorElement {
  components() {
    return {
      AssetItems,
      LibraryItems,
      CustomAssets,
      SingleObjectItems
    };
  }
  initState() {
    return {
      selectedIndexValue: 2
    };
  }
  afterRender() {
    this.$el.toggle(this.$config.get("editor.design.mode") === "item");
  }
  [BIND("$el")]() {
    return {
      style: {
        display: this.$config.get("editor.design.mode") === "item" ? "block" : "none"
      }
    };
  }
  template() {
    return `
      <div class='layer-tab'>
        <div class="tab number-tab side-tab side-tab-left" data-selected-value="2" ref="$tab">
          <div class="tab-header" ref="$header">   
            <div class="tab-item selected" data-value="2" data-direction="right" data-tooltip="${this.$i18n("app.tab.title.layers")}">
              <label>${iconUse$1("layers")}</label>
            </div>            
            <div class='tab-item' data-value='6' data-direction="right"  data-tooltip="${this.$i18n("app.tab.title.components")}">
              <label>${iconUse$1("plugin")}</label>
            </div>            

            ${this.$injectManager.getTargetMenuItems("leftbar.tab").filter((it) => {
      return it.class.designMode && it.class.designMode.includes("item");
    }).map((it) => {
      const { value, title: title2 } = it.class;
      let iconString = it.class.icon;
      if (obj[it.class.icon]) {
        iconString = iconUse$1(it.class.icon);
      }
      return `
                <div class='tab-item' data-value='${value}' data-direction="right"  data-tooltip="${title2}">
                  <label>${iconString || title2}</label>
                </div>
              `;
    })}

          </div>
          <div class="tab-body" ref="$body">
            <div class="tab-content selected" data-value="2">
              ${createComponent("SingleObjectItems")}
            </div>
            <div class='tab-content' data-value='6'>
              ${createComponent("CustomAssets")}
            </div>
            ${this.$injectManager.getTargetMenuItems("leftbar.tab").filter((it) => {
      return it.class.designMode && it.class.designMode.includes("item");
    }).map((it) => {
      const { value } = it.class;
      return `
                <div class='tab-content' data-value='${value}'>
                  ${this.$injectManager.generate(`leftbar.tab.${value}`)}
                </div>
              `;
    })}
          </div>
        </div>
      </div>
    `;
  }
  [CLICK("$header .tab-item:not(.extra-item)")](e2) {
    var selectedIndexValue = e2.$dt.attr("data-value");
    if (this.state.selectedIndexValue === selectedIndexValue) {
      return;
    }
    this.$el.$$(`[data-value="${this.state.selectedIndexValue}"]`).forEach((it) => it.removeClass("selected"));
    this.$el.$$(`[data-value="${selectedIndexValue}"]`).forEach((it) => it.addClass("selected"));
    this.setState({ selectedIndexValue }, false);
  }
}
class SingleInspector extends EditorElement {
  afterRender() {
    this.$el.toggle(this.$config.get("editor.design.mode") === "item");
  }
  [BIND("$el")]() {
    return {
      style: {
        display: this.$config.get("editor.design.mode") === "item" ? "block" : "none"
      }
    };
  }
  template() {
    return `
      <div class="feature-control inspector">
        <div>
              ${createComponent("AlignmentProperty")}
              ${createComponent("DepthProperty")}
              ${createComponent("PathToolProperty")}
              ${createComponent("PositionProperty")}
              ${createComponent("AppearanceProperty")}

              ${this.$injectManager.generate("inspector.tab.style")}                             
              <div class='empty'></div>
        </div>
      </div>
    `;
  }
}
var SwitchLeftPanel$1 = "";
class SwitchLeftPanel extends EditorElement {
  template() {
    return `
            <button class="elf--switch-left-panel" data-tooltip="Toggle left panel" data-direction="top left">${iconUse$1("switch_left")}</button>
        `;
  }
  [CLICK()]() {
    this.$config.toggle("show.left.panel");
  }
}
var SwitchRightPanel$1 = "";
class SwitchRightPanel extends EditorElement {
  template() {
    return `
            <button class="elf--switch-right-panel" data-tooltip="Toggle right panel" data-direction="top right">${iconUse$1("switch_right")}</button>
        `;
  }
  [CLICK()]() {
    this.$config.toggle("show.right.panel");
  }
}
class DesignEditor extends BaseLayout {
  initialize() {
    super.initialize();
    (async () => {
      this.$pathkit.registerPathKit(await PathKitInit());
    })();
  }
  components() {
    return {
      LayerTab,
      ItemLayerTab,
      ToolBar,
      StatusBar,
      Inspector,
      SingleInspector,
      BodyPanel,
      PopupManager,
      KeyboardManager,
      IconManager,
      SwitchLeftPanel,
      SwitchRightPanel
    };
  }
  getPlugins() {
    return designEditorPlugins;
  }
  initState() {
    return {
      leftSize: 340,
      rightSize: 280,
      bottomSize: 0,
      lastBottomSize: 150
    };
  }
  template() {
    const isItemMode = this.$config.is("editor.design.mode", "item");
    return `
      <div class="designeditor">
        <div class="layout-main">
          <div class='layout-top' ref='$top'>
            ${createComponent("ToolBar")}
          </div>
          <div class="layout-middle" ref='$middle'>      
            <div class="layout-body" ref='$bodyPanel'>
              ${createComponent("BodyPanel", { ref: "$bodyPanelView" })}
            </div>                           
            <div class='layout-left' ref='$leftPanel'>
              ${isItemMode ? createComponent("ItemLayerTab") : createComponent("LayerTab")}
            </div>
            <div class="layout-right" ref='$rightPanel'>
              ${isItemMode ? createComponent("SingleInspector") : createComponent("Inspector")}
            </div>
            <div class='left-arrow' ref='$leftArrow'>
              ${createComponent("SwitchLeftPanel")}
            </div>
            <div class='splitter' ref='$splitter'></div>            
            <div class='right-arrow' ref='$rightArrow'>
              ${createComponent("SwitchRightPanel")}
            </div>            
          </div>
          ${createComponent("KeyboardManager")}
        </div>
        ${createComponent("PopupManager")}
        ${createComponent("IconManager")}
      </div>
    `;
  }
  [BIND("$el")]() {
    return {
      "data-design-mode": this.$config.get("editor.design.mode")
    };
  }
  [BIND("$splitter")]() {
    let left2 = this.state.leftSize;
    if (this.$config.false("show.left.panel")) {
      left2 = 0;
    }
    return {
      style: {
        left: left2
      }
    };
  }
  [BIND("$leftArrow")]() {
    let left2 = this.state.leftSize;
    if (this.$config.false("show.left.panel")) {
      left2 = 0;
    }
    return {
      style: {
        left: left2
      }
    };
  }
  [BIND("$leftPanel")]() {
    let left2 = `0px`;
    let width2 = this.state.leftSize;
    let bottom2 = this.state.bottomSize;
    if (this.$config.false("show.left.panel")) {
      left2 = `-${this.state.leftSize}px`;
    }
    return {
      style: { left: left2, width: width2, bottom: bottom2 }
    };
  }
  [BIND("$rightPanel")]() {
    let right2 = 0;
    let bottom2 = this.state.bottomSize;
    if (this.$config.false("show.right.panel")) {
      right2 = -this.state.rightSize;
    }
    return {
      style: {
        right: right2,
        bottom: bottom2
      }
    };
  }
  [BIND("$rightArrow")]() {
    let right2 = 6;
    let bottom2 = this.state.bottomSize;
    if (this.$config.true("show.right.panel")) {
      right2 = this.state.rightSize + 6;
    }
    return {
      style: {
        right: right2,
        bottom: bottom2
      }
    };
  }
  [BIND("$bodyPanel")]() {
    let left2 = this.state.leftSize;
    let right2 = this.state.rightSize;
    let bottom2 = this.state.bottomSize;
    if (this.$config.false("show.left.panel")) {
      left2 = 0;
    }
    if (this.$config.false("show.right.panel")) {
      right2 = 0;
    }
    return {
      style: {
        left: left2 + 14,
        right: right2 + 14,
        bottom: bottom2
      }
    };
  }
  [POINTERSTART("$splitter") + MOVE("moveSplitter") + END("moveEndSplitter")]() {
    this.minSize = this.$theme("left_size");
    this.maxSize = this.$theme("left_max_size");
    this.leftSize = Length.parse(this.refs.$splitter.css("left")).value;
    this.refs.$splitter.addClass("selected");
  }
  moveSplitter(dx) {
    this.setState({
      leftSize: Math.max(Math.min(this.leftSize + dx, this.maxSize), this.minSize)
    });
  }
  moveEndSplitter() {
    this.refs.$splitter.removeClass("selected");
  }
  afterRender() {
    super.afterRender();
    this.$config.init("editor.layout.elements", this.refs);
  }
  refresh() {
    this.bindData("$el");
    this.bindData("$splitter");
    this.bindData("$leftArrow");
    this.bindData("$rightArrow");
    this.bindData("$headerPanel");
    this.bindData("$leftPanel");
    this.bindData("$rightPanel");
    this.bindData("$toggleRightButton");
    this.bindData("$toggleLeftButton");
    this.bindData("$bodyPanel");
    this.bindData("$footerPanel");
    this.emit("resizeEditor");
  }
  [CONFIG("show.left.panel")]() {
    this.refresh();
    this.nextTick(() => {
      this.emit("resizeCanvas");
    });
  }
  [CONFIG("show.right.panel")]() {
    this.refresh();
    this.nextTick(() => {
      this.emit("resizeCanvas");
    });
  }
  [CONFIG("editor.design.mode")]() {
    this.bindData("$el");
  }
  [DRAGOVER("$middle") + PREVENT](e2) {
  }
  [DROP("$middle") + PREVENT](e2) {
  }
  [SUBSCRIBE("toggle.fullscreen")]() {
    this.$el.toggleFullscreen();
  }
  [SUBSCRIBE("getLayoutElement")](callback) {
    if (isFunction(callback)) {
      callback(this.refs);
    }
  }
}
var exportLibrary = __spreadValues({
  EditorInstance: Editor,
  Length,
  EditorElement,
  HTMLLayerRender: LayerRender$1,
  Component,
  MenuItem,
  BaseProperty,
  ObjectProperty,
  PathParser,
  Segment,
  Point,
  icon: obj
}, Event$1);
var App = __spreadValues({
  createDesignEditor(opts = { type: "white" }) {
    return start(DesignEditor, __spreadValues({}, opts));
  }
}, exportLibrary);
export { App as default };
