var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj2, key, value) => key in obj2 ? __defProp(obj2, key, { enumerable: true, configurable: true, writable: true, value }) : obj2[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __accessCheck = (obj2, member, msg) => {
  if (!member.has(obj2))
    throw TypeError("Cannot " + msg);
};
var __privateGet = (obj2, member, getter) => {
  __accessCheck(obj2, member, "read from private field");
  return getter ? getter.call(obj2) : member.get(obj2);
};
var __privateAdd = (obj2, member, value) => {
  if (member.has(obj2))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj2) : member.set(obj2, value);
};
var __privateSet = (obj2, member, value, setter) => {
  __accessCheck(obj2, member, "write to private field");
  setter ? setter.call(obj2, value) : member.set(obj2, value);
  return value;
};
var __privateWrapper = (obj2, member, setter, getter) => {
  return {
    set _(value) {
      __privateSet(obj2, member, value, setter);
    },
    get _() {
      return __privateGet(obj2, member, getter);
    }
  };
};
var __privateMethod = (obj2, member, method) => {
  __accessCheck(obj2, member, "access private method");
  return method;
};
var _state, _prevState, _localTimestamp, _loadMethods, _timestamp, _cachedMethodList, _props, _propsKeys, _isServer, _propsKeyList, _prefLoadTemplate, _refreshTimestamp, refreshTimestamp_fn, _setProps, setProps_fn, _getProp, getProp_fn, _subscribes, _storeInstance, _modelManager, _json, _cachedValue, _timestamp2, _lastChangedField, _collapsed, _compiledTimeline;
function collectProps(root, filterFunction = () => true) {
  let p = root;
  let results = [];
  do {
    const isObject2 = p instanceof Object;
    if (isObject2 === false) {
      break;
    }
    const names2 = Object.getOwnPropertyNames(p).filter(filterFunction);
    results.push.apply(results, names2);
  } while (p = Object.getPrototypeOf(p));
  return results;
}
function debounce(callback, delay = 0) {
  if (delay === 0) {
    return callback;
  }
  var t = void 0;
  return function($1, $2, $3, $4, $5) {
    if (t) {
      window.clearTimeout(t);
    }
    t = window.setTimeout(function() {
      callback($1, $2, $3, $4, $5);
    }, delay || 300);
  };
}
function throttle(callback, delay) {
  var t = void 0;
  return function($1, $2, $3, $4, $5) {
    if (!t) {
      t = window.setTimeout(function() {
        callback($1, $2, $3, $4, $5);
        t = null;
      }, delay || 300);
    }
  };
}
function ifCheck(callback, context, checkMethods) {
  return (...args2) => {
    const ifResult = checkMethods.every((check2) => {
      return context[check2].apply(context, args2);
    });
    if (ifResult) {
      callback.apply(context, args2);
    }
  };
}
function makeRequestAnimationFrame(callback, context) {
  return (...args2) => {
    window.requestAnimationFrame(() => {
      callback.apply(context, args2);
    });
  };
}
function keyEach(obj2, callback) {
  Object.keys(obj2).forEach((key, index2) => {
    callback(key, obj2[key], index2);
  });
}
function keyMap(obj2, callback) {
  return Object.keys(obj2).map((key, index2) => {
    return callback(key, obj2[key], index2);
  });
}
function keyMapJoin(obj2, callback, joinString = "") {
  return keyMap(obj2, callback).join(joinString);
}
function get(obj2, key, callback) {
  var returnValue = defaultValue(obj2[key], key);
  if (isFunction(callback)) {
    return callback(returnValue);
  }
  return returnValue;
}
function defaultValue(value, defaultValue2) {
  return typeof value == "undefined" ? defaultValue2 : value;
}
function isUndefined(value) {
  return typeof value == "undefined";
}
function isNotUndefined(value) {
  return !isUndefined(value);
}
function isBoolean(value) {
  return typeof value == "boolean";
}
function isString(value) {
  return typeof value == "string";
}
function isNotString(value) {
  return !isString(value);
}
function isArray(value) {
  return Array.isArray(value);
}
function isObject(value) {
  return typeof value == "object" && !Array.isArray(value) && !isNumber(value) && !isString(value) && value !== null;
}
function isFunction(value) {
  return typeof value == "function";
}
function isNumber(value) {
  return typeof value == "number";
}
function isZero(num) {
  return num === 0;
}
function isNotZero(num) {
  return !isZero(num);
}
const CLONE_FUNCTION = (obj2) => JSON.parse(JSON.stringify(obj2));
function clone$1(obj2) {
  if (isUndefined(obj2))
    return void 0;
  return CLONE_FUNCTION(obj2);
}
function combineKeyArray(obj2) {
  Object.keys(obj2).forEach((key) => {
    if (Array.isArray(obj2[key])) {
      obj2[key] = obj2[key].join(", ");
    }
  });
  return obj2;
}
function classnames(...args2) {
  const result = [];
  args2.filter(Boolean).forEach((it) => {
    if (isObject(it)) {
      Object.keys(it).filter((k) => Boolean(it[k])).forEach((key) => {
        result.push(key);
      });
    } else if (isString(it)) {
      result.push(it);
    }
  });
  return result.join(" ");
}
const setBooleanProp = (el, name, value) => {
  if (value) {
    el.setAttribute(name, name);
    el[name] = value;
  } else {
    el.removeAttribute(name);
    el[name] = value;
  }
};
const setProp = (el, name, value) => {
  if (typeof value === "boolean") {
    setBooleanProp(el, name, value);
  } else {
    el.setAttribute(name, value);
  }
};
const removeBooleanProp = (node, name) => {
  node.removeAttribute(name);
  node[name] = false;
};
const removeUndefinedProp = (node, name) => {
  node.removeAttribute(name);
};
const removeProp = (node, name, value) => {
  if (typeof value === "boolean") {
    removeBooleanProp(node, name);
  } else if (name) {
    removeUndefinedProp(node, name);
  }
};
const updateProp = (node, name, newValue, oldValue) => {
  if (!newValue) {
    removeProp(node, name, oldValue);
  } else if (!oldValue || newValue !== oldValue) {
    setProp(node, name, newValue);
  } else
    ;
};
const updateProps = (node, newProps = {}, oldProps = {}) => {
  const keyList2 = [];
  keyList2.push.apply(keyList2, Object.keys(newProps));
  keyList2.push.apply(keyList2, Object.keys(oldProps));
  const props = new Set(keyList2);
  props.forEach((key) => {
    updateProp(node, key, newProps[key], oldProps[key]);
  });
};
function changed(node1, node2) {
  return node1.nodeType === window.Node.TEXT_NODE && node1.textContent !== node2.textContent || node1.nodeName !== node2.nodeName;
}
function hasPassed(node1) {
  if ((node1 == null ? void 0 : node1.nodeType) === 8) {
    return true;
  }
  return node1.nodeType !== window.Node.TEXT_NODE && node1.getAttribute("data-domdiff-pass") === "true";
}
function hasRefClass(node1) {
  return node1.nodeType !== window.Node.TEXT_NODE && node1.getAttribute("refClass");
}
function getProps(attributes) {
  var results = {};
  const len2 = attributes.length;
  for (let i = 0; i < len2; i++) {
    const t = attributes[i];
    results[t.name] = t.value;
  }
  return results;
}
function updateElement(parentElement, oldEl, newEl, i, options2 = {}) {
  if (!oldEl) {
    parentElement.appendChild(newEl.cloneNode(true));
  } else if (!newEl) {
    parentElement.removeChild(oldEl);
  } else if (hasPassed(oldEl) || hasPassed(newEl))
    ;
  else if (changed(newEl, oldEl) || hasRefClass(newEl)) {
    parentElement.replaceChild(newEl.cloneNode(true), oldEl);
  } else if (newEl.nodeType !== window.Node.TEXT_NODE && newEl.nodeType !== window.Node.COMMENT_NODE && newEl.toString() !== "[object HTMLUnknownElement]") {
    if (options2.checkPassed && options2.checkPassed(oldEl, newEl))
      ;
    else {
      updateProps(oldEl, getProps(newEl.attributes), getProps(oldEl.attributes));
    }
    var oldChildren = children(oldEl);
    var newChildren = children(newEl);
    var max = Math.max(oldChildren.length, newChildren.length);
    for (var index2 = 0; index2 < max; index2++) {
      updateElement(oldEl, oldChildren[index2], newChildren[index2], index2, options2);
    }
  }
}
const children = (el) => {
  var element = el.firstChild;
  if (!element) {
    return [];
  }
  var results = [];
  do {
    results.push(element);
    element = element.nextSibling;
  } while (element);
  return results;
};
function DomDiff(A, B, options2 = {}) {
  options2.checkPassed = isFunction(options2.checkPassed) ? options2.checkPassed : void 0;
  options2.removedElements = [];
  A = A.el || A;
  B = B.el || B;
  var childrenA = children(A);
  var childrenB = children(B);
  var len2 = Math.max(childrenA.length, childrenB.length);
  if (len2 === 0) {
    return;
  }
  if (childrenA.length === 0 && childrenB.length > 0) {
    A.append(...childrenB);
  } else {
    for (var i = 0; i < len2; i++) {
      updateElement(A, childrenA[i], childrenB[i], i, options2);
    }
  }
}
const UUID_REG$1 = /[xy]/g;
function uuid$1() {
  var dt = new Date().getTime();
  var uuid2 = "xxx12-xx-34xx".replace(UUID_REG$1, function(c2) {
    var r = (dt + Math.random() * 16) % 16 | 0;
    dt = Math.floor(dt / 16);
    return (c2 == "x" ? r : r & 3 | 8).toString(16);
  });
  return uuid2;
}
function uuidShort$1() {
  var dt = new Date().getTime();
  var uuid2 = "idxxxxxxx".replace(UUID_REG$1, function(c2) {
    var r = (dt + Math.random() * 16) % 16 | 0;
    dt = Math.floor(dt / 16);
    return (c2 == "x" ? r : r & 3 | 8).toString(16);
  });
  return uuid2;
}
const map = {};
const aliasMap = {};
const __rootInstance = /* @__PURE__ */ new Set();
const __tempVariables = /* @__PURE__ */ new Map();
const __tempVariablesGroup = /* @__PURE__ */ new Map();
const VARIABLE_SAPARATOR = "v:";
function variable$4(value, groupId = "") {
  const id = `${VARIABLE_SAPARATOR}${uuidShort$1()}`;
  __tempVariables.set(id, value);
  if (groupId) {
    __tempVariablesGroup.has(groupId) || __tempVariablesGroup.set(groupId, /* @__PURE__ */ new Set());
    __tempVariablesGroup.get(groupId).add(id);
  }
  return id;
}
function initializeGroupVariables(groupId) {
  if (__tempVariablesGroup.has(groupId)) {
    __tempVariablesGroup.get(groupId).forEach((id) => {
      __tempVariables.delete(id);
    });
    __tempVariablesGroup.delete(groupId);
  }
}
function recoverVariable(id, removeVariable = true) {
  if (isString(id) === false) {
    return id;
  }
  let value = id;
  if (__tempVariables.has(id)) {
    value = __tempVariables.get(id);
    if (removeVariable) {
      __tempVariables.delete(id);
    }
  }
  return value;
}
function getVariable(idOrValue) {
  if (__tempVariables.has(idOrValue)) {
    return __tempVariables.get(idOrValue);
  }
  return idOrValue;
}
function hasVariable(id) {
  return __tempVariables.has(id);
}
function spreadVariable(obj2) {
  return Object.entries(obj2).map(([key, value]) => {
    return `${key}=${variable$4(value)}`;
  }).join(" ");
}
function registElement(classes = {}) {
  Object.keys(classes).forEach((key) => {
    map[key] = classes[key];
  });
}
function replaceElement(module) {
  if (map[module.name]) {
    map[module.name] = module;
  }
}
function registAlias(a, b) {
  aliasMap[a] = b;
}
function retriveAlias(key) {
  return aliasMap[key];
}
function retriveElement(className) {
  return map[retriveAlias(className) || className];
}
function registRootElementInstance(instance) {
  __rootInstance.add(instance);
}
function getRootElementInstanceList() {
  return [...__rootInstance];
}
function renderRootElementInstance(module) {
  replaceElement(module);
  getRootElementInstanceList().forEach((instance) => {
    instance.hmr();
  });
}
class Dom {
  constructor(tag, className, attr) {
    if (typeof tag !== "string") {
      this.el = tag;
    } else {
      var el = document.createElement(tag);
      if (className) {
        el.className = className;
      }
      attr = attr || {};
      Object.assign(el, attr);
      this.el = el;
    }
  }
  static create(tag, className, attr) {
    return new Dom(tag, className, attr);
  }
  static createByHTML(htmlString) {
    var div2 = Dom.create("div");
    return div2.html(htmlString).firstChild;
  }
  static getScrollTop() {
    return Math.max(window.pageYOffset, document.documentElement.scrollTop, document.body.scrollTop);
  }
  static getScrollLeft() {
    return Math.max(window.pageXOffset, document.documentElement.scrollLeft, document.body.scrollLeft);
  }
  static parse(html) {
    var parser = window.DOMParser();
    return parser.parseFromString(html, "text/htmll");
  }
  static body() {
    return Dom.create(document.body);
  }
  get exists() {
    return Boolean(this.el);
  }
  setAttr(obj2) {
    Object.keys(obj2).forEach((key) => {
      this.attr(key, obj2[key]);
    });
    return this;
  }
  setAttrNS(obj2, namespace = "http://www.w3.org/2000/svg") {
    Object.keys(obj2).forEach((key) => {
      this.attr(key, obj2[key], namespace);
    });
    return this;
  }
  setProp(obj2) {
    Object.keys(obj2).forEach((key) => {
      if (this.el[key] != obj2[key]) {
        this.el[key] = obj2[key];
      }
    });
    return this;
  }
  data(key, value) {
    if (arguments.length === 1) {
      const value2 = this.attr("data-" + key);
      return recoverVariable(value2, false);
    } else if (arguments.length === 2) {
      return this.attr("data-" + key, value);
    }
    return this;
  }
  attr(...args2) {
    if (args2.length == 1) {
      return isFunction(this.el.getAttribute) && this.el.getAttribute(args2[0]);
    }
    if (this.el.getAttribute(args2[0]) != args2[1]) {
      this.el.setAttribute(args2[0], args2[1]);
    }
    return this;
  }
  attrNS(key, value, namespace = "http://www.w3.org/2000/svg") {
    if (arguments.length == 1) {
      return this.el.getAttributeNS(namespace, key);
    }
    if (this.el.getAttributeNS(namespace, key) != value) {
      this.el.setAttributeNS(namespace, key, value);
    }
    return this;
  }
  attrKeyValue(keyField) {
    return {
      [this.el.getAttribute(keyField)]: this.val()
    };
  }
  get attributes() {
    try {
      [...this.el.attributes];
      return this.el.attributes;
    } catch (e) {
      const length2 = this.el.attributes.length;
      const attributes = [];
      for (var i = 0; i < length2; i++) {
        attributes.push(this.el.attributes[`${i}`]);
      }
      return attributes;
    }
  }
  attrs(...args2) {
    return args2.map((key) => {
      return this.el.getAttribute(key);
    });
  }
  styles(...args2) {
    return args2.map((key) => {
      return this.el.style[key];
    });
  }
  removeAttr(key) {
    this.el.removeAttribute(key);
    return this;
  }
  removeStyle(key) {
    this.el.style.removeProperty(key);
    return this;
  }
  is(checkElement) {
    if (checkElement instanceof Dom) {
      return this.el === checkElement.el;
    }
    return this.el === checkElement;
  }
  isTag(tag) {
    return this.el.tagName.toLowerCase() === tag.toLowerCase();
  }
  closest(cls) {
    var temp = this;
    var checkCls = false;
    while (!(checkCls = temp.hasClass(cls))) {
      if (temp.el.parentNode) {
        temp = Dom.create(temp.el.parentNode);
      } else {
        return null;
      }
    }
    if (checkCls) {
      return temp;
    }
    return null;
  }
  path() {
    if (!this.el)
      return [];
    let pathList = [this];
    let $parentNode = this.parent();
    if (!$parentNode.el)
      return pathList;
    while ($parentNode) {
      pathList.unshift($parentNode);
      $parentNode = $parentNode.parent();
      if (!$parentNode.el)
        break;
    }
    return pathList;
  }
  get $parent() {
    return this.parent();
  }
  parent() {
    return Dom.create(this.el.parentNode);
  }
  hasParent() {
    return !!this.el.parentNode;
  }
  removeClass(...args2) {
    this.el.classList.remove(...args2);
    return this;
  }
  replaceClass(oldClass, newClass) {
    this.el.classList.replace(oldClass, newClass);
    return this;
  }
  hasClass(cls) {
    if (!this.el.classList)
      return false;
    return this.el.classList.contains(cls);
  }
  addClass(...args2) {
    this.el.classList.add(...args2);
    return this;
  }
  onlyOneClass(cls) {
    var parent = this.parent();
    parent.children().forEach((it) => {
      it.removeClass(cls);
    });
    this.addClass(cls);
  }
  toggleClass(cls, isForce) {
    this.el.classList.toggle(cls, isForce);
    return this;
  }
  outerHTML() {
    if (this.isTextNode) {
      return this.text();
    }
    return this.el.outerHTML;
  }
  html(html) {
    try {
      if (typeof html === "undefined") {
        return this.el.innerHTML;
      }
      if (typeof html === "string") {
        Object.assign(this.el, { innerHTML: html });
      } else {
        this.empty().append(html);
      }
      return this;
    } catch (e) {
      console.log(e, html);
      return this;
    }
  }
  htmlDiff(fragment2) {
    DomDiff(this, fragment2);
  }
  updateDiff(html, rootElement = "div", options2 = {}) {
    DomDiff(this, Dom.create(rootElement).html(html), options2);
  }
  updateSVGDiff(html, rootElement = "div") {
    DomDiff(this, Dom.create(rootElement).html(`<svg>${html}</svg>`).firstChild.firstChild);
  }
  find(selector2) {
    if (this.isTextNode)
      return void 0;
    return this.el.querySelector(selector2);
  }
  $(selector2) {
    var node = this.find(selector2);
    return node ? Dom.create(node) : null;
  }
  findAll(selector2) {
    if (this.isTextNode)
      return [];
    return Array.from(this.el.querySelectorAll(selector2));
  }
  $$(selector2) {
    var arr = this.findAll(selector2);
    return arr.map((node) => Dom.create(node));
  }
  empty() {
    while (this.el.firstChild)
      this.el.removeChild(this.el.firstChild);
    return this;
  }
  append(el) {
    if (typeof el === "string") {
      this.el.appendChild(document.createTextNode(el));
    } else {
      this.el.appendChild(el.el || el);
    }
    return this;
  }
  prepend(el) {
    if (typeof el === "string") {
      this.el.prepend(document.createTextNode(el));
    } else {
      this.el.prepend(el.el || el);
    }
    return this;
  }
  prependHTML(html) {
    var $dom = Dom.create("div").html(html);
    this.prepend($dom.createChildrenFragment());
    return $dom;
  }
  appendHTML(html) {
    var $dom = Dom.create("div").html(html);
    this.append($dom.createChildrenFragment());
    return $dom;
  }
  createChildrenFragment() {
    const list2 = this.childNodes;
    var fragment2 = document.createDocumentFragment();
    list2.forEach(($el) => fragment2.appendChild($el.el));
    return fragment2;
  }
  appendTo(target) {
    var t = target.el ? target.el : target;
    t.appendChild(this.el);
    return this;
  }
  remove() {
    if (this.el.parentNode) {
      this.el.parentNode.removeChild(this.el);
    }
    return this;
  }
  removeChild(el) {
    this.el.removeChild(el.el || el);
    return this;
  }
  text(value) {
    if (typeof value === "undefined") {
      return this.el.textContent;
    } else {
      var tempText = value;
      if (value instanceof Dom) {
        tempText = value.text();
      }
      if (this.el.textContent !== tempText) {
        this.el.textContent = tempText;
      }
      return this;
    }
  }
  css(key, value) {
    if (typeof key !== "undefined" && typeof value !== "undefined") {
      if (key.indexOf("--") === 0 && typeof value !== "undefined") {
        this.el.style.setProperty(key, value);
      } else {
        this.el.style[key] = value;
      }
    } else if (typeof key !== "undefined") {
      if (typeof key === "string") {
        return window.getComputedStyle(this.el)[key];
      } else {
        Object.entries(key).forEach(([localKey, value2]) => {
          if (localKey.indexOf("--") === 0 && typeof value2 !== "undefined") {
            this.el.style.setProperty(localKey, value2);
          } else {
            this.el.style[localKey] = value2;
          }
        });
      }
    }
    return this;
  }
  getComputedStyle(...list2) {
    var css = window.getComputedStyle(this.el);
    var obj2 = {};
    list2.forEach((it) => {
      obj2[it] = css[it];
    });
    return obj2;
  }
  getStyleList(...list2) {
    var style = {};
    var len2 = this.el.style.length;
    for (var i = 0; i < len2; i++) {
      var key = this.el.style[i];
      style[key] = this.el.style[key];
    }
    list2.forEach((key2) => {
      style[key2] = this.css(key2);
    });
    return style;
  }
  cssText(value) {
    if (typeof value === "undefined") {
      return this.el.style.cssText;
    }
    if (value != this.el.tempCssText) {
      this.el.style.cssText = value;
      this.el.tempCssText = value;
    }
    return this;
  }
  cssArray(arr) {
    if (arr[0])
      this.el.style[arr[0]] = arr[1];
    if (arr[2])
      this.el.style[arr[2]] = arr[3];
    if (arr[4])
      this.el.style[arr[4]] = arr[5];
    if (arr[6])
      this.el.style[arr[6]] = arr[7];
    if (arr[8])
      this.el.style[arr[8]] = arr[9];
    return this;
  }
  cssFloat(key) {
    return parseFloat(this.css(key));
  }
  cssInt(key) {
    return parseInt(this.css(key));
  }
  px(key, value) {
    return this.css(key, `${value}px`);
  }
  rect() {
    return this.el.getBoundingClientRect();
  }
  bbox() {
    return this.el.getBBox();
  }
  isSVG() {
    return this.el.tagName.toUpperCase() === "SVG";
  }
  offsetRect() {
    if (this.isSVG()) {
      const parentBox = this.parent().rect();
      const box = this.rect();
      return {
        x: box.x - parentBox.x,
        y: box.y - parentBox.y,
        width: box.width,
        height: box.height
      };
    }
    const el = this.el;
    return {
      x: el.offsetLeft,
      y: el.offsetTop,
      width: el.offsetWidth,
      height: el.offsetHeight
    };
  }
  offset() {
    var rect2 = this.rect();
    var scrollTop = Dom.getScrollTop();
    var scrollLeft = Dom.getScrollLeft();
    return {
      top: rect2.top + scrollTop,
      left: rect2.left + scrollLeft
    };
  }
  offsetLeft() {
    return this.offset().left;
  }
  offsetTop() {
    return this.offset().top;
  }
  position() {
    if (this.el.style.top) {
      return {
        top: parseFloat(this.css("top")),
        left: parseFloat(this.css("left"))
      };
    } else {
      return this.rect();
    }
  }
  size() {
    return [this.width(), this.height()];
  }
  width() {
    return this.el.offsetWidth || this.rect().width;
  }
  contentWidth() {
    return this.width() - this.cssFloat("padding-left") - this.cssFloat("padding-right");
  }
  height() {
    return this.el.offsetHeight || this.rect().height;
  }
  contentHeight() {
    return this.height() - this.cssFloat("padding-top") - this.cssFloat("padding-bottom");
  }
  val(value) {
    if (typeof value === "undefined") {
      return this.el.value;
    } else if (typeof value !== "undefined") {
      var tempValue = value;
      if (value instanceof Dom) {
        tempValue = value.val();
      }
      this.el.value = tempValue;
    }
    return this;
  }
  matches(selector2) {
    if (this.el) {
      if (!this.el.matches)
        return null;
      if (this.el.matches(selector2)) {
        return this;
      }
      return this.parent().matches(selector2);
    }
    return null;
  }
  get value() {
    return this.el.value;
  }
  get naturalWidth() {
    return this.el.naturalWidth;
  }
  get naturalHeight() {
    return this.el.naturalHeight;
  }
  get files() {
    return this.el.files ? [...this.el.files] : [];
  }
  get isTextNode() {
    return this.el.nodeType === 3;
  }
  realVal() {
    switch (this.el.nodeType) {
      case "INPUT":
        var type = this.attr("type");
        if (type == "checkbox" || type == "radio") {
          return this.checked();
        }
        return this.el.value;
      case "SELECT":
      case "TEXTAREA":
        return this.el.value;
    }
    return "";
  }
  int() {
    return parseInt(this.val(), 10);
  }
  float() {
    return parseFloat(this.val());
  }
  show(displayType = "block") {
    this.el.style.display = displayType != "none" ? displayType : "block";
    return this;
  }
  hide() {
    this.el.style.display = "none";
    return this;
  }
  isHide() {
    return this.el.style.display === "none";
  }
  isShow() {
    return !this.isHide();
  }
  toggle(isForce) {
    var currentHide = this.isHide();
    if (arguments.length == 1) {
      if (isForce) {
        return this.show();
      } else {
        return this.hide();
      }
    } else {
      if (currentHide) {
        return this.show();
      } else {
        return this.hide();
      }
    }
  }
  get totalLength() {
    return this.el.getTotalLength();
  }
  scrollIntoView() {
    this.el.scrollIntoView();
  }
  addScrollLeft(dt) {
    this.el.scrollLeft += dt;
    return this;
  }
  addScrollTop(dt) {
    this.el.scrollTop += dt;
    return this;
  }
  setScrollTop(scrollTop) {
    this.el.scrollTop = scrollTop;
    return this;
  }
  setScrollLeft(scrollLeft) {
    this.el.scrollLeft = scrollLeft;
    return this;
  }
  scrollTop() {
    if (this.el === document.body) {
      return Dom.getScrollTop();
    }
    return this.el.scrollTop;
  }
  scrollLeft() {
    if (this.el === document.body) {
      return Dom.getScrollLeft();
    }
    return this.el.scrollLeft;
  }
  scrollHeight() {
    return this.el.scrollHeight;
  }
  scrollWidth() {
    return this.el.scrollWidth;
  }
  on(eventName, callback, opt1, opt2) {
    this.el.addEventListener(eventName, callback, opt1, opt2);
    return this;
  }
  off(eventName, callback) {
    this.el.removeEventListener(eventName, callback);
    return this;
  }
  getElement() {
    return this.el;
  }
  createChild(tag, className = "", attrs = {}, css = {}) {
    let $element = Dom.create(tag, className, attrs);
    $element.css(css);
    this.append($element);
    return $element;
  }
  get firstChild() {
    return Dom.create(this.el.firstElementChild);
  }
  children() {
    var element = this.el.firstElementChild;
    if (!element) {
      return [];
    }
    var results = [];
    do {
      results.push(Dom.create(element));
      element = element.nextElementSibling;
    } while (element);
    return results;
  }
  get childNodes() {
    const result = [];
    if (this.el.hasChildNodes()) {
      const childNodes = this.el.childNodes;
      for (let i = 0; i < childNodes.length; i++) {
        result.push(Dom.create(childNodes[i]));
      }
    }
    return result;
  }
  childLength() {
    return this.el.children.length;
  }
  replace(newElement) {
    if (this.el.parentNode) {
      this.el.parentNode.replaceChild(newElement.el || newElement, this.el);
    }
    return this;
  }
  replaceChild(oldElement, newElement) {
    this.el.replaceChild(newElement.el || newElement, oldElement.el || oldElement);
    return this;
  }
  checked(isChecked = false) {
    if (arguments.length == 0) {
      return !!this.el.checked;
    }
    this.el.checked = !!isChecked;
    return this;
  }
  click() {
    this.el.click();
    return this;
  }
  focus() {
    this.el.focus();
    return this;
  }
  select() {
    if (this.attr("contenteditable") === "true") {
      var range = document.createRange();
      range.selectNodeContents(this.el);
      var sel = window.getSelection();
      sel.removeAllRanges();
      sel.addRange(range);
    } else {
      this.el.select();
    }
    return this;
  }
  blur() {
    this.el.blur();
    return this;
  }
  context(contextType = "2d") {
    if (!this._initContext) {
      this._initContext = this.el.getContext(contextType);
    }
    return this._initContext;
  }
  resize({ width: width2, height: height2 }) {
    this._initContext = null;
    var ctx = this.context();
    var scale2 = window.devicePixelRatio || 1;
    this.px("width", +width2);
    this.px("height", +height2);
    this.el.width = width2 * scale2;
    this.el.height = height2 * scale2;
    ctx.scale(scale2, scale2);
  }
  toDataURL(type = "image/png", quality = 1) {
    return this.el.toDataURL(type, quality);
  }
  clear() {
    this.context().clearRect(0, 0, this.el.width, this.el.height);
  }
  update(callback) {
    this.clear();
    callback.call(this, this);
  }
  drawImage(img, dx = 0, dy = 0) {
    var ctx = this.context();
    var scale2 = window.devicePixelRatio || 1;
    ctx.drawImage(img, dx, dy, img.width, img.height, 0, 0, this.el.width / scale2, this.el.height / scale2);
  }
  drawOption(option = {}) {
    var ctx = this.context();
    Object.assign(ctx, option);
  }
  drawLine(x1, y1, x2, y2) {
    var ctx = this.context();
    ctx.beginPath();
    ctx.moveTo(x1, y1);
    ctx.lineTo(x2, y2);
    ctx.stroke();
    ctx.closePath();
  }
  drawPath(...path) {
    var ctx = this.context();
    ctx.beginPath();
    path.forEach((p, index2) => {
      if (index2 == 0) {
        ctx.moveTo(p[0], p[1]);
      } else {
        ctx.lineTo(p[0], p[1]);
      }
    });
    ctx.stroke();
    ctx.fill();
    ctx.closePath();
  }
  drawCircle(cx, cy, r) {
    var ctx = this.context();
    ctx.beginPath();
    ctx.arc(cx, cy, r, 0, 2 * Math.PI);
    ctx.stroke();
    ctx.fill();
  }
  drawText(x, y, text2) {
    this.context().fillText(text2, x, y);
  }
  fullscreen() {
    var element = this.el;
    if (element.requestFullscreen) {
      element.requestFullscreen();
    } else if (element.wekitRequestFullscreen) {
      element.wekitRequestFullscreen();
    }
  }
  toggleFullscreen() {
    if (this.el === document.fullscreenElement) {
      document.exitFullscreen();
    } else {
      this.fullscreen();
    }
  }
}
class BaseStore {
  constructor(editor) {
    this.id = uuidShort$1();
    this.cachedCallback = {};
    this.callbacks = {};
    this.editor = editor;
    this.promiseProxy = new Proxy(this, {
      get: (target, key) => {
        return this.makePromiseEvent(key);
      }
    });
  }
  getCallbacks(event) {
    if (!this.callbacks[event]) {
      this.callbacks[event] = [];
    }
    return this.callbacks[event];
  }
  setCallbacks(event, list2 = []) {
    this.callbacks[event] = list2;
  }
  debug(...args2) {
    if (this.editor && this.editor.context.config.get("debug.mode")) {
      console.debug(...args2);
    }
  }
  on(event, originalCallback, context, debounceDelay = 0, throttleDelay = 0, enableAllTrigger = false, enableSelfTrigger = false, beforeMethods = [], frame = false) {
    var callback = originalCallback;
    if (debounceDelay > 0)
      callback = debounce(originalCallback, debounceDelay);
    else if (throttleDelay > 0)
      callback = throttle(originalCallback, throttleDelay);
    if (beforeMethods.length) {
      callback = ifCheck(callback, context, beforeMethods);
    }
    if (frame) {
      callback = makeRequestAnimationFrame(callback, context);
    }
    this.getCallbacks(event).push({
      event,
      callback,
      context,
      originalCallback,
      enableAllTrigger,
      enableSelfTrigger
    });
    return () => {
      this.off(event, originalCallback);
    };
  }
  off(event, originalCallback) {
    this.debug("off message event", event);
    if (arguments.length == 1) {
      this.setCallbacks(event);
    } else if (arguments.length == 2) {
      this.setCallbacks(event, this.getCallbacks(event).filter((f) => {
        return f.originalCallback !== originalCallback;
      }));
    }
  }
  offAll(context) {
    Object.keys(this.callbacks).forEach((event) => {
      this.setCallbacks(event, this.getCallbacks(event).filter((f) => {
        return f.context !== context;
      }));
    });
    this.debug("off all message", context.sourceName);
  }
  getCachedCallbacks(event) {
    return this.getCallbacks(event);
  }
  get promise() {
    return this.promiseProxy;
  }
  get p() {
    return this.promise;
  }
  makePromiseEvent(event) {
    var list2 = this.getCachedCallbacks(event);
    const source2 = this.source;
    return (...args2) => window.Promise.all(list2.filter((f) => {
      return !f.enableSelfTrigger;
    }).filter((f) => {
      return f.enableAllTrigger || f.originalCallback.source !== source2;
    }).map((f) => {
      return new window.Promise((resolve) => {
        resolve(f.callback.apply(f.context, args2));
      });
    }));
  }
  sendMessage(source2, event, ...args2) {
    this.sendMessageList(source2, [[event, ...args2]]);
  }
  runMessage(runnableFunction, args2) {
    const result = runnableFunction.callback.apply(runnableFunction.context, args2);
    if (isNotUndefined(result)) {
      if (result === false) {
        return;
      } else if (isFunction(result)) {
        result();
        return;
      }
    }
  }
  sendMessageList(source2, messages = []) {
    window.Promise.resolve().then(() => {
      messages.forEach(([event, ...args2]) => {
        var list2 = this.getCachedCallbacks(event);
        if (list2 && list2.length) {
          const runnableFunctions = list2.filter((f) => !f.enableSelfTrigger).filter((f) => f.enableAllTrigger || f.originalCallback.source !== source2);
          let i = runnableFunctions.length;
          while (i--) {
            const f = runnableFunctions[i];
            this.runMessage(f, args2);
          }
        } else {
          this.debug(`message event ${event} is not exist.`);
        }
      });
    });
  }
  nextSendMessage(source2, callback, ...args2) {
    window.Promise.resolve().then(() => {
      callback(...args2);
    });
  }
  triggerMessage(source2, event, ...args2) {
    window.Promise.resolve().then(() => {
      var list2 = this.getCachedCallbacks(event);
      if (list2) {
        const runnableFunctions = list2.filter((f) => f.originalCallback.source === source2);
        runnableFunctions.forEach((f) => {
          f.callback.apply(f.context, args2);
        });
      } else {
        this.debug(event, " is not valid event");
      }
    });
  }
  emit(event, ...args2) {
    if (isFunction(event)) {
      event(...args2);
    } else if (isArray(event)) {
      this.sendMessageList(this.source, event);
    } else {
      this.sendMessage(this.source, event, ...args2);
    }
  }
  nextTick(callback) {
    this.nextSendMessage(this.source, callback);
  }
  trigger(event, ...args2) {
    if (isFunction(event)) {
      event(...args2);
    } else {
      this.triggerMessage(this.source, event, ...args2);
    }
  }
}
const MAGIC_METHOD_REG = /^@magic:([a-zA-Z][a-zA-Z0-9]*)[\W]{1}(.*)*$/g;
const MAGIC_METHOD = "@magic:";
const SPLITTER = "|";
const FUNC_REGEXP = /(([\$a-z_\-]+)\([^\(\)]*\)|([a-z_\-]+))/gi;
const FUNC_START_CHARACTER = "(";
const FUNC_END_CHARACTER = ")";
const MAGICMETHOD_EXTRA = {
  KEYWORD: "keyword",
  FUNCTION: "function",
  VALUE: "value"
};
class MagicMethod {
  constructor(obj2) {
    this.context = obj2.context;
    this.originalMethod = obj2.originalMethod;
    this.method = obj2.method;
    this.args = obj2.args;
    this.pipes = obj2.pipes;
    this.keys = obj2.keys;
    this.__cache = /* @__PURE__ */ new Map();
  }
  setCache(key, value) {
    this.__cache.set(key, value);
  }
  hasCache(key) {
    return this.__cache.has(key);
  }
  getCache(key) {
    return this.__cache.get(key);
  }
  hasKeyword(keyword) {
    if (this.hasCache(keyword)) {
      return this.getCache(keyword);
    }
    let exists = false;
    this.pipes.forEach((pipe) => {
      switch (pipe.type) {
        case MAGICMETHOD_EXTRA.KEYWORD:
          if (pipe.value === keyword) {
            exists = true;
          }
          break;
      }
    });
    this.setCache(keyword, exists);
    return exists;
  }
  hasFunction(funcName) {
    if (this.hasCache(funcName)) {
      return this.getCache(funcName);
    }
    let exists = !!this.getFunction(funcName);
    this.setCache(funcName, exists);
    return exists;
  }
  getFunction(funcName) {
    return this.functions.find((pipe) => pipe.func === funcName);
  }
  getFunctionList(funcName) {
    return this.functions.filter((pipe) => pipe.func === funcName);
  }
  get originalCallback() {
    return this.context[this.originalMethod];
  }
  get keywords() {
    return this.keys[MAGICMETHOD_EXTRA.KEYWORD].map((pipe) => pipe.value);
  }
  get functions() {
    return this.keys[MAGICMETHOD_EXTRA.FUNCTION];
  }
  get values() {
    return this.keys[MAGICMETHOD_EXTRA.VALUE].map((pipe) => pipe.value);
  }
  execute(...args2) {
    return this.originalCallback.call(this.context, ...args2);
  }
  executeWithContext(context, ...args2) {
    return this.originalCallback.call(context, ...args2);
  }
  static make(str, ...args2) {
    return `${MAGIC_METHOD}${str} ${args2.join(SPLITTER)}`;
  }
  static check(str) {
    return str.match(MAGIC_METHOD_REG) !== null;
  }
  static parse(str, context = {}) {
    const matches2 = str.match(MAGIC_METHOD_REG);
    if (!matches2) {
      return void 0;
    }
    const result = matches2[0].split(MAGIC_METHOD)[1].split(SPLITTER).map((item) => item.trim());
    let [initializer, ...pipes] = result;
    const [method, ...args2] = initializer.split(" ");
    const pipeList = pipes.map((it) => {
      return this.parsePipe(it);
    }).filter((it) => it.value);
    const pipeObjects = {
      function: [],
      keyword: [],
      value: []
    };
    pipeList.forEach((pipe) => {
      if (pipe.type === "function") {
        pipeObjects.function.push(pipe);
      } else if (pipe.type === "keyword") {
        pipeObjects.keyword.push(pipe);
      } else {
        pipeObjects.value.push(pipe);
      }
    });
    return new MagicMethod({
      context,
      originalMethod: str,
      method,
      args: args2,
      pipes: pipeList,
      keys: pipeObjects
    });
  }
  static parsePipe(it) {
    const result = it.match(FUNC_REGEXP);
    if (!result) {
      return {
        type: "value",
        value: it
      };
    }
    const [value] = result;
    if (value.includes(FUNC_START_CHARACTER)) {
      const [func, rest] = value.split(FUNC_START_CHARACTER);
      const [args2] = rest.split(FUNC_END_CHARACTER);
      return {
        type: "function",
        value,
        func,
        args: args2.split(",").map((it2) => it2.trim()).filter(Boolean)
      };
    }
    return {
      type: "keyword",
      value: result[0]
    };
  }
}
const makeEventChecker = (value, split = SPLITTER) => {
  return ` ${split} ${value}`;
};
const MULTI_PREFIX = "ME@";
const PIPE = (...args2) => {
  return args2.join(SPLITTER);
};
const EVENT = (...args2) => {
  return MULTI_PREFIX + PIPE(...args2);
};
const COMMAND = EVENT;
const ON = EVENT;
const NAME_SAPARATOR = ":";
const SAPARATOR = " ";
const refManager = {};
const DOM_EVENT_MAKE = (...keys2) => {
  var key = keys2.join(NAME_SAPARATOR);
  return (...args2) => {
    const [selector2, ...result] = args2;
    return MagicMethod.make("domevent", [key, selector2].join(" "), ...result);
  };
};
const SUBSCRIBE_EVENT_MAKE = (...args2) => {
  return MagicMethod.make("subscribe", ...args2);
};
const CALLBACK_EVENT_MAKE = (...args2) => {
  return MagicMethod.make("callback", ...args2);
};
const OBSERVER_EVENT_MAKE = (...args2) => {
  return MagicMethod.make("observer", ...args2);
};
const CHECKER = (value, split = SPLITTER) => {
  return makeEventChecker(value, split);
};
const AFTER = (value, split = SPLITTER) => {
  return CHECKER(`after(${value})`, split);
};
const BEFORE = (value, split = SPLITTER) => {
  return CHECKER(`before(${value})`, split);
};
const IF = CHECKER;
const KEY = CHECKER;
const ARROW_UP = CHECKER("ArrowUp");
const ARROW_DOWN = CHECKER("ArrowDown");
const ARROW_LEFT = CHECKER("ArrowLeft");
const ARROW_RIGHT = CHECKER("ArrowRight");
const ENTER = CHECKER("Enter");
const SPACE = CHECKER("Space");
const ESCAPE = CHECKER("Escape");
const BACKSPACE = CHECKER("Backspace");
const DELETE = CHECKER("Delete");
const EQUAL = CHECKER("Equal");
const MINUS = CHECKER("Minus");
const BRACKET_RIGHT = CHECKER("BracketRight");
const BRACKET_LEFT = CHECKER("BracketLeft");
const ALT = CHECKER("isAltKey");
const SHIFT = CHECKER("isShiftKey");
const META = CHECKER("isMetaKey");
const CONTROL = CHECKER("isCtrlKey");
const MOUSE$1 = CHECKER("hasMouse");
const TOUCH$1 = CHECKER("hasTouch");
const PEN = CHECKER("hasPen");
const SELF = CHECKER("self");
const LEFT_BUTTON = CHECKER("isMouseLeftButton");
const RIGHT_BUTTON = CHECKER("isMouseRightButton");
const FIT = CHECKER("fit");
const PASSIVE = CHECKER("passive");
const DOMDIFF = CHECKER("domdiff");
const DEBOUNCE = (t = 100) => {
  return CHECKER(`debounce(${t})`);
};
const DELAY = (t = 300) => {
  return CHECKER(`delay(${t})`);
};
const D1000 = DEBOUNCE(1e3);
const THROTTLE = (t = 100) => {
  return CHECKER(`throttle(${t})`);
};
const ALL_TRIGGER = CHECKER("allTrigger()");
const SELF_TRIGGER = CHECKER("selfTrigger()");
const FRAME = CHECKER("frame()");
const PARAMS = (obj2) => {
  return CHECKER(`params(${variable$4(obj2)})`);
};
const CAPTURE = CHECKER("capture()");
const PREVENT = AFTER(`preventDefault`);
const STOP = AFTER(`stopPropagation`);
const SUBSCRIBE = SUBSCRIBE_EVENT_MAKE;
const SUBSCRIBE_ALL = (...args2) => SUBSCRIBE_EVENT_MAKE(...args2, ALL_TRIGGER);
const SUBSCRIBE_SELF = (...args2) => SUBSCRIBE_EVENT_MAKE(...args2, SELF_TRIGGER);
const CONFIG = (config, ...args2) => SUBSCRIBE_EVENT_MAKE(`config:${config}`, ...args2);
const CALLBACK = CALLBACK_EVENT_MAKE;
const RAF = CALLBACK("requestAnimationFrame");
const OBSERVER = OBSERVER_EVENT_MAKE;
const CUSTOM = DOM_EVENT_MAKE;
const CLICK = DOM_EVENT_MAKE("click");
const DOUBLECLICK = DOM_EVENT_MAKE("dblclick");
const MOUSEDOWN = DOM_EVENT_MAKE("mousedown");
const MOUSEUP = DOM_EVENT_MAKE("mouseup");
const MOUSEMOVE = DOM_EVENT_MAKE("mousemove");
const MOUSEOVER = DOM_EVENT_MAKE("mouseover");
const MOUSEOUT = DOM_EVENT_MAKE("mouseout");
const MOUSEENTER = DOM_EVENT_MAKE("mouseenter");
const MOUSELEAVE = DOM_EVENT_MAKE("mouseleave");
const TOUCHSTART = DOM_EVENT_MAKE("touchstart");
const TOUCHMOVE = DOM_EVENT_MAKE("touchmove");
const TOUCHEND = DOM_EVENT_MAKE("touchend");
const KEYDOWN = DOM_EVENT_MAKE("keydown");
const KEYUP = DOM_EVENT_MAKE("keyup");
const KEYPRESS = DOM_EVENT_MAKE("keypress");
const DRAG = DOM_EVENT_MAKE("drag");
const DRAGSTART = DOM_EVENT_MAKE("dragstart");
const DROP = DOM_EVENT_MAKE("drop");
const DRAGOVER = DOM_EVENT_MAKE("dragover");
const DRAGENTER = DOM_EVENT_MAKE("dragenter");
const DRAGLEAVE = DOM_EVENT_MAKE("dragleave");
const DRAGEXIT = DOM_EVENT_MAKE("dragexit");
const DRAGOUT = DOM_EVENT_MAKE("dragout");
const DRAGEND = DOM_EVENT_MAKE("dragend");
const CONTEXTMENU = DOM_EVENT_MAKE("contextmenu");
const CHANGE = DOM_EVENT_MAKE("change");
const INPUT = DOM_EVENT_MAKE("input");
const FOCUS = DOM_EVENT_MAKE("focus");
const FOCUSIN = DOM_EVENT_MAKE("focusin");
const FOCUSOUT = DOM_EVENT_MAKE("focusout");
const BLUR = DOM_EVENT_MAKE("blur");
const PASTE = DOM_EVENT_MAKE("paste");
const RESIZE = DOM_EVENT_MAKE("resize");
const SCROLL = DOM_EVENT_MAKE("scroll");
const SUBMIT = DOM_EVENT_MAKE("submit");
const POINTERSTART = (...args2) => {
  return CUSTOM("pointerdown")(...args2) + LEFT_BUTTON;
};
const POINTEROVER = CUSTOM("pointerover");
const POINTERENTER = CUSTOM("pointerenter");
const POINTEROUT = CUSTOM("pointerout");
const POINTERMOVE = CUSTOM("pointermove");
const POINTEREND = CUSTOM("pointerup");
const CHANGEINPUT = CUSTOM("change", "input");
const WHEEL = CUSTOM("wheel", "mousewheel", "DOMMouseScroll");
const ANIMATIONSTART = DOM_EVENT_MAKE("animationstart");
const ANIMATIONEND = DOM_EVENT_MAKE("animationend");
const ANIMATIONITERATION = DOM_EVENT_MAKE("animationiteration");
const TRANSITIONSTART = DOM_EVENT_MAKE("transitionstart");
const TRANSITIONEND = DOM_EVENT_MAKE("transitionend");
const TRANSITIONRUN = DOM_EVENT_MAKE("transitionrun");
const TRANSITIONCANCEL = DOM_EVENT_MAKE("transitioncancel");
const DOUBLETAB = CUSTOM("doubletab");
const LOAD = (value = "$el") => {
  return MagicMethod.make("load", value);
};
const getRef = (id) => {
  return refManager[id] || "";
};
const BIND_CHECK_FUNCTION = (field) => {
  return function() {
    return this.prevState[field] != this.state[field];
  };
};
const BIND_CHECK_DEFAULT_FUNCTION = () => {
  return true;
};
const BIND = (value = "$el") => {
  return MagicMethod.make("bind", value);
};
function normalizeWheelEvent(e) {
  let dx = e.deltaX;
  let dy = e.deltaY;
  if (dx === 0 && e.shiftKey) {
    [dy, dx] = [dx, dy];
  }
  if (e.deltaMode === window.WheelEvent.DOM_DELTA_LINE) {
    dy *= 8;
  } else if (e.deltaMode === window.WheelEvent.DOM_DELTA_PAGE) {
    dy *= 24;
  }
  return [limit(dx, 24), limit(dy, 24), 0];
}
function limit(delta, maxDelta) {
  return Math.sign(delta) * Math.min(maxDelta, Math.abs(delta));
}
var Event = {
  addDomEvent(dom, eventName, callback, useCapture = false) {
    if (dom) {
      dom.addEventListener(eventName, callback, useCapture);
    }
  },
  removeDomEvent(dom, eventName, callback) {
    if (dom) {
      dom.removeEventListener(eventName, callback);
    }
  },
  pos(e) {
    if (e.touches && e.touches[0]) {
      return e.touches[0];
    }
    return e;
  },
  posXY(e) {
    var pos = this.pos(e);
    return {
      x: pos.pageX,
      y: pos.pageY
    };
  }
};
class BaseHandler {
  constructor(context, options2 = {}) {
    this.context = context;
    this.options = options2;
  }
  initialize() {
  }
  load() {
  }
  refresh() {
  }
  render() {
  }
  getRef(id) {
    return this.context.getRef(id);
  }
  run() {
  }
  destroy() {
  }
}
const convertToPx = (key, value) => {
  if (isNumber(value)) {
    switch (key) {
      case "width":
      case "height":
      case "top":
      case "left":
      case "right":
      case "bottom":
        return value + "px";
    }
  }
  return value;
};
const applyElementAttribute = ($element, key, value, hasStyleAttribute = false) => {
  if (key === "cssText") {
    $element.cssText(value);
    return;
  } else if (key === "style") {
    if (typeof value !== "string") {
      const css = {};
      Object.entries(value).forEach(([key2, value2]) => {
        css[key2] = convertToPx(key2, value2);
      });
      if (hasStyleAttribute) {
        const styleText = Object.keys(css).map((key2) => {
          return `${key2}:${css[key2]};`;
        }).join("");
        $element.attr("style", styleText);
      } else {
        $element.css(css);
      }
    }
    return;
  } else if (key === "class") {
    if (Array.isArray(value)) {
      $element.addClass(...value.filter(Boolean));
    } else if (isObject(value)) {
      const keys2 = Object.keys(value);
      for (var i = 0, len2 = keys2.length; i < len2; i++) {
        const className = keys2[i];
        const hasClass = value[className];
        $element.toggleClass(className, hasClass);
      }
    } else {
      $element.el.className = value;
    }
    return;
  } else if (key === "callback") {
    if (typeof value === "function") {
      value();
      return;
    }
  }
  if (typeof value === "undefined") {
    $element.removeAttr(key);
  } else {
    if ($element.el.nodeName === "TEXTAREA" && key === "value") {
      $element.text(value);
    } else if (key === "text" || key === "textContent") {
      $element.text(value);
    } else if (key === "innerHTML" || key === "html") {
      $element.html(value);
    } else if (key === "htmlDiff") {
      $element.updateDiff(value);
    } else if (key === "svgDiff") {
      $element.updateSVGDiff(value);
    } else if (key === "value") {
      $element.val(value);
    } else {
      $element.attr(key, value);
    }
  }
};
const FunctionMap = {};
class BindHandler extends BaseHandler {
  async initialize() {
    if (!FunctionMap[this.context.sourceName]) {
      FunctionMap[this.context.sourceName] = this.context.filterMethodes("bind");
    }
  }
  getBindMethods() {
    return FunctionMap[this.context.sourceName] || [];
  }
  async bindData(...args2) {
    const list2 = this.getBindMethods();
    if (!(list2 == null ? void 0 : list2.length))
      return;
    const bindList = list2 == null ? void 0 : list2.filter((it) => {
      if (!args2.length)
        return true;
      return args2.indexOf(it.args[0]) > -1;
    });
    await Promise.all(bindList == null ? void 0 : bindList.map(async (magicMethod) => {
      let refObject = this.getRef(`${magicMethod.keywords[0]}`);
      let refCallback = BIND_CHECK_DEFAULT_FUNCTION;
      if (typeof refObject === "string" && refObject !== "") {
        refCallback = BIND_CHECK_FUNCTION(refObject);
      } else if (typeof refObject === "function") {
        refCallback = refObject;
      }
      const elName = magicMethod.args[0];
      let $element = this.context.refs[elName];
      const isBindCheck = typeof refCallback === "function" && refCallback.call(this.context);
      if ($element && isBindCheck) {
        const results = await magicMethod.executeWithContext(this.context, ...args2);
        if (!results)
          return;
        const keys2 = Object.keys(results);
        for (var elementKeyIndex = 0, len2 = keys2.length; elementKeyIndex < len2; elementKeyIndex++) {
          const key = keys2[elementKeyIndex];
          const value = results[key];
          applyElementAttribute($element, key, value, this.context.isServer);
        }
      }
    }));
  }
  destroy() {
    this._bindMethods = void 0;
  }
}
class CallbackHandler extends BaseHandler {
  initialize() {
    var _a, _b;
    this.destroy();
    if (!this._callbacks) {
      this._callbacks = this.context.filterMethodes("callback");
    }
    if (!((_a = this._bindings) == null ? void 0 : _a.length) && ((_b = this._callbacks) == null ? void 0 : _b.length)) {
      this._callbacks.forEach((key) => this.parseCallback(key));
    }
  }
  destroy() {
    if (this.context.notEventRedefine)
      ;
    else {
      this.removeCallbackAll();
    }
  }
  getCallback(field) {
    return this.context[field];
  }
  removeCallbackAll() {
    this.getBindings().forEach((obj2) => {
      this.removeCallback(obj2);
    });
    this.initBindings();
  }
  removeCallback({ requestId }) {
    window.cancelAnimationFrame(requestId);
  }
  getBindings() {
    if (!this._bindings) {
      this.initBindings();
    }
    return this._bindings;
  }
  addBinding(obj2) {
    this.getBindings().push(obj2);
  }
  initBindings() {
    this._bindings = [];
  }
  makeCallback(callbackObject) {
    const callback = callbackObject.callback;
    const run = (time) => {
      callback(time);
      callbackObject.requestId = window.requestAnimationFrame(run);
    };
    return () => {
      callbackObject.requestId = window.requestAnimationFrame(run);
    };
  }
  addCallback(callbackObject, magicMethod) {
    const callback = this.makeCallback(callbackObject, magicMethod);
    this.addBinding(callbackObject);
    callback();
  }
  bindingCallback(magicMethod, callback) {
    var _a, _b;
    const obj2 = {
      eventName: magicMethod.args[0],
      callback
    };
    obj2.codes = [];
    obj2.checkMethodList = [];
    const debounceFunction = magicMethod.getFunction("debounce");
    const throttleFunction = magicMethod.getFunction("throttle");
    if (debounceFunction) {
      var debounceTime = +(((_a = debounceFunction.args) == null ? void 0 : _a[0]) || 0);
      obj2.callback = debounce(callback, debounceTime);
    } else if (throttleFunction) {
      var throttleTime = +(((_b = throttleFunction.args) == null ? void 0 : _b[0]) || 0);
      obj2.callback = throttle(callback, throttleTime);
    }
    magicMethod.keywords.forEach((keyword) => {
      const method = keyword;
      if (this.getCallback(method)) {
        obj2.checkMethodList.push(method);
      } else {
        obj2.codes.push(method.toLowerCase());
      }
    });
    this.addCallback(obj2, magicMethod);
  }
  parseCallback(it) {
    const context = this.context;
    var arr = it.args;
    if (arr) {
      var originalCallback = context[it.originalMethod].bind(context);
      this.bindingCallback(it, originalCallback);
    }
  }
}
const scrollBlockingEvents = {
  touchstart: true,
  touchmove: true,
  mousedown: true,
  mouseup: true,
  mousemove: true
};
const eventConverts = {
  doubletab: "touchend"
};
const customEventNames = {
  doubletab: true
};
const selfCheckMethods = {
  self(e) {
    return e && e.$dt && e.$dt.is(e.target);
  },
  isAltKey(e) {
    return e.altKey;
  },
  isCtrlKey(e) {
    return e.ctrlKey;
  },
  isShiftKey(e) {
    return e.shiftKey;
  },
  isMetaKey(e) {
    return e.metaKey || e.key == "Meta" || e.code.indexOf("Meta") > -1;
  },
  isMouseLeftButton(e) {
    return e.buttons === 1;
  },
  isMouseRightButton(e) {
    return e.buttons === 2;
  },
  hasMouse(e) {
    return e.pointerType === "mouse";
  },
  hasTouch(e) {
    return e.pointerType === "touch";
  },
  hasPen(e) {
    return e.pointerType === "pen";
  },
  preventDefault(e) {
    e.preventDefault();
    return true;
  },
  stopPropagation(e) {
    e.stopPropagation();
    return true;
  }
};
class DomEventHandler extends BaseHandler {
  initialize() {
    var _a, _b;
    this.destroy();
    if (this._domEvents && this.context.notEventRedefine) {
      return;
    }
    if (!this._domEvents || this._domEvents.length === 0 || this._bindings.length === 0) {
      this._domEvents = this.context.filterMethodes("domevent");
    }
    if (!((_a = this._bindings) == null ? void 0 : _a.length) && ((_b = this._domEvents) == null ? void 0 : _b.length)) {
      this._domEvents.forEach((it) => this.parseDomEvent(it));
    }
  }
  destroy() {
    if (this.context.notEventRedefine)
      ;
    else {
      this.removeEventAll();
    }
  }
  getCallback(field) {
    return this.context[field] || selfCheckMethods[field];
  }
  removeEventAll() {
    this.getBindings().forEach((obj2) => {
      this.removeDomEvent(obj2);
    });
    this.initBindings();
  }
  removeDomEvent({ eventName, dom, callback }) {
    Event.removeDomEvent(dom, eventName, callback);
  }
  getBindings() {
    if (!this._bindings) {
      this.initBindings();
    }
    return this._bindings;
  }
  addBinding(obj2) {
    this.getBindings().push(obj2);
  }
  initBindings() {
    this._bindings = [];
  }
  matchPath(el, selector2) {
    if (el) {
      if (el.matches(selector2)) {
        return el;
      }
      return this.matchPath(el.parentElement, selector2);
    }
    return null;
  }
  hasDelegate(e, eventObject) {
    return this.matchPath(e.target || e.srcElement, eventObject.delegate);
  }
  makeCallback(eventObject, magicMethod, callback) {
    if (eventObject.delegate) {
      return this.makeDelegateCallback(eventObject, magicMethod, callback);
    } else {
      return this.makeDefaultCallback(eventObject, magicMethod, callback);
    }
  }
  makeDefaultCallback(eventObject, magicMethod, callback) {
    return (e) => {
      var returnValue = this.runEventCallback(e, eventObject, magicMethod, callback);
      if (isNotUndefined(returnValue)) {
        return returnValue;
      }
    };
  }
  makeDelegateCallback(eventObject, magicMethod, callback) {
    return (e) => {
      const delegateTarget = this.hasDelegate(e, eventObject);
      if (delegateTarget) {
        e.$dt = Dom.create(delegateTarget);
        var returnValue = this.runEventCallback(e, eventObject, magicMethod, callback);
        if (isNotUndefined(returnValue)) {
          return returnValue;
        }
      }
    };
  }
  runEventCallback(e, eventObject, magicMethod, callback) {
    const context = this.context;
    e.xy = Event.posXY(e);
    if (eventObject.beforeMethods.length) {
      eventObject.beforeMethods.every((before) => {
        return this.getCallback(before.target).call(context, e, before.param);
      });
    }
    if (this.checkEventType(e, eventObject)) {
      var returnValue = callback(e, e.$dt, e.xy);
      if (returnValue !== false && eventObject.afterMethods.length) {
        eventObject.afterMethods.forEach((after) => {
          return this.getCallback(after.target).call(context, e, after.param);
        });
      }
      return returnValue;
    }
  }
  checkEventType(e, eventObject) {
    const context = this.context;
    var hasKeyCode = true;
    if (eventObject.codes.length) {
      hasKeyCode = (e.code ? eventObject.codes.indexOf(e.code.toLowerCase()) > -1 : false) || (e.key ? eventObject.codes.indexOf(e.key.toLowerCase()) > -1 : false);
    }
    var isAllCheck = true;
    if (eventObject.checkMethodList.length) {
      isAllCheck = eventObject.checkMethodList.every((field) => {
        var fieldValue = this.getCallback(field);
        if (isFunction(fieldValue) && fieldValue) {
          return fieldValue.call(context, e);
        } else if (isNotUndefined(fieldValue)) {
          return !!fieldValue;
        }
        return true;
      });
    }
    return hasKeyCode && isAllCheck;
  }
  getDefaultDomElement(dom) {
    const context = this.context;
    let el;
    if (dom) {
      el = context.refs[dom] || context[dom] || window[dom];
    } else {
      el = context.el || context.$el || context.$root;
    }
    if (el instanceof Dom) {
      return el.getElement();
    }
    return el;
  }
  getRealEventName(eventName) {
    return eventConverts[eventName] || eventName;
  }
  getCustomEventName(eventName) {
    return customEventNames[eventName] ? eventName : "";
  }
  getDefaultEventObject(eventName, dom, delegate, magicMethod, callback) {
    var _a, _b;
    const obj2 = {
      eventName: this.getRealEventName(eventName),
      customEventName: this.getCustomEventName(eventName),
      callback
    };
    const [, , ...delegates] = magicMethod.args;
    obj2.dom = this.getDefaultDomElement(dom);
    obj2.delegate = delegates.join(SAPARATOR);
    obj2.beforeMethods = [];
    obj2.afterMethods = [];
    obj2.codes = [];
    obj2.checkMethodList = [];
    const debounceFunction = magicMethod.getFunction("debounce");
    const throttleFunction = magicMethod.getFunction("throttle");
    if (debounceFunction) {
      var debounceTime = +(((_a = debounceFunction.args) == null ? void 0 : _a[0]) || 0);
      obj2.callback = debounce(callback, debounceTime);
    } else if (throttleFunction) {
      var throttleTime = +(((_b = throttleFunction.args) == null ? void 0 : _b[0]) || 0);
      obj2.callback = throttle(callback, throttleTime);
    }
    const afterFunctionList = magicMethod.getFunctionList("after");
    const beforeFunctionList = magicMethod.getFunctionList("before");
    if (afterFunctionList.length) {
      afterFunctionList.forEach((afterFunction) => {
        var r = afterFunction.args[0].split(" ");
        var [target, param] = r;
        obj2.afterMethods.push({
          target,
          param
        });
      });
    }
    if (beforeFunctionList.length) {
      beforeFunctionList.forEach((beforeFunction) => {
        var r = beforeFunction.args[0].split(" ");
        var [target, param] = r;
        obj2.beforeMethods.push({
          target,
          param
        });
      });
    }
    magicMethod.keywords.forEach((keyword) => {
      const method = keyword;
      if (this.getCallback(method)) {
        obj2.checkMethodList.push(method);
      } else {
        obj2.codes.push(method.toLowerCase());
      }
    });
    return obj2;
  }
  addDomEvent(eventObject, magicMethod, callback) {
    eventObject.callback = this.makeCallback(eventObject, magicMethod, callback);
    this.addBinding(eventObject);
    var options2 = false;
    if (magicMethod.hasKeyword("capture")) {
      options2 = true;
    }
    if (scrollBlockingEvents[eventObject.eventName]) {
      options2 = {
        passive: true,
        capture: options2
      };
    }
    if (eventObject.dom) {
      Event.addDomEvent(eventObject.dom, eventObject.eventName, eventObject.callback, options2);
    }
  }
  makeCustomEventCallback(eventObject, magicMethod, callback) {
    var _a;
    if (eventObject.customEventName === "doubletab") {
      var delay = 300;
      var delayFunction = magicMethod.getFunction("delay");
      if (delayFunction) {
        delay = +(((_a = delayFunction.args) == null ? void 0 : _a[0]) || 0);
      }
      return (...args2) => {
        if (!this.doubleTab) {
          this.doubleTab = {
            time: window.performance.now()
          };
        } else {
          if (window.performance.now() - this.doubleTab.time < delay) {
            callback(...args2);
          }
          this.doubleTab = null;
        }
      };
    }
    return callback;
  }
  bindingDomEvent([eventName, dom, ...delegate], magicMethod, callback) {
    let eventObject = this.getDefaultEventObject(eventName, dom, delegate, magicMethod, callback);
    eventObject.callback = this.makeCustomEventCallback(eventObject, magicMethod, eventObject.callback);
    this.addDomEvent(eventObject, magicMethod, eventObject.callback);
  }
  getEventNames(eventName) {
    let results = [];
    eventName.split(NAME_SAPARATOR).forEach((e) => {
      var arr = e.split(NAME_SAPARATOR);
      results.push.apply(results, arr);
    });
    return results;
  }
  parseDomEvent(it) {
    const context = this.context;
    var arr = it.args;
    if (arr) {
      var eventNames = this.getEventNames(arr[0]);
      var callback = context[it.originalMethod].bind(context);
      for (let i = 0, len2 = eventNames.length; i < len2; i++) {
        arr[0] = eventNames[i];
        this.bindingDomEvent(arr, it, callback);
      }
    }
  }
}
class ObserverHandler extends BaseHandler {
  initialize() {
    var _a, _b;
    this.destroy();
    if (this._observers && this.context.notEventRedefine) {
      return;
    }
    if (!this._observers || this._observers.length === 0) {
      this._observers = this.context.filterMethodes("observer");
    }
    if (!((_a = this._bindings) == null ? void 0 : _a.length) && ((_b = this._observers) == null ? void 0 : _b.length)) {
      this._observers.forEach((it) => this.parseObserver(it));
    }
  }
  destroy() {
    if (this.context.notEventRedefine)
      ;
    else {
      this.removeEventAll();
    }
  }
  removeEventAll() {
    this.getBindings().forEach((observer) => {
      this.removeDomEvent(observer);
    });
    this.initBindings();
  }
  disconnectObserver(observer) {
    observer == null ? void 0 : observer.disconnect();
  }
  getBindings() {
    if (!this._bindings) {
      this.initBindings();
    }
    return this._bindings;
  }
  addBinding(obj2) {
    this.getBindings().push(obj2);
  }
  initBindings() {
    this._bindings = [];
  }
  addObserver(observer) {
    this.addBinding(observer);
  }
  getDefaultDomElement(dom) {
    const context = this.context;
    let el;
    if (dom) {
      el = context.refs[dom] || context[dom] || window[dom];
    } else {
      el = context.el || context.$el || context.$root;
    }
    if (el instanceof Dom) {
      return el.getElement();
    }
    return el;
  }
  createObserver(magicMethod, callback) {
    var _a;
    const [observerType, observerTarget] = magicMethod.args || ["intersection"];
    const $target = this.getDefaultDomElement(observerTarget);
    const params = magicMethod.getFunction("params");
    const options2 = getVariable((_a = params == null ? void 0 : params.args) == null ? void 0 : _a[0]);
    let observer;
    switch (observerType) {
      case "intersection":
        if (options2.root) {
          options2.root = this.getDefaultDomElement(options2.root);
        }
        observer = new window.IntersectionObserver(callback, options2 || {});
        observer.observe($target);
        break;
      case "mutation":
        observer = new window.MutationObserver(callback);
        observer.observe($target, options2 || {
          attributes: true,
          characterData: true,
          childList: true
        });
        break;
      case "performance":
        observer = new window.PerformanceObserver(callback);
        observer.observe(options2 || {
          entryTypes: ["paint"]
        });
        break;
    }
    return observer;
  }
  bindingObserver(magicMethod, callback) {
    this.addObserver(this.createObserver(magicMethod, callback));
  }
  parseObserver(it) {
    const context = this.context;
    var originalCallback = context[it.originalMethod].bind(context);
    this.bindingObserver(it, originalCallback);
  }
}
const REFERENCE_PROPERTY = "ref";
const TEMP_DIV = Dom.create("div");
const QUERY_PROPERTY = `[${REFERENCE_PROPERTY}]`;
const REF_CLASS = "refclass";
const REF_CLASS_PROPERTY = `[${REF_CLASS}]`;
const EMPTY_ARRAY = [];
const _EventMachine = class {
  constructor(opt, props) {
    __privateAdd(this, _refreshTimestamp);
    __privateAdd(this, _setProps);
    __privateAdd(this, _getProp);
    __privateAdd(this, _state, {});
    __privateAdd(this, _prevState, {});
    __privateAdd(this, _localTimestamp, 0);
    __privateAdd(this, _loadMethods, void 0);
    __privateAdd(this, _timestamp, void 0);
    __privateAdd(this, _cachedMethodList, void 0);
    __privateAdd(this, _props, {});
    __privateAdd(this, _propsKeys, {});
    __privateAdd(this, _isServer, false);
    __privateAdd(this, _propsKeyList, []);
    __privateAdd(this, _prefLoadTemplate, {});
    this.refs = {};
    this.children = {};
    this.id = uuid$1();
    this.initializeProperty(opt, props);
    this.handlers = this.initializeHandler();
    this.initComponents();
  }
  get __timestamp() {
    return __privateGet(this, _localTimestamp);
  }
  get timestamp() {
    return __privateGet(this, _timestamp);
  }
  set timestamp(value) {
    __privateSet(this, _timestamp, value);
  }
  get target() {
    return this.$el.el;
  }
  checkProps(props = {}) {
    return props;
  }
  initializeProperty(opt, props = {}) {
    this.opt = opt || {};
    this.parent = this.opt;
    this.source = uuid$1();
    this.sourceName = this.constructor.name;
    this.props = new Proxy(__privateGet(this, _props), {
      get: (target, key) => {
        return __privateMethod(this, _getProp, getProp_fn).call(this, key);
      },
      set: (target, key) => {
        throw new Error(`${key} is readonly`);
      }
    });
    __privateMethod(this, _setProps, setProps_fn).call(this, props);
  }
  hasProp(key) {
    return __privateGet(this, _propsKeyList).includes(key == null ? void 0 : key.toUpperCase());
  }
  setServer(isServer = true) {
    __privateSet(this, _isServer, isServer);
  }
  get isServer() {
    var _a;
    return ((_a = this.parent) == null ? void 0 : _a.isServer) || __privateGet(this, _isServer);
  }
  initComponents() {
    this.childComponents = this.components();
  }
  initializeHandler() {
    return [
      new BindHandler(this),
      new DomEventHandler(this),
      new CallbackHandler(this),
      new ObserverHandler(this)
    ];
  }
  initState() {
    return {};
  }
  setState(state = {}, isLoad = true) {
    __privateSet(this, _prevState, __privateGet(this, _state));
    __privateSet(this, _state, Object.assign({}, __privateGet(this, _state), state));
    if (isLoad) {
      this.load();
    }
  }
  toggleState(key, isLoad = true) {
    this.setState({
      [key]: !__privateGet(this, _state)[key]
    }, isLoad);
  }
  apply(obj2) {
    return spreadVariable(obj2);
  }
  _reload(props, $container = null) {
    if ($container) {
      this.render($container);
    }
    __privateMethod(this, _setProps, setProps_fn).call(this, props);
    __privateSet(this, _state, {});
    this.setState(this.initState(), false);
    this.refresh(true);
  }
  checkLoad($container) {
    window.requestAnimationFrame(() => {
      this.render($container);
    });
  }
  get state() {
    return __privateGet(this, _state);
  }
  get isPreLoaded() {
    return true;
  }
  async render($container) {
    if (!this.isPreLoaded) {
      this.checkLoad($container);
      return;
    }
    const template = this.template();
    const newDomElement = this.parseTemplate(template);
    if (this.$el) {
      this.$el.htmlDiff(newDomElement);
    } else {
      this.$el = newDomElement;
      this.refs.$el = this.$el;
      if ($container) {
        $container.append(this.$el);
      }
    }
    await this.load();
    this.afterRender();
    return this;
  }
  get html() {
    return this.$el.outerHTML();
  }
  initialize() {
    __privateSet(this, _state, this.initState());
  }
  afterRender() {
  }
  components() {
    return {};
  }
  getRef(...args2) {
    const key = args2.join("");
    return this.refs[key];
  }
  refreshElementReference(targetRef, refName) {
    var refs = targetRef.$$(QUERY_PROPERTY);
    for (var refsIndex = 0, refsLen = refs.length; refsIndex < refsLen; refsIndex++) {
      const $dom = refs[refsIndex];
      const name = $dom.attr(REFERENCE_PROPERTY);
      if (this.refs[name]) {
        if (this.refs[name].is($dom) === false) {
          this.refs[name] = $dom;
        }
      } else {
        this.refs[name] = $dom;
      }
    }
    this.afterLoadRendering(targetRef, refName);
  }
  afterLoadRendering() {
  }
  afterComponentRendering() {
  }
  parseTemplate(html, isLoad) {
    if (Array.isArray(html)) {
      html = html.join("");
    }
    html = (html || "").trim();
    const list2 = TEMP_DIV.html(html).childNodes || [];
    for (var i = 0, len2 = list2.length; i < len2; i++) {
      const $el = list2[i];
      var ref = $el.attr(REFERENCE_PROPERTY);
      if (ref) {
        if (!isLoad) {
          this.refs[ref] = $el;
        }
      }
      var refs = $el.$$(QUERY_PROPERTY);
      var temp = {};
      for (var refsIndex = 0, refsLen = refs.length; refsIndex < refsLen; refsIndex++) {
        const $dom = refs[refsIndex];
        const name = $dom.attr(REFERENCE_PROPERTY);
        if (temp[name]) {
          console.warn(`${ref} is duplicated. - ${this.sourceName}`, this);
        } else {
          temp[name] = true;
        }
        if (!isLoad) {
          this.refs[name] = $dom;
        }
      }
    }
    if (!isLoad) {
      return list2[0];
    }
    return TEMP_DIV.createChildrenFragment();
  }
  parsePropertyInfo($dom) {
    let props = {};
    for (var t of $dom.attributes) {
      const name = t.name || t.nodeName;
      const value = t.value || t.nodeValue;
      if (hasVariable(name)) {
        const recoveredValue = getVariable(name);
        if (isObject(recoveredValue)) {
          props = Object.assign(props, recoveredValue);
        } else {
          props[name] = getVariable(value);
        }
      } else {
        props[name] = getVariable(value);
      }
    }
    const content2 = $dom.html();
    if (content2) {
      props.content = content2;
      props.contentChildren = this.parseContent(props.content);
    }
    return props;
  }
  parseSourceName(obj2) {
    if (obj2.parent) {
      return [obj2.sourceName, ...this.parseSourceName(obj2.parent)];
    }
    return [obj2.sourceName];
  }
  getEventMachineComponent(refClassName) {
    var EventMachineComponent = retriveElement(refClassName) || this.childComponents[refClassName];
    return EventMachineComponent;
  }
  createFunctionComponent(EventMachineComponent, props, BaseClass = _EventMachine) {
    class FunctionElement extends BaseClass {
      template() {
        return EventMachineComponent.call(this, this.props);
      }
    }
    return new FunctionElement(this, props);
  }
  createInstanceForComponent(EventMachineComponent, targetElement, props) {
    if (EventMachineComponent.__proto__.name === "ProxyComponent") {
      return new EventMachineComponent({ target: targetElement, props });
    }
    if (EventMachineComponent.__proto__.name === "" && isFunction(EventMachineComponent)) {
      return this.createFunctionComponent(EventMachineComponent, props);
    }
    return new EventMachineComponent(this, props);
  }
  async renderComponent({ $dom, refName, component: component2, props }) {
    var _a;
    var instance = null;
    if (this.children[refName]) {
      instance = this.children[refName];
      instance.timestamp = this.__timestamp;
      instance._reload(props);
    } else {
      instance = this.createInstanceForComponent(component2, $dom.$parent.el, props);
      instance.timestamp = this.__timestamp;
      this.children[refName || instance.id] = instance;
      if (isFunction(instance.render)) {
        await instance.render();
      }
    }
    this.afterComponentRendering($dom, refName, instance, props);
    if (instance.renderTarget) {
      (_a = instance.$el) == null ? void 0 : _a.appendTo(instance.renderTarget);
      $dom.remove();
    } else if (instance.$el) {
      $dom.replace(instance.$el);
    } else {
      $dom.remove();
    }
  }
  parseContent(html, filteredRefClass = []) {
    return Dom.create("div").html(html).children().map(($dom) => {
      return this._getComponentInfo($dom);
    }).filter((it) => filteredRefClass.length === 0 ? true : filteredRefClass.includes(it.refClass));
  }
  _getComponentInfo($dom) {
    const refClass = $dom.attr(REF_CLASS);
    const EventMachineComponent = this.getEventMachineComponent(refClass);
    if (EventMachineComponent) {
      let props = this.parsePropertyInfo($dom);
      let refName = $dom.attr(REFERENCE_PROPERTY);
      return {
        $dom,
        refClass,
        props,
        refName: refName || props.ref,
        component: EventMachineComponent
      };
    } else {
      return {
        refClass,
        notUsed: true,
        $dom
      };
    }
  }
  getComponentInfoList($el) {
    if (!$el)
      return EMPTY_ARRAY;
    let targets = $el.$$(REF_CLASS_PROPERTY).filter((it) => {
      return it.path().filter((a) => {
        return a.attr(REF_CLASS);
      }).length === 1;
    });
    if (!targets.length) {
      return EMPTY_ARRAY;
    }
    return targets.map(($dom) => this._getComponentInfo($dom));
  }
  async parseComponent() {
    const $el = this.$el;
    const componentList = this.getComponentInfoList($el);
    if (!componentList.length)
      return;
    await Promise.all(componentList.map(async (comp) => {
      if (comp.notUsed) {
        comp.$dom.remove();
        console.warn(`${comp.refClass} is not used.`);
      } else {
        await this.renderComponent(comp);
      }
    }));
    keyEach(this.children, (key, child) => {
      if (child.timestamp !== this.__timestamp) {
        child.clean();
      }
    });
  }
  clean() {
    if (this.$el && !this.$el.hasParent()) {
      keyEach(this.children, (key, child) => {
        if (isFunction(child == null ? void 0 : child.clean)) {
          child.clean();
        }
      });
      this.destroy();
      return true;
    }
  }
  refresh() {
    this.load();
  }
  async _afterLoad() {
    __privateMethod(this, _refreshTimestamp, refreshTimestamp_fn).call(this);
    this.runHandlers("initialize");
    await this.bindData();
    await this.parseComponent();
  }
  async makeLoadAction(magicMethod) {
    const [elName, ...args2] = magicMethod.args;
    let isDomDiff = magicMethod.hasKeyword("domdiff");
    const refTarget = this.refs[elName];
    if (refTarget) {
      var newTemplate = await magicMethod.execute(...args2);
      if (Array.isArray(newTemplate)) {
        newTemplate = newTemplate.join("");
      }
      if (__privateGet(this, _prefLoadTemplate)[elName] != newTemplate) {
        __privateGet(this, _prefLoadTemplate)[elName] = newTemplate;
        const fragment2 = this.parseTemplate(newTemplate, true);
        if (isDomDiff) {
          refTarget.htmlDiff(fragment2);
        } else {
          refTarget.html(fragment2);
        }
      }
      this.refreshElementReference(refTarget, elName);
    }
  }
  async load(...args2) {
    if (!__privateGet(this, _loadMethods)) {
      __privateSet(this, _loadMethods, this.filterMethodes("load"));
    }
    const filtedLoadMethodList = __privateGet(this, _loadMethods).filter((it) => args2.length === 0 ? true : it.args[0] === args2[0]);
    await Promise.all(filtedLoadMethodList.map(async (magicMethod) => {
      await this.makeLoadAction(magicMethod);
    }));
    await this._afterLoad();
  }
  async runHandlers(func = "run", ...args2) {
    await Promise.all(this.handlers.filter((h) => h[func]).map(async (h) => {
      await h[func](...args2);
    }));
  }
  async bindData(...args2) {
    await this.runHandlers("bindData", ...args2);
  }
  template() {
    return null;
  }
  eachChildren(callback) {
    if (!isFunction(callback))
      return;
    Object.keys(this.children).forEach((key) => {
      callback(this.children[key]);
    });
  }
  hmr() {
    this.created();
    this.initialize();
    this.rerender();
    this.eachChildren((child) => {
      child.hmr();
    });
  }
  rerender() {
    var $parent = this.$el.parent();
    this.destroy();
    this.render($parent);
  }
  destroy() {
    this.eachChildren((childComponent) => {
      childComponent.destroy();
    });
    this.runHandlers("destroy");
    if (this.$el) {
      this.$el.remove();
    }
    this.$el = null;
    this.refs = {};
    this.children = {};
  }
  collectMethodes(refreshCache = false) {
    if (!__privateGet(this, _cachedMethodList) || refreshCache) {
      __privateSet(this, _cachedMethodList, collectProps(this, (name) => MagicMethod.check(name)).map((it) => {
        return MagicMethod.parse(it, this);
      }));
    }
    return __privateGet(this, _cachedMethodList);
  }
  filterMethodes(methodKey, refreshCache = false) {
    return this.collectMethodes(refreshCache).filter((it) => {
      return it.method === methodKey;
    });
  }
};
let EventMachine = _EventMachine;
_state = new WeakMap();
_prevState = new WeakMap();
_localTimestamp = new WeakMap();
_loadMethods = new WeakMap();
_timestamp = new WeakMap();
_cachedMethodList = new WeakMap();
_props = new WeakMap();
_propsKeys = new WeakMap();
_isServer = new WeakMap();
_propsKeyList = new WeakMap();
_prefLoadTemplate = new WeakMap();
_refreshTimestamp = new WeakSet();
refreshTimestamp_fn = function() {
  __privateWrapper(this, _localTimestamp)._++;
};
_setProps = new WeakSet();
setProps_fn = function(props) {
  __privateSet(this, _props, this.checkProps(props));
  __privateSet(this, _propsKeys, {});
  Object.keys(props).forEach((key) => {
    __privateGet(this, _propsKeys)[key.toUpperCase()] = key;
  });
  __privateSet(this, _propsKeyList, Object.keys(__privateGet(this, _propsKeys)));
};
_getProp = new WeakSet();
getProp_fn = function(key) {
  return __privateGet(this, _props)[__privateGet(this, _propsKeys)[key.toUpperCase()]];
};
const _UIElement = class extends EventMachine {
  constructor(opt, props = {}) {
    super(opt, props);
    __privateAdd(this, _subscribes, []);
    __privateAdd(this, _storeInstance, void 0);
    if (props.store) {
      __privateSet(this, _storeInstance, props.store);
    } else {
      __privateSet(this, _storeInstance, new BaseStore());
    }
    this.created();
    this.initialize();
  }
  async render($container) {
    await super.render($container);
    this.initializeStoreEvent();
    return this;
  }
  currentContext() {
    return this.contexts[this.contexts.length - 1];
  }
  setStore(storeInstance) {
    __privateSet(this, _storeInstance, storeInstance);
  }
  get $store() {
    return __privateGet(this, _storeInstance) || this.parent.$store;
  }
  async created() {
  }
  getRealEventName(e, separator) {
    var startIndex = e.indexOf(separator);
    return e.substr(startIndex < 0 ? 0 : startIndex + separator.length);
  }
  createLocalCallback(event, callback) {
    var newCallback = callback.bind(this);
    newCallback.displayName = `${this.sourceName}.${event}`;
    newCallback.source = this.source;
    return newCallback;
  }
  initializeStoreEvent() {
    if (__privateGet(this, _subscribes).length == 0) {
      __privateSet(this, _subscribes, this.filterMethodes("subscribe"));
      __privateGet(this, _subscribes).forEach((magicMethod) => {
        var _a, _b;
        const events = magicMethod.args.join(" ");
        const checkMethodList = [];
        const eventList = [];
        let debounce2 = 0;
        let throttle2 = 0;
        let isAllTrigger = false;
        let isSelfTrigger = false;
        let isFrameTrigger = false;
        const debounceFunction = magicMethod.getFunction("debounce");
        const throttleFunction = magicMethod.getFunction("throttle");
        const allTriggerFunction = magicMethod.getFunction("allTrigger");
        const selfTriggerFunction = magicMethod.getFunction("selfTrigger");
        const frameFunction = magicMethod.getFunction("frame");
        if (debounceFunction) {
          debounce2 = +(((_a = debounceFunction.args) == null ? void 0 : _a[0]) || 0);
        }
        if (throttleFunction) {
          throttle2 = +(((_b = throttleFunction.args) == null ? void 0 : _b[0]) || 0);
        }
        if (allTriggerFunction) {
          isAllTrigger = true;
        }
        if (selfTriggerFunction) {
          isSelfTrigger = true;
        }
        if (frameFunction) {
          isFrameTrigger = true;
        }
        magicMethod.keywords.forEach((keyword) => {
          const method = keyword;
          if (this[method]) {
            checkMethodList.push(method);
          } else {
            eventList.push(method);
          }
        });
        const originalCallback = this[magicMethod.originalMethod];
        [...eventList, events].filter(Boolean).forEach((e) => {
          var callback = this.createLocalCallback(e, originalCallback);
          this.$store.on(e, callback, this, debounce2, throttle2, isAllTrigger, isSelfTrigger, checkMethodList, isFrameTrigger);
        });
      });
    }
  }
  destoryStoreEvent() {
    this.$store.offAll(this);
  }
  destroy() {
    super.destroy();
    this.destoryStoreEvent();
  }
  rerender() {
    super.rerender();
    this.initialize();
    this.initializeStoreEvent();
  }
  emit(messageName, ...args2) {
    this.$store.source = this.source;
    this.$store.sourceContext = this;
    this.$store.emit(messageName, ...args2);
  }
  nextTick(callback, delay = 0) {
    window.setTimeout(() => {
      this.$store.nextTick(callback);
    }, delay);
  }
  trigger(messageName, ...args2) {
    this.$store.source = this.source;
    this.$store.trigger(messageName, ...args2);
  }
  broadcast(messageName, ...args2) {
    Object.keys(this.children).forEach((key) => {
      this.children[key].trigger(messageName, ...args2);
      this.children[key].broadcast(messageName, ...args2);
    });
  }
  on(message, callback, debounceDelay = 0, throttleDelay = 0, enableAllTrigger = false, enableSelfTrigger = false, frame = false) {
    this.$store.on(message, callback, this.source, debounceDelay, throttleDelay, enableAllTrigger, enableSelfTrigger, [], frame);
  }
  off(message, callback) {
    this.$store.off(message, callback, this.source);
  }
  subscribe(callback, debounceSecond = 0, throttleSecond = 0) {
    const id = `subscribe.${uuidShort$1()}`;
    const newCallback = this.createLocalCallback(id, callback);
    this.$store.on(id, newCallback, this, debounceSecond, throttleSecond, false, true);
    return id;
  }
  createFunctionComponent(EventMachineComponent, props, baseClass = _UIElement) {
    return super.createFunctionComponent(EventMachineComponent, props, baseClass);
  }
  static createElementInstance(ElementClass, props) {
    if (ElementClass.__proto__.name === "") {
      class FunctionElement extends _UIElement {
        template() {
          return ElementClass.call(this, this.props);
        }
      }
      return new FunctionElement(props, props);
    } else {
      return new ElementClass(props, props);
    }
  }
};
let UIElement = _UIElement;
_subscribes = new WeakMap();
_storeInstance = new WeakMap();
const start$1 = (ElementClass, opt) => {
  const $container = Dom.create(opt.container || document.body);
  const app = UIElement.createElementInstance(ElementClass, opt);
  app.render($container);
  registRootElementInstance(app);
  return app;
};
async function renderToString(ElementClass, opt) {
  const app = UIElement.createElementInstance(ElementClass, opt);
  app.setServer(true);
  const instance = await app.render();
  return instance.html;
}
function CSS_TO_STRING$1(style, postfix = "") {
  var newStyle = style || {};
  return Object.keys(newStyle).filter((key) => isNotUndefined(newStyle[key])).map((key) => `${key}: ${newStyle[key]}`).join(";" + postfix);
}
function OBJECT_TO_PROPERTY$1(obj2) {
  const target = obj2 || {};
  return Object.keys(target).map((key) => {
    if (key === "class") {
      if (isObject(obj2[key])) {
        return `${key}="${classnames(obj2[key])}"`;
      }
    }
    if (key === "style") {
      if (isObject(obj2[key])) {
        return `${key}="${CSS_TO_STRING$1(obj2[key])}"`;
      }
    }
    if (isBoolean(obj2[key]) || isUndefined(obj2[key]) || obj2[key] === "undefined") {
      if (obj2[key]) {
        return key;
      } else {
        return "";
      }
    }
    return `${key}="${obj2[key]}"`;
  }).join(" ");
}
function createComponent(ComponentName, props = {}, children2 = []) {
  children2 = children2.flat(Infinity).join("");
  let targetVariable;
  targetVariable = Object.keys(props).length ? variable$4(props) : "";
  const ref = props.ref ? `ref="${props.ref}"` : "";
  return `<object refClass="${ComponentName}" ${ref} ${targetVariable}>${children2}</object>`;
}
function createComponentList(...args2) {
  return args2.map((it) => {
    let ComponentName;
    let props = {};
    let children2 = [];
    if (isString(it)) {
      ComponentName = it;
    } else if (isArray(it)) {
      [ComponentName, props = {}, children2 = []] = it;
    }
    if (children2.length) {
      return createComponent(ComponentName, props, createComponentList(children2));
    }
    return createComponent(ComponentName, props);
  }).join("\n");
}
function createElement(Component2, props, children2 = []) {
  children2 = children2.flat(Infinity);
  return `<${Component2} ${OBJECT_TO_PROPERTY$1(props)}>${children2.join(" ")}</${Component2}>`;
}
function createElementJsx(Component2, props = {}, ...children2) {
  children2 = children2.flat(Infinity);
  if (Component2 === FragmentInstance) {
    return children2;
  }
  props = props || {};
  if (typeof Component2 !== "string") {
    const ComponentName = Component2.name;
    registElement({
      [ComponentName]: Component2
    });
    return createComponent(ComponentName, props, children2);
  } else {
    return createElement(Component2, props, children2);
  }
}
const FragmentInstance = new Object();
var index = "";
var BlankBodyPanel$1 = "";
var EPSILON = 1e-6;
var ARRAY_TYPE = typeof Float32Array !== "undefined" ? Float32Array : Array;
if (!Math.hypot)
  Math.hypot = function() {
    var y = 0, i = arguments.length;
    while (i--) {
      y += arguments[i] * arguments[i];
    }
    return Math.sqrt(y);
  };
function create$5() {
  var out = new ARRAY_TYPE(9);
  if (ARRAY_TYPE != Float32Array) {
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
  }
  out[0] = 1;
  out[4] = 1;
  out[8] = 1;
  return out;
}
function multiply$2(out, a, b) {
  var a00 = a[0], a01 = a[1], a02 = a[2];
  var a10 = a[3], a11 = a[4], a12 = a[5];
  var a20 = a[6], a21 = a[7], a22 = a[8];
  var b00 = b[0], b01 = b[1], b02 = b[2];
  var b10 = b[3], b11 = b[4], b12 = b[5];
  var b20 = b[6], b21 = b[7], b22 = b[8];
  out[0] = b00 * a00 + b01 * a10 + b02 * a20;
  out[1] = b00 * a01 + b01 * a11 + b02 * a21;
  out[2] = b00 * a02 + b01 * a12 + b02 * a22;
  out[3] = b10 * a00 + b11 * a10 + b12 * a20;
  out[4] = b10 * a01 + b11 * a11 + b12 * a21;
  out[5] = b10 * a02 + b11 * a12 + b12 * a22;
  out[6] = b20 * a00 + b21 * a10 + b22 * a20;
  out[7] = b20 * a01 + b21 * a11 + b22 * a21;
  out[8] = b20 * a02 + b21 * a12 + b22 * a22;
  return out;
}
function fromTranslation$1(out, v) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 1;
  out[5] = 0;
  out[6] = v[0];
  out[7] = v[1];
  out[8] = 1;
  return out;
}
function fromRotation$1(out, rad) {
  var s = Math.sin(rad), c2 = Math.cos(rad);
  out[0] = c2;
  out[1] = s;
  out[2] = 0;
  out[3] = -s;
  out[4] = c2;
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  out[8] = 1;
  return out;
}
function fromScaling$1(out, v) {
  out[0] = v[0];
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = v[1];
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  out[8] = 1;
  return out;
}
function create$4() {
  var out = new ARRAY_TYPE(16);
  if (ARRAY_TYPE != Float32Array) {
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
  }
  out[0] = 1;
  out[5] = 1;
  out[10] = 1;
  out[15] = 1;
  return out;
}
function fromValues$1(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
  var out = new ARRAY_TYPE(16);
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m03;
  out[4] = m10;
  out[5] = m11;
  out[6] = m12;
  out[7] = m13;
  out[8] = m20;
  out[9] = m21;
  out[10] = m22;
  out[11] = m23;
  out[12] = m30;
  out[13] = m31;
  out[14] = m32;
  out[15] = m33;
  return out;
}
function identity$3(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
function transpose(out, a) {
  if (out === a) {
    var a01 = a[1], a02 = a[2], a03 = a[3];
    var a12 = a[6], a13 = a[7];
    var a23 = a[11];
    out[1] = a[4];
    out[2] = a[8];
    out[3] = a[12];
    out[4] = a01;
    out[6] = a[9];
    out[7] = a[13];
    out[8] = a02;
    out[9] = a12;
    out[11] = a[14];
    out[12] = a03;
    out[13] = a13;
    out[14] = a23;
  } else {
    out[0] = a[0];
    out[1] = a[4];
    out[2] = a[8];
    out[3] = a[12];
    out[4] = a[1];
    out[5] = a[5];
    out[6] = a[9];
    out[7] = a[13];
    out[8] = a[2];
    out[9] = a[6];
    out[10] = a[10];
    out[11] = a[14];
    out[12] = a[3];
    out[13] = a[7];
    out[14] = a[11];
    out[15] = a[15];
  }
  return out;
}
function invert(out, a) {
  var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
  var a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
  var a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
  var a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];
  var b00 = a00 * a11 - a01 * a10;
  var b01 = a00 * a12 - a02 * a10;
  var b02 = a00 * a13 - a03 * a10;
  var b03 = a01 * a12 - a02 * a11;
  var b04 = a01 * a13 - a03 * a11;
  var b05 = a02 * a13 - a03 * a12;
  var b06 = a20 * a31 - a21 * a30;
  var b07 = a20 * a32 - a22 * a30;
  var b08 = a20 * a33 - a23 * a30;
  var b09 = a21 * a32 - a22 * a31;
  var b10 = a21 * a33 - a23 * a31;
  var b11 = a22 * a33 - a23 * a32;
  var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
  if (!det) {
    return null;
  }
  det = 1 / det;
  out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
  out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
  out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
  out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
  out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
  out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
  out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
  out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
  out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
  out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
  out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
  out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
  out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
  out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
  out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
  out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;
  return out;
}
function multiply$1(out, a, b) {
  var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
  var a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
  var a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
  var a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];
  var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
  out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  b0 = b[4];
  b1 = b[5];
  b2 = b[6];
  b3 = b[7];
  out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  b0 = b[8];
  b1 = b[9];
  b2 = b[10];
  b3 = b[11];
  out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  b0 = b[12];
  b1 = b[13];
  b2 = b[14];
  b3 = b[15];
  out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  return out;
}
function translate(out, a, v) {
  var x = v[0], y = v[1], z = v[2];
  var a00, a01, a02, a03;
  var a10, a11, a12, a13;
  var a20, a21, a22, a23;
  if (a === out) {
    out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
    out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
    out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
    out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
  } else {
    a00 = a[0];
    a01 = a[1];
    a02 = a[2];
    a03 = a[3];
    a10 = a[4];
    a11 = a[5];
    a12 = a[6];
    a13 = a[7];
    a20 = a[8];
    a21 = a[9];
    a22 = a[10];
    a23 = a[11];
    out[0] = a00;
    out[1] = a01;
    out[2] = a02;
    out[3] = a03;
    out[4] = a10;
    out[5] = a11;
    out[6] = a12;
    out[7] = a13;
    out[8] = a20;
    out[9] = a21;
    out[10] = a22;
    out[11] = a23;
    out[12] = a00 * x + a10 * y + a20 * z + a[12];
    out[13] = a01 * x + a11 * y + a21 * z + a[13];
    out[14] = a02 * x + a12 * y + a22 * z + a[14];
    out[15] = a03 * x + a13 * y + a23 * z + a[15];
  }
  return out;
}
function scale$1(out, a, v) {
  var x = v[0], y = v[1], z = v[2];
  out[0] = a[0] * x;
  out[1] = a[1] * x;
  out[2] = a[2] * x;
  out[3] = a[3] * x;
  out[4] = a[4] * y;
  out[5] = a[5] * y;
  out[6] = a[6] * y;
  out[7] = a[7] * y;
  out[8] = a[8] * z;
  out[9] = a[9] * z;
  out[10] = a[10] * z;
  out[11] = a[11] * z;
  out[12] = a[12];
  out[13] = a[13];
  out[14] = a[14];
  out[15] = a[15];
  return out;
}
function rotate$1(out, a, rad, axis) {
  var x = axis[0], y = axis[1], z = axis[2];
  var len2 = Math.hypot(x, y, z);
  var s, c2, t;
  var a00, a01, a02, a03;
  var a10, a11, a12, a13;
  var a20, a21, a22, a23;
  var b00, b01, b02;
  var b10, b11, b12;
  var b20, b21, b22;
  if (len2 < EPSILON) {
    return null;
  }
  len2 = 1 / len2;
  x *= len2;
  y *= len2;
  z *= len2;
  s = Math.sin(rad);
  c2 = Math.cos(rad);
  t = 1 - c2;
  a00 = a[0];
  a01 = a[1];
  a02 = a[2];
  a03 = a[3];
  a10 = a[4];
  a11 = a[5];
  a12 = a[6];
  a13 = a[7];
  a20 = a[8];
  a21 = a[9];
  a22 = a[10];
  a23 = a[11];
  b00 = x * x * t + c2;
  b01 = y * x * t + z * s;
  b02 = z * x * t - y * s;
  b10 = x * y * t - z * s;
  b11 = y * y * t + c2;
  b12 = z * y * t + x * s;
  b20 = x * z * t + y * s;
  b21 = y * z * t - x * s;
  b22 = z * z * t + c2;
  out[0] = a00 * b00 + a10 * b01 + a20 * b02;
  out[1] = a01 * b00 + a11 * b01 + a21 * b02;
  out[2] = a02 * b00 + a12 * b01 + a22 * b02;
  out[3] = a03 * b00 + a13 * b01 + a23 * b02;
  out[4] = a00 * b10 + a10 * b11 + a20 * b12;
  out[5] = a01 * b10 + a11 * b11 + a21 * b12;
  out[6] = a02 * b10 + a12 * b11 + a22 * b12;
  out[7] = a03 * b10 + a13 * b11 + a23 * b12;
  out[8] = a00 * b20 + a10 * b21 + a20 * b22;
  out[9] = a01 * b20 + a11 * b21 + a21 * b22;
  out[10] = a02 * b20 + a12 * b21 + a22 * b22;
  out[11] = a03 * b20 + a13 * b21 + a23 * b22;
  if (a !== out) {
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  }
  return out;
}
function rotateX(out, a, rad) {
  var s = Math.sin(rad);
  var c2 = Math.cos(rad);
  var a10 = a[4];
  var a11 = a[5];
  var a12 = a[6];
  var a13 = a[7];
  var a20 = a[8];
  var a21 = a[9];
  var a22 = a[10];
  var a23 = a[11];
  if (a !== out) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  }
  out[4] = a10 * c2 + a20 * s;
  out[5] = a11 * c2 + a21 * s;
  out[6] = a12 * c2 + a22 * s;
  out[7] = a13 * c2 + a23 * s;
  out[8] = a20 * c2 - a10 * s;
  out[9] = a21 * c2 - a11 * s;
  out[10] = a22 * c2 - a12 * s;
  out[11] = a23 * c2 - a13 * s;
  return out;
}
function rotateY(out, a, rad) {
  var s = Math.sin(rad);
  var c2 = Math.cos(rad);
  var a00 = a[0];
  var a01 = a[1];
  var a02 = a[2];
  var a03 = a[3];
  var a20 = a[8];
  var a21 = a[9];
  var a22 = a[10];
  var a23 = a[11];
  if (a !== out) {
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  }
  out[0] = a00 * c2 - a20 * s;
  out[1] = a01 * c2 - a21 * s;
  out[2] = a02 * c2 - a22 * s;
  out[3] = a03 * c2 - a23 * s;
  out[8] = a00 * s + a20 * c2;
  out[9] = a01 * s + a21 * c2;
  out[10] = a02 * s + a22 * c2;
  out[11] = a03 * s + a23 * c2;
  return out;
}
function rotateZ(out, a, rad) {
  var s = Math.sin(rad);
  var c2 = Math.cos(rad);
  var a00 = a[0];
  var a01 = a[1];
  var a02 = a[2];
  var a03 = a[3];
  var a10 = a[4];
  var a11 = a[5];
  var a12 = a[6];
  var a13 = a[7];
  if (a !== out) {
    out[8] = a[8];
    out[9] = a[9];
    out[10] = a[10];
    out[11] = a[11];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  }
  out[0] = a00 * c2 + a10 * s;
  out[1] = a01 * c2 + a11 * s;
  out[2] = a02 * c2 + a12 * s;
  out[3] = a03 * c2 + a13 * s;
  out[4] = a10 * c2 - a00 * s;
  out[5] = a11 * c2 - a01 * s;
  out[6] = a12 * c2 - a02 * s;
  out[7] = a13 * c2 - a03 * s;
  return out;
}
function fromTranslation(out, v) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = v[0];
  out[13] = v[1];
  out[14] = v[2];
  out[15] = 1;
  return out;
}
function fromScaling(out, v) {
  out[0] = v[0];
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = v[1];
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = v[2];
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
function fromRotation(out, rad, axis) {
  var x = axis[0], y = axis[1], z = axis[2];
  var len2 = Math.hypot(x, y, z);
  var s, c2, t;
  if (len2 < EPSILON) {
    return null;
  }
  len2 = 1 / len2;
  x *= len2;
  y *= len2;
  z *= len2;
  s = Math.sin(rad);
  c2 = Math.cos(rad);
  t = 1 - c2;
  out[0] = x * x * t + c2;
  out[1] = y * x * t + z * s;
  out[2] = z * x * t - y * s;
  out[3] = 0;
  out[4] = x * y * t - z * s;
  out[5] = y * y * t + c2;
  out[6] = z * y * t + x * s;
  out[7] = 0;
  out[8] = x * z * t + y * s;
  out[9] = y * z * t - x * s;
  out[10] = z * z * t + c2;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
function fromZRotation(out, rad) {
  var s = Math.sin(rad);
  var c2 = Math.cos(rad);
  out[0] = c2;
  out[1] = s;
  out[2] = 0;
  out[3] = 0;
  out[4] = -s;
  out[5] = c2;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
function getTranslation(out, mat) {
  out[0] = mat[12];
  out[1] = mat[13];
  out[2] = mat[14];
  return out;
}
function getScaling(out, mat) {
  var m11 = mat[0];
  var m12 = mat[1];
  var m13 = mat[2];
  var m21 = mat[4];
  var m22 = mat[5];
  var m23 = mat[6];
  var m31 = mat[8];
  var m32 = mat[9];
  var m33 = mat[10];
  out[0] = Math.hypot(m11, m12, m13);
  out[1] = Math.hypot(m21, m22, m23);
  out[2] = Math.hypot(m31, m32, m33);
  return out;
}
function getRotation(out, mat) {
  var scaling = new ARRAY_TYPE(3);
  getScaling(scaling, mat);
  var is1 = 1 / scaling[0];
  var is2 = 1 / scaling[1];
  var is3 = 1 / scaling[2];
  var sm11 = mat[0] * is1;
  var sm12 = mat[1] * is2;
  var sm13 = mat[2] * is3;
  var sm21 = mat[4] * is1;
  var sm22 = mat[5] * is2;
  var sm23 = mat[6] * is3;
  var sm31 = mat[8] * is1;
  var sm32 = mat[9] * is2;
  var sm33 = mat[10] * is3;
  var trace = sm11 + sm22 + sm33;
  var S = 0;
  if (trace > 0) {
    S = Math.sqrt(trace + 1) * 2;
    out[3] = 0.25 * S;
    out[0] = (sm23 - sm32) / S;
    out[1] = (sm31 - sm13) / S;
    out[2] = (sm12 - sm21) / S;
  } else if (sm11 > sm22 && sm11 > sm33) {
    S = Math.sqrt(1 + sm11 - sm22 - sm33) * 2;
    out[3] = (sm23 - sm32) / S;
    out[0] = 0.25 * S;
    out[1] = (sm12 + sm21) / S;
    out[2] = (sm31 + sm13) / S;
  } else if (sm22 > sm33) {
    S = Math.sqrt(1 + sm22 - sm11 - sm33) * 2;
    out[3] = (sm31 - sm13) / S;
    out[0] = (sm12 + sm21) / S;
    out[1] = 0.25 * S;
    out[2] = (sm23 + sm32) / S;
  } else {
    S = Math.sqrt(1 + sm33 - sm11 - sm22) * 2;
    out[3] = (sm12 - sm21) / S;
    out[0] = (sm31 + sm13) / S;
    out[1] = (sm23 + sm32) / S;
    out[2] = 0.25 * S;
  }
  return out;
}
function perspectiveNO(out, fovy, aspect2, near, far) {
  var f = 1 / Math.tan(fovy / 2), nf;
  out[0] = f / aspect2;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = f;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[15] = 0;
  if (far != null && far !== Infinity) {
    nf = 1 / (near - far);
    out[10] = (far + near) * nf;
    out[14] = 2 * far * near * nf;
  } else {
    out[10] = -1;
    out[14] = -2 * near;
  }
  return out;
}
var perspective = perspectiveNO;
function create$3() {
  var out = new ARRAY_TYPE(3);
  if (ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
  }
  return out;
}
function clone(a) {
  var out = new ARRAY_TYPE(3);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  return out;
}
function length(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  return Math.hypot(x, y, z);
}
function fromValues(x, y, z) {
  var out = new ARRAY_TYPE(3);
  out[0] = x;
  out[1] = y;
  out[2] = z;
  return out;
}
function add$1(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  return out;
}
function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  return out;
}
function multiply(out, a, b) {
  out[0] = a[0] * b[0];
  out[1] = a[1] * b[1];
  out[2] = a[2] * b[2];
  return out;
}
function divide(out, a, b) {
  out[0] = a[0] / b[0];
  out[1] = a[1] / b[1];
  out[2] = a[2] / b[2];
  return out;
}
function floor(out, a) {
  out[0] = Math.floor(a[0]);
  out[1] = Math.floor(a[1]);
  out[2] = Math.floor(a[2]);
  return out;
}
function round$2(out, a) {
  out[0] = Math.round(a[0]);
  out[1] = Math.round(a[1]);
  out[2] = Math.round(a[2]);
  return out;
}
function distance$1(a, b) {
  var x = b[0] - a[0];
  var y = b[1] - a[1];
  var z = b[2] - a[2];
  return Math.hypot(x, y, z);
}
function negate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  out[2] = -a[2];
  return out;
}
function normalize$3(out, a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  var len2 = x * x + y * y + z * z;
  if (len2 > 0) {
    len2 = 1 / Math.sqrt(len2);
  }
  out[0] = a[0] * len2;
  out[1] = a[1] * len2;
  out[2] = a[2] * len2;
  return out;
}
function dot$1(a, b) {
  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
}
function cross(out, a, b) {
  var ax = a[0], ay = a[1], az = a[2];
  var bx = b[0], by = b[1], bz = b[2];
  out[0] = ay * bz - az * by;
  out[1] = az * bx - ax * bz;
  out[2] = ax * by - ay * bx;
  return out;
}
function lerp$1(out, a, b, t) {
  var ax = a[0];
  var ay = a[1];
  var az = a[2];
  out[0] = ax + t * (b[0] - ax);
  out[1] = ay + t * (b[1] - ay);
  out[2] = az + t * (b[2] - az);
  return out;
}
function transformMat4(out, a, m) {
  var x = a[0], y = a[1], z = a[2];
  var w = m[3] * x + m[7] * y + m[11] * z + m[15];
  w = w || 1;
  out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;
  out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;
  out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;
  return out;
}
function equals$2(a, b) {
  var a0 = a[0], a1 = a[1], a2 = a[2];
  var b0 = b[0], b1 = b[1], b2 = b[2];
  return Math.abs(a0 - b0) <= EPSILON * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= EPSILON * Math.max(1, Math.abs(a2), Math.abs(b2));
}
var div$1 = divide;
var dist = distance$1;
var len = length;
(function() {
  var vec = create$3();
  return function(a, stride, offset, count, fn, arg) {
    var i, l;
    if (!stride) {
      stride = 3;
    }
    if (!offset) {
      offset = 0;
    }
    if (count) {
      l = Math.min(count * stride + offset, a.length);
    } else {
      l = a.length;
    }
    for (i = offset; i < l; i += stride) {
      vec[0] = a[i];
      vec[1] = a[i + 1];
      vec[2] = a[i + 2];
      fn(vec, vec, arg);
      a[i] = vec[0];
      a[i + 1] = vec[1];
      a[i + 2] = vec[2];
    }
    return a;
  };
})();
function create$2() {
  var out = new ARRAY_TYPE(4);
  if (ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
  }
  return out;
}
function normalize$2(out, a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  var w = a[3];
  var len2 = x * x + y * y + z * z + w * w;
  if (len2 > 0) {
    len2 = 1 / Math.sqrt(len2);
  }
  out[0] = x * len2;
  out[1] = y * len2;
  out[2] = z * len2;
  out[3] = w * len2;
  return out;
}
(function() {
  var vec = create$2();
  return function(a, stride, offset, count, fn, arg) {
    var i, l;
    if (!stride) {
      stride = 4;
    }
    if (!offset) {
      offset = 0;
    }
    if (count) {
      l = Math.min(count * stride + offset, a.length);
    } else {
      l = a.length;
    }
    for (i = offset; i < l; i += stride) {
      vec[0] = a[i];
      vec[1] = a[i + 1];
      vec[2] = a[i + 2];
      vec[3] = a[i + 3];
      fn(vec, vec, arg);
      a[i] = vec[0];
      a[i + 1] = vec[1];
      a[i + 2] = vec[2];
      a[i + 3] = vec[3];
    }
    return a;
  };
})();
function create$1() {
  var out = new ARRAY_TYPE(4);
  if (ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
  }
  out[3] = 1;
  return out;
}
function setAxisAngle(out, axis, rad) {
  rad = rad * 0.5;
  var s = Math.sin(rad);
  out[0] = s * axis[0];
  out[1] = s * axis[1];
  out[2] = s * axis[2];
  out[3] = Math.cos(rad);
  return out;
}
function getAxisAngle(out_axis, q) {
  var rad = Math.acos(q[3]) * 2;
  var s = Math.sin(rad / 2);
  if (s > EPSILON) {
    out_axis[0] = q[0] / s;
    out_axis[1] = q[1] / s;
    out_axis[2] = q[2] / s;
  } else {
    out_axis[0] = 1;
    out_axis[1] = 0;
    out_axis[2] = 0;
  }
  return rad;
}
function slerp(out, a, b, t) {
  var ax = a[0], ay = a[1], az = a[2], aw = a[3];
  var bx = b[0], by = b[1], bz = b[2], bw = b[3];
  var omega, cosom, sinom, scale0, scale1;
  cosom = ax * bx + ay * by + az * bz + aw * bw;
  if (cosom < 0) {
    cosom = -cosom;
    bx = -bx;
    by = -by;
    bz = -bz;
    bw = -bw;
  }
  if (1 - cosom > EPSILON) {
    omega = Math.acos(cosom);
    sinom = Math.sin(omega);
    scale0 = Math.sin((1 - t) * omega) / sinom;
    scale1 = Math.sin(t * omega) / sinom;
  } else {
    scale0 = 1 - t;
    scale1 = t;
  }
  out[0] = scale0 * ax + scale1 * bx;
  out[1] = scale0 * ay + scale1 * by;
  out[2] = scale0 * az + scale1 * bz;
  out[3] = scale0 * aw + scale1 * bw;
  return out;
}
function fromMat3(out, m) {
  var fTrace = m[0] + m[4] + m[8];
  var fRoot;
  if (fTrace > 0) {
    fRoot = Math.sqrt(fTrace + 1);
    out[3] = 0.5 * fRoot;
    fRoot = 0.5 / fRoot;
    out[0] = (m[5] - m[7]) * fRoot;
    out[1] = (m[6] - m[2]) * fRoot;
    out[2] = (m[1] - m[3]) * fRoot;
  } else {
    var i = 0;
    if (m[4] > m[0])
      i = 1;
    if (m[8] > m[i * 3 + i])
      i = 2;
    var j = (i + 1) % 3;
    var k = (i + 2) % 3;
    fRoot = Math.sqrt(m[i * 3 + i] - m[j * 3 + j] - m[k * 3 + k] + 1);
    out[i] = 0.5 * fRoot;
    fRoot = 0.5 / fRoot;
    out[3] = (m[j * 3 + k] - m[k * 3 + j]) * fRoot;
    out[j] = (m[j * 3 + i] + m[i * 3 + j]) * fRoot;
    out[k] = (m[k * 3 + i] + m[i * 3 + k]) * fRoot;
  }
  return out;
}
function fromEuler(out, x, y, z) {
  var halfToRad = 0.5 * Math.PI / 180;
  x *= halfToRad;
  y *= halfToRad;
  z *= halfToRad;
  var sx = Math.sin(x);
  var cx = Math.cos(x);
  var sy = Math.sin(y);
  var cy = Math.cos(y);
  var sz = Math.sin(z);
  var cz = Math.cos(z);
  out[0] = sx * cy * cz - cx * sy * sz;
  out[1] = cx * sy * cz + sx * cy * sz;
  out[2] = cx * cy * sz - sx * sy * cz;
  out[3] = cx * cy * cz + sx * sy * sz;
  return out;
}
var normalize$1 = normalize$2;
(function() {
  var tmpvec3 = create$3();
  var xUnitVec3 = fromValues(1, 0, 0);
  var yUnitVec3 = fromValues(0, 1, 0);
  return function(out, a, b) {
    var dot2 = dot$1(a, b);
    if (dot2 < -0.999999) {
      cross(tmpvec3, xUnitVec3, a);
      if (len(tmpvec3) < 1e-6)
        cross(tmpvec3, yUnitVec3, a);
      normalize$3(tmpvec3, tmpvec3);
      setAxisAngle(out, tmpvec3, Math.PI);
      return out;
    } else if (dot2 > 0.999999) {
      out[0] = 0;
      out[1] = 0;
      out[2] = 0;
      out[3] = 1;
      return out;
    } else {
      cross(tmpvec3, a, b);
      out[0] = tmpvec3[0];
      out[1] = tmpvec3[1];
      out[2] = tmpvec3[2];
      out[3] = 1 + dot2;
      return normalize$1(out, out);
    }
  };
})();
(function() {
  var temp1 = create$1();
  var temp2 = create$1();
  return function(out, a, b, c2, d, t) {
    slerp(temp1, a, d, t);
    slerp(temp2, b, c2, t);
    slerp(out, temp1, temp2, 2 * t * (1 - t));
    return out;
  };
})();
(function() {
  var matr = create$5();
  return function(out, view, right2, up) {
    matr[0] = right2[0];
    matr[3] = right2[1];
    matr[6] = right2[2];
    matr[1] = up[0];
    matr[4] = up[1];
    matr[7] = up[2];
    matr[2] = -view[0];
    matr[5] = -view[1];
    matr[8] = -view[2];
    return normalize$1(out, fromMat3(out, matr));
  };
})();
function create() {
  var out = new ARRAY_TYPE(2);
  if (ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
  }
  return out;
}
function distance(a, b) {
  var x = b[0] - a[0], y = b[1] - a[1];
  return Math.hypot(x, y);
}
function equals$1(a, b) {
  var a0 = a[0], a1 = a[1];
  var b0 = b[0], b1 = b[1];
  return Math.abs(a0 - b0) <= EPSILON * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1, Math.abs(a1), Math.abs(b1));
}
(function() {
  var vec = create();
  return function(a, stride, offset, count, fn, arg) {
    var i, l;
    if (!stride) {
      stride = 2;
    }
    if (!offset) {
      offset = 0;
    }
    if (count) {
      l = Math.min(count * stride + offset, a.length);
    } else {
      l = a.length;
    }
    for (i = offset; i < l; i += stride) {
      vec[0] = a[i];
      vec[1] = a[i + 1];
      fn(vec, vec, arg);
      a[i] = vec[0];
      a[i + 1] = vec[1];
    }
    return a;
  };
})();
var CanvasView$2 = "";
const ADD_BODY_FIRST_MOUSEMOVE = "add/body/first/mousemove";
const ADD_BODY_MOUSEMOVE = "add/body/mousemove";
const ADD_BODY_MOUSEUP = "add/body/mouseup";
const FIRSTMOVE = (method = "move") => {
  return AFTER(`bodyMouseFirstMove ${method}`);
};
const MOVE = (method = "move") => {
  return AFTER(`bodyMouseMove ${method}`);
};
const END = (method = "end") => {
  return AFTER(`bodyMouseUp ${method}`);
};
const UPDATE_VIEWPORT = "updateViewport";
const TOGGLE_FULLSCREEN = "toggle.fullscreen";
const REFRESH_SELECTION = "refreshSelection";
const REFRESH_SELECTION_TOOL = "refreshSelectionTool";
const REFRESH_CONTENT = "refreshContent";
const SHOW_COMPONENT_POPUP = "showComponentPopup";
const SHOW_NOTIFY = "showNotify";
const RESIZE_WINDOW = "resize.window";
const RESIZE_CANVAS = "resizeCanvas";
const UPDATE_CANVAS = "updateCanvas";
const OPEN_CONTEXT_MENU = "openContextMenu";
const START_GUESTURE = "startGuesture";
const END_GUESTURE = "endGuesture";
const KEYMAP_KEYDOWN = "keymapKeydown";
const KEYMAP_KEYUP = "keymapKeyup";
const SET_LOCALE = "setLocale";
const PUSH_MODE_VIEW = "pushModeView";
const POP_MODE_VIEW = "popModeView";
let osInfo = {
  name: void 0
};
function os() {
  if (osInfo.name === void 0) {
    if (window.navigator.appVersion.indexOf("Win") != -1)
      osInfo.name = "win";
    else if (window.navigator.appVersion.indexOf("Mac") != -1)
      osInfo.name = "mac";
    else if (window.navigator.appVersion.indexOf("X11") != -1)
      osInfo.name = "linux";
    else
      osInfo.name = "";
  }
  return osInfo.name;
}
const KEY_CODE = {
  backspace: 8,
  tab: 9,
  enter: 13,
  escape: 27,
  space: 32,
  pageup: 33,
  pagedown: 34,
  end: 35,
  home: 36,
  left: 37,
  up: 38,
  right: 39,
  down: 40,
  insert: 45,
  delete: 46,
  0: 48,
  1: 49,
  2: 50,
  3: 51,
  4: 52,
  5: 53,
  6: 54,
  7: 55,
  8: 56,
  9: 57,
  semicolon: 59,
  equals: 61,
  a: 65,
  b: 66,
  c: 67,
  d: 68,
  e: 69,
  f: 70,
  g: 71,
  h: 72,
  i: 73,
  j: 74,
  k: 75,
  l: 76,
  m: 77,
  n: 78,
  o: 79,
  p: 80,
  q: 81,
  r: 82,
  s: 83,
  t: 84,
  u: 85,
  v: 86,
  w: 87,
  x: 88,
  y: 89,
  z: 90,
  multiply: 106,
  add: 107,
  subtract: 109,
  divide: 111,
  f1: 112,
  f2: 113,
  f3: 114,
  f4: 115,
  f5: 116,
  f6: 117,
  f7: 118,
  f8: 119,
  f9: 120,
  f10: 121,
  f11: 122,
  f12: 123,
  f13: 124,
  f14: 125,
  f15: 126,
  f16: 127,
  f17: 128,
  f18: 129,
  f19: 130,
  comma: 188,
  ",": 188,
  period: 190,
  ".": 190,
  slash: 191,
  "/": 191,
  backquote: 192,
  "`": 192,
  openbracket: 219,
  "[": 219,
  backslash: 220,
  "\\": 220,
  closebracket: 221,
  "]": 221,
  quote: 222,
  "'": 222,
  altgr: 225
};
const keyAlias$1 = {
  ARROWRIGHT: "\u2192",
  ARROWLEFT: "\u2190",
  ARROWUP: "\u2191",
  ARROWDOWN: "\u2192",
  BACKSPACE: "\u232B",
  CMD: "\u2318",
  SHIFT: "\u21E7",
  CTRL: "\u2303",
  ALT: "\u2325",
  ENTER: "\u21B5",
  ESC: "\u238B",
  TAB: "\u21E5",
  SPACE: "\u2423",
  CAPSLOCK: "\u21EA",
  DELETE: "\u2326",
  INSERT: "\u2324",
  HOME: "\u21F1",
  END: "\u21F2",
  PAGEUP: "\u21DE",
  PAGEDOWN: "\u21DF",
  PRINTSCREEN: "\u2399",
  SCROLLLOCK: "\u21DE",
  PAUSE: "\u23CF",
  NUMLOCK: "\u21EA",
  META: "\u2318",
  WINDOWS: "\u2318",
  CONTEXTMENU: "\u2325",
  COMMAND: "\u2318"
};
const OSName$1 = os();
const KeyStringMaker = (item, os2 = OSName$1) => {
  return (item[os2] || item.key).split("+").map((it) => it.trim()).map((it) => {
    const keyString = it.toUpperCase();
    return keyAlias$1[keyString] || keyString;
  }).join(" ");
};
const Language = {
  EN: "en_US",
  FR: "fr_FR",
  KO: "ko_KR"
};
const EditingMode = {
  SELECT: "select",
  APPEND: "append",
  DRAW: "draw",
  PATH: "path"
};
const DesignMode = {
  EDIT: "edit",
  PREVIEW: "preview",
  DESIGN: "design",
  ITEM: "item"
};
const CanvasViewToolLevel = {
  DRAG_AREA: 0,
  RENDERING_AREA: 256,
  SELECTION_TOOL: 512,
  LAYOUT_TOOL: 768
};
const NotifyType = {
  ERROR: "error",
  INFO: "info",
  SUCCESS: "success",
  WARNING: "warning",
  ALERT: "alert"
};
const IntersectEpsilonNumberType = {
  RECT: 30
};
const ClipboardType = {
  TEXT: "text",
  IMAGE: "image",
  SVG: "svg",
  HTML: "html",
  JSON: "json"
};
const ClipboardActionType = {
  COPY: "copy",
  CUT: "cut"
};
const MenuItemType = {
  BUTTON: "button",
  LINK: "link",
  SEPARATOR: "separator",
  CHECKBOX: "checkbox",
  RADIO: "radio",
  SUBMENU: "submenu",
  DROPDOWN: "dropdown"
};
const ViewModeType = {
  CanvasView: "CanvasView",
  PathEditorView: "PathEditorView"
};
class EditorElement extends UIElement {
  get notEventRedefine() {
    return true;
  }
  get $editor() {
    if (!this.__cacheParentEditor) {
      let parentElement = this.parent;
      while (parentElement) {
        if (parentElement.$editor) {
          this.__cacheParentEditor = parentElement.$editor;
          break;
        }
        parentElement = parentElement.parent;
      }
    }
    return this.__cacheParentEditor;
  }
  get $context() {
    return this.$editor.context;
  }
  get $store() {
    return this.$context.store || this.parent.$store;
  }
  get localeKey() {
    return "";
  }
  getMessageKey(key) {
    if (this.localeKey) {
      return `${this.localeKey}.${key}`;
    }
    return key;
  }
  $i18n(key, params = {}, locale) {
    return this.$editor.getI18nMessage(this.getMessageKey(key), params, locale);
  }
  $initI18n(key) {
    return this.$editor.initI18nMessage(this.getMessageKey(key));
  }
  get $config() {
    return this.$context.config;
  }
  get $selection() {
    return this.$context.selection;
  }
  get $segmentSelection() {
    return this.$context.segmentSelection;
  }
  get $commands() {
    return this.$context.commands;
  }
  get $viewport() {
    return this.$context.viewport;
  }
  get $snapManager() {
    return this.$context.snapManager;
  }
  get $timeline() {
    return this.$context.timeline;
  }
  get $history() {
    return this.$context.history;
  }
  get $shortcuts() {
    return this.$context.shortcuts;
  }
  get $keyboardManager() {
    return this.$context.keyboardManager;
  }
  get $storageManager() {
    return this.$context.storageManager;
  }
  get $injectManager() {
    return this.$context.injectManager;
  }
  get $model() {
    return this.$context.modelManager;
  }
  get $lockManager() {
    return this.$context.lockManager;
  }
  get $visibleManager() {
    return this.$context.visibleManager;
  }
  get $modeView() {
    return this.$context.modeViewManager;
  }
  get $icon() {
    return this.$context.icon;
  }
  get $stateManager() {
    return this.$context.stateManager;
  }
  get $menu() {
    return this.$context.menuManager;
  }
  notify(type, title2, description, duration = 1e3) {
    this.emit(SHOW_NOTIFY, type, title2, description, duration);
  }
  alert(title2, description, duration = 1e3) {
    this.notify(NotifyType.ALERT, title2, description, duration);
  }
  $theme(key) {
    return this.$editor.themeValue(key);
  }
  bodyMouseFirstMove(e, methodName) {
    if (this[methodName]) {
      this.emit(ADD_BODY_FIRST_MOUSEMOVE, this[methodName], this, e.xy);
    }
  }
  bodyMouseMove(e, methodName) {
    if (this[methodName]) {
      this.emit(ADD_BODY_MOUSEMOVE, this[methodName], this, e.xy);
    }
  }
  bodyMouseUp(e, methodName) {
    if (this[methodName]) {
      this.emit(ADD_BODY_MOUSEUP, this[methodName], this, e.xy);
    }
  }
  createFunctionComponent(EventMachineComponent, props, baseClass = EditorElement) {
    return super.createFunctionComponent(EventMachineComponent, props, baseClass);
  }
}
class BlankCanvasView extends EditorElement {
  initState() {
    return {
      cursor: "auto",
      cursorArgs: []
    };
  }
  afterRender() {
    this.nextTick(() => {
      this.refreshCanvasSize();
      this.refreshCursor();
    });
  }
  template() {
    return /* @__PURE__ */ createElementJsx("div", {
      class: "elf--page-container",
      tabIndex: "-1",
      ref: "$container"
    }, /* @__PURE__ */ createElementJsx("div", {
      class: "page-view",
      ref: "$pageView"
    }, /* @__PURE__ */ createElementJsx("div", {
      class: "page-lock scrollbar",
      ref: "$lock"
    }, this.$injectManager.generate("canvas.view"))));
  }
  [BIND("$pageView")]() {
    return {
      style: {
        "--elf--canvas-background-color": this.$config.get("style.canvas.background.color")
      }
    };
  }
  checkSpace() {
    if (this.$context.config.get("set.tool.hand")) {
      return true;
    }
    return this.$context.keyboardManager.check(this.$context.shortcuts.getGeneratedKeyCode(KEY_CODE.space));
  }
  [POINTERSTART("$lock") + IF("checkSpace") + MOVE("movePan") + END("moveEndPan")]() {
    this.startMovePan();
  }
  [CONFIG("set.tool.hand")](value) {
    if (value) {
      this.startMovePan();
      this.$commands.emit("refreshCursor", "grab");
    } else {
      this.$commands.emit("recoverCursor", "auto");
    }
  }
  startMovePan() {
    this.lastDist = create$3();
  }
  movePan(dx, dy) {
    this.$commands.emit("refreshCursor", "grabbing");
    const currentDist = fromValues(dx, dy, 0);
    this.$context.viewport.pan(...transformMat4([], subtract([], this.lastDist, currentDist), this.$context.viewport.scaleMatrixInverse));
    this.lastDist = currentDist;
  }
  refreshCursor() {
    if (this.$context.config.get("set.tool.hand") === false) {
      this.$commands.emit("refreshCursor", "auto");
    } else {
      this.$commands.emit("refreshCursor", "grab");
    }
  }
  moveEndPan() {
    this.refreshCursor();
  }
  async [BIND("$container")]() {
    const cursor = await this.$context.cursorManager.load(this.state.cursor, ...this.state.cursorArgs || []);
    return {
      style: {
        cursor
      }
    };
  }
  [DRAGOVER("$lock") + PREVENT]() {
  }
  [DROP("$lock") + PREVENT](e) {
    const newCenter = this.$context.viewport.getWorldPosition(e);
    if (e.dataTransfer.getData("text/asset")) {
      this.$command.emit("drop.asset", {
        asset: { id: e.dataTransfer.getData("text/asset"), center: newCenter }
      });
    } else {
      const id = Dom.create(e.target).attr("data-id");
      if (id) {
        this.$command.emit("drop.asset", {
          gradient: e.dataTransfer.getData("text/gradient"),
          pattern: e.dataTransfer.getData("text/pattern"),
          color: e.dataTransfer.getData("text/color"),
          imageUrl: e.dataTransfer.getData("image/info")
        }, id);
      } else {
        const imageUrl = e.dataTransfer.getData("image/info");
        this.$command.emit("dropImageUrl", imageUrl);
      }
    }
  }
  [WHEEL("$lock") + PREVENT](e) {
    const [dx, dy] = normalizeWheelEvent(e);
    if (!this.state.gesture) {
      if (e.ctrlKey) {
        this.$context.viewport.setMousePoint(e.clientX, e.clientY);
      }
      this.emit("startGesture");
      this.state.gesture = true;
    } else {
      if (e.ctrlKey) {
        const zoomFactor = 1 - 2.5 * dy / 100;
        this.$context.viewport.zoom(zoomFactor);
      } else {
        const newDx = -2.5 * dx;
        const newDy = -2.5 * dy;
        this.$context.viewport.pan(-newDx / this.$viewport.scale, -newDy / this.$viewport.scale, 0);
      }
    }
    window.clearTimeout(this.state.timer);
    this.state.timer = window.setTimeout(() => {
      this.state.gesture = void 0;
      this.emit("endGesture");
    }, 200);
  }
  refreshCanvasSize() {
    this.$context.viewport.refreshCanvasSize(this.refs.$lock.rect());
  }
  [SUBSCRIBE(RESIZE_WINDOW, RESIZE_CANVAS)]() {
    this.refreshCanvasSize();
  }
  [CONFIG("editor.cursor")]() {
    this.state.cursor = this.$config.get("editor.cursor");
    this.state.cursorArgs = this.$config.get("editor.cursor.args");
    this.bindData("$container");
  }
  [CONFIG("editor.cursor.args")]() {
    this.state.cursor = this.$config.get("editor.cursor");
    this.state.cursorArgs = this.$config.get("editor.cursor.args");
    this.bindData("$container");
  }
  [SUBSCRIBE(UPDATE_VIEWPORT)]() {
    this.$commands.emit("refreshCursor", "auto");
  }
}
var PageSubEditor$1 = "";
class PageSubEditor extends EditorElement {
  template() {
    return `
      <div class='elf--page-subeditor'>
        ${this.$injectManager.generate("page.subeditor.view")}         
      </div>
    `;
  }
}
class BlankBodyPanel extends EditorElement {
  components() {
    return {
      BlankCanvasView,
      PageSubEditor
    };
  }
  template() {
    return `
      <div class="elf--body-panel">
        <div class="submenu-area">
          ${createComponent("PageSubEditor")}
        </div>
        <div class='editing-area'>
          <div class="canvas-layout">
            ${createComponent("BlankCanvasView")}
          </div>

        </div>
      </div>
    `;
  }
  [SUBSCRIBE(TOGGLE_FULLSCREEN)]() {
    this.refs.$el.toggleFullscreen();
  }
}
class BaseUI extends UIElement {
  get notEventRedefine() {
    return true;
  }
  getValue() {
    return this.props.defaultValue;
  }
  sendEvent() {
    const key = this.props.key;
    const value = this.getValue();
    const params = this.props.params;
    if (isFunction(this.props.onClick)) {
      this.props.onClick(key, value, params);
    } else if (this.props.command) {
      this.$commands.emit(this.props.command, ...this.props.args || []);
    } else if (isString(this.props.action)) {
      this.emit(this.props.action, key, value, params);
    } else if (isArray(this.props.action)) {
      this.emit(this.props.action.map((action) => [action, key, value, params]));
    } else {
      if (this.props.onChange) {
        this.parent.trigger(this.props.onChange, key, value, params);
      }
    }
  }
}
var Button$1 = "";
class Button extends BaseUI {
  initState() {
    return {
      label: this.props.label || "",
      text: this.props.text || "",
      params: this.props.params || ""
    };
  }
  template() {
    return `<div class='small-editor button' ref='$body'></div>`;
  }
  [LOAD("$body") + DOMDIFF]() {
    var { label, text: text2 } = this.state;
    var hasLabel = label ? "has-label" : "";
    return `
        <div class='elf--button ${hasLabel}'>
            ${label ? `<label title="${label}">${label}</label>` : ""}
            <div class='area'>
                <button type="button" >${text2 || label}</button>
            </div>
        </div>
    `;
  }
  getValue() {
    return this.props.defaultValue;
  }
  [CLICK("$el button")]() {
    this.sendEvent();
  }
}
var ToggleButton$1 = "";
const DEFAULT_LABELS$1 = ["True", "False"];
class ToggleButton extends BaseUI {
  initState() {
    return {
      checkedValue: this.props.checkedValue || this.props.value,
      checked: this.props.value || "false",
      toggleLabels: this.props.toggleLabels || DEFAULT_LABELS$1,
      toggleTitles: this.props.toggleTitles || [],
      toggleValues: this.props.toggleValues || ["true", "false"]
    };
  }
  template() {
    return /* @__PURE__ */ createElementJsx("div", {
      class: "small-editor button",
      ref: "$body"
    });
  }
  [LOAD("$body") + DOMDIFF]() {
    var { checked, checkedValue } = this.state;
    return `
        <div class='elf--toggle-button'>
            <div class='area' ref="$area">
                ${this.state.toggleValues.map((it, index2) => {
      let label = this.state.toggleLabels[index2];
      let title2 = this.state.toggleTitles[index2];
      return createElementJsx("div", {
        class: `${it === checked ? "visible" : ""} ${it === checkedValue ? "checked" : ""}`
      }, createElementJsx("button", {
        type: "button",
        "data-index": index2,
        class: it === checkedValue ? "checked" : "",
        value: it,
        title: title2,
        style: "--elf--toggle-checkbox-tooltip-top: -20%;"
      }, label));
    }).join("")}
            </div>
        </div>
    `;
  }
  [BIND("$area")]() {
    const selectedIndex = this.state.toggleValues.findIndex((v) => v === this.state.checked);
    return {
      "data-selected-index": selectedIndex
    };
  }
  setValue(checked) {
    this.setState({
      checked
    });
  }
  getValue() {
    return this.state.checked;
  }
  [CLICK("$el button") + PREVENT + STOP](e) {
    const value = e.$dt.value;
    const selectedIndex = this.state.toggleValues.findIndex((v) => v === value);
    const nextValue = this.state.toggleValues[(selectedIndex + 1) % this.state.toggleValues.length];
    this.setValue(nextValue);
    this.trigger("change");
  }
  [SUBSCRIBE_SELF("change")]() {
    this.sendEvent();
  }
}
var ToggleCheckBox$1 = "";
const DEFAULT_LABELS = ["True", "False"];
class ToggleCheckBox extends BaseUI {
  initState() {
    return {
      label: this.props.label || "",
      checked: this.props.value || false,
      toggleLabels: this.props.toggleLabels || DEFAULT_LABELS,
      toggleTitles: this.props.toggleTitles || [],
      toggleValues: this.props.toggleValues || [true, false]
    };
  }
  template() {
    return /* @__PURE__ */ createElementJsx("div", {
      class: "small-editor button",
      ref: "$body"
    });
  }
  [LOAD("$body")]() {
    var { label, checked } = this.state;
    var hasLabel = label ? "has-label" : "";
    return `
        <div class='elf--toggle-checkbox ${hasLabel}'>
            ${label ? `<label title="${label}">${label}</label>` : ""}
            <div class='area' ref="$area">
                ${this.state.toggleValues.map((it, index2) => {
      let label2 = this.state.toggleLabels[index2];
      let title2 = this.state.toggleTitles[index2];
      return createElementJsx("div", null, createElementJsx("button", {
        type: "button",
        class: `${it === checked ? "checked" : ""}`,
        "data-index": index2,
        title: title2,
        style: "--elf--toggle-checkbox-tooltip-top: -20%;"
      }, label2));
    }).join("")}
            </div>
        </div>
    `;
  }
  [BIND("$area")]() {
    const selectedIndex = this.state.toggleValues.findIndex((v) => v === this.state.checked);
    const unit = 100 / this.state.toggleValues.length;
    return {
      "data-selected-index": selectedIndex,
      cssText: `
                --unit-count: ${this.state.toggleValues.length};
                --button-font-size: ${13 - this.state.toggleValues.length}px ;
                --selected-button-size: ${1 / this.state.toggleValues.length * 100}%;
                --selected-button-position: ${selectedIndex * unit}%;
            `
    };
  }
  setValue(checked) {
    this.setState({
      checked
    });
  }
  getValue() {
    return this.state.checked;
  }
  [CLICK("$el button")](e) {
    const index2 = +e.$dt.data("index");
    this.setValue(this.state.toggleValues[index2]);
    this.trigger("change");
  }
  [SUBSCRIBE_SELF("change")]() {
    this.sendEvent();
  }
}
class TabPanel extends UIElement {
  initState() {
    return {
      value: this.props.value || ""
    };
  }
  template() {
    const { content: content2 } = this.props;
    const { value } = this.state;
    return /* @__PURE__ */ createElementJsx("div", {
      class: "tab-content scrollbar",
      "data-value": value
    }, content2);
  }
}
var Tabs$1 = "";
class Tabs extends UIElement {
  afterRender() {
    window.setTimeout(() => {
      this.setValue(this.state.selectedValue);
    }, 0);
  }
  initState() {
    return {
      type: this.props.type || "number",
      direction: this.props.direction || "",
      selectedValue: this.props.selectedValue || ""
    };
  }
  template() {
    return `
        <div class="tab number ${this.state.type === "side" ? `number-tab side-tab` : ""} side-tab-${this.state.direction}" ref="$tab"></div>
      `;
  }
  [LOAD("$tab")]() {
    const { content: content2, contentChildren = [] } = this.props;
    const children2 = contentChildren.filter((it) => it.component === TabPanel);
    return [
      /* @__PURE__ */ createElementJsx("div", {
        class: "tab-header",
        ref: "$header"
      }, children2.map((it) => /* @__PURE__ */ createElementJsx("div", {
        class: "tab-item",
        "data-value": it.props.value,
        title: it.props.title
      }, /* @__PURE__ */ createElementJsx("label", {
        class: "title"
      }, it.props.icon || it.props.title)))),
      /* @__PURE__ */ createElementJsx("div", {
        class: "tab-body",
        ref: "$body"
      }, content2)
    ];
  }
  [CLICK("$header .tab-item:not(.empty-item)")](e) {
    var selectedValue = e.$dt.attr("data-value");
    this.setValue(selectedValue);
  }
  updateData(data) {
    this.setState(data, false);
    this.parent.trigger(this.props.onchange, this.getValue());
  }
  getValue() {
    return this.state.selectedValue;
  }
  setValue(selectedValue) {
    var _a, _b;
    (_a = this.$el.$(`* > .tab-item[data-value="${selectedValue}"]`)) == null ? void 0 : _a.onlyOneClass("selected");
    (_b = this.$el.$(`* > .tab-content[data-value="${selectedValue}"]`)) == null ? void 0 : _b.onlyOneClass("selected");
    this.updateData({ selectedValue });
  }
}
class BlankInspector extends EditorElement {
  afterRender() {
    this.$el.toggle(this.$config.is("editor.design.mode", DesignMode.DESIGN));
  }
  [BIND("$el")]() {
    return {
      style: {
        display: this.$config.is("editor.design.mode", DesignMode.DESIGN) ? "block" : "none"
      }
    };
  }
  template() {
    return /* @__PURE__ */ createElementJsx("div", {
      class: "feature-control inspector"
    }, /* @__PURE__ */ createElementJsx("div", null, /* @__PURE__ */ createElementJsx(Tabs, {
      ref: "$tab",
      selectedValue: this.$config.get("inspector.selectedValue"),
      onchange: (value) => {
        this.$config.set("inspector.selectedValue", value);
      }
    }, this.$injectManager.getTargetUI("inspector.tab").map((it) => {
      const { value, title: title2, icon, loadElements = [] } = it.class;
      return /* @__PURE__ */ createElementJsx(TabPanel, {
        value,
        title: title2,
        icon
      }, /* @__PURE__ */ createElementJsx("div", {
        style: "display: flex: flex-direction: column;"
      }, loadElements == null ? void 0 : loadElements.map((element) => createElement(element)), this.$injectManager.generate("inspector.tab." + value), /* @__PURE__ */ createElementJsx("div", {
        class: "empty",
        style: "order: 1000000;"
      })));
    }))));
  }
}
class BlankLayerTab extends EditorElement {
  template() {
    return /* @__PURE__ */ createElementJsx("div", {
      class: "layer-tab"
    }, /* @__PURE__ */ createElementJsx(Tabs, {
      ref: "$tab",
      type: "side",
      direction: "left",
      selectedValue: this.$config.get("layertab.selectedValue"),
      onchange: (value) => {
        this.$config.set("layertab.selectedValue", value);
      }
    }, this.$injectManager.getTargetUI("layertab.tab").map((it) => {
      const { value, title: title2, icon, loadElements = [] } = it.class;
      return /* @__PURE__ */ createElementJsx(TabPanel, {
        value,
        title: title2,
        icon
      }, /* @__PURE__ */ createElementJsx("div", {
        style: "display: flex: flex-direction: column;"
      }, loadElements == null ? void 0 : loadElements.map((element) => createElement(element)), this.$injectManager.generate("layertab.tab." + value), /* @__PURE__ */ createElementJsx("div", {
        class: "empty",
        style: "order: 1000000;"
      })));
    })));
  }
}
var BlankToolBar$1 = "";
var ToolbarMenuItem$2 = "";
function _icon_template(tpl, opt) {
  const defaultOpts = Object.assign({
    width: 24,
    height: 24
  }, opt);
  return `
        <svg 
            xmlns="http://www.w3.org/2000/svg" 
            width="${defaultOpts.width}" 
            height="${defaultOpts.height}" 
            viewBox="0 0 ${defaultOpts.viewBoxWidth || defaultOpts.width} ${defaultOpts.viewBoxHeight || defaultOpts.height}">${tpl}</svg>`;
}
var __glob_0_0$7 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": _icon_template
}, Symbol.toStringTag, { value: "Module" }));
var account_tree = _icon_template(`<path d="M22 11V3h-7v3H9V3H2v8h7V8h2v10h4v3h7v-8h-7v3h-2V8h2v3z"/>`);
var __glob_0_1$7 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": account_tree
}, Symbol.toStringTag, { value: "Module" }));
var add = _icon_template(`<path d="M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6v2z"/>`);
var __glob_0_2$6 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": add
}, Symbol.toStringTag, { value: "Module" }));
var add_box = _icon_template(`<path d="M19 3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-2 10h-4v4h-2v-4H7v-2h4V7h2v4h4v2z"/>`);
var __glob_0_3$6 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": add_box
}, Symbol.toStringTag, { value: "Module" }));
var add_circle$1 = _icon_template(`<path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm5 11h-4v4h-2v-4H7v-2h4V7h2v4h4v2z"/>`);
var __glob_0_4$6 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": add_circle$1
}, Symbol.toStringTag, { value: "Module" }));
var add_note = _icon_template(`<path d="M14 2H6c-1.1 0-1.99.9-1.99 2L4 20c0 1.1.89 2 1.99 2H18c1.1 0 2-.9 2-2V8l-6-6zm2 14h-3v3h-2v-3H8v-2h3v-3h2v3h3v2zm-3-7V3.5L18.5 9H13z"/>`);
var __glob_0_5$6 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": add_note
}, Symbol.toStringTag, { value: "Module" }));
var align_center = _icon_template(`<path d="M7 15v2h10v-2H7zm-4 6h18v-2H3v2zm0-8h18v-2H3v2zm4-6v2h10V7H7zM3 3v2h18V3H3z"/>`);
var __glob_0_6$6 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": align_center
}, Symbol.toStringTag, { value: "Module" }));
var align_horizontal_center = _icon_template(`<polygon points="11,2 13,2 13,7 21,7 21,10 13,10 13,14 18,14 18,17 13,17 13,22 11,22 11,17 6,17 6,14 11,14 11,10 3,10 3,7 11,7"/>`);
var __glob_0_7$6 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": align_horizontal_center
}, Symbol.toStringTag, { value: "Module" }));
var align_horizontal_left = _icon_template(`<path d="M4,22H2V2h2V22z M22,7H6v3h16V7z M16,14H6v3h10V14z"/>`);
var __glob_0_8$6 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": align_horizontal_left
}, Symbol.toStringTag, { value: "Module" }));
var align_horizontal_right = _icon_template(`<path d="M20,2h2v20h-2V2z M2,10h16V7H2V10z M8,17h10v-3H8V17z"/>`);
var __glob_0_9$5 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": align_horizontal_right
}, Symbol.toStringTag, { value: "Module" }));
var align_justify = _icon_template(`<path d="M3 21h18v-2H3v2zm0-4h18v-2H3v2zm0-4h18v-2H3v2zm0-4h18V7H3v2zm0-6v2h18V3H3z"/>`);
var __glob_0_10$5 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": align_justify
}, Symbol.toStringTag, { value: "Module" }));
var align_left = _icon_template(`<path d="M15 15H3v2h12v-2zm0-8H3v2h12V7zM3 13h18v-2H3v2zm0 8h18v-2H3v2zM3 3v2h18V3H3z"/>`);
var __glob_0_11$5 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": align_left
}, Symbol.toStringTag, { value: "Module" }));
var align_right = _icon_template(`<path d="M3 21h18v-2H3v2zm6-4h12v-2H9v2zm-6-4h18v-2H3v2zm6-4h12V7H9v2zM3 3v2h18V3H3z"/>`);
var __glob_0_12$5 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": align_right
}, Symbol.toStringTag, { value: "Module" }));
var align_vertical_bottom = _icon_template(`<path d="M22,22H2v-2h20V22z M10,2H7v16h3V2z M17,8h-3v10h3V8z"/>`);
var __glob_0_13$5 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": align_vertical_bottom
}, Symbol.toStringTag, { value: "Module" }));
var align_vertical_center = _icon_template(`<polygon points="22,11 17,11 17,6 14,6 14,11 10,11 10,3 7,3 7,11 1.84,11 1.84,13 7,13 7,21 10,21 10,13 14,13 14,18 17,18 17,13 22,13"/>`);
var __glob_0_14$5 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": align_vertical_center
}, Symbol.toStringTag, { value: "Module" }));
var align_vertical_top = _icon_template(`<path d="M22,2v2H2V2H22z M7,22h3V6H7V22z M14,16h3V6h-3V16z"/>`);
var __glob_0_15$4 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": align_vertical_top
}, Symbol.toStringTag, { value: "Module" }));
var alternate = _icon_template(`<path d="M7 7h10v3l4-4-4-4v3H5v6h2V7zm10 10H7v-3l-4 4 4 4v-3h12v-6h-2v4z"/>`);
var __glob_0_16$4 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": alternate
}, Symbol.toStringTag, { value: "Module" }));
var alternate_reverse = _icon_template(`<path d="M7 7h10v3l4-4-4-4v3H5v6h2V7zm10 10H7v-3l-4 4 4 4v-3h12v-6h-2v4z" />`);
var __glob_0_17$4 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": alternate_reverse
}, Symbol.toStringTag, { value: "Module" }));
var apps = _icon_template(`<path d="M4 8h4V4H4v4zm6 12h4v-4h-4v4zm-6 0h4v-4H4v4zm0-6h4v-4H4v4zm6 0h4v-4h-4v4zm6-10v4h4V4h-4zm-6 4h4V4h-4v4zm6 6h4v-4h-4v4zm0 6h4v-4h-4v4z"/>`);
var __glob_0_18$4 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": apps
}, Symbol.toStringTag, { value: "Module" }));
var archive = _icon_template(`<path d="M20.54 5.23l-1.39-1.68C18.88 3.21 18.47 3 18 3H6c-.47 0-.88.21-1.16.55L3.46 5.23C3.17 5.57 3 6.02 3 6.5V19c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V6.5c0-.48-.17-.93-.46-1.27zM12 17.5L6.5 12H10v-2h4v2h3.5L12 17.5zM5.12 5l.81-1h12l.94 1H5.12z"/>`);
var __glob_0_19$4 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": archive
}, Symbol.toStringTag, { value: "Module" }));
var arrowLeft = _icon_template(`<path d="M14 7l-5 5 5 5V7z"/>`);
var __glob_0_20$4 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": arrowLeft
}, Symbol.toStringTag, { value: "Module" }));
var arrowRight = _icon_template(`<path d="M10 17l5-5-5-5v10z"/>`);
var __glob_0_21$3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": arrowRight
}, Symbol.toStringTag, { value: "Module" }));
var arrow_right = _icon_template(`<path d="M10 17l5-5-5-5v10z"/>`);
var __glob_0_22$3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": arrow_right
}, Symbol.toStringTag, { value: "Module" }));
var artboard$1 = _icon_template(`<path d="M6 2c-1.1 0-1.99.9-1.99 2L4 20c0 1.1.89 2 1.99 2H18c1.1 0 2-.9 2-2V8l-6-6H6zm7 7V3.5L18.5 9H13z"/>`);
var __glob_0_23$3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": artboard$1
}, Symbol.toStringTag, { value: "Module" }));
var auto_awesome = _icon_template(`<path d="M19 9l1.25-2.75L23 5l-2.75-1.25L19 1l-1.25 2.75L15 5l2.75 1.25L19 9zm-7.5.5L9 4 6.5 9.5 1 12l5.5 2.5L9 20l2.5-5.5L17 12l-5.5-2.5zM19 15l-1.25 2.75L15 19l2.75 1.25L19 23l1.25-2.75L23 19l-2.75-1.25L19 15z"/>`);
var __glob_0_24$3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": auto_awesome
}, Symbol.toStringTag, { value: "Module" }));
var autorenew = _icon_template(`<path d="M12 6v3l4-4-4-4v3c-4.42 0-8 3.58-8 8 0 1.57.46 3.03 1.24 4.26L6.7 14.8c-.45-.83-.7-1.79-.7-2.8 0-3.31 2.69-6 6-6zm6.76 1.74L17.3 9.2c.44.84.7 1.79.7 2.8 0 3.31-2.69 6-6 6v-3l-4 4 4 4v-3c4.42 0 8-3.58 8-8 0-1.57-.46-3.03-1.24-4.26z"/>`);
var __glob_0_25$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": autorenew
}, Symbol.toStringTag, { value: "Module" }));
var ballot = _icon_template(`<clipPath><use xlink:href="#a" overflow="visible"/></clipPath><path fill-rule="evenodd" clip-rule="evenodd" d="M13 9.5h5v-2h-5v2zm0 7h5v-2h-5v2zm6 4.5H5c-1.1 0-2-.9-2-2V5c0-1.1.9-2 2-2h14c1.1 0 2 .9 2 2v14c0 1.1-.9 2-2 2zM6 11h5V6H6v5zm1-4h3v3H7V7zM6 18h5v-5H6v5zm1-4h3v3H7v-3z"/>`);
var __glob_0_26$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": ballot
}, Symbol.toStringTag, { value: "Module" }));
var bar_chart = _icon_template(`<path d="M5 9.2h3V19H5zM10.6 5h2.8v14h-2.8zm5.6 8H19v6h-2.8z"/>`);
var __glob_0_27$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": bar_chart
}, Symbol.toStringTag, { value: "Module" }));
var blur = _icon_template(`<path d="M6 13c-.55 0-1 .45-1 1s.45 1 1 1 1-.45 1-1-.45-1-1-1zm0 4c-.55 0-1 .45-1 1s.45 1 1 1 1-.45 1-1-.45-1-1-1zm0-8c-.55 0-1 .45-1 1s.45 1 1 1 1-.45 1-1-.45-1-1-1zm-3 .5c-.28 0-.5.22-.5.5s.22.5.5.5.5-.22.5-.5-.22-.5-.5-.5zM6 5c-.55 0-1 .45-1 1s.45 1 1 1 1-.45 1-1-.45-1-1-1zm15 5.5c.28 0 .5-.22.5-.5s-.22-.5-.5-.5-.5.22-.5.5.22.5.5.5zM14 7c.55 0 1-.45 1-1s-.45-1-1-1-1 .45-1 1 .45 1 1 1zm0-3.5c.28 0 .5-.22.5-.5s-.22-.5-.5-.5-.5.22-.5.5.22.5.5.5zm-11 10c-.28 0-.5.22-.5.5s.22.5.5.5.5-.22.5-.5-.22-.5-.5-.5zm7 7c-.28 0-.5.22-.5.5s.22.5.5.5.5-.22.5-.5-.22-.5-.5-.5zm0-17c.28 0 .5-.22.5-.5s-.22-.5-.5-.5-.5.22-.5.5.22.5.5.5zM10 7c.55 0 1-.45 1-1s-.45-1-1-1-1 .45-1 1 .45 1 1 1zm0 5.5c-.83 0-1.5.67-1.5 1.5s.67 1.5 1.5 1.5 1.5-.67 1.5-1.5-.67-1.5-1.5-1.5zm8 .5c-.55 0-1 .45-1 1s.45 1 1 1 1-.45 1-1-.45-1-1-1zm0 4c-.55 0-1 .45-1 1s.45 1 1 1 1-.45 1-1-.45-1-1-1zm0-8c-.55 0-1 .45-1 1s.45 1 1 1 1-.45 1-1-.45-1-1-1zm0-4c-.55 0-1 .45-1 1s.45 1 1 1 1-.45 1-1-.45-1-1-1zm3 8.5c-.28 0-.5.22-.5.5s.22.5.5.5.5-.22.5-.5-.22-.5-.5-.5zM14 17c-.55 0-1 .45-1 1s.45 1 1 1 1-.45 1-1-.45-1-1-1zm0 3.5c-.28 0-.5.22-.5.5s.22.5.5.5.5-.22.5-.5-.22-.5-.5-.5zm-4-12c-.83 0-1.5.67-1.5 1.5s.67 1.5 1.5 1.5 1.5-.67 1.5-1.5-.67-1.5-1.5-1.5zm0 8.5c-.55 0-1 .45-1 1s.45 1 1 1 1-.45 1-1-.45-1-1-1zm4-4.5c-.83 0-1.5.67-1.5 1.5s.67 1.5 1.5 1.5 1.5-.67 1.5-1.5-.67-1.5-1.5-1.5zm0-4c-.83 0-1.5.67-1.5 1.5s.67 1.5 1.5 1.5 1.5-.67 1.5-1.5-.67-1.5-1.5-1.5z"/>`);
var __glob_0_28$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": blur
}, Symbol.toStringTag, { value: "Module" }));
var blur_linear = _icon_template(`<path d="M5 17.5c.83 0 1.5-.67 1.5-1.5s-.67-1.5-1.5-1.5-1.5.67-1.5 1.5.67 1.5 1.5 1.5zM9 13c.55 0 1-.45 1-1s-.45-1-1-1-1 .45-1 1 .45 1 1 1zm0-4c.55 0 1-.45 1-1s-.45-1-1-1-1 .45-1 1 .45 1 1 1zM3 21h18v-2H3v2zM5 9.5c.83 0 1.5-.67 1.5-1.5S5.83 6.5 5 6.5 3.5 7.17 3.5 8 4.17 9.5 5 9.5zm0 4c.83 0 1.5-.67 1.5-1.5s-.67-1.5-1.5-1.5-1.5.67-1.5 1.5.67 1.5 1.5 1.5zM9 17c.55 0 1-.45 1-1s-.45-1-1-1-1 .45-1 1 .45 1 1 1zm8-.5c.28 0 .5-.22.5-.5s-.22-.5-.5-.5-.5.22-.5.5.22.5.5.5zM3 3v2h18V3H3zm14 5.5c.28 0 .5-.22.5-.5s-.22-.5-.5-.5-.5.22-.5.5.22.5.5.5zm0 4c.28 0 .5-.22.5-.5s-.22-.5-.5-.5-.5.22-.5.5.22.5.5.5zM13 9c.55 0 1-.45 1-1s-.45-1-1-1-1 .45-1 1 .45 1 1 1zm0 4c.55 0 1-.45 1-1s-.45-1-1-1-1 .45-1 1 .45 1 1 1zm0 4c.55 0 1-.45 1-1s-.45-1-1-1-1 .45-1 1 .45 1 1 1z"/>`);
var __glob_0_29$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": blur_linear
}, Symbol.toStringTag, { value: "Module" }));
var boolean_difference = _icon_template(`<path d="M 20 10L 30 10L 30 30L 10 30L 10 20L 20 20L 20 10Z M 0 0L 20 0L 20 20L 0 20L 0 0Z  M 2 2L 2 18L 18 18L 18 2L 2 2Z" />`, { width: 30, height: 30 });
var __glob_0_30$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": boolean_difference
}, Symbol.toStringTag, { value: "Module" }));
var boolean_intersection = _icon_template(`<path d="
    M 10 10L 30 10L 30 30L 10 30L 10 10Z 
    M 20 12L 18 18L 12 18L 12 28L 28 28L 28 12L 12 12Z 
    M 0 0L 20 0L 20 20L 0 20L 0 0Z  
    M 2 2L 2 18L 18 18L 18 2L 2 2Z
" />`, { width: 30, height: 30 });
var __glob_0_31$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": boolean_intersection
}, Symbol.toStringTag, { value: "Module" }));
var boolean_union = _icon_template(`<path d="M 0 0L 20 0L 20 20L 0 20L 0 0Z M 10 10L 30 10L 30 30L 10 30L 10 10Z"/>`, { width: 30, height: 30 });
var __glob_0_32$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": boolean_union
}, Symbol.toStringTag, { value: "Module" }));
var boolean_xor = _icon_template(`<path d="
    M 10 10L 30 10L 30 30L 10 30L 10 10Z
    M 0 0L 20 0L 20 20L 0 20L 0 0Z 
" fill-rule="evenodd"/>`, { width: 30, height: 30 });
var __glob_0_33$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": boolean_xor
}, Symbol.toStringTag, { value: "Module" }));
var border_all = _icon_template(`<path d="M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-1 16H6c-.55 0-1-.45-1-1V6c0-.55.45-1 1-1h12c.55 0 1 .45 1 1v12c0 .55-.45 1-1 1z"/>`);
var __glob_0_34$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": border_all
}, Symbol.toStringTag, { value: "Module" }));
var border_inner = _icon_template(`<path d="M3 5v3c0 .55.45 1 1 1s1-.45 1-1V6c0-.55.45-1 1-1h2c.55 0 1-.45 1-1s-.45-1-1-1H5c-1.1 0-2 .9-2 2zm1 10c-.55 0-1 .45-1 1v3c0 1.1.9 2 2 2h3c.55 0 1-.45 1-1s-.45-1-1-1H6c-.55 0-1-.45-1-1v-2c0-.55-.45-1-1-1zm15 3c0 .55-.45 1-1 1h-2c-.55 0-1 .45-1 1s.45 1 1 1h3c1.1 0 2-.9 2-2v-3c0-.55-.45-1-1-1s-1 .45-1 1v2zm0-15h-3c-.55 0-1 .45-1 1s.45 1 1 1h2c.55 0 1 .45 1 1v2c0 .55.45 1 1 1s1-.45 1-1V5c0-1.1-.9-2-2-2z"/>`);
var __glob_0_35$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": border_inner
}, Symbol.toStringTag, { value: "Module" }));
var border_style = _icon_template(`<path d="M15 21h2v-2h-2v2zm4 0h2v-2h-2v2zM7 21h2v-2H7v2zm4 0h2v-2h-2v2zm8-4h2v-2h-2v2zm0-4h2v-2h-2v2zM3 3v18h2V5h16V3H3zm16 6h2V7h-2v2z"/>`);
var __glob_0_36$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": border_style
}, Symbol.toStringTag, { value: "Module" }));
var bottom = _icon_template(`<path d="M4,20 L20,20Z M10,8 L10,16 L14,16 L14,8Z" stroke-width="1" />`);
var __glob_0_37$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": bottom
}, Symbol.toStringTag, { value: "Module" }));
var broken_image = _icon_template(`<path d="M21 5v6.59l-3-3.01-4 4.01-4-4-4 4-3-3.01V5c0-1.1.9-2 2-2h14c1.1 0 2 .9 2 2zm-3 6.42l3 3.01V19c0 1.1-.9 2-2 2H5c-1.1 0-2-.9-2-2v-6.58l3 2.99 4-4 4 4 4-3.99z"/>`);
var __glob_0_38$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": broken_image
}, Symbol.toStringTag, { value: "Module" }));
var brush = _icon_template(`<path d="M7 14c-1.66 0-3 1.34-3 3 0 1.31-1.16 2-2 2 .92 1.22 2.49 2 4 2 2.21 0 4-1.79 4-4 0-1.66-1.34-3-3-3zm13.71-9.37l-1.34-1.34c-.39-.39-1.02-.39-1.41 0L9 12.25 11.75 15l8.96-8.96c.39-.39.39-1.02 0-1.41z"/>`);
var __glob_0_39$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": brush
}, Symbol.toStringTag, { value: "Module" }));
var build = _icon_template(`<path d="M22.7 19l-9.1-9.1c.9-2.3.4-5-1.5-6.9-2-2-5-2.4-7.4-1.3L9 6 6 9 1.6 4.7C.4 7.1.9 10.1 2.9 12.1c1.9 1.9 4.6 2.4 6.9 1.5l9.1 9.1c.4.4 1 .4 1.4 0l2.3-2.3c.5-.4.5-1.1.1-1.4z"/>`);
var __glob_0_40$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": build
}, Symbol.toStringTag, { value: "Module" }));
var camera_roll = _icon_template(`<path d="M14 5c0-1.1-.9-2-2-2h-1V2c0-.55-.45-1-1-1H6c-.55 0-1 .45-1 1v1H4c-1.1 0-2 .9-2 2v15c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2h8V5h-8zm-2 13h-2v-2h2v2zm0-9h-2V7h2v2zm4 9h-2v-2h2v2zm0-9h-2V7h2v2zm4 9h-2v-2h2v2zm0-9h-2V7h2v2z"/>`);
var __glob_0_41$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": camera_roll
}, Symbol.toStringTag, { value: "Module" }));
var cat = _icon_template(`
<path d="M712.4846,631.2673c-8.3777-59.9758-44.6997-121.2822-117.7703-198.7816
	c-51.7295-54.8649-72.0865-105.7791-55.8514-139.6883c12.4393-25.9817,42.587-35.8935,65.343-34.1103
	c26.3435,2.0661,37.3148,18.5905,41.88,32.0888c6.5847,19.471,2.7829,43.5175-8.4753,53.6029
	c-2.4382,2.1843-19.5444,15.6083-31.617,2.486c-16.0995-17.4994,1.3123-34.1181,1.3123-34.1181s25.7198-19.4211,11.5477-34.6431
	c-14.1721-15.2219-81.6211,4.7241-73.1766,62.9098c2.102,14.4833,9.8525,35.0453,41.7667,49.9105
	c31.3411,14.5985,62.0806,11.5356,84.3365-8.4017c26.8387-24.0431,36.221-68.5172,22.8163-108.1526
	c-13.0433-38.5685-45.3375-63.5167-86.387-66.7359c-22.4584-1.7602-45.9053,2.9182-66.0231,13.1776
	c-22.1882,11.3155-39.3094,28.5606-49.5124,49.8713c-15.207,31.7608-27.0118,99.5788,64.7797,196.9337
	c64.4428,68.3486,97.5892,122.6011,104.3126,170.7358c6.1263,43.8577-32.9753,141.2908-59.1734,141.8642
	c-18.2653,0.3997-13.0681-28.0174-11.1219-46.1832c3.4623-32.3166,9.02-64.4668,7.8147-96.946
	c-1.7692-47.6774-16.0649-83.7216-38.2463-125.1911c-20.1995-37.7643-37.8974-60.6029-92.5699-111.4463
	c-13.4884-12.5438-27.4699-22.5866-44.7675-38.1754c-17.5431-15.8101-21.9685-33.5474-24.195-48.6835
	c-4.6472-31.5926,5.266-35.0392,22.933-61.1816c7.51,6.1134,15.132,13.1576,22.5878,21.2593
	c0.8908,0.9678,2.1063,1.4586,3.3257,1.4586c1.0938,0,2.1906-0.3947,3.059-1.1939c1.8362-1.6895,1.9548-4.548,0.2647-6.3846
	c-8.043-8.7399-16.2394-16.2892-24.29-22.8068c1.0196-1.6815,1.9806-3.3693,2.913-5.06
	c11.2809,3.873,22.4781,8.5857,32.8744,14.3263c0.6923,0.3824,1.4415,0.5638,2.1804,0.5638c1.592,0,3.1354-0.8433,3.9596-2.3353
	c1.2061-2.1848,0.4133-4.9333-1.7714-6.14c-10.5501-5.8255-21.7927-10.625-33.0861-14.5846
	c1.7051-3.6655,3.2152-7.3481,4.5178-11.0449c9.9095,1.0547,20.2559,2.6507,30.8756,4.9542
	c2.4407,0.5281,4.8451-1.0193,5.3736-3.4585c0.5285-2.4387-1.0193-4.8446-3.4586-5.3736
	c-10.3543-2.2456-20.4231-3.8448-30.0823-4.9431c6.761-25.5357,4.0583-51.5754-8.0207-76.8648
	C448.2098,115.8869,474.731,76.8288,466.0513,18c-68.8775,17.9071-87.2624,54.1776-94.1043,50.875
	c-7.9472-3.8361-40.5018-11.036-62.952-10.6586c-37.278,0.6267-61.382,7.0395-61.382,7.0395
	c-11.2537-14.6686-35.9431-36.6889-90.105-41.2683c2.9433,47.1602,13.4346,82.2557,28.5291,102.9373l-0.7433,2.377
	c-11.7879,32.4393-13.5817,62.8858-3.8016,89.6451c-9.0883,1.1019-18.5685,2.7173-28.321,4.9987
	c-2.4299,0.5687-3.939,2.9991-3.3708,5.429c0.5687,2.4294,2.9972,3.939,5.429,3.3708c10.3087-2.4115,20.3424-4.0428,29.9266-5.0891
	c1.4184,2.9763,2.9836,5.904,4.7147,8.7755c-11.2262,4.119-22.4456,9.1879-32.9296,15.4312
	c-2.1445,1.2767-2.8476,4.0498-1.5704,6.1939c0.8453,1.4199,2.3461,2.2073,3.8866,2.2073c0.7859,0,1.5827-0.2054,2.3073-0.6369
	c10.5541-6.2849,22.0078-11.3381,33.4798-15.4008c3.3157,4.5403,7.0729,8.9251,11.2576,13.1527
	c-5.6694,5.3088-11.3757,11.2216-17,17.8125c-1.6199,1.8979-1.3944,4.7505,0.504,6.3699c0.8507,0.7266,1.8935,1.0816,2.931,1.0816
	c1.2767,0,2.5456-0.5383,3.4389-1.5856c5.5062-6.4525,11.1144-12.2327,16.692-17.4078c5.7832,5.4212,11.3758,11.1287,15.514,17.8627
	c7.8208,12.7265,8.3216,25.8196,6.7598,40.6753c-3.119,29.6671-13.4278,58.0414-20.0391,87.1301
	c-16.8163,73.989-9.0635,132.7513,20.7169,202.5388c8.0053,18.7598,17.5698,36.9144,23.7843,56.341
	c10.5081,32.8488,7.8436,88.3559,8.2697,122.8419v2.9318c0,0-19.9931,0.1384-28.4717,6.0748
	c-8.2555,5.7802-10.3883,21.931-4.3929,28.6906c6.6872,7.5395,21.6739,10.6397,31.6837,11.8093
	c119.664,13.9824,293.6021-2.6707,341.7446-8.3345C701.2023,821.2982,721.1432,693.2562,712.4846,631.2673z M437.2106,66.5267
	c-0.1946,33.6617-23.5064,50.7886-23.5064,50.7886c-6.2684-17.19-21.1558-25.3943-21.1558-25.3943
	C408.2194,68.8708,437.2106,66.5267,437.2106,66.5267z M201.6607,103.3024c0,0-19.8527-14.6264-20.0184-43.3732
	c0,0,24.6894,2.0019,38.035,21.6866C219.6773,81.6158,206.999,88.6223,201.6607,103.3024z M215.969,158.6876
	c15.0275-4.1452,27.2506-3.8264,37.1033-1.1182c-15.9193,16.5729-7.4137,31.0502-3.2583,36.286
	C221.2402,186.9178,215.969,158.6876,215.969,158.6876z M252.8369,194.4974c13.6546-17.1619,7.1357-30.6827,3.4758-35.9226
	c24.8589,8.5877,33.2057,32.5095,33.2057,32.5095C274.4792,195.6167,262.4471,196.221,252.8369,194.4974z M308.1766,232.8661
	c-4.1644,0.2111-22.0216-7.8084-21.8634-21.8635c0.1244-11.0539,40.2451-7.8568,42.1652,0
	C330.8523,220.7164,312.3411,232.655,308.1766,232.8661z M327.2252,191.0843c0,0,8.7972-25.2037,35.2186-33.1565
	c-12.424,19.1432-1.5466,31.7233,3.55,36.1478C356.055,196.2867,343.3752,195.9514,327.2252,191.0843z M369.7458,193.0825
	c10.0879-20.4091-1.0878-32.4358-4.9794-35.7968c9.66-2.4378,21.5306-2.5917,36.0081,1.4018
	C400.7746,158.6876,395.8536,185.0439,369.7458,193.0825z"/>
`);
var __glob_0_42$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": cat
}, Symbol.toStringTag, { value: "Module" }));
var center = _icon_template(`
    <path d="M12,4 L12,20Z M6,10 L18,10 L18,14 L6,14Z" stroke-width="1" />
`);
var __glob_0_43$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": center
}, Symbol.toStringTag, { value: "Module" }));
var chart = _icon_template(`<path d="M9 17H7v-7h2v7zm4 0h-2V7h2v10zm4 0h-2v-4h2v4zm2.5 2.1h-15V5h15v14.1zm0-16.1h-15c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h15c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2z"/>`);
var __glob_0_44$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": chart
}, Symbol.toStringTag, { value: "Module" }));
var check$1 = _icon_template(`<path d="M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41z"/>`);
var __glob_0_45$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": check$1
}, Symbol.toStringTag, { value: "Module" }));
var chevron_left = _icon_template(`<path d="M15.41 7.41L14 6l-6 6 6 6 1.41-1.41L10.83 12z"/>`);
var __glob_0_46$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": chevron_left
}, Symbol.toStringTag, { value: "Module" }));
var chevron_right = _icon_template(`
    <path d="M10 6L8.59 7.41 13.17 12l-4.58 4.59L10 18l6-6-6-6z"/>
`);
var __glob_0_47$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": chevron_right
}, Symbol.toStringTag, { value: "Module" }));
var circle = _icon_template(`<path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8z"/>`);
var __glob_0_48$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": circle
}, Symbol.toStringTag, { value: "Module" }));
var close = _icon_template(`<path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/>`);
var __glob_0_49$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": close
}, Symbol.toStringTag, { value: "Module" }));
var code = _icon_template(`<path d="M9.4 16.6L4.8 12l4.6-4.6L8 6l-6 6 6 6 1.4-1.4zm5.2 0l4.6-4.6-4.6-4.6L16 6l6 6-6 6-1.4-1.4z"/>`);
var __glob_0_50$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": code
}, Symbol.toStringTag, { value: "Module" }));
var color$1 = _icon_template(`<path d="M12 3c-4.97 0-9 4.03-9 9s4.03 9 9 9c.83 0 1.5-.67 1.5-1.5 0-.39-.15-.74-.39-1.01-.23-.26-.38-.61-.38-.99 0-.83.67-1.5 1.5-1.5H16c2.76 0 5-2.24 5-5 0-4.42-4.03-8-9-8zm-5.5 9c-.83 0-1.5-.67-1.5-1.5S5.67 9 6.5 9 8 9.67 8 10.5 7.33 12 6.5 12zm3-4C8.67 8 8 7.33 8 6.5S8.67 5 9.5 5s1.5.67 1.5 1.5S10.33 8 9.5 8zm5 0c-.83 0-1.5-.67-1.5-1.5S13.67 5 14.5 5s1.5.67 1.5 1.5S15.33 8 14.5 8zm3 4c-.83 0-1.5-.67-1.5-1.5S16.67 9 17.5 9s1.5.67 1.5 1.5-.67 1.5-1.5 1.5z"/>`);
var __glob_0_51$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": color$1
}, Symbol.toStringTag, { value: "Module" }));
var color_lens = _icon_template(`<path d="M12 3c-4.97 0-9 4.03-9 9s4.03 9 9 9c.83 0 1.5-.67 1.5-1.5 0-.39-.15-.74-.39-1.01-.23-.26-.38-.61-.38-.99 0-.83.67-1.5 1.5-1.5H16c2.76 0 5-2.24 5-5 0-4.42-4.03-8-9-8zm-5.5 9c-.83 0-1.5-.67-1.5-1.5S5.67 9 6.5 9 8 9.67 8 10.5 7.33 12 6.5 12zm3-4C8.67 8 8 7.33 8 6.5S8.67 5 9.5 5s1.5.67 1.5 1.5S10.33 8 9.5 8zm5 0c-.83 0-1.5-.67-1.5-1.5S13.67 5 14.5 5s1.5.67 1.5 1.5S15.33 8 14.5 8zm3 4c-.83 0-1.5-.67-1.5-1.5S16.67 9 17.5 9s1.5.67 1.5 1.5-.67 1.5-1.5 1.5z"/>`);
var __glob_0_52$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": color_lens
}, Symbol.toStringTag, { value: "Module" }));
var control_point = _icon_template(`<path d="M13 7h-2v4H7v2h4v4h2v-4h4v-2h-4V7zm-1-5C6.49 2 2 6.49 2 12s4.49 10 10 10 10-4.49 10-10S17.51 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8z"/>`);
var __glob_0_53$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": control_point
}, Symbol.toStringTag, { value: "Module" }));
var copy = _icon_template(`<path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12V1zm-1 4l6 6v10c0 1.1-.9 2-2 2H7.99C6.89 23 6 22.1 6 21l.01-14c0-1.1.89-2 1.99-2h7zm-1 7h5.5L14 6.5V12z"/>`);
var __glob_0_54$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": copy
}, Symbol.toStringTag, { value: "Module" }));
var create_folder = _icon_template(`
    <path d="M22 6H12l-2-2H2v16h20V6zm-3 8h-3v3h-2v-3h-3v-2h3V9h2v3h3v2z"/>
`);
var __glob_0_55$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": create_folder
}, Symbol.toStringTag, { value: "Module" }));
var cube = _icon_template(`<path d="M21 16.5a1 1 0 0 1-.527.881l-7.907 4.443a.996.996 0 0 1-1.132 0l-7.907-4.443A1 1 0 0 1 3 16.5v-9a1 1 0 0 1 .527-.881l7.907-4.443a.995.995 0 0 1 1.132 0l7.907 4.443A1 1 0 0 1 21 7.5v9zM12 4.15L6.042 7.5l5.96 3.35 5.958-3.35-5.958-3.35zM5 15.916l6 3.372V12.58L5 9.209v6.706zm14 0V9.209l-6 3.372v6.707l6-3.373z" />`);
var __glob_0_56$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": cube
}, Symbol.toStringTag, { value: "Module" }));
var cylinder = _icon_template(`
<g class="cylinder">
<path d="M 12 0 C 7.636719 0 3 1.226562 3 3.5 L 3 20.5 C 3 22.773438 7.636719 24 12 24 C 16.363281 24 21 22.773438 21 20.5 L 21 3.5 C 21 1.226562 16.363281 0 12 0 Z M 20 19.121094 C 19.921875 19.140625 19.84375 19.171875 19.78125 19.230469 C 19.574219 19.414062 19.554688 19.726562 19.738281 19.933594 C 19.914062 20.128906 20 20.320312 20 20.5 C 20 21.542969 16.957031 23 12 23 C 7.042969 23 4 21.542969 4 20.5 C 4 20.320312 4.085938 20.128906 4.261719 19.933594 C 4.445312 19.726562 4.425781 19.410156 4.21875 19.226562 C 4.15625 19.171875 4.078125 19.140625 4 19.121094 L 4 5.160156 C 5.59375 6.363281 8.863281 7 12 7 C 15.136719 7 18.40625 6.363281 20 5.160156 Z M 12 6 C 7.042969 6 4 4.542969 4 3.5 C 4 2.457031 7.042969 1 12 1 C 16.957031 1 20 2.457031 20 3.5 C 20 4.542969 16.957031 6 12 6 Z M 12 6 "/>
</g>
`);
var __glob_0_57$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": cylinder
}, Symbol.toStringTag, { value: "Module" }));
var dahaze = _icon_template(`<path d="M2 15.5v2h20v-2H2zm0-5v2h20v-2H2zm0-5v2h20v-2H2z"/>`);
var __glob_0_58$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": dahaze
}, Symbol.toStringTag, { value: "Module" }));
var dark$1 = _icon_template(`<path d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"/>`);
var __glob_0_59$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": dark$1
}, Symbol.toStringTag, { value: "Module" }));
var delete_forever = _icon_template(`<path d="M6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7H6v12zm2.46-7.12l1.41-1.41L12 12.59l2.12-2.12 1.41 1.41L13.41 14l2.12 2.12-1.41 1.41L12 15.41l-2.12 2.12-1.41-1.41L10.59 14l-2.13-2.12zM15.5 4l-1-1h-5l-1 1H5v2h14V4z"/>`);
var __glob_0_60$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": delete_forever
}, Symbol.toStringTag, { value: "Module" }));
var device_hub = _icon_template(`<path d="M17 16l-4-4V8.82C14.16 8.4 15 7.3 15 6c0-1.66-1.34-3-3-3S9 4.34 9 6c0 1.3.84 2.4 2 2.82V12l-4 4H3v5h5v-3.05l4-4.2 4 4.2V21h5v-5h-4z"/>`);
var __glob_0_61$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": device_hub
}, Symbol.toStringTag, { value: "Module" }));
var diffuse = _icon_template(`<path d="M5 14.5h14v-6H5v6zM11 .55V3.5h2V.55h-2zm8.04 2.5l-1.79 1.79 1.41 1.41 1.8-1.79-1.42-1.41zM13 22.45V19.5h-2v2.95h2zm7.45-3.91l-1.8-1.79-1.41 1.41 1.79 1.8 1.42-1.42zM3.55 4.46l1.79 1.79 1.41-1.41-1.79-1.79-1.41 1.41zm1.41 15.49l1.79-1.8-1.41-1.41-1.79 1.79 1.41 1.42z"/>`);
var __glob_0_62$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": diffuse
}, Symbol.toStringTag, { value: "Module" }));
function direction(transform2 = "") {
  return _icon_template(`
        <g transform='${transform2}'><path fill='#fff' d='M2.6 5.6L0 8.3 2.6 11l1.2-1.2-.5-.5h9.4l-.5.5 1.2 1.2L16 8.3l-2.6-2.7-1.2 1.2.5.5H3.3l.5-.5-1.2-1.2z'/><path fill='#231f20' d='M5.1 279h-4v1h5v-5h-1zm5 0v5h-5v1h5v5h1v-5h5v-1h-5v-5z'/><path fill='#fff' d='M.6 278.5h4v-4h2v6h-6zm4.5.5h-4v1h5v-5h-1zm4.5-.5h2v5h5v2h-5v5h-2v-5h-5v-2h5zm.5 5.5h-5v1h5v5h1v-5h5v-1h-5v-5h-1z'/><path fill='#000' d='M2.6 6.3l-2 2 2 2 .6-.5-1-1H14l-1 1 .5.5 2-2-2-2-.5.5 1 1H2.1l1-1-.5-.5z'/></g>
    `, { width: 24, height: 24, viewBoxWidth: 16, viewBoxHeight: 16 });
}
var __glob_0_63$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": direction
}, Symbol.toStringTag, { value: "Module" }));
var doc = _icon_template(`<path d="M6 2c-1.1 0-1.99.9-1.99 2L4 20c0 1.1.89 2 1.99 2H18c1.1 0 2-.9 2-2V8l-6-6H6zm7 7V3.5L18.5 9H13z"/>`);
var __glob_0_64$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": doc
}, Symbol.toStringTag, { value: "Module" }));
var drag_handle = _icon_template(`<path d="M20 9H4v2h16V9zM4 15h16v-2H4v2z"/>`);
var __glob_0_65$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": drag_handle
}, Symbol.toStringTag, { value: "Module" }));
var drag_indicator = _icon_template(`<path d="M11 18c0 1.1-.9 2-2 2s-2-.9-2-2 .9-2 2-2 2 .9 2 2zm-2-8c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm0-6c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm6 4c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2zm0 2c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm0 6c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2z"/>`);
var __glob_0_66$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": drag_indicator
}, Symbol.toStringTag, { value: "Module" }));
var draw = _icon_template(`<path d="M18.85,10.39l1.06-1.06c0.78-0.78,0.78-2.05,0-2.83L18.5,5.09c-0.78-0.78-2.05-0.78-2.83,0l-1.06,1.06L18.85,10.39z M14.61,11.81L7.41,19H6v-1.41l7.19-7.19L14.61,11.81z M13.19,7.56L4,16.76V21h4.24l9.19-9.19L13.19,7.56L13.19,7.56z M19,17.5 c0,2.19-2.54,3.5-5,3.5c-0.55,0-1-0.45-1-1s0.45-1,1-1c1.54,0,3-0.73,3-1.5c0-0.47-0.48-0.87-1.23-1.2l1.48-1.48 C18.32,15.45,19,16.29,19,17.5z M4.58,13.35C3.61,12.79,3,12.06,3,11c0-1.8,1.89-2.63,3.56-3.36C7.59,7.18,9,6.56,9,6 c0-0.41-0.78-1-2-1C5.74,5,5.2,5.61,5.17,5.64C4.82,6.05,4.19,6.1,3.77,5.76C3.36,5.42,3.28,4.81,3.62,4.38C3.73,4.24,4.76,3,7,3 c2.24,0,4,1.32,4,3c0,1.87-1.93,2.72-3.64,3.47C6.42,9.88,5,10.5,5,11c0,0.31,0.43,0.6,1.07,0.86L4.58,13.35z" />`);
var __glob_0_67$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": draw
}, Symbol.toStringTag, { value: "Module" }));
var east = _icon_template(`<path d="M15,5l-1.41,1.41L18.17,11H2V13h16.17l-4.59,4.59L15,19l7-7L15,5z"/>`);
var __glob_0_68$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": east
}, Symbol.toStringTag, { value: "Module" }));
var edit = _icon_template(`<path d="M3 17.46v3.04c0 .28.22.5.5.5h3.04c.13 0 .26-.05.35-.15L17.81 9.94l-3.75-3.75L3.15 17.1c-.1.1-.15.22-.15.36zM20.71 7.04c.39-.39.39-1.02 0-1.41l-2.34-2.34c-.39-.39-1.02-.39-1.41 0l-1.83 1.83 3.75 3.75 1.83-1.83z"/>`);
var __glob_0_69$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": edit
}, Symbol.toStringTag, { value: "Module" }));
var end = _icon_template(`<path transform="translate(24,0) scale(-1, 1)" d="M14.59,7.41L18.17,11H6v2h12.17l-3.59,3.59L16,18l6-6l-6-6L14.59,7.41z M2,6v12h2V6H2z"/>`);
var __glob_0_70$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": end
}, Symbol.toStringTag, { value: "Module" }));
var exit_to_app = _icon_template(`<path d="M10.09 15.59L11.5 17l5-5-5-5-1.41 1.41L12.67 11H3v2h9.67l-2.58 2.59zM19 3H5c-1.11 0-2 .9-2 2v4h2V5h14v14H5v-4H3v4c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2z"/>`);
var __glob_0_71$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": exit_to_app
}, Symbol.toStringTag, { value: "Module" }));
var expand = _icon_template(`<path d="M16.59 8.59L12 13.17 7.41 8.59 6 10l6 6 6-6z"/>`);
var __glob_0_72$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": expand
}, Symbol.toStringTag, { value: "Module" }));
var expand_more = _icon_template(`<path d="M16.59 8.59L12 13.17 7.41 8.59 6 10l6 6 6-6-1.41-1.41z"/>`);
var __glob_0_73$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": expand_more
}, Symbol.toStringTag, { value: "Module" }));
var _export = _icon_template(`<path d="M9 3L5 6.99h3V14h2V6.99h3L9 3zm7 14.01V10h-2v7.01h-3L15 21l4-3.99h-3z"/>`);
var __glob_0_74$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": _export
}, Symbol.toStringTag, { value: "Module" }));
var face = _icon_template(`<path d="M9 11.75c-.69 0-1.25.56-1.25 1.25s.56 1.25 1.25 1.25 1.25-.56 1.25-1.25-.56-1.25-1.25-1.25zm6 0c-.69 0-1.25.56-1.25 1.25s.56 1.25 1.25 1.25 1.25-.56 1.25-1.25-.56-1.25-1.25-1.25zM12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8 0-.29.02-.58.05-.86 2.36-1.05 4.23-2.98 5.21-5.37C11.07 8.33 14.05 10 17.42 10c.78 0 1.53-.09 2.25-.26.21.71.33 1.47.33 2.26 0 4.41-3.59 8-8 8z"/>`);
var __glob_0_75$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": face
}, Symbol.toStringTag, { value: "Module" }));
var fast_forward = _icon_template(`<path d="M4 18l8.5-6L4 6v12zm9-12v12l8.5-6L13 6z"/>`);
var __glob_0_76$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": fast_forward
}, Symbol.toStringTag, { value: "Module" }));
var fast_rewind = _icon_template(`<path d="M11 18V6l-8.5 6 8.5 6zm.5-6l8.5 6V6l-8.5 6z"/>`);
var __glob_0_77$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": fast_rewind
}, Symbol.toStringTag, { value: "Module" }));
var file_copy = _icon_template(`<path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12V1zm-1 4l6 6v10c0 1.1-.9 2-2 2H7.99C6.89 23 6 22.1 6 21l.01-14c0-1.1.89-2 1.99-2h7zm-1 7h5.5L14 6.5V12z"/>`);
var __glob_0_78$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": file_copy
}, Symbol.toStringTag, { value: "Module" }));
var filter$1 = _icon_template(`<path d="M18.7 12.4c-.28-.16-.57-.29-.86-.4.29-.11.58-.24.86-.4 1.92-1.11 2.99-3.12 3-5.19-1.79-1.03-4.07-1.11-6 0-.28.16-.54.35-.78.54.05-.31.08-.63.08-.95 0-2.22-1.21-4.15-3-5.19C10.21 1.85 9 3.78 9 6c0 .32.03.64.08.95-.24-.2-.5-.39-.78-.55-1.92-1.11-4.2-1.03-6 0 0 2.07 1.07 4.08 3 5.19.28.16.57.29.86.4-.29.11-.58.24-.86.4-1.92 1.11-2.99 3.12-3 5.19 1.79 1.03 4.07 1.11 6 0 .28-.16.54-.35.78-.54-.05.32-.08.64-.08.96 0 2.22 1.21 4.15 3 5.19 1.79-1.04 3-2.97 3-5.19 0-.32-.03-.64-.08-.95.24.2.5.38.78.54 1.92 1.11 4.2 1.03 6 0-.01-2.07-1.08-4.08-3-5.19zM12 16c-2.21 0-4-1.79-4-4s1.79-4 4-4 4 1.79 4 4-1.79 4-4 4z"/>`);
var __glob_0_79$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": filter$1
}, Symbol.toStringTag, { value: "Module" }));
var flag = _icon_template(`<path d="M14.4 6L14 4H5v17h2v-7h5.6l.4 2h7V6z"/>`);
var __glob_0_80$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": flag
}, Symbol.toStringTag, { value: "Module" }));
var flash_on = _icon_template(`<path d="M7 2v11h3v9l7-12h-4l4-8z"/>`);
var __glob_0_81$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": flash_on
}, Symbol.toStringTag, { value: "Module" }));
var flatten$1 = _icon_template(`<path d="M4,9v2h16V9H4z M16,4l-1.41-1.41L13,4.17V1h-2v3.19L9.39,2.61L8,4l4,4L16,4z M4,14h16v-2H4V14z M8,19l1.39,1.39L11,18.81 V22h2v-3.17l1.59,1.59L16,19l-4-4L8,19z"/>`);
var __glob_0_82$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": flatten$1
}, Symbol.toStringTag, { value: "Module" }));
var flex = _icon_template(`<path d="M3,5v14h18V5H3z M8.33,17H5V7h3.33V17z M13.67,17h-3.33V7h3.33V17z M19,17h-3.33V7H19V17z"/>`);
var __glob_0_83$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": flex
}, Symbol.toStringTag, { value: "Module" }));
var flip = _icon_template(`<path d="M15 21h2v-2h-2v2zm4-12h2V7h-2v2zM3 5v14c0 1.1.9 2 2 2h4v-2H5V5h4V3H5c-1.1 0-2 .9-2 2zm16-2v2h2c0-1.1-.9-2-2-2zm-8 20h2V1h-2v22zm8-6h2v-2h-2v2zM15 5h2V3h-2v2zm4 8h2v-2h-2v2zm0 8c1.1 0 2-.9 2-2h-2v2z"/>`);
var __glob_0_84$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": flip
}, Symbol.toStringTag, { value: "Module" }));
var flipY = _icon_template(`<path d="M15 21h2v-2h-2v2zm4-12h2V7h-2v2zM3 5v14c0 1.1.9 2 2 2h4v-2H5V5h4V3H5c-1.1 0-2 .9-2 2zm16-2v2h2c0-1.1-.9-2-2-2zm-8 20h2V1h-2v22zm8-6h2v-2h-2v2zM15 5h2V3h-2v2zm4 8h2v-2h-2v2zm0 8c1.1 0 2-.9 2-2h-2v2z"/>`);
var __glob_0_85$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": flipY
}, Symbol.toStringTag, { value: "Module" }));
var flip_camera = _icon_template(`
    <path d="M9,12c0,1.66,1.34,3,3,3s3-1.34,3-3s-1.34-3-3-3S9,10.34,9,12z"/>
    <path d="M8,10V8H5.09C6.47,5.61,9.05,4,12,4c3.72,0,6.85,2.56,7.74,6h2.06c-0.93-4.56-4.96-8-9.8-8C8.73,2,5.82,3.58,4,6.01V4H2v6
        H8z"/>
    <path d="M16,14v2h2.91c-1.38,2.39-3.96,4-6.91,4c-3.72,0-6.85-2.56-7.74-6H2.2c0.93,4.56,4.96,8,9.8,8c3.27,0,6.18-1.58,8-4.01V20
        h2v-6H16z"/>
`);
var __glob_0_86$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": flip_camera
}, Symbol.toStringTag, { value: "Module" }));
var folder = _icon_template(`<path d="M10 4H4c-1.1 0-1.99.9-1.99 2L2 18c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V8c0-1.1-.9-2-2-2h-8l-2-2z"/>`);
var __glob_0_87$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": folder
}, Symbol.toStringTag, { value: "Module" }));
var font_download = _icon_template(`<path d="M9.93 13.5h4.14L12 7.98zM20 2H4c-1.1 0-2 .9-2 2v16c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zm-4.05 16.5l-1.14-3H9.17l-1.12 3H5.96l5.11-13h1.86l5.11 13h-2.09z"/>`);
var __glob_0_88$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": font_download
}, Symbol.toStringTag, { value: "Module" }));
var format_bold = _icon_template(`<path d="M15.6 10.79c.97-.67 1.65-1.77 1.65-2.79 0-2.26-1.75-4-4-4H7v14h7.04c2.09 0 3.71-1.7 3.71-3.79 0-1.52-.86-2.82-2.15-3.42zM10 6.5h3c.83 0 1.5.67 1.5 1.5s-.67 1.5-1.5 1.5h-3v-3zm3.5 9H10v-3h3.5c.83 0 1.5.67 1.5 1.5s-.67 1.5-1.5 1.5z"/>`);
var __glob_0_89$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": format_bold
}, Symbol.toStringTag, { value: "Module" }));
var format_indent = _icon_template(`<path d="M3 21h18v-2H3v2zM3 8v8l4-4-4-4zm8 9h10v-2H11v2zM3 3v2h18V3H3zm8 6h10V7H11v2zm0 4h10v-2H11v2z"/>`);
var __glob_0_90$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": format_indent
}, Symbol.toStringTag, { value: "Module" }));
var format_line_spacing = _icon_template(`<path d="M6 7h2.5L5 3.5 1.5 7H4v10H1.5L5 20.5 8.5 17H6V7zm4-2v2h12V5H10zm0 14h12v-2H10v2zm0-6h12v-2H10v2z"/>`);
var __glob_0_91$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": format_line_spacing
}, Symbol.toStringTag, { value: "Module" }));
var format_shapes = _icon_template(`<path d="M23 7V1h-6v2H7V1H1v6h2v10H1v6h6v-2h10v2h6v-6h-2V7h2zM3 3h2v2H3V3zm2 18H3v-2h2v2zm12-2H7v-2H5V7h2V5h10v2h2v10h-2v2zm4 2h-2v-2h2v2zM19 5V3h2v2h-2zm-5.27 9h-3.49l-.73 2H7.89l3.4-9h1.4l3.41 9h-1.63l-.74-2zm-3.04-1.26h2.61L12 8.91l-1.31 3.83z"/>`);
var __glob_0_92$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": format_shapes
}, Symbol.toStringTag, { value: "Module" }));
var format_size = _icon_template(`<path d="M9 4v3h5v12h3V7h5V4H9zm-6 8h3v7h3v-7h3V9H3v3z"/>`);
var __glob_0_93$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": format_size
}, Symbol.toStringTag, { value: "Module" }));
var fullscreen = _icon_template(`<path d="M7 14H5v5h5v-2H7v-3zm-2-4h2V7h3V5H5v5zm12 7h-3v2h5v-5h-2v3zM14 5v2h3v3h2V5h-5z"/>`);
var __glob_0_94$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": fullscreen
}, Symbol.toStringTag, { value: "Module" }));
var gps_fixed = _icon_template(`<path d="M12 8c-2.21 0-4 1.79-4 4s1.79 4 4 4 4-1.79 4-4-1.79-4-4-4zm8.94 3c-.46-4.17-3.77-7.48-7.94-7.94V1h-2v2.06C6.83 3.52 3.52 6.83 3.06 11H1v2h2.06c.46 4.17 3.77 7.48 7.94 7.94V23h2v-2.06c4.17-.46 7.48-3.77 7.94-7.94H23v-2h-2.06zM12 19c-3.87 0-7-3.13-7-7s3.13-7 7-7 7 3.13 7 7-3.13 7-7 7z"/>`);
var __glob_0_95$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": gps_fixed
}, Symbol.toStringTag, { value: "Module" }));
var gradient$2 = _icon_template('<path d="M11 9h2v2h-2zm-2 2h2v2H9zm4 0h2v2h-2zm2-2h2v2h-2zM7 9h2v2H7zm12-6H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zM9 18H7v-2h2v2zm4 0h-2v-2h2v2zm4 0h-2v-2h2v2zm2-7h-2v2h2v2h-2v-2h-2v2h-2v-2h-2v2H9v-2H7v2H5v-2h2v-2H5V5h14v6z"/>');
var __glob_0_96$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": gradient$2
}, Symbol.toStringTag, { value: "Module" }));
var grid$1 = _icon_template(`<path d="M3,3v8h8V3H3z M9,9H5V5h4V9z M3,13v8h8v-8H3z M9,19H5v-4h4V19z M13,3v8h8V3H13z M19,9h-4V5h4V9z M13,13v8h8v-8H13z M19,19h-4v-4h4V19z"/>`);
var __glob_0_97$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": grid$1
}, Symbol.toStringTag, { value: "Module" }));
var grid3x3 = _icon_template(`<path d="M20,10V8h-4V4h-2v4h-4V4H8v4H4v2h4v4H4v2h4v4h2v-4h4v4h2v-4h4v-2h-4v-4H20z M14,14h-4v-4h4V14z"/>`);
var __glob_0_98$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": grid3x3
}, Symbol.toStringTag, { value: "Module" }));
var group = _icon_template(`
        <path d="M3 5h2V3c-1.1 0-2 .9-2 2zm0 8h2v-2H3v2zm4 8h2v-2H7v2zM3 9h2V7H3v2zm10-6h-2v2h2V3zm6 0v2h2c0-1.1-.9-2-2-2zM5 21v-2H3c0 1.1.9 2 2 2zm-2-4h2v-2H3v2zM9 3H7v2h2V3zm2 18h2v-2h-2v2zm8-8h2v-2h-2v2zm0 8c1.1 0 2-.9 2-2h-2v2zm0-12h2V7h-2v2zm0 8h2v-2h-2v2zm-4 4h2v-2h-2v2zm0-16h2V3h-2v2zM7 17h10V7H7v10zm2-8h6v6H9V9z"/>
    `);
var __glob_0_99$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": group
}, Symbol.toStringTag, { value: "Module" }));
var height = _icon_template(`<polygon points="13,6.99 16,6.99 12,3 8,6.99 11,6.99 11,17.01 8,17.01 12,21 16,17.01 13,17.01"/>`);
var __glob_0_100$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": height
}, Symbol.toStringTag, { value: "Module" }));
var highlight_at = _icon_template(`<path d="M17,5h-2V3h2V5z M15,15v6l2.29-2.29L19.59,21L21,19.59l-2.29-2.29L21,15H15z M19,9h2V7h-2V9z M19,13h2v-2h-2V13z M11,21h2 v-2h-2V21z M7,5h2V3H7V5z M3,17h2v-2H3V17z M5,21v-2H3C3,20.1,3.9,21,5,21z M19,3v2h2C21,3.9,20.1,3,19,3z M11,5h2V3h-2V5z M3,9h2 V7H3V9z M7,21h2v-2H7V21z M3,13h2v-2H3V13z M3,5h2V3C3.9,3,3,3.9,3,5z"/>`);
var __glob_0_101$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": highlight_at
}, Symbol.toStringTag, { value: "Module" }));
var horizontal_align_center = _icon_template(`<path d="M8 19h3v4h2v-4h3l-4-4-4 4zm8-14h-3V1h-2v4H8l4 4 4-4zM4 11v2h16v-2H4z" transform="rotate(-90 12 12)" />`);
var __glob_0_102$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": horizontal_align_center
}, Symbol.toStringTag, { value: "Module" }));
var horizontal_distribute = _icon_template(`<path d="M4,22H2V2h2V22z M22,2h-2v20h2V2z M13.5,7h-3v10h3V7z"/>`);
var __glob_0_103$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": horizontal_distribute
}, Symbol.toStringTag, { value: "Module" }));
var horizontal_rule = _icon_template(`<rect fill-rule="evenodd" height="2" width="16" x="4" y="11"/>`);
var __glob_0_104$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": horizontal_rule
}, Symbol.toStringTag, { value: "Module" }));
var image$1 = _icon_template(`<path d="M21 19V5c0-1.1-.9-2-2-2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2zM8.5 13.5l2.5 3.01L14.5 12l4.5 6H5l3.5-4.5z"/>`);
var __glob_0_105$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": image$1
}, Symbol.toStringTag, { value: "Module" }));
var input = _icon_template(`<path d="M21 3.01H3c-1.1 0-2 .9-2 2V9h2V4.99h18v14.03H3V15H1v4.01c0 1.1.9 1.98 2 1.98h18c1.1 0 2-.88 2-1.98v-14c0-1.11-.9-2-2-2zM11 16l4-4-4-4v3H1v2h10v3z"/>`);
var __glob_0_106$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": input
}, Symbol.toStringTag, { value: "Module" }));
var italic = _icon_template(`<path d="M10 4v3h2.21l-3.42 8H6v3h8v-3h-2.21l3.42-8H18V4z"/>`);
var __glob_0_107$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": italic
}, Symbol.toStringTag, { value: "Module" }));
var join_full = _icon_template(`
<g>
    <g>
        <ellipse cx="12" cy="12" rx="3" ry="5.74"/>
        <path d="M7.5,12c0-0.97,0.23-4.16,3.03-6.5C9.75,5.19,8.9,5,8,5c-3.86,0-7,3.14-7,7s3.14,7,7,7c0.9,0,1.75-0.19,2.53-0.5 C7.73,16.16,7.5,12.97,7.5,12z"/><path d="M16,5c-0.9,0-1.75,0.19-2.53,0.5c2.8,2.34,3.03,5.53,3.03,6.5c0,0.97-0.23,4.16-3.03,6.5C14.25,18.81,15.1,19,16,19 c3.86,0,7-3.14,7-7S19.86,5,16,5z"/>
    </g>
</g>
`);
var __glob_0_108$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": join_full
}, Symbol.toStringTag, { value: "Module" }));
var join_right = _icon_template(`
<ellipse cx="12" cy="12" rx="3" ry="5.74"/>
<path d="M16.5,12c0,0.97-0.23,4.16-3.03,6.5C14.25,18.81,15.1,19,16,19c3.86,0,7-3.14,7-7s-3.14-7-7-7c-0.9,0-1.75,0.19-2.53,0.5 C16.27,7.84,16.5,11.03,16.5,12z"/></g><g><path d="M8,19c0.9,0,1.75-0.19,2.53-0.5c-0.61-0.51-1.1-1.07-1.49-1.63C8.71,16.95,8.36,17,8,17c-2.76,0-5-2.24-5-5s2.24-5,5-5 c0.36,0,0.71,0.05,1.04,0.13c0.39-0.56,0.88-1.12,1.49-1.63C9.75,5.19,8.9,5,8,5c-3.86,0-7,3.14-7,7S4.14,19,8,19z"/>
`);
var __glob_0_109$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": join_right
}, Symbol.toStringTag, { value: "Module" }));
var justify_content_space_around = _icon_template(`<path d="M15,7v10H9V7H15z M21,5h-3v14h3V5z M17,5H7v14h10V5z M6,5H3v14h3V5z"/>`);
var __glob_0_110$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": justify_content_space_around
}, Symbol.toStringTag, { value: "Module" }));
var keyboard = _icon_template(`<path d="M20 5H4c-1.1 0-1.99.9-1.99 2L2 17c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm-9 3h2v2h-2V8zm0 3h2v2h-2v-2zM8 8h2v2H8V8zm0 3h2v2H8v-2zm-1 2H5v-2h2v2zm0-3H5V8h2v2zm9 7H8v-2h8v2zm0-4h-2v-2h2v2zm0-3h-2V8h2v2zm3 3h-2v-2h2v2zm0-3h-2V8h2v2z"/>`);
var __glob_0_111$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": keyboard
}, Symbol.toStringTag, { value: "Module" }));
var keyboard_arrow_down = _icon_template(`<path d="M7.41 8.59L12 13.17l4.59-4.58L18 10l-6 6-6-6 1.41-1.41z"/>`);
var __glob_0_112$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": keyboard_arrow_down
}, Symbol.toStringTag, { value: "Module" }));
var keyboard_arrow_left = _icon_template(`<path d="M15.41 16.59L10.83 12l4.58-4.59L14 6l-6 6 6 6 1.41-1.41z"/>`);
var __glob_0_113$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": keyboard_arrow_left
}, Symbol.toStringTag, { value: "Module" }));
var keyboard_arrow_right = _icon_template(`<path d="M8.59 16.59L13.17 12 8.59 7.41 10 6l6 6-6 6-1.41-1.41z"/>`);
var __glob_0_114$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": keyboard_arrow_right
}, Symbol.toStringTag, { value: "Module" }));
var keyboard_arrow_up = _icon_template(`<path d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6 1.41 1.41z"/>`);
var __glob_0_115$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": keyboard_arrow_up
}, Symbol.toStringTag, { value: "Module" }));
var landscape = _icon_template(`<path d="M14 6l-3.75 5 2.85 3.8-1.6 1.2C9.81 13.75 7 10 7 10l-6 8h22L14 6z"/>`);
var __glob_0_116$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": landscape
}, Symbol.toStringTag, { value: "Module" }));
var launch = _icon_template(`
        <path d="M19 19H5V5h7V3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2v-7h-2v7zM14 3v2h3.59l-9.83 9.83 1.41 1.41L19 6.41V10h2V3h-7z"/>
    `);
var __glob_0_117$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": launch
}, Symbol.toStringTag, { value: "Module" }));
var layers = _icon_template(`<path d="M11.99 18.54l-7.37-5.73L3 14.07l9 7 9-7-1.63-1.27-7.38 5.74zM12 16l7.36-5.73L21 9l-9-7-9 7 1.63 1.27L12 16z"/>`);
var __glob_0_118$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": layers
}, Symbol.toStringTag, { value: "Module" }));
var layout_default = _icon_template(`<path d="M19 7h-8v6h8V7zm-2 4h-4V9h4v2zm4-8H3c-1.1 0-2 .9-2 2v14c0 1.1.9 1.98 2 1.98h18c1.1 0 2-.88 2-1.98V5c0-1.1-.9-2-2-2zm0 16.01H3V4.98h18v14.03z"/>`);
var __glob_0_119 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": layout_default
}, Symbol.toStringTag, { value: "Module" }));
var layout_flex = _icon_template(`<path d="M20,4H4C2.9,4,2,4.9,2,6v12c0,1.1,0.9,2,2,2h16c1.1,0,2-0.9,2-2V6C22,4.9,21.1,4,20,4z M8,18H4V6h4V18z M14,18h-4V6h4V18z M20,18h-4V6h4V18z"/>`);
var __glob_0_120 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": layout_flex
}, Symbol.toStringTag, { value: "Module" }));
var layout_grid = _icon_template(`<path d="M3,3v8h8V3H3z M9,9H5V5h4V9z M3,13v8h8v-8H3z M9,19H5v-4h4V19z M13,3v8h8V3H13z M19,9h-4V5h4V9z M13,13v8h8v-8H13z M19,19h-4v-4h4V19z"/>`);
var __glob_0_121 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": layout_grid
}, Symbol.toStringTag, { value: "Module" }));
var left = _icon_template(`<path d="M2,4 L2,20Z M6,10 L16,10 L16,14 L6,14Z" stroke-width="1" />`);
var __glob_0_122 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": left
}, Symbol.toStringTag, { value: "Module" }));
var left_hide = _icon_template(`<path d="M18.41 16.59L13.82 12l4.59-4.59L17 6l-6 6 6 6zM6 6h2v12H6z"/>`);
var __glob_0_123 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": left_hide
}, Symbol.toStringTag, { value: "Module" }));
var lens = _icon_template(`<path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2z"/>`);
var __glob_0_124 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": lens
}, Symbol.toStringTag, { value: "Module" }));
var light$1 = _icon_template(`<path d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"/>`);
var __glob_0_125 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": light$1
}, Symbol.toStringTag, { value: "Module" }));
var line_cap_butt = _icon_template(`
        <rect class="base" width="13" height="12" x="3" y="2" fill="transparent" fill-rule="nonzero"></rect>
        <path fill="currentColor" fill-rule="nonzero" d="M3.5,6.06300874 C4.20280365,6.2438979 4.7561021,6.79719635 4.93699126,7.5 L16,7.5 L16,8.5 L4.93699126,8.5 C4.7561021,9.20280365 4.20280365,9.7561021 3.5,9.93699126 L3.5,13.5 L16,13.5 L16,14.5 L2.5,14.5 L2.5,9.93699126 C1.63738639,9.71496986 1,8.93191971 1,8 C1,7.06808029 1.63738639,6.28503014 2.5,6.06300874 L2.5,1.5 L16,1.5 L16,2.5 L3.5,2.5 L3.5,6.06300874 Z"></path>
    `, { width: 18, height: 16 });
var __glob_0_126 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": line_cap_butt
}, Symbol.toStringTag, { value: "Module" }));
var line_cap_round = _icon_template(`
        <path class="base" fill="transparent" fill-rule="nonzero" d="M8,2 L16,2 L16,14 L8,14 C4.6862915,14 2,11.3137085 2,8 L2,8 C2,4.6862915 4.6862915,2 8,2 Z"></path>
        <path fill="currentColor" fill-rule="nonzero" d="M9.93699126,8.5 C9.71496986,9.36261361 8.93191971,10 8,10 C6.8954305,10 6,9.1045695 6,8 C6,6.8954305 6.8954305,6 8,6 C8.93191971,6 9.71496986,6.63738639 9.93699126,7.5 L16,7.5 L16,8.5 L9.93699126,8.5 Z M16,13.5 L16,14.5 L8,14.5 C4.41014913,14.5 1.5,11.5898509 1.5,8 C1.5,4.41014913 4.41014913,1.5 8,1.5 L16,1.5 L16,2.5 L8,2.5 C4.96243388,2.5 2.5,4.96243388 2.5,8 C2.5,11.0375661 4.96243388,13.5 8,13.5 L16,13.5 Z"></path>
    `, { width: 18, height: 16 });
var __glob_0_127 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": line_cap_round
}, Symbol.toStringTag, { value: "Module" }));
var line_cap_square = _icon_template(`
        <rect class="base" width="14" height="12" x="2" y="2" fill="transparent" fill-rule="nonzero"></rect>
        <path fill="currentColor" fill-rule="nonzero" d="M9.93699126,8.5 C9.71496986,9.36261361 8.93191971,10 8,10 C6.8954305,10 6,9.1045695 6,8 C6,6.8954305 6.8954305,6 8,6 C8.93191971,6 9.71496986,6.63738639 9.93699126,7.5 L16,7.5 L16,8.5 L9.93699126,8.5 Z M2.5,13.5 L16,13.5 L16,14.5 L1.5,14.5 L1.5,1.5 L16,1.5 L16,2.5 L2.5,2.5 L2.5,13.5 Z"></path>
    `, { width: 18, height: 16 });
var __glob_0_128 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": line_cap_square
}, Symbol.toStringTag, { value: "Module" }));
var line_chart = _icon_template(`<path d="M3.5 18.49l6-6.01 4 4L22 6.92l-1.41-1.41-7.09 7.97-4-4L2 16.99z"/>`);
var __glob_0_129 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": line_chart
}, Symbol.toStringTag, { value: "Module" }));
var line_join_bevel = _icon_template(`<g fill="none" fill-rule="evenodd"><polygon class="base" fill="transparent" fill-rule="nonzero" points="2 14.5 2 7.538 7.382 1.5 16 1.5 16 14.5"></polygon><path fill="currentColor" fill-rule="nonzero" d="M2.96551724,7.95245414 L2.96551724,14.5 L2,14.5 L2,7.53775146 L7.38172454,1.5 L16,1.5 L16,2.46 L7.76471206,2.46 L2.96551724,7.95245414 Z M10.9369913,9 C10.7561021,9.70280365 10.2028036,10.2561021 9.5,10.4369913 L9.5,14.5 L8.5,14.5 L8.5,10.4369913 C7.63738639,10.2149699 7,9.43191971 7,8.5 C7,7.3954305 7.8954305,6.5 9,6.5 C9.93191971,6.5 10.7149699,7.13738639 10.9369913,8 L16,8 L16,9 L10.9369913,9 Z"></path></g>`, { width: 18, height: 16 });
var __glob_0_130 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": line_join_bevel
}, Symbol.toStringTag, { value: "Module" }));
var line_join_miter = _icon_template(`<g fill="none" fill-rule="evenodd"><rect class="base" width="14" height="13" x="2" y="1.5" fill="transparent" fill-rule="nonzero"></rect><path fill="currentColor" fill-rule="nonzero" d="M10.9369913,9 C10.7561021,9.70280365 10.2028036,10.2561021 9.5,10.4369913 L9.5,14.5 L8.5,14.5 L8.5,10.4369913 C7.63738639,10.2149699 7,9.43191971 7,8.5 C7,7.3954305 7.8954305,6.5 9,6.5 C9.93191971,6.5 10.7149699,7.13738639 10.9369913,8 L16,8 L16,9 L10.9369913,9 Z M3,2.5 L3,14.5 L2,14.5 L2,1.5 L16,1.5 L16,2.5 L3,2.5 Z"></path></g>`, { width: 18, height: 16 });
var __glob_0_131 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": line_join_miter
}, Symbol.toStringTag, { value: "Module" }));
var line_join_round = _icon_template(`<g fill="none" fill-rule="evenodd"><path class="base" fill="transparent" fill-rule="nonzero" d="M9,1.5 L16,1.5 L16,14.5 L2,14.5 L2,8.5 C2,4.63400675 5.13400675,1.5 9,1.5 Z"></path><path fill="currentColor" fill-rule="nonzero" d="M2.96551724,14.5 L2,14.5 L2,7.74 C2,4.29374316 4.80979916,1.5 8.27586207,1.5 L16,1.5 L16,2.46 L8.27586207,2.46 C5.3430396,2.46 2.96551724,4.82393652 2.96551724,7.74 L2.96551724,14.5 Z M10.9369913,9 C10.7561021,9.70280365 10.2028036,10.2561021 9.5,10.4369913 L9.5,14.5 L8.5,14.5 L8.5,10.4369913 C7.63738639,10.2149699 7,9.43191971 7,8.5 C7,7.3954305 7.8954305,6.5 9,6.5 C9.93191971,6.5 10.7149699,7.13738639 10.9369913,8 L16,8 L16,9 L10.9369913,9 Z"></path></g>`, { width: 18, height: 16 });
var __glob_0_132 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": line_join_round
}, Symbol.toStringTag, { value: "Module" }));
var line_style = _icon_template(`<path d="M3 16h5v-2H3v2zm6.5 0h5v-2h-5v2zm6.5 0h5v-2h-5v2zM3 20h2v-2H3v2zm4 0h2v-2H7v2zm4 0h2v-2h-2v2zm4 0h2v-2h-2v2zm4 0h2v-2h-2v2zM3 12h8v-2H3v2zm10 0h8v-2h-8v2zM3 4v4h18V4H3z"/>`);
var __glob_0_133 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": line_style
}, Symbol.toStringTag, { value: "Module" }));
var line_weight = _icon_template(`<path d="M3 17h18v-2H3v2zm0 3h18v-1H3v1zm0-7h18v-3H3v3zm0-9v4h18V4H3z"/>`);
var __glob_0_134 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": line_weight
}, Symbol.toStringTag, { value: "Module" }));
var list = _icon_template(`<path d="M4 14h4v-4H4v4zm0 5h4v-4H4v4zM4 9h4V5H4v4zm5 5h12v-4H9v4zm0 5h12v-4H9v4zM9 5v4h12V5H9z"/>`);
var __glob_0_135 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": list
}, Symbol.toStringTag, { value: "Module" }));
var local_library = _icon_template(`<path d="M12 11.55C9.64 9.35 6.48 8 3 8v11c3.48 0 6.64 1.35 9 3.55 2.36-2.19 5.52-3.55 9-3.55V8c-3.48 0-6.64 1.35-9 3.55zM12 8c1.66 0 3-1.34 3-3s-1.34-3-3-3-3 1.34-3 3 1.34 3 3 3z"/>`);
var __glob_0_136 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": local_library
}, Symbol.toStringTag, { value: "Module" }));
var local_movie = _icon_template(`<path d="M18 3v2h-2V3H8v2H6V3H4v18h2v-2h2v2h8v-2h2v2h2V3h-2zM8 17H6v-2h2v2zm0-4H6v-2h2v2zm0-4H6V7h2v2zm10 8h-2v-2h2v2zm0-4h-2v-2h2v2zm0-4h-2V7h2v2z"/>`);
var __glob_0_137 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": local_movie
}, Symbol.toStringTag, { value: "Module" }));
var lock = _icon_template(`<path d="M18 8h-1V6c0-2.76-2.24-5-5-5S7 3.24 7 6v2H6c-1.1 0-2 .9-2 2v10c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V10c0-1.1-.9-2-2-2zm-6 9c-1.1 0-2-.9-2-2s.9-2 2-2 2 .9 2 2-.9 2-2 2zm3.1-9H8.9V6c0-1.71 1.39-3.1 3.1-3.1 1.71 0 3.1 1.39 3.1 3.1v2z"/>`);
var __glob_0_138 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": lock
}, Symbol.toStringTag, { value: "Module" }));
var lock_open = _icon_template(`<path d="M12 17c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2zm6-9h-1V6c0-2.76-2.24-5-5-5S7 3.24 7 6h1.9c0-1.71 1.39-3.1 3.1-3.1 1.71 0 3.1 1.39 3.1 3.1v2H6c-1.1 0-2 .9-2 2v10c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V10c0-1.1-.9-2-2-2zm0 12H6V10h12v10z"/>`);
var __glob_0_139 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": lock_open
}, Symbol.toStringTag, { value: "Module" }));
var looks = _icon_template(`<path d="M12 10c-3.86 0-7 3.14-7 7h2c0-2.76 2.24-5 5-5s5 2.24 5 5h2c0-3.86-3.14-7-7-7zm0-4C5.93 6 1 10.93 1 17h2c0-4.96 4.04-9 9-9s9 4.04 9 9h2c0-6.07-4.93-11-11-11z"/>`);
var __glob_0_140 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": looks
}, Symbol.toStringTag, { value: "Module" }));
var margin = _icon_template(`<path d="M3,3v18h18V3H3z M19,19H5V5h14V19z M11,7h2v2h-2V7z M7,7h2v2H7V7z M15,7h2v2h-2V7z M7,11h2v2H7V11z M11,11h2v2h-2V11z M15,11h2v2h-2V11z"/>`);
var __glob_0_141 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": margin
}, Symbol.toStringTag, { value: "Module" }));
var merge = _icon_template(`<path d="M17 20.41L18.41 19 15 15.59 13.59 17 17 20.41zM7.5 8H11v5.59L5.59 19 7 20.41l6-6V8h3.5L12 3.5 7.5 8z"/>`);
var __glob_0_142 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": merge
}, Symbol.toStringTag, { value: "Module" }));
var middle = _icon_template(`<path d="M4,12 L20,12Z M10,8 L10,16 L14,16 L14,8Z" stroke-width="1" />`);
var __glob_0_143 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": middle
}, Symbol.toStringTag, { value: "Module" }));
var navigation = _icon_template(`<path d="M12 2L4.5 20.29l.71.71L12 18l6.79 3 .71-.71z" transform="rotate(-30 12 12)" stroke-width="1" fill="transparent"/>`);
var __glob_0_144 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": navigation
}, Symbol.toStringTag, { value: "Module" }));
var near_me = _icon_template(`<path d="M21 3L3 10.53v.98l6.84 2.65L12.48 21h.98L21 3z"/>`);
var __glob_0_145 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": near_me
}, Symbol.toStringTag, { value: "Module" }));
var north = _icon_template(`<path d="M5,9l1.41,1.41L11,5.83V22H13V5.83l4.59,4.59L19,9l-7-7L5,9z"/>`);
var __glob_0_146 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": north
}, Symbol.toStringTag, { value: "Module" }));
var note = _icon_template(`<path d="M17 10H7v2h10v-2zm2-7h-1V1h-2v2H8V1H6v2H5c-1.11 0-1.99.9-1.99 2L3 19c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm0 16H5V8h14v11zm-5-5H7v2h7v-2z"/>`);
var __glob_0_147 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": note
}, Symbol.toStringTag, { value: "Module" }));
var nowrap = _icon_template(`<path d="M14 17H4v2h10v-2zm6-8H4v2h16V9zM4 15h16v-2H4v2zM4 5v2h16V5H4z"/>`);
var __glob_0_148 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": nowrap
}, Symbol.toStringTag, { value: "Module" }));
var opacity = _icon_template(`<path d="M17.66 8L12 2.35 6.34 8C4.78 9.56 4 11.64 4 13.64s.78 4.11 2.34 5.67 3.61 2.35 5.66 2.35 4.1-.79 5.66-2.35S20 15.64 20 13.64 19.22 9.56 17.66 8zM6 14c.01-2 .62-3.27 1.76-4.4L12 5.27l4.24 4.38C17.38 10.77 17.99 12 18 14H6z"/>`);
var __glob_0_149 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": opacity
}, Symbol.toStringTag, { value: "Module" }));
var outline = _icon_template(`
    <path d="M19.77 4.93l1.4 1.4L8.43 19.07l-5.6-5.6 1.4-1.4 4.2 4.2L19.77 4.93m0-2.83L8.43 13.44l-4.2-4.2L0 13.47l8.43 8.43L24 6.33 19.77 2.1z"/>
`);
var __glob_0_150 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": outline
}, Symbol.toStringTag, { value: "Module" }));
var outline_circle = _icon_template(`<path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8z"/>`);
var __glob_0_151 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": outline_circle
}, Symbol.toStringTag, { value: "Module" }));
var outline_image = _icon_template(`<path d="M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm0 16H5V5h14v14zm-5.04-6.71l-2.75 3.54-1.96-2.36L6.5 17h11l-3.54-4.71z"/>`);
var __glob_0_152 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": outline_image
}, Symbol.toStringTag, { value: "Module" }));
var outline_rect = _icon_template(`<path d="M19 5v14H5V5h14m0-2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2z"/>`);
var __glob_0_153 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": outline_rect
}, Symbol.toStringTag, { value: "Module" }));
var outline_shape = _icon_template(`<path d="M2 12C2 6.48 6.48 2 12 2s10 4.48 10 10-4.48 10-10 10S2 17.52 2 12zm10 6c3.31 0 6-2.69 6-6s-2.69-6-6-6-6 2.69-6 6 2.69 6 6 6z"/>`);
var __glob_0_154 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": outline_shape
}, Symbol.toStringTag, { value: "Module" }));
var padding = _icon_template(`<path d="M3 5h2V3c-1.1 0-2 .9-2 2zm0 8h2v-2H3v2zm4 8h2v-2H7v2zM3 9h2V7H3v2zm10-6h-2v2h2V3zm6 0v2h2c0-1.1-.9-2-2-2zM5 21v-2H3c0 1.1.9 2 2 2zm-2-4h2v-2H3v2zM9 3H7v2h2V3zm2 18h2v-2h-2v2zm8-8h2v-2h-2v2zm0 8c1.1 0 2-.9 2-2h-2v2zm0-12h2V7h-2v2zm0 8h2v-2h-2v2zm-4 4h2v-2h-2v2zm0-16h2V3h-2v2zM7 17h10V7H7v10zm2-8h6v6H9V9z"/>`);
var __glob_0_155 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": padding
}, Symbol.toStringTag, { value: "Module" }));
var paint = _icon_template(`<path d="M18 4V3c0-.55-.45-1-1-1H5c-.55 0-1 .45-1 1v4c0 .55.45 1 1 1h12c.55 0 1-.45 1-1V6h1v4H9v11c0 .55.45 1 1 1h2c.55 0 1-.45 1-1v-9h8V4h-3z"/>`);
var __glob_0_156 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": paint
}, Symbol.toStringTag, { value: "Module" }));
var palette = _icon_template(`<path d="M12 3c-4.97 0-9 4.03-9 9s4.03 9 9 9c.83 0 1.5-.67 1.5-1.5 0-.39-.15-.74-.39-1.01-.23-.26-.38-.61-.38-.99 0-.83.67-1.5 1.5-1.5H16c2.76 0 5-2.24 5-5 0-4.42-4.03-8-9-8zm-5.5 9c-.83 0-1.5-.67-1.5-1.5S5.67 9 6.5 9 8 9.67 8 10.5 7.33 12 6.5 12zm3-4C8.67 8 8 7.33 8 6.5S8.67 5 9.5 5s1.5.67 1.5 1.5S10.33 8 9.5 8zm5 0c-.83 0-1.5-.67-1.5-1.5S13.67 5 14.5 5s1.5.67 1.5 1.5S15.33 8 14.5 8zm3 4c-.83 0-1.5-.67-1.5-1.5S16.67 9 17.5 9s1.5.67 1.5 1.5-.67 1.5-1.5 1.5z"/>`);
var __glob_0_157 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": palette
}, Symbol.toStringTag, { value: "Module" }));
var pantool = _icon_template(`<path d="M18 24h-6.55c-1.08 0-2.14-.45-2.89-1.23l-7.3-7.61 2.07-1.83c.62-.55 1.53-.66 2.26-.27L8 14.34V4.79c0-1.38 1.12-2.5 2.5-2.5.17 0 .34.02.51.05.09-1.3 1.17-2.33 2.49-2.33.86 0 1.61.43 2.06 1.09.29-.12.61-.18.94-.18 1.38 0 2.5 1.12 2.5 2.5v.28c.16-.03.33-.05.5-.05 1.38 0 2.5 1.12 2.5 2.5V20c0 2.21-1.79 4-4 4zM4.14 15.28l5.86 6.1c.38.39.9.62 1.44.62H18c1.1 0 2-.9 2-2V6.15c0-.28-.22-.5-.5-.5s-.5.22-.5.5V12h-2V3.42c0-.28-.22-.5-.5-.5s-.5.22-.5.5V12h-2V2.51c0-.28-.22-.5-.5-.5s-.5.22-.5.5V12h-2V4.79c0-.28-.22-.5-.5-.5s-.5.23-.5.5v12.87l-5.35-2.83-.51.45z"/>`);
var __glob_0_158 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": pantool
}, Symbol.toStringTag, { value: "Module" }));
var pattern_check = _icon_template(`<path d="M4 8h4V4H4v4zm6 12h4v-4h-4v4zm-6 0h4v-4H4v4zm0-6h4v-4H4v4zm6 0h4v-4h-4v4zm6-10v4h4V4h-4zm-6 4h4V4h-4v4zm6 6h4v-4h-4v4zm0 6h4v-4h-4v4z"/>`);
var __glob_0_159 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": pattern_check
}, Symbol.toStringTag, { value: "Module" }));
var pattern_cross_dot = _icon_template(`<path d="M6,13c-0.55,0-1,0.45-1,1s0.45,1,1,1s1-0.45,1-1S6.55,13,6,13z M6,17c-0.55,0-1,0.45-1,1s0.45,1,1,1s1-0.45,1-1 S6.55,17,6,17z M6,9c-0.55,0-1,0.45-1,1s0.45,1,1,1s1-0.45,1-1S6.55,9,6,9z M3,9.5c-0.28,0-0.5,0.22-0.5,0.5s0.22,0.5,0.5,0.5 s0.5-0.22,0.5-0.5S3.28,9.5,3,9.5z M6,5C5.45,5,5,5.45,5,6s0.45,1,1,1s1-0.45,1-1S6.55,5,6,5z M21,10.5c0.28,0,0.5-0.22,0.5-0.5 S21.28,9.5,21,9.5s-0.5,0.22-0.5,0.5S20.72,10.5,21,10.5z M14,7c0.55,0,1-0.45,1-1s-0.45-1-1-1s-1,0.45-1,1S13.45,7,14,7z M14,3.5 c0.28,0,0.5-0.22,0.5-0.5S14.28,2.5,14,2.5S13.5,2.72,13.5,3S13.72,3.5,14,3.5z M3,13.5c-0.28,0-0.5,0.22-0.5,0.5 s0.22,0.5,0.5,0.5s0.5-0.22,0.5-0.5S3.28,13.5,3,13.5z M10,20.5c-0.28,0-0.5,0.22-0.5,0.5s0.22,0.5,0.5,0.5s0.5-0.22,0.5-0.5 S10.28,20.5,10,20.5z M10,3.5c0.28,0,0.5-0.22,0.5-0.5S10.28,2.5,10,2.5S9.5,2.72,9.5,3S9.72,3.5,10,3.5z M10,7c0.55,0,1-0.45,1-1 s-0.45-1-1-1S9,5.45,9,6S9.45,7,10,7z M10,12.5c-0.83,0-1.5,0.67-1.5,1.5s0.67,1.5,1.5,1.5s1.5-0.67,1.5-1.5S10.83,12.5,10,12.5z M18,13c-0.55,0-1,0.45-1,1s0.45,1,1,1s1-0.45,1-1S18.55,13,18,13z M18,17c-0.55,0-1,0.45-1,1s0.45,1,1,1s1-0.45,1-1 S18.55,17,18,17z M18,9c-0.55,0-1,0.45-1,1s0.45,1,1,1s1-0.45,1-1S18.55,9,18,9z M18,5c-0.55,0-1,0.45-1,1s0.45,1,1,1s1-0.45,1-1 S18.55,5,18,5z M21,13.5c-0.28,0-0.5,0.22-0.5,0.5s0.22,0.5,0.5,0.5s0.5-0.22,0.5-0.5S21.28,13.5,21,13.5z M14,17 c-0.55,0-1,0.45-1,1s0.45,1,1,1s1-0.45,1-1S14.55,17,14,17z M14,20.5c-0.28,0-0.5,0.22-0.5,0.5s0.22,0.5,0.5,0.5s0.5-0.22,0.5-0.5 S14.28,20.5,14,20.5z M10,8.5c-0.83,0-1.5,0.67-1.5,1.5s0.67,1.5,1.5,1.5s1.5-0.67,1.5-1.5S10.83,8.5,10,8.5z M10,17 c-0.55,0-1,0.45-1,1s0.45,1,1,1s1-0.45,1-1S10.55,17,10,17z M14,12.5c-0.83,0-1.5,0.67-1.5,1.5s0.67,1.5,1.5,1.5s1.5-0.67,1.5-1.5 S14.83,12.5,14,12.5z M14,8.5c-0.83,0-1.5,0.67-1.5,1.5s0.67,1.5,1.5,1.5s1.5-0.67,1.5-1.5S14.83,8.5,14,8.5z"/>`);
var __glob_0_160 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": pattern_cross_dot
}, Symbol.toStringTag, { value: "Module" }));
var pattern_dot = _icon_template(`<path d="M6,13c-0.55,0-1,0.45-1,1s0.45,1,1,1s1-0.45,1-1S6.55,13,6,13z M6,17c-0.55,0-1,0.45-1,1s0.45,1,1,1s1-0.45,1-1 S6.55,17,6,17z M6,9c-0.55,0-1,0.45-1,1s0.45,1,1,1s1-0.45,1-1S6.55,9,6,9z M3,9.5c-0.28,0-0.5,0.22-0.5,0.5s0.22,0.5,0.5,0.5 s0.5-0.22,0.5-0.5S3.28,9.5,3,9.5z M6,5C5.45,5,5,5.45,5,6s0.45,1,1,1s1-0.45,1-1S6.55,5,6,5z M21,10.5c0.28,0,0.5-0.22,0.5-0.5 S21.28,9.5,21,9.5s-0.5,0.22-0.5,0.5S20.72,10.5,21,10.5z M14,7c0.55,0,1-0.45,1-1s-0.45-1-1-1s-1,0.45-1,1S13.45,7,14,7z M14,3.5 c0.28,0,0.5-0.22,0.5-0.5S14.28,2.5,14,2.5S13.5,2.72,13.5,3S13.72,3.5,14,3.5z M3,13.5c-0.28,0-0.5,0.22-0.5,0.5 s0.22,0.5,0.5,0.5s0.5-0.22,0.5-0.5S3.28,13.5,3,13.5z M10,20.5c-0.28,0-0.5,0.22-0.5,0.5s0.22,0.5,0.5,0.5s0.5-0.22,0.5-0.5 S10.28,20.5,10,20.5z M10,3.5c0.28,0,0.5-0.22,0.5-0.5S10.28,2.5,10,2.5S9.5,2.72,9.5,3S9.72,3.5,10,3.5z M10,7c0.55,0,1-0.45,1-1 s-0.45-1-1-1S9,5.45,9,6S9.45,7,10,7z M10,12.5c-0.83,0-1.5,0.67-1.5,1.5s0.67,1.5,1.5,1.5s1.5-0.67,1.5-1.5S10.83,12.5,10,12.5z M18,13c-0.55,0-1,0.45-1,1s0.45,1,1,1s1-0.45,1-1S18.55,13,18,13z M18,17c-0.55,0-1,0.45-1,1s0.45,1,1,1s1-0.45,1-1 S18.55,17,18,17z M18,9c-0.55,0-1,0.45-1,1s0.45,1,1,1s1-0.45,1-1S18.55,9,18,9z M18,5c-0.55,0-1,0.45-1,1s0.45,1,1,1s1-0.45,1-1 S18.55,5,18,5z M21,13.5c-0.28,0-0.5,0.22-0.5,0.5s0.22,0.5,0.5,0.5s0.5-0.22,0.5-0.5S21.28,13.5,21,13.5z M14,17 c-0.55,0-1,0.45-1,1s0.45,1,1,1s1-0.45,1-1S14.55,17,14,17z M14,20.5c-0.28,0-0.5,0.22-0.5,0.5s0.22,0.5,0.5,0.5s0.5-0.22,0.5-0.5 S14.28,20.5,14,20.5z M10,8.5c-0.83,0-1.5,0.67-1.5,1.5s0.67,1.5,1.5,1.5s1.5-0.67,1.5-1.5S10.83,8.5,10,8.5z M10,17 c-0.55,0-1,0.45-1,1s0.45,1,1,1s1-0.45,1-1S10.55,17,10,17z M14,12.5c-0.83,0-1.5,0.67-1.5,1.5s0.67,1.5,1.5,1.5s1.5-0.67,1.5-1.5 S14.83,12.5,14,12.5z M14,8.5c-0.83,0-1.5,0.67-1.5,1.5s0.67,1.5,1.5,1.5s1.5-0.67,1.5-1.5S14.83,8.5,14,8.5z"/>`);
var __glob_0_161 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": pattern_dot
}, Symbol.toStringTag, { value: "Module" }));
var pattern_grid = _icon_template(`<path d="M22,7V5h-3V2h-2v3h-4V2h-2v3H7V2H5v3H2v2h3v4H2v2h3v4H2v2h3v3h2v-3h4v3h2v-3h4v3h2v-3h3v-2h-3v-4h3v-2h-3V7H22z M7,7h4v4 H7V7z M7,17v-4h4v4H7z M17,17h-4v-4h4V17z M17,11h-4V7h4V11z"/>`);
var __glob_0_162 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": pattern_grid
}, Symbol.toStringTag, { value: "Module" }));
var pattern_horizontal_line = _icon_template(`<path d="M3 15h18v-2H3v2zm0 4h18v-2H3v2zm0-8h18V9H3v2zm0-6v2h18V5H3z"/>`);
var __glob_0_163 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": pattern_horizontal_line
}, Symbol.toStringTag, { value: "Module" }));
var pause = _icon_template(`<path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"/>`);
var __glob_0_164 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": pause
}, Symbol.toStringTag, { value: "Module" }));
var pentool = _icon_template(`
    <g transform="translate(4.000003875248012, 4.000001937624006)">
        <path stroke="currentColor" d="M 7.501491970838878 -0.0000015572448855733659Q 14.336036333057622 7.389304433496911 15.674208571053226 11.025537025755131Q 17.012380809048864 14.661769618013372 12.854180922821438 14.544928811787997L 12.854180922821438 16.99999278410904L 3.2146550430021494 16.99999278410904L 3.2146550430021494 14.544928811787997Q -0.8480130988910353 14.661769618013372 0.22369613306813782 11.025537025755131Q 1.295405365027311 7.389304433496911 7.501491970838878 -0.0000015572448855733659Z M 7.501491970838878 -0.0000015572448855733659M 7.043097362212707 10.615180199186797L 7.043097362212707 2.029497238417552Q 2.4235653311211847 7.389304433496911 1.2143202542326725 11.099378313047254Q 0.22369613306813782 14.380813978493594 4.269842778971384 13.709709450113499L 4.269842778971384 16.233605781316655L 11.751764459057853 16.233605781316655L 11.751764459057853 13.709709450113499Q 15.84146041516868 14.140123940309786 14.670231046646997 10.775846698306177Q 14.195747591990225 9.593976493057127 8.077664264490855 2.029497238417552L 8.077664264490855 10.615180199186797L 7.043097362212707 10.615180199186797Z"/>
    </g>
`);
var __glob_0_165 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": pentool
}, Symbol.toStringTag, { value: "Module" }));
var photo = _icon_template(`<path d="M21 19V5c0-1.1-.9-2-2-2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2zM8.5 13.5l2.5 3.01L14.5 12l4.5 6H5l3.5-4.5z"/>`);
var __glob_0_166 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": photo
}, Symbol.toStringTag, { value: "Module" }));
var play = _icon_template(`<path d="M8 5v14l11-7z"/>`);
var __glob_0_167 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": play
}, Symbol.toStringTag, { value: "Module" }));
var plugin = _icon_template(`<path d="M3 3h8v8H3zm10 0h8v8h-8zM3 13h8v8H3zm15 0h-2v3h-3v2h3v3h2v-3h3v-2h-3z"/>`);
var __glob_0_168 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": plugin
}, Symbol.toStringTag, { value: "Module" }));
var polygon$1 = _icon_template(`<path d="M17.2,3H6.8l-5.2,9l5.2,9h10.4l5.2-9L17.2,3z M16.05,19H7.95l-4.04-7l4.04-7h8.09l4.04,7L16.05,19z"/>`);
var __glob_0_169 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": polygon$1
}, Symbol.toStringTag, { value: "Module" }));
var power_input = _icon_template(`<path d="M2 9v2h19V9H2zm0 6h5v-2H2v2zm7 0h5v-2H9v2zm7 0h5v-2h-5v2z"/>`);
var __glob_0_170 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": power_input
}, Symbol.toStringTag, { value: "Module" }));
var publish = _icon_template(`<path d="M5 4v2h14V4H5zm0 10h4v6h6v-6h4l-7-7-7 7z"/>`);
var __glob_0_171 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": publish
}, Symbol.toStringTag, { value: "Module" }));
var rect$1 = _icon_template(`<path d="M19 3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2z"/>`);
var __glob_0_172 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": rect$1
}, Symbol.toStringTag, { value: "Module" }));
var redo = _icon_template(`<path d="M18.4 10.6C16.55 8.99 14.15 8 11.5 8c-4.65 0-8.58 3.03-9.96 7.22L3.9 16c1.05-3.19 4.05-5.5 7.6-5.5 1.95 0 3.73.72 5.12 1.88L13 16h9V7l-3.6 3.6z"/>`);
var __glob_0_173 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": redo
}, Symbol.toStringTag, { value: "Module" }));
var refresh = _icon_template(`<path d="M17.65 6.35C16.2 4.9 14.21 4 12 4c-4.42 0-7.99 3.58-7.99 8s3.57 8 7.99 8c3.73 0 6.84-2.55 7.73-6h-2.08c-.82 2.33-3.04 4-5.65 4-3.31 0-6-2.69-6-6s2.69-6 6-6c1.66 0 3.14.69 4.22 1.78L13 11h7V4l-2.35 2.35z"/>`);
var __glob_0_174 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": refresh
}, Symbol.toStringTag, { value: "Module" }));
var remove = _icon_template(`<path d="M6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7H6v12zM19 4h-3.5l-1-1h-5l-1 1H5v2h14V4z"/>`);
var __glob_0_175 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": remove
}, Symbol.toStringTag, { value: "Module" }));
var remove2 = _icon_template(`<path d="M19 13H5v-2h14v2z"/>`);
var __glob_0_176 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": remove2
}, Symbol.toStringTag, { value: "Module" }));
var repeat$1 = _icon_template(`<path d="M7 7h10v3l4-4-4-4v3H5v6h2V7zm10 10H7v-3l-4 4 4 4v-3h12v-6h-2v4z"/>`);
var __glob_0_177 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": repeat$1
}, Symbol.toStringTag, { value: "Module" }));
var replay = _icon_template(`<defs><path id="a" d="M0 0h24v24H0V0z"/></defs><clipPath id="b"><use xlink:href="#a" overflow="visible"/></clipPath><path d="M12 5V1L7 6l5 5V7c3.3 0 6 2.7 6 6s-2.7 6-6 6-6-2.7-6-6H4c0 4.4 3.6 8 8 8s8-3.6 8-8-3.6-8-8-8zm-1.1 11H10v-3.3L9 13v-.7l1.8-.6h.1V16zm4.3-1.8c0 .3 0 .6-.1.8l-.3.6s-.3.3-.5.3-.4.1-.6.1-.4 0-.6-.1-.3-.2-.5-.3-.2-.3-.3-.6-.1-.5-.1-.8v-.7c0-.3 0-.6.1-.8l.3-.6s.3-.3.5-.3.4-.1.6-.1.4 0 .6.1c.2.1.3.2.5.3s.2.3.3.6.1.5.1.8v.7zm-.9-.8v-.5s-.1-.2-.1-.3-.1-.1-.2-.2-.2-.1-.3-.1-.2 0-.3.1l-.2.2s-.1.2-.1.3v2s.1.2.1.3.1.1.2.2.2.1.3.1.2 0 .3-.1l.2-.2s.1-.2.1-.3v-1.5z" clip-path="url(#b)"/>`);
var __glob_0_178 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": replay
}, Symbol.toStringTag, { value: "Module" }));
var right = _icon_template(`<path d="M20,4 L20,20Z M6,10 L16,10 L16,14 L6,14Z" stroke-width="1" />`);
var __glob_0_179 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": right
}, Symbol.toStringTag, { value: "Module" }));
var right_hide = _icon_template(`<path d="M5.59 7.41L10.18 12l-4.59 4.59L7 18l6-6-6-6zM16 6h2v12h-2z"/>`);
var __glob_0_180 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": right_hide
}, Symbol.toStringTag, { value: "Module" }));
var rotate = _icon_template(`
        <path d="M7.11 8.53L5.7 7.11C4.8 8.27 4.24 9.61 4.07 11h2.02c.14-.87.49-1.72 1.02-2.47zM6.09 13H4.07c.17 1.39.72 2.73 1.62 3.89l1.41-1.42c-.52-.75-.87-1.59-1.01-2.47zm1.01 5.32c1.16.9 2.51 1.44 3.9 1.61V17.9c-.87-.15-1.71-.49-2.46-1.03L7.1 18.32zM13 4.07V1L8.45 5.55 13 10V6.09c2.84.48 5 2.94 5 5.91s-2.16 5.43-5 5.91v2.02c3.95-.49 7-3.85 7-7.93s-3.05-7.44-7-7.93z" stroke='white' stroke-width="0.5" />
    `);
var __glob_0_181 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": rotate
}, Symbol.toStringTag, { value: "Module" }));
var rotate_left = _icon_template(`<path d="M7.11 8.53L5.7 7.11C4.8 8.27 4.24 9.61 4.07 11h2.02c.14-.87.49-1.72 1.02-2.47zM6.09 13H4.07c.17 1.39.72 2.73 1.62 3.89l1.41-1.42c-.52-.75-.87-1.59-1.01-2.47zm1.01 5.32c1.16.9 2.51 1.44 3.9 1.61V17.9c-.87-.15-1.71-.49-2.46-1.03L7.1 18.32zM13 4.07V1L8.45 5.55 13 10V6.09c2.84.48 5 2.94 5 5.91s-2.16 5.43-5 5.91v2.02c3.95-.49 7-3.85 7-7.93s-3.05-7.44-7-7.93z"/>`);
var __glob_0_182 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": rotate_left
}, Symbol.toStringTag, { value: "Module" }));
var round$1 = _icon_template(`<path d="M19 19h2v2h-2v-2zm0-2h2v-2h-2v2zM3 13h2v-2H3v2zm0 4h2v-2H3v2zm0-8h2V7H3v2zm0-4h2V3H3v2zm4 0h2V3H7v2zm8 16h2v-2h-2v2zm-4 0h2v-2h-2v2zm4 0h2v-2h-2v2zm-8 0h2v-2H7v2zm-4 0h2v-2H3v2zM21 8c0-2.76-2.24-5-5-5h-5v2h5c1.65 0 3 1.35 3 3v5h2V8z"/>`);
var __glob_0_183 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": round$1
}, Symbol.toStringTag, { value: "Module" }));
var same_height$1 = _icon_template(`
    <path d="M4,4 L20,4Z M4,20 L20,20Z M10,8 L10,16 L14,16 L14,8Z" stroke-width="1" />
`);
var __glob_0_184 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": same_height$1
}, Symbol.toStringTag, { value: "Module" }));
var same_width$1 = _icon_template(`
    <path d="M20,4 L20,20Z M2,4 L2,20Z M6,10 L16,10 L16,14 L6,14Z" stroke-width="1" />
`);
var __glob_0_185 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": same_width$1
}, Symbol.toStringTag, { value: "Module" }));
var save = _icon_template(`<path d="M19 12v7H5v-7H3v7c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2v-7h-2zm-6 .67l2.59-2.58L17 11.5l-5 5-5-5 1.41-1.41L11 12.67V3h2z"/><path fill="none" d="M0 0h24v24H0z"/>`);
var __glob_0_186 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": save
}, Symbol.toStringTag, { value: "Module" }));
var scatter = _icon_template(`<g fill="#010101"><circle cx="7" cy="14" r="3"/><circle cx="11" cy="6" r="3"/><circle cx="16.6" cy="17.6" r="3"/></g>`);
var __glob_0_187 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": scatter
}, Symbol.toStringTag, { value: "Module" }));
var screen = _icon_template(`<path d="M7 14H5v5h5v-2H7v-3zm-2-4h2V7h3V5H5v5zm12 7h-3v2h5v-5h-2v3zM14 5v2h3v3h2V5h-5z"/>`);
var __glob_0_188 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": screen
}, Symbol.toStringTag, { value: "Module" }));
var setting = _icon_template(`<path d="M15.95 10.78c.03-.25.05-.51.05-.78s-.02-.53-.06-.78l1.69-1.32c.15-.12.19-.34.1-.51l-1.6-2.77c-.1-.18-.31-.24-.49-.18l-1.99.8c-.42-.32-.86-.58-1.35-.78L12 2.34c-.03-.2-.2-.34-.4-.34H8.4c-.2 0-.36.14-.39.34l-.3 2.12c-.49.2-.94.47-1.35.78l-1.99-.8c-.18-.07-.39 0-.49.18l-1.6 2.77c-.1.18-.06.39.1.51l1.69 1.32c-.04.25-.07.52-.07.78s.02.53.06.78L2.37 12.1c-.15.12-.19.34-.1.51l1.6 2.77c.1.18.31.24.49.18l1.99-.8c.42.32.86.58 1.35.78l.3 2.12c.04.2.2.34.4.34h3.2c.2 0 .37-.14.39-.34l.3-2.12c.49-.2.94-.47 1.35-.78l1.99.8c.18.07.39 0 .49-.18l1.6-2.77c.1-.18.06-.39-.1-.51l-1.67-1.32zM10 13c-1.65 0-3-1.35-3-3s1.35-3 3-3 3 1.35 3 3-1.35 3-3 3z"/>`);
var __glob_0_189 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": setting
}, Symbol.toStringTag, { value: "Module" }));
var settings_input_component = _icon_template(`<path d="M5 2c0-.55-.45-1-1-1s-1 .45-1 1v4H1v6h6V6H5V2zm4 14c0 1.3.84 2.4 2 2.82V23h2v-4.18c1.16-.41 2-1.51 2-2.82v-2H9v2zm-8 0c0 1.3.84 2.4 2 2.82V23h2v-4.18C6.16 18.4 7 17.3 7 16v-2H1v2zM21 6V2c0-.55-.45-1-1-1s-1 .45-1 1v4h-2v6h6V6h-2zm-8-4c0-.55-.45-1-1-1s-1 .45-1 1v4H9v6h6V6h-2V2zm4 14c0 1.3.84 2.4 2 2.82V23h2v-4.18c1.16-.41 2-1.51 2-2.82v-2h-6v2z"/>`);
var __glob_0_190 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": settings_input_component
}, Symbol.toStringTag, { value: "Module" }));
var shadow$1 = _icon_template(`<path d="M15.96 10.29l-2.75 3.54-1.96-2.36L8.5 15h11l-3.54-4.71zM3 5H1v16c0 1.1.9 2 2 2h16v-2H3V5zm18-4H7c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V3c0-1.1-.9-2-2-2zm0 16H7V3h14v14z"/>`);
var __glob_0_191 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": shadow$1
}, Symbol.toStringTag, { value: "Module" }));
var shape = _icon_template(`<path d="M23 7V1h-6v2H7V1H1v6h2v10H1v6h6v-2h10v2h6v-6h-2V7h2zM3 3h2v2H3V3zm2 18H3v-2h2v2zm12-2H7v-2H5V7h2V5h10v2h2v10h-2v2zm4 2h-2v-2h2v2zM19 5V3h2v2h-2z"/>`);
var __glob_0_192 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": shape
}, Symbol.toStringTag, { value: "Module" }));
var shuffle = _icon_template(`<path d="M10.59 9.17L5.41 4 4 5.41l5.17 5.17 1.42-1.41zM14.5 4l2.04 2.04L4 18.59 5.41 20 17.96 7.46 20 9.5V4h-5.5zm.33 9.41l-1.41 1.41 3.13 3.13L14.5 20H20v-5.5l-2.04 2.04-3.13-3.13z"/>`);
var __glob_0_193 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": shuffle
}, Symbol.toStringTag, { value: "Module" }));
var size = _icon_template(`<path d="M21 15h2v2h-2v-2zm0-4h2v2h-2v-2zm2 8h-2v2c1 0 2-1 2-2zM13 3h2v2h-2V3zm8 4h2v2h-2V7zm0-4v2h2c0-1-1-2-2-2zM1 7h2v2H1V7zm16-4h2v2h-2V3zm0 16h2v2h-2v-2zM3 3C2 3 1 4 1 5h2V3zm6 0h2v2H9V3zM5 3h2v2H5V3zm-4 8v8c0 1.1.9 2 2 2h12V11H1zm2 8l2.5-3.21 1.79 2.15 2.5-3.22L13 19H3z"/>`);
var __glob_0_194 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": size
}, Symbol.toStringTag, { value: "Module" }));
var skip_next = _icon_template(`<path d="M6 18l8.5-6L6 6v12zM16 6v12h2V6h-2z"/>`);
var __glob_0_195 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": skip_next
}, Symbol.toStringTag, { value: "Module" }));
var skip_prev = _icon_template(`<path d="M6 6h2v12H6zm3.5 6l8.5 6V6z"/>`);
var __glob_0_196 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": skip_prev
}, Symbol.toStringTag, { value: "Module" }));
var smooth = _icon_template(`<path d="M4.59 6.89c.7-.71 1.4-1.35 1.71-1.22.5.2 0 1.03-.3 1.52-.25.42-2.86 3.89-2.86 6.31 0 1.28.48 2.34 1.34 2.98.75.56 1.74.73 2.64.46 1.07-.31 1.95-1.4 3.06-2.77 1.21-1.49 2.83-3.44 4.08-3.44 1.63 0 1.65 1.01 1.76 1.79-3.78.64-5.38 3.67-5.38 5.37 0 1.7 1.44 3.09 3.21 3.09 1.63 0 4.29-1.33 4.69-6.1H21v-2.5h-2.47c-.15-1.65-1.09-4.2-4.03-4.2-2.25 0-4.18 1.91-4.94 2.84-.58.73-2.06 2.48-2.29 2.72-.25.3-.68.84-1.11.84-.45 0-.72-.83-.36-1.92.35-1.09 1.4-2.86 1.85-3.52.78-1.14 1.3-1.92 1.3-3.28C8.95 3.69 7.31 3 6.44 3 5.12 3 3.97 4 3.72 4.25c-.36.36-.66.66-.88.93l1.75 1.71zm9.29 11.66c-.31 0-.74-.26-.74-.72 0-.6.73-2.2 2.87-2.76-.3 2.69-1.43 3.48-2.13 3.48z"/>`);
var __glob_0_197 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": smooth
}, Symbol.toStringTag, { value: "Module" }));
var source = _icon_template(`<path d="M20,6h-8l-2-2H4C2.9,4,2.01,4.9,2.01,6L2,18c0,1.1,0.9,2,2,2h16c1.1,0,2-0.9,2-2V8C22,6.9,21.1,6,20,6z M20,18L4,18V6h5.17 l2,2H20V18z M18,12H6v-2h12V12z M14,16H6v-2h8V16z"/>`);
var __glob_0_198 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": source
}, Symbol.toStringTag, { value: "Module" }));
var south = _icon_template(`<path d="M19,15l-1.41-1.41L13,18.17V2H11v16.17l-4.59-4.59L5,15l7,7L19,15z"/>`);
var __glob_0_199 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": south
}, Symbol.toStringTag, { value: "Module" }));
var space = _icon_template(`<path d="M18 9v4H6V9H4v6h16V9h-2z"/>`);
var __glob_0_200 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": space
}, Symbol.toStringTag, { value: "Module" }));
var specular = _icon_template(`<path d="M3.55 18.54l1.41 1.41 1.79-1.8-1.41-1.41-1.79 1.8zM11 22.45h2V19.5h-2v2.95zM4 10.5H1v2h3v-2zm11-4.19V1.5H9v4.81C7.21 7.35 6 9.28 6 11.5c0 3.31 2.69 6 6 6s6-2.69 6-6c0-2.22-1.21-4.15-3-5.19zm5 4.19v2h3v-2h-3zm-2.76 7.66l1.79 1.8 1.41-1.41-1.8-1.79-1.4 1.4z"/>`);
var __glob_0_201 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": specular
}, Symbol.toStringTag, { value: "Module" }));
var speed = _icon_template(`<path d="M20.38 8.57l-1.23 1.85a8 8 0 0 1-.22 7.58H5.07A8 8 0 0 1 15.58 6.85l1.85-1.23A10 10 0 0 0 3.35 19a2 2 0 0 0 1.72 1h13.85a2 2 0 0 0 1.74-1 10 10 0 0 0-.27-10.44zm-9.79 6.84a2 2 0 0 0 2.83 0l5.66-8.49-8.49 5.66a2 2 0 0 0 0 2.83z"/>`);
var __glob_0_202 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": speed
}, Symbol.toStringTag, { value: "Module" }));
var star = _icon_template(`<path d="M22 9.24l-7.19-.62L12 2 9.19 8.63 2 9.24l5.46 4.73L5.82 21 12 17.27 18.18 21l-1.63-7.03L22 9.24zM12 15.4l-3.76 2.27 1-4.28-3.32-2.88 4.38-.38L12 6.1l1.71 4.04 4.38.38-3.32 2.88 1 4.28L12 15.4z"/>`);
var __glob_0_203 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": star
}, Symbol.toStringTag, { value: "Module" }));
var start = _icon_template(`<path d="M14.59,7.41L18.17,11H6v2h12.17l-3.59,3.59L16,18l6-6l-6-6L14.59,7.41z M2,6v12h2V6H2z"/>`);
var __glob_0_204 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": start
}, Symbol.toStringTag, { value: "Module" }));
var storage = _icon_template(`<path d="M2 20h20v-4H2v4zm2-3h2v2H4v-2zM2 4v4h20V4H2zm4 3H4V5h2v2zm-4 7h20v-4H2v4zm2-3h2v2H4v-2z"/>`);
var __glob_0_205 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": storage
}, Symbol.toStringTag, { value: "Module" }));
var straighten = _icon_template(`<path d="M21 6H3c-1.1 0-2 .9-2 2v8c0 1.1.9 2 2 2h18c1.1 0 2-.9 2-2V8c0-1.1-.9-2-2-2zm0 10H3V8h2v4h2V8h2v4h2V8h2v4h2V8h2v4h2V8h2v8z"/>`);
var __glob_0_206 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": straighten
}, Symbol.toStringTag, { value: "Module" }));
var strikethrough = _icon_template(`<defs><path id="a" d="M0 0h24v24H0V0z"/></defs><clipPath id="b"><use xlink:href="#a" overflow="visible"/></clipPath><path clip-path="url(#b)" d="M7.24 8.75c-.26-.48-.39-1.03-.39-1.67 0-.61.13-1.16.4-1.67.26-.5.63-.93 1.11-1.29.48-.35 1.05-.63 1.7-.83.66-.19 1.39-.29 2.18-.29.81 0 1.54.11 2.21.34.66.22 1.23.54 1.69.94.47.4.83.88 1.08 1.43.25.55.38 1.15.38 1.81h-3.01c0-.31-.05-.59-.15-.85-.09-.27-.24-.49-.44-.68-.2-.19-.45-.33-.75-.44-.3-.1-.66-.16-1.06-.16-.39 0-.74.04-1.03.13-.29.09-.53.21-.72.36-.19.16-.34.34-.44.55-.1.21-.15.43-.15.66 0 .48.25.88.74 1.21.38.25.77.48 1.41.7H7.39c-.05-.08-.11-.17-.15-.25zM21 12v-2H3v2h9.62c.18.07.4.14.55.2.37.17.66.34.87.51.21.17.35.36.43.57.07.2.11.43.11.69 0 .23-.05.45-.14.66-.09.2-.23.38-.42.53-.19.15-.42.26-.71.35-.29.08-.63.13-1.01.13-.43 0-.83-.04-1.18-.13s-.66-.23-.91-.42c-.25-.19-.45-.44-.59-.75-.14-.31-.25-.76-.25-1.21H6.4c0 .55.08 1.13.24 1.58.16.45.37.85.65 1.21.28.35.6.66.98.92.37.26.78.48 1.22.65.44.17.9.3 1.38.39.48.08.96.13 1.44.13.8 0 1.53-.09 2.18-.28s1.21-.45 1.67-.79c.46-.34.82-.77 1.07-1.27s.38-1.07.38-1.71c0-.6-.1-1.14-.31-1.61-.05-.11-.11-.23-.17-.33H21z"/>`);
var __glob_0_207 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": strikethrough
}, Symbol.toStringTag, { value: "Module" }));
var stroke_to_path = _icon_template(`<path d="M20 4h-4l-4-4-4 4H4c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2zm0 16H4V6h4.52l3.52-3.5L15.52 6H20v14zM6 18h12V8H6v10zm2-8h8v6H8v-6z"/>`);
var __glob_0_208 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": stroke_to_path
}, Symbol.toStringTag, { value: "Module" }));
var swap_horiz = _icon_template(`<path d="M6.99 11L3 15l3.99 4v-3H14v-2H6.99v-3zM21 9l-3.99-4v3H10v2h7.01v3L21 9z"/>`);
var __glob_0_209 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": swap_horiz
}, Symbol.toStringTag, { value: "Module" }));
var switch_left = _icon_template(`<path d="M8.5,8.62v6.76L5.12,12L8.5,8.62 M10,5l-7,7l7,7V5L10,5z M14,5v14l7-7L14,5z"/>`);
var __glob_0_210 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": switch_left
}, Symbol.toStringTag, { value: "Module" }));
var switch_right = _icon_template(`<path d="M15.5,15.38V8.62L18.88,12L15.5,15.38 M14,19l7-7l-7-7V19L14,19z M10,19V5l-7,7L10,19z"/>`);
var __glob_0_211 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": switch_right
}, Symbol.toStringTag, { value: "Module" }));
var sync = _icon_template(`<path d="M12 4V1L8 5l4 4V6c3.31 0 6 2.69 6 6 0 1.01-.25 1.97-.7 2.8l1.46 1.46C19.54 15.03 20 13.57 20 12c0-4.42-3.58-8-8-8zm0 14c-3.31 0-6-2.69-6-6 0-1.01.25-1.97.7-2.8L5.24 7.74C4.46 8.97 4 10.43 4 12c0 4.42 3.58 8 8 8v3l4-4-4-4v3z"/>`);
var __glob_0_212 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": sync
}, Symbol.toStringTag, { value: "Module" }));
var table_rows = _icon_template(`<path d="M19,3H5C3.9,3,3,3.9,3,5v14c0,1.1,0.9,2,2,2h14c1.1,0,2-0.9,2-2V5C21,3.9,20.1,3,19,3z M19,5v3H5V5H19z M19,10v4H5v-4H19z M5,19v-3h14v3H5z"/>`);
var __glob_0_213 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": table_rows
}, Symbol.toStringTag, { value: "Module" }));
var text_rotate = _icon_template(`<path d="M12.75 3h-1.5L6.5 14h2.1l.9-2.2h5l.9 2.2h2.1L12.75 3zm-2.62 7L12 4.98 13.87 10h-3.74zm10.37 8l-3-3v2H5v2h12.5v2l3-3z"/>`);
var __glob_0_214 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": text_rotate
}, Symbol.toStringTag, { value: "Module" }));
var texture$1 = _icon_template(`<path d="M19.51 3.08L3.08 19.51c.09.34.27.65.51.9.25.24.56.42.9.51L20.93 4.49c-.19-.69-.73-1.23-1.42-1.41zM11.88 3L3 11.88v2.83L14.71 3h-2.83zM5 3c-1.1 0-2 .9-2 2v2l4-4H5zm14 18c.55 0 1.05-.22 1.41-.59.37-.36.59-.86.59-1.41v-2l-4 4h2zm-9.71 0h2.83L21 12.12V9.29L9.29 21z"/>`);
var __glob_0_215 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": texture$1
}, Symbol.toStringTag, { value: "Module" }));
var timer = _icon_template(`<path d="M15 1H9v2h6V1zm-4 13h2V8h-2v6zm8.03-6.61l1.42-1.42c-.43-.51-.9-.99-1.41-1.41l-1.42 1.42C16.07 4.74 14.12 4 12 4c-4.97 0-9 4.03-9 9s4.02 9 9 9 9-4.03 9-9c0-2.12-.74-4.07-1.97-5.61zM12 20c-3.87 0-7-3.13-7-7s3.13-7 7-7 7 3.13 7 7-3.13 7-7 7z"/>`);
var __glob_0_216 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": timer
}, Symbol.toStringTag, { value: "Module" }));
var title = _icon_template(`<path d="M5 4v3h5.5v12h3V7H19V4z"/>`);
var __glob_0_217 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": title
}, Symbol.toStringTag, { value: "Module" }));
var to_back = _icon_template(`<path d="M 7 7L 22 7L 22 22L 7 22L 7 7Z" style="fill:white !important;"/><path d="M 0 0L 14 0L 14 14L 0 14L 0 0Z M 16 16L 30 16L 30 30L 16 30L 16 16Z"/>`, { width: 30, height: 30 });
var __glob_0_218 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": to_back
}, Symbol.toStringTag, { value: "Module" }));
var to_front = _icon_template(`<path d="M 0 0L 14 0L 14 14L 0 14L 0 0Z M 16 16L 30 16L 30 30L 16 30L 16 16Z"/><path d="M 7 7L 22 7L 22 22L 7 22L 7 7Z" style="fill:white !important;"/>`, { width: 30, height: 30 });
var __glob_0_219 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": to_front
}, Symbol.toStringTag, { value: "Module" }));
var tonality = _icon_template(`<path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-1 17.93c-3.94-.49-7-3.85-7-7.93s3.05-7.44 7-7.93v15.86zm2-15.86c1.03.13 2 .45 2.87.93H13v-.93zM13 7h5.24c.25.31.48.65.68 1H13V7zm0 3h6.74c.08.33.15.66.19 1H13v-1zm0 9.93V19h2.87c-.87.48-1.84.8-2.87.93zM18.24 17H13v-1h5.92c-.2.35-.43.69-.68 1zm1.5-3H13v-1h6.93c-.04.34-.11.67-.19 1z"/>`);
var __glob_0_220 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": tonality
}, Symbol.toStringTag, { value: "Module" }));
var top = _icon_template(`<path d="M4,4 L20,4Z M10,8 L10,16 L14,16 L14,8Z" stroke-width="1" />`);
var __glob_0_221 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": top
}, Symbol.toStringTag, { value: "Module" }));
var transform$1 = _icon_template(`<path d="M22 18v-2H8V4h2L7 1 4 4h2v2H2v2h4v8c0 1.1.9 2 2 2h8v2h-2l3 3 3-3h-2v-2h4zM10 8h6v6h2V8c0-1.1-.9-2-2-2h-6v2z"/>`);
var __glob_0_222 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": transform$1
}, Symbol.toStringTag, { value: "Module" }));
var underline = _icon_template(`<path d="M12 17c3.31 0 6-2.69 6-6V3h-2.5v8c0 1.93-1.57 3.5-3.5 3.5S8.5 12.93 8.5 11V3H6v8c0 3.31 2.69 6 6 6zm-7 2v2h14v-2H5z"/>`);
var __glob_0_223 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": underline
}, Symbol.toStringTag, { value: "Module" }));
var undo = _icon_template(`<path d="M12.5 8c-2.65 0-5.05.99-6.9 2.6L2 7v9h9l-3.62-3.62c1.39-1.16 3.16-1.88 5.12-1.88 3.54 0 6.55 2.31 7.6 5.5l2.37-.78C21.08 11.03 17.15 8 12.5 8z"/>`);
var __glob_0_224 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": undo
}, Symbol.toStringTag, { value: "Module" }));
var unfold = _icon_template(`<path d="M12 5.83L15.17 9l1.41-1.41L12 3 7.41 7.59 8.83 9 12 5.83zm0 12.34L8.83 15l-1.41 1.41L12 21l4.59-4.59L15.17 15 12 18.17z"/>`);
var __glob_0_225 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": unfold
}, Symbol.toStringTag, { value: "Module" }));
var vertical_align_baseline = _icon_template(`<path d="M16,18v2H8v-2H16z M11,7.99V16h2V7.99h3L12,4L8,7.99H11z"/>`);
var __glob_0_226 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": vertical_align_baseline
}, Symbol.toStringTag, { value: "Module" }));
var vertical_align_bottom = _icon_template(`<path d="M16 13h-3V3h-2v10H8l4 4 4-4zM4 19v2h16v-2H4z"/>`);
var __glob_0_227 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": vertical_align_bottom
}, Symbol.toStringTag, { value: "Module" }));
var vertical_align_center = _icon_template(`<path d="M8 19h3v4h2v-4h3l-4-4-4 4zm8-14h-3V1h-2v4H8l4 4 4-4zM4 11v2h16v-2H4z"/>`);
var __glob_0_228 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": vertical_align_center
}, Symbol.toStringTag, { value: "Module" }));
var vertical_align_stretch = _icon_template(`
    <path d="M19,13H5c-1.1,0-2,0.9-2,2v4c0,1.1,0.9,2,2,2h14c1.1,0,2-0.9,2-2v-4C21,13.9,20.1,13,19,13z M19,19H5v-4h14V19z"/>
    <path d="M19,3H5C3.9,3,3,3.9,3,5v4c0,1.1,0.9,2,2,2h14c1.1,0,2-0.9,2-2V5C21,3.9,20.1,3,19,3z M19,9H5V5h14V9z"/>
`);
var __glob_0_229 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": vertical_align_stretch
}, Symbol.toStringTag, { value: "Module" }));
var vertical_align_top = _icon_template(`<path d="M8 11h3v10h2V11h3l-4-4-4 4zM4 3v2h16V3H4z"/>`);
var __glob_0_230 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": vertical_align_top
}, Symbol.toStringTag, { value: "Module" }));
var vertical_distribute = _icon_template(`<path d="M22,2v2H2V2H22z M7,10.5v3h10v-3H7z M2,20v2h20v-2H2z"/>`);
var __glob_0_231 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": vertical_distribute
}, Symbol.toStringTag, { value: "Module" }));
var video$1 = _icon_template(`
        <path d="M17 10.5V7c0-.55-.45-1-1-1H4c-.55 0-1 .45-1 1v10c0 .55.45 1 1 1h12c.55 0 1-.45 1-1v-3.5l4 4v-11l-4 4z"/>
    `);
var __glob_0_232 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": video$1
}, Symbol.toStringTag, { value: "Module" }));
var view_comfy = _icon_template(`<path d="M3 9h4V5H3v4zm0 5h4v-4H3v4zm5 0h4v-4H8v4zm5 0h4v-4h-4v4zM8 9h4V5H8v4zm5-4v4h4V5h-4zm5 9h4v-4h-4v4zM3 19h4v-4H3v4zm5 0h4v-4H8v4zm5 0h4v-4h-4v4zm5 0h4v-4h-4v4zm0-14v4h4V5h-4z"/>`);
var __glob_0_233 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": view_comfy
}, Symbol.toStringTag, { value: "Module" }));
var view_list = _icon_template(`<path d="M4 14h4v-4H4v4zm0 5h4v-4H4v4zM4 9h4V5H4v4zm5 5h12v-4H9v4zm0 5h12v-4H9v4zM9 5v4h12V5H9z"/>`);
var __glob_0_234 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": view_list
}, Symbol.toStringTag, { value: "Module" }));
var view_week = _icon_template(`<path d="M20,4H4C2.9,4,2,4.9,2,6v12c0,1.1,0.9,2,2,2h16c1.1,0,2-0.9,2-2V6C22,4.9,21.1,4,20,4z M8,18H4V6h4V18z M14,18h-4V6h4V18z M20,18h-4V6h4V18z"/>`);
var __glob_0_235 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": view_week
}, Symbol.toStringTag, { value: "Module" }));
var view_week_reverse = _icon_template(`<path d="M20,4H4C2.9,4,2,4.9,2,6v12c0,1.1,0.9,2,2,2h16c1.1,0,2-0.9,2-2V6C22,4.9,21.1,4,20,4z M8,18H4V6h4V18z M14,18h-4V6h4V18z M20,18h-4V6h4V18z M0,12 L24,12"/>`);
var __glob_0_236 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": view_week_reverse
}, Symbol.toStringTag, { value: "Module" }));
var vignette = _icon_template(`<path d="M21 3H3c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h18c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-9 15c-4.42 0-8-2.69-8-6s3.58-6 8-6 8 2.69 8 6-3.58 6-8 6z"/>`);
var __glob_0_237 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": vignette
}, Symbol.toStringTag, { value: "Module" }));
var vintage = _icon_template(`<path d="M18.7 12.4c-.28-.16-.57-.29-.86-.4.29-.11.58-.24.86-.4 1.92-1.11 2.99-3.12 3-5.19-1.79-1.03-4.07-1.11-6 0-.28.16-.54.35-.78.54.05-.31.08-.63.08-.95 0-2.22-1.21-4.15-3-5.19C10.21 1.85 9 3.78 9 6c0 .32.03.64.08.95-.24-.2-.5-.39-.78-.55-1.92-1.11-4.2-1.03-6 0 0 2.07 1.07 4.08 3 5.19.28.16.57.29.86.4-.29.11-.58.24-.86.4-1.92 1.11-2.99 3.12-3 5.19 1.79 1.03 4.07 1.11 6 0 .28-.16.54-.35.78-.54-.05.32-.08.64-.08.96 0 2.22 1.21 4.15 3 5.19 1.79-1.04 3-2.97 3-5.19 0-.32-.03-.64-.08-.95.24.2.5.38.78.54 1.92 1.11 4.2 1.03 6 0-.01-2.07-1.08-4.08-3-5.19zM12 16c-2.21 0-4-1.79-4-4s1.79-4 4-4 4 1.79 4 4-1.79 4-4 4z"/>`);
var __glob_0_238 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": vintage
}, Symbol.toStringTag, { value: "Module" }));
var visible = _icon_template(`<path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>`);
var __glob_0_239 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": visible
}, Symbol.toStringTag, { value: "Module" }));
var visible_off = _icon_template(`<path d="M12 6c3.79 0 7.17 2.13 8.82 5.5-.59 1.22-1.42 2.27-2.41 3.12l1.41 1.41c1.39-1.23 2.49-2.77 3.18-4.53C21.27 7.11 17 4 12 4c-1.27 0-2.49.2-3.64.57l1.65 1.65C10.66 6.09 11.32 6 12 6zm-1.07 1.14L13 9.21c.57.25 1.03.71 1.28 1.28l2.07 2.07c.08-.34.14-.7.14-1.07C16.5 9.01 14.48 7 12 7c-.37 0-.72.05-1.07.14zM2.01 3.87l2.68 2.68C3.06 7.83 1.77 9.53 1 11.5 2.73 15.89 7 19 12 19c1.52 0 2.98-.29 4.32-.82l3.42 3.42 1.41-1.41L3.42 2.45 2.01 3.87zm7.5 7.5l2.61 2.61c-.04.01-.08.02-.12.02-1.38 0-2.5-1.12-2.5-2.5 0-.05.01-.08.01-.13zm-3.4-3.4l1.75 1.75c-.23.55-.36 1.15-.36 1.78 0 2.48 2.02 4.5 4.5 4.5.63 0 1.23-.13 1.77-.36l.98.98c-.88.24-1.8.38-2.75.38-3.79 0-7.17-2.13-8.82-5.5.7-1.43 1.72-2.61 2.93-3.53z"/>`);
var __glob_0_240 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": visible_off
}, Symbol.toStringTag, { value: "Module" }));
var volume_down = _icon_template(`
        <path d="M18.5 12c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02zM5 9v6h4l5 5V4L9 9H5z"/>
    `);
var __glob_0_241 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": volume_down
}, Symbol.toStringTag, { value: "Module" }));
var volume_off = _icon_template(`
    <path d="M16.5 12c0-1.77-1.02-3.29-2.5-4.03v2.21l2.45 2.45c.03-.2.05-.41.05-.63zm2.5 0c0 .94-.2 1.82-.54 2.64l1.51 1.51C20.63 14.91 21 13.5 21 12c0-4.28-2.99-7.86-7-8.77v2.06c2.89.86 5 3.54 5 6.71zM4.27 3L3 4.27 7.73 9H3v6h4l5 5v-6.73l4.25 4.25c-.67.52-1.42.93-2.25 1.18v2.06c1.38-.31 2.63-.95 3.69-1.81L19.73 21 21 19.73l-9-9L4.27 3zM12 4L9.91 6.09 12 8.18V4z"/>
`);
var __glob_0_242 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": volume_off
}, Symbol.toStringTag, { value: "Module" }));
var volume_up = _icon_template(`
    <path d="M3 9v6h4l5 5V4L7 9H3zm13.5 3c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02zM14 3.23v2.06c2.89.86 5 3.54 5 6.71s-2.11 5.85-5 6.71v2.06c4.01-.91 7-4.49 7-8.77s-2.99-7.86-7-8.77z"/>
`);
var __glob_0_243 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": volume_up
}, Symbol.toStringTag, { value: "Module" }));
var wave = _icon_template(`<path d="M17 16.99c-1.35 0-2.2.42-2.95.8-.65.33-1.18.6-2.05.6-.9 0-1.4-.25-2.05-.6-.75-.38-1.57-.8-2.95-.8s-2.2.42-2.95.8c-.65.33-1.17.6-2.05.6v1.95c1.35 0 2.2-.42 2.95-.8.65-.33 1.17-.6 2.05-.6s1.4.25 2.05.6c.75.38 1.57.8 2.95.8s2.2-.42 2.95-.8c.65-.33 1.18-.6 2.05-.6.9 0 1.4.25 2.05.6.75.38 1.58.8 2.95.8v-1.95c-.9 0-1.4-.25-2.05-.6-.75-.38-1.6-.8-2.95-.8zm0-4.45c-1.35 0-2.2.43-2.95.8-.65.32-1.18.6-2.05.6-.9 0-1.4-.25-2.05-.6-.75-.38-1.57-.8-2.95-.8s-2.2.43-2.95.8c-.65.32-1.17.6-2.05.6v1.95c1.35 0 2.2-.43 2.95-.8.65-.35 1.15-.6 2.05-.6s1.4.25 2.05.6c.75.38 1.57.8 2.95.8s2.2-.43 2.95-.8c.65-.35 1.15-.6 2.05-.6s1.4.25 2.05.6c.75.38 1.58.8 2.95.8v-1.95c-.9 0-1.4-.25-2.05-.6-.75-.38-1.6-.8-2.95-.8zm2.95-8.08c-.75-.38-1.58-.8-2.95-.8s-2.2.42-2.95.8c-.65.32-1.18.6-2.05.6-.9 0-1.4-.25-2.05-.6-.75-.37-1.57-.8-2.95-.8s-2.2.42-2.95.8c-.65.33-1.17.6-2.05.6v1.93c1.35 0 2.2-.43 2.95-.8.65-.33 1.17-.6 2.05-.6s1.4.25 2.05.6c.75.38 1.57.8 2.95.8s2.2-.43 2.95-.8c.65-.32 1.18-.6 2.05-.6.9 0 1.4.25 2.05.6.75.38 1.58.8 2.95.8V5.04c-.9 0-1.4-.25-2.05-.58zM17 8.09c-1.35 0-2.2.43-2.95.8-.65.35-1.15.6-2.05.6s-1.4-.25-2.05-.6c-.75-.38-1.57-.8-2.95-.8s-2.2.43-2.95.8c-.65.35-1.15.6-2.05.6v1.95c1.35 0 2.2-.43 2.95-.8.65-.32 1.18-.6 2.05-.6s1.4.25 2.05.6c.75.38 1.57.8 2.95.8s2.2-.43 2.95-.8c.65-.32 1.18-.6 2.05-.6.9 0 1.4.25 2.05.6.75.38 1.58.8 2.95.8V9.49c-.9 0-1.4-.25-2.05-.6-.75-.38-1.6-.8-2.95-.8z"/>`);
var __glob_0_244 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": wave
}, Symbol.toStringTag, { value: "Module" }));
var waves = _icon_template(`<path d="M17 16.99c-1.35 0-2.2.42-2.95.8-.65.33-1.18.6-2.05.6-.9 0-1.4-.25-2.05-.6-.75-.38-1.57-.8-2.95-.8s-2.2.42-2.95.8c-.65.33-1.17.6-2.05.6v1.95c1.35 0 2.2-.42 2.95-.8.65-.33 1.17-.6 2.05-.6s1.4.25 2.05.6c.75.38 1.57.8 2.95.8s2.2-.42 2.95-.8c.65-.33 1.18-.6 2.05-.6.9 0 1.4.25 2.05.6.75.38 1.58.8 2.95.8v-1.95c-.9 0-1.4-.25-2.05-.6-.75-.38-1.6-.8-2.95-.8zm0-4.45c-1.35 0-2.2.43-2.95.8-.65.32-1.18.6-2.05.6-.9 0-1.4-.25-2.05-.6-.75-.38-1.57-.8-2.95-.8s-2.2.43-2.95.8c-.65.32-1.17.6-2.05.6v1.95c1.35 0 2.2-.43 2.95-.8.65-.35 1.15-.6 2.05-.6s1.4.25 2.05.6c.75.38 1.57.8 2.95.8s2.2-.43 2.95-.8c.65-.35 1.15-.6 2.05-.6s1.4.25 2.05.6c.75.38 1.58.8 2.95.8v-1.95c-.9 0-1.4-.25-2.05-.6-.75-.38-1.6-.8-2.95-.8zm2.95-8.08c-.75-.38-1.58-.8-2.95-.8s-2.2.42-2.95.8c-.65.32-1.18.6-2.05.6-.9 0-1.4-.25-2.05-.6-.75-.37-1.57-.8-2.95-.8s-2.2.42-2.95.8c-.65.33-1.17.6-2.05.6v1.93c1.35 0 2.2-.43 2.95-.8.65-.33 1.17-.6 2.05-.6s1.4.25 2.05.6c.75.38 1.57.8 2.95.8s2.2-.43 2.95-.8c.65-.32 1.18-.6 2.05-.6.9 0 1.4.25 2.05.6.75.38 1.58.8 2.95.8V5.04c-.9 0-1.4-.25-2.05-.58zM17 8.09c-1.35 0-2.2.43-2.95.8-.65.35-1.15.6-2.05.6s-1.4-.25-2.05-.6c-.75-.38-1.57-.8-2.95-.8s-2.2.43-2.95.8c-.65.35-1.15.6-2.05.6v1.95c1.35 0 2.2-.43 2.95-.8.65-.32 1.18-.6 2.05-.6s1.4.25 2.05.6c.75.38 1.57.8 2.95.8s2.2-.43 2.95-.8c.65-.32 1.18-.6 2.05-.6.9 0 1.4.25 2.05.6.75.38 1.58.8 2.95.8V9.49c-.9 0-1.4-.25-2.05-.6-.75-.38-1.6-.8-2.95-.8z"/>`);
var __glob_0_245 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": waves
}, Symbol.toStringTag, { value: "Module" }));
var web = _icon_template(`<path d="M20 4H4c-1.1 0-1.99.9-1.99 2L2 18c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2zm-5 14H4v-4h11v4zm0-5H4V9h11v4zm5 5h-4V9h4v9z"/>`);
var __glob_0_246 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": web
}, Symbol.toStringTag, { value: "Module" }));
var west = _icon_template(`<path d="M9,19l1.41-1.41L5.83,13H22V11H5.83l4.59-4.59L9,5l-7,7L9,19z"/>`);
var __glob_0_247 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": west
}, Symbol.toStringTag, { value: "Module" }));
var width$1 = _icon_template(`<polygon transform="rotate(90 12 12)" points="13,6.99 16,6.99 12,3 8,6.99 11,6.99 11,17.01 8,17.01 12,21 16,17.01 13,17.01"/>`);
var __glob_0_248 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": width$1
}, Symbol.toStringTag, { value: "Module" }));
var wrap = _icon_template(`<path d="M11 9l1.42 1.42L8.83 14H18V4h2v12H8.83l3.59 3.58L11 21l-6-6 6-6z"/>`);
var __glob_0_249 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": wrap
}, Symbol.toStringTag, { value: "Module" }));
var wrap_text = _icon_template(`<path d="M4 19h6v-2H4v2zM20 5H4v2h16V5zm-3 6H4v2h13.25c1.1 0 2 .9 2 2s-.9 2-2 2H15v-2l-3 3 3 3v-2h2c2.21 0 4-1.79 4-4s-1.79-4-4-4z"/>`);
var __glob_0_250 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": wrap_text
}, Symbol.toStringTag, { value: "Module" }));
const modules$7 = { "./icon_list/_icon_template.js": __glob_0_0$7, "./icon_list/account_tree.js": __glob_0_1$7, "./icon_list/add.js": __glob_0_2$6, "./icon_list/add_box.js": __glob_0_3$6, "./icon_list/add_circle.js": __glob_0_4$6, "./icon_list/add_note.js": __glob_0_5$6, "./icon_list/align_center.js": __glob_0_6$6, "./icon_list/align_horizontal_center.js": __glob_0_7$6, "./icon_list/align_horizontal_left.js": __glob_0_8$6, "./icon_list/align_horizontal_right.js": __glob_0_9$5, "./icon_list/align_justify.js": __glob_0_10$5, "./icon_list/align_left.js": __glob_0_11$5, "./icon_list/align_right.js": __glob_0_12$5, "./icon_list/align_vertical_bottom.js": __glob_0_13$5, "./icon_list/align_vertical_center.js": __glob_0_14$5, "./icon_list/align_vertical_top.js": __glob_0_15$4, "./icon_list/alternate.js": __glob_0_16$4, "./icon_list/alternate_reverse.js": __glob_0_17$4, "./icon_list/apps.js": __glob_0_18$4, "./icon_list/archive.js": __glob_0_19$4, "./icon_list/arrowLeft.js": __glob_0_20$4, "./icon_list/arrowRight.js": __glob_0_21$3, "./icon_list/arrow_right.js": __glob_0_22$3, "./icon_list/artboard.js": __glob_0_23$3, "./icon_list/auto_awesome.js": __glob_0_24$3, "./icon_list/autorenew.js": __glob_0_25$2, "./icon_list/ballot.js": __glob_0_26$2, "./icon_list/bar_chart.js": __glob_0_27$2, "./icon_list/blur.js": __glob_0_28$2, "./icon_list/blur_linear.js": __glob_0_29$2, "./icon_list/boolean_difference.js": __glob_0_30$2, "./icon_list/boolean_intersection.js": __glob_0_31$2, "./icon_list/boolean_union.js": __glob_0_32$2, "./icon_list/boolean_xor.js": __glob_0_33$2, "./icon_list/border_all.js": __glob_0_34$2, "./icon_list/border_inner.js": __glob_0_35$2, "./icon_list/border_style.js": __glob_0_36$2, "./icon_list/bottom.js": __glob_0_37$2, "./icon_list/broken_image.js": __glob_0_38$2, "./icon_list/brush.js": __glob_0_39$2, "./icon_list/build.js": __glob_0_40$2, "./icon_list/camera_roll.js": __glob_0_41$2, "./icon_list/cat.js": __glob_0_42$2, "./icon_list/center.js": __glob_0_43$2, "./icon_list/chart.js": __glob_0_44$2, "./icon_list/check.js": __glob_0_45$2, "./icon_list/chevron_left.js": __glob_0_46$2, "./icon_list/chevron_right.js": __glob_0_47$2, "./icon_list/circle.js": __glob_0_48$2, "./icon_list/close.js": __glob_0_49$2, "./icon_list/code.js": __glob_0_50$2, "./icon_list/color.js": __glob_0_51$2, "./icon_list/color_lens.js": __glob_0_52$1, "./icon_list/control_point.js": __glob_0_53$1, "./icon_list/copy.js": __glob_0_54$1, "./icon_list/create_folder.js": __glob_0_55$1, "./icon_list/cube.js": __glob_0_56$1, "./icon_list/cylinder.js": __glob_0_57$1, "./icon_list/dahaze.js": __glob_0_58$1, "./icon_list/dark.js": __glob_0_59$1, "./icon_list/delete_forever.js": __glob_0_60$1, "./icon_list/device_hub.js": __glob_0_61$1, "./icon_list/diffuse.js": __glob_0_62$1, "./icon_list/direction.js": __glob_0_63$1, "./icon_list/doc.js": __glob_0_64$1, "./icon_list/drag_handle.js": __glob_0_65$1, "./icon_list/drag_indicator.js": __glob_0_66$1, "./icon_list/draw.js": __glob_0_67$1, "./icon_list/east.js": __glob_0_68$1, "./icon_list/edit.js": __glob_0_69$1, "./icon_list/end.js": __glob_0_70$1, "./icon_list/exit_to_app.js": __glob_0_71$1, "./icon_list/expand.js": __glob_0_72$1, "./icon_list/expand_more.js": __glob_0_73$1, "./icon_list/export.js": __glob_0_74$1, "./icon_list/face.js": __glob_0_75$1, "./icon_list/fast_forward.js": __glob_0_76$1, "./icon_list/fast_rewind.js": __glob_0_77$1, "./icon_list/file_copy.js": __glob_0_78$1, "./icon_list/filter.js": __glob_0_79$1, "./icon_list/flag.js": __glob_0_80$1, "./icon_list/flash_on.js": __glob_0_81$1, "./icon_list/flatten.js": __glob_0_82$1, "./icon_list/flex.js": __glob_0_83$1, "./icon_list/flip.js": __glob_0_84$1, "./icon_list/flipY.js": __glob_0_85$1, "./icon_list/flip_camera.js": __glob_0_86$1, "./icon_list/folder.js": __glob_0_87$1, "./icon_list/font_download.js": __glob_0_88$1, "./icon_list/format_bold.js": __glob_0_89$1, "./icon_list/format_indent.js": __glob_0_90$1, "./icon_list/format_line_spacing.js": __glob_0_91$1, "./icon_list/format_shapes.js": __glob_0_92$1, "./icon_list/format_size.js": __glob_0_93$1, "./icon_list/fullscreen.js": __glob_0_94$1, "./icon_list/gps_fixed.js": __glob_0_95$1, "./icon_list/gradient.js": __glob_0_96$1, "./icon_list/grid.js": __glob_0_97$1, "./icon_list/grid3x3.js": __glob_0_98$1, "./icon_list/group.js": __glob_0_99$1, "./icon_list/height.js": __glob_0_100$1, "./icon_list/highlight_at.js": __glob_0_101$1, "./icon_list/horizontal_align_center.js": __glob_0_102$1, "./icon_list/horizontal_distribute.js": __glob_0_103$1, "./icon_list/horizontal_rule.js": __glob_0_104$1, "./icon_list/image.js": __glob_0_105$1, "./icon_list/input.js": __glob_0_106$1, "./icon_list/italic.js": __glob_0_107$1, "./icon_list/join_full.js": __glob_0_108$1, "./icon_list/join_right.js": __glob_0_109$1, "./icon_list/justify_content_space_around.js": __glob_0_110$1, "./icon_list/keyboard.js": __glob_0_111$1, "./icon_list/keyboard_arrow_down.js": __glob_0_112$1, "./icon_list/keyboard_arrow_left.js": __glob_0_113$1, "./icon_list/keyboard_arrow_right.js": __glob_0_114$1, "./icon_list/keyboard_arrow_up.js": __glob_0_115$1, "./icon_list/landscape.js": __glob_0_116$1, "./icon_list/launch.js": __glob_0_117$1, "./icon_list/layers.js": __glob_0_118$1, "./icon_list/layout_default.js": __glob_0_119, "./icon_list/layout_flex.js": __glob_0_120, "./icon_list/layout_grid.js": __glob_0_121, "./icon_list/left.js": __glob_0_122, "./icon_list/left_hide.js": __glob_0_123, "./icon_list/lens.js": __glob_0_124, "./icon_list/light.js": __glob_0_125, "./icon_list/line_cap_butt.js": __glob_0_126, "./icon_list/line_cap_round.js": __glob_0_127, "./icon_list/line_cap_square.js": __glob_0_128, "./icon_list/line_chart.js": __glob_0_129, "./icon_list/line_join_bevel.js": __glob_0_130, "./icon_list/line_join_miter.js": __glob_0_131, "./icon_list/line_join_round.js": __glob_0_132, "./icon_list/line_style.js": __glob_0_133, "./icon_list/line_weight.js": __glob_0_134, "./icon_list/list.js": __glob_0_135, "./icon_list/local_library.js": __glob_0_136, "./icon_list/local_movie.js": __glob_0_137, "./icon_list/lock.js": __glob_0_138, "./icon_list/lock_open.js": __glob_0_139, "./icon_list/looks.js": __glob_0_140, "./icon_list/margin.js": __glob_0_141, "./icon_list/merge.js": __glob_0_142, "./icon_list/middle.js": __glob_0_143, "./icon_list/navigation.js": __glob_0_144, "./icon_list/near_me.js": __glob_0_145, "./icon_list/north.js": __glob_0_146, "./icon_list/note.js": __glob_0_147, "./icon_list/nowrap.js": __glob_0_148, "./icon_list/opacity.js": __glob_0_149, "./icon_list/outline.js": __glob_0_150, "./icon_list/outline_circle.js": __glob_0_151, "./icon_list/outline_image.js": __glob_0_152, "./icon_list/outline_rect.js": __glob_0_153, "./icon_list/outline_shape.js": __glob_0_154, "./icon_list/padding.js": __glob_0_155, "./icon_list/paint.js": __glob_0_156, "./icon_list/palette.js": __glob_0_157, "./icon_list/pantool.js": __glob_0_158, "./icon_list/pattern_check.js": __glob_0_159, "./icon_list/pattern_cross_dot.js": __glob_0_160, "./icon_list/pattern_dot.js": __glob_0_161, "./icon_list/pattern_grid.js": __glob_0_162, "./icon_list/pattern_horizontal_line.js": __glob_0_163, "./icon_list/pause.js": __glob_0_164, "./icon_list/pentool.js": __glob_0_165, "./icon_list/photo.js": __glob_0_166, "./icon_list/play.js": __glob_0_167, "./icon_list/plugin.js": __glob_0_168, "./icon_list/polygon.js": __glob_0_169, "./icon_list/power_input.js": __glob_0_170, "./icon_list/publish.js": __glob_0_171, "./icon_list/rect.js": __glob_0_172, "./icon_list/redo.js": __glob_0_173, "./icon_list/refresh.js": __glob_0_174, "./icon_list/remove.js": __glob_0_175, "./icon_list/remove2.js": __glob_0_176, "./icon_list/repeat.js": __glob_0_177, "./icon_list/replay.js": __glob_0_178, "./icon_list/right.js": __glob_0_179, "./icon_list/right_hide.js": __glob_0_180, "./icon_list/rotate.js": __glob_0_181, "./icon_list/rotate_left.js": __glob_0_182, "./icon_list/round.js": __glob_0_183, "./icon_list/same_height.js": __glob_0_184, "./icon_list/same_width.js": __glob_0_185, "./icon_list/save.js": __glob_0_186, "./icon_list/scatter.js": __glob_0_187, "./icon_list/screen.js": __glob_0_188, "./icon_list/setting.js": __glob_0_189, "./icon_list/settings_input_component.js": __glob_0_190, "./icon_list/shadow.js": __glob_0_191, "./icon_list/shape.js": __glob_0_192, "./icon_list/shuffle.js": __glob_0_193, "./icon_list/size.js": __glob_0_194, "./icon_list/skip_next.js": __glob_0_195, "./icon_list/skip_prev.js": __glob_0_196, "./icon_list/smooth.js": __glob_0_197, "./icon_list/source.js": __glob_0_198, "./icon_list/south.js": __glob_0_199, "./icon_list/space.js": __glob_0_200, "./icon_list/specular.js": __glob_0_201, "./icon_list/speed.js": __glob_0_202, "./icon_list/star.js": __glob_0_203, "./icon_list/start.js": __glob_0_204, "./icon_list/storage.js": __glob_0_205, "./icon_list/straighten.js": __glob_0_206, "./icon_list/strikethrough.js": __glob_0_207, "./icon_list/stroke_to_path.js": __glob_0_208, "./icon_list/swap_horiz.js": __glob_0_209, "./icon_list/switch_left.js": __glob_0_210, "./icon_list/switch_right.js": __glob_0_211, "./icon_list/sync.js": __glob_0_212, "./icon_list/table_rows.js": __glob_0_213, "./icon_list/text_rotate.js": __glob_0_214, "./icon_list/texture.js": __glob_0_215, "./icon_list/timer.js": __glob_0_216, "./icon_list/title.js": __glob_0_217, "./icon_list/to_back.js": __glob_0_218, "./icon_list/to_front.js": __glob_0_219, "./icon_list/tonality.js": __glob_0_220, "./icon_list/top.js": __glob_0_221, "./icon_list/transform.js": __glob_0_222, "./icon_list/underline.js": __glob_0_223, "./icon_list/undo.js": __glob_0_224, "./icon_list/unfold.js": __glob_0_225, "./icon_list/vertical_align_baseline.js": __glob_0_226, "./icon_list/vertical_align_bottom.js": __glob_0_227, "./icon_list/vertical_align_center.js": __glob_0_228, "./icon_list/vertical_align_stretch.js": __glob_0_229, "./icon_list/vertical_align_top.js": __glob_0_230, "./icon_list/vertical_distribute.js": __glob_0_231, "./icon_list/video.js": __glob_0_232, "./icon_list/view_comfy.js": __glob_0_233, "./icon_list/view_list.js": __glob_0_234, "./icon_list/view_week.js": __glob_0_235, "./icon_list/view_week_reverse.js": __glob_0_236, "./icon_list/vignette.js": __glob_0_237, "./icon_list/vintage.js": __glob_0_238, "./icon_list/visible.js": __glob_0_239, "./icon_list/visible_off.js": __glob_0_240, "./icon_list/volume_down.js": __glob_0_241, "./icon_list/volume_off.js": __glob_0_242, "./icon_list/volume_up.js": __glob_0_243, "./icon_list/wave.js": __glob_0_244, "./icon_list/waves.js": __glob_0_245, "./icon_list/web.js": __glob_0_246, "./icon_list/west.js": __glob_0_247, "./icon_list/width.js": __glob_0_248, "./icon_list/wrap.js": __glob_0_249, "./icon_list/wrap_text.js": __glob_0_250 };
const obj$3 = {};
Object.entries(modules$7).forEach(([key, value]) => {
  key = key.replace("./icon_list/", "").replace(".js", "");
  obj$3[key] = value.default;
});
function iconUse(name, transform2 = "", opt = { width: 24, height: 24 }) {
  if (!name)
    return "";
  return `<svg viewBox="0 0 ${opt.width} ${opt.height}" xmlns="http://www.w3.org/2000/svg">
  <use href="#icon-${name}" transform="${transform2 || ""}" width="${opt.width}" height="${opt.height}" /> 
</svg>`;
}
function iconUseForPath(pathString2, opt = { width: 24, height: 24 }) {
  return `
    <svg viewBox="0 0 ${opt.width} ${opt.height}" xmlns="http://www.w3.org/2000/svg">
      <path d="${pathString2}" style="fill:${opt.fill || "transparent"};stroke:${opt.stroke || "white"}" stroke-width="1" />
    </svg>
  `;
}
function iconMake(svgString, opt = { width: 24, height: 24 }) {
  return `
    <svg viewBox="0 0 ${opt.width} ${opt.height}" xmlns="http://www.w3.org/2000/svg">
      ${svgString}
    </svg>
  `;
}
function iconBlank() {
  return iconMake(`<path d="M0 0h24v24H0z" fill="none" fill-opacity="0"/>`);
}
class ToolbarButtonMenuItem extends EditorElement {
  initialize() {
    super.initialize();
    const events = this.props.events || [];
    if (events.length) {
      events.forEach((event) => {
        this.on(event, () => this.refresh());
      });
    }
  }
  template() {
    return `<button type="button"  class='elf--toolbar-menu-item' ></button>`;
  }
  [CLICK("$el")]() {
    if (this.props.command) {
      this.$commands.emit(this.props.command, ...this.props.args || []);
    } else if (isFunction(this.props.action)) {
      this.props.action(this.$editor, this);
    } else if (isFunction(this.props.onClick)) {
      this.props.onClick(this.$editor, this);
    }
    if (isFunction(this.props.nextTick)) {
      this.props.nextTick(this.$editor);
    }
  }
  [LOAD("$el") + DOMDIFF]() {
    return `<span class="icon">${iconUse(this.props.icon)}</span><span>${this.props.title || ""}</span>`;
  }
  [BIND("$el")]() {
    const selected = isFunction(this.props.selected) ? this.props.selected(this.$editor) : false;
    return {
      style: __spreadValues({}, this.props.style),
      "data-selected": selected
    };
  }
}
var ToolBarRenderer$2 = "";
function Divider() {
  return `<li class="dropdown-divider"></li>`;
}
class DropdownMenuItem extends EditorElement {
  initialize() {
    super.initialize();
    const events = this.props.events || [];
    if (events.length) {
      events.forEach((event) => {
        this.on(event, () => this.refresh());
      });
    }
  }
  template() {
    var _a;
    const it = this.props;
    const checked = isFunction(it.checked) ? it.checked(this.$editor) : it.checked;
    return `
          <li data-has-children="${Boolean((_a = it.items) == null ? void 0 : _a.length)}"
            ${it.disabled ? "disabled" : ""} 
            ${it.shortcut ? "shortcut" : ""}
            ${checked ? `checked` : ""}
          >
              <span class="icon">${checked ? iconUse("check") : it.icon || ""}</span>
              <div class='menu-item-text'>
                <label>${this.$i18n(it.title)}</label>
                <kbd class="shortcut">${it.shortcut || ""}</kbd>
              </div>
          </li>
        `;
  }
  [CLICK("$el") + PREVENT + STOP]() {
    if (this.props.command) {
      this.emit(this.props.command, ...this.props.args || []);
    } else if (isFunction(this.props.action)) {
      this.props.action(this.$editor, this);
    } else if (isFunction(this.props.onClick)) {
      this.props.action(this.$editor, this);
    }
    if (isFunction(this.props.nextTick)) {
      this.nextTick(() => {
        this.props.nextTick(this.$editor, this);
      });
    }
    if (this.props.closable) {
      this.parent.close();
    }
  }
}
class DropdownCheckboxMenuItem extends DropdownMenuItem {
  template() {
    return `<li class='checkbox'></li>`;
  }
  get checked() {
    if (isFunction(this.props.checked)) {
      return this.props.checked(this.$editor, this);
    }
    return this.props.checked;
  }
  [LOAD("$el") + DOMDIFF]() {
    return `
        <label>
          <input type="checkbox" ${this.checked ? 'checked="checked"' : ""} value="${this.props.value}" /> 
          ${this.$i18n(this.props.title)}
        </label>
      `;
  }
}
class DropdownCustomMenuItem extends DropdownMenuItem {
  template() {
    return `<li class='custom'></li>`;
  }
  getTemplateString() {
    if (isFunction(this.props.template)) {
      return this.props.template(this.$editor, this);
    }
    return this.$i18n(this.props.template);
  }
  [LOAD("$el") + DOMDIFF]() {
    return this.getTemplateString();
  }
}
function DropdownDividerMenuItem() {
  return `<li class="dropdown-divider"></li>`;
}
function DropdownLinkMenuItem() {
  return `<li>
        <a href="${this.props.href}" target="${this.props.target || "_blank"}">${this.$i18n(this.props.title)}</a>
      </li>`;
}
function DropdownTextMenuItem() {
  return `<li class='text'><label>${this.$i18n(this.props.text)}</label></li>`;
}
function makeMenuItem(it, id) {
  if (it === "-") {
    return createComponent("Divider", {
      ref: `${id}-divider`
    });
  }
  if (it === "-" || it.type === "divider") {
    return createComponent("DropdownDividerMenuItem", {
      ref: `${id}-divider`
    });
  }
  if (isString(it)) {
    return createComponent("DropdownTextMenuItem", {
      text: it,
      ref: `${id}-text`
    });
  }
  if (it.type === "link") {
    return createComponent("DropdownLinkMenuItem", {
      href: it.href,
      target: it.target,
      title: it.title,
      closable: it.closable,
      ref: `${id}-link`
    });
  }
  if (it.type === "custom") {
    return createComponent("DropdownCustomMenuItem", {
      action: it.action,
      command: it.command,
      args: it.args,
      icon: it.icon,
      text: it.text,
      events: it.events,
      template: it.template,
      closable: it.closable,
      ref: `${id}-custom`
    });
  }
  if (it.type === "checkbox") {
    return createComponent("DropdownCheckboxMenuItem", {
      checked: it.checked,
      command: it.command,
      args: it.args || [],
      disabled: it.disabled,
      direction: it.direction,
      icon: it.icon,
      nextTick: it.nextTick,
      onClick: it.onClick,
      action: it.action,
      shortcut: it.shortcut,
      title: it.title,
      key: it.key,
      events: it.events,
      closable: it.closable,
      items: it.items || [],
      ref: `${id}-checkbox`
    });
  }
  if (isArray(it.items)) {
    return createComponent("DropdownMenuList", {
      title: it.title,
      items: it.items,
      ref: `${id}-list`
    });
  }
  return createComponent("DropdownMenuItem", {
    checked: it.checked,
    command: it.command,
    args: it.args || [],
    disabled: it.disabled,
    direction: it.direction,
    icon: it.icon,
    nextTick: it.nextTick,
    onClick: it.onClick,
    action: it.action,
    shortcut: it.shortcut,
    title: it.title,
    key: it.key,
    events: it.events,
    closable: it.closable,
    items: it.items || [],
    ref: `${id}-menu-item`
  });
}
class DropdownMenuList extends EditorElement {
  components() {
    return {
      Divider,
      DropdownDividerMenuItem,
      DropdownLinkMenuItem,
      DropdownTextMenuItem,
      DropdownCustomMenuItem,
      DropdownCheckboxMenuItem,
      DropdownMenuList,
      DropdownMenuItem
    };
  }
  get groupId() {
    return `${this.props.id}-groupId`;
  }
  template() {
    return `
        <li class="dropdown-menu-list">
            <label>${this.$i18n(this.props.title)}</label> 
            <span>${iconUse("arrowRight")}</span>              
            <ul>
                ${this.props.items.map((child, index2) => makeMenuItem(child, `${this.groupId}-${index2}`)).join("")}
            </ul>
        </li>
      `;
  }
}
var DropdownMenu$1 = "";
function round(n, k) {
  k = typeof k === "undefined" ? 1 : k;
  return Math.round(n * k) / k;
}
function area$1(x, y, areaWidth = 100) {
  const column = x < 0 ? Math.floor(x / areaWidth) : Math.ceil(x / areaWidth);
  const row = y < 0 ? Math.floor(y / areaWidth) : Math.ceil(y / areaWidth);
  return [row, column];
}
function degreeToRadian(degrees) {
  return degrees * (Math.PI / 180);
}
function div(num, divNum = 1) {
  return num === 0 ? 0 : num / divNum;
}
function radianToDegree(radian) {
  var angle = radian * (180 / Math.PI);
  if (angle < 0) {
    angle = 360 + angle;
  }
  return angle;
}
function getXInCircle(angle, radius, centerX = 0) {
  return centerX + radius * Math.cos(degreeToRadian(angle));
}
function getYInCircle(angle, radius, centerY = 0) {
  return centerY + radius * Math.sin(degreeToRadian(angle));
}
function getXYInCircle(angle, radius, centerX = 0, centerY = 0) {
  return {
    x: getXInCircle(angle, radius, centerX),
    y: getYInCircle(angle, radius, centerY)
  };
}
function getDist(x, y, centerX = 0, centerY = 0) {
  return distance([x, y], [centerX, centerY]);
}
function getPointBetweenVerties(start2, end2, pointDist = 0) {
  return lerp$1([], start2, end2, 1 + pointDist / dist(start2, end2));
}
function vertiesMap(verties, transformView) {
  if (verties.length === 1) {
    return [transformMat4([], verties[0], transformView)];
  } else if (verties.length === 2) {
    return [
      transformMat4([], verties[0], transformView),
      transformMat4([], verties[1], transformView)
    ];
  } else if (verties.length === 3) {
    return [
      transformMat4([], verties[0], transformView),
      transformMat4([], verties[1], transformView),
      transformMat4([], verties[2], transformView)
    ];
  } else if (verties.length === 4) {
    return [
      transformMat4([], verties[0], transformView),
      transformMat4([], verties[1], transformView),
      transformMat4([], verties[2], transformView),
      transformMat4([], verties[3], transformView)
    ];
  } else if (verties.length === 5) {
    return [
      transformMat4([], verties[0], transformView),
      transformMat4([], verties[1], transformView),
      transformMat4([], verties[2], transformView),
      transformMat4([], verties[3], transformView),
      transformMat4([], verties[4], transformView)
    ];
  }
  return verties.map((v) => {
    return transformMat4([], v, transformView);
  });
}
function getTargetPointX(source2, target, axis, nextTarget) {
  return [
    source2,
    [target[0], source2[1], target[2]],
    axis,
    Math.abs(source2[0] - target[0]),
    nextTarget
  ];
}
function getTargetPointY(source2, target, axis, nextTarget) {
  return [
    [target[0], source2[1], source2[2]],
    target,
    axis,
    Math.abs(source2[1] - target[1]),
    nextTarget
  ];
}
function invertTargetPoint(arr, isInvert = false) {
  if (isInvert === false)
    return arr;
  const [source2, target, axis, dist2, newTarget, sourceVerties, targetVerties] = arr;
  if (newTarget) {
    return [
      [target[0], newTarget[1], target[2]],
      [source2[0], newTarget[1], source2[2]],
      axis,
      dist2,
      [source2[0], source2[1], newTarget[2]],
      sourceVerties,
      targetVerties,
      isInvert
    ];
  } else {
    return [
      target,
      source2,
      axis,
      dist2,
      newTarget,
      sourceVerties,
      targetVerties,
      isInvert
    ];
  }
}
function makeGuidePoint(sourceVerties, targetVerties) {
  let leftVerties = sourceVerties;
  let rightVerties = targetVerties;
  let hasInvert = false;
  if (sourceVerties[4][0] - targetVerties[4][0] > 0) {
    leftVerties = targetVerties;
    rightVerties = sourceVerties;
    hasInvert = true;
  }
  const leftCenter = lerp$1([], leftVerties[1], leftVerties[2], 0.5);
  const rightCenter = lerp$1([], rightVerties[0], rightVerties[3], 0.5);
  let pointList = [];
  if (rightVerties[0][1] <= leftCenter[1] && leftCenter[1] <= rightVerties[3][1]) {
    pointList.push(getTargetPointX(leftCenter, rightCenter, "x", null));
  } else if (rightVerties[0][1] <= leftVerties[1][1]) {
    if (rightVerties[3][0] <= leftVerties[1][0] && leftVerties[1][0] <= rightVerties[2][0]) {
      pointList.push(getTargetPointY(rightVerties[3], [rightVerties[3][0], leftVerties[1][1], leftVerties[1][2]], "y", null));
    } else {
      pointList.push(getTargetPointX(leftVerties[1], rightCenter, "x", rightVerties[3]));
    }
  } else if (leftVerties[3][0] <= rightVerties[0][0] && rightVerties[0][0] <= leftVerties[2][0]) {
    pointList.push(getTargetPointY(leftVerties[3], rightVerties[0], "y"));
  } else if (rightVerties[3][0] <= leftVerties[0][0] && leftVerties[0][0] <= rightVerties[2][0]) {
    pointList.push(getTargetPointY([rightVerties[0][0], leftVerties[3][1], leftVerties[3][2]], rightVerties[0], "y"));
  } else if (rightVerties[3][0] <= leftVerties[1][0] && leftVerties[1][0] <= rightVerties[2][0]) {
    pointList.push(getTargetPointY(rightVerties[3], [rightVerties[3][0], leftVerties[1][1], leftVerties[1][2]], "y"));
  } else {
    pointList.push(getTargetPointX(leftVerties[2], rightCenter, "x", rightVerties[0]));
  }
  pointList.sort((a, b) => {
    return a[3] - b[3];
  });
  return invertTargetPoint([...pointList[0], sourceVerties, targetVerties], hasInvert);
}
function getVertiesMaxX(verties) {
  let maxValue = Number.MIN_SAFE_INTEGER;
  verties.forEach((v) => {
    maxValue = Math.max(v[0], maxValue);
  });
  return maxValue;
}
function getVertiesMaxY(verties) {
  let maxValue = Number.MIN_SAFE_INTEGER;
  verties.forEach((v) => {
    maxValue = Math.max(v[1], maxValue);
  });
  return maxValue;
}
function getVertiesMinX(verties) {
  let maxValue = Number.MAX_SAFE_INTEGER;
  verties.forEach((v) => {
    maxValue = Math.min(v[0], maxValue);
  });
  return maxValue;
}
function getVertiesCenterX(verties) {
  let minX = Number.MAX_SAFE_INTEGER;
  let maxX = Number.MIN_SAFE_INTEGER;
  verties.forEach((v) => {
    minX = Math.min(v[0], minX);
    maxX = Math.max(v[0], maxX);
  });
  return Math.round((minX + maxX) / 2);
}
function getVertiesMinY(verties) {
  let maxValue = Number.MAX_SAFE_INTEGER;
  verties.forEach((v) => {
    maxValue = Math.min(v[1], maxValue);
  });
  return maxValue;
}
function getVertiesCenterY(verties) {
  let minY = Number.MAX_SAFE_INTEGER;
  let maxY = Number.MIN_SAFE_INTEGER;
  verties.forEach((v) => {
    minY = Math.min(v[1], minY);
    maxY = Math.max(v[1], maxY);
  });
  return Math.round((minY + maxY) / 2);
}
function calculateAngle(rx, ry) {
  return radianToDegree(Math.atan2(ry, rx));
}
function calculateAngleForVec3(point2, center2, dist2) {
  return calculateAnglePointDistance({ x: point2[0], y: point2[1] }, { x: center2[0], y: center2[1] }, { dx: dist2[0], dy: dist2[1] });
}
function calculateRotationOriginMat4(angle, origin) {
  const view = create$4();
  translate(view, view, origin);
  rotateZ(view, view, degreeToRadian(angle));
  translate(view, view, negate([], origin));
  return view;
}
function calculateMatrix(...args2) {
  const view = create$4();
  args2.forEach((v) => {
    multiply$1(view, view, v);
  });
  return view;
}
function calculateMatrixInverse(...args2) {
  return invert([], calculateMatrix(...args2));
}
function calculateAnglePointDistance(point2, center2, dist2) {
  var x = point2.x - center2.x;
  var y = point2.y - center2.y;
  var angle1 = calculateAngle(x, y);
  var x2 = point2.x + dist2.dx - center2.x;
  var y2 = point2.y + dist2.dy - center2.y;
  var angle = calculateAngle(x2, y2) - angle1;
  return angle;
}
function calculateAngle360(rx, ry) {
  return (calculateAngle(rx, ry) + 180) % 360;
}
const UUID_REG = /[xy]/g;
function uuid() {
  var dt = new Date().getTime();
  var uuid2 = "xxx12-xx-34xx".replace(UUID_REG, function(c2) {
    var r = (dt + Math.random() * 16) % 16 | 0;
    dt = Math.floor(dt / 16);
    return (c2 == "x" ? r : r & 3 | 8).toString(16);
  });
  return uuid2;
}
function uuidShort() {
  var dt = new Date().getTime();
  var uuid2 = "idxxxxxxx".replace(UUID_REG, function(c2) {
    var r = (dt + Math.random() * 16) % 16 | 0;
    dt = Math.floor(dt / 16);
    return (c2 == "x" ? r : r & 3 | 8).toString(16);
  });
  return uuid2;
}
const splitReg$1 = /[\b\t ,\n]/g;
function normalize(str) {
  return str.trim().split(splitReg$1).filter((it) => it).map((it) => +it);
}
const stringToPercent = {
  center: 50,
  top: 0,
  left: 0,
  right: 100,
  bottom: 100
};
class Position {
}
Position.CENTER = "center";
Position.TOP = "top";
Position.RIGHT = "right";
Position.LEFT = "left";
Position.BOTTOM = "bottom";
const REG_CSS_UNIT$1 = /([\d.]+)(px|pt|fr|r?em|deg|vh|vw|m?s|%|g?rad|turn)/gi;
class Length {
  constructor(value = "", unit = "") {
    this.value = value;
    if (isNumber(this.value) && isNaN(this.value)) {
      this.value = 0;
    }
    this.unit = unit;
  }
  [Symbol.toPrimitive](hint) {
    if (hint == "number") {
      return this.value;
    }
    return this.toString();
  }
  static min(...args2) {
    var min = args2.shift();
    for (var i = 0, len2 = args2.length; i < len2; i++) {
      if (min.value > args2[i].value) {
        min = args2[i];
      }
    }
    return min;
  }
  static max(...args2) {
    var max = args2.shift();
    for (var i = 0, len2 = args2.length; i < len2; i++) {
      if (max.value < args2[i].value) {
        max = args2[i];
      }
    }
    return max;
  }
  static string(value) {
    return new Length(value + "", "");
  }
  static number(value) {
    return new Length(+value, "number");
  }
  static px(value) {
    return new Length(+value, "px");
  }
  static em(value) {
    return new Length(+value, "em");
  }
  static percent(value) {
    return new Length(+value, "%");
  }
  static makePercent(value, maxValue) {
    return Length.percent(value / maxValue * 100);
  }
  static deg(value) {
    return new Length(+value, "deg");
  }
  static rad(value) {
    return new Length(+value, "rad");
  }
  static turn(value) {
    return new Length(+value, "turn");
  }
  static fr(value) {
    return new Length(+value, "fr");
  }
  static second(value) {
    return new Length(+value, "s");
  }
  static ms(value) {
    return new Length(+value, "ms");
  }
  static var(value) {
    return new Length(value + "", "--");
  }
  static z() {
    return 0;
  }
  static calc(str) {
    return new Length(str, "calc");
  }
  static parse(obj2) {
    obj2 = obj2 || Length.number(0);
    if (isString(obj2)) {
      obj2 = obj2.trim();
      var arr = obj2.replace(REG_CSS_UNIT$1, "$1 $2").split(" ");
      var isNumberString = +arr[0] == arr[0];
      if (isNumberString) {
        return new Length(+arr[0], arr[1]);
      } else {
        return new Length(arr[0]);
      }
    }
    if (obj2 instanceof Length) {
      return obj2;
    } else if (obj2.unit) {
      if (obj2.unit == "%" || obj2.unit == "percent") {
        var value = 0;
        if (isNotUndefined(obj2.percent)) {
          value = obj2.percent;
        } else if (isNotUndefined(obj2.value)) {
          value = obj2.value;
        }
        return Length.percent(value);
      } else if (obj2.unit == "px") {
        var value = 0;
        if (isNotUndefined(obj2.px)) {
          value = obj2.px;
        } else if (isNotUndefined(obj2.value)) {
          value = obj2.value;
        }
        return value;
      } else if (obj2.unit == "em") {
        var value = 0;
        if (isNotUndefined(obj2.em)) {
          value = obj2.em;
        } else if (isNotUndefined(obj2.value)) {
          value = obj2.value;
        }
        return Length.em(value);
      } else if (obj2.unit == "deg") {
        var value = 0;
        if (isNotUndefined(obj2.deg)) {
          value = obj2.deg;
        } else if (isNotUndefined(obj2.value)) {
          value = obj2.value;
        }
        return Length.deg(value);
      } else if (obj2.unit == "turn") {
        var value = 0;
        if (isNotUndefined(obj2.deg)) {
          value = obj2.turn;
        } else if (isNotUndefined(obj2.value)) {
          value = obj2.value;
        }
        return Length.turn(value);
      } else if (obj2.unit == "s") {
        var value = 0;
        if (isNotUndefined(obj2.second)) {
          value = obj2.second;
        } else if (isNotUndefined(obj2.value)) {
          value = obj2.value;
        }
        return Length.second(value);
      } else if (obj2.unit == "ms") {
        var value = 0;
        if (isNotUndefined(obj2.ms)) {
          value = obj2.ms;
        } else if (isNotUndefined(obj2.value)) {
          value = obj2.value;
        }
        return Length.ms(value);
      } else if (obj2.unit == "number") {
        var value = 0;
        if (isNotUndefined(obj2.value)) {
          value = obj2.value;
        }
        return Length.number(value);
      } else if (obj2.unit == "--") {
        var value = 0;
        if (isNotUndefined(obj2.value)) {
          value = obj2.value;
        }
        return Length.var(value);
      } else if (obj2.unit === "" || obj2.unit === "string") {
        var value = "";
        if (isNotUndefined(obj2.str)) {
          value = obj2.str;
        } else if (isNotUndefined(obj2.value)) {
          value = obj2.value;
        }
        return Length.string(value);
      }
    }
    return Length.string(obj2);
  }
  toString() {
    return this.getUnitText();
  }
  getUnitText() {
    switch (this.unit) {
      case "string":
      case "number":
        return this.value + "";
      case "var":
        return `var(--${this.value})`;
      case "calc":
        return `calc(${this.value})`;
      default:
        return this.value + this.unit;
    }
  }
  isUnitType(unit) {
    return this.unit === unit;
  }
  isCalc() {
    return this.isUnitType("calc");
  }
  isFr() {
    return this.isUnitType("fr");
  }
  isPercent() {
    return this.isUnitType("%");
  }
  isPx() {
    return this.isUnitType("px");
  }
  isEm() {
    return this.isUnitType("em");
  }
  isDeg() {
    return this.isUnitType("deg");
  }
  isRad() {
    return this.isUnitType("rad");
  }
  isTurn() {
    return this.isUnitType("turn");
  }
  isSecond() {
    return this.isUnitType("s");
  }
  isMs() {
    return this.isUnitType("ms");
  }
  isNumber() {
    return this.isUnitType("number");
  }
  isString() {
    return this.isUnitType("");
  }
  isVar() {
    return this.isUnitType("--");
  }
  isNaN() {
    return isNumber(this.value) && isNaN(this.value);
  }
  set(value) {
    this.value = value;
    return this;
  }
  add(obj2) {
    this.value += +obj2;
    return this;
  }
  sub(obj2) {
    return this.add(-1 * obj2);
  }
  mul(obj2) {
    this.value *= +obj2;
    return this;
  }
  div(obj2) {
    this.value /= +obj2;
    return this;
  }
  mod(obj2) {
    this.value %= +obj2;
    return this;
  }
  clone() {
    return new Length(this.value, this.unit);
  }
  getUnitName() {
    return this.unit === "%" ? "percent" : this.unit;
  }
  get isAuto() {
    return this.value === "auto" || this.unit === "auto";
  }
  get isNotAuto() {
    return !this.isAuto;
  }
  toJSON() {
    return this.toString();
  }
  rate(maxValue = 100) {
    return this.value / maxValue;
  }
  stringToPercent() {
    if (isNotUndefined(stringToPercent[this.value])) {
      return Length.percent(stringToPercent[this.value]);
    }
    return Length.percent(0);
  }
  stringToEm(maxValue) {
    return this.stringToPercent().toEm(maxValue);
  }
  stringToPx(maxValue) {
    return this.stringToPercent().toPx(maxValue);
  }
  toPercent(maxValue, fontSize = 16) {
    if (this.isPercent()) {
      return this.clone();
    } else if (this.isPx()) {
      return Length.percent(this.value * 100 / maxValue);
    } else if (this.isEm()) {
      return Length.percent(this.value * fontSize * 100 / maxValue);
    } else if (this.isString()) {
      return this.stringToPercent(maxValue);
    } else if (this.isDeg()) {
      return Length.percent(this.value / 360 * 100);
    }
  }
  toEm(maxValue, fontSize = 16) {
    if (this.isPercent()) {
      return Length.em(this.value / 100 * maxValue / fontSize);
    } else if (this.isPx()) {
      return Length.em(this.value / fontSize);
    } else if (this.isEm()) {
      return this.clone();
    } else if (this.isString()) {
      return this.stringToEm(maxValue);
    }
  }
  toPx(maxValue, fontSize = 16) {
    if (this.isPercent()) {
      if (isUndefined(maxValue)) {
        return this;
      }
      return Length.px(this.value / 100 * maxValue);
    } else if (this.isPx()) {
      return this.clone();
    } else if (this.isEm()) {
      return Length.px(this.value / 100 * maxValue / fontSize);
    } else if (this.isString()) {
      return this.stringToPx(maxValue);
    } else if (this.isNumber()) {
      return Length.px(this.value).toPx(maxValue);
    }
  }
  toDeg() {
    if (this.isDeg()) {
      return this.clone();
    } else if (this.isTurn()) {
      return Length.deg(this.value * 360);
    } else if (this.isRad()) {
      return Length.deg(radianToDegree(this.value));
    }
  }
  toRad() {
    if (this.isRad()) {
      return this.clone();
    } else if (this.isTurn()) {
      const deg = this.toDeg();
      return Length.rad(degreeToRadian(deg.value));
    } else if (this.isDeg()) {
      return Length.rad(degreeToRadian(this.value));
    }
  }
  toTurn() {
    if (this.isTurn()) {
      return this.clone();
    } else if (this.isDeg()) {
      return Length.turn(this.value / 360);
    }
  }
  toSecond() {
    if (this.isSecond()) {
      return this;
    } else if (this.isMs()) {
      return Length.second(this.value / 1e3);
    }
  }
  toMs() {
    if (this.isSecond()) {
      return Length.ms(this.value * 1e3);
    } else if (this.isMs()) {
      return this;
    }
  }
  to(unit, maxValue, fontSize = 16) {
    if (unit === "px") {
      return this.toPx(maxValue, fontSize);
    } else if (unit === "%" || unit === "percent") {
      return this.toPercent(maxValue, fontSize);
    } else if (unit === "em") {
      return this.toEm(maxValue, fontSize);
    } else if (unit === "deg") {
      return this.toDeg();
    } else if (unit === "turn") {
      return this.toTurn();
    }
  }
  toUnit(unit) {
    return new Length(this.value, unit);
  }
  calculate(type, dist2) {
    var func = this[type];
    if (func) {
      return func.call(this, dist2);
    }
    return this;
  }
  includes(...arr) {
    return arr.includes(this.value);
  }
  round(k) {
    return new Length(round(this.value, k), this.unit);
  }
  floor() {
    return new Length(Math.floor(this.value), this.unit);
  }
  equals(t) {
    return this.is(t.value) && this.isUnitType(t.unit);
  }
  is(value) {
    return this.value === value;
  }
  clamp(min, max) {
    return new Length(Math.max(min, Math.min(max, this.value)), this.unit);
  }
  isZero() {
    return this.value === 0;
  }
  changeUnitValue(px2, maxValue) {
    const unit = this.unit;
    return Length.px(px2).to(unit, maxValue);
  }
  toObject() {
    return { value: this.value, unit: this.unit };
  }
}
Length.auto = Length.string("auto");
class DropdownMenu extends EditorElement {
  components() {
    return {
      Divider,
      DropdownDividerMenuItem,
      DropdownLinkMenuItem,
      DropdownTextMenuItem,
      DropdownCustomMenuItem,
      DropdownCheckboxMenuItem,
      DropdownMenuList,
      DropdownMenuItem
    };
  }
  initialize() {
    super.initialize();
    const events = this.props.events || [];
    if (events.length) {
      events.forEach((event) => {
        this.on(event, () => this.refresh());
      });
    }
  }
  initState() {
    return {
      direction: this.props.direction || "left",
      opened: this.props.opened || false,
      items: this.props.items || [],
      dy: this.props.dy || 0
    };
  }
  findItem(searchKey) {
    return this.state.items.find((it) => it.key && it.key === searchKey);
  }
  template() {
    const { direction: direction2 } = this.state;
    return `
        <div class="${classnames("dropdown-menu", {
      opened: false
    })}" data-direction="${direction2}">
          <span class='icon' ref="$icon"></span>
          <span class='label' ref='$label'></span>
          <span class='dropdown-arrow' ref="$arrow">${iconUse("keyboard_arrow_down")}</span>
          <ul class="dropdown-menu-item-list" ref="$list"></ul>
          <div class="dropdown-menu-arrow">
              <svg viewBox="0 0 12 6" width="12" height="6">
                <path d="M0,6 L6,0 L12,6 "></path>
              </svg>
          </div>
      </div>
      `;
  }
  [LOAD("$icon")]() {
    return isFunction(this.props.icon) ? this.props.icon(this.$editor, this) : this.props.icon;
  }
  [BIND("$label")]() {
    return {
      innerHTML: this.props.title
    };
  }
  [BIND("$el")]() {
    const selected = isFunction(this.props.selected) ? this.props.selected(this.$editor, this) : false;
    return {
      "data-selected": !!selected,
      style: __spreadProps(__spreadValues({}, this.props.style || {}), {
        "--elf--dropdown-menu-width": this.props.width,
        "--elf--dropdown-menu-dy": isNotUndefined(this.props.dy) ? Length.px(this.props.dy) : 0
      })
    };
  }
  close() {
    this.setState({
      opened: false
    }, false);
    this.$el.removeClass("opened");
  }
  toggle() {
    this.setState({
      opened: !this.state.opened
    }, false);
    this.$el.toggleClass("opened", this.state.opened);
    if (this.state.opened) {
      this.emit("hideDropdownMenu");
    }
  }
  get groupId() {
    return this.id + "$list";
  }
  [LOAD("$list") + DOMDIFF]() {
    return this.state.items.map((it, index2) => makeMenuItem(it, `${this.groupId}-${index2}`));
  }
  checkDropdownOpen(e) {
    const ul = Dom.create(e.target).closest("dropdown-menu-item-list");
    if (!ul)
      return true;
    return false;
  }
  [CLICK("$arrow") + IF("checkDropdownOpen")]() {
    this.toggle();
  }
  [CLICK("$label") + IF("checkDropdownOpen")]() {
    this.toggle();
  }
  [CLICK("$icon")]() {
    const selectedKey = isFunction(this.props.selectedKey) ? this.props.selectedKey(this.$editor, this) : this.props.selectedKey;
    const menuItem = this.findItem(selectedKey);
    if (!menuItem) {
      if (isFunction(this.props.action)) {
        this.props.action(this.$editor, this);
      }
      return;
    }
    const command = menuItem.command;
    const args2 = menuItem.args;
    const action = menuItem.action;
    const nextTick = menuItem.nextTick;
    if (command) {
      this.$commands.emit(command, ...args2);
    } else if (action && isFunction(action)) {
      this.emit(action);
    }
    if (nextTick && isFunction(nextTick)) {
      this.nextTick(() => {
        nextTick(this.$editor);
      });
    }
    this.close();
  }
  [SUBSCRIBE_SELF("updateMenuItems")](items) {
    this.setState({ items });
  }
  [SUBSCRIBE("hideDropdownMenu")]() {
    this.close();
  }
  [POINTERSTART("document")](e) {
    const $target = Dom.create(e.target);
    const $dropdown = $target.closest("dropdown-menu");
    if (!$dropdown) {
      this.close();
    } else if ($dropdown.el !== this.$el.el) {
      this.close();
    }
  }
}
class ToolBarRenderer$1 extends EditorElement {
  checkProps(props = {}) {
    return props;
  }
  components() {
    return {
      DropdownMenu,
      ToolbarButtonMenuItem
    };
  }
  template() {
    return `<div class="elf--toolbar-renderer"></div>`;
  }
  [LOAD("$el")]() {
    return this.props.items.map((item, index2) => {
      return this.renderMenuItem(item, index2);
    });
  }
  renderMenuItem(item, index2) {
    switch (item.type) {
      case MenuItemType.LINK:
        return this.renderLink(item, index2);
      case MenuItemType.SUBMENU:
        return this.renderMenu(item, index2);
      case MenuItemType.BUTTON:
        return this.renderButton(item, index2);
      case MenuItemType.DROPDOWN:
        return this.renderDropdown(item, index2);
      default:
        return this.renderButton(item, index2);
    }
  }
  renderButton(item, index2) {
    return createComponent("ToolbarButtonMenuItem", {
      ref: "$button-" + index2,
      title: item.title,
      icon: item.icon,
      command: item.command,
      shortcut: item.shortcut,
      args: item.args,
      nextTick: item.nextTick,
      disabled: item.disabled,
      selected: item.selected,
      selectedKey: item.selectedKey,
      action: item.action,
      events: item.events,
      style: item.style
    });
  }
  renderDropdown(item, index2) {
    return createComponent("DropdownMenu", __spreadProps(__spreadValues({
      ref: "$dropdown-" + index2
    }, item), {
      items: item.items,
      icon: item.icon,
      title: item.title,
      direction: item.direction,
      events: item.events || [],
      selected: item.selected,
      selectedKey: item.selectedKey,
      action: item.action,
      style: item.style,
      dy: 6
    }), [item.content]);
  }
}
const DEFAULT_TITLE = "";
const DEFAULT_ICON = "";
const DEFAULT_CHECKED = false;
class MenuItem extends EditorElement {
  template() {
    return `
        <button 
            type="button" 
            class='elf--menu-item ${this.getClassName()}' 
            data-no-title="${this.isHideTitle()}" 
            ${this.isHideTitle() && this.isHideTooltip() === false ? `data-tooltip="${this.getTitle()}"` : ""} 
            checked="${this.getChecked() ? "checked" : ""}"
            ${this.isDisabled() ? "disabled" : ""}
            data-direction="${this.getDirection()}"
        >
            <div class="icon ${this.getIcon()}" ref="$icon">${obj$3[this.getIconString()] || this.getIconString() || ""}</div>
            ${this.isHideTitle() ? "" : `<div class="title">${this.getTitle()}</div>`}
            
        </button>
        `;
  }
  getClassName() {
    return "";
  }
  clickButton() {
  }
  getChecked() {
    return DEFAULT_CHECKED;
  }
  isDisabled() {
    return false;
  }
  setSelected(isSelected) {
    this.$el.toggleClass("selected", isSelected);
  }
  getTitle() {
    return DEFAULT_TITLE;
  }
  getIcon() {
    return DEFAULT_ICON;
  }
  setIcon(iconString) {
    this.refs.$icon.html(obj$3[iconString] || iconString || "");
  }
  getIconString() {
    return DEFAULT_ICON;
  }
  isHideTitle() {
    return false;
  }
  isHideTooltip() {
    return true;
  }
  [CLICK()](e) {
    this.clickButton(e);
  }
  getDirection() {
    return this.props.direction || "";
  }
  static createMenuItem(opt = {}) {
    return class extends MenuItem {
      getIconString() {
        return opt.iconString || "add_box";
      }
      getTitle() {
        return opt.title || "New Item";
      }
      isHideTitle() {
        return opt.isHideTitle || true;
      }
      clickButton(e) {
        opt.clickButton(e);
      }
      getDirection() {
        return opt.direction;
      }
    };
  }
}
class ExportView extends MenuItem {
  getIconString() {
    return "launch";
  }
  getTitle() {
    return this.$i18n("menu.item.export.title");
  }
  clickButton() {
    this.emit("showExportView");
  }
}
class ThemeChanger extends MenuItem {
  getIconString() {
    if (this.$config.is("editor.theme", "dark")) {
      return "dark";
    } else {
      return "light";
    }
  }
  getTitle() {
    return "Theme";
  }
  isHideTitle() {
    return true;
  }
  clickButton() {
    if (this.$config.get("editor.theme") === "dark") {
      this.$config.set("editor.theme", "light");
      this.setIcon("light");
    } else {
      this.$config.set("editor.theme", "dark");
      this.setIcon("dark");
    }
  }
}
class BlankToolBar extends EditorElement {
  components() {
    return {
      ToolBarRenderer: ToolBarRenderer$1,
      ThemeChanger,
      ExportView,
      DropdownMenu
    };
  }
  template() {
    return `
            <div class='elf--blank-tool-bar'>
                <div class='left'>
                    ${createComponent("ToolBarRenderer", {
      items: this.$menu.getTargetMenu("toolbar.left")
    })}
                    ${this.$injectManager.generate("toolbar.left")}                                        
                </div>
                <div class='center'>
                    ${createComponent("ToolBarRenderer", {
      items: this.$menu.getTargetMenu("toolbar.center")
    })}
                    ${this.$injectManager.generate("toolbar.center")}                                        
                </div>
                <div class='right'>
                    ${createComponent("ToolBarRenderer", {
      items: this.$menu.getTargetMenu("toolbar.right")
    })}                
                    ${this.$injectManager.generate("toolbar.right")}                    
                    ${createComponent("ThemeChanger")}
                </div>
            </div>
        `;
  }
  [SUBSCRIBE("updateMenu")](target) {
    if (target === "toolbar.left" || target === "toolbar.center" || target === "toolbar.right") {
      this.refresh();
    }
  }
}
var layout$5 = "";
function baseEditor(editor) {
  editor.registerElement({
    Button,
    ToggleButton,
    ToggleCheckBox
  });
  editor.registerAlias({
    "toggle-checkbox": "ToggleCheckBox",
    "toggle-button": "ToggleButton",
    button: "Button"
  });
}
var body_move_ms = {
  key: "body.move.ms",
  defaultValue: 30,
  title: "pointer move delay millisecond",
  description: "Set delay millisecond to moving pointer in body  ",
  type: "number"
};
var __glob_0_0$6 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": body_move_ms
}, Symbol.toStringTag, { value: "Module" }));
var debug_mode$1 = {
  key: "debug.mode",
  defaultValue: false,
  title: "debug mode",
  description: "Set debug mode to on ",
  type: "boolean"
};
var __glob_0_1$6 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": debug_mode$1
}, Symbol.toStringTag, { value: "Module" }));
var editor_cursor = {
  key: "editor.cursor",
  defaultValue: "auto",
  title: "Editor Cursor ",
  description: "Set editor's cursor",
  type: "string"
};
var __glob_0_2$5 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": editor_cursor
}, Symbol.toStringTag, { value: "Module" }));
var editor_theme = {
  key: "editor.theme",
  defaultValue: "light",
  title: "Editor Theme ",
  description: "Set editor's theme",
  type: "string"
};
var __glob_0_3$5 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": editor_theme
}, Symbol.toStringTag, { value: "Module" }));
var event_doubleclick_timing = {
  key: "event.doubleclick.timing",
  defaultValue: 500,
  title: "doubleclick timing",
  description: "whether doubleclick timing is in some seconds",
  type: "number"
};
var __glob_0_4$5 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": event_doubleclick_timing
}, Symbol.toStringTag, { value: "Module" }));
var language_locale = {
  key: "language.locale",
  defaultValue: Language.EN,
  title: "set locale for editor",
  description: "set locale for editor",
  type: "string"
};
var __glob_0_5$5 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": language_locale
}, Symbol.toStringTag, { value: "Module" }));
var set_tool_hand$2 = {
  key: "set.tool.hand",
  defaultValue: false,
  title: "Hand tool",
  description: "Hand tool is on",
  type: "boolean",
  storage: "none"
};
var __glob_0_6$5 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": set_tool_hand$2
}, Symbol.toStringTag, { value: "Module" }));
var store_key = {
  key: "store.key",
  defaultValue: "easylogic.studio",
  title: "Store Key",
  description: "Set localStorage key",
  type: "string"
};
var __glob_0_7$5 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": store_key
}, Symbol.toStringTag, { value: "Module" }));
var style_canvas_background_color = {
  key: "style.canvas.background.color",
  defaultValue: "#ececec",
  title: "Canvas Background Color",
  description: "Set canvas background color",
  type: "color"
};
var __glob_0_8$5 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": style_canvas_background_color
}, Symbol.toStringTag, { value: "Module" }));
const modules$6 = { "./config_list/body.move.ms.js": __glob_0_0$6, "./config_list/debug.mode.js": __glob_0_1$6, "./config_list/editor.cursor.js": __glob_0_2$5, "./config_list/editor.theme.js": __glob_0_3$5, "./config_list/event.doubleclick.timing.js": __glob_0_4$5, "./config_list/language.locale.js": __glob_0_5$5, "./config_list/set.tool.hand.js": __glob_0_6$5, "./config_list/store.key.js": __glob_0_7$5, "./config_list/style.canvas.background.color.js": __glob_0_8$5 };
var configs$2 = Object.values(modules$6).map((it) => it.default);
function defaultConfigs(editor) {
  configs$2.forEach((config) => {
    editor.registerConfig(config);
  });
}
function defaultIcons(editor) {
  editor.registerIcon("artboard", "artboard");
  editor.registerIcon("circle", "lens");
  editor.registerIcon("image", "image");
  editor.registerIcon("text", "title");
  editor.registerIcon("svg-text", "title");
  editor.registerIcon("boolean-path", "pentool");
  editor.registerIcon("svg-path", "pentool");
  editor.registerIcon("polygon", "polygon");
  editor.registerIcon("star", "star");
  editor.registerIcon("spline", "smooth");
  editor.registerIcon("rect", "rect");
}
var en_US = {
  "app.title": "elf",
  "app.sample": (a, b, c2) => {
    return `${a}-${b}-${c2}`;
  },
  "app.lang.en_US": "English",
  "app.lang.ko_KR": "\uD55C\uAD6D\uC5B4",
  "app.lang.fr_FR": "Fran\xE7ais",
  "app.label.lang": "Language",
  "app.layout.all": "Layout",
  "app.layout.css": "CSS Mode",
  "app.layout.svg": "SVG Mode",
  "app.label.layout": "Menu Layout",
  "app.theme.dark": "Dark",
  "app.theme.light": "Light",
  "app.theme.toon": "Toon",
  "app.theme.gray": "Gray",
  "app.label.theme": "Theme",
  "app.tab.title.projects": "Projects",
  "app.tab.title.layers": "Layers",
  "app.tab.title.libraries": "Library",
  "app.tab.title.components": "Component",
  "app.tab.title.artboards": "Artboard",
  "app.tab.title.assets": "Assets",
  "app.tab.title.keyMap": "KeyMap",
  "app.confirm.message.artboard.items.removeArtboard": "Do you remove an artboard preview really?",
  "app.confirm.message.custom-component.items.removeCustomComponent": "Do you remove a custom component preview really?",
  "menu.item.download.title": "Source",
  "menu.item.save.title": "Save",
  "menu.item.export.title": "Export",
  "menu.item.codepen.title": "CodePen",
  "menu.item.fullscreen.title": "Full Screen",
  "menu.item.shortcuts.title": "ShortCuts",
  "menu.item.github.title": "Github",
  "menu.item.learn.title": "Learn",
  "menu.item.projects.title": "Projects",
  "menu.item.language.title": "Language",
  "project.property.title": "Project",
  "project.information.property.title": "Project information",
  "project.information.property.name": "Name",
  "project.information.property.description": "Description",
  "artboard.property.title": "ArtBoards",
  "artboard.property.layout.title.flex": "Flex",
  "artboard.property.layout.title.grid": "Grid",
  "layer.tree.property.title": "Layers",
  "layer.tree.property.layout.title.flex": "Flex",
  "layer.tree.property.layout.title.grid": "Grid",
  "alignment.property.title": "Alignment",
  "position.property.title": "Position",
  "position.property.X": "X",
  "position.property.Y": "Y",
  "size.property.title": "Size",
  "position.property.width": "W",
  "position.property.height": "H",
  "position.property.opacity": "Opacity",
  "position.property.rotate": "Rotate",
  "background.color.property.title": "Appearance",
  "background.color.property.color": "Color",
  "background.color.property.zindex": "z-index",
  "background.color.property.blend": "Blend",
  "background.color.property.overflow": "Overflow",
  "background.color.property.overflow.visible": "Visible",
  "background.color.property.overflow.hidden": "Hidden",
  "background.color.property.overflow.scroll": "Scroll",
  "background.color.property.overflow.auto": "Auto",
  "blend.normal": "normal",
  "blend.multiply": "multiply",
  "blend.screen": "screen",
  "blend.overlay": "overlay",
  "blend.darken": "darken",
  "blend.lighten": "lighten",
  "blend.color-dodge": "color-dodge",
  "blend.color-burn": "color-burn",
  "blend.hard-light": "hard-light",
  "blend.soft-light": "soft-light",
  "blend.difference": "difference",
  "blend.exclusion": "exclusion",
  "blend.hue": "hue",
  "blend.saturation": "saturation",
  "blend.color": "color",
  "blend.luminosity": "luminosity",
  "background.image.property.title": "Fill",
  "border.property.title": "Border",
  "border.radius.property.title": "Border Radius",
  "boxshadow.property.title": "Box Shadows",
  "filter.property.title": "Filter",
  "filter.property.blur": "Blur",
  "filter.property.grayscale": "GrayScale",
  "filter.property.hue-rotate": "Hue Rotate",
  "filter.property.invert": "Invert",
  "filter.property.brightness": "Brightness",
  "filter.property.contrast": "Contrast",
  "filter.property.drop-shadow": "Drop Shadow",
  "filter.property.drop-shadow.color": "Color",
  "filter.property.drop-shadow.offsetX": "Offset X",
  "filter.property.drop-shadow.offsetY": "Offset Y",
  "filter.property.drop-shadow.blurRadius": "Blur",
  "filter.property.opacity": "Opacity",
  "filter.property.saturate": "Saturate",
  "filter.property.sepia": "Sepia",
  "filter.property.svg": "SVG",
  "font.property.title": "Font",
  "font.property.color": "Color",
  "font.property.size": "Size",
  "font.property.stretch": "Stretch",
  "font.property.weight": "Weight",
  "font.property.style": "Style",
  "font.property.family": "Family",
  "font.spacing.property.title": "Font spacing",
  "font.spacing.property.lineHeight": "Line height",
  "font.spacing.property.letterSpacing": "Letter spacing",
  "font.spacing.property.wordSpacing": "Word spacing",
  "font.spacing.property.indent": "Indent",
  "backdrop.filter.property.title": "Backdrop Filter",
  "clippath.property.title": "Clip Path",
  "export.property.title": "Export",
  "export.property.download": "Download",
  "iframe.property.title": "IFrame",
  "image.property.title": "Image",
  "image.property.origin": "Origin",
  "image.property.size": "Size",
  "image.property.width": "Width",
  "image.property.height": "height",
  "video.property.title": "Video",
  "video.property.play": "Play",
  "video.property.pause": "Pause",
  "video.property.volume": "Volume",
  "video.property.playbackRate": "Playback Rate",
  "video.property.currentTime": "Current Time",
  "video.property.playTime": "Play Time Distance",
  "motion.property.title": "Motion",
  "text.property.title": "Text Style",
  "text.property.align": "Align",
  "text.property.transform": "Transform",
  "text.property.decoration": "Decoration",
  "text.clip.property.title": "Text Clip",
  "text.shadow.property.title": "Text Shadows",
  "text.fill.property.title": "Text Fill",
  "text.fill.property.fill": "Fill",
  "text.fill.property.stroke": "Stroke",
  "text.fill.property.strokeWidth": "Width",
  "transform.property.title": "Transform",
  "transform.origin.property.title": "Transform Origin",
  "transition.property.title": "CSS Transition",
  "keyframe.property.title": "CSS Keyframe",
  "selector.property.title": "Selector",
  "selector.property.none": "None selector",
  "path.data.property.title": "Path Information",
  "polygon.data.property.title": "Polygon Information",
  "perspective.property.title": "Perspective",
  "perspective.origin.property.title": "Perspective Origin",
  "svg.item.property.title": "Appearance",
  "svg.item.property.isMotionPath": "Motion Path",
  "svg.item.property.fill": "Fill",
  "svg.item.property.fillOpacity": "Opacity",
  "svg.item.property.path": "Path",
  "svg.item.property.polygon": "Polygon",
  "svg.item.property.totalLength": "Total Length",
  "svg.item.property.fillRule": "Fill Rule",
  "svg.item.property.stroke": "Stroke",
  "svg.item.property.strokeWidth": "Width",
  "svg.item.property.dashArray": "Dash Array",
  "svg.item.property.dashOffset": "Dash Offset",
  "svg.item.property.lineCap": "Line Cap",
  "svg.item.property.lineJoin": "Line Join",
  "svg.item.property.filter": "Filter",
  "svg.item.property.blend": "Blend Mode",
  "border.editor.all": "All",
  "border.editor.width": "Width",
  "border.editor.style": "Style",
  "border.editor.color": "C",
  "border.editor.top": "Top",
  "border.editor.left": "Left",
  "border.editor.right": "Right",
  "border.editor.bottom": "Bottom",
  "border.radius.editor.topLeft": "Top Left",
  "border.radius.editor.topRight": "Top Right",
  "border.radius.editor.bottomLeft": "Bottom Left",
  "border.radius.editor.bottomRight": "Bottom Right",
  "boxshadow.editor.blur": "Blur",
  "boxshadow.editor.spread": "Spread",
  "css.property.editor.properties": "Properties",
  "offset.path.list.editor.path": "Path",
  "offset.path.list.editor.totalLength": "Total Length",
  "offset.path.list.editor.distance": "Distance",
  "offset.path.list.editor.direction": "Direction",
  "offset.path.list.editor.rotate": "Rotate",
  "svgfilter.select.editor.message.create": "Create new svg filter",
  "svgfilter.select.editor.message.select": "Select a filter",
  "fill.editor.message.click.image": "Click the preview area if you want to select a image",
  "fill.editor.message.drag.position": "Drag if you want to move center position",
  "fill.editor.x1": "Start X",
  "fill.editor.x2": "End X",
  "fill.editor.y1": "Start Y",
  "fill.editor.y2": "End Y",
  "fill.editor.spread": "Spread",
  "fill.editor.offset": "Offset",
  "fill.editor.cx": "Center X",
  "fill.editor.cy": "Center Y",
  "fill.editor.r": "End radius",
  "fill.editor.fx": "Start X",
  "fill.editor.fy": "Start Y",
  "fill.editor.fr": "Start radius",
  "perspective.origin.editor.originX": "Origin X",
  "perspective.origin.editor.originY": "Origin Y",
  "path.manager.msg": "Keydown ESC or Enter key to close editing",
  "path.manager.mode.done": "Done",
  "path.manager.mode.modify": "Modify",
  "path.manager.mode.path": "Path",
  "path.manager.mode.warp": "Warp",
  "path.manager.mode.transform": "Transform",
  "path.manager.mode.reverse": "Reverse",
  "path.manager.mode.flipX": "Flip X",
  "path.manager.mode.flipY": "Flip Y",
  "path.manager.mode.flipOrigin": "Flip Origin",
  "colorpicker.popup.title": "ColorPicker",
  "selector.popup.title": "Selector Property",
  "selector.popup.selector": "Selector",
  "background.image.position.popup.title": "Background Pattern",
  "background.image.position.popup.size": "Size",
  "background.image.position.popup.width": "Width",
  "background.image.position.popup.height": "Height",
  "background.image.position.popup.repeat": "Repeat",
  "background.image.position.popup.blend": "Blend",
  "background.image.position.popup.type.repeat": "repeat",
  "background.image.position.popup.type.no-repeat": "no repeat",
  "background.image.position.popup.type.repeat-x": "repeat-x",
  "background.image.position.popup.type.repeat-y": "repeat-y",
  "background.image.position.popup.type.space": "space",
  "background.image.position.popup.type.round": "round",
  "gradient.picker.popup.title": "Gradient & Image Picker",
  "gradient.picker.popup.static-gradient": "Static",
  "gradient.picker.popup.linear-gradient": "Linear",
  "gradient.picker.popup.repeating-linear-gradient": "Repeating Linear",
  "gradient.picker.popup.radial-gradient": "Radial",
  "gradient.picker.popup.repeating-radial-gradient": "Repeating Radial",
  "gradient.picker.popup.conic-gradient": "Linear",
  "gradient.picker.popup.repeating-conic-gradient": "Repeating Conic",
  "image.asset.property.title": "Image",
  "video.asset.property.title": "Video",
  "color.asset.property.title": "Color",
  "gradient.asset.property.title": "Gradient",
  "pattern.asset.property.title": "Pattern",
  "svgfilter.asset.property.title": "SVG Filter",
  "inspector.tab.title.design": "Design",
  "inspector.tab.title.component": "Component",
  "inspector.tab.title.transition": "Animation",
  "inspector.tab.title.asset": "Assets",
  "inspector.tab.title.text": "Text",
  "inspector.tab.title.code": "Code",
  "inspector.tab.title.history": "History",
  "timeline.property.title": "Timeline",
  "timeline.property.resize": "Drag if you want to resize timeline height.",
  "timeline.animation.property.title": "Animations",
  "timeline.play.control.play": "Play",
  "timeline.play.control.pause": "Pause",
  "timeline.play.control.first": "First",
  "timeline.play.control.prev": "Previous",
  "timeline.play.control.next": "Next",
  "timeline.play.control.last": "Last",
  "timeline.play.control.direction": "Direction",
  "timeline.play.control.speed": "Speed",
  "timeline.play.control.repeat": "Repeat",
  "timeline.play.control.infinite": "Infinite",
  "timeline.play.control.normal": "normal",
  "timeline.play.control.alternate": "alternate",
  "timeline.play.control.reverse": "reverse",
  "timeline.play.control.alternate.reverse": "alternate reverse",
  "timeline.value.editor.value": "Value",
  "timeline.value.editor.time": "Time",
  "timeline.value.editor.timing": "Timing",
  "timeline.value.editor.offset.message": "Please input enter key to change time offset.",
  "svgfilter.popup.title": "SVG Filter",
  "css.item.rotate": "Rotate",
  "css.item.rotateX": "Rotate X",
  "css.item.rotateY": "Rotate Y",
  "css.item.rotateZ": "Rotate Z",
  "css.item.rotate3d": "3D Rotate",
  "css.item.skewX": "Skew X",
  "css.item.skewY": "Skew Y",
  "css.item.translate": "Translate",
  "css.item.translateX": "Translate X",
  "css.item.translateY": "Translate Y",
  "css.item.translateZ": "Translate Z",
  "css.item.translate3d": "3D Translate",
  "css.item.perspective": "Perspective",
  "css.item.scale": "Scale",
  "css.item.scaleX": "Scale X",
  "css.item.scaleY": "Scale Y",
  "css.item.scaleZ": "Scale Z",
  "css.item.scale3d": "3D Scale",
  "css.item.matrix": "Matrix",
  "css.item.matrix3d": "3D Matrix",
  "animation.property.title": "CSS Animation",
  "animation.property.direction": "Direction",
  "animation.property.play.state": "Play State",
  "animation.property.fill.mode": "Fill Mode",
  "animation.property.delay": "Delay",
  "animation.property.duration": "Duration",
  "animation.property.iteration.count": "Iteration Count",
  "animation.property.Select a keyframe": "Select a keyframe",
  "animation.property.popup.title": "Animation",
  "animation.property.popup.timing.function": "Timing Function",
  "animation.property.popup.keyframe": "Keyframe",
  "animation.property.popup.direction": "Direction",
  "animation.property.popup.play.state": "Play State",
  "animation.property.popup.fill.mode": "Fill Mode",
  "animation.property.popup.delay": "Delay",
  "animation.property.popup.duration": "Duration",
  "animation.property.popup.iteration": "Iteration",
  "animation.property.popup.normal": "normal",
  "animation.property.popup.reverse": "reverse",
  "animation.property.popup.alternate": "alternate",
  "animation.property.popup.alternate-reverse": "alternate-reverse",
  "animation.property.popup.none": "none",
  "animation.property.popup.forwards": "forwards",
  "animation.property.popup.backwards": "backwards",
  "animation.property.popup.both": "both",
  "animation.property.popup.Select a keyframe": "Select a keyframe",
  "keyframe.popup.title": "Keyframe",
  "code.view.property.title": "CodeView",
  "svg.filter.editor.tab.filter": "Filter",
  "svg.filter.editor.tab.preset": "Preset",
  "svg.filter.editor.tab.asset": "Assets",
  "svg.filter.editor.GRAPHIC REFERENCES": "GRAPHIC REFERENCES",
  "svg.filter.editor.SOURCES": "SOURCES",
  "svg.filter.editor.MODIFIER": "MODIFIER",
  "svg.filter.editor.LIGHTING": "LIGHTING",
  "svg.filter.editor.COMBINERS": "COMBINERS",
  "svg.filter.editor.Template": "Template",
  "layout.property.title": "Layout",
  "layout.property.flex": "Flex Box",
  "layout.property.grid": "Grid",
  "layout.property.default": "Default",
  "layout.property.resizing.title": "Resizing",
  "layout.property.resizing.self.title": "Self Resizing",
  "default.layout.item.property.title.constraints": "Constraints",
  "flex.layout.editor.row": "Row",
  "flex.layout.editor.column": "column",
  "flex.layout.editor.row-reverse": "Row Reverse",
  "flex.layout.editor.column-reverse": "Column Reverse",
  "flex.layout.editor.nowrap": "Nowrap",
  "flex.layout.editor.wrap": "Wrap",
  "flex.layout.editor.wrap-reverse": "Wrap Reverse",
  "flex.layout.editor.flex-start": "Start",
  "flex.layout.editor.flex-end": "End",
  "flex.layout.editor.center": "Center",
  "flex.layout.editor.space-between": "Between",
  "flex.layout.editor.space-around": "Around",
  "flex.layout.editor.baseline": "BaseLine",
  "flex.layout.editor.stretch": "Stretch",
  "flex.layout.editor.direction": "Direction",
  "flex.layout.editor.justify-content": "Justify Content",
  "flex.layout.editor.align-items": "Align Items",
  "flex.layout.editor.align-content": "Align Content",
  "flex.layout.item.property.title": "Flex Item Detail",
  "flex.layout.item.property.grow": "Flex Grow",
  "flex.layout.item.property.shrink": "Flex Shrink",
  "flex.layout.item.property.basis": "Flex Basis",
  "flex.layout.item.property.none": "none",
  "flex.layout.item.property.auto": "auto",
  "flex.layout.item.property.value": "value",
  "grid.layout.editor.template.columns": "Columns",
  "grid.layout.editor.column.gap": "Column Gap",
  "grid.layout.editor.template.rows": "Rows",
  "grid.layout.editor.row.gap": "Row Gap",
  "grid.box.editor.box.title": "Box",
  "grid.box.editor.type": "Type",
  "grid.box.editor.repeat": "Repeat",
  "grid.box.editor.length": "Length",
  "grid.box.editor.none": "None",
  "grid.box.editor.auto": "Auto",
  "grid.box.editor.count": "Count",
  "grid.box.editor.value": "Size",
  "grid.layout.item.property.title": "Layout Item Detail",
  "grid.layout.item.property.column": "Column",
  "grid.layout.item.property.row": "Row",
  "grid.layout.item.property.start": "Start",
  "grid.layout.item.property.end": "End",
  "grid.layout.item.property.none": "none",
  "grid.layout.item.property.value": "value",
  "box.model.property.title": "Box Model",
  "box.model.property.margin": "Margin",
  "box.model.property.padding": "Padding",
  "component.items.canvas": "Canvas",
  "component.items.layer": "Layer",
  "component.items.3dlayer": "3D Layer",
  "component.items.drawing": "Drawing",
  "component.items.custom": "Custom Component",
  "component.items.chart": "Chart",
  "component.items.plugin": "Plugin",
  "svg.text.property.title": "SVG Text Style",
  "svg.text.property.textarea": "Text Area",
  "svg.text.property.size": "Font Size",
  "svg.text.property.weight": "Font Weight",
  "svg.text.property.style": "Font Style",
  "svg.text.property.anchor": "Text Anchor",
  "svg.text.property.family": "Font Family",
  "svg.text.property.length.adjust": "Length Adjust",
  "svg.text.property.text.length": "Text Length",
  "svg.text.property.start.offset": "Start Offset",
  "fill.picker.popup.title": "SVG Fragment picker",
  "gradient.editor.drag.message": "Drag if you want to move center pointer.",
  "draw.manager.tolerance": "Tolerance",
  "pattern.property.title": "Pattern",
  "pattern.info.popup.title": "Pattern Info",
  "pattern.info.popup.width": "Width",
  "pattern.info.popup.height": "Height",
  "pattern.info.popup.lineWidth": "Line Width",
  "pattern.info.popup.lineHeight": "Line Height",
  "pattern.info.popup.rotate": "Rotate",
  "pattern.info.popup.blend": "Blend Mode",
  "pattern.info.popup.foreColor": "Fore",
  "pattern.info.popup.backColor": "Back",
  "stroke.dasharray.editor.add": "Add Dash",
  "viewport.panning.enable": "You can move the area by holding down space key and dragging the screen.",
  "image.select.editor.button": "Select Image"
};
var fr_FR = {
  "app.title": "elf",
  "app.sample": (a, b, c2) => {
    return `${a}-${b}-${c2}`;
  },
  "app.lang.en_US": "English",
  "app.lang.ko_KR": "\uD55C\uAD6D\uC5B4",
  "app.lang.fr_FR": "Fran\xE7ais",
  "app.label.lang": "Langue",
  "app.layout.all": "Layout",
  "app.layout.css": "CSS Mode",
  "app.layout.svg": "SVG Mode",
  "app.label.layout": "Menu Layout",
  "app.theme.dark": "Sombre",
  "app.theme.light": "Clair",
  "app.theme.gray": "Gris",
  "app.label.theme": "Th\xE8me",
  "app.tab.title.projects": "Projets",
  "app.tab.title.layers": "Objets",
  "app.tab.title.libraries": "Librarie",
  "app.tab.title.components": "Objet",
  "app.tab.title.artboards": "Artboard",
  "app.tab.title.assets": "Elements",
  "app.tab.title.keyMap": "Clavier",
  "app.confirm.message.artboard.items.removeArtboard": "Do you remove an artboard preview really?",
  "app.confirm.message.custom-component.items.removeCustomComponent": "Do you remove a custom component preview really?",
  "menu.item.download.title": "T\xE9l\xE9charger",
  "menu.item.save.title": "Enregistrer",
  "menu.item.export.title": "Exporter",
  "menu.item.codepen.title": "CodePen",
  "menu.item.fullscreen.title": "Ecran",
  "menu.item.shortcuts.title": "ShortCuts",
  "menu.item.github.title": "Github",
  "menu.item.learn.title": "Docs",
  "menu.item.projects.title": "Projects",
  "project.property.title": "Projet",
  "project.information.property.title": "Information",
  "project.information.property.name": "Nom",
  "project.information.property.description": "Description",
  "artboard.property.title": "Planche",
  "artboard.property.layout.title.flex": "Flex",
  "artboard.property.layout.title.grid": "Grille",
  "layer.tree.property.title": "Objets",
  "layer.tree.property.layout.title.flex": "Flex",
  "layer.tree.property.layout.title.grid": "Grille",
  "alignment.property.title": "Alignment",
  "position.property.title": "Position",
  "position.property.X": "X",
  "position.property.Y": "Y",
  "size.property.title": "Taille",
  "position.property.width": "Largeur",
  "position.property.height": "Hauteur",
  "position.property.opacity": "Opacity",
  "position.property.rotate": "Rotate",
  "background.color.property.title": "Apparance",
  "background.color.property.color": "Couleur",
  "background.color.property.zindex": "z-index",
  "background.color.property.opacity": "Opacit\xE9",
  "background.color.property.blend": "M\xE9lange",
  "background.color.property.overflow": "D\xE9bordement",
  "background.color.property.overflow.visible": "Visible",
  "background.color.property.overflow.hidden": "Cach\xE9",
  "background.color.property.overflow.scroll": "Scroll",
  "background.color.property.overflow.auto": "Auto",
  "blend.normal": "normal",
  "blend.multiply": "multiplie",
  "blend.screen": "\xE9cran",
  "blend.overlay": "couche",
  "blend.darken": "sombre",
  "blend.lighten": "clair",
  "blend.color-dodge": "dodge",
  "blend.color-burn": "brul\xE9",
  "blend.hard-light": "dur",
  "blend.soft-light": "doux",
  "blend.difference": 'diff"rence',
  "blend.exclusion": "exclusion",
  "blend.hue": "teinte",
  "blend.saturation": "saturation",
  "blend.color": "couleur",
  "blend.luminosity": "luminosit\xE9",
  "background.image.property.title": "Remplissage",
  "border.property.title": "Bordure",
  "border.radius.property.title": "Rayon de bordure",
  "boxshadow.property.title": "Ombres",
  "filter.property.title": "Filtre",
  "filter.property.blur": "Flou",
  "filter.property.grayscale": "Echelle de gris",
  "filter.property.hue-rotate": "Rotation teinte",
  "filter.property.invert": "Invertir",
  "filter.property.brightness": "Luminosit\xE9",
  "filter.property.contrast": "Contraste",
  "filter.property.drop-shadow": "Ombre port\xE9e",
  "filter.property.drop-shadow.color": "Couleur",
  "filter.property.drop-shadow.offsetX": "D\xE9calage X",
  "filter.property.drop-shadow.offsetY": "D\xE9calage Y",
  "filter.property.drop-shadow.blurRadius": "Flou",
  "filter.property.opacity": "Opacit\xE9",
  "filter.property.saturate": "Saturation",
  "filter.property.sepia": "S\xE9pia",
  "filter.property.svg": "SVG",
  "font.property.title": "Police",
  "font.property.color": "Couleur",
  "font.property.size": "Taille",
  "font.property.stretch": "Etirement",
  "font.property.weight": "Poids",
  "font.property.style": "Style",
  "font.property.family": "Famille",
  "font.spacing.property.title": "Espaces du texte",
  "font.spacing.property.lineHeight": "Hauteur de ligne",
  "font.spacing.property.letterSpacing": "Espace inter-caract\xE8res",
  "font.spacing.property.wordSpacing": "Espace inter-mots",
  "font.spacing.property.indent": "Identation",
  "backdrop.filter.property.title": "Filtre Backdrop",
  "clippath.property.title": "Chemin du Clip",
  "export.property.title": "Exporter",
  "export.property.download": "T\xE9l\xE9charger",
  "iframe.property.title": "IFrame",
  "image.property.title": "Image",
  "image.property.origin": "Origine",
  "image.property.size": "Taille",
  "image.property.width": "Largeur",
  "image.property.height": "Hauteur",
  "video.property.title": "Video",
  "video.property.play": "Jouer",
  "video.property.pause": "Pause",
  "video.property.volume": "Volume",
  "video.property.playbackRate": "Vitesse de lecture",
  "video.property.currentTime": "Temps actuel",
  "video.property.playTime": "Temps de lecture",
  "motion.property.title": "Mouvement",
  "text.property.title": "Style Texte",
  "text.property.align": "Alignement",
  "text.property.transform": "Transformation",
  "text.property.decoration": "D\xE9coration",
  "text.clip.property.title": "Clip Texte",
  "text.shadow.property.title": "Ombres Texte",
  "text.fill.property.title": "Remplissage Texte",
  "text.fill.property.fill": "Remplissage",
  "text.fill.property.stroke": "Trait",
  "text.fill.property.strokeWidth": "Largeur",
  "transform.property.title": "Transformation",
  "transform.origin.property.title": "Origine Transformation",
  "transition.property.title": "Transition CSS",
  "keyframe.property.title": "Image cl\xE9 CSS",
  "selector.property.title": "S\xE9l\xE9cteur",
  "selector.property.none": "Aucun s\xE9l\xE9cteur",
  "path.data.property.title": "Information Chemin",
  "polygon.data.property.title": "Information Polygone",
  "perspective.property.title": "Perspective",
  "perspective.origin.property.title": "Origine Perspective",
  "svg.item.property.title": "Appearance",
  "svg.item.property.isMotionPath": "Chemin de mouvement",
  "svg.item.property.fill": "Remplissage",
  "svg.item.property.fillOpacity": "Opacit\xE9",
  "svg.item.property.path": "Chemin",
  "svg.item.property.polygon": "Polygone",
  "svg.item.property.totalLength": "Longueur totale",
  "svg.item.property.fillRule": "R\xE8gle remplissage",
  "svg.item.property.stroke": "Trait",
  "svg.item.property.strokeWidth": "Largeur de trait",
  "svg.item.property.dashArray": "Suite tiret",
  "svg.item.property.dashOffset": "D\xE9calage tiret",
  "svg.item.property.lineCap": "Chapeau Ligne",
  "svg.item.property.lineJoin": "Jonction ligne",
  "svg.item.property.filter": "Filtre",
  "svg.item.property.blend": "Blend Mode",
  "border.editor.all": "Tout",
  "border.editor.width": "Largeur",
  "border.editor.style": "Style",
  "border.editor.color": "Couleur",
  "border.editor.top": "Haut",
  "border.editor.left": "Gauche",
  "border.editor.right": "Droite",
  "border.editor.bottom": "Bas",
  "border.radius.editor.topLeft": "Haut gauche",
  "border.radius.editor.topRight": "Haut droite",
  "border.radius.editor.bottomLeft": "Bas gauche",
  "border.radius.editor.bottomRight": "Bas droite",
  "boxshadow.editor.blur": "Flou",
  "boxshadow.editor.spread": "Etalement",
  "css.property.editor.properties": "Propri\xE9t\xE9s",
  "offset.path.list.editor.path": "Chemin",
  "offset.path.list.editor.totalLength": "Longueur totale",
  "offset.path.list.editor.distance": "Distance",
  "offset.path.list.editor.direction": "Direction",
  "offset.path.list.editor.rotate": "Rotation",
  "svgfilter.select.editor.message.create": "Cr\xE9er un filtre svg",
  "svgfilter.select.editor.message.select": "S\xE9lection filtre",
  "fill.editor.message.click.image": "Cliquez sur aper\xE7u si vous souhaitez s\xE9lectionner une image",
  "fill.editor.message.drag.position": "Prendre pour changer la position centrale",
  "fill.editor.x1": "D\xE9but X",
  "fill.editor.x2": "Fin X",
  "fill.editor.y1": "D\xE9but Y",
  "fill.editor.y2": "Fin Y",
  "fill.editor.spread": "Etalement",
  "fill.editor.offset": "D\xE9calage",
  "fill.editor.cx": "Centre X",
  "fill.editor.cy": "Centre Y",
  "fill.editor.r": "Rayon de fin",
  "fill.editor.fx": "D\xE9part X",
  "fill.editor.fy": "D\xE9part Y",
  "fill.editor.fr": "Rayon de d\xE9part",
  "perspective.origin.editor.originX": "Origine X",
  "perspective.origin.editor.originY": "Origine Y",
  "path.manager.msg": "Appuyer ESC ou Entr\xE9z keypour fermer Edition",
  "path.manager.mode.done": "Done",
  "path.manager.mode.modify": "Modifier",
  "path.manager.mode.path": "Chemin",
  "path.manager.mode.warp": "Warp",
  "path.manager.mode.transform": "Transformer",
  "path.manager.mode.reverse": "Reverse",
  "path.manager.mode.flipX": "Retouner X",
  "path.manager.mode.flipY": "Retouner Y",
  "path.manager.mode.flipOrigin": "Retouner Origine",
  "colorpicker.popup.title": "Pipette",
  "selector.popup.title": "Propi\xE9t\xE9 de S\xE9lecteur",
  "selector.popup.selector": "S\xE9lecteur",
  "background.image.position.popup.title": "Motif de fond",
  "background.image.position.popup.size": "Taille",
  "background.image.position.popup.width": "Largeur",
  "background.image.position.popup.height": "Hauteur",
  "background.image.position.popup.repeat": "Rep\xE8te",
  "background.image.position.popup.blend": "M\xE9lange",
  "background.image.position.popup.type.repeat": "rep\xE8te",
  "background.image.position.popup.type.no-repeat": "sans rep\xE9tition",
  "background.image.position.popup.type.repeat-x": "rep\xE8te-x",
  "background.image.position.popup.type.repeat-y": "rep\xE8te-y",
  "background.image.position.popup.type.space": "espace",
  "background.image.position.popup.type.round": "rond",
  "gradient.picker.popup.title": "S\xE9lection Gradient & Image",
  "image.asset.property.title": "Image",
  "video.asset.property.title": "Vid\xE9o",
  "color.asset.property.title": "Couleur",
  "gradient.asset.property.title": "Gradient",
  "pattern.asset.property.title": "Motif",
  "svgfilter.asset.property.title": "Filtre SVG",
  "inspector.tab.title.design": "Design",
  "inspector.tab.title.component": "Composant",
  "inspector.tab.title.transition": "Animation",
  "inspector.tab.title.asset": "El\xE9ments",
  "inspector.tab.title.text": "Texte",
  "inspector.tab.title.code": "Code",
  "inspector.tab.title.history": "History",
  "timeline.property.title": "Chronologie",
  "timeline.property.resize": "Drag if you want to resize timeline height.",
  "timeline.animation.property.title": "Animations",
  "timeline.play.control.play": "Jouer",
  "timeline.play.control.pause": "Pause",
  "timeline.play.control.first": "Premier",
  "timeline.play.control.prev": "Pr\xE9c\xE9dent",
  "timeline.play.control.next": "Suivant",
  "timeline.play.control.last": "Dernier",
  "timeline.play.control.direction": "Direction",
  "timeline.play.control.speed": "Vitesse",
  "timeline.play.control.repeat": "R\xE9p\xE9ter",
  "timeline.play.control.infinite": "Infini",
  "timeline.play.control.normal": "normal",
  "timeline.play.control.alternate": "alternatif",
  "timeline.play.control.reverse": "inverse",
  "timeline.play.control.alternate.reverse": "inverse alternatif",
  "timeline.value.editor.value": "Valeur",
  "timeline.value.editor.time": "Temps",
  "timeline.value.editor.timing": "Calage temps",
  "timeline.value.editor.offset.message": "Please input enter key to change time offset.",
  "svgfilter.popup.title": "Filtre SVG",
  "css.item.rotate": "Rotation",
  "css.item.rotateX": "Rotation X",
  "css.item.rotateY": "Rotation Y",
  "css.item.rotateZ": "Rotation Z",
  "css.item.rotate3d": "Rotation 3D",
  "css.item.skewX": "Oblique X",
  "css.item.skewY": "Oblique Y",
  "css.item.translate": "Translation",
  "css.item.translateX": "Translation X",
  "css.item.translateY": "Translation Y",
  "css.item.translateZ": "Translation Z",
  "css.item.translate3d": "Translation 3D",
  "css.item.perspective": "Persp\xE9ctive",
  "css.item.scale": "Echelle",
  "css.item.scaleX": "Echelle X",
  "css.item.scaleY": "Echelle Y",
  "css.item.scaleZ": "Echelle Z",
  "css.item.scale3d": "Echelle 3D",
  "css.item.matrix": "Matrice",
  "css.item.matrix3d": "Matrice 3D",
  "animation.property.title": "Animation CSS",
  "animation.property.direction": "Direction",
  "animation.property.play.state": "Etat lecture",
  "animation.property.fill.mode": "Mode remplissage",
  "animation.property.delay": "D\xE9lais",
  "animation.property.duration": "Dur\xE9e",
  "animation.property.iteration.count": "Nombre It\xE9rations",
  "animation.property.Select a keyframe": "Selectionner une image cl\xE9",
  "animation.property.popup.title": "Animation",
  "animation.property.popup.timing.function": "Fonction temps",
  "animation.property.popup.keyframe": "image cl\xE9",
  "animation.property.popup.direction": "Direction",
  "animation.property.popup.play.state": "Etat lecture",
  "animation.property.popup.fill.mode": "Mode remplissage",
  "animation.property.popup.delay": "D\xE9lais",
  "animation.property.popup.duration": "Dur\xE9\xE9",
  "animation.property.popup.iteration": "It\xE9ration",
  "animation.property.popup.normal": "normal",
  "animation.property.popup.reverse": "inverse",
  "animation.property.popup.alternate": "alternatif",
  "animation.property.popup.alternate-reverse": "inverse alternatif",
  "animation.property.popup.none": "Aucun",
  "animation.property.popup.forwards": "en avant",
  "animation.property.popup.backwards": "en arri\xE8re",
  "animation.property.popup.both": "les deux",
  "animation.property.popup.Select a keyframe": "Selectionner une image cl\xE9",
  "keyframe.popup.title": "image cl\xE9",
  "code.view.property.title": "Vue code",
  "svg.filter.editor.tab.filter": "Filtrer",
  "svg.filter.editor.tab.preset": "Pre-rempli",
  "svg.filter.editor.tab.asset": "El\xE9ments",
  "svg.filter.editor.GRAPHIC REFERENCES": "REFERENCES GRAPHIQUES",
  "svg.filter.editor.SOURCES": "SOURCES",
  "svg.filter.editor.MODIFIER": "MODIFIER",
  "svg.filter.editor.LIGHTING": "ECLAIRAGE",
  "svg.filter.editor.COMBINERS": "COMBINER",
  "svg.filter.editor.Template": "Mod\xE8le",
  "layout.property.title": "Disposition",
  "layout.property.flex": "Bo\xEEte Flex",
  "layout.property.grid": "Grille",
  "layout.property.default": "D\xE9faut",
  "layout.property.resizing.title": "Resizing",
  "layout.property.resizing.self.title": "Self Resizing",
  "default.layout.item.property.title.constraints": "Constraints",
  "flex.layout.editor.row": "Ligne",
  "flex.layout.editor.column": "Colonne",
  "flex.layout.editor.row-reverse": "Inverse ligne",
  "flex.layout.editor.column-reverse": "Inverse Colonne",
  "flex.layout.editor.nowrap": "Non-emball\xE9",
  "flex.layout.editor.wrap": "Emball\xE9 (wrap)",
  "flex.layout.editor.wrap-reverse": "Inverse emball\xE9",
  "flex.layout.editor.flex-start": "D\xE9but",
  "flex.layout.editor.flex-end": "Fin",
  "flex.layout.editor.center": "Centrer",
  "flex.layout.editor.space-between": "Entre",
  "flex.layout.editor.space-around": "Autour",
  "flex.layout.editor.baseline": "Base",
  "flex.layout.editor.stretch": "Etirement",
  "flex.layout.editor.direction": "Direction",
  "flex.layout.editor.justify-content": "Justifier",
  "flex.layout.editor.align-items": "Aligner objets",
  "flex.layout.editor.align-content": "Aligner contenu",
  "flex.layout.item.property.title": "D\xE9tail Disposition objet",
  "flex.layout.item.property.grow": "Augmenter Flex",
  "flex.layout.item.property.shrink": "R\xE9duire Flex",
  "flex.layout.item.property.basis": "Base Flex",
  "flex.layout.item.property.none": "Aucun",
  "flex.layout.item.property.auto": "auto",
  "flex.layout.item.property.value": "valeur",
  "grid.layout.editor.template.columns": "Colonne",
  "grid.layout.editor.column.gap": "Espace Colonne",
  "grid.layout.editor.template.rows": "Lignes",
  "grid.layout.editor.row.gap": "Espace lignes",
  "grid.box.editor.box.title": "Bo\xEEte",
  "grid.box.editor.type": "Type",
  "grid.box.editor.repeat": "R\xE9p\xE9ter",
  "grid.box.editor.length": "Longueur",
  "grid.box.editor.none": "Aucun",
  "grid.box.editor.auto": "Auto",
  "grid.box.editor.count": "Compte",
  "grid.box.editor.value": "Taille",
  "grid.layout.item.property.title": "D\xE9tail disposition objets",
  "grid.layout.item.property.column": "Colonne",
  "grid.layout.item.property.row": "Ligne",
  "grid.layout.item.property.start": "D\xE9but",
  "grid.layout.item.property.end": "Fin",
  "grid.layout.item.property.none": "Aucun",
  "grid.layout.item.property.value": "valeur",
  "box.model.property.title": "Mod\xE8le",
  "box.model.property.margin": "Marge",
  "box.model.property.padding": "Espace",
  "component.items.canvas": "Toile",
  "component.items.layer": "Objet",
  "component.items.3dlayer": "Objet 3D",
  "component.items.drawing": "Dessin",
  "component.items.custom": "Composant personnalis\xE9",
  "component.items.chart": "Chart",
  "component.items.plugin": "Plugin",
  "svg.text.property.title": "Style SVG Texte",
  "svg.text.property.textarea": "Zone Texte",
  "svg.text.property.size": "Taille",
  "svg.text.property.weight": "Poids",
  "svg.text.property.style": "Style",
  "svg.text.property.anchor": "Ancre Texte",
  "svg.text.property.family": "Famille",
  "svg.text.property.length.adjust": "Ajusteement longueur",
  "svg.text.property.text.length": "Ajusteement Texte",
  "svg.text.property.start.offset": "D\xE9callage d\xE9part",
  "fill.picker.popup.title": "S\xE9lection Fragment SVG",
  "gradient.editor.drag.message": "Glisser pour d\xE9placer centre.",
  "draw.manager.tolerance": "Tol\xE9rance",
  "pattern.property.title": "Motif",
  "pattern.info.popup.title": "Info Motif",
  "pattern.info.popup.width": "Largeur",
  "pattern.info.popup.height": "Hauteur",
  "pattern.info.popup.lineWidth": "Largeur ligne",
  "pattern.info.popup.lineHeight": "Hauteur de ligne",
  "pattern.info.popup.rotate": "Rotatation",
  "pattern.info.popup.blend": "M\xE9lange",
  "pattern.info.popup.foreColor": "Avant",
  "pattern.info.popup.backColor": "Arri\xE8re",
  "stroke.dasharray.editor.add": "Ajout tiret",
  "viewport.panning.enable": "You can move the area by holding down space and dragging the screen."
};
var ko_KR = {
  "app.title": "elf",
  "app.sample": (a, b, c2) => {
    return `${a}-${b}-${c2}`;
  },
  "app.lang.en_US": "English",
  "app.lang.ko_KR": "\uD55C\uAD6D\uC5B4",
  "app.lang.fr_FR": "Fran\xE7ais",
  "app.label.lang": "\uC5B8\uC5B4",
  "app.layout.all": "\uB808\uC774\uC544\uC6C3",
  "app.layout.css": "CSS \uBAA8\uB4DC",
  "app.layout.svg": "SVG \uBAA8\uB4DC",
  "app.label.layout": "\uBA54\uB274\uAD6C\uC131",
  "app.theme.dark": "\uC5B4\uB450\uC6B4",
  "app.theme.light": "\uBC1D\uC740",
  "app.theme.toon": "\uADF8\uB9AC\uAE30",
  "app.theme.gray": "\uD68C\uC0C9",
  "app.label.theme": "\uD14C\uB9C8",
  "app.tab.title.projects": "\uD504\uB85C\uC81D\uD2B8",
  "app.tab.title.layers": "\uB808\uC774\uC5B4",
  "app.tab.title.libraries": "\uB77C\uC774\uBE0C\uB7EC\uB9AC",
  "app.tab.title.components": "\uCEF4\uD3EC\uB10C\uD2B8",
  "app.tab.title.artboards": "\uC544\uD2B8\uBCF4\uB4DC",
  "app.tab.title.assets": "\uC5D0\uC14B",
  "app.tab.title.keyMap": "\uB2E8\uCD95\uD0A4",
  "app.confirm.message.artboard.items.removeArtboard": "\uC544\uD2B8\uBCF4\uB4DC \uD504\uB9AC\uBDF0\uB97C \uC0AD\uC81C \uD558\uC2DC\uACA0\uC2B5\uB2C8\uAE4C?",
  "app.confirm.message.custom-component.items.removeCustomComponent": "\uCEF4\uD3EC\uB10C\uD2B8 \uD504\uB9AC\uBDF0\uB97C \uC0AD\uC81C \uD558\uC2DC\uACA0\uC2B5\uB2C8\uAE4C?",
  "menu.item.download.title": "\uB2E4\uC6B4\uB85C\uB4DC",
  "menu.item.save.title": "\uC800\uC7A5",
  "menu.item.export.title": "\uB0B4\uBCF4\uB0B4\uAE30",
  "menu.item.fullscreen.title": "\uC804\uCCB4\uD654\uBA74",
  "menu.item.shortcuts.title": "\uB2E8\uCD95\uD0A4",
  "menu.item.github.title": "Github",
  "menu.item.learn.title": "\uBC30\uC6B0\uAE30",
  "menu.item.projects.title": "\uD504\uB85C\uC81D\uD2B8",
  "project.property.title": "\uD504\uB85C\uC81D\uD2B8",
  "project.information.property.title": "\uD504\uB85C\uC81D\uD2B8 \uC815\uBCF4",
  "project.information.property.name": "\uC774\uB984",
  "project.information.property.description": "\uC124\uBA85",
  "artboard.property.title": "\uC544\uD2B8\uBCF4\uB4DC",
  "artboard.property.layout.title.flex": "\uD50C\uB809\uC2A4",
  "artboard.property.layout.title.grid": "\uADF8\uB9AC\uB4DC",
  "layer.tree.property.title": "\uB808\uC774\uC5B4",
  "layer.tree.property.layout.title.flex": "\uD50C\uB809\uC2A4",
  "layer.tree.property.layout.title.grid": "\uADF8\uB9AC\uB4DC",
  "alignment.property.title": "\uC815\uB82C",
  "position.property.title": "\uC704\uCE58",
  "position.property.X": "X",
  "position.property.Y": "Y",
  "size.property.title": "\uD06C\uAE30",
  "position.property.width": "\uB113\uC774",
  "position.property.height": "\uB192\uC774",
  "position.property.rotate": "\uD68C\uC804",
  "position.property.opacity": "\uD22C\uBA85",
  "background.color.property.title": "\uD45C\uC2DC",
  "background.color.property.color": "\uBC30\uACBD\uC0C9",
  "background.color.property.zindex": "z-index",
  "background.color.property.blend": "\uBE14\uB80C\uB4DC\uBAA8\uB4DC",
  "background.color.property.overflow": "\uC624\uBC84\uD50C\uB85C\uC6B0",
  "background.color.property.overflow.visible": "\uBCF4\uC774\uAE30",
  "background.color.property.overflow.hidden": "\uC228\uAE30\uAE30",
  "background.color.property.overflow.scroll": "\uC2A4\uD06C\uB864",
  "background.color.property.overflow.auto": "\uC790\uB3D9",
  "blend.normal": "Normal(\uD45C\uC900) \uD63C\uD569\uBAA8\uB4DC",
  "blend.multiply": "Multiply(\uACF1\uD558\uAE30) \uBAA8\uB4DC",
  "blend.screen": "Screen(\uC2A4\uD06C\uB9B0) \uBAA8\uB4DC ",
  "blend.overlay": "Overlay(\uC624\uBC84\uB808\uC774) \uBAA8\uB4DC",
  "blend.darken": "Darken(\uC5B4\uB461\uAE30) \uBAA8\uB4DC",
  "blend.lighten": "Lighten(\uBC1D\uAE30) \uBAA8\uB4DC ",
  "blend.color-dodge": "Color Dodge(\uCEEC\uB7EC \uB2F7\uC9C0) \uBAA8\uB4DC ",
  "blend.color-burn": "Color Burn(\uCEEC\uB7EC \uBC88) \uBAA8\uB4DC ",
  "blend.hard-light": "Hard Light(\uD558\uB4DC \uB77C\uC774\uD2B8) \uBAA8\uB4DC ",
  "blend.soft-light": "Soft Light(\uC18C\uD504\uD2B8 \uB77C\uC774\uD2B8) \uBAA8\uB4DC ",
  "blend.difference": "Difference(\uCC28\uC774) \uBAA8\uB4DC",
  "blend.exclusion": "Exclusion(\uC81C\uC678) \uBAA8\uB4DC",
  "blend.hue": "Hue(\uC0C9\uC870) \uBAA8\uB4DC ",
  "blend.saturation": "Saturation(\uCC44\uB3C4) \uBAA8\uB4DC",
  "blend.color": "Color(\uC0C9\uC0C1) \uBAA8\uB4DC",
  "blend.luminosity": "Luminosity(\uAD11\uB3C4) \uBAA8\uB4DC ",
  "background.image.property.title": "\uCC44\uC6B0\uAE30",
  "border.property.title": "\uC678\uACFD\uC120",
  "border.radius.property.title": "\uB465\uADFC \uC678\uACFD\uC120",
  "boxshadow.property.title": "\uADF8\uB9BC\uC790",
  "filter.property.title": "\uD544\uD130",
  "filter.property.blur": "\uD750\uB9BC(Blur)",
  "filter.property.grayscale": "\uD68C\uC0C9(GrayScale)",
  "filter.property.hue-rotate": "\uC0C9\uC870(HueRotate)",
  "filter.property.invert": "\uBC18\uC804(Invert)",
  "filter.property.brightness": "\uBC1D\uAE30(Brightness)",
  "filter.property.contrast": "\uB300\b\uC870(Contrast)",
  "filter.property.drop-shadow": "\uADF8\uB9BC\uC790(Drop Shadow)",
  "filter.property.drop-shadow.color": "\uC0C9",
  "filter.property.drop-shadow.offsetX": "X",
  "filter.property.drop-shadow.offsetY": "Y",
  "filter.property.drop-shadow.blurRadius": "\uD750\uB9BC",
  "filter.property.opacity": "\uD22C\uBA85\uB3C4(Opacity)",
  "filter.property.saturate": "\uCC44\uB3C4(Saturate)",
  "filter.property.sepia": "\uAC08\uC0C9\uD1A4(Sepia)",
  "filter.property.svg": "SVG",
  "font.property.title": "\uD3F0\uD2B8",
  "font.property.color": "\uC0C9",
  "font.property.size": "\uD06C\uAE30",
  "font.property.stretch": "\uBED7\uAE30",
  "font.property.weight": "\uAD75\uAE30",
  "font.property.style": "\uC2A4\uD0C0\uC77C",
  "font.property.family": "\uAE00\uAF34",
  "font.spacing.property.title": "\uD3F0\uD2B8 \uACF5\uAC04",
  "font.spacing.property.lineHeight": "\uC904 \uB192\uC774",
  "font.spacing.property.letterSpacing": "\uAE00\uC790 \uAC04\uACA9",
  "font.spacing.property.wordSpacing": "\uB2E8\uC5B4 \uAC04\uACA9",
  "font.spacing.property.indent": "\uB4E4\uC5EC\uC4F0\uAE30",
  "backdrop.filter.property.title": "\uD6C4\uBA74 \uD544\uD130",
  "clippath.property.title": "\uD074\uB9BD\uD328\uC2A4",
  "export.property.title": "\uB0B4\uBCF4\uB0B4\uAE30",
  "export.property.download": "\uB2E4\uC6B4\uB85C\uB4DC",
  "iframe.property.title": "\uC544\uC774\uD504\uB808\uC784",
  "image.property.title": "\uC774\uBBF8\uC9C0",
  "image.property.origin": "\uC6D0\uBCF8",
  "image.property.size": "\uD06C\uAE30",
  "image.property.width": "\uB113\uC774",
  "image.property.height": "\uB192\uC774",
  "video.property.title": "\uBE44\uB514\uC624",
  "video.property.play": "\uC2DC\uC791",
  "video.property.pause": "\uBA48\uCDA4",
  "video.property.volume": "\uBCFC\uB968",
  "video.property.playbackRate": "\uBE60\uB974\uAE30",
  "video.property.currentTime": "\uD604\uC7AC \uC2DC\uAC04",
  "video.property.playTime": "\uD50C\uB808\uC774 \uC2DC\uAC04 \uAC04\uACA9",
  "motion.property.title": "\uBAA8\uC158",
  "path.data.property.title": "\uD328\uC2A4 \uC815\uBCF4",
  "polygon.data.property.title": "\uD3F4\uB9AC\uACE4 \uC815\uBCF4",
  "text.property.title": "\uD14D\uC2A4\uD2B8 \uC2A4\uD0C0\uC77C",
  "text.property.align": "\uC815\uB82C",
  "text.property.transform": "\uBCC0\uD615",
  "text.property.decoration": "\uC7A5\uC2DD",
  "text.clip.property.title": "\uD14D\uC2A4\uD2B8 \uD074\uB9BD",
  "text.shadow.property.title": "\uD14D\uC2A4\uD2B8 \uADF8\uB9BC\uC790",
  "text.fill.property.title": "\uD14D\uC2A4\uD2B8 \uCC44\uC6B0\uAE30",
  "text.fill.property.fill": "\uCC44\uC6B0\uAE30",
  "text.fill.property.stroke": "\uC724\uACFD\uC120",
  "text.fill.property.strokeWidth": "\uC724\uACFD\uC120 \uAD75\uAE30",
  "transform.property.title": "\uD2B8\uB79C\uC2A4\uD3FC",
  "transform.origin.property.title": "\uD2B8\uB79C\uC2A4\uD3FC Origin",
  "transition.property.title": "CSS \uD2B8\uB79C\uC9C0\uC158",
  "keyframe.property.title": "CSS \uD0A4\uD504\uB808\uC784",
  "selector.property.title": "CSS \uC140\uB809\uD130",
  "selector.property.none": "\uC120\uD0DD\uC790 \uC5C6\uC74C",
  "perspective.property.title": "\uD22C\uC601(perspective)",
  "perspective.origin.property.title": "\uD22C\uC601 \uC911\uC2EC\uC810",
  "svg.item.property.title": "\uBCF4\uC774\uAE30",
  "svg.item.property.isMotionPath": "\uBAA8\uC158 \uD328\uC2A4",
  "svg.item.property.fill": "\uCC44\uC6B0\uAE30",
  "svg.item.property.fillOpacity": "\uD22C\uBA85\uB3C4",
  "svg.item.property.path": "\uD328\uC2A4",
  "svg.item.property.polygon": "\uD3F4\uB9AC\uACE4",
  "svg.item.property.totalLength": "\uC804\uCCB4 \uAE38\uC774",
  "svg.item.property.fillRule": "\uCC44\uC6B0\uAE30 \uADDC\uCE59",
  "svg.item.property.stroke": "\uC120",
  "svg.item.property.strokeWidth": "\uC120 \uAD75\uAE30",
  "svg.item.property.dashArray": "\uC810\uC120 \uAE38\uC774",
  "svg.item.property.dashOffset": "\uC810\uC120 \uC704\uCE58",
  "svg.item.property.lineCap": "\uC120 \uBAA8\uC591",
  "svg.item.property.lineJoin": "\uACB9\uCE5C \uC120",
  "svg.item.property.filter": "\uD544\uD130",
  "svg.item.property.blend": "\uBE14\uB80C\uB4DC",
  "border.editor.all": "\uC804\uCCB4",
  "border.editor.width": "\uD06C\uAE30",
  "border.editor.style": "\uC2A4\uD0C0\uC77C",
  "border.editor.color": "\uC0C9",
  "border.editor.top": "\uC704",
  "border.editor.left": "\uC67C\uCABD",
  "border.editor.right": "\uC624\uB978\uCABD",
  "border.editor.bottom": "\uC544\uB798",
  "border.radius.editor.topLeft": "\uC67C\uCABD \uC704",
  "border.radius.editor.topRight": "\uC624\uB978\uCABD \uC704",
  "border.radius.editor.bottomLeft": "\uC67C\uCABD \uC544\uB798",
  "border.radius.editor.bottomRight": "\uC624\uB978\uCABD \uC544\uB798",
  "boxshadow.editor.blur": "\uD750\uB9BC",
  "boxshadow.editor.spread": "\uAE38\uC774",
  "css.property.editor.properties": "\uC18D\uC131",
  "offset.path.list.editor.path": "\uD328\uC2A4",
  "offset.path.list.editor.totalLength": "\uC804\uCCB4 \uAE38\uC774",
  "offset.path.list.editor.distance": "\uAC70\uB9AC",
  "offset.path.list.editor.direction": "\uBC29\uD5A5",
  "offset.path.list.editor.rotate": "\uD68C\uC804",
  "svgfilter.select.editor.message.create": "\uC0C8\uB85C\uC6B4 SVG Filter \uB97C \uB9CC\uB4DC\uC138\uC694.",
  "svgfilter.select.editor.message.select": "\uD544\uD130\uB97C \uC120\uD0DD\uD558\uC138\uC694.",
  "fill.editor.message.click.image": "\uC774\uBBF8\uC9C0\uB97C \uC120\uD0DD\uD558\uACE0 \uC2F6\uC73C\uBA74 \uD504\uB9AC\uBDF0 \uC601\uC5ED\uC744 \uD074\uB9AD\uD558\uC138\uC694.",
  "fill.editor.message.drag.position": "\uAC00\uC6B4\uB370 \uC704\uCE58\uB97C \uB4DC\uB798\uADF8 \uD574\uBCF4\uC138\uC694.",
  "fill.editor.x1": "\uC2DC\uC791 X",
  "fill.editor.x2": "\uB05D X",
  "fill.editor.y1": "\uC2DC\uC791 Y",
  "fill.editor.y2": "\uB05D Y",
  "fill.editor.spread": "\uD655\uC0B0",
  "fill.editor.offset": "\uC704\uCE58",
  "fill.editor.cx": "\uC911\uC2EC\uC810 X",
  "fill.editor.cy": "\uC911\uC2EC\uC810 Y",
  "fill.editor.r": "\uB05D \uBC18\uC9C0\uB984",
  "fill.editor.fx": "\uC2DC\uC791 X",
  "fill.editor.fy": "\uC2DC\uC791 Y",
  "fill.editor.fr": "\uC2DC\uC791 \uBC18\uC9C0\uB984",
  "perspective.origin.editor.originX": "\uC911\uC2EC\uC810 X",
  "perspective.origin.editor.originY": "\uC911\uC2EC\uC810 Y",
  "path.manager.msg": "\uD3B8\uC9D1\uC744 \uC885\uB8CC\uD560 \uB54C\uB294 ESC \uD0A4\uB098 Enter \uD0A4\uB97C \uB204\uB974\uC138\uC694. \uB610\uB294 \uD654\uBA74\uC744 \uD074\uB9AD\uD558\uC2DC\uBA74 \uB429\uB2C8\uB2E4.",
  "path.manager.mode.done": "\uC644\uB8CC",
  "path.manager.mode.modify": "\uC810 \uD3B8\uC9D1",
  "path.manager.mode.path": "\uC810 \uCD94\uAC00",
  "path.manager.mode.warp": "\uC6CC\uD504",
  "path.manager.mode.transform": "\uBCC0\uD615",
  "path.manager.mode.reverse": "\uC21C\uC11C\uBCC0\uACBD",
  "path.manager.mode.flipX": "X\uCD95 \uD68C\uC804",
  "path.manager.mode.flipY": "Y\uCD95 \uD68C\uC804",
  "path.manager.mode.flipOrigin": "\uC804\uCCB4 \uD68C\uC804",
  "colorpicker.popup.title": "\uC0C9\uC0C1 \uC120\uD0DD",
  "selector.popup.title": "\uC120\uD0DD\uC790 \uC18D\uC131",
  "selector.popup.selector": "\uC120\uD0DD\uC790",
  "background.image.position.popup.title": "\uBC30\uACBD \uD328\uD134",
  "background.image.position.popup.size": "\uD06C\uAE30",
  "background.image.position.popup.width": "\uB113\uC774",
  "background.image.position.popup.height": "\uB192\uC774",
  "background.image.position.popup.repeat": "\uBC18\uBCF5",
  "background.image.position.popup.blend": "\uBE14\uB80C\uB4DC",
  "background.image.position.popup.type.repeat": "\uBC18\uBCF5",
  "background.image.position.popup.type.no-repeat": "\uBC18\uBCF5 \uC548\uD568",
  "background.image.position.popup.type.repeat-x": "x\uCD95 \uBC18\uBCF5",
  "background.image.position.popup.type.repeat-y": "y\uCD95 \uBC18\uBCF5",
  "background.image.position.popup.type.space": "\uACF5\uBC31\uC720\uC9C0",
  "background.image.position.popup.type.round": "\uBC18\uC62C\uB9BC",
  "gradient.picker.popup.title": "\uADF8\uB77C\uB514\uC5B8\uD2B8\uC640 \uC774\uBBF8\uC9C0",
  "image.asset.property.title": "\uC774\uBBF8\uC9C0",
  "video.asset.property.title": "\uBE44\uB514\uC624",
  "color.asset.property.title": "\uC0C9",
  "gradient.asset.property.title": "\uADF8\uB77C\uB514\uC5B8\uD2B8",
  "pattern.asset.property.title": "\uD328\uD134",
  "svgfilter.asset.property.title": "SVG \uD544\uD130",
  "inspector.tab.title.design": "\uB514\uC790\uC778",
  "inspector.tab.title.component": "\uCEF4\uD3EC\uB10C\uD2B8 \uC18D\uC131",
  "inspector.tab.title.transition": "\uC560\uB2C8\uBA54\uC774\uC158",
  "inspector.tab.title.asset": "\uC5D0\uC14B \uAD00\uB9AC\uC790",
  "inspector.tab.title.text": "\uD14D\uC2A4\uD2B8",
  "inspector.tab.title.code": "\uCF54\uB4DC",
  "inspector.tab.title.history": "\uAE30\uB85D",
  "timeline.property.title": "\uD0C0\uC784\uB77C\uC778",
  "timeline.property.resize": "\uD0C0\uC784\uB77C\uC778 \uB192\uC774\uB97C \uBCC0\uACBD\uD569\uB2C8\uB2E4. \uB4DC\uB798\uADF8 \uD574\uC8FC\uC138\uC694.",
  "timeline.animation.property.title": "\uC560\uB2C8\uBA54\uC774\uC158",
  "timeline.play.control.play": "\uD50C\uB808\uC774",
  "timeline.play.control.pause": "\uBA48\uCDA4",
  "timeline.play.control.first": "\uCC98\uC74C\uC73C\uB85C",
  "timeline.play.control.prev": "\uC774\uC804\uC73C\uB85C",
  "timeline.play.control.next": "\uB2E4\uC74C\uC73C\uB85C",
  "timeline.play.control.last": "\uB9C8\uC9C0\uB9C9\uC73C\uB85C",
  "timeline.play.control.direction": "\uBC29\uD5A5",
  "timeline.play.control.speed": "\uC18D\uB825",
  "timeline.play.control.repeat": "\uBC18\uBCF5",
  "timeline.play.control.infinite": "\uBB34\uD55C",
  "timeline.play.control.normal": "normal",
  "timeline.play.control.alternate": "alternate",
  "timeline.play.control.reverse": "reverse",
  "timeline.play.control.alternate.reverse": "alternate reverse",
  "timeline.value.editor.value": "\uAC12",
  "timeline.value.editor.time": "\uC2DC\uAC04",
  "timeline.value.editor.timing": "\uD0C0\uC774\uBC0D \uD568\uC218",
  "timeline.value.editor.offset.message": "Enter\uD0A4\uB97C \uC785\uB825\uD558\uBA74 \uC801\uC6A9\uB429\uB2C8\uB2E4.",
  "svgfilter.popup.title": "SVG \uD544\uD130",
  "css.item.rotate": "\uD68C\uC804",
  "css.item.rotateX": "X\uCD95 \uD68C\uC804",
  "css.item.rotateY": "Y\uCD95 \uD68C\uC804",
  "css.item.rotateZ": "Z\uCD95 \uD68C\uC804",
  "css.item.rotate3d": "3D \uD68C\uC804",
  "css.item.skewX": "X\uCD95 \uB298\uC774\uAE30",
  "css.item.skewY": "Y\uCD95 \uB298\uC774\uAE30",
  "css.item.translate": "\uC774\uB3D9",
  "css.item.translateX": "X\uCD95 \uC774\uB3D9",
  "css.item.translateY": "Y\uCD95 \uC774\uB3D9",
  "css.item.translateZ": "Z\uCD95 \uC774\uB3D9",
  "css.item.translate3d": "3D \uC774\uB3D9",
  "css.item.perspective": "\uC6D0\uADFC",
  "css.item.scale": "\uD06C\uAE30\uBCC0\uACBD",
  "css.item.scaleX": "X\uCD95 \uD06C\uAE30\uBCC0\uACBD",
  "css.item.scaleY": "Y\uCD95 \uD06C\uAE30\uBCC0\uACBD",
  "css.item.scaleZ": "Z\uCD95 \uD06C\uAE30\uBCC0\uACBD",
  "css.item.scale3d": "3D \uD06C\uAE30\uBCC0\uACBD",
  "css.item.matrix": "\uBCC0\uD658 \uD589\uB82C",
  "css.item.matrix3d": "3D \uBCC0\uD658 \uD589\uB82C",
  "animation.property.title": "CSS \uC560\uB2C8\uBA54\uC774\uC158",
  "animation.property.direction": "\uBC29\uD5A5",
  "animation.property.play.state": "\uD50C\uB808\uC774 \uC0C1\uD0DC",
  "animation.property.fill.mode": "\uCC44\uC6B0\uAE30 \uBAA8\uB4DC",
  "animation.property.delay": "\uB300\uAE30\uC2DC\uAC04",
  "animation.property.duration": "\uC2DC\uAC04",
  "animation.property.iteration.count": "\uBC18\uBCF5 \uD69F\uC218",
  "animation.property.select a keyframe": "\uD0A4\uD504\uB808\uC784\uC744 \uC120\uD0DD\uD574\uC8FC\uC138\uC694",
  "animation.property.popup.title": "CSS \uC560\uB2C8\uBA54\uC774\uC158",
  "animation.property.popup.timing.function": "\uD0C0\uC774\uBC0D \uD568\uC218",
  "animation.property.popup.keyframe": "\uD0A4\uD504\uB808\uC784",
  "animation.property.popup.direction": "\uBC29\uD5A5",
  "animation.property.popup.play.state": "\uD50C\uB808\uC774 \uC0C1\uD0DC",
  "animation.property.popup.fill.mode": "\uCC44\uC6B0\uAE30 \uBAA8\uB4DC",
  "animation.property.popup.delay": "\uB300\uAE30\uC2DC\uAC04",
  "animation.property.popup.duration": "\uC2DC\uAC04",
  "animation.property.popup.iteration": "\uBC18\uBCF5 \uD69F\uC218",
  "animation.property.popup.normal": "\uC2DC\uAC04\uC21C",
  "animation.property.popup.reverse": "\uC5ED\uC2DC\uAC04\uC21C",
  "animation.property.popup.alternate": "\uC655\uBCF5 \uC2DC\uAC04\uC21C",
  "animation.property.popup.alternate-reverse": "\uC655\uBCF5 \uC5ED\uC2DC\uAC04\uC21C",
  "animation.property.popup.none": "none",
  "animation.property.popup.forwards": "forwards",
  "animation.property.popup.backwards": "backwards",
  "animation.property.popup.both": "both",
  "animation.property.popup.Select a keyframe": "\uD0A4\uD504\uB808\uC784\uC744 \uC120\uD0DD\uD574\uC8FC\uC138\uC694.",
  "keyframe.popup.title": "\uD0A4\uD504\uB808\uC784",
  "code.view.property.title": "\uCF54\uB4DC\uBDF0",
  "svg.filter.editor.tab.filter": "\uD544\uD130",
  "svg.filter.editor.tab.preset": "\uD504\uB9AC\uC14B",
  "svg.filter.editor.tab.asset": "\uC5D0\uC14B",
  "svg.filter.editor.GRAPHIC REFERENCES": "\uCC38\uC870 \uADF8\uB798\uD53D",
  "svg.filter.editor.SOURCES": "\uC6D0\uBCF8",
  "svg.filter.editor.MODIFIER": "\uC218\uC815",
  "svg.filter.editor.LIGHTING": "\uBE5B",
  "svg.filter.editor.COMBINERS": "\uACB0\uD569",
  "svg.filter.editor.Template": "\uD15C\uD50C\uB9BF",
  "layout.property.title": "\uB808\uC774\uC544\uC6C3",
  "layout.property.flex": "\uD50C\uB809\uC2A4 \uBC15\uC2A4",
  "layout.property.grid": "\uADF8\uB9AC\uB4DC",
  "layout.property.default": "\uAE30\uBCF8 \uC88C\uD45C",
  "layout.property.resizing.title": "\uC0AC\uC774\uC988 \uC870\uC808",
  "layout.property.resizing.self.title": "\uC544\uC774\uD15C \uC0AC\uC774\uC988 \uC870\uC808",
  "default.layout.item.property.title.constraints": "Constraints",
  "flex.layout.editor.row": "\uD589",
  "flex.layout.editor.column": "\uC5F4",
  "flex.layout.editor.row-reverse": "\uC5ED\uBC29\uD5A5 \uD589",
  "flex.layout.editor.column-reverse": "\uC5ED\uBC29\uD5A5 \uC5F4",
  "flex.layout.editor.nowrap": "\uAC10\uC2F8\uC9C0 \uC54A\uAE30",
  "flex.layout.editor.wrap": "\uAC10\uC2F8\uAE30",
  "flex.layout.editor.wrap-reverse": "\uC5ED\uBC29\uD5A5 \uAC10\uC2F8\uAE30",
  "flex.layout.editor.flex-start": "\uC2DC\uC791",
  "flex.layout.editor.flex-end": "\uB05D",
  "flex.layout.editor.center": "\uC911\uAC04",
  "flex.layout.editor.space-between": "\uACF5\uAC04 \uC911\uAC04 \uCC44\uC6C0",
  "flex.layout.editor.space-around": "\uACF5\uAC04 \uC591\uB05D \uCC44\uC6C0",
  "flex.layout.editor.baseline": "\uAE30\uBCF8\uC120",
  "flex.layout.editor.stretch": "\uD3BC\uCE58\uAE30",
  "flex.layout.editor.direction": "\uBC29\uD5A5",
  "flex.layout.editor.justify-content": "\uCEE8\uD150\uCE20 \uC870\uC815",
  "flex.layout.editor.align-items": "\uC544\uC774\uD15C \uC815\uB82C",
  "flex.layout.editor.align-content": "\uCEE8\uD150\uCE20 \uC815\uB82C",
  "flex.layout.item.property.title": "\uD50C\uB809\uC2A4 \uC544\uC774\uD15C \uC124\uC815",
  "flex.layout.item.property.grow": "\uACF5\uAC04 \uBE44\uC728",
  "flex.layout.item.property.shrink": "\uCD95\uC18C \uBE44\uC728",
  "flex.layout.item.property.basis": "\uCD08\uAE30 \uD06C\uAE30",
  "flex.layout.item.property.none": "\uC5C6\uC74C",
  "flex.layout.item.property.auto": "\uC790\uB3D9",
  "flex.layout.item.property.value": "\uAC12",
  "grid.layout.editor.template.columns": "\uC5F4",
  "grid.layout.editor.column.gap": "\uC5F4 \uAC04\uACA9",
  "grid.layout.editor.template.rows": "\uD589",
  "grid.layout.editor.row.gap": "\uD589 \uAC04\uACA9",
  "grid.box.editor.box.title": "\uC601\uC5ED",
  "grid.box.editor.type": "\uD0C0\uC785",
  "grid.box.editor.repeat": "\uBC18\uBCF5",
  "grid.box.editor.length": "\uAE38\uC774",
  "grid.box.editor.none": "\uC5C6\uC74C",
  "grid.box.editor.auto": "\uC790\uB3D9",
  "grid.box.editor.count": "\uAC1C\uC218",
  "grid.box.editor.value": "\uD06C\uAE30",
  "grid.layout.item.property.title": "\uADF8\uB9AC\uB4DC \uC544\uC774\uD15C \uC124\uC815",
  "grid.layout.item.property.column": "\uC5F4",
  "grid.layout.item.property.row": "\uD589",
  "grid.layout.item.property.start": "\uC2DC\uC791",
  "grid.layout.item.property.End": "\uB05D",
  "grid.layout.item.property.none": "\uC5C6\uC74C",
  "grid.layout.item.property.value": "\uAC12",
  "box.model.property.title": "\uBC15\uC2A4 \uBAA8\uB378",
  "box.model.property.margin": "\uB9C8\uC9C4",
  "box.model.property.padding": "\uD328\uB529",
  "component.items.canvas": "\uCE94\uBC84\uC2A4",
  "component.items.layer": "\uB808\uC774\uC5B4",
  "component.items.3dlayer": "3D \uB808\uC774\uC5B4",
  "component.items.drawing": "\uADF8\uB9AC\uAE30",
  "component.items.custom": "\uC0AC\uC6A9\uC790 \uC815\uC758 \uCEF4\uD3EC\uB10C\uD2B8",
  "component.items.chart": "\uCC28\uD2B8",
  "component.items.plugin": "\uD50C\uB7EC\uADF8\uC778",
  "svg.text.property.title": "SVG Text \uC2A4\uD0C0\uC77C",
  "svg.text.property.textarea": "\uD14D\uC2A4\uD2B8 \uC785\uB825",
  "svg.text.property.size": "\uD3F0\uD2B8 \uD06C\uAE30",
  "svg.text.property.weight": "\uD3F0\uD2B8 \uAD75\uAE30",
  "svg.text.property.style": "\uD3F0\uD2B8 \uC2A4\uD0C0\uC77C",
  "svg.text.property.anchor": "\uD14D\uC2A4\uD2B8 \uC704\uCE58",
  "svg.text.property.family": "\uD3F0\uD2B8 \uAE00\uAF34",
  "svg.text.property.length.adjust": "\uAE38\uC774 \uB300\uC751",
  "svg.text.property.text.length": "\uD14D\uC2A4\uD2B8 \uAE38\uC774",
  "svg.text.property.start.offset": "\uC2DC\uC791 \uC9C0\uC810",
  "fill.picker.popup.title": "\uC0C9 \uCC44\uC6B0\uAE30",
  "gradient.editor.drag.message": "\uB4DC\uB798\uADF8 \uD558\uBA74 \uC911\uC2EC\uC810\uC744 \uC62E\uAE38 \uC218 \uC788\uC2B5\uB2C8\uB2E4.",
  "draw.manager.tolerance": "\uD3EC\uC778\uD2B8 \uD5C8\uC6A9 \uC624\uCC28",
  "pattern.property.title": "\uD328\uD134",
  "pattern.info.popup.title": "\uD328\uD134 \uC815\uBCF4",
  "pattern.info.popup.width": "\uB113\uC774",
  "pattern.info.popup.height": "\uB192\uC774",
  "pattern.info.popup.lineWidth": "\uC120 \uB113\uC774",
  "pattern.info.popup.lineHeight": "\uC120 \uB192\uC774",
  "pattern.info.popup.rotate": "\uD68C\uC804",
  "pattern.info.popup.blend": "\uBE14\uB80C\uB4DC",
  "pattern.info.popup.foreColor": "\uD328\uD134\uC0C9",
  "pattern.info.popup.backColor": "\uBC30\uACBD\uC0C9",
  "stroke.dasharray.editor.add": "\uC810 \uCD94\uAC00",
  "viewport.panning.enable": "space \uB97C \uB204\uB978\uCC44 \uD654\uBA74\uC744 \uB4DC\uB798\uADF8 \uD558\uBA74 \uC601\uC5ED\uC744 \uC6C0\uC9C1\uC77C \uC218 \uC788\uC2B5\uB2C8\uB2E4."
};
var locales = {
  en_US,
  fr_FR,
  ko_KR
};
function defaultMessages(editor) {
  Object.keys(locales).forEach(function(locale) {
    editor.registerI18nMessage(locale, locales[locale]);
  });
}
var SelectEditor$1 = "";
const ConstraintsDirection = {
  HORIZONTAL: "constraints-horizontal",
  VERTICAL: "constraints-vertical"
};
const Constraints = {
  NONE: "none",
  MIN: "min",
  MAX: "max",
  STRETCH: "stretch",
  SCALE: "scale",
  CENTER: "center"
};
const BooleanOperation = {
  DIFFERENCE: "difference",
  INTERSECTION: "intersection",
  UNION: "union",
  REVERSE_DIFFERENCE: "reverse-difference",
  XOR: "xor"
};
const StrokeLineCap = {
  BUTT: "butt",
  ROUND: "round",
  SQUARE: "square"
};
const StrokeLineJoin = {
  MITER: "miter",
  ROUND: "round",
  BEVEL: "bevel"
};
const BlendMode = {
  NORMAL: "normal",
  MULTIPLY: "multiply",
  SCREEN: "screen",
  OVERLAY: "overlay",
  DARKEN: "darken",
  LIGHTEN: "lighten",
  COLOR_DODGE: "color-dodge",
  COLOR_BURN: "color-burn",
  HARD_LIGHT: "hard-light",
  SOFT_LIGHT: "soft-light",
  DIFFERENCE: "difference",
  EXCLUSION: "exclusion",
  HUE: "hue",
  SATURATION: "saturation",
  COLOR: "color",
  LUMINOSITY: "luminosity"
};
const TextDecoration = {
  NONE: "none",
  UNDERLINE: "underline",
  OVERLINE: "overline",
  LINE_THROUGH: "line-through",
  BLINK: "blink"
};
const TextTransform = {
  NONE: "none",
  CAPITALIZE: "capitalize",
  UPPERCASE: "uppercase",
  LOWERCASE: "lowercase"
};
const TextAlign = {
  START: "start",
  END: "end",
  LEFT: "left",
  RIGHT: "right",
  CENTER: "center",
  JUSTIFY: "justify"
};
const Overflow = {
  VISIBLE: "visible",
  HIDDEN: "hidden",
  SCROLL: "scroll",
  AUTO: "auto"
};
const BorderStyle = {
  NONE: "none",
  HIDDEN: "hidden",
  DOTTED: "dotted",
  DASHED: "dashed",
  SOLID: "solid",
  DOUBLE: "double",
  GROOVE: "groove",
  RIDGE: "ridge",
  INSET: "inset",
  OUTSET: "outset"
};
const TransformValue = {
  NONE: "none",
  PERSPECTIVE: "perspective",
  TRANSLATE: "translate",
  TRANSLATE_X: "translateX",
  TRANSLATE_Y: "translateY",
  TRANSLATE_Z: "translateZ",
  TRANSLATE_3D: "translate3d",
  SCALE: "scale",
  SCALE_X: "scaleX",
  SCALE_Y: "scaleY",
  SCALE_Z: "scaleZ",
  SCALE_3D: "scale3d",
  ROTATE: "rotate",
  ROTATE_X: "rotateX",
  ROTATE_Y: "rotateY",
  ROTATE_Z: "rotateZ",
  SKEW: "skew",
  SKEW_X: "skewX",
  SKEW_Y: "skewY",
  MATRIX: "matrix",
  MATRIX_3D: "matrix3d"
};
const Layout = {
  DEFAULT: "default",
  FLEX: "flex",
  GRID: "grid"
};
const FlexDirection = {
  ROW: "row",
  ROW_REVERSE: "row-reverse",
  COLUMN: "column",
  COLUMN_REVERSE: "column-reverse"
};
const JustifyContent = {
  FLEX_START: "flex-start",
  FLEX_END: "flex-end",
  CENTER: "center",
  SPACE_BETWEEN: "space-between",
  SPACE_AROUND: "space-around",
  SPACE_EVENLY: "space-evenly"
};
const AlignItems = {
  FLEX_START: "flex-start",
  FLEX_END: "flex-end",
  CENTER: "center",
  BASELINE: "baseline",
  STRETCH: "stretch"
};
const AlignContent = {
  FLEX_START: "flex-start",
  FLEX_END: "flex-end",
  CENTER: "center",
  SPACE_BETWEEN: "space-between",
  SPACE_AROUND: "space-around",
  SPACE_EVENLY: "space-evenly"
};
const FlexWrap = {
  NOWRAP: "nowrap",
  WRAP: "wrap",
  WRAP_REVERSE: "wrap-reverse"
};
const ResizingMode = {
  FIXED: "fixed",
  HUG_CONTENT: "hug-content",
  FILL_CONTAINER: "fill-container"
};
const TextClip = {
  NONE: "none",
  TEXT: "text"
};
const BoxShadowStyle = {
  OUTSET: "outset",
  INSET: "inset"
};
const GradientType = {
  STATIC: "static-gradient",
  LINEAR: "linear-gradient",
  RADIAL: "radial-gradient",
  CONIC: "conic-gradient",
  REPEATING_LINEAR: "repeating-linear-gradient",
  REPEATING_RADIAL: "repeating-radial-gradient",
  REPEATING_CONIC: "repeating-conic-gradient",
  IMAGE: "image",
  URL: "url"
};
const RadialGradientSizeType = {
  CLOSEST_SIDE: "closest-side",
  CLOSEST_CORNER: "closest-corner",
  FARTHEST_SIDE: "farthest-side",
  FARTHEST_CORNER: "farthest-corner"
};
const RadialGradientType = {
  CIRCLE: "circle",
  ELLIPSE: "ellipse"
};
const ClipPathType = {
  NONE: "none",
  CIRCLE: "circle",
  ELLIPSE: "ellipse",
  POLYGON: "polygon",
  INSET: "inset",
  PATH: "path",
  SVG: "svg"
};
const VisibilityType = {
  VISIBLE: "visible",
  HIDDEN: "hidden"
};
const TimingFunction = {
  LINEAR: "linear",
  EASE: "ease",
  EASE_IN: "ease-in",
  EASE_OUT: "ease-out",
  EASE_IN_OUT: "ease-in-out",
  STEPS: "steps",
  CUBIC_BEZIER: "cubic-bezier",
  PATH: "path"
};
const SpreadMethodType = {
  PAD: "pad",
  REFLECT: "reflect",
  REPEAT: "repeat"
};
const FuncType = {
  COMMA: "comma",
  COLOR: "color",
  LENGTH: "length",
  GRADIENT: "gradient",
  TIMING: "timing",
  KEYWORD: "keyword",
  STRING: "string",
  NUMBER: "number",
  BOOLEAN: "boolean",
  FUNCTION: "function",
  PATH: "path",
  URL: "url",
  REPEAT: "repeat",
  UNKNOWN: "unknown"
};
const PathSegmentType = {
  MOVETO: "M",
  LINETO: "L",
  CURVETO: "C",
  QUARDTO: "Q",
  ARCTO: "A",
  CLOSEPATH: "Z",
  UNKNOWN: "unknown"
};
const DirectionType = {
  TO_TOP: "to top",
  TO_RIGHT: "to right",
  TO_BOTTOM: "to bottom",
  TO_LEFT: "to left",
  TO_TOP_LEFT: "to top left",
  TO_TOP_RIGHT: "to top right",
  TO_BOTTOM_LEFT: "to bottom left",
  TO_BOTTOM_RIGHT: "to bottom right"
};
const DirectionNumberType = {
  1: DirectionType.TO_TOP_LEFT,
  2: DirectionType.TO_TOP_RIGHT,
  3: DirectionType.TO_BOTTOM_LEFT,
  4: DirectionType.TO_BOTTOM_RIGHT,
  11: DirectionType.TO_TOP,
  12: DirectionType.TO_RIGHT,
  13: DirectionType.TO_BOTTOM,
  14: DirectionType.TO_LEFT
};
const TargetActionType = {
  APPEND_CHILD: "appendChild",
  INSERT_BEFORE: "insertBefore",
  INSERT_AFTER: "insertAfter"
};
class SelectEditor extends EditorElement {
  initState() {
    var splitChar = this.props.split || ",";
    var options2 = Array.isArray(this.props.options) ? this.props.options.map((it) => {
      if (typeof it === "string") {
        return { value: it, text: it };
      }
      return it;
    }) : (this.props.options || "").split(splitChar).map((it) => it.trim()).map((it) => {
      const [value2, text2] = it.split(":");
      return { value: value2, text: text2 || value2 };
    });
    var value = this.props.value;
    var tabIndex = this.props.tabindex;
    var title2 = this.props.title;
    return {
      splitChar,
      label: this.props.label || "",
      title: title2,
      options: options2,
      value,
      tabIndex
    };
  }
  template() {
    var { label, title: title2, tabIndex, value = BlendMode.NORMAL } = this.state;
    var hasLabel = label ? "has-label" : "";
    var hasTabIndex = tabIndex ? 'tabIndex="1"' : "";
    var compact = this.props.compact ? "compact" : "";
    if (obj$3[label]) {
      label = iconUse(label);
    }
    return `
            <div class='elf--select-editor ${hasLabel} ${compact}'>
                ${label ? `<label title="${title2}">${label}</label>` : ""}
                <div class="editor-view">
                    <select ref='$options' ${hasTabIndex}></select>
                    <div class='selected-value'>
                        <span class='value' ref="$selectedValue">${value}</span>
                        <span class='expand' ref='$expand'>${iconUse("expand_more")}</span>
                    </div>
                </div>
            </div>
        `;
  }
  getValue() {
    return this.refs.$options.value;
  }
  setValue(value) {
    this.state.value = value + "";
    this.refs.$options.val(this.state.value);
    this.refresh();
  }
  [BIND("$options")]() {
    return {
      "data-count": this.state.options.length.toString()
    };
  }
  [BIND("$selectedValue")]() {
    var _a;
    return {
      text: (_a = this.state.options.find((it) => it.value === this.state.value)) == null ? void 0 : _a.text
    };
  }
  [LOAD("$options") + DOMDIFF]() {
    var arr = this.state.options.map((it) => {
      var value = it.value;
      var label = it.text || it.value;
      if (label === "") {
        label = this.props["none-value"] ? this.props["none-value"] : "";
      } else if (label === "-") {
        label = "----------";
        value = "";
      }
      var selected = value === this.state.value ? "selected" : "";
      const disabled = it.disabled ? "disabled" : "";
      return `<option ${selected} value="${value}" ${disabled}>${label}</option>`;
    });
    return arr;
  }
  [CHANGE("$options")]() {
    this.updateData({
      value: this.refs.$options.value
    });
    this.bindData("$selectedValue");
  }
  updateData(data) {
    this.setState(data, false);
    this.parent.trigger(this.props.onchange, this.props.key, this.state.value, this.props.params);
  }
}
const blend_list = [
  BlendMode.NORMAL,
  BlendMode.MULTIPLY,
  BlendMode.SCREEN,
  BlendMode.OVERLAY,
  BlendMode.DARKEN,
  BlendMode.LIGHTEN,
  BlendMode.COLOR_DODGE,
  BlendMode.COLOR_BURN,
  BlendMode.HARD_LIGHT,
  BlendMode.SOFT_LIGHT,
  BlendMode.DIFFERENCE,
  BlendMode.EXCLUSION,
  BlendMode.HUE,
  BlendMode.SATURATION,
  BlendMode.COLOR,
  BlendMode.LUMINOSITY
];
class BlendSelectEditor extends SelectEditor {
  getBlendList() {
    return blend_list.map((it) => {
      return { value: it, text: this.$i18n(`blend.${it}`) };
    });
  }
  initState() {
    return __spreadProps(__spreadValues({}, super.initState()), {
      options: this.getBlendList()
    });
  }
}
var BoxShadowEditor$1 = "";
const color_names = {
  aliceblue: "rgb(240, 248, 255)",
  antiquewhite: "rgb(250, 235, 215)",
  aqua: "rgb(0, 255, 255)",
  aquamarine: "rgb(127, 255, 212)",
  azure: "rgb(240, 255, 255)",
  beige: "rgb(245, 245, 220)",
  bisque: "rgb(255, 228, 196)",
  black: "rgb(0, 0, 0)",
  blanchedalmond: "rgb(255, 235, 205)",
  blue: "rgb(0, 0, 255)",
  blueviolet: "rgb(138, 43, 226)",
  brown: "rgb(165, 42, 42)",
  burlywood: "rgb(222, 184, 135)",
  cadetblue: "rgb(95, 158, 160)",
  chartreuse: "rgb(127, 255, 0)",
  chocolate: "rgb(210, 105, 30)",
  coral: "rgb(255, 127, 80)",
  cornflowerblue: "rgb(100, 149, 237)",
  cornsilk: "rgb(255, 248, 220)",
  crimson: "rgb(237, 20, 61)",
  cyan: "rgb(0, 255, 255)",
  darkblue: "rgb(0, 0, 139)",
  darkcyan: "rgb(0, 139, 139)",
  darkgoldenrod: "rgb(184, 134, 11)",
  darkgray: "rgb(169, 169, 169)",
  darkgrey: "rgb(169, 169, 169)",
  darkgreen: "rgb(0, 100, 0)",
  darkkhaki: "rgb(189, 183, 107)",
  darkmagenta: "rgb(139, 0, 139)",
  darkolivegreen: "rgb(85, 107, 47)",
  darkorange: "rgb(255, 140, 0)",
  darkorchid: "rgb(153, 50, 204)",
  darkred: "rgb(139, 0, 0)",
  darksalmon: "rgb(233, 150, 122)",
  darkseagreen: "rgb(143, 188, 143)",
  darkslateblue: "rgb(72, 61, 139)",
  darkslategray: "rgb(47, 79, 79)",
  darkslategrey: "rgb(47, 79, 79)",
  darkturquoise: "rgb(0, 206, 209)",
  darkviolet: "rgb(148, 0, 211)",
  deeppink: "rgb(255, 20, 147)",
  deepskyblue: "rgb(0, 191, 255)",
  dimgray: "rgb(105, 105, 105)",
  dimgrey: "rgb(105, 105, 105)",
  dodgerblue: "rgb(30, 144, 255)",
  firebrick: "rgb(178, 34, 34)",
  floralwhite: "rgb(255, 250, 240)",
  forestgreen: "rgb(34, 139, 34)",
  fuchsia: "rgb(255, 0, 255)",
  gainsboro: "rgb(220, 220, 220)",
  ghostwhite: "rgb(248, 248, 255)",
  gold: "rgb(255, 215, 0)",
  goldenrod: "rgb(218, 165, 32)",
  gray: "rgb(128, 128, 128)",
  grey: "rgb(128, 128, 128)",
  green: "rgb(0, 128, 0)",
  greenyellow: "rgb(173, 255, 47)",
  honeydew: "rgb(240, 255, 240)",
  hotpink: "rgb(255, 105, 180)",
  indianred: "rgb(205, 92, 92)",
  indigo: "rgb(75, 0, 130)",
  ivory: "rgb(255, 255, 240)",
  khaki: "rgb(240, 230, 140)",
  lavender: "rgb(230, 230, 250)",
  lavenderblush: "rgb(255, 240, 245)",
  lawngreen: "rgb(124, 252, 0)",
  lemonchiffon: "rgb(255, 250, 205)",
  lightblue: "rgb(173, 216, 230)",
  lightcoral: "rgb(240, 128, 128)",
  lightcyan: "rgb(224, 255, 255)",
  lightgoldenrodyellow: "rgb(250, 250, 210)",
  lightgreen: "rgb(144, 238, 144)",
  lightgray: "rgb(211, 211, 211)",
  lightgrey: "rgb(211, 211, 211)",
  lightpink: "rgb(255, 182, 193)",
  lightsalmon: "rgb(255, 160, 122)",
  lightseagreen: "rgb(32, 178, 170)",
  lightskyblue: "rgb(135, 206, 250)",
  lightslategray: "rgb(119, 136, 153)",
  lightslategrey: "rgb(119, 136, 153)",
  lightsteelblue: "rgb(176, 196, 222)",
  lightyellow: "rgb(255, 255, 224)",
  lime: "rgb(0, 255, 0)",
  limegreen: "rgb(50, 205, 50)",
  linen: "rgb(250, 240, 230)",
  magenta: "rgb(255, 0, 255)",
  maroon: "rgb(128, 0, 0)",
  mediumaquamarine: "rgb(102, 205, 170)",
  mediumblue: "rgb(0, 0, 205)",
  mediumorchid: "rgb(186, 85, 211)",
  mediumpurple: "rgb(147, 112, 219)",
  mediumseagreen: "rgb(60, 179, 113)",
  mediumslateblue: "rgb(123, 104, 238)",
  mediumspringgreen: "rgb(0, 250, 154)",
  mediumturquoise: "rgb(72, 209, 204)",
  mediumvioletred: "rgb(199, 21, 133)",
  midnightblue: "rgb(25, 25, 112)",
  mintcream: "rgb(245, 255, 250)",
  mistyrose: "rgb(255, 228, 225)",
  moccasin: "rgb(255, 228, 181)",
  navajowhite: "rgb(255, 222, 173)",
  navy: "rgb(0, 0, 128)",
  oldlace: "rgb(253, 245, 230)",
  olive: "rgb(128, 128, 0)",
  olivedrab: "rgb(107, 142, 35)",
  orange: "rgb(255, 165, 0)",
  orangered: "rgb(255, 69, 0)",
  orchid: "rgb(218, 112, 214)",
  palegoldenrod: "rgb(238, 232, 170)",
  palegreen: "rgb(152, 251, 152)",
  paleturquoise: "rgb(175, 238, 238)",
  palevioletred: "rgb(219, 112, 147)",
  papayawhip: "rgb(255, 239, 213)",
  peachpuff: "rgb(255, 218, 185)",
  peru: "rgb(205, 133, 63)",
  pink: "rgb(255, 192, 203)",
  plum: "rgb(221, 160, 221)",
  powderblue: "rgb(176, 224, 230)",
  purple: "rgb(128, 0, 128)",
  rebeccapurple: "rgb(102, 51, 153)",
  red: "rgb(255, 0, 0)",
  rosybrown: "rgb(188, 143, 143)",
  royalblue: "rgb(65, 105, 225)",
  saddlebrown: "rgb(139, 69, 19)",
  salmon: "rgb(250, 128, 114)",
  sandybrown: "rgb(244, 164, 96)",
  seagreen: "rgb(46, 139, 87)",
  seashell: "rgb(255, 245, 238)",
  sienna: "rgb(160, 82, 45)",
  silver: "rgb(192, 192, 192)",
  skyblue: "rgb(135, 206, 235)",
  slateblue: "rgb(106, 90, 205)",
  slategray: "rgb(112, 128, 144)",
  slategrey: "rgb(112, 128, 144)",
  snow: "rgb(255, 250, 250)",
  springgreen: "rgb(0, 255, 127)",
  steelblue: "rgb(70, 130, 180)",
  tan: "rgb(210, 180, 140)",
  teal: "rgb(0, 128, 128)",
  thistle: "rgb(216, 191, 216)",
  tomato: "rgb(255, 99, 71)",
  turquoise: "rgb(64, 224, 208)",
  violet: "rgb(238, 130, 238)",
  wheat: "rgb(245, 222, 179)",
  white: "rgb(255, 255, 255)",
  whitesmoke: "rgb(245, 245, 245)",
  yellow: "rgb(255, 255, 0)",
  yellowgreen: "rgb(154, 205, 50)",
  transparent: "rgba(0, 0, 0, 0)",
  currentColor: "currentColor"
};
function isColorName(name) {
  return !!color_names[name];
}
function getColorByName(name) {
  return color_names[name];
}
var ColorNames = {
  isColorName,
  getColorByName
};
function ReverseXyz(n) {
  return Math.pow(n, 3) > 8856e-6 ? Math.pow(n, 3) : (n - 16 / 116) / 7.787;
}
function ReverseRGB(n) {
  return n > 31308e-7 ? 1.055 * Math.pow(n, 1 / 2.4) - 0.055 : 12.92 * n;
}
function XYZtoRGB(x, y, z) {
  if (arguments.length == 1) {
    var { x, y, z } = arguments[0];
  }
  let X = x / 100;
  let Y = y / 100;
  let Z = z / 100;
  let R = X * 3.2406 + Y * -1.5372 + Z * -0.4986;
  let G = X * -0.9689 + Y * 1.8758 + Z * 0.0415;
  let B = X * 0.0557 + Y * -0.204 + Z * 1.057;
  R = ReverseRGB(R);
  G = ReverseRGB(G);
  B = ReverseRGB(B);
  const r = round(R * 255);
  const g = round(G * 255);
  const b = round(B * 255);
  return { r, g, b };
}
function LABtoXYZ(l, a, b) {
  if (arguments.length == 1) {
    var { l, a, b } = arguments[0];
  }
  let Y = (l + 16) / 116;
  let X = a / 500 + Y;
  let Z = Y - b / 200;
  Y = ReverseXyz(Y);
  X = ReverseXyz(X);
  Z = ReverseXyz(Z);
  const x = X * 95.047;
  const y = Y * 100;
  const z = Z * 108.883;
  return { x, y, z };
}
function PivotXyz(n) {
  return n > 8856e-6 ? Math.pow(n, 1 / 3) : (7.787 * n + 16) / 116;
}
function XYZtoLAB(x, y, z) {
  if (arguments.length == 1) {
    var { x, y, z } = arguments[0];
  }
  let X = x / 95.047;
  let Y = y / 100;
  let Z = z / 108.883;
  X = PivotXyz(X);
  Y = PivotXyz(Y);
  Z = PivotXyz(Z);
  const l = 116 * Y - 16;
  const a = 500 * (X - Y);
  const b = 200 * (Y - Z);
  return { l, a, b };
}
function LABtoRGB(l, a, b) {
  if (arguments.length == 1) {
    var { l, a, b } = arguments[0];
  }
  return XYZtoRGB(LABtoXYZ(l, a, b));
}
function RGBtoHSV(r, g, b) {
  if (arguments.length == 1) {
    var { r, g, b } = arguments[0];
  }
  const R1 = r / 255;
  const G1 = g / 255;
  const B1 = b / 255;
  const MaxC = Math.max(R1, G1, B1);
  const MinC = Math.min(R1, G1, B1);
  const DeltaC = MaxC - MinC;
  var H = 0;
  if (DeltaC == 0) {
    H = 0;
  } else if (MaxC == R1) {
    H = 60 * ((G1 - B1) / DeltaC % 6);
  } else if (MaxC == G1) {
    H = 60 * ((B1 - R1) / DeltaC + 2);
  } else if (MaxC == B1) {
    H = 60 * ((R1 - G1) / DeltaC + 4);
  }
  if (H < 0) {
    H = 360 + H;
  }
  var S = 0;
  if (MaxC == 0)
    S = 0;
  else
    S = DeltaC / MaxC;
  var V = MaxC;
  return { h: H, s: S, v: V };
}
function RGBtoCMYK(r, g, b) {
  if (arguments.length == 1) {
    var { r, g, b } = arguments[0];
  }
  const R1 = r / 255;
  const G1 = g / 255;
  const B1 = b / 255;
  const K = 1 - Math.max(R1, G1, B1);
  const C = (1 - R1 - K) / (1 - K);
  const M = (1 - G1 - K) / (1 - K);
  const Y = (1 - B1 - K) / (1 - K);
  return { c: C, m: M, y: Y, k: K };
}
function RGBtoHSL(r, g, b) {
  if (arguments.length == 1) {
    var { r, g, b } = arguments[0];
  }
  r /= 255, g /= 255, b /= 255;
  var max = Math.max(r, g, b), min = Math.min(r, g, b);
  var h, s, l = (max + min) / 2;
  if (max == min) {
    h = s = 0;
  } else {
    var d = max - min;
    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
    switch (max) {
      case r:
        h = (g - b) / d + (g < b ? 6 : 0);
        break;
      case g:
        h = (b - r) / d + 2;
        break;
      case b:
        h = (r - g) / d + 4;
        break;
    }
    h /= 6;
  }
  return { h: round(h * 360), s: round(s * 100), l: round(l * 100) };
}
function c(r, g, b) {
  if (arguments.length == 1) {
    var { r, g, b } = arguments[0];
  }
  return gray((r + g + b) / 3 > 90 ? 0 : 255);
}
function gray(gray2) {
  return { r: gray2, g: gray2, b: gray2 };
}
function RGBtoSimpleGray(r, g, b) {
  if (arguments.length == 1) {
    var { r, g, b } = arguments[0];
  }
  return gray(Math.ceil((r + g + b) / 3));
}
function RGBtoGray(r, g, b) {
  if (arguments.length == 1) {
    var { r, g, b } = arguments[0];
  }
  return gray(RGBtoYCrCb(r, g, b).y);
}
function brightness(r, g, b) {
  return Math.ceil(r * 0.2126 + g * 0.7152 + b * 0.0722);
}
function RGBtoYCrCb(r, g, b) {
  if (arguments.length == 1) {
    var { r, g, b } = arguments[0];
  }
  const Y = brightness(r, g, b);
  const Cb = 0.564 * (b - Y);
  const Cr = 0.713 * (r - Y);
  return { y: Y, cr: Cr, cb: Cb };
}
function PivotRGB(n) {
  return (n > 0.04045 ? Math.pow((n + 0.055) / 1.055, 2.4) : n / 12.92) * 100;
}
function RGBtoXYZ(r, g, b) {
  if (arguments.length == 1) {
    var { r, g, b } = arguments[0];
  }
  let R = r / 255;
  let G = g / 255;
  let B = b / 255;
  R = PivotRGB(R);
  G = PivotRGB(G);
  B = PivotRGB(B);
  const x = R * 0.4124 + G * 0.3576 + B * 0.1805;
  const y = R * 0.2126 + G * 0.7152 + B * 0.0722;
  const z = R * 0.0193 + G * 0.1192 + B * 0.9505;
  return { x, y, z };
}
function RGBtoLAB(r, g, b) {
  if (arguments.length == 1) {
    var { r, g, b } = arguments[0];
  }
  return XYZtoLAB(RGBtoXYZ(r, g, b));
}
function HUEtoRGB(p, q, t) {
  if (t < 0)
    t += 1;
  if (t > 1)
    t -= 1;
  if (t < 1 / 6)
    return p + (q - p) * 6 * t;
  if (t < 1 / 2)
    return q;
  if (t < 2 / 3)
    return p + (q - p) * (2 / 3 - t) * 6;
  return p;
}
function HSLtoHSV(h, s, l) {
  if (arguments.length == 1) {
    var { h, s, l } = arguments[0];
  }
  const rgb2 = HSLtoRGB(h, s, l);
  return RGBtoHSV(rgb2.r, rgb2.g, rgb2.b);
}
function HSLtoRGB(h, s, l) {
  if (arguments.length == 1) {
    var { h, s, l } = arguments[0];
  }
  var r, g, b;
  h /= 360;
  s /= 100;
  l /= 100;
  if (s == 0) {
    r = g = b = l;
  } else {
    var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
    var p = 2 * l - q;
    r = HUEtoRGB(p, q, h + 1 / 3);
    g = HUEtoRGB(p, q, h);
    b = HUEtoRGB(p, q, h - 1 / 3);
  }
  return { r: round(r * 255), g: round(g * 255), b: round(b * 255) };
}
const color_regexp = /(#(?:[\da-f]{3}){1,2}|#(?:[\da-f]{8})|rgb\((?:\s*\d{1,3},\s*){2}\d{1,3}\s*\)|rgba\((?:\s*\d{1,3},\s*){3}\d*\.?\d+\s*\)|hsl\(\s*\d{1,3}(?:,\s*\d{1,3}%){2}\s*\)|hsla\(\s*\d{1,3}(?:,\s*\d{1,3}%){2},\s*\d*\.?\d+\s*\)|([\w_-]+))/gi;
function getColorIndexString(it, prefix = "@") {
  return `${prefix}${it.startIndex}`.padEnd(10, "0");
}
function isColor(str) {
  const results = matches(str);
  return !!results.length;
}
function matches(str) {
  const matches2 = str.match(color_regexp);
  let result = [];
  if (!matches2) {
    return result;
  }
  for (var i = 0, len2 = matches2.length; i < len2; i++) {
    if (matches2[i].indexOf("#") > -1 || matches2[i].indexOf("rgb") > -1 || matches2[i].indexOf("hsl") > -1) {
      result.push({ color: matches2[i] });
    } else {
      var nameColor = ColorNames.getColorByName(matches2[i]);
      if (nameColor) {
        result.push({ color: matches2[i], nameColor });
      }
    }
  }
  var pos = { next: 0 };
  result.forEach((item) => {
    const startIndex = str.indexOf(item.color, pos.next);
    item.startIndex = startIndex;
    item.endIndex = startIndex + item.color.length;
    pos.next = item.endIndex;
  });
  return result;
}
function convertMatches(str, prefix = "@") {
  const m = matches(str);
  m.forEach((it) => {
    str = str.replace(it.color, getColorIndexString(it, prefix));
  });
  return { str, matches: m };
}
function convertMatchesArray(str, splitStr = ",") {
  const ret = convertMatches(str);
  return ret.str.split(splitStr).map((it, index2) => {
    it = trim(it);
    if (ret.matches[index2]) {
      it = it.replace(getColorIndexString(ret.matches[index2]), ret.matches[index2].color);
    }
    return it;
  });
}
function reverseMatches(str, matches2) {
  matches2.forEach((it) => {
    str = str.replace(getColorIndexString(it), it.color);
  });
  return str;
}
const REG_TRIM = /^\s+|\s+$/g;
function trim(str) {
  return str.replace(REG_TRIM, "");
}
function parse(str) {
  if (isString(str)) {
    if (ColorNames.isColorName(str)) {
      str = ColorNames.getColorByName(str);
    }
    if (str.indexOf("rgb(") > -1) {
      var arr = str.replace("rgb(", "").replace(")", "").split(",");
      for (var i = 0, len2 = arr.length; i < len2; i++) {
        arr[i] = parseInt(trim(arr[i]), 10);
      }
      var obj2 = { type: "rgb", r: arr[0], g: arr[1], b: arr[2], a: 1 };
      obj2 = __spreadValues(__spreadValues({}, obj2), RGBtoHSL(obj2));
      return obj2;
    } else if (str.indexOf("rgba(") > -1) {
      var arr = str.replace("rgba(", "").replace(")", "").split(",");
      for (var i = 0, len2 = arr.length; i < len2; i++) {
        if (len2 - 1 == i) {
          arr[i] = parseFloat(trim(arr[i]));
        } else {
          arr[i] = parseInt(trim(arr[i]), 10);
        }
      }
      var obj2 = { type: "rgb", r: arr[0], g: arr[1], b: arr[2], a: arr[3] };
      obj2 = __spreadValues(__spreadValues({}, obj2), RGBtoHSL(obj2));
      return obj2;
    } else if (str.indexOf("hsl(") > -1) {
      var arr = str.replace("hsl(", "").replace(")", "").split(",");
      for (var i = 0, len2 = arr.length; i < len2; i++) {
        arr[i] = parseFloat(trim(arr[i]));
      }
      var obj2 = { type: "hsl", h: arr[0], s: arr[1], l: arr[2], a: 1 };
      obj2 = __spreadValues(__spreadValues({}, obj2), HSLtoRGB(obj2));
      return obj2;
    } else if (str.indexOf("hsla(") > -1) {
      var arr = str.replace("hsla(", "").replace(")", "").split(",");
      for (var i = 0, len2 = arr.length; i < len2; i++) {
        if (len2 - 1 == i) {
          arr[i] = parseFloat(trim(arr[i]));
        } else {
          arr[i] = parseInt(trim(arr[i]), 10);
        }
      }
      var obj2 = { type: "hsl", h: arr[0], s: arr[1], l: arr[2], a: arr[3] };
      obj2 = __spreadValues(__spreadValues({}, obj2), HSLtoRGB(obj2));
      return obj2;
    } else if (str.indexOf("#") == 0) {
      str = str.replace("#", "");
      var arr = [];
      var a = 1;
      if (str.length == 3) {
        for (var i = 0, len2 = str.length; i < len2; i++) {
          var char = str.substr(i, 1);
          arr.push(parseInt(char + char, 16));
        }
      } else if (str.length === 8) {
        for (var i = 0, len2 = str.length; i < len2; i += 2) {
          arr.push(parseInt(str.substr(i, 2), 16));
        }
        a = arr.pop() / 255;
      } else {
        for (var i = 0, len2 = str.length; i < len2; i += 2) {
          arr.push(parseInt(str.substr(i, 2), 16));
        }
      }
      var obj2 = { type: "hex", r: arr[0], g: arr[1], b: arr[2], a };
      obj2 = __spreadValues(__spreadValues({}, obj2), RGBtoHSL(obj2));
      return obj2;
    }
  } else if (isNumber(str)) {
    if (0 <= str && str <= 16777215) {
      const r = (str & 16711680) >> 16;
      const g = (str & 65280) >> 8;
      const b = (str & 255) >> 0;
      var obj2 = { type: "hex", r, g, b, a: 1 };
      obj2 = __spreadValues(__spreadValues({}, obj2), RGBtoHSL(obj2));
      return obj2;
    } else if (0 <= str && str <= 4294967295) {
      const r = (str & 4278190080) >> 24;
      const g = (str & 16711680) >> 16;
      const b = (str & 65280) >> 8;
      const a2 = (str & 255) / 255;
      var obj2 = { type: "hex", r, g, b, a: a2 };
      obj2 = __spreadValues(__spreadValues({}, obj2), RGBtoHSL(obj2));
      return obj2;
    }
  }
  return str;
}
function parseGradient(colors2) {
  if (isString(colors2)) {
    colors2 = convertMatchesArray(colors2);
  }
  colors2 = colors2.map((it) => {
    if (isString(it)) {
      const ret = convertMatches(it);
      let arr = trim(ret.str).split(" ");
      if (arr[1]) {
        if (arr[1].indexOf("%") > -1) {
          arr[1] = parseFloat(arr[1].replace(/%/, "")) / 100;
        } else {
          arr[1] = parseFloat(arr[1]);
        }
      } else {
        arr[1] = "*";
      }
      arr[0] = reverseMatches(arr[0], ret.matches);
      return arr;
    } else if (Array.isArray(it)) {
      if (!it[1]) {
        it[1] = "*";
      } else if (isString(it[1])) {
        if (it[1].indexOf("%") > -1) {
          it[1] = parseFloat(it[1].replace(/%/, "")) / 100;
        } else {
          it[1] = +it[1];
        }
      }
      return [...it];
    }
  });
  const count = colors2.filter((it) => {
    return it[1] === "*";
  }).length;
  if (count > 0) {
    const sum = colors2.filter((it) => {
      return it[1] != "*" && it[1] != 1;
    }).map((it) => it[1]).reduce((total, cur) => {
      return total + cur;
    }, 0);
    const dist2 = (1 - sum) / count;
    colors2.forEach((it, index2) => {
      if (it[1] == "*" && index2 > 0) {
        if (colors2.length - 1 == index2)
          ;
        else {
          it[1] = dist2;
        }
      }
    });
  }
  return colors2;
}
const identity$2 = () => true;
function _traverse(obj2, filterCallback = identity$2) {
  var results = [];
  let len2 = obj2.layers.length;
  for (let start2 = len2; start2--; ) {
    let it = obj2.layers[start2];
    results.push(..._traverse(it.ref, filterCallback));
  }
  if (filterCallback(obj2)) {
    results.push(obj2);
  }
  return results;
}
class Item {
  constructor(json = {}) {
    this.ref = new Proxy(this, {
      get: (target, key) => {
        var originMethod = target[key];
        if (isFunction(originMethod)) {
          return (...args2) => {
            return originMethod.apply(target, args2);
          };
        } else {
          return originMethod || target.json[key];
        }
      },
      set: (target, key, value) => {
        const isDiff = target.json[key] != value;
        if (isDiff) {
          target.json[key] = value;
          this.changed();
        }
        return true;
      }
    });
    if (json instanceof Item) {
      json = json.toJSON();
    }
    this.json = this.convert(Object.assign(this.getDefaultObject(), json));
    this.lastChangedField = {};
    this.lastChangedFieldKeys = [];
    this.cachedValue = {};
    return this.ref;
  }
  getDefaultTitle() {
    return "Item";
  }
  getIcon() {
    return "";
  }
  isAttribute() {
    return false;
  }
  isChanged(timestamp) {
    return this.json.timestamp != Number(timestamp);
  }
  changed() {
    this.json.timestamp = this.json._timestamp + window.performance.now();
  }
  get title() {
    return this.json.name || this.getDefaultTitle();
  }
  renameWithCount() {
    let arr = this.json.name.split(" ");
    if (arr.length < 2) {
      return;
    }
    let last = arr.pop();
    let lastNumber = +last;
    if (isNumber(lastNumber) && isNaN(lastNumber) === false) {
      lastNumber++;
    } else {
      lastNumber = last;
    }
    const nextName = [...arr, lastNumber].join(" ");
    this.reset({
      name: nextName
    });
  }
  get allLayers() {
    return _traverse(this.ref);
  }
  filteredAllLayers(filterCallback) {
    return _traverse(this.ref, filterCallback);
  }
  get id() {
    return this.json.id;
  }
  get layers() {
    return this.json.layers;
  }
  get parent() {
    return this.json.parent;
  }
  setParent(otherParent) {
    this.json.parent = otherParent;
  }
  get depth() {
    if (!this.parent)
      return 1;
    return this.parent.depth + 1;
  }
  get top() {
    if (!this.parent)
      return this.ref;
    let localParent = this.parent;
    do {
      if (!localParent.parent) {
        return localParent;
      }
      localParent = localParent.parent;
    } while (localParent);
  }
  get project() {
    return this.path.find((it) => it.is("project"));
  }
  get artboard() {
    return this.path.find((it) => it.is("artboard"));
  }
  get path() {
    if (!this.parent)
      return [this.ref];
    const list2 = this.parent.path;
    list2.push(this.ref);
    return list2;
  }
  getInnerId(postfix = "") {
    return this.json.id + postfix;
  }
  is(checkItemType) {
    if (!this.json)
      return false;
    return checkItemType === this.json.itemType;
  }
  isNot(checkItemType) {
    return this.is(checkItemType) === false;
  }
  isSVG() {
    return false;
  }
  addCache(key, value) {
    this.cachedValue[key] = value;
  }
  getCache(key) {
    return this.cachedValue[key];
  }
  computed(key, newValueCallback) {
    const cachedKey = `__cachedKey_${key}`;
    const parsedKey = `${cachedKey}__parseValue`;
    const value = this.json[key];
    if (this.getCache(key) === value && this.getCache(parsedKey)) {
      return this.getCache(parsedKey);
    }
    this.addCache(key, value);
    this.addCache(parsedKey, newValueCallback(value, this.ref));
    return this.getCache(parsedKey);
  }
  editable() {
    return true;
  }
  generateListNumber() {
    this.layers.forEach((it, index2) => {
      it.no = index2;
      it.generateListNumber();
    });
  }
  convert(json) {
    if (json.layers) {
      json.layers.forEach((layer) => {
        layer.parent = this.ref;
      });
    }
    return json;
  }
  setCache() {
  }
  toCloneObject(isDeep = true) {
    var json = this.attrs("itemType", "name", "elementType", "type", "visible", "lock", "selected");
    if (isDeep) {
      json.layers = this.json.layers.map((layer) => layer.clone(isDeep));
    }
    return json;
  }
  clone(isDeep = true) {
    var ItemClass = this.constructor;
    var item = new ItemClass(this.toCloneObject(isDeep));
    item.setParent(this.json.parent);
    return item;
  }
  reset(obj2) {
    if (!obj2.__changedId)
      obj2.__changedId = uuid();
    if (this.lastChangedField.__changedId !== obj2.__changedId) {
      this.json = this.convert(Object.assign(this.json, obj2));
      this.lastChangedField = obj2;
      this.lastChangedFieldKeys = Object.keys(obj2);
      this.changed();
    }
    return true;
  }
  hasChangedField(...args2) {
    return args2.some((it) => this.lastChangedFieldKeys.includes(it));
  }
  getDefaultObject(obj2 = {}) {
    var id = uuidShort();
    return __spreadValues({
      id,
      _timestamp: Date.now(),
      _time: window.performance.now(),
      visible: true,
      lock: false,
      selected: false,
      layers: []
    }, obj2);
  }
  attrs(...args2) {
    const result = {};
    args2.forEach((field) => {
      result[field] = clone$1(this.json[field]);
    });
    return result;
  }
  hasChildren() {
    return this.layers.length > 0;
  }
  appendChild(layer) {
    if (layer.parent === this.ref) {
      return layer;
    }
    this.resetMatrix(layer);
    if (layer.parent) {
      layer.remove();
    }
    layer.setParent(this.ref);
    this.json.layers.push(layer);
    this.project.addIndexItem(layer);
    return layer;
  }
  prependChildItem(layer) {
    this.resetMatrix(layer);
    if (layer.parent) {
      layer.remove();
    }
    layer.setParent(this.ref);
    this.json.layers.unshift(layer);
    this.project.addIndexItem(layer);
    return layer;
  }
  resetMatrix() {
  }
  refreshMatrixCache() {
  }
  insertChild(layer, index2 = 0) {
    this.resetMatrix(layer);
    if (layer.parent) {
      layer.remove();
    }
    layer.setParent(this.ref);
    this.json.layers.splice(index2, 0, layer);
    this.project.addIndexItem(layer);
    return layer;
  }
  insertAfter(layer) {
    const index2 = this.parent.findIndex(this);
    this.parent.insertChild(layer, index2);
    this.project.addIndexItem(layer);
    return layer;
  }
  insertBefore(layer) {
    const index2 = this.parent.findIndex(this);
    this.parent.insertChild(layer, index2 - 1);
    this.project.addIndexItem(layer);
    return layer;
  }
  setPositionInPlace(position2, item) {
    this.layers.splice(position2, 0, item);
  }
  toggle(field, toggleValue) {
    if (isUndefined(toggleValue)) {
      this.json[field] = !this.json[field];
    } else {
      this.json[field] = !!toggleValue;
    }
  }
  isTreeItemHide() {
    let currentParent = this.parent;
    let collapsedList = [];
    do {
      if (currentParent.is("project"))
        break;
      collapsedList.push(Boolean(currentParent.collapsed));
      currentParent = currentParent.parent;
    } while (currentParent);
    return Boolean(collapsedList.filter(Boolean).length);
  }
  expectJSON(key) {
    if (key === "parent")
      return false;
    if (isUndefined(this.json[key]))
      return false;
    return true;
  }
  toJSON() {
    const json = this.json;
    let newJSON = {};
    Object.keys(json).filter((key) => this.expectJSON(key)).forEach((key) => {
      newJSON[key] = json[key];
    });
    return newJSON;
  }
  resize() {
  }
  copy(dist2 = 0) {
    return this.json.parent.copyItem(this.ref, dist2);
  }
  findIndex(item) {
    return this.json.layers.indexOf(item.ref);
  }
  copyItem(childItem, dist2 = 10) {
    var child = childItem.clone();
    child.renameWithCount();
    child.move([dist2, dist2, 0]);
    var childIndex = this.findIndex(childItem);
    if (childIndex > -1) {
      this.json.layers.push(child);
      this.project.addIndexItem(child);
    }
    return child;
  }
  remove() {
    this.json.parent.removeChild(this.ref);
    this.project.removeIndexItem(this.ref);
  }
  removeChild(childItem) {
    const index2 = this.findIndex(childItem);
    if (index2 > -1) {
      this.json.layers.splice(index2, 1);
    }
  }
  hasParent(parentId) {
    var isParent = this.json.parent.id === parentId;
    if (!isParent && this.json.parent.is("project") === false)
      return this.json.parent.hasParent(parentId);
    return isParent;
  }
}
const MAX_CACHE_COUNT$2 = 1e3;
const cachedTransformOriginMap = /* @__PURE__ */ new Map();
class TransformOriginCache {
  static has(key) {
    return cachedTransformOriginMap.has(key);
  }
  static get(key) {
    return cachedTransformOriginMap.get(key);
  }
  static set(key, parsedValue) {
    if (cachedTransformOriginMap.size > MAX_CACHE_COUNT$2) {
      cachedTransformOriginMap.clear();
    }
    cachedTransformOriginMap.set(key, parsedValue);
  }
}
class TransformOrigin {
  static parseStyle(transformOrigin = "50% 50% 0px") {
    if (TransformOriginCache.has(transformOrigin)) {
      return TransformOriginCache.get(transformOrigin);
    }
    const origins = transformOrigin.trim().split(" ").filter((it) => it.trim());
    let parsedTransformOrigin = null;
    if (origins.length === 1) {
      parsedTransformOrigin = [origins[0], origins[0]].map((it) => Length.parse(it));
    } else {
      parsedTransformOrigin = origins.map((it) => Length.parse(it));
    }
    TransformOriginCache.set(transformOrigin, parsedTransformOrigin);
    return parsedTransformOrigin;
  }
  static scale(transformOrigin, width2, height2) {
    let parsedTransformOrigin = TransformOrigin.parseStyle(transformOrigin);
    if (width2 === 0 && height2 === 0) {
      return [0, 0, 0];
    }
    const originX = parsedTransformOrigin[0].toPx(width2).value;
    const originY = parsedTransformOrigin[1].toPx(height2).value;
    const originZ = parsedTransformOrigin[2].value;
    return [originX, originY, originZ];
  }
  static toPx(transformOrigin, width2, height2, distance2 = 0) {
    let [transformOriginX, transformOriginY, transformOriginZ] = TransformOrigin.parseStyle(transformOrigin);
    transformOriginX = transformOriginX.toPx(width2);
    transformOriginY = transformOriginY.toPx(height2);
    transformOriginZ = transformOriginZ.toPx(distance2);
    return `${transformOriginX} ${transformOriginY} ${transformOriginZ}`;
  }
}
function rectRect(rx1, ry1, rw1, rh1, rx2, ry2, rw2, rh2) {
  return rx1 + rw1 >= rx2 && rx1 <= rx2 + rw2 && ry1 + rh1 >= ry2 && ry1 <= ry2 + rh2;
}
class Rect {
  constructor(x, y, width2, height2) {
    this.x = x;
    this.y = y;
    this.width = width2;
    this.height = height2;
  }
  get left() {
    return this.x;
  }
  get right() {
    return this.x + this.width;
  }
  get top() {
    return this.y;
  }
  get bottom() {
    return this.y + this.height;
  }
  get centerX() {
    return this.x + this.width / 2;
  }
  get centerY() {
    return this.y + this.height / 2;
  }
  get center() {
    return [this.centerX, this.centerY];
  }
  get topLeft() {
    return [this.left, this.top];
  }
  get topRight() {
    return [this.right, this.top];
  }
  get bottomLeft() {
    return [this.left, this.bottom];
  }
  get bottomRight() {
    return [this.right, this.bottom];
  }
  get vertices() {
    return [this.topLeft, this.topRight, this.bottomLeft, this.bottomRight];
  }
  intersect(rect2) {
    return intersectRectRect(this, rect2);
  }
}
function intersectRectRect(rect1, rect2) {
  const minRectX = Math.min(rect1.x, rect2.x);
  const minRectY = Math.min(rect1.y, rect2.y);
  const rect1Verties = rectToVerties(rect1.x - minRectX, rect1.y - minRectY, rect1.width, rect1.height);
  const rect2Verties = rectToVerties(rect2.x - minRectX, rect2.y - minRectY, rect2.width, rect2.height);
  const startPoint = [
    Math.max(rect1Verties[0][0], rect2Verties[0][0]),
    Math.max(rect1Verties[0][1], rect2Verties[0][1]),
    Math.max(rect1Verties[0][2], rect2Verties[0][2])
  ];
  const endPoint = [
    Math.min(rect1Verties[2][0], rect2Verties[2][0]),
    Math.min(rect1Verties[2][1], rect2Verties[2][1]),
    Math.min(rect1Verties[2][2], rect2Verties[2][2])
  ];
  const minX = Math.min(startPoint[0], endPoint[0]);
  const minY = Math.min(startPoint[1], endPoint[1]);
  const maxX = Math.max(startPoint[0], endPoint[0]);
  const maxY = Math.max(startPoint[1], endPoint[1]);
  return new Rect(minX + minRectX, minY + minRectY, maxX - minX, maxY - minY);
}
function linePoint(x1, y1, x2, y2, px2, py2, buffer = 0.1) {
  const dist1 = Math.hypot(px2 - x1, py2 - y1);
  const dist2 = Math.hypot(px2 - x2, py2 - y2);
  const lineLength = Math.hypot(x1 - x2, y1 - y2);
  const calcDist = dist1 + dist2;
  return calcDist >= lineLength - buffer && calcDist <= lineLength + buffer;
}
function lineLineWithoutPoint(x1, y1, x2, y2, x3, y3, x4, y4) {
  let A = ((x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3)) / ((y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1));
  let B = ((x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3)) / ((y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1));
  return 0 <= A && A <= 1 && 0 <= B && B <= 1;
}
function lineLine(x1, y1, x2, y2, x3, y3, x4, y4, epsilon = 0.1) {
  if (linePoint(x1, y1, x2, y2, x3, y3))
    return true;
  else if (linePoint(x1, y1, x2, y2, x4, y4))
    return true;
  else if (linePoint(x3, y3, x4, y4, x1, y1))
    return [x1, y1];
  else if (linePoint(x3, y3, x4, y4, x2, y2))
    return [x2, y2];
  return lineLineWithoutPoint(x1, y1, x2, y2, x3, y3, x4, y4);
}
function polyPoint(verties = [], px2, py2, withoutPoint = false) {
  let isCollision = false;
  const len2 = verties.length;
  if (withoutPoint === false) {
    for (let i = 0; i < len2; i++) {
      const v1 = verties[i];
      const v2 = verties[(i + 1) % len2];
      if (linePoint(v1[0], v1[1], v2[0], v2[1], px2, py2)) {
        isCollision = true;
        break;
      }
    }
  }
  if (isCollision)
    return true;
  verties.forEach((vector, index2) => {
    const [cx, cy] = vector;
    const [nx, ny] = verties[(index2 + 1) % len2];
    if ((cy >= py2 && ny < py2 || cy < py2 && ny >= py2) && px2 < (nx - cx) * (py2 - cy) / (ny - cy) + cx) {
      isCollision = !isCollision;
    }
  });
  return isCollision;
}
function polyLine(verties = [], x1, y1, x2, y2, withoutPoint = false) {
  const len2 = verties.length;
  return verties.some((vector, index2) => {
    const [x3, y3] = vector;
    const [x4, y4] = verties[(index2 + 1) % len2];
    if (withoutPoint) {
      return lineLineWithoutPoint(x1, y1, x2, y2, x3, y3, x4, y4);
    } else {
      return lineLine(x1, y1, x2, y2, x3, y3, x4, y4);
    }
  });
}
function polyPoly(verties = [], targetVerties = [], withoutPoint = false) {
  const len2 = verties.length;
  return verties.some((vector, index2) => {
    const [x1, y1] = vector;
    const [x2, y2] = verties[(index2 + 1) % len2];
    let collision = polyLine(targetVerties, x1, y1, x2, y2, withoutPoint);
    if (collision)
      return true;
    collision = polyPoint(verties, targetVerties[0][0], targetVerties[0][1], withoutPoint);
    if (collision)
      return true;
    return false;
  });
}
function rectToVerties(x, y, width2, height2, origin = "50% 50% 0px") {
  const center2 = TransformOrigin.scale(origin, width2, height2);
  return [
    [x, y, 0],
    [x + width2, y, 0],
    [x + width2, y + height2, 0],
    [x, y + height2, 0],
    [x + center2[0], y + center2[1], 0]
  ];
}
function getRotatePointer(verties, dist2 = 0) {
  const topPointer = lerp$1([], verties[0], verties[1], 0.5);
  const bottomPointer = lerp$1([], verties[2], verties[3], 0.5);
  const rotatePointer = getPointBetweenVerties(bottomPointer, topPointer, dist2);
  return rotatePointer;
}
function rectToVertiesForArea(x, y, width2, height2) {
  return rectToVerties(x, y, width2, height2);
}
function itemsToRectVerties(items = []) {
  let minX = Number.MAX_SAFE_INTEGER;
  let minY = Number.MAX_SAFE_INTEGER;
  let maxX = Number.MIN_SAFE_INTEGER;
  let maxY = Number.MIN_SAFE_INTEGER;
  const xList = [];
  const yList = [];
  items.forEach((item) => {
    item.originVerties.forEach((vector) => {
      xList.push(vector[0]);
      yList.push(vector[1]);
    });
  });
  minX = Math.min.apply(Math, xList);
  maxX = Math.max.apply(Math, xList);
  minY = Math.min.apply(Math, yList);
  maxY = Math.max.apply(Math, yList);
  if (minX === Number.MAX_SAFE_INTEGER)
    minX = 0;
  if (minY === Number.MAX_SAFE_INTEGER)
    minY = 0;
  if (maxX === Number.MIN_SAFE_INTEGER)
    maxX = 0;
  if (maxY === Number.MIN_SAFE_INTEGER)
    maxY = 0;
  return rectToVerties(minX, minY, maxX - minX, maxY - minY);
}
function targetItemsToRectVerties(items = []) {
  let minX = Number.MAX_SAFE_INTEGER;
  let minY = Number.MAX_SAFE_INTEGER;
  let maxX = Number.MIN_SAFE_INTEGER;
  let maxY = Number.MIN_SAFE_INTEGER;
  const xList = [];
  const yList = [];
  items.forEach((item) => {
    item.targetVerties.forEach((vector) => {
      xList.push(vector[0]);
      yList.push(vector[1]);
    });
  });
  minX = Math.min.apply(Math, xList);
  maxX = Math.max.apply(Math, xList);
  minY = Math.min.apply(Math, yList);
  maxY = Math.max.apply(Math, yList);
  if (minX === Number.MAX_SAFE_INTEGER)
    minX = 0;
  if (minY === Number.MAX_SAFE_INTEGER)
    minY = 0;
  if (maxX === Number.MIN_SAFE_INTEGER)
    maxX = 0;
  if (maxY === Number.MIN_SAFE_INTEGER)
    maxY = 0;
  return rectToVerties(minX, minY, maxX - minX, maxY - minY);
}
function vertiesToRectangle(verties) {
  const x = verties[0][0];
  const y = verties[0][1];
  const width2 = dist(verties[0], verties[1]);
  const height2 = dist(verties[0], verties[3]);
  return new Rect(x, y, width2, height2);
}
function vertiesToPath(verties = []) {
  const results = [];
  for (var i = 0; i < verties.length; i++) {
    if (i === 0) {
      results.push(`M ${verties[i][0]} ${verties[i][1]}`);
    } else {
      results.push(`L ${verties[i][0]} ${verties[i][1]}`);
    }
  }
  if (results.length) {
    results.push("Z");
  }
  return results.join(" ");
}
function toRectVertiesWithoutTransformOrigin(verties) {
  return toRectVerties(verties).filter((it, index2) => {
    return index2 < 4;
  });
}
function toRectVerties(verties) {
  let minX = Number.MAX_SAFE_INTEGER;
  let minY = Number.MAX_SAFE_INTEGER;
  let maxX = Number.MIN_SAFE_INTEGER;
  let maxY = Number.MIN_SAFE_INTEGER;
  const xList = [];
  const yList = [];
  verties.forEach((vector) => {
    xList.push(vector[0]);
    yList.push(vector[1]);
  });
  minX = Math.min.apply(Math, xList);
  maxX = Math.max.apply(Math, xList);
  minY = Math.min.apply(Math, yList);
  maxY = Math.max.apply(Math, yList);
  if (minX === Number.MAX_SAFE_INTEGER)
    minX = 0;
  if (minY === Number.MAX_SAFE_INTEGER)
    minY = 0;
  if (maxX === Number.MIN_SAFE_INTEGER)
    maxX = 0;
  if (maxY === Number.MIN_SAFE_INTEGER)
    maxY = 0;
  return rectToVerties(minX, minY, maxX - minX, maxY - minY);
}
const predefinedBezier = {
  linear: true,
  ease: true,
  "ease-in": true,
  "ease-out": true,
  "ease-in-out": true
};
const bezierObj = {
  ease: "cubic-bezier(0.25, 0.1, 0.25, 1)",
  "ease-in": "cubic-bezier(0.42, 0, 1, 1)",
  "ease-out": "cubic-bezier(0, 0, 0.58, 1)"
};
const bezierList = [
  [0, 0, 1, 1, "linear", true],
  [0.25, 0.1, 0.25, 1, "ease", true],
  [0.42, 0, 1, 1, "ease-in", true],
  [0, 0, 0.58, 1, "ease-out", true],
  [0.47, 0, 0.745, 0.715, "ease-in-sine"],
  [0.39, 0.575, 0.565, 1, "ease-out-sine"],
  [0.445, 0.05, 0.55, 0.95, "ease-in-out-sine"],
  [0.55, 0.085, 0.68, 0.53, "ease-in-quad"],
  [0.25, 0.46, 0.45, 0.94, "ease-out-quad"],
  [0.455, 0.03, 0.515, 0.955, "ease-in-out-quad"],
  [0.55, 0.055, 0.675, 0.19, "ease-in-cubic"],
  [0.215, 0.61, 0.355, 1, "ease-out-cubic"],
  [0.645, 0.045, 0.355, 1, "ease-in-out-cubic"],
  [0.895, 0.03, 0.685, 0.22, "ease-in-quart"],
  [0.165, 0.84, 0.44, 1, "ease-out-quart"],
  [0.77, 0, 0.175, 1, "ease-in-out-quart"],
  [0.6, 0.04, 0.98, 0.335, "ease-in-circ"],
  [0.075, 0.82, 0.165, 1, "ease-out-circ"],
  [0.785, 0.135, 0.15, 0.86, "ease-in-out-circ"],
  [0.95, 0.05, 0.795, 0.035, "ease-in-expo"],
  [0.19, 1, 0.22, 1, "ease-out-expo"],
  [1, 0, 0, 1, "ease-in-out-expo"],
  [0.755, 0.05, 0.855, 0.06, "ease-in-quint"],
  [0.23, 1, 0.32, 1, "ease-out-quint"],
  [0.86, 0, 0.07, 1, "ease-in-out-quint"],
  [0.6, -0.28, 0.735, 0.045, "ease-in-back"],
  [0.175, 0.885, 0.32, 1.275, "ease-out-back"],
  [0.68, -0.55, 0.265, 1.55, "ease-in-out-back"]
];
const getPredefinedCubicBezier = (str) => {
  return [...parseCubicBezier(bezierObj[str] || str)];
};
const formatCubicBezier = (arr) => {
  arr = arr.map((it) => Math.floor(it * 100) / 100);
  for (var i = 0, len2 = bezierList.length; i < len2; i++) {
    var bezier = bezierList[i];
    if (bezier[0] == arr[0] && bezier[1] == arr[1] && bezier[2] == arr[2] && bezier[3] == arr[3] && bezier[5]) {
      return bezier[4];
    }
  }
  return `cubic-bezier( ${arr.filter((_, index2) => index2 < 4).join(",")} )`;
};
function parseCubicBezier(str) {
  if (typeof str == "string") {
    if (predefinedBezier[str]) {
      return bezierList.filter((it) => it[4] === str)[0];
    } else {
      var arr = str.replace("cubic-bezier", "").replace("(", "").replace(")", "").split(",");
      arr = arr.map((it) => parseFloat(it.trim()));
      return arr;
    }
  }
  return str;
}
const createBezier = (C1, C2, C3, C4) => {
  var points = [C1, C2, C3, C4];
  return function(t) {
    return getBezierPointOne(points, t);
  };
};
const createBezierQuard = (C1, C2, C3) => {
  var points = [C1, C2, C3];
  return function(t) {
    return getBezierPointOneQuard(points, t);
  };
};
const createBezierLine = (C1, C2) => {
  var points = [C1, C2];
  return function(t) {
    return getBezierPointOneLine(points, t);
  };
};
const checkDist = (obj2, curve, t, x, y) => {
  var p = curve(t);
  var dist2 = getDist(x, y, p.x, p.y);
  if (dist2 < obj2.minDist) {
    obj2.minDist = dist2;
    obj2.minT = t;
  }
};
const getPolygonalDist = (points = []) => {
  let total = 0;
  points.forEach((point2, index2) => {
    var next = points[index2 + 1];
    if (!next) {
      return;
    }
    var dist$1 = dist(fromValues(point2.x, point2.y, 0), fromValues(next.x, next.y, 0));
    total += dist$1;
  });
  return total;
};
const getCurveDist = (sx, sy, cx1, cy1, cx2, cy2, ex, ey, count = 1e3) => {
  var curve = createBezier({ x: sx, y: sy }, { x: cx1, y: cy1 }, { x: cx2, y: cy2 }, { x: ex, y: ey });
  var total = 0;
  var startPoint = curve(0);
  for (var i = 0; i <= count; i++) {
    var t = i / count;
    var xy2 = curve(t);
    total += getDist(startPoint.x, startPoint.y, xy2.x, xy2.y);
    startPoint = xy2;
  }
  return total;
};
const getQuardDist = (sx, sy, cx1, cy1, ex, ey, count = 1e3) => {
  var curve = createBezierQuard({ x: sx, y: sy }, { x: cx1, y: cy1 }, { x: ex, y: ey });
  var total = 0;
  var startPoint = curve(0);
  for (var i = 0; i <= count; i++) {
    var t = i / count;
    var xy2 = curve(t);
    total += getDist(startPoint.x, startPoint.y, xy2.x, xy2.y);
    startPoint = xy2;
  }
  return total;
};
const makeCurveFunction = (curve, count = 10) => {
  var obj2 = {
    minDist: Infinity,
    minT: 0
  };
  return function(x, y) {
    for (var i = 0; i <= count; i++) {
      checkDist(obj2, curve, i / count, x, y);
    }
    var step2 = 1 / (count * 2);
    var t = obj2.minT;
    for (var i = 0; i < count; i++) {
      checkDist(obj2, curve, Math.max(0, t - step2), x, y);
      checkDist(obj2, curve, Math.min(1, t + step2), x, y);
      step2 /= 2;
    }
    return obj2.minT;
  };
};
const recoverBezier = (C1, C2, C3, C4, count = 20) => {
  return makeCurveFunction(createBezier(C1, C2, C3, C4), count);
};
const recoverBezierQuard = (C1, C2, C3, count = 20) => {
  return makeCurveFunction(createBezierQuard(C1, C2, C3), count);
};
const recoverBezierLine = (C1, C2, count = 20) => {
  return makeCurveFunction(createBezierLine(C1, C2), count);
};
const createBezierForPattern = (bezierString) => {
  if (bezierString === "linear") {
    var C1 = { x: 0, y: 0 };
    var C2 = { x: 1, y: 1 };
    return createBezierLine(C1, C2);
  }
  var bezierList2 = parseCubicBezier(bezierString);
  var C1 = { x: 0, y: 0 };
  var C2 = { x: bezierList2[0], y: bezierList2[1] };
  var C3 = { x: bezierList2[2], y: bezierList2[3] };
  var C4 = { x: 1, y: 1 };
  return createBezier(C1, C2, C3, C4);
};
const interpolate = (p1, p2, t) => {
  return {
    x: p1.x + (p2.x - p1.x) * t,
    y: p1.y + (p2.y - p1.y) * t
  };
};
const getBezierPointOne = (points, t) => {
  var p0 = interpolate(points[0], points[1], t);
  var p1 = interpolate(points[1], points[2], t);
  var p2 = interpolate(points[2], points[3], t);
  var p3 = interpolate(p0, p1, t);
  var p4 = interpolate(p1, p2, t);
  return interpolate(p3, p4, t);
};
const getBezierPointOneQuard = (points, t) => {
  var p0 = interpolate(points[0], points[1], t);
  var p1 = interpolate(points[1], points[2], t);
  return interpolate(p0, p1, t);
};
const getBezierPointOneLine = (points, t) => {
  return interpolate(points[0], points[1], t);
};
const getBezierPoints = (points, t) => {
  var p0 = interpolate(points[0], points[1], t);
  var p1 = interpolate(points[1], points[2], t);
  var p2 = interpolate(points[2], points[3], t);
  var p3 = interpolate(p0, p1, t);
  var p4 = interpolate(p1, p2, t);
  var p5 = interpolate(p3, p4, t);
  return {
    first: [points[0], p0, p3, p5],
    second: [p5, p4, p2, points[3]]
  };
};
const getBezierPointsQuard = (points, t) => {
  var p0 = interpolate(points[0], points[1], t);
  var p1 = interpolate(points[1], points[2], t);
  var p2 = interpolate(p0, p1, t);
  return {
    first: [points[0], p0, p2],
    second: [p2, p1, points[2]]
  };
};
const splitBezierPointsByCount = (points, count = 1) => {
  var result = [];
  while (count > 0) {
    const curve = getBezierPoints(points, 1 / count);
    result.push(curve.first);
    points = curve.second;
    count--;
  }
  return result;
};
const splitBezierPointsQuardByCount = (points, count = 1) => {
  var result = [];
  while (count > 0) {
    const curve = getBezierPointsQuard(points, 1 / count);
    result.push(curve.first);
    points = curve.second;
    count--;
  }
  return result;
};
const splitBezierPointsLineByCount = (points, count = 1) => {
  var result = [];
  const unit = 1 / count;
  while (count > 0) {
    const curve = getBezierPointsLine(points, unit);
    result.push(curve.first);
    points = curve.second;
    count--;
  }
  return result;
};
const getBezierPointsLine = (points, t) => {
  var p0 = interpolate(points[0], points[1], t);
  return {
    first: [points[0], p0],
    second: [p0, points[1]]
  };
};
const normalizeCurveForLine = (points) => {
  return [
    clone(points[0]),
    [
      points[0][0] + (points[1][0] - points[0][0]) * 0.33,
      points[0][1] + (points[1][1] - points[0][1]) * 0.33,
      0
    ],
    [
      points[0][0] + (points[1][0] - points[0][0]) * 0.66,
      points[0][1] + (points[1][1] - points[0][1]) * 0.66,
      0
    ],
    clone(points[1])
  ];
};
const normalizeCurveForQuard = (points) => {
  const twoOfThree = 2 / 3;
  return [
    clone(points[0]),
    fromValues(points[0][0] + twoOfThree * (points[1][0] - points[0][0]), points[0][1] + twoOfThree * (points[1][1] - points[0][1]), 0),
    fromValues(points[2][0] + twoOfThree * (points[1][0] - points[2][0]), points[2][1] + twoOfThree * (points[1][1] - points[2][1]), 0),
    clone(points[2])
  ];
};
const polygonalForCurve = (c1, c2, c3, c4, count = 1e3) => {
  const totalLength = getCurveDist(c1[0], c1[1], c2[0], c2[1], c3[0], c3[1], c4[0], c4[1], count);
  let samplingCount = 10;
  let samplingStep = totalLength / samplingCount;
  let lastLength = 0;
  let points = [];
  const bezierPoints = [c1, c2, c3, c4].map((point2) => ({
    x: point2[0],
    y: point2[1]
  }));
  do {
    points = [];
    let currentLength = 0;
    for (let i = 0; i <= samplingCount; i++) {
      const nextPoint = getBezierPointOne(bezierPoints, currentLength / totalLength);
      points.push(nextPoint);
      currentLength += samplingStep;
    }
    lastLength = getPolygonalDist(points);
    samplingCount += samplingCount * (totalLength - lastLength) / totalLength;
    samplingStep = totalLength / samplingCount;
  } while (totalLength - lastLength > 0.25);
  return points.map((point2) => fromValues(point2.x, point2.y, 0));
};
const calculateA = (points) => {
  const a1 = negate([], points[0]);
  const a2 = multiply([], [3, 3, 3], points[1]);
  const a3 = multiply([], [-3, -3, -3], points[2]);
  const a4 = points[3];
  const newP = add$1([], add$1([], a1, a2), add$1([], a3, a4));
  return multiply([], [3, 3, 3], newP);
};
const calculateB = (points) => {
  const b1 = points[0];
  const b2 = multiply([], [-2, -2, -2], points[1]);
  const b3 = points[2];
  const newP = add$1([], add$1([], b1, b2), b3);
  return multiply([], [6, 6, 6], newP);
};
const calculateC = (points) => {
  const newP = add$1([], points[1], negate([], points[0]));
  return multiply([], [3, 3, 3], newP);
};
const findRootForCurve = (points) => {
  const a = calculateA(points);
  const b = calculateB(points);
  const c2 = calculateC(points);
  const roots = [];
  const distX = b[0] * b[0] - 4 * a[0] * c2[0];
  if (distX < 0)
    ;
  else if (distX === 0) {
    let rootX = -b[0] / (2 * a[0]);
    if (isNaN(rootX))
      rootX = 0;
    if (0 <= rootX && rootX <= 1) {
      roots.push(rootX);
    }
  } else if (distX > 0) {
    const rootX1 = (-b[0] + Math.sqrt(distX)) / (2 * a[0]);
    const rootX2 = (-b[0] - Math.sqrt(distX)) / (2 * a[0]);
    if (0 <= rootX1 && rootX1 <= 1) {
      roots.push(rootX1);
    }
    if (0 <= rootX2 && rootX2 <= 1) {
      roots.push(rootX2);
    }
  }
  const distY = b[1] * b[1] - 4 * a[1] * c2[1];
  if (distY < 0)
    ;
  else if (distY === 0) {
    let rootY = -b[1] / (2 * a[1]);
    if (isNaN(rootY))
      rootY = 0;
    if (0 <= rootY && rootY <= 1) {
      roots.push(rootY);
    }
  } else if (distY > 0) {
    const rootY1 = (-b[1] + Math.sqrt(distY)) / (2 * a[1]);
    const rootY2 = (-b[1] - Math.sqrt(distY)) / (2 * a[1]);
    if (0 <= rootY1 && rootY1 <= 1) {
      roots.push(rootY1);
    }
    if (0 <= rootY2 && rootY2 <= 1) {
      roots.push(rootY2);
    }
  }
  return roots;
};
const getCurveBBox = (points) => {
  const roots = findRootForCurve(points);
  const xyPoints = points.map((p) => {
    return { x: p[0], y: p[1] };
  });
  roots.push(0, 1);
  return roots.map((t) => {
    const { x, y } = getBezierPointOne(xyPoints, t);
    return [x, y, 0];
  });
};
function format(obj2, type, defaultColor = "rgba(0, 0, 0, 0)") {
  if (Array.isArray(obj2)) {
    obj2 = { r: obj2[0], g: obj2[1], b: obj2[2], a: obj2[3] };
  }
  if (type == "hex") {
    return hex(obj2);
  } else if (type == "rgb") {
    return rgb(obj2, defaultColor);
  } else if (type == "hsl") {
    return hsl(obj2);
  }
  return obj2;
}
function formatWithoutAlpha(obj2, type, defaultColor = "rgba(0, 0, 0, 0)") {
  const newColorObj = clone$1(obj2);
  newColorObj.a = 1;
  return format(newColorObj, type, defaultColor);
}
function hex(obj2) {
  if (Array.isArray(obj2)) {
    obj2 = { r: obj2[0], g: obj2[1], b: obj2[2], a: obj2[3] };
  }
  var r = obj2.r.toString(16);
  if (obj2.r < 16)
    r = "0" + r;
  var g = obj2.g.toString(16);
  if (obj2.g < 16)
    g = "0" + g;
  var b = obj2.b.toString(16);
  if (obj2.b < 16)
    b = "0" + b;
  if (obj2.a == 1 || typeof obj2.a === "undefined") {
    return `#${r}${g}${b}`;
  } else {
    const alpha2 = Math.ceil(obj2.a * 255);
    var a = alpha2.toString(16);
    if (alpha2 < 16)
      a = "0" + a;
    return `#${r}${g}${b}${a}`;
  }
}
function rgb(obj2, defaultColor = "rgba(0, 0, 0, 0)") {
  if (Array.isArray(obj2)) {
    obj2 = { r: obj2[0], g: obj2[1], b: obj2[2], a: obj2[3] };
  }
  if (typeof obj2 === "undefined") {
    return void 0;
  }
  if (obj2.a == 1 || typeof obj2.a === "undefined") {
    if (isNaN(obj2.r)) {
      return defaultColor;
    }
    return `rgb(${obj2.r},${obj2.g},${obj2.b})`;
  } else {
    return `rgba(${obj2.r},${obj2.g},${obj2.b},${obj2.a})`;
  }
}
function hsl(obj2) {
  if (Array.isArray(obj2)) {
    obj2 = { r: obj2[0], g: obj2[1], b: obj2[2], a: obj2[3] };
  }
  if (obj2.a == 1 || typeof obj2.a === "undefined") {
    return `hsl(${obj2.h},${obj2.s}%,${obj2.l}%)`;
  } else {
    return `hsla(${obj2.h},${obj2.s}%,${obj2.l}%,${obj2.a})`;
  }
}
function randomNumber(min, max) {
  return Math.floor(Math.random() * (max - min + 1)) + min;
}
function randomByCount(count = 1) {
  let arr = [];
  for (var i = 0; i < count; i++) {
    arr[arr.length] = random$1();
  }
  return arr;
}
function random$1() {
  return rgb({
    r: randomNumber(0, 255),
    g: randomNumber(0, 255),
    b: randomNumber(0, 255)
  });
}
function randomRGBA() {
  return rgb({
    r: randomNumber(0, 255),
    g: randomNumber(0, 255),
    b: randomNumber(0, 255),
    a: randomNumber(0, 1e3) / 1e3
  });
}
function randomItem(...args2) {
  return args2[randomNumber(0, args2.length - 1)];
}
function repeat(count) {
  return [...Array(count)];
}
function CSS_TO_STRING(style, postfix = "") {
  var newStyle = style || {};
  return Object.keys(newStyle).filter((key) => isNotUndefined(newStyle[key])).map((key) => `${key}: ${newStyle[key]}`).join(";" + postfix);
}
function STRING_TO_CSS(str = "", splitChar = ";", keySplitChar = ":") {
  str = str + "";
  var style = {};
  if (str === "")
    return style;
  str.split(splitChar).forEach((it) => {
    var [key, ...value] = it.split(keySplitChar).map((it2) => it2.trim());
    if (key != "") {
      style[key] = value.join(keySplitChar);
    }
  });
  return style;
}
function OBJECT_TO_PROPERTY(obj2) {
  const target = obj2 || {};
  return Object.keys(target).map((key) => {
    if (key === "class") {
      if (isObject(obj2[key])) {
        return `${key}="${classnames(obj2[key])}"`;
      }
    }
    if (key === "style") {
      if (isObject(obj2[key])) {
        return `${key}="${CSS_TO_STRING(obj2[key])}"`;
      }
    }
    if (isBoolean(obj2[key]) || isUndefined(obj2[key]) || obj2[key] === "undefined") {
      if (obj2[key]) {
        return key;
      } else {
        return "";
      }
    }
    return `${key}="${obj2[key]}"`;
  }).join(" ");
}
function TAG_TO_STRING(str) {
  return str.replace(/</g, "&lt;").replace(/>/g, "&gt;");
}
function mapjoin(arr, callback, joinString = "") {
  return arr.map(callback).join(joinString);
}
function isArrayEquals(A, B) {
  const s = /* @__PURE__ */ new Set([...A, ...B]);
  return s.size === A.length && s.size === B.length;
}
const curveToPath = (timingFunction, width2 = 30, height2 = 30) => {
  const currentBezier = getPredefinedCubicBezier(timingFunction);
  return `
        M0 ${width2} 
        C 
        ${currentBezier[0] * width2} ${currentBezier[1] == 0 ? height2 : (1 - currentBezier[1]) * height2},
        ${currentBezier[2] * width2} ${currentBezier[3] == 1 ? 0 : (1 - currentBezier[3]) * height2},
        ${width2} 0
    `;
};
const curveToPointLine = (timingFunction, width2 = 30, height2 = 30) => {
  const currentBezier = getPredefinedCubicBezier(timingFunction);
  return `
        M 0 ${width2} 
        L ${currentBezier[0] * width2} ${currentBezier[1] == 0 ? height2 : (1 - currentBezier[1]) * height2}
        M ${width2} 0
        L ${currentBezier[2] * width2} ${currentBezier[3] == 1 ? 0 : (1 - currentBezier[3]) * height2}
    `;
};
const valueFunctionIdentity = (v) => v;
const valueMap = (obj2, valueFunction = valueFunctionIdentity) => {
  const newObj = clone$1(obj2);
  Object.keys(newObj).forEach((key) => {
    newObj[key] = valueFunction(newObj[key]);
  });
  return newObj;
};
const objectFloor = (obj2) => valueMap(obj2, Math.floor);
class PropertyItem extends Item {
  getDefaultObject(obj2 = {}) {
    return __spreadValues({
      selected: false,
      layers: []
    }, obj2);
  }
  isAttribute() {
    return true;
  }
  toCSS() {
    return {};
  }
  toString() {
    return CSS_TO_STRING(this.toCSS());
  }
}
class BoxShadow extends PropertyItem {
  static parse(obj2) {
    return new BoxShadow(obj2);
  }
  static parseStyle(str) {
    var boxShadows = [];
    str = str.trim();
    if (!str)
      return boxShadows;
    var results = convertMatches(str);
    boxShadows = results.str.split(",").filter((it) => it.trim()).map((shadow2) => {
      var values = shadow2.trim().split(" ");
      var insets = values.filter((it) => it === BoxShadowStyle.INSET);
      var colors2 = values.filter((it) => it.includes("@")).map((it) => {
        return reverseMatches(it, results.matches);
      });
      var numbers = values.filter((it) => {
        return it !== BoxShadowStyle.INSET && !it.includes("@");
      });
      return BoxShadow.parse({
        inset: insets.length ? BoxShadowStyle.INSET : BoxShadowStyle.OUTSET,
        color: colors2[0] || "rgba(0, 0, 0, 1)",
        offsetX: Length.parse(numbers[0] || "0px"),
        offsetY: Length.parse(numbers[1] || "0px"),
        blurRadius: Length.parse(numbers[2] || "0px"),
        spreadRadius: Length.parse(numbers[3] || "0px")
      });
    });
    return boxShadows;
  }
  static join(list2) {
    return list2.map((it) => BoxShadow.parse(it)).join(", ");
  }
  getDefaultObject() {
    return super.getDefaultObject({
      itemType: "box-shadow",
      inset: false,
      offsetX: 0,
      offsetY: 0,
      blurRadius: 0,
      spreadRadius: 0,
      color: "rgba(0, 0, 0, 1)"
    });
  }
  toCloneObject() {
    return __spreadValues(__spreadValues({}, super.toCloneObject()), this.attrs("inset", "offsetX", "offsetY", "blurRadius", "spreadRadius", "color"));
  }
  convert(json) {
    json = super.convert(json);
    if (isNumber(json.offsetX))
      json.offsetX = Length.px(json.offsetX);
    else if (json.offsetX)
      json.offsetX = Length.parse(json.offsetX);
    if (isNumber(json.offsetY))
      json.offsetY = Length.px(json.offsetY);
    else if (json.offsetY)
      json.offsetY = Length.parse(json.offsetY);
    if (isNumber(json.blurRadius))
      json.blurRadius = Length.px(json.blurRadius);
    else if (json.blurRadius)
      json.blurRadius = Length.parse(json.blurRadius);
    if (isNumber(json.spreadRadius))
      json.spreadRadius = Length.px(json.spreadRadius);
    else if (json.spreadRadius)
      json.spreadRadius = Length.parse(json.spreadRadius);
    return json;
  }
  toCSS() {
    return {
      "box-shadow": this.toString()
    };
  }
  toString() {
    var json = this.json;
    return `${json.inset === BoxShadowStyle.INSET ? "inset " : ""}${json.offsetX} ${json.offsetY} ${json.blurRadius} ${json.spreadRadius} ${json.color}`;
  }
}
class BoxShadowEditor extends EditorElement {
  initState() {
    return {
      boxShadows: BoxShadow.parseStyle(this.props.value || "")
    };
  }
  template() {
    return `
      <div class="elf--box-shadow-editor" >
        <div class='box-shadow-list' ref='$shadowList'></div>
      </div>
    `;
  }
  [LOAD("$shadowList") + DOMDIFF]() {
    var arr = this.state.boxShadows.map((shadow2, index2) => {
      return `
        <div class="shadow-item real" data-index="${index2}">
            <label draggable="true" data-index="${index2}">${iconUse("drag_indicator")}</label>
            <div class="shadow-content">
            ${createComponent("ColorViewEditor", {
        mini: true,
        key: "color",
        value: shadow2.color,
        params: index2,
        onchange: "changeKeyValue"
      })}
            ${createComponent("NumberInputEditor", {
        mini: true,
        key: "offsetX",
        label: "X",
        value: shadow2.offsetX,
        params: index2,
        onchange: "changeKeyValue"
      })}          
            ${createComponent("NumberInputEditor", {
        mini: true,
        key: "offsetY",
        label: "Y",
        value: shadow2.offsetY,
        params: index2,
        onchange: "changeKeyValue"
      })}                    
            ${createComponent("ToggleButton", {
        mini: true,
        key: "inset",
        value: shadow2.inset,
        params: index2,
        onChange: "changeKeyValue",
        checkedValue: BoxShadowStyle.INSET,
        toggleLabels: [iconUse("border_style"), iconUse("border_style")],
        toggleTitles: [BoxShadowStyle.INSET, BoxShadowStyle.INSET],
        toggleValues: [BoxShadowStyle.OUTSET, BoxShadowStyle.INSET]
      })}            

            ${createComponent("NumberInputEditor", {
        mini: true,
        label: "B",
        key: "blurRadius",
        value: shadow2.blurRadius,
        params: index2,
        onchange: "changeKeyValue"
      })} 
            ${createComponent("NumberInputEditor", {
        mini: true,
        label: "S",
        key: "spreadRadius",
        value: shadow2.spreadRadius,
        params: index2,
        onchange: "changeKeyValue"
      })}             
          </div>
          <div class="tools">
            <button type="button" class="remove" data-index="${index2}">
              ${iconUse("remove2")}
            </button>
          </div>
        </div>
      `;
    });
    return arr.join("");
  }
  modifyBoxShadow() {
    var value = this.state.boxShadows.join(", ");
    this.parent.trigger(this.props.onchange, this.props.key, value);
  }
  [SUBSCRIBE("add")](shadow2 = "") {
    if (shadow2) {
      this.state.boxShadows = BoxShadow.parseStyle(shadow2);
    } else {
      const shadowObj = new BoxShadow({
        color: "black",
        inset: BoxShadowStyle.OUTSET,
        offsetX: 2,
        offsetY: 2,
        blurRadius: 3,
        spreadRadius: 1
      });
      this.state.boxShadows.push(shadowObj);
    }
    this.refresh();
    this.modifyBoxShadow();
  }
  [CLICK("$add")]() {
    this.trigger("add");
  }
  [DRAGSTART("$shadowList .shadow-item > label")](e) {
    this.startIndex = +e.$dt.attr("data-index");
  }
  [DRAGOVER("$shadowList .shadow-item") + PREVENT]() {
  }
  sortItem(arr, startIndex, targetIndex) {
    arr.splice(targetIndex + (startIndex < targetIndex ? -1 : 0), 0, ...arr.splice(startIndex, 1));
  }
  sortBoxShadow(startIndex, targetIndex) {
    this.sortItem(this.state.boxShadows, startIndex, targetIndex);
  }
  [DROP("$shadowList .shadow-item") + PREVENT](e) {
    var targetIndex = +e.$dt.attr("data-index");
    this.sortBoxShadow(this.startIndex, targetIndex);
    this.refresh();
    this.modifyBoxShadow();
  }
  [CLICK("$shadowList .remove")](e) {
    var index2 = +e.$dt.attr("data-index");
    this.state.boxShadows.splice(index2, 1);
    this.refresh();
    this.modifyBoxShadow();
  }
  [SUBSCRIBE_SELF("changeKeyValue")](key, value, index2) {
    var shadow2 = this.state.boxShadows[index2];
    shadow2.reset({
      [key]: value
    });
    this.modifyBoxShadow();
  }
}
const colors$k = [
  "#FFF8E1",
  "#FFECB3",
  "#FFE082",
  "#FFD54F",
  "#FFCA28",
  "#FFC107",
  "#FFB300",
  "#FFA000",
  "#FF8F00",
  "#FF6F00",
  "#FFE57F",
  "#FFD740",
  "#FFC400",
  "#FFAB00"
].map((color2) => {
  return { color: color2 };
});
var materialAmber = {
  title: "material amber",
  key: "material-amber",
  execute: function() {
    return colors$k;
  }
};
var __glob_0_0$5 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": materialAmber
}, Symbol.toStringTag, { value: "Module" }));
const colors$j = [
  "#e3f2fd",
  "#bbdefb",
  "#90caf9",
  "#64b5f6",
  "#42a5f5",
  "#2196f3",
  "#1e88e5",
  "#1976d2",
  "#1565c0",
  "#0d47a1",
  "#2196f3",
  "#82b1ff",
  "#448aff",
  "#2979ff",
  "#2962ff"
].map((color2) => {
  return { color: color2 };
});
var materialBlue = {
  title: "material blue",
  key: "material-blue",
  execute: function() {
    return colors$j;
  }
};
var __glob_0_1$5 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": materialBlue
}, Symbol.toStringTag, { value: "Module" }));
const colors$i = [
  "#ECEFF1",
  "#CFD8DC",
  "#B0BEC5",
  "#90A4AE",
  "#78909C",
  "#607D8B",
  "#546E7A",
  "#455A64",
  "#37474F",
  "#263238"
].map((color2) => {
  return { color: color2 };
});
var materialBluegray = {
  title: "material bluegray",
  key: "material-bluegray",
  execute: function() {
    return colors$i;
  }
};
var __glob_0_2$4 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": materialBluegray
}, Symbol.toStringTag, { value: "Module" }));
const colors$h = [
  "#EFEBE9",
  "#D7CCC8",
  "#BCAAA4",
  "#A1887F",
  "#8D6E63",
  "#795548",
  "#6D4C41",
  "#5D4037",
  "#4E342E",
  "#3E2723"
].map((color2) => {
  return { color: color2 };
});
var materialBrown = {
  title: "material brown",
  key: "material-brown",
  execute: function() {
    return colors$h;
  }
};
var __glob_0_3$4 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": materialBrown
}, Symbol.toStringTag, { value: "Module" }));
const colors$g = [
  "#e0f7fa",
  "#b2ebf2",
  "#80deea",
  "#4dd0e1",
  "#26c6da",
  "#00bcd4",
  "#00acc1",
  "#0097a7",
  "#00838f",
  "#006064",
  "#00bcd4",
  "#84ffff",
  "#18ffff",
  "#00e5ff",
  "#00b8d4"
].map((color2) => {
  return { color: color2 };
});
var materialCyan = {
  title: "material cyan",
  key: "material-cyan",
  execute: function() {
    return colors$g;
  }
};
var __glob_0_4$4 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": materialCyan
}, Symbol.toStringTag, { value: "Module" }));
const colors$f = [
  "#FBE9E7",
  "#FFCCBC",
  "#FFAB91",
  "#FF8A65",
  "#FF7043",
  "#FF5722",
  "#F4511E",
  "#E64A19",
  "#D84315",
  "#BF360C",
  "#FF9E80",
  "#FF6E40",
  "#FF3D00",
  "#DD2C00"
].map((color2) => {
  return { color: color2 };
});
var materialDeeporange = {
  title: "material deep orange",
  key: "material-deeporange",
  execute: function() {
    return colors$f;
  }
};
var __glob_0_5$4 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": materialDeeporange
}, Symbol.toStringTag, { value: "Module" }));
const colors$e = [
  "#ede7f6",
  "#d1c4e9",
  "#b39ddb",
  "#9575cd",
  "#7e57c2",
  "#673ab7",
  "#5e35b1",
  "#512da8",
  "#4527a0",
  "#311b92",
  "#673ab7",
  "#b388ff",
  "#7c4dff",
  "#651fff",
  "#6200ea"
].map((color2) => {
  return { color: color2 };
});
var materialDeeppurple = {
  title: "material deep purple",
  key: "material-deeppurple",
  execute: function() {
    return colors$e;
  }
};
var __glob_0_6$4 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": materialDeeppurple
}, Symbol.toStringTag, { value: "Module" }));
const colors$d = [
  "#FAFAFA",
  "#F5F5F5",
  "#EEEEEE",
  "#E0E0E0",
  "#BDBDBD",
  "#9E9E9E",
  "#757575",
  "#616161",
  "#424242",
  "#212121"
].map((color2) => {
  return { color: color2 };
});
var materialGray = {
  title: "material gray",
  key: "material-gray",
  execute: function() {
    return colors$d;
  }
};
var __glob_0_7$4 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": materialGray
}, Symbol.toStringTag, { value: "Module" }));
const colors$c = [
  "#E8F5E9",
  "#C8E6C9",
  "#A5D6A7",
  "#81C784",
  "#66BB6A",
  "#4CAF50",
  "#43A047",
  "#388E3C",
  "#2E7D32",
  "#1B5E20",
  "#B9F6CA",
  "#69F0AE",
  "#00E676",
  "#00C853"
].map((color2) => {
  return { color: color2 };
});
var materialGreen = {
  title: "material green",
  key: "material-green",
  execute: function() {
    return colors$c;
  }
};
var __glob_0_8$4 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": materialGreen
}, Symbol.toStringTag, { value: "Module" }));
const colors$b = [
  "#e8eaf6",
  "#c5cae9",
  "#9fa8da",
  "#7986cb",
  "#5c6bc0",
  "#3f51b5",
  "#3949ab",
  "#303f9f",
  "#283593",
  "#1a237e",
  "#3f51b5",
  "#8c9eff",
  "#536dfe",
  "#3d5afe",
  "#304ffe"
].map((color2) => {
  return { color: color2 };
});
var materialIndigo = {
  title: "material indigo",
  key: "material-indigo",
  execute: function() {
    return colors$b;
  }
};
var __glob_0_9$4 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": materialIndigo
}, Symbol.toStringTag, { value: "Module" }));
const colors$a = [
  "#e1f5fe",
  "#b3e5fc",
  "#81d4fa",
  "#4fc3f7",
  "#29b6f6",
  "#03a9f4",
  "#039be5",
  "#0288d1",
  "#0277bd",
  "#01579b",
  "#03a9f4",
  "#80d8ff",
  "#40c4ff",
  "#00b0ff",
  "#0091ea"
].map((color2) => {
  return { color: color2 };
});
var materialLightblue = {
  title: "material light blue",
  key: "material-lightblue",
  execute: function() {
    return colors$a;
  }
};
var __glob_0_10$4 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": materialLightblue
}, Symbol.toStringTag, { value: "Module" }));
const colors$9 = [
  "#F1F8E9",
  "#DCEDC8",
  "#C5E1A5",
  "#AED581",
  "#9CCC65",
  "#8BC34A",
  "#7CB342",
  "#689F38",
  "#558B2F",
  "#33691E",
  "#CCFF90",
  "#B2FF59",
  "#76FF03",
  "#64DD17"
].map((color2) => {
  return { color: color2 };
});
var materialLightgreen = {
  title: "material lightgreen",
  key: "material-lightgreen",
  execute: function() {
    return colors$9;
  }
};
var __glob_0_11$4 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": materialLightgreen
}, Symbol.toStringTag, { value: "Module" }));
const colors$8 = [
  "#F9FBE7",
  "#F0F4C3",
  "#E6EE9C",
  "#DCE775",
  "#D4E157",
  "#CDDC39",
  "#C0CA33",
  "#AFB42B",
  "#9E9D24",
  "#827717",
  "#F4FF81",
  "#EEFF41",
  "#C6FF00",
  "#AEEA00"
].map((color2) => {
  return { color: color2 };
});
var materialLime = {
  title: "material lime",
  key: "material-lime",
  execute: function() {
    return colors$8;
  }
};
var __glob_0_12$4 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": materialLime
}, Symbol.toStringTag, { value: "Module" }));
const colors$7 = [
  "#FFF3E0",
  "#FFE0B2",
  "#FFCC80",
  "#FFB74D",
  "#FFA726",
  "#FF9800",
  "#FB8C00",
  "#F57C00",
  "#EF6C00",
  "#E65100",
  "#FFD180",
  "#FFAB40",
  "#FF9100",
  "#FF6D00"
].map((color2) => {
  return { color: color2 };
});
var materialOrange = {
  title: "material orange",
  key: "material-orange",
  execute: function() {
    return colors$7;
  }
};
var __glob_0_13$4 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": materialOrange
}, Symbol.toStringTag, { value: "Module" }));
const colors$6 = [
  "#fce4ec",
  "#f8bbd0",
  "#f48fb1",
  "#f06292",
  "#ec407a",
  "#e91e63",
  "#d81b60",
  "#c2185b",
  "#ad1457",
  "#880e4f",
  "#e91e63",
  "#ff80ab",
  "#ff4081",
  "#f50057",
  "#c51162"
].map((color2) => {
  return { color: color2 };
});
var materialPink = {
  title: "material pink",
  key: "material-pink",
  execute: function() {
    return colors$6;
  }
};
var __glob_0_14$4 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": materialPink
}, Symbol.toStringTag, { value: "Module" }));
const colors$5 = [
  "#f3e5f5",
  "#e1bee7",
  "#ce93d8",
  "#ba68c8",
  "#ab47bc",
  "#9c27b0",
  "#8e24aa",
  "#7b1fa2",
  "#6a1b9a",
  "#4a148c",
  "#9c27b0",
  "#ea80fc",
  "#e040fb",
  "#d500f9",
  "#aa00ff"
].map((color2) => {
  return { color: color2 };
});
var materialPurple = {
  title: "material purple",
  key: "material-purple",
  execute: function() {
    return colors$5;
  }
};
var __glob_0_15$3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": materialPurple
}, Symbol.toStringTag, { value: "Module" }));
const colors$4 = [
  "#ffebee",
  "#ffcdd2",
  "#ef9a9a",
  "#e57373",
  "#ef5350",
  "#f44336",
  "#e53935",
  "#d32f2f",
  "#c62828",
  "#b71c1c",
  "#f44336",
  "#ff8a80",
  "#ff5252",
  "#ff1744",
  "#d50000"
].map((color2) => {
  return { color: color2 };
});
var materialRed = {
  title: "material red",
  key: "material-red",
  execute: function() {
    return colors$4;
  }
};
var __glob_0_16$3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": materialRed
}, Symbol.toStringTag, { value: "Module" }));
const colors$3 = [
  "#e0f2f1",
  "#b2dfdb",
  "#80cbc4",
  "#4db6ac",
  "#26a69a",
  "#009688",
  "#00897b",
  "#00796b",
  "#00695c",
  "#004d40",
  "#009688",
  "#a7ffeb",
  "#64ffda",
  "#1de9b6",
  "#00bfa5"
].map((color2) => {
  return { color: color2 };
});
var materialTeal = {
  title: "material teal",
  key: "material-teal",
  execute: function() {
    return colors$3;
  }
};
var __glob_0_17$3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": materialTeal
}, Symbol.toStringTag, { value: "Module" }));
const colors$2 = [
  "#FFFDE7",
  "#FFF9C4",
  "#FFF59D",
  "#FFF176",
  "#FFEE58",
  "#FFEB3B",
  "#FDD835",
  "#FBC02D",
  "#F9A825",
  "#F57F17",
  "#FFFF8D",
  "#FFFF00",
  "#FFEA00",
  "#FFD600"
].map((color2) => {
  return { color: color2 };
});
var materialYellow = {
  title: "material yellow",
  key: "material-yellow",
  execute: function() {
    return colors$2;
  }
};
var __glob_0_18$3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": materialYellow
}, Symbol.toStringTag, { value: "Module" }));
const colors$1 = [
  "#f8f9fa",
  "#f1f3f5",
  "#e9ecef",
  "#dee2e6",
  "#ced4da",
  "#adb5bd",
  "#868e96",
  "#495057",
  "#343a40",
  "#212529"
].map((color2) => {
  return { color: color2 };
});
var opencolorGray = {
  title: "opencolor gray",
  resource: "https://yeun.github.io/open-color/",
  key: "opencolor-gray",
  execute: function() {
    return colors$1;
  }
};
var __glob_0_19$3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": opencolorGray
}, Symbol.toStringTag, { value: "Module" }));
function CMYKtoRGB(c2, m, y, k) {
  if (arguments.length == 1) {
    var { c: c2, m, y, k } = arguments[0];
  }
  const R = 255 * (1 - c2) * (1 - k);
  const G = 255 * (1 - m) * (1 - k);
  const B = 255 * (1 - y) * (1 - k);
  return { r: R, g: G, b: B };
}
function HSVtoRGB(h, s, v) {
  if (arguments.length == 1) {
    var { h, s, v } = arguments[0];
  }
  var H = h;
  var S = s;
  var V = v;
  if (H >= 360) {
    H = 0;
  }
  const C = S * V;
  const X = C * (1 - Math.abs(H / 60 % 2 - 1));
  const m = V - C;
  let temp = [];
  if (0 <= H && H < 60) {
    temp = [C, X, 0];
  } else if (60 <= H && H < 120) {
    temp = [X, C, 0];
  } else if (120 <= H && H < 180) {
    temp = [0, C, X];
  } else if (180 <= H && H < 240) {
    temp = [0, X, C];
  } else if (240 <= H && H < 300) {
    temp = [X, 0, C];
  } else if (300 <= H && H < 360) {
    temp = [C, 0, X];
  }
  return {
    r: round((temp[0] + m) * 255),
    g: round((temp[1] + m) * 255),
    b: round((temp[2] + m) * 255)
  };
}
function HSVtoHSL(h, s, v) {
  if (arguments.length == 1) {
    var { h, s, v } = arguments[0];
  }
  const rgb2 = HSVtoRGB(h, s, v);
  return RGBtoHSL(rgb2.r, rgb2.g, rgb2.b);
}
function YCrCbtoRGB(y, cr, cb, bit) {
  if (arguments.length == 1) {
    var { y, cr, cb, bit } = arguments[0];
    bit = bit || 0;
  }
  const R = y + 1.402 * (cr - bit);
  const G = y - 0.344 * (cb - bit) - 0.714 * (cr - bit);
  const B = y + 1.772 * (cb - bit);
  return { r: Math.ceil(R), g: Math.ceil(G), b: Math.ceil(B) };
}
function interpolateRGB(startColor, endColor, t = 0.5, exportFormat = "hex") {
  var obj2 = interpolateRGBObject(startColor, endColor, t);
  return format(obj2, exportFormat);
}
function interpolateRGBObject(startColor, endColor, t = 0.5) {
  const startColorAlpha = typeof startColor.a === "undefined" ? 1 : startColor.a;
  const endColorAlpha = typeof endColor.a === "undefined" ? 1 : endColor.a;
  return {
    r: round(startColor.r + (endColor.r - startColor.r) * t),
    g: round(startColor.g + (endColor.g - startColor.g) * t),
    b: round(startColor.b + (endColor.b - startColor.b) * t),
    a: round(startColorAlpha + (endColorAlpha - startColorAlpha) * t, 100)
  };
}
function scale(scale2, count = 5) {
  if (!scale2)
    return [];
  if (typeof scale2 === "string") {
    scale2 = convertMatchesArray(scale2);
  }
  scale2 = scale2 || [];
  var len2 = scale2.length;
  var colors2 = [];
  for (var i = 0; i < len2 - 1; i++) {
    for (var index2 = 0; index2 < count; index2++) {
      colors2.push(blend(scale2[i], scale2[i + 1], index2 / count));
    }
  }
  return colors2;
}
function blend(startColor, endColor, ratio = 0.5, format2 = "hex") {
  var s = parse(startColor);
  var e = parse(endColor);
  return interpolateRGB(s, e, ratio, format2);
}
function mix(startcolor, endColor, ratio = 0.5, format2 = "hex") {
  return blend(startcolor, endColor, ratio, format2);
}
function contrast(c2) {
  c2 = parse(c2);
  return (Math.round(c2.r * 299) + Math.round(c2.g * 587) + Math.round(c2.b * 114)) / 1e3;
}
function contrastColor(c2) {
  return contrast(c2) >= 128 ? "black" : "white";
}
function gradient$1(colors2, count = 10) {
  colors2 = parseGradient(colors2);
  let newColors = [];
  let maxCount = count - (colors2.length - 1);
  let allCount = maxCount;
  for (var i = 1, len2 = colors2.length; i < len2; i++) {
    var startColor = colors2[i - 1][0];
    var endColor = colors2[i][0];
    var rate = i == 1 ? colors2[i][1] : colors2[i][1] - colors2[i - 1][1];
    var colorCount = i == colors2.length - 1 ? allCount : Math.floor(rate * maxCount);
    newColors = newColors.concat(scale([startColor, endColor], colorCount), [
      endColor
    ]);
    allCount -= colorCount;
  }
  return newColors;
}
function scaleHSV(color2, target = "h", count = 9, exportFormat = "rgb", min = 0, max = 1, dist2 = 100) {
  var colorObj = parse(color2);
  var hsv = RGBtoHSV(colorObj);
  var unit = (max - min) * dist2 / count;
  var results = [];
  for (var i = 1; i <= count; i++) {
    hsv[target] = Math.abs((dist2 - unit * i) / dist2);
    results.push(format(HSVtoRGB(hsv), exportFormat));
  }
  return results;
}
function scaleH(color2, count = 9, exportFormat = "rgb", min = 0, max = 360) {
  return scaleHSV(color2, "h", count, exportFormat, min, max, 1);
}
function scaleS(color2, count = 9, exportFormat = "rgb", min = 0, max = 1) {
  return scaleHSV(color2, "s", count, exportFormat, min, max, 100);
}
function scaleV(color2, count = 9, exportFormat = "rgb", min = 0, max = 1) {
  return scaleHSV(color2, "v", count, exportFormat, min, max, 100);
}
scale.parula = function(count) {
  return scale(["#352a87", "#0f5cdd", "#00b5a6", "#ffc337", "#fdff00"], count);
};
scale.jet = function(count) {
  return scale([
    "#00008f",
    "#0020ff",
    "#00ffff",
    "#51ff77",
    "#fdff00",
    "#ff0000",
    "#800000"
  ], count);
};
scale.hsv = function(count) {
  return scale([
    "#ff0000",
    "#ffff00",
    "#00ff00",
    "#00ffff",
    "#0000ff",
    "#ff00ff",
    "#ff0000"
  ], count);
};
scale.hot = function(count) {
  return scale(["#0b0000", "#ff0000", "#ffff00", "#ffffff"], count);
};
scale.pink = function(count) {
  return scale(["#1e0000", "#bd7b7b", "#e7e5b2", "#ffffff"], count);
};
scale.bone = function(count) {
  return scale(["#000000", "#4a4a68", "#a6c6c6", "#ffffff"], count);
};
scale.copper = function(count) {
  return scale(["#000000", "#3d2618", "#9d623e", "#ffa167", "#ffc77f"], count);
};
const hue_color = [
  { rgb: "#ff0000", start: 0 },
  { rgb: "#ffff00", start: 0.17 },
  { rgb: "#00ff00", start: 0.33 },
  { rgb: "#00ffff", start: 0.5 },
  { rgb: "#0000ff", start: 0.67 },
  { rgb: "#ff00ff", start: 0.83 },
  { rgb: "#ff0000", start: 1 }
];
function checkHueColor(p) {
  var startColor, endColor;
  for (var i = 0; i < hue_color.length; i++) {
    if (hue_color[i].start >= p) {
      startColor = hue_color[i - 1];
      endColor = hue_color[i];
      break;
    }
  }
  if (startColor && endColor) {
    return mix(startColor, endColor, (p - startColor.start) / (endColor.start - startColor.start));
  }
  return hue_color[0].rgb;
}
function initHueColors() {
  for (var i = 0, len2 = hue_color.length; i < len2; i++) {
    var hue = hue_color[i];
    var obj2 = parse(hue.rgb);
    hue.r = obj2.r;
    hue.g = obj2.g;
    hue.b = obj2.b;
  }
}
initHueColors();
var random = {
  title: "random",
  key: "random",
  execute: function(count = 42) {
    const colorList = randomByCount(count).map((color2) => {
      return { color: color2 };
    });
    colorList.sort((a, b) => {
      const localA = parse(a.color);
      const localB = parse(b.color);
      return localA.h > localB.h ? 1 : -1;
    });
    return colorList;
  }
};
var __glob_0_20$3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": random
}, Symbol.toStringTag, { value: "Module" }));
const modules$5 = { "./colors_list/material-amber.js": __glob_0_0$5, "./colors_list/material-blue.js": __glob_0_1$5, "./colors_list/material-bluegray.js": __glob_0_2$4, "./colors_list/material-brown.js": __glob_0_3$4, "./colors_list/material-cyan.js": __glob_0_4$4, "./colors_list/material-deeporange.js": __glob_0_5$4, "./colors_list/material-deeppurple.js": __glob_0_6$4, "./colors_list/material-gray.js": __glob_0_7$4, "./colors_list/material-green.js": __glob_0_8$4, "./colors_list/material-indigo.js": __glob_0_9$4, "./colors_list/material-lightblue.js": __glob_0_10$4, "./colors_list/material-lightgreen.js": __glob_0_11$4, "./colors_list/material-lime.js": __glob_0_12$4, "./colors_list/material-orange.js": __glob_0_13$4, "./colors_list/material-pink.js": __glob_0_14$4, "./colors_list/material-purple.js": __glob_0_15$3, "./colors_list/material-red.js": __glob_0_16$3, "./colors_list/material-teal.js": __glob_0_17$3, "./colors_list/material-yellow.js": __glob_0_18$3, "./colors_list/opencolor-gray.js": __glob_0_19$3, "./colors_list/random.js": __glob_0_20$3 };
var colors = Object.values(modules$5).map((it) => it.default);
var ColorAssetsEditor$1 = "";
class ColorAssetsEditor extends EditorElement {
  initState() {
    return {
      mode: "grid",
      preset: "random",
      isLoaded: false,
      colors
    };
  }
  getTools() {
    return `<div ref="$tools"></div>`;
  }
  [LOAD("$tools")]() {
    const options2 = this.state.colors.map((it) => {
      return { value: it.key, text: it.title };
    });
    return createComponent("SelectEditor", {
      key: "preset",
      value: this.state.preset,
      options: options2,
      onchange: "changePreset"
    });
  }
  [SUBSCRIBE("changePreset")](key, value) {
    this.setState({
      [key]: value
    });
  }
  template() {
    return `
      <div class='elf--color-assets-editor'>
        <div class='color-assets-head'>
          <div class='tools'>${this.getTools()}</div>
        </div>
        <div class='color-list' ref='$colorList' data-view-mode='${this.state.mode}'></div>
      </div>
    `;
  }
  [CLICK("$title")]() {
    this.$el.toggleClass("is-open");
  }
  [LOAD("$colorList")]() {
    var preset = this.state.colors.find((it) => it.key === this.state.preset);
    if (!preset) {
      return "";
    }
    var results = preset.execute().map((item, index2) => {
      return `
        <div class='color-item' data-index="${index2}" data-color="${item.color}">
          <div class='preview' title="${item.color}" data-index="${index2}">
            <div class='color-view' style='background-color: ${item.color};'></div>
          </div>
        </div>
      `;
    });
    return results;
  }
  executeColor(callback, isRefresh = true, isEmit = true) {
    var project2 = this.$context.selection.currentProject;
    if (project2) {
      callback && callback(project2);
      if (isRefresh)
        this.refresh();
      if (isEmit)
        this.emit("refreshColorAssets");
    } else {
      window.alert("Please select a project.");
    }
  }
  [CLICK("$colorList .preview")](e) {
    const color2 = e.$dt.$(".color-view").css("background-color");
    this.modifyColorPicker(color2);
  }
  modifyColorPicker(color2) {
    this.parent.trigger(this.props.onchange, this.props.key, color2, this.props.params);
  }
}
var ColorSingleEditor$1 = "";
class ColorSingleEditor extends EditorElement {
  initState() {
    return {
      params: this.props.params,
      color: this.props.color || "rgba(0, 0, 0, 1)"
    };
  }
  updateData(opt = {}) {
    this.setState(opt, false);
    this.modifyColor();
  }
  modifyColor() {
    this.parent.trigger(this.props.onchange, this.props.key, this.state.color, this.state.params);
  }
  changeColor(color2) {
    this.setState({ color: color2 });
  }
  setValue(color2) {
    this.changeColor(color2);
  }
  [BIND("$miniView")]() {
    return {
      style: {
        "background-color": this.state.color
      }
    };
  }
  template() {
    return `
            <div class='elf--color-single-editor'>
                <div class='preview' ref='$preview'>
                    <div class='mini-view'>
                        <div class='color-view' style="background-color: ${this.state.color}" ref='$miniView'></div>
                    </div>
                </div>
            </div>
        `;
  }
  [CLICK("$preview")]() {
    this.viewColorPicker();
  }
  viewColorPicker() {
    this.emit("showColorPickerPopup", {
      target: this,
      changeEvent: (color2) => {
        this.refs.$miniView.cssText(`background-color: ${color2}`);
        this.updateData({ color: color2 });
      },
      color: this.state.color
    });
  }
}
var ColorViewEditor$1 = "";
class ColorViewEditor extends EditorElement {
  initState() {
    const value = this.props.value || "rgba(0, 0, 0, 1)";
    const compact = isBoolean(this.props.compact) ? this.props.compact : this.props.compact === "true";
    const mini = isBoolean(this.props.mini) ? this.props.mini : this.props.mini === "true";
    return {
      label: this.props.label,
      value,
      compact,
      mini,
      color: parse(value),
      colorFocus: false,
      opacityFocus: false
    };
  }
  updateData(opt = {}) {
    this.setState(opt);
    this.modifyColor();
  }
  updateEndData(opt = {}) {
    this.setState(opt);
    this.modifyEndColor();
  }
  getValue() {
    return this.state.value;
  }
  setValue(value) {
    this.changeColor(value);
  }
  modifyColor() {
    this.parent.trigger(this.props.onchange, this.props.key, this.state.value, this.props.params);
  }
  modifyEndColor() {
    this.parent.trigger(this.props.onchangeend, this.props.key, this.state.value, this.props.params);
  }
  changeColor(value) {
    this.setState({
      value,
      color: parse(value)
    });
  }
  get alpha() {
    return this.state.color.a * 100;
  }
  get hexColor() {
    return formatWithoutAlpha(this.state.color, "hex");
  }
  get fullColor() {
    return format(this.state.color, this.state.color.type);
  }
  refresh() {
    this.refreshColorView();
    this.refs.$colorCode.val(this.state.value);
    this.refs.$opacityCode.val(this.alpha);
  }
  refreshColorView() {
    this.bindData("$miniView1");
    this.bindData("$miniView2");
  }
  template() {
    var { label, compact, mini } = this.state;
    var hasLabel = label ? "has-label" : "";
    var hasCompact = compact ? "compact" : "";
    var hasMini = mini ? "mini" : "";
    return `
            <div class='elf--color-view-editor ${hasLabel} ${hasCompact} ${hasMini}'>
                ${label ? `<label>${label}</label>` : ""}            
                <div class='color-code' ref="$container">
                    <div class='preview' ref='$preview'>
                        <div class='mini-view'>
                            <div class='color-view' ref='$miniView1'></div>
                            <div class='color-view' ref='$miniView2'></div>
                        </div>
                    </div>                
                    <div class="color-input">
                        <input type="text" ref='$colorCode' value='${this.state.value}' tabIndex="1" />
                    </div>
                    <div class="opacity-input">                    
                        <input type="number" ref='$opacityCode' value='${this.alpha}' tabIndex="2" max="100" min="0" step="0.1" />
                    </div>                    
                </div>
            </div>
        `;
  }
  [BIND("$el")]() {
    return {
      class: {
        focused: this.state.colorFocus || this.state.opacityFocus
      }
    };
  }
  [BIND("$miniView1")]() {
    return {
      style: {
        "background-color": this.hexColor
      }
    };
  }
  [BIND("$miniView2")]() {
    return {
      style: {
        "background-color": this.fullColor
      }
    };
  }
  [BIND("$colorCode")]() {
    return {
      value: this.props.format ? this.hexColor : this.state.value
    };
  }
  [BIND("$opacityCode")]() {
    return {
      value: this.alpha
    };
  }
  [FOCUSIN("$colorCode")]() {
    this.setState({
      colorFocus: true
    });
    this.refs.$colorCode.select();
  }
  [FOCUSOUT("$colorCode")]() {
    this.setState({
      colorFocus: false
    });
  }
  [FOCUSIN("$opacityCode")]() {
    this.setState({
      opacityFocus: true
    });
    this.refs.$opacityCode.select();
  }
  [FOCUSOUT("$opacityCode")]() {
    this.setState({
      opacityFocus: false
    });
  }
  [CLICK("$preview")]() {
    this.viewColorPicker();
  }
  viewColorPicker() {
    this.emit("showColorPickerPopup", {
      target: this,
      changeEvent: (color2) => {
        this.updateData({ value: color2, color: parse(color2) });
      },
      changeEndEvent: (color2) => {
        this.updateEndData({ value: color2, color: parse(color2) });
      },
      color: this.state.value
    }, null, this.$el.rect());
  }
  [CLICK("$remove")]() {
    this.updateData({ value: "" });
  }
  [INPUT("$el .color-input input")](e) {
    var color2 = e.$dt.value;
    this.updateData({
      value: color2,
      color: parse(color2)
    });
    this.refreshColorView();
  }
  [INPUT("$el .opacity-input input")](e) {
    var opacity2 = +e.$dt.value;
    opacity2 = Math.max(0, Math.min(100, opacity2));
    const color2 = parse(this.state.value);
    color2.a = round(opacity2 / 100, 1e3);
    const value = format(color2, color2.type);
    this.updateData({
      value,
      color: color2
    });
    this.refreshColorView();
  }
}
var ComponentEditor$1 = "";
class ComponentEditor extends EditorElement {
  initState() {
    return {
      inspector: this.props.inspector
    };
  }
  template() {
    return `
      <div ref='$body' class="component-editor"></div>
    `;
  }
  getPropertyEditor(index2, childEditor) {
    if (childEditor.type === "folder") {
      return `
        <div class='component-folder'>
          <label>${iconUse("chevron_right")} ${childEditor.label}</label>
          <ul>
            ${childEditor.children.map((it, itemIndex) => {
        return `<li>${this.getPropertyEditor(`${index2}${itemIndex}`, it)}</li>`;
      }).join("")}
          </ul>
        </div>
      `;
    } else if (childEditor.type === "column") {
      const size2 = (childEditor.size || [2]).join("-");
      return `
        <div class='column column-${size2}' style="--column-gap: ${childEditor.gap || 0}px; --row-gap: ${childEditor.rowGap || 0}px" >
          ${childEditor.columns.map((it, itemIndex) => {
        if (it === "-") {
          return `<div class="column-item"></div>`;
        } else if (it.type === "label") {
          return `<div class="column-item">
                    <label>${it.label}</label>
                  </div>`;
        }
        return `
                  <div class='column-item'>
                    ${this.getPropertyEditor(`${index2}${itemIndex}`, it)}
                  </div>
                `;
      }).join("")}  
        </div>
      `;
    }
    return createComponent(childEditor.editor, __spreadProps(__spreadValues({}, childEditor.editorOptions), {
      onchange: (key, value) => {
        const newValue = isFunction(childEditor.convert) ? childEditor.convert(key, value) : value;
        this.trigger("changeComponentValue", key, newValue);
      },
      ref: `${childEditor.key}${index2}`,
      key: childEditor.key,
      value: childEditor.defaultValue
    }));
  }
  [LOAD("$body")]() {
    const inspector = this.state.inspector;
    var self2 = inspector.map((it, index2) => {
      if (isString(it) || it.type === "label") {
        const title2 = it.label || it;
        return `
          <div class='component-item'> 
            <label>${title2}</label>
          </div>`;
      } else if (it.type === "folder") {
        return `
          <div class='component-item'>
            ${this.getPropertyEditor(index2, it)}
          </div>
        `;
      } else {
        return `
            <div class='component-item'> 
              ${this.getPropertyEditor(index2, it)}
            </div>
          `;
      }
    });
    return self2;
  }
  setInspector(inspector) {
    this.setState({
      inspector
    });
  }
  setValue(obj2 = {}) {
    Object.keys(obj2).forEach((key) => {
      const value = obj2[key];
      this.eachChildren((child) => {
        if (child.setValue && child.props.key === key) {
          child.setValue(value);
        }
      });
    });
  }
  getValue() {
    const result = {};
    this.eachChildren((child) => {
      if (isFunction(child.getValue) && child.props.key) {
        result[child.props.key] = child.getValue();
      }
    });
    return result;
  }
  [SUBSCRIBE_SELF("changeComponentValue")](key, value) {
    this.parent.trigger(this.props.onchange, key, value);
  }
  [CLICK("$el .component-folder > label")](e) {
    const $target = e.$dt.closest("component-folder");
    $target.toggleClass("close");
  }
}
var CSSPropertyEditor$1 = "";
class CSSPropertyEditor extends EditorElement {
  initState() {
    return {
      hideTitle: this.props["hide-title"] === "true",
      hideRefresh: this.props["hide-refresh"] === "true",
      properties: []
    };
  }
  updateData(opt) {
    this.setState(opt, false);
    this.modifyProperty();
  }
  modifyProperty() {
    this.parent.trigger(this.props.onchange, this.state.properties);
  }
  template() {
    const hideTitleClass = this.state.hideTitle ? "hide-title" : "";
    const hideRefreshClass = this.state.hideRefresh ? "hide-refresh" : "";
    return `
      <div class='elf--css-property-editor ${hideTitleClass} ${hideRefreshClass}'>
        <div class='title'>
          <label>${this.$i18n("css.property.editor.properties")}</label>
          <div class='tools'>
            ${this.makePropertySelect()}
            <button type="button" ref='$addProperty'>${obj$3.add}</button>
          </div>
        </div>
        <div class='input grid-1 css-property-list' ref='$property'></div>
      </div>
    `;
  }
  getPropertyDefaultValue(key) {
    switch (key) {
      case "animation-timing-function":
      case "box-shadow":
      case "text-shadow":
      case "color":
      case "background-image":
      case "background-color":
      case "text-fill-color":
      case "text-stroke-color":
      case "filter":
      case "backdrop-filter":
      case "var":
      case "transform":
      case "transform-origin":
      case "perspective-origin":
      case "playTime":
        return Length.string("");
      case "offset-distance":
        return Length.percent(0);
      case "rotate":
        return Length.deg(0);
      case "mix-blend-mode":
        return "normal";
      case "clip-path":
        return "";
      case "opacity":
        return 1;
      default:
        return 0;
    }
  }
  [CLICK("$addProperty")]() {
    var key = this.getRef("$propertySelect").value;
    var searchItem = this.state.properties.find((it) => {
      return it.key === key;
    });
    if (searchItem) {
      window.alert(`${key} is already added.`);
      return;
    }
    var value = this.getPropertyDefaultValue(key);
    var current = this.$context.selection.current;
    if (current) {
      value = current[key];
    }
    this.state.properties.push({ key, value });
    this.refresh();
    this.modifyProperty();
  }
  makeIndivisualPropertyColorEditor(property, index2) {
    var key = property.key.split("-").join("");
    return `
      <div class='property-editor'>
        <object refClass="ColorViewEditor" ref='$${key}${index2}' value="${property.value}" key="${property.key}" onChange="changeColorProperty" />
      </div>
    `;
  }
  makeCustomePropertyEditor(property, index2) {
    return `
      <div class='property-editor'>
        ${createComponent(property.editor, {
      onchange: "changeSelect",
      ref: `$customProperty${index2}`,
      key: property.key,
      value: property.value
    })}
      </div>
    `;
  }
  makeIndivisualPropertyEditor(property, index2) {
    if (property.key === "background-image") {
      return `
        <div class='property-editor'>
          ${createComponent("BackgroundImageEditor", {
        ref: `$backgroundImage${index2}`,
        key: property.key,
        "hide-title": this.state.hideTitle,
        value: property.value,
        onchange: "changeKeyValue"
      })}
        </div>
      `;
    } else if (property.key === "filter") {
      return `
        <div class='property-editor'>
          <object refClass="FilterEditor" ref='$filter${index2}' key="${property.key}" value="${property.value}" onChange="changeKeyValue" />
        </div>
      `;
    } else if (property.key === "backdrop-filter") {
      return `
        <div class='property-editor'>
          <object refClass="FilterEditor" ref='$backdropFilter${index2}' key="${property.key}" value="${property.value}" onChange="changeKeyValue" />
        </div>
      `;
    } else if (property.key === "box-shadow") {
      return `
        <div class='property-editor'>
          <object refClass="BoxShadowEditor" ref='$boxshadow${index2}' value="${property.value}" hide-label="false" onChange="changeBoxShadowProperty" />
        </div>
      `;
    } else if (property.key === "text-shadow") {
      return `
        <div class='property-editor'>
          <object refClass="TextShadowEditor" ref='$textshadow${index2}' value="${property.value}" hide-label="false" onChange="changeTextShadowProperty" />
        </div>
      `;
    } else if (property.key === "var") {
      return `
        <div class='property-editor'>
          <object refClass="VarEditor" ref='$var${index2}' value="${property.value}" onChange="changeVar" />
        </div>
      `;
    } else if (property.key === "transform") {
      return `
        <div class='property-editor'>
          <object refClass="TransformEditor" ref='$transform${index2}' value="${property.value}" onChange="changeTransform" />
        </div>
      `;
    } else if (property.key === "transform-origin") {
      return `
        <div class='property-editor'>
          <object refClass="TransformOriginEditor" ref='$transformOrigin${index2}' value="${property.value}" onChange="changeTransformOrigin" />
        </div>
      `;
    } else if (property.key === "perspective-origin") {
      return `
        <div class='property-editor'>
          <object refClass="PerspectiveOriginEditor" ref='$perspectiveOrigin${index2}' value="${property.value}" onChange="changePerspectiveOrigin" />
        </div>
      `;
    } else if (property.key === "fill-rule") {
      return `
        <div class='property-editor'>
          <object refClass="SelectEditor"  
          ref='$fillRule${index2}' 
          key='fill-rule' 
          icon="true" 
          options=${variable$4(["nonzero", "evenodd"])}
          value="${property.value}"
          onchange="changeSelect" />
        </div>
      `;
    } else if (property.key === "stroke-linecap") {
      return `
        <div class='property-editor'>
          <object refClass="SelectEditor"  
          ref='$strokeLinecap${index2}' 
          key='stroke-linecap' 
          icon="true" 
          options=${variable$4(["butt", "round", "square"])}          
          value="${property.value}"
          onchange="changeSelect" />
        </div>
      `;
    } else if (property.key === "stroke-linejoin") {
      return `
        <div class='property-editor'>
          <object refClass="SelectEditor"  
          ref='$strokeLinejoin${index2}' 
          key='stroke-linejoin' 
          icon="true" 
          options=${variable$4([
        "miter",
        "arcs",
        "bevel",
        "miter-clip",
        "round"
      ])}                    
          value="${property.value}"
          onchange="changeSelect" />
        </div>
      `;
    } else if (property.key === "mix-blend-mode") {
      return `
        <div class='property-editor'>
          <object refClass="BlendSelectEditor" 
          ref='$mixBlendMode${index2}' 
          key='mix-blend-mode' 
          icon="true" 
          value="${property.value}"
          onchange="changeSelect" />
        </div>
      `;
    } else if (property.key === "stroke-dasharray") {
      return `
        <object refClass="StrokeDashArrayEditor" 
          ref='$strokeDashArray${index2}' 
          key='stroke-dasharray'
          value='${property.value}' 
          onchange='changeSelect' 
        />
      `;
    } else if (property.key === "border-radius") {
      return `
        <object refClass="BorderRadiusEditor"
          ref='$borderRadius${index2}' 
          key='border-radius'
          value='${property.value}' 
          onchange='changeBorderRadius' 
        />
      `;
    } else if (property.key === "border") {
      return `
        <object refClass="BorderEditor"
          ref='$border${index2}' 
          key='border'
          value='${property.value}' 
          onchange='changeKeyValue' 
        />
      `;
    } else if (property.key === "clip-path") {
      return `
        <object refClass="ClipPathEditor"
          ref='$clipPath${index2}' 
          key='clip-path'
          value='${property.value}' 
          onchange='changeClipPath' 
        />
      `;
    } else if (property.key === "d") {
      return `
        <object refClass="PathDataEditor" ref='$pathData${index2}' key='d' value='${property.value}' onchange='changeSelect' />
      `;
    } else if (property.key === "points") {
      return `
        <object refClass="PolygonDataEditor" ref='$polygonData${index2}' key='points' value='${property.value}' onchange='changeSelect' />
      `;
    } else if (property.key === "playTime") {
      return `
        <object refClass="MediaProgressEditor" ref='$playTime${index2}'  key='playTime' value="${property.value}" onchange="changeSelect" />      
      `;
    }
    return `
      <div class='property-editor'>
        ???

      </div>
    `;
  }
  [SUBSCRIBE_SELF("changeKeyValue")](key, value) {
    this.modifyPropertyValue(key, value);
  }
  [SUBSCRIBE_SELF("changeBorderRadius")](value) {
    this.modifyPropertyValue("border-radius", value);
  }
  [SUBSCRIBE_SELF("changeClipPath")](value) {
    this.modifyPropertyValue("clip-path", value);
  }
  [SUBSCRIBE_SELF("changeColorProperty")](key, color2) {
    this.modifyPropertyValue(key, color2);
  }
  [SUBSCRIBE_SELF("changeBackgroundImageProperty")](key, backgroundImage2) {
    this.modifyPropertyValue(key, backgroundImage2);
  }
  [SUBSCRIBE_SELF("changeFilterProperty")](filter2) {
    this.modifyPropertyValue("filter", filter2);
  }
  [SUBSCRIBE_SELF("changeBackdropFilterProperty")](filter2) {
    this.modifyPropertyValue("backdrop-filter", filter2);
  }
  [SUBSCRIBE_SELF("changeBoxShadowProperty")](boxshadow) {
    this.modifyPropertyValue("box-shadow", boxshadow);
  }
  [SUBSCRIBE_SELF("changeTextShadowProperty")](textShadow2) {
    this.modifyPropertyValue("text-shadow", textShadow2);
  }
  [SUBSCRIBE_SELF("changeVar")](value) {
    this.modifyPropertyValue("var", value);
  }
  [SUBSCRIBE_SELF("changeTransform")](value) {
    this.modifyPropertyValue("transform", value);
  }
  [SUBSCRIBE_SELF("changeTransformOrigin")](value) {
    this.modifyPropertyValue("transform-origin", value);
  }
  [SUBSCRIBE_SELF("changePerspectiveOrigin")](value) {
    this.modifyPropertyValue("perspective-origin", value);
  }
  [SUBSCRIBE_SELF("changeSelect")](key, value) {
    this.modifyPropertyValue(key, value);
  }
  makePropertyEditor(property, index2) {
    if (property.editor) {
      return this.makeCustomePropertyEditor(property, index2);
    }
    switch (property.key) {
      case "animation-timing-function":
      case "box-shadow":
      case "text-shadow":
      case "background-image":
      case "filter":
      case "backdrop-filter":
      case "var":
      case "transform":
      case "transform-origin":
      case "perspective-origin":
      case "mix-blend-mode":
      case "border":
      case "border-radius":
      case "clip-path":
      case "fill-rule":
      case "stroke-linecap":
      case "stroke-linejoin":
      case "stroke-dasharray":
      case "d":
      case "points":
      case "offset-path":
      case "playTime":
        return this.makeIndivisualPropertyEditor(property, index2);
      case "color":
      case "background-color":
      case "text-fill-color":
      case "text-stroke-color":
      case "stroke":
      case "fill":
        return this.makeIndivisualPropertyColorEditor(property, index2);
      case "opacity":
      case "fill-opacity":
      case "stroke-dashoffset":
      case "offset-distance":
        let min = 0;
        let max = 1;
        let step2 = 0.01;
        return `
          <div class='property-editor'>
            <object refClass="NumberRangeEditor"  
              ref='$opacity${index2}' 
              key='${property.key}' 
              min="${min}"
              max="${max}"
              step="${step2}"
              value="${property.value || 1}"
              selected-unit='number'
              removable="true"
              onchange="changeRangeEditor" />
          </div>
        `;
      case "rotate":
        return `
          <div class='property-editor'>
            <object refClass="RangeEditor"  
              ref='rangeEditor${index2}' 
              key='${property.key}' 
              value='${property.value}'  
              min="-2000"
              max="2000"
              units="deg" 
              onChange="changeRangeEditor" />
          </div>
        `;
      case "left":
      case "margin-top":
      case "margin-bottom":
      case "margin-left":
      case "margin-right":
      case "padding-top":
      case "padding-bottom":
      case "padding-left":
      case "padding-right":
      case "width":
      case "height":
      case "perspective":
      case "text-stroke-width":
      default:
        return `
          <div class='property-editor'>
            <object refClass="RangeEditor"  ref='rangeEditor${index2}' key='${property.key}' value='${property.value}' max="1000" onChange="changeRangeEditor" />
          </div>
        `;
    }
  }
  [SUBSCRIBE_SELF("changeRangeEditor")](key, value) {
    this.modifyPropertyValue(key, value + "");
  }
  searchKey(key, callback) {
    this.state.properties.filter((it) => it.key === key).forEach(callback);
  }
  modifyPropertyValue(key, value) {
    this.searchKey(key, (it) => {
      it.value = value;
    });
    this.modifyProperty();
  }
  makePropertySelect() {
    return `
      <select class='property-select' ref='$propertySelect'>
        <optgroup label='Position'>
          <option value='x'>x</option>
          <option value='y'>y</option>        
        </optgroup>
        <optgroup label='Size'>
          <option value='width'>width</option>
          <option value='height'>height</option>
        </optgroup>      
        <optgroup label='Box Model'>
          <option value='margin-left'>margin-left</option>
          <option value='margin-right'>margin-right</option>
          <option value='margin-bottom'>margin-bottom</option>
          <option value='margin-top'>margin-top</option>
          <option value='padding-left'>padding-left</option>
          <option value='padding-right'>padding-right</option>
          <option value='padding-bottom'>padding-bottom</option>
          <option value='padding-top'>padding-top</option>       
        </optgroup>
        <optgroup label='Border'>
          <option value='border'>border</option>
          <option value='border-radius'>border-radius</option>
        </optgroup>        
        <optgroup label='Style'>
          <option value='background-color'>background-color</option>
          <option value='background-image'>background-image</option>
          <option value='box-shadow'>box-shadow</option>
          <option value='text-shadow'>text-shadow</option>
          <option value='filter'>filter</option>      
          <option value='backdrop-filter'>backdrop-filter</option>
          <option value='mix-blend-mode'>mix-blend-mode</option>
        </optgroup>            
        <optgroup label='Transform'>
          <option value='transform'>transform</option>
          <option value='transform-origin'>transform-origin</option>
          <option value='perspective'>perspective</option>
          <option value='perspective-origin'>perspective-origin</option>
        </optgroup>
        <optgroup label='Font'>
          <option value='font-size'>font-size</option>
          <option value='font-weight'>font-weight</option>          
        </optgroup>
        <optgroup label='Animation'>
          <option value='animation-timing-function'>timing-function</option>
        </optgroup>        
      </select>
    `;
  }
  [LOAD("$property")]() {
    return this.state.properties.map((it, index2) => {
      return `
        <div class='css-property-item'>
          <div class='title'>
            <label>${it.key}</label>
            <div class='tools'>
              <button type="button" class='remove' data-index="${index2}">${obj$3.remove2}</button>
            </div>
          </div>
          <div class='title-2'>
            <div class='tools'>
              <label><button type="button" class='refresh' data-index="${index2}">${obj$3.refresh}</button> Refresh</label>
            </div>
          </div>
          <div class='value-editor'>
            ${this.makePropertyEditor(it, index2)}
          </div>
        </div>
      `;
    });
  }
  [SUBSCRIBE("showCSSPropertyEditor")](properties = []) {
    this.setState({ properties });
    this.refresh();
  }
  [CLICK("$property .remove")](e) {
    var index2 = +e.$dt.attr("data-index");
    this.state.properties.splice(index2, 1);
    this.refresh();
    this.modifyProperty();
  }
  [CLICK("$property .refresh")]() {
    this.parent.trigger("refreshPropertyValue");
  }
}
var CubicBezierEditor$1 = "";
class CubicBezierEditor extends EditorElement {
  initState() {
    return {
      key: this.props.key,
      currentBezier: getPredefinedCubicBezier(this.props.value || "linear"),
      isAnimating: isUndefined(this.props.isAnimating) ? true : Boolean(this.props.isAnimating),
      currentBezierIndex: 0,
      selectedColor: "#609de2",
      animatedColor: "#609de266",
      curveColor: "#609de2",
      baseLineColor: "rgba(117, 117, 117, 0.46)"
    };
  }
  afterRender() {
    window.setTimeout(() => {
      this.refresh();
    }, 10);
  }
  template() {
    const linearCurve = curveToPath(this.state.currentBezier, 150, 150);
    const linearCurvePoint = curveToPointLine(this.state.currentBezier, 150, 150);
    const easeCurve = curveToPath("ease", 30, 30);
    const easeCurvePoint = curveToPointLine("ease", 30, 30);
    const easeInCurve = curveToPath("ease-in", 30, 30);
    const easeInCurvePoint = curveToPointLine("ease-in", 30, 30);
    const easeOutCurve = curveToPath("ease-out", 30, 30);
    const easeOutCurvePoint = curveToPointLine("ease-out", 30, 30);
    return `
            <div class='elf--cubic-bezier-editor'>
                <div class='predefined'>
                    <div class='left' ref='$left'>${obj$3.chevron_left}</div>
                    <div class='predefined-text' ref='$text'></div>
                    <div class='right' ref='$right'>${obj$3.chevron_right}</div>
                </div>
                <div class='animation' ref='$animationArea'>
                    <canvas 
                        class='animation-canvas' 
                        ref='$animationCanvas' 
                        title='Click and Replay point animation' 
                        width='230px' 
                        height='20px'
                    ></canvas>
                </div>
                <div class='item-list' ref='$itemList' data-selected-value=''>
                    <div class='item' data-bezier='ease' title='ease'>
                        <svg class='item-canvas' width="30" height="30" viewBox="0 0 30 30">
                            <path d="${easeCurve}" stroke="white" stroke-width="1" fill='none' />
                            <path d="${easeCurvePoint}" stroke="gray" stroke-width="1" fill='none' />
                        </svg>
                    </div>
                    <div class='item' data-bezier='ease-in' title='ease-in'>
                        <svg class='item-canvas' width="30" height="30" viewBox="0 0 30 30">
                            <path d="${easeInCurve}" stroke="white" stroke-width="1" fill='none' />
                            <path d="${easeInCurvePoint}" stroke="gray" stroke-width="1" fill='none' /> 
                        </svg>
                    </div>
                    <div class='item' data-bezier='ease-out' title='ease-out'>
                        <svg class='item-canvas' width="30" height="30" viewBox="0 0 30 30">
                            <path d="${easeOutCurve}" stroke="white" stroke-width="1" fill='none' />
                            <path d="${easeOutCurvePoint}" stroke="gray" stroke-width="1" fill='none' />
                        </svg>
                    </div>
                </div>
                <div class='bezier'>
                    <svg class='bezier-canvas' width="150" height="150" viewBox="0 0 150 150" overflow="visible">
                        <path d="${linearCurve}" stroke="black" stroke-width="1" fill='none' ref='$bezierCanvas' />
                        <path d="${linearCurvePoint}" stroke="gray" stroke-width="1" fill='none' ref='$bezierCanvasPoint' />
                    </svg>                
                    <div class='control' ref='$control'>
                        <div class='pointer1' ref='$pointer1'></div>
                        <div class='pointer2' ref='$pointer2'></div>
                    </div>
                </div>
            </div>
        `;
  }
  [BIND("$animationArea")]() {
    return {
      style: {
        display: this.state.isAnimating ? "block" : "none"
      }
    };
  }
  [BIND("$bezierCanvas")]() {
    return {
      d: curveToPath(this.state.currentBezier, 150, 150)
    };
  }
  [BIND("$bezierCanvasPoint")]() {
    return {
      d: curveToPointLine(this.state.currentBezier, 150, 150)
    };
  }
  updateData(opt = {}) {
    this.setState(opt);
    this.modifyCubicBezier();
  }
  modifyCubicBezier() {
    this.parent.trigger(this.props.onchange, this.state.key, formatCubicBezier(this.state.currentBezier));
  }
  [CLICK("$left")]() {
    var { currentBezier, currentBezierIndex } = this.state;
    if (currentBezierIndex == 0) {
      currentBezierIndex = bezierList.length - 1;
    } else {
      --currentBezierIndex;
    }
    var currentBezier = bezierList[currentBezierIndex];
    this.updateData({ currentBezierIndex, currentBezier });
    this.refresh();
  }
  [CLICK("$right")]() {
    var { currentBezier, currentBezierIndex } = this.state;
    currentBezierIndex = ++currentBezierIndex % bezierList.length;
    currentBezier = bezierList[currentBezierIndex];
    this.updateData({ currentBezierIndex, currentBezier });
    this.refresh();
  }
  [CLICK("$text")]() {
    var currentBezier = [...bezierList[this.state.currentBezierIndex]];
    this.updateData({ currentBezier });
    this.refresh();
  }
  [CLICK("$itemList .item")](e) {
    var bezierString = e.$dt.attr("data-bezier");
    this.refs.$itemList.attr("data-selected-value", bezierString);
    var currentBezier = getPredefinedCubicBezier(bezierString);
    this.updateData({
      currentBezier
    });
    this.refresh();
  }
  refresh() {
    this.refreshEasingText();
    this.refreshBezierCanvas();
  }
  refreshBezierCanvas() {
    this.bindData("$bezierCanvas");
    this.bindData("$bezierCanvasPoint");
    this.refreshPointer();
    this.drawPoint();
  }
  refreshEasingText() {
    this.refs.$text.html(this.state.currentBezier[4] || "ease");
  }
  refreshPointer() {
    var currentBezier = getPredefinedCubicBezier(this.state.currentBezier);
    var width2 = this.refs.$control.width();
    var height2 = this.refs.$control.height();
    var left2 = currentBezier[0] * width2;
    var top2 = (1 - currentBezier[1]) * height2;
    this.refs.$pointer1.css({
      left: Length.px(left2),
      top: Length.px(top2)
    });
    left2 = currentBezier[2] * width2;
    top2 = (1 - currentBezier[3]) * height2;
    this.refs.$pointer2.css({
      left: Length.px(left2),
      top: Length.px(top2)
    });
  }
  drawPoint() {
    if (this.state.isAnimating === false)
      return;
    if (this.timer)
      window.clearTimeout(this.timer);
    if (this.animationTimer)
      window.clearTimeout(this.animationTimer);
    this.timer = window.setTimeout(() => {
      this.animationPoint();
    }, 100);
  }
  start(i) {
    var pos = this.animationCanvasData.func(i);
    var x = 10 + (this.animationCanvasData.width - 20) * pos.y;
    var y = 10;
    var context = this.animationCanvasData.context;
    context.beginPath();
    context.arc(x, y, 5, 0, 2 * Math.PI);
    context.fill();
    context.stroke();
    context.closePath();
    if (i >= 1) {
      return;
    }
    this.animationTimer = window.setTimeout(() => {
      this.start(i + 0.05);
    }, 50);
  }
  animationPoint() {
    const currentBezier = getPredefinedCubicBezier(this.state.currentBezier);
    var func = createBezierForPattern(formatCubicBezier(currentBezier));
    this.refs.$animationCanvas.clear();
    var width2 = this.refs.$animationCanvas.width();
    var height2 = this.refs.$animationCanvas.height();
    var context = this.refs.$animationCanvas.context();
    context.fillStyle = this.state.animatedColor;
    context.strokeStyle = this.state.selectedColor;
    context.lineWidth = 1;
    this.animationCanvasData = {
      func,
      width: width2,
      height: height2,
      context
    };
    this.start(0);
  }
  setPosition(e) {
    var width2 = this.refs.$control.width();
    var height2 = this.refs.$control.height();
    var minX = this.refs.$control.offset().left;
    var minY = this.refs.$control.offset().top;
    var p = e;
    var x = p.x;
    if (0 > x) {
      x = 0;
    } else if (p.x > document.body.clientWidth) {
      x = document.body.clientWidth;
    }
    x -= minX;
    if (x < 0) {
      x = 0;
    }
    if (width2 < x) {
      x = width2;
    }
    var y = p.y;
    y -= minY;
    return {
      x: div(x, width2),
      y: y == height2 ? 0 : div(height2 - y, height2)
    };
  }
  [POINTERSTART("$pointer1") + MOVE("movePointer1") + END("drawPoint")](e) {
    this.clientX = e.clientX;
    this.clientY = e.clientY;
  }
  movePointer1(dx, dy) {
    var pos = this.setPosition({
      x: this.clientX + dx,
      y: this.clientY + dy
    });
    this.state.currentBezier[0] = pos.x;
    this.state.currentBezier[1] = pos.y;
    this.refreshBezierCanvas();
    this.modifyCubicBezier();
  }
  [POINTERSTART("$pointer2") + MOVE("movePointer2") + END("drawPoint")](e) {
    this.clientX = e.clientX;
    this.clientY = e.clientY;
  }
  movePointer2(dx, dy) {
    var pos = this.setPosition({
      x: this.clientX + dx,
      y: this.clientY + dy
    });
    this.state.currentBezier[2] = pos.x;
    this.state.currentBezier[3] = pos.y;
    this.refreshBezierCanvas();
    this.modifyCubicBezier();
  }
  [SUBSCRIBE("showCubicBezierEditor")](timingFunction) {
    var currentBezier = getPredefinedCubicBezier(timingFunction || this.state.currentBezier);
    this.setState({ currentBezier });
    this.refresh();
  }
}
var DirectionEditor$1 = "";
class DirectionLength {
  static parse(str) {
    var temp = str.split(" ").filter((it) => it.trim()).map((it) => Length.parse(it));
    var top2 = Length.percent(0), right2 = Length.percent(0), bottom2 = Length.percent(0), left2 = Length.percent(0);
    if (temp.length === 1) {
      top2 = temp[0].clone();
      right2 = temp[0].clone();
      bottom2 = temp[0].clone();
      left2 = temp[0].clone();
    } else if (temp.length === 2) {
      top2 = temp[0].clone();
      right2 = temp[1].clone();
      bottom2 = temp[0].clone();
      left2 = temp[1].clone();
    } else if (temp.length === 3) {
      top2 = temp[0].clone();
      right2 = temp[1].clone();
      bottom2 = temp[2].clone();
      left2 = temp[1].clone();
    } else if (temp.length === 4) {
      top2 = temp[0].clone();
      right2 = temp[1].clone();
      bottom2 = temp[2].clone();
      left2 = temp[3].clone();
    }
    return [temp.length, top2, right2, bottom2, left2];
  }
}
const typeList$2 = [
  { key: "top", title: "Top" },
  { key: "right", title: "Right" },
  { key: "bottom", title: "Bottom" },
  { key: "left", title: "Left" }
];
class DirectionEditor extends EditorElement {
  initState() {
    var [count, top2, right2, bottom2, left2] = DirectionLength.parse(this.props.value);
    return {
      isAll: count === 1,
      all: top2.clone(),
      top: top2.clone(),
      right: right2.clone(),
      bottom: bottom2.clone(),
      left: left2.clone()
    };
  }
  template() {
    return `<div class='elf--direction-editor' ref='$body'></div>`;
  }
  [SUBSCRIBE("changeBorderRadius")](key, value) {
    if (key === "all") {
      typeList$2.forEach((it) => {
        this.state[it.key] = value.clone();
        this.children[`$${it.key}`].setValue(value.clone());
      });
    }
    this.updateData({
      [key]: value
    });
  }
  [LOAD("$body")]() {
    var selectedValue = this.state.isAll ? "all" : "partitial";
    var direction2 = this.state.all;
    var display = selectedValue === "all" ? "display:none" : "display:block";
    return `
      <div class="property-item direction-item">
        <div class="radius-selector" data-selected-value="${selectedValue}" ref="$selector">
          <button type="button" data-value="all">${obj$3.border_all}</button>
          <button type="button" data-value="partitial">
            ${obj$3.border_inner}
          </button>
        </div>
        <div class="radius-value">
          ${createComponent("RangeEditor", {
      ref: "$all",
      key: "all",
      value: direction2,
      onchange: "changeBorderRadius"
    })}
        </div>
      </div>
      <div
        class="property-item full direction-item"
        ref="$partitialSetting"
        style="${display}"
      >
        <div class="radius-setting-box">
          ${typeList$2.map((it) => {
      var value = this.state[it.key];
      return `
              <div>
                  ${createComponent("RangeEditor", {
        ref: `$${it.key}`,
        label: it.title,
        key: it.key,
        value,
        onchange: "changeBorderRadius"
      })}
              </div>  
            `;
    }).join("")}
        </div>
      </div>
    `;
  }
  updateData(opt = {}) {
    this.setState(opt, false);
    var value = [];
    if (this.state.isAll) {
      value = [
        1,
        this.state.all,
        this.state.all,
        this.state.all,
        this.state.all
      ];
    } else {
      value = [
        4,
        this.state.top,
        this.state.right,
        this.state.bottom,
        this.state.left
      ];
    }
    this.parent.trigger(this.props.onchange, value);
  }
  [CLICK("$selector button")](e) {
    var type = e.$dt.attr("data-value");
    this.refs.$selector.attr("data-selected-value", type);
    if (type === "all") {
      this.refs.$partitialSetting.hide();
    } else {
      this.refs.$partitialSetting.show("grid");
    }
    this.updateData({
      isAll: type === "all"
    });
  }
}
var FilterEditor$1 = "";
const FILTER_REG = /((blur|grayscale|drop-shadow|hue-rotate|invert|brightness|contrast|opacity|saturate|sepia|url)\(([^)]*)\))/gi;
class Filter extends PropertyItem {
  getDefaultObject(obj2 = {}) {
    return super.getDefaultObject(__spreadValues({
      itemType: "filter"
    }, obj2));
  }
  toString() {
    return `${this.json.type}(${this.json.value || ""})`;
  }
  static parse(obj2) {
    var FilterClass = FilterClassName[obj2.type];
    if (FilterClass) {
      return new FilterClass(obj2);
    } else {
      return new URLSvgFilter({
        value: obj2.value
      });
    }
  }
  static parseStyle(filter2) {
    var filters = [];
    if (!filter2)
      return filters;
    var results = convertMatches(filter2);
    var matches2 = results.str.match(FILTER_REG) || [];
    matches2.forEach((value, index2) => {
      var [filterName, filterValue] = value.split("(");
      filterValue = filterValue.split(")")[0];
      if (filterName === "drop-shadow") {
        var arr = filterValue.split(" ");
        var colors2 = arr.filter((it) => it.includes("@")).map((it) => {
          return reverseMatches(it, results.matches);
        });
        var values = arr.filter((it) => !it.includes("@"));
        filters[index2] = Filter.parse({
          type: filterName,
          offsetX: Length.parse(values[0]),
          offsetY: Length.parse(values[1]),
          blurRadius: Length.parse(values[2]),
          color: colors2[0] || "rgba(0, 0, 0, 1)"
        });
      } else {
        filters[index2] = Filter.parse({
          type: filterName,
          value: Length.parse(filterValue)
        });
      }
    });
    return filters;
  }
  static join(list2) {
    return list2.map((it) => Filter.parse(it)).join(" ");
  }
}
class BlurFilter extends Filter {
  getDefaultObject() {
    return super.getDefaultObject({
      type: "blur",
      value: BlurFilter.spec.defaultValue
    });
  }
  toCloneObject() {
    return __spreadValues(__spreadValues({}, super.toCloneObject()), this.attrs("value"));
  }
}
BlurFilter.spec = {
  inputType: "range",
  min: 0,
  max: 100,
  step: 1,
  unit: "px",
  units: ["px", "em"],
  defaultValue: "0px"
};
class URLSvgFilter extends Filter {
  getDefaultObject() {
    return super.getDefaultObject({
      type: "svg",
      value: URLSvgFilter.spec.defaultValue
    });
  }
  toCloneObject() {
    return __spreadValues(__spreadValues({}, super.toCloneObject()), this.attrs("value"));
  }
  toString() {
    return `url(#${this.json.value || ""})`;
  }
}
URLSvgFilter.spec = {
  inputType: "select",
  defaultValue: ""
};
class GrayscaleFilter extends Filter {
  getDefaultObject() {
    return super.getDefaultObject({
      type: "grayscale",
      value: GrayscaleFilter.spec.defaultValue
    });
  }
  toCloneObject() {
    return __spreadValues(__spreadValues({}, super.toCloneObject()), this.attrs("value"));
  }
}
GrayscaleFilter.spec = {
  inputType: "range",
  min: 0,
  max: 100,
  step: 1,
  unit: "%",
  units: ["%"],
  defaultValue: Length.percent(0)
};
class HueRotateFilter extends Filter {
  getDefaultObject() {
    return super.getDefaultObject({
      type: "hue-rotate",
      value: HueRotateFilter.spec.defaultValue
    });
  }
}
HueRotateFilter.spec = {
  inputType: "range",
  min: 0,
  max: 360,
  step: 1,
  unit: "deg",
  units: ["deg"],
  defaultValue: Length.deg(0)
};
class InvertFilter extends Filter {
  getDefaultObject() {
    return super.getDefaultObject({
      type: "invert",
      value: InvertFilter.spec.defaultValue
    });
  }
}
InvertFilter.spec = {
  inputType: "range",
  min: 0,
  max: 100,
  step: 1,
  unit: "%",
  units: ["%"],
  defaultValue: Length.percent(0)
};
class BrightnessFilter extends Filter {
  getDefaultObject() {
    return super.getDefaultObject({
      type: "brightness",
      value: BrightnessFilter.spec.defaultValue
    });
  }
}
BrightnessFilter.spec = {
  inputType: "range",
  min: 0,
  max: 200,
  step: 1,
  unit: "%",
  units: ["%"],
  defaultValue: Length.percent(100)
};
class ContrastFilter extends Filter {
  getDefaultObject() {
    return super.getDefaultObject({
      type: "contrast",
      value: ContrastFilter.spec.defaultValue
    });
  }
}
ContrastFilter.spec = {
  inputType: "range",
  min: 0,
  max: 200,
  step: 1,
  unit: "%",
  units: ["%"],
  defaultValue: Length.percent(100)
};
class OpacityFilter extends Filter {
  getDefaultObject() {
    return super.getDefaultObject({
      type: "opacity",
      value: OpacityFilter.spec.defaultValue
    });
  }
}
OpacityFilter.spec = {
  inputType: "range",
  min: 0,
  max: 100,
  step: 1,
  unit: "%",
  units: ["%"],
  defaultValue: Length.percent(100)
};
class SaturateFilter extends Filter {
  getDefaultObject() {
    return super.getDefaultObject({
      type: "saturate",
      value: SaturateFilter.spec.defaultValue
    });
  }
}
SaturateFilter.spec = {
  inputType: "range",
  min: 0,
  max: 100,
  step: 1,
  unit: "%",
  units: ["%"],
  defaultValue: Length.percent(100)
};
class SepiaFilter extends Filter {
  getDefaultObject() {
    return super.getDefaultObject({
      type: "sepia",
      value: SepiaFilter.spec.defaultValue
    });
  }
}
SepiaFilter.spec = {
  inputType: "range",
  min: 0,
  max: 100,
  step: 1,
  unit: "%",
  units: ["%"],
  defaultValue: Length.percent(0)
};
class DropshadowFilter extends Filter {
  getDefaultObject() {
    return super.getDefaultObject({
      type: "drop-shadow",
      multi: true,
      offsetX: DropshadowFilter.spec.offsetX.defaultValue,
      offsetY: DropshadowFilter.spec.offsetY.defaultValue,
      blurRadius: DropshadowFilter.spec.blurRadius.defaultValue,
      color: DropshadowFilter.spec.color.defaultValue
    });
  }
  toString() {
    var json = this.json;
    return `drop-shadow(${json.offsetX} ${json.offsetY} ${json.blurRadius} ${json.color})`;
  }
}
DropshadowFilter.spec = {
  offsetX: {
    title: "Offset X",
    inputType: "range",
    min: -100,
    max: 100,
    step: 1,
    defaultValue: "0px",
    unit: "px",
    units: ["px", "em"]
  },
  offsetY: {
    title: "Offset Y",
    inputType: "range",
    min: -100,
    max: 100,
    step: 1,
    defaultValue: "0px",
    unit: "px",
    units: ["px", "em"]
  },
  blurRadius: {
    title: "Blur Radius",
    inputType: "range",
    min: 0,
    max: 100,
    step: 1,
    defaultValue: "0px",
    unit: "px",
    units: ["px", "em", "%"]
  },
  color: {
    title: "Color",
    inputType: "color",
    defaultValue: "rgba(0, 0, 0, 1)",
    unit: "color"
  }
};
const FilterClassName = {
  blur: BlurFilter,
  grayscale: GrayscaleFilter,
  "hue-rotate": HueRotateFilter,
  invert: InvertFilter,
  brightness: BrightnessFilter,
  contrast: ContrastFilter,
  opacity: OpacityFilter,
  saturate: SaturateFilter,
  sepia: SepiaFilter,
  "drop-shadow": DropshadowFilter,
  svg: URLSvgFilter
};
const filter_list$2 = [
  "blur",
  "grayscale",
  "hue-rotate",
  "invert",
  "brightness",
  "contrast",
  "drop-shadow",
  "opacity",
  "saturate",
  "sepia",
  "svg"
];
var specList = {
  blur: BlurFilter.spec,
  grayscale: GrayscaleFilter.spec,
  "hue-rotate": HueRotateFilter.spec,
  invert: InvertFilter.spec,
  brightness: BrightnessFilter.spec,
  contrast: ContrastFilter.spec,
  "drop-shadow": DropshadowFilter.spec,
  opacity: OpacityFilter.spec,
  saturate: SaturateFilter.spec,
  sepia: SepiaFilter.spec,
  svg: URLSvgFilter.spec
};
class FilterEditor extends EditorElement {
  initState() {
    return {
      hideLabel: this.props.hideLabel === "true" ? true : false,
      filters: Filter.parseStyle(this.props.value)
    };
  }
  template() {
    return `
      <div class='elf--filter-editor filter-list'>
          <div class='filter-list' ref='$filterList'></div>
      </div>`;
  }
  [LOAD("$filterSelect")]() {
    var list2 = filter_list$2.map((it) => {
      return { title: it, value: it };
    });
    var svgFilterList = this.getSVGFilterList();
    var totalList = [];
    if (svgFilterList.length) {
      totalList = [...list2, { title: "-------", value: "" }, ...svgFilterList];
    } else {
      totalList = [...list2];
    }
    return totalList.map((it) => {
      var { title: title2, value } = it;
      return `<option value='${value}'>${title2}</option>`;
    });
  }
  getSpec(filterType) {
    return specList[filterType];
  }
  makeDropShadowFilterTemplate(spec, filter2, index2) {
    return `
      <div class="filter-item">
        <div class="title drop-shadow">
          <label draggable="true"  data-index="${index2}">${iconUse("drag_indicator")}</label>
          <span class='sub-title'>${this.$i18n("filter.property.drop-shadow")}</span>
          <div class="filter-menu">
            <button type="button" class="del" data-index="${index2}">${iconUse("remove2")}</button>
          </div>
        </div>
        <div class="filter-ui-list">
          ${createComponentList([
      "ColorViewEditor",
      {
        ref: `$dropShadowColorView${index2}`,
        params: index2,
        compact: true,
        value: filter2.color,
        onchange: "changeDropShadowColor"
      }
    ], ...["offsetX", "offsetY", "blurRadius"].map((key) => {
      return [
        "InputRangeEditor",
        {
          ref: `$${key}${index2}`,
          label: this.$i18n(`filter.property.drop-shadow.${key}`),
          key: index2,
          min: spec[key].min,
          max: spec[key].max,
          step: spec[key].step,
          params: key,
          value: filter2[key].value || spec[key].defaultValue,
          units: spec[key].units,
          onchange: "changeRangeEditor"
        }
      ];
    }))}
        </div>

      </div>
    `;
  }
  getSVGFilterList() {
    var current = this.$context.selection.current;
    var arr = [];
    if (current) {
      arr = current.svgfilters.map((it) => {
        return {
          title: `svg - #${it.id}`,
          value: it.id
        };
      });
    }
    return arr;
  }
  makeOneFilterEditor(index2, filter2, spec) {
    if (filter2.type === "svg") {
      var options2 = "";
      var current = this.$context.selection.current;
      if (current) {
        options2 = current.svgfilters.map((it) => {
          return { value: it.id };
        });
      }
      return createComponent("SelectEditor", {
        ref: `$select${index2}`,
        key: index2,
        label: "SVG Filter",
        value: filter2.value,
        options: ["", ...options2],
        onchange: "changeRangeEditor"
      });
    }
    return createComponent("InputRangeEditor", {
      ref: `$range${index2}_${filter2.type}`,
      label: this.$i18n("filter.property." + filter2.type),
      key: index2,
      min: spec.min,
      max: spec.max,
      value: filter2.value,
      units: spec.units,
      onchange: "changeRangeEditor"
    });
  }
  makeOneFilterTemplate(spec, filter2, index2) {
    return `
      <div class="filter-item" data-index="${index2}">
        <div class="title" >
          <label draggable="true" data-index="${index2}">${iconUse("drag_indicator")}</label>
          ${filter2.type != "svg" ? `
          <div class="filter-ui">
            ${this.makeOneFilterEditor(index2, filter2, spec)}
          </div>
        ` : `
          <div>
            <span class='svg-filter-edit' data-index="${index2}">${filter2.value}</span>
          </div>
        `}          
          <div class="filter-menu">
            <button type="button" class="del" data-index="${index2}">
              ${iconUse("remove2")}
            </button>
          </div>
        </div>
      </div>
    `;
  }
  makeFilterTemplate(filter2, index2) {
    if (filter2.type === "drop-shadow") {
      return this.makeDropShadowFilterTemplate(this.getSpec(filter2.type), filter2, index2);
    } else {
      return this.makeOneFilterTemplate(this.getSpec(filter2.type), filter2, index2);
    }
  }
  [LOAD("$filterList")]() {
    return this.state.filters.map((filter2, index2) => {
      return this.makeFilterTemplate(filter2, index2.toString());
    });
  }
  [DRAGSTART("$filterList .filter-item > .title > label")](e) {
    this.startIndex = +e.$dt.attr("data-index");
  }
  [DRAGOVER("$filterList .filter-item > .title > label") + PREVENT]() {
  }
  sortItem(arr, startIndex, targetIndex) {
    arr.splice(targetIndex + (startIndex < targetIndex ? -1 : 0), 0, ...arr.splice(startIndex, 1));
  }
  sortFilter(startIndex, targetIndex) {
    this.sortItem(this.state.filters, startIndex, targetIndex);
  }
  [DROP("$filterList .filter-item") + PREVENT](e) {
    var targetIndex = +e.$dt.attr("data-index");
    var current = this.$context.selection.current;
    if (!current)
      return;
    this.sortFilter(this.startIndex, targetIndex);
    this.refresh();
    this.modifyFilter();
  }
  modifyFilter() {
    var value = this.state.filters.join(" ");
    this.parent.trigger(this.props.onchange, this.props.key, value, this.props.params);
  }
  makeFilter(type, opt = {}) {
    return Filter.parse(__spreadProps(__spreadValues({}, opt), { type }));
  }
  [CLICK("$filterList .svg-filter-edit")](e) {
    var _a, _b;
    var index2 = +e.$dt.attr("data-index");
    var filter2 = this.state.filters[index2];
    var current = this.$context.selection.current;
    if (current) {
      var svgfilterIndex = current.getSVGFilterIndex((_b = (_a = filter2.value) == null ? void 0 : _a.value) == null ? void 0 : _b.replace("#", ""));
      this.trigger("openSVGFilterPopup", svgfilterIndex);
    }
  }
  [SUBSCRIBE("openSVGFilterPopup")](index2) {
    const current = this.$context.selection.current || { svgfilters: [] };
    const svgfilter = current.svgfilters[index2];
    this.emit("showSVGFilterPopup", {
      changeEvent: (params) => {
        var current2 = this.$context.selection.current;
        if (current2) {
          current2.setSVGFilterValue(params.index, {
            filters: params.filters
          });
          this.$commands.executeCommand("setAttribute", "change filter", this.$context.selection.pack("svgfilters", "filter"));
        }
      },
      index: index2,
      preview: false,
      filters: svgfilter.filters
    });
  }
  [SUBSCRIBE_SELF("add")](filterType) {
    if (filterType === "svg") {
      const index2 = this.$context.selection.current.createSVGFilter({
        filters: []
      });
      const filter2 = this.$context.selection.current.svgfilters[index2];
      this.state.filters.push(this.makeFilter(filterType, {
        value: filter2.id
      }));
      this.refresh();
      this.modifyFilter();
      this.trigger("openSVGFilterPopup", index2);
    } else {
      this.state.filters.push(this.makeFilter(filterType));
      this.refresh();
      this.modifyFilter();
    }
  }
  [CLICK("$add")]() {
    var filterType = this.refs.$filterSelect.value;
    this.trigger("add", filterType);
  }
  [CLICK("$filterList .filter-menu .del")](e) {
    var index2 = +e.$dt.attr("data-index");
    this.state.filters.splice(index2, 1);
    this.refresh();
    this.modifyFilter();
  }
  [SUBSCRIBE_SELF("changeDropShadowColor")](key, color2, params) {
    var index2 = +params;
    this.state.filters[index2].reset({
      color: color2
    });
    this.modifyFilter();
  }
  [SUBSCRIBE_SELF("changeRangeEditor")](key, value, params) {
    if (params) {
      this.state.filters[+key].reset({
        [params]: value
      });
    } else {
      this.state.filters[+key].reset({
        value
      });
    }
    this.modifyFilter();
  }
}
const font_list = [
  "",
  "Arial",
  "Arial Black",
  "Times New Roman",
  "Times",
  "Courier New",
  "Courier",
  "Verdana",
  "Georgia",
  "Palatino",
  "Garamond",
  "Bookman",
  "Tahoma",
  "Trebuchet MS",
  "Impact",
  "Comic Sans MS",
  "serif",
  "sans-serif",
  "monospace",
  "cursive",
  "fantasy",
  "system-ui"
];
class FontSelectEditor extends SelectEditor {
  getFontList() {
    return font_list.map((it) => {
      return { value: it };
    });
  }
  initState() {
    return __spreadProps(__spreadValues({}, super.initState()), {
      options: this.getFontList()
    });
  }
}
var GradientEditor$1 = "";
const CSS_FUNC_REGEXP = /(([-]?[\d.]+)(px|pt|fr|r?em|deg|vh|vw|m?s|%|g?rad|turn)?)|#(?:[\da-f]{8})|(#(?:[\da-f]{3}){1,2}|([a-z_-]+)\([^()]+\)|([a-z_-]+))|(,)/gi;
const CSS_LENGTH_REGEXP = /^[-]?([\d.]+)(px|pt|fr|r?em|deg|vh|vw|m?s|%|g?rad|turn)?$/gi;
const CSS_KEYWORD_REGEXP = /^[a-z_-]+$/gi;
const GRADIENT_LIST = [
  GradientType.STATIC,
  GradientType.LINEAR,
  GradientType.RADIAL,
  GradientType.CONIC,
  GradientType.REPEATING_CONIC,
  GradientType.REPEATING_LINEAR,
  GradientType.REPEATING_RADIAL
];
const TIMIING_LIST = [
  TimingFunction.LINEAR,
  TimingFunction.EASE,
  TimingFunction.EASE_IN,
  TimingFunction.EASE_OUT,
  TimingFunction.EASE_IN_OUT
];
const CSS_FUNC_MATCHES = (str) => {
  if (str === ",") {
    return "comma";
  } else if (str.indexOf("#") === 0) {
    return "hex";
  } else if (ColorNames.isColorName(str)) {
    return "color";
  } else if (GRADIENT_LIST.includes(str) || TIMIING_LIST.includes(str)) {
    return str;
  } else if (str.match(CSS_LENGTH_REGEXP)) {
    return "length";
  } else if (str.match(CSS_KEYWORD_REGEXP)) {
    return "keyword";
  }
};
const findFunctionEndIndex = (allString, startIndex, funcStartCharacter = "(", funcEndCharacter = ")") => {
  const result = [];
  for (var i = startIndex; i < allString.length; i++) {
    const it = allString[i];
    if (it === funcStartCharacter) {
      result.push(funcStartCharacter);
    } else if (it === funcEndCharacter) {
      result.pop();
      if (result.length === 0) {
        break;
      }
    }
  }
  if (result.length > 0) {
    return -1;
  }
  return i + 1;
};
const makeFuncType = (type) => {
  if (GRADIENT_LIST.includes(type)) {
    return FuncType.GRADIENT;
  } else if (TIMIING_LIST.includes(type)) {
    return FuncType.TIMING;
  } else if (type === "color") {
    return FuncType.COLOR;
  } else if (type === "hex") {
    return FuncType.COLOR;
  } else if (type === "length") {
    return FuncType.LENGTH;
  } else if (type === "comma") {
    return FuncType.COMMA;
  }
  return type;
};
const makeGroupFunction = (type) => (item, allString, funcStartCharacter = "(", funcEndCharacter = ")") => {
  const lastIndex = findFunctionEndIndex(allString, item.startIndex, funcStartCharacter, funcEndCharacter);
  if (lastIndex === -1) {
    return {
      convert: true,
      funcType: makeFuncType(type),
      matchedString: allString,
      type,
      startIndex: item.startIndex,
      endIndex: item.startIndex + allString.length
    };
  }
  const matchedString = allString.substring(item.startIndex, lastIndex);
  const matchedStringIndex = matchedString.indexOf(funcStartCharacter) + funcStartCharacter.length;
  const args2 = allString.substring(item.startIndex + matchedStringIndex, item.startIndex + matchedString.lastIndexOf(funcEndCharacter));
  const startIndex = item.startIndex;
  const endIndex = item.startIndex + matchedString.length;
  const newParsed = parseValue(args2).map((it) => {
    return __spreadProps(__spreadValues({}, it), {
      fullTextStartIndex: item.startIndex + matchedStringIndex + it.startIndex,
      fullTextEndIndex: item.startIndex + matchedStringIndex + it.endIndex
    });
  });
  let parameters = [];
  let commaIndex = 0;
  newParsed.forEach((it) => {
    if (it.func === FuncType.COMMA) {
      commaIndex++;
    } else {
      if (!parameters[commaIndex])
        parameters[commaIndex] = [];
      parameters[commaIndex].push(it);
    }
  });
  return {
    convert: true,
    funcType: makeFuncType(type),
    type,
    startIndex,
    endIndex,
    matchedString,
    args: args2,
    parameters
  };
};
const CSS_FUNC_PARSER_MAP = {
  length: (item) => Length.parse(item.matchedString),
  hex: (item) => __spreadValues({
    funcType: FuncType.COLOR
  }, parse(item.matchedString)),
  rgb: (item) => __spreadValues({
    funcType: FuncType.COLOR
  }, parse(item.matchedString)),
  rgba: (item) => __spreadValues({
    funcType: FuncType.COLOR
  }, parse(item.matchedString)),
  hsl: (item) => __spreadValues({
    funcType: FuncType.COLOR
  }, parse(item.matchedString)),
  hsla: (item) => __spreadValues({
    funcType: FuncType.COLOR
  }, parse(item.matchedString)),
  color: (item) => __spreadValues({
    funcType: FuncType.COLOR
  }, parse(item.matchedString)),
  steps: (item) => ({
    funcType: FuncType.TIMING,
    name: TimingFunction.STEPS,
    count: +item.parameters[0],
    direction: item.parameters[1]
  }),
  path: (item) => ({
    funcType: FuncType.TIMING,
    name: TimingFunction.PATH,
    d: item.args
  }),
  repeat: (item) => {
    return {
      funcType: FuncType.REPEAT,
      count: +item.parameters[0],
      length: Length.parse(item.parameters[1])
    };
  },
  "static-gradient": makeGroupFunction("static-gradient"),
  "linear-gradient": makeGroupFunction("linear-gradient"),
  "radial-gradient": makeGroupFunction("radial-gradient"),
  "conic-gradient": makeGroupFunction("conic-gradient"),
  "repeating-linear-gradient": makeGroupFunction("repeating-linear-gradient"),
  "repeating-radial-gradient": makeGroupFunction("repeating-radial-gradient"),
  "repeating-conic-gradient": makeGroupFunction("repeating-conic-gradient"),
  "cubic-bezier": (item) => ({
    funcType: FuncType.TIMING,
    name: TimingFunction.CUBIC_BEZIER,
    matchedString: item.matchedString,
    x1: +item.parameters[0],
    y1: +item.parameters[1],
    x2: +item.parameters[2],
    y2: +item.parameters[3]
  }),
  ease: (item) => ({
    funcType: FuncType.TIMING,
    name: TimingFunction.EASE,
    matchedString: item.matchedString,
    x1: 0.25,
    y1: 0.1,
    x2: 0.25,
    y2: 1
  }),
  "ease-in": (item) => ({
    funcType: FuncType.TIMING,
    name: TimingFunction.EASE_IN,
    matchedString: item.matchedString,
    x1: 0.42,
    y1: 0,
    x2: 1,
    y2: 1
  }),
  "ease-out": (item) => ({
    funcType: FuncType.TIMING,
    name: TimingFunction.EASE_OUT,
    matchedString: item.matchedString,
    x1: 0,
    y1: 0,
    x2: 0.58,
    y2: 1
  }),
  "ease-in-out": (item) => ({
    funcType: FuncType.TIMING,
    name: TimingFunction.EASE_IN_OUT,
    matchedString: item.matchedString,
    x1: 0.42,
    y1: 0,
    x2: 0.58,
    y2: 1
  }),
  linear: (item) => ({
    funcType: FuncType.TIMING,
    name: TimingFunction.LINEAR,
    matchedString: item.matchedString,
    x1: 0,
    y1: 0,
    x2: 1,
    y2: 1
  })
};
function parseValue(str, {
  funcStartCharacter = "(",
  funcEndCharacter = ")",
  parameterSaparator = ",",
  customFuncMap: customFuncMap2 = {}
} = {}) {
  let matches2 = str.match(CSS_FUNC_REGEXP);
  let result = [];
  if (!matches2) {
    return result;
  }
  function checkParsedResult(startIndex, endIndex, matchedString) {
    return result.some((it) => {
      if (it.parsed && isArray(it.parsed)) {
        return it.parsed.some((parsedIt) => {
          if (parsedIt.startIndex === startIndex && parsedIt.endIndex === endIndex && matchedString === parsedIt.matchedString) {
            return true;
          }
          return false;
        });
      }
      if (it.startIndex === startIndex && it.endIndex === endIndex && matchedString === it.matchedString) {
        return true;
      }
      return false;
    });
  }
  var pos = { next: 0 };
  matches2 = matches2.map((matchedString) => {
    const startIndex = str.indexOf(matchedString, pos.next);
    pos.next = startIndex + matchedString.length;
    return { index: startIndex, matchedString };
  });
  pos.next = 0;
  for (var i = 0, len2 = matches2.length; i < len2; i++) {
    const { matchedString, index: index2 } = matches2[i];
    if (index2 < pos.next)
      continue;
    let parsedFunc = CSS_FUNC_MATCHES(matchedString);
    let item = {
      matchedString
    };
    const startIndex = str.indexOf(item.matchedString, pos.next);
    if (startIndex < 0) {
      continue;
    }
    item.startIndex = startIndex;
    item.endIndex = startIndex + item.matchedString.length;
    const isContinue = checkParsedResult(item.startIndex, item.endIndex, item.matchedString);
    if (isContinue) {
      continue;
    }
    if (parsedFunc) {
      item = __spreadProps(__spreadValues({}, item), {
        func: parsedFunc
      });
    } else {
      const [func, rest] = matchedString.split(funcStartCharacter);
      const [args2] = rest.split(funcEndCharacter);
      item = __spreadProps(__spreadValues({}, item), {
        func,
        args: args2,
        parameters: args2.split(parameterSaparator).map((it) => it.trim())
      });
      parsedFunc = func;
    }
    let customFunctionCallback;
    if (CSS_FUNC_PARSER_MAP[parsedFunc]) {
      customFunctionCallback = CSS_FUNC_PARSER_MAP[parsedFunc] || CSS_FUNC_PARSER_MAP[item.matchedString];
    } else if (customFuncMap2[parsedFunc] || customFuncMap2[item.matchedString]) {
      customFunctionCallback = customFuncMap2[parsedFunc] || customFuncMap2[item.matchedString];
    }
    if (customFunctionCallback) {
      const parsed = customFunctionCallback.call(null, item, str, funcStartCharacter, funcEndCharacter, parameterSaparator);
      if (parsed == null ? void 0 : parsed.convert) {
        item = __spreadValues(__spreadValues({}, item), parsed);
        delete item.convert;
      } else {
        item = __spreadProps(__spreadValues({}, item), {
          parsed
        });
      }
    }
    result.push(item);
    pos.next = item.endIndex;
  }
  return result;
}
function parseOneValue(str) {
  return parseValue(str)[0];
}
function parseGroupValue(str, customMapFuncName = "temp") {
  var _a;
  return (_a = parseValue(`${customMapFuncName}(${str})`, {
    customFuncMap: {
      [customMapFuncName]: makeGroupFunction(customMapFuncName)
    }
  })[0]) == null ? void 0 : _a.parameters;
}
class ColorStep {
  constructor(obj2 = {}) {
    this.id = obj2.id || uuidShort();
    this.color = obj2.color || "transparent";
    this.cut = obj2.cut || false;
    this.percent = obj2.percent || 0;
    this.unit = obj2.unit || "%";
    this.px = obj2.px || 0;
    this.em = obj2.em || 0;
    this.prevColorStep = obj2.prevColorStep || null;
    this.timing = obj2.timing || parseValue("linear")[0].parsed;
    this.timingCount = obj2.timingCount || 1;
  }
  toCloneObject() {
    return {
      id: this.id,
      color: this.color,
      cut: this.cut,
      percent: this.percent,
      unit: this.unit,
      px: this.px,
      em: this.em,
      prevColorStep: this.prevColorStep,
      timing: this.timing,
      timingCount: this.timingCount
    };
  }
  on() {
    this.cut = true;
  }
  off() {
    this.cut = false;
  }
  toggle() {
    this.cut = !this.cut;
  }
  toggleTiming() {
    switch (this.timing.name) {
      case TimingFunction.LINEAR:
        this.timing = parseOneValue("steps(1, start)").parsed;
        break;
      case TimingFunction.STEPS:
        this.timing = parseOneValue("ease").parsed;
        this.timingCount = 15;
        break;
      case TimingFunction.EASE:
      case TimingFunction.EASE_IN:
      case TimingFunction.EASE_IN_OUT:
      case TimingFunction.EASE_OUT:
      case TimingFunction.CUBIC_BEZIER:
        this.timing = parseOneValue("path(M 0 0 C 0.25 0.25 0.75 0.75 1 1)").parsed;
        this.timingCount = 15;
        break;
      default:
        this.timing = parseOneValue("linear").parsed;
        this.timingCount = 1;
        break;
    }
  }
  getUnit() {
    return this.unit == "%" ? "percent" : this.unit;
  }
  add(num) {
    var unit = this.getUnit();
    this[unit] += +num;
    return this;
  }
  sub(num) {
    var unit = this.getUnit();
    this[unit] -= +num;
    return this;
  }
  mul(num) {
    var unit = this.getUnit();
    this[unit] *= +num;
    return this;
  }
  div(num) {
    var unit = this.getUnit();
    this[unit] /= +num;
    return this;
  }
  mod(num) {
    var unit = this.getUnit();
    this[unit] %= +num;
    return this;
  }
  get isPx() {
    return this.unit == "px";
  }
  get isPercent() {
    return this.unit == "%" || this.unit === "percent";
  }
  get isEm() {
    return this.unit == "em";
  }
  toLength() {
    if (this.isPx) {
      return Length.px(this.px);
    } else if (this.isPercent) {
      return Length.percent(this.percent);
    } else if (this.isEm) {
      return Length.em(this.em);
    }
  }
  getPrevLength() {
    if (!this.prevColorStep)
      return "";
    return this.prevColorStep.toLength();
  }
  toString() {
    var prev = this.cut ? this.getPrevLength() : "";
    var color2 = this.color || "transparent";
    return `${color2} ${prev} ${this.toLength()}`;
  }
  setValue(percent, maxValue) {
    if (this.isPx) {
      this.px = maxValue * percent / 100;
    } else if (this.isPercent) {
      this.percent = percent;
    } else if (this.isEm) {
      this.em = maxValue * percent / 100 / 16;
    }
    if (this.parent) {
      this.parent.sortColorStep();
    }
  }
  static parse(colorStepString) {
    let colorsteps = [];
    const results = convertMatches(colorStepString);
    var arr = results.str.split(" ").filter((it) => it.trim());
    const colorIndex = +arr[0].replace("@", "");
    const color2 = results.matches[colorIndex].color;
    if (arr.length === 1) {
      colorsteps.push(new ColorStep({
        color: color2,
        unit: "%",
        percent: 0,
        hasNotUnit: true
      }));
    } else if (arr.length === 2) {
      const len2 = Length.parse(arr[1]);
      let data = { unit: len2.unit };
      if (len2.isPercent()) {
        data.percent = len2.value;
      } else if (len2.isPx()) {
        data.px = len2.value;
      } else if (len2.isEm()) {
        data.em = len2.value;
      }
      colorsteps.push(new ColorStep(__spreadValues({ color: color2 }, data)));
    } else if (arr.length === 3) {
      const len2 = Length.parse(arr[2]);
      let data = { unit: len2.unit };
      if (len2.isPercent()) {
        data.percent = len2.value;
      } else if (len2.isPx()) {
        data.px = len2.value;
      } else if (len2.isEm()) {
        data.em = len2.value;
      }
      colorsteps.push(new ColorStep(__spreadValues({ color: color2, cut: true }, data)));
    }
    return colorsteps;
  }
  static createColorStep(maxCount = 2, maxValue = 100, unitType = "%") {
    var colorStepCount = randomNumber(2, maxCount);
    var unitValue = maxValue / colorStepCount;
    var colorsteps = repeat(colorStepCount).map((_, index2) => {
      return `${random$1()} ${index2 * unitValue}${unitType}`;
    }).join(",");
    return colorsteps;
  }
  static createRepeatColorStep(maxCount = 2, unitValue = 1) {
    var colorStepCount = randomNumber(2, maxCount);
    var colorsteps = repeat(colorStepCount).map((_, index2) => {
      return `${random$1()} ${Length.parse(unitValue).mul(index2 + 1)}`;
    }).join(",");
    return colorsteps;
  }
}
class ImageResource extends PropertyItem {
  getDefaultObject(obj2 = {}) {
    return __spreadValues({
      itemType: "image-resource",
      type: "image"
    }, obj2);
  }
  isGradient() {
    return false;
  }
  isLinear() {
    return false;
  }
  isImage() {
    return false;
  }
  hasAngle() {
    return false;
  }
  isUrl() {
    return false;
  }
  isFile() {
    return false;
  }
  isAttribute() {
    return true;
  }
  toString() {
    return "none";
  }
}
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getAugmentedNamespace(n) {
  if (n.__esModule)
    return n;
  var a = Object.defineProperty({}, "__esModule", { value: true });
  Object.keys(n).forEach(function(k) {
    var d = Object.getOwnPropertyDescriptor(n, k);
    Object.defineProperty(a, k, d.get ? d : {
      enumerable: true,
      get: function() {
        return n[k];
      }
    });
  });
  return a;
}
var fitCurve$1 = { exports: {} };
(function(module, exports) {
  (function(global2, factory) {
    {
      factory(module);
    }
  })(commonjsGlobal, function(module2) {
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    /**
     *  @preserve  JavaScript implementation of
     *  Algorithm for Automatically Fitting Digitized Curves
     *  by Philip J. Schneider
     *  "Graphics Gems", Academic Press, 1990
     *
     *  The MIT License (MIT)
     *
     *  https://github.com/soswow/fit-curves
     */
    function fitCurve2(points, maxError, progressCallback) {
      if (!Array.isArray(points)) {
        throw new TypeError("First argument should be an array");
      }
      points.forEach(function(point2) {
        if (!Array.isArray(point2) || point2.some(function(item) {
          return typeof item !== "number";
        }) || point2.length !== points[0].length) {
          throw Error("Each point should be an array of numbers. Each point should have the same amount of numbers.");
        }
      });
      points = points.filter(function(point2, i) {
        return i === 0 || !point2.every(function(val, j) {
          return val === points[i - 1][j];
        });
      });
      if (points.length < 2) {
        return [];
      }
      var len2 = points.length;
      var leftTangent = createTangent(points[1], points[0]);
      var rightTangent = createTangent(points[len2 - 2], points[len2 - 1]);
      return fitCubic(points, leftTangent, rightTangent, maxError, progressCallback);
    }
    function fitCubic(points, leftTangent, rightTangent, error, progressCallback) {
      var MaxIterations = 20;
      var bezCurve, u, uPrime, maxError, prevErr, splitPoint, prevSplit, centerVector, toCenterTangent, fromCenterTangent, beziers, dist2, i;
      if (points.length === 2) {
        dist2 = maths.vectorLen(maths.subtract(points[0], points[1])) / 3;
        bezCurve = [points[0], maths.addArrays(points[0], maths.mulItems(leftTangent, dist2)), maths.addArrays(points[1], maths.mulItems(rightTangent, dist2)), points[1]];
        return [bezCurve];
      }
      u = chordLengthParameterize(points);
      var _generateAndReport = generateAndReport(points, u, u, leftTangent, rightTangent, progressCallback);
      bezCurve = _generateAndReport[0];
      maxError = _generateAndReport[1];
      splitPoint = _generateAndReport[2];
      if (maxError === 0 || maxError < error) {
        return [bezCurve];
      }
      if (maxError < error * error) {
        uPrime = u;
        prevErr = maxError;
        prevSplit = splitPoint;
        for (i = 0; i < MaxIterations; i++) {
          uPrime = reparameterize(bezCurve, points, uPrime);
          var _generateAndReport2 = generateAndReport(points, u, uPrime, leftTangent, rightTangent, progressCallback);
          bezCurve = _generateAndReport2[0];
          maxError = _generateAndReport2[1];
          splitPoint = _generateAndReport2[2];
          if (maxError < error) {
            return [bezCurve];
          } else if (splitPoint === prevSplit) {
            var errChange = maxError / prevErr;
            if (errChange > 0.9999 && errChange < 1.0001) {
              break;
            }
          }
          prevErr = maxError;
          prevSplit = splitPoint;
        }
      }
      beziers = [];
      centerVector = maths.subtract(points[splitPoint - 1], points[splitPoint + 1]);
      if (centerVector.every(function(val) {
        return val === 0;
      })) {
        centerVector = maths.subtract(points[splitPoint - 1], points[splitPoint]);
        var _ref = [-centerVector[1], centerVector[0]];
        centerVector[0] = _ref[0];
        centerVector[1] = _ref[1];
      }
      toCenterTangent = maths.normalize(centerVector);
      fromCenterTangent = maths.mulItems(toCenterTangent, -1);
      beziers = beziers.concat(fitCubic(points.slice(0, splitPoint + 1), leftTangent, toCenterTangent, error, progressCallback));
      beziers = beziers.concat(fitCubic(points.slice(splitPoint), fromCenterTangent, rightTangent, error, progressCallback));
      return beziers;
    }
    function generateAndReport(points, paramsOrig, paramsPrime, leftTangent, rightTangent, progressCallback) {
      var bezCurve, maxError, splitPoint;
      bezCurve = generateBezier(points, paramsPrime, leftTangent, rightTangent);
      var _computeMaxError = computeMaxError(points, bezCurve, paramsOrig);
      maxError = _computeMaxError[0];
      splitPoint = _computeMaxError[1];
      if (progressCallback) {
        progressCallback({
          bez: bezCurve,
          points,
          params: paramsOrig,
          maxErr: maxError,
          maxPoint: splitPoint
        });
      }
      return [bezCurve, maxError, splitPoint];
    }
    function generateBezier(points, parameters, leftTangent, rightTangent) {
      var bezCurve, A, a, C, X, det_C0_C1, det_C0_X, det_X_C1, alpha_l, alpha_r, epsilon, segLength, i, len2, tmp2, u, ux, firstPoint = points[0], lastPoint = points[points.length - 1];
      bezCurve = [firstPoint, null, null, lastPoint];
      A = maths.zeros_Xx2x2(parameters.length);
      for (i = 0, len2 = parameters.length; i < len2; i++) {
        u = parameters[i];
        ux = 1 - u;
        a = A[i];
        a[0] = maths.mulItems(leftTangent, 3 * u * (ux * ux));
        a[1] = maths.mulItems(rightTangent, 3 * ux * (u * u));
      }
      C = [[0, 0], [0, 0]];
      X = [0, 0];
      for (i = 0, len2 = points.length; i < len2; i++) {
        u = parameters[i];
        a = A[i];
        C[0][0] += maths.dot(a[0], a[0]);
        C[0][1] += maths.dot(a[0], a[1]);
        C[1][0] += maths.dot(a[0], a[1]);
        C[1][1] += maths.dot(a[1], a[1]);
        tmp2 = maths.subtract(points[i], bezier.q([firstPoint, firstPoint, lastPoint, lastPoint], u));
        X[0] += maths.dot(a[0], tmp2);
        X[1] += maths.dot(a[1], tmp2);
      }
      det_C0_C1 = C[0][0] * C[1][1] - C[1][0] * C[0][1];
      det_C0_X = C[0][0] * X[1] - C[1][0] * X[0];
      det_X_C1 = X[0] * C[1][1] - X[1] * C[0][1];
      alpha_l = det_C0_C1 === 0 ? 0 : det_X_C1 / det_C0_C1;
      alpha_r = det_C0_C1 === 0 ? 0 : det_C0_X / det_C0_C1;
      segLength = maths.vectorLen(maths.subtract(firstPoint, lastPoint));
      epsilon = 1e-6 * segLength;
      if (alpha_l < epsilon || alpha_r < epsilon) {
        bezCurve[1] = maths.addArrays(firstPoint, maths.mulItems(leftTangent, segLength / 3));
        bezCurve[2] = maths.addArrays(lastPoint, maths.mulItems(rightTangent, segLength / 3));
      } else {
        bezCurve[1] = maths.addArrays(firstPoint, maths.mulItems(leftTangent, alpha_l));
        bezCurve[2] = maths.addArrays(lastPoint, maths.mulItems(rightTangent, alpha_r));
      }
      return bezCurve;
    }
    function reparameterize(bezier2, points, parameters) {
      return parameters.map(function(p, i) {
        return newtonRaphsonRootFind(bezier2, points[i], p);
      });
    }
    function newtonRaphsonRootFind(bez, point2, u) {
      var d = maths.subtract(bezier.q(bez, u), point2), qprime = bezier.qprime(bez, u), numerator = maths.mulMatrix(d, qprime), denominator = maths.sum(maths.squareItems(qprime)) + 2 * maths.mulMatrix(d, bezier.qprimeprime(bez, u));
      if (denominator === 0) {
        return u;
      } else {
        return u - numerator / denominator;
      }
    }
    function chordLengthParameterize(points) {
      var u = [], currU, prevU, prevP;
      points.forEach(function(p, i) {
        currU = i ? prevU + maths.vectorLen(maths.subtract(p, prevP)) : 0;
        u.push(currU);
        prevU = currU;
        prevP = p;
      });
      u = u.map(function(x) {
        return x / prevU;
      });
      return u;
    }
    function computeMaxError(points, bez, parameters) {
      var dist2, maxDist, splitPoint, v, i, count, point2, t;
      maxDist = 0;
      splitPoint = Math.floor(points.length / 2);
      var t_distMap = mapTtoRelativeDistances(bez, 10);
      for (i = 0, count = points.length; i < count; i++) {
        point2 = points[i];
        t = find_t(bez, parameters[i], t_distMap, 10);
        v = maths.subtract(bezier.q(bez, t), point2);
        dist2 = v[0] * v[0] + v[1] * v[1];
        if (dist2 > maxDist) {
          maxDist = dist2;
          splitPoint = i;
        }
      }
      return [maxDist, splitPoint];
    }
    var mapTtoRelativeDistances = function mapTtoRelativeDistances2(bez, B_parts) {
      var B_t_curr;
      var B_t_dist = [0];
      var B_t_prev = bez[0];
      var sumLen = 0;
      for (var i = 1; i <= B_parts; i++) {
        B_t_curr = bezier.q(bez, i / B_parts);
        sumLen += maths.vectorLen(maths.subtract(B_t_curr, B_t_prev));
        B_t_dist.push(sumLen);
        B_t_prev = B_t_curr;
      }
      B_t_dist = B_t_dist.map(function(x) {
        return x / sumLen;
      });
      return B_t_dist;
    };
    function find_t(bez, param, t_distMap, B_parts) {
      if (param < 0) {
        return 0;
      }
      if (param > 1) {
        return 1;
      }
      var lenMax, lenMin, tMax, tMin, t;
      for (var i = 1; i <= B_parts; i++) {
        if (param <= t_distMap[i]) {
          tMin = (i - 1) / B_parts;
          tMax = i / B_parts;
          lenMin = t_distMap[i - 1];
          lenMax = t_distMap[i];
          t = (param - lenMin) / (lenMax - lenMin) * (tMax - tMin) + tMin;
          break;
        }
      }
      return t;
    }
    function createTangent(pointA, pointB) {
      return maths.normalize(maths.subtract(pointA, pointB));
    }
    var maths = function() {
      function maths2() {
        _classCallCheck(this, maths2);
      }
      maths2.zeros_Xx2x2 = function zeros_Xx2x2(x) {
        var zs = [];
        while (x--) {
          zs.push([0, 0]);
        }
        return zs;
      };
      maths2.mulItems = function mulItems(items, multiplier) {
        return items.map(function(x) {
          return x * multiplier;
        });
      };
      maths2.mulMatrix = function mulMatrix(m1, m2) {
        return m1.reduce(function(sum, x1, i) {
          return sum + x1 * m2[i];
        }, 0);
      };
      maths2.subtract = function subtract2(arr1, arr2) {
        return arr1.map(function(x1, i) {
          return x1 - arr2[i];
        });
      };
      maths2.addArrays = function addArrays(arr1, arr2) {
        return arr1.map(function(x1, i) {
          return x1 + arr2[i];
        });
      };
      maths2.addItems = function addItems(items, addition) {
        return items.map(function(x) {
          return x + addition;
        });
      };
      maths2.sum = function sum(items) {
        return items.reduce(function(sum2, x) {
          return sum2 + x;
        });
      };
      maths2.dot = function dot2(m1, m2) {
        return maths2.mulMatrix(m1, m2);
      };
      maths2.vectorLen = function vectorLen(v) {
        return Math.hypot.apply(Math, v);
      };
      maths2.divItems = function divItems(items, divisor) {
        return items.map(function(x) {
          return x / divisor;
        });
      };
      maths2.squareItems = function squareItems(items) {
        return items.map(function(x) {
          return x * x;
        });
      };
      maths2.normalize = function normalize2(v) {
        return this.divItems(v, this.vectorLen(v));
      };
      return maths2;
    }();
    var bezier = function() {
      function bezier2() {
        _classCallCheck(this, bezier2);
      }
      bezier2.q = function q(ctrlPoly, t) {
        var tx = 1 - t;
        var pA = maths.mulItems(ctrlPoly[0], tx * tx * tx), pB = maths.mulItems(ctrlPoly[1], 3 * tx * tx * t), pC = maths.mulItems(ctrlPoly[2], 3 * tx * t * t), pD = maths.mulItems(ctrlPoly[3], t * t * t);
        return maths.addArrays(maths.addArrays(pA, pB), maths.addArrays(pC, pD));
      };
      bezier2.qprime = function qprime(ctrlPoly, t) {
        var tx = 1 - t;
        var pA = maths.mulItems(maths.subtract(ctrlPoly[1], ctrlPoly[0]), 3 * tx * tx), pB = maths.mulItems(maths.subtract(ctrlPoly[2], ctrlPoly[1]), 6 * tx * t), pC = maths.mulItems(maths.subtract(ctrlPoly[3], ctrlPoly[2]), 3 * t * t);
        return maths.addArrays(maths.addArrays(pA, pB), pC);
      };
      bezier2.qprimeprime = function qprimeprime(ctrlPoly, t) {
        return maths.addArrays(maths.mulItems(maths.addArrays(maths.subtract(ctrlPoly[2], maths.mulItems(ctrlPoly[1], 2)), ctrlPoly[0]), 6 * (1 - t)), maths.mulItems(maths.addArrays(maths.subtract(ctrlPoly[3], maths.mulItems(ctrlPoly[2], 2)), ctrlPoly[1]), 6 * t));
      };
      return bezier2;
    }();
    module2.exports = fitCurve2;
    module2.exports.fitCubic = fitCubic;
    module2.exports.createTangent = createTangent;
  });
})(fitCurve$1);
var fitCurve = fitCurve$1.exports;
var _slicedToArray = function() {
  function sliceIterator(arr, i) {
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = void 0;
    try {
      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);
        if (i && _arr.length === i)
          break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"])
          _i["return"]();
      } finally {
        if (_d)
          throw _e;
      }
    }
    return _arr;
  }
  return function(arr, i) {
    if (Array.isArray(arr)) {
      return arr;
    } else if (Symbol.iterator in Object(arr)) {
      return sliceIterator(arr, i);
    } else {
      throw new TypeError("Invalid attempt to destructure non-iterable instance");
    }
  };
}();
var TAU = Math.PI * 2;
var mapToEllipse = function mapToEllipse2(_ref, rx, ry, cosphi, sinphi, centerx, centery) {
  var x = _ref.x, y = _ref.y;
  x *= rx;
  y *= ry;
  var xp = cosphi * x - sinphi * y;
  var yp = sinphi * x + cosphi * y;
  return {
    x: xp + centerx,
    y: yp + centery
  };
};
var approxUnitArc = function approxUnitArc2(ang1, ang2) {
  var a = ang2 === 1.5707963267948966 ? 0.551915024494 : ang2 === -1.5707963267948966 ? -0.551915024494 : 4 / 3 * Math.tan(ang2 / 4);
  var x1 = Math.cos(ang1);
  var y1 = Math.sin(ang1);
  var x2 = Math.cos(ang1 + ang2);
  var y2 = Math.sin(ang1 + ang2);
  return [{
    x: x1 - y1 * a,
    y: y1 + x1 * a
  }, {
    x: x2 + y2 * a,
    y: y2 - x2 * a
  }, {
    x: x2,
    y: y2
  }];
};
var vectorAngle = function vectorAngle2(ux, uy, vx, vy) {
  var sign2 = ux * vy - uy * vx < 0 ? -1 : 1;
  var dot2 = ux * vx + uy * vy;
  if (dot2 > 1) {
    dot2 = 1;
  }
  if (dot2 < -1) {
    dot2 = -1;
  }
  return sign2 * Math.acos(dot2);
};
var getArcCenter = function getArcCenter2(px2, py2, cx, cy, rx, ry, largeArcFlag, sweepFlag, sinphi, cosphi, pxp, pyp) {
  var rxsq = Math.pow(rx, 2);
  var rysq = Math.pow(ry, 2);
  var pxpsq = Math.pow(pxp, 2);
  var pypsq = Math.pow(pyp, 2);
  var radicant = rxsq * rysq - rxsq * pypsq - rysq * pxpsq;
  if (radicant < 0) {
    radicant = 0;
  }
  radicant /= rxsq * pypsq + rysq * pxpsq;
  radicant = Math.sqrt(radicant) * (largeArcFlag === sweepFlag ? -1 : 1);
  var centerxp = radicant * rx / ry * pyp;
  var centeryp = radicant * -ry / rx * pxp;
  var centerx = cosphi * centerxp - sinphi * centeryp + (px2 + cx) / 2;
  var centery = sinphi * centerxp + cosphi * centeryp + (py2 + cy) / 2;
  var vx1 = (pxp - centerxp) / rx;
  var vy1 = (pyp - centeryp) / ry;
  var vx2 = (-pxp - centerxp) / rx;
  var vy2 = (-pyp - centeryp) / ry;
  var ang1 = vectorAngle(1, 0, vx1, vy1);
  var ang2 = vectorAngle(vx1, vy1, vx2, vy2);
  if (sweepFlag === 0 && ang2 > 0) {
    ang2 -= TAU;
  }
  if (sweepFlag === 1 && ang2 < 0) {
    ang2 += TAU;
  }
  return [centerx, centery, ang1, ang2];
};
var arcToBezier = function arcToBezier2(_ref2) {
  var px2 = _ref2.px, py2 = _ref2.py, cx = _ref2.cx, cy = _ref2.cy, rx = _ref2.rx, ry = _ref2.ry, _ref2$xAxisRotation = _ref2.xAxisRotation, xAxisRotation = _ref2$xAxisRotation === void 0 ? 0 : _ref2$xAxisRotation, _ref2$largeArcFlag = _ref2.largeArcFlag, largeArcFlag = _ref2$largeArcFlag === void 0 ? 0 : _ref2$largeArcFlag, _ref2$sweepFlag = _ref2.sweepFlag, sweepFlag = _ref2$sweepFlag === void 0 ? 0 : _ref2$sweepFlag;
  var curves = [];
  if (rx === 0 || ry === 0) {
    return [];
  }
  var sinphi = Math.sin(xAxisRotation * TAU / 360);
  var cosphi = Math.cos(xAxisRotation * TAU / 360);
  var pxp = cosphi * (px2 - cx) / 2 + sinphi * (py2 - cy) / 2;
  var pyp = -sinphi * (px2 - cx) / 2 + cosphi * (py2 - cy) / 2;
  if (pxp === 0 && pyp === 0) {
    return [];
  }
  rx = Math.abs(rx);
  ry = Math.abs(ry);
  var lambda = Math.pow(pxp, 2) / Math.pow(rx, 2) + Math.pow(pyp, 2) / Math.pow(ry, 2);
  if (lambda > 1) {
    rx *= Math.sqrt(lambda);
    ry *= Math.sqrt(lambda);
  }
  var _getArcCenter = getArcCenter(px2, py2, cx, cy, rx, ry, largeArcFlag, sweepFlag, sinphi, cosphi, pxp, pyp), _getArcCenter2 = _slicedToArray(_getArcCenter, 4), centerx = _getArcCenter2[0], centery = _getArcCenter2[1], ang1 = _getArcCenter2[2], ang2 = _getArcCenter2[3];
  var ratio = Math.abs(ang2) / (TAU / 4);
  if (Math.abs(1 - ratio) < 1e-7) {
    ratio = 1;
  }
  var segments = Math.max(Math.ceil(ratio), 1);
  ang2 /= segments;
  for (var i = 0; i < segments; i++) {
    curves.push(approxUnitArc(ang1, ang2));
    ang1 += ang2;
  }
  return curves.map(function(curve) {
    var _mapToEllipse = mapToEllipse(curve[0], rx, ry, cosphi, sinphi, centerx, centery), x1 = _mapToEllipse.x, y1 = _mapToEllipse.y;
    var _mapToEllipse2 = mapToEllipse(curve[1], rx, ry, cosphi, sinphi, centerx, centery), x2 = _mapToEllipse2.x, y2 = _mapToEllipse2.y;
    var _mapToEllipse3 = mapToEllipse(curve[2], rx, ry, cosphi, sinphi, centerx, centery), x = _mapToEllipse3.x, y = _mapToEllipse3.y;
    return { x1, y1, x2, y2, x, y };
  });
};
class Point {
  static isEqual(a, b, c2) {
    if (arguments.length === 2) {
      return a.x === b.x && a.y === b.y;
    } else if (arguments.length === 3) {
      return Point.isEqual(a, b) && Point.isEqual(b, c2);
    }
  }
  static isFirst(point2) {
    return point2 && point2.command == "M";
  }
  static DouglasPeuker(tolerance, points, start2, last) {
    if (last <= start2 + 1)
      return;
    let maxdist2 = 0;
    let breakIndex = start2;
    const tol2 = tolerance * tolerance;
    const startPoint = points[start2];
    const lastPoint = points[last];
    for (var i = start2 + 1; i < last; i++) {
      const dist2 = Point.segmentDistance2(points[i].x, points[i].y, startPoint, lastPoint);
      if (dist2 <= maxdist2)
        continue;
      breakIndex = i;
      maxdist2 = dist2;
    }
    if (maxdist2 > tol2) {
      points[breakIndex].mark = true;
      Point.DouglasPeuker(tolerance, points, start2, breakIndex);
      Point.DouglasPeuker(tolerance, points, breakIndex, last);
    }
  }
  static simply(points, tolerance = 10) {
    if (points.length <= 2) {
      return points;
    }
    points = clone$1(points);
    points[0].mark = true;
    points[points.length - 1].mark = true;
    Point.DouglasPeuker(tolerance, points, 0, points.length - 1);
    return points.filter((it) => Boolean(it.mark));
  }
  static segmentDistance2(x, y, A, B) {
    let dx = B.x - A.x;
    let dy = B.y - A.y;
    let lenAB = dx * dx + dy * dy;
    let du = x - A.x;
    let dv = y - A.y;
    let dot2 = dx * du + dy * dv;
    if (lenAB === 0)
      return du * du + dv * dv;
    if (dot2 <= 0)
      return du * du + dv * dv;
    else if (dot2 >= lenAB) {
      du = x - B.x;
      dv = y - B.y;
      return du * du + dv * dv;
    } else {
      const slash = du * dy - dv * dx;
      return slash * slash / lenAB;
    }
  }
  static isInLine(A, B, C) {
    if (A.x === C.x)
      return B.x === C.x;
    if (A.y === C.y)
      return B.y === C.y;
    return (A.x - C.x) * (A.y - C.y) === (C.x - B.x) * (C.y - B.y);
  }
  static isLine(point2) {
    return Point.isInLine(point2.endPoint, point2.startPoint, point2, point2.reversePoint);
  }
  static getReversePoint(start2, end2) {
    const [x, y] = lerp$1([], [end2.x, end2.y, 0], [start2.x, start2.y, 0], 2);
    return { x, y };
  }
  static getIndexPoint(points, index2) {
    return points[index2];
  }
  static getPoint(points, p0) {
    return points.filter((p) => {
      return Point.isEqual(p.startPoint, p0);
    })[0];
  }
  static getIndex(points, p0) {
    var firstIndex = -1;
    for (var i = 0, len2 = points.length; i < len2; i++) {
      var p = points[i];
      if (Point.isEqual(p.startPoint, p0)) {
        firstIndex = i;
        break;
      }
    }
    return firstIndex;
  }
  static getGroupList(points) {
    const groupList = [];
    let groupIndex = 0;
    points.forEach((point2, index2) => {
      if (point2.command === "M") {
        groupList.push({ point: point2, index: index2, groupIndex: groupIndex++ });
      }
    });
    return groupList;
  }
  static getSplitedGroupList(points) {
    const localPoints = clone$1(points);
    const splitedGroupList = [];
    for (var i = 0, groupIndex = -1, len2 = localPoints.length; i < len2; i++) {
      const point2 = localPoints[i];
      if (point2.command === "M") {
        groupIndex++;
        splitedGroupList[groupIndex] = {
          startPointIndex: i,
          point: point2,
          points: []
        };
      }
      splitedGroupList[groupIndex].points.push(point2);
    }
    return splitedGroupList;
  }
  static getGroup(groupList, pointIndex) {
    const list2 = groupList.filter((group2) => group2.point.index <= pointIndex);
    return list2.pop();
  }
  static getGroupIndex(points, index2) {
    var groupIndex = -1;
    for (var i = 0, len2 = points.length; i < len2; i++) {
      if (points[i].command === "M") {
        groupIndex++;
      }
      if (points[i].index === index2) {
        return groupIndex;
      }
    }
  }
  static getLastPoint(points, index2) {
    if (!points.length)
      return null;
    var lastIndex = -1;
    for (var i = index2 + 1, len2 = points.length; i < len2; i++) {
      if (points[i].command === "M") {
        lastIndex = i - 1;
        break;
      }
    }
    if (lastIndex == -1) {
      lastIndex = points.length - 1;
    }
    if (points[lastIndex] && points[lastIndex].command === "Z") {
      lastIndex -= 1;
    }
    var point2 = points[lastIndex];
    if (point2) {
      point2.index = lastIndex;
    }
    return point2;
  }
  static getFirstPoint(points, index2) {
    var firstIndex = -1;
    for (var i = index2 - 1; i > 0; i--) {
      if (points[i].command === "M") {
        firstIndex = i;
        break;
      }
    }
    if (firstIndex === -1) {
      firstIndex = 0;
    }
    var point2 = points[firstIndex];
    if (point2) {
      point2.index = firstIndex;
    }
    return point2;
  }
  static getConnectedPointList(points, index2) {
    const current = points[index2];
    return points.filter((p, i) => i !== index2 && Point.isEqual(p.startPoint, current.startPoint));
  }
  static getPrevPoint(points, index2) {
    var prevIndex = index2 - 1;
    if (prevIndex < 0) {
      return Point.getLastPoint(points, index2);
    }
    var point2 = points[prevIndex];
    if (point2) {
      point2.index = prevIndex;
    }
    return point2;
  }
  static getNextPoint(points, index2) {
    var currentPoint = points[index2];
    var nextPoint = points[index2 + 1];
    if (nextPoint) {
      nextPoint.index = index2 + 1;
    }
    if (currentPoint.connected || currentPoint.close) {
      nextPoint = Point.getFirstPoint(points, index2);
    }
    return nextPoint;
  }
  static removePoint(points, pIndex, segment) {
    if (segment === "startPoint") {
      return points.filter((_, index2) => index2 !== pIndex);
    }
  }
  static splitPoints(points) {
    let splitedPointGroup = [];
    let lastPoints = [];
    points.forEach((p) => {
      if (Point.isFirst(p)) {
        lastPoints = [p];
        splitedPointGroup.push(lastPoints);
      } else {
        lastPoints.push(p);
      }
    });
    return splitedPointGroup;
  }
  static recoverPoints(pointGroup) {
    const newPoints = [];
    pointGroup.forEach((points) => {
      points.forEach((p, index2) => {
        if (index2 === 0) {
          p.command = "M";
          p.originalCommand = "M";
        }
      });
      newPoints.push.apply(newPoints, points);
    });
    newPoints.forEach((p, index2) => {
      p.index = index2;
    });
    return newPoints;
  }
}
class Segment {
  static M(x, y) {
    return {
      command: "M",
      values: [x, y]
    };
  }
  static L(x, y) {
    return {
      command: "L",
      values: [x, y]
    };
  }
  static Q(x1, y1, x, y) {
    return {
      command: "Q",
      values: [x1, y1, x, y]
    };
  }
  static C(x1, y1, x2, y2, x, y) {
    return {
      command: "C",
      values: [x1, y1, x2, y2, x, y]
    };
  }
  static A(rx, ry, xrot, laf, sf, x, y) {
    return {
      command: "A",
      values: [rx, ry, xrot, laf, sf, x, y]
    };
  }
  static Z() {
    return {
      command: "Z",
      values: []
    };
  }
  static isMoveTo(segment) {
    return segment.command === "M";
  }
  static isLineTo(segment) {
    return segment.command === "L";
  }
  static isQuadraticBezierCurve(segment) {
    return segment.command === "Q";
  }
  static isCubicBezierCurve(segment) {
    return segment.command === "C";
  }
  static isArc(segment) {
    return segment.command === "A";
  }
  static isClosePath(segment) {
    return segment.command === "Z";
  }
}
const REG_PARSE_NUMBER_FOR_PATH = /([mMlLvVhHcCsSqQtTaAzZ]([^mMlLvVhHcCsSqQtTaAzZ]*))/g;
var numberReg = /-?[0-9]*\.?[0-9]+(?:e[-+]?\d+)?/gi;
function xy$2(point2) {
  return {
    x: point2[0],
    y: point2[1]
  };
}
class PathParser {
  constructor(pathString2 = "") {
    this.reset(pathString2);
  }
  reset(pathString2 = "") {
    this.segments = [];
    this.pathString = pathString2.trim();
    this.parse();
    return this;
  }
  resetSegments(segments) {
    this.segments = segments || [];
    this.pathString = this.joinPath();
    return this;
  }
  addSegments(segments) {
    return this.resetSegments([...this.segments, ...segments]);
  }
  addPath(otherPath, transform2 = create$4()) {
    const newPath = otherPath.clone();
    newPath.transformMat4(transform2);
    return this.addSegments(newPath.segments);
  }
  trim(str = "") {
    var arr = str.match(numberReg) || [];
    return arr.filter((it) => it != "");
  }
  parse() {
    var arr = this.pathString.match(REG_PARSE_NUMBER_FOR_PATH) || [];
    this.segments = arr.map((s) => {
      var command = s[0];
      var values = this.trim(s.replace(command, "")).map((it) => +it);
      return { command, values };
    });
    this.segments = this.segments.map((s, index2) => {
      switch (s.command) {
        case "m":
          var prev = this.segments[index2 - 1];
          if (prev && (prev.command == "z" || prev.command == "Z")) {
            prev = this.segments[index2 - 2];
          }
          var x = (prev == null ? void 0 : prev.values[prev.values.length - 2]) || 0;
          var y = (prev == null ? void 0 : prev.values[prev.values.length - 1]) || 0;
          for (var i = 0, len2 = s.values.length; i < len2; i += 2) {
            s.values[i] += x;
            s.values[i + 1] += y;
          }
          return {
            command: s.command.toUpperCase(),
            values: [...s.values]
          };
        case "c":
        case "l":
        case "q":
        case "s":
        case "t":
        case "v":
        case "h":
          var prev = this.segments[index2 - 1];
          var x = (prev == null ? void 0 : prev.values[prev.values.length - 2]) || 0;
          var y = (prev == null ? void 0 : prev.values[prev.values.length - 1]) || 0;
          for (var i = 0, len2 = s.values.length; i < len2; i += 2) {
            s.values[i] += x;
            s.values[i + 1] += y;
          }
          return {
            command: s.command.toUpperCase(),
            values: [...s.values]
          };
        case "a":
          var prev = this.segments[index2 - 1];
          var x = (prev == null ? void 0 : prev.values[prev.values.length - 2]) || 0;
          var y = (prev == null ? void 0 : prev.values[prev.values.length - 1]) || 0;
          s.values[5] += x;
          s.values[6] += y;
          return {
            command: s.command.toUpperCase(),
            values: [...s.values]
          };
        case "z":
          return {
            command: s.command.toUpperCase(),
            values: []
          };
        default:
          return s;
      }
    });
    this.segments.forEach((it, index2) => {
      const prev = this.segments[index2 - 1];
      if (it.command == "A") {
        const x1 = (prev == null ? void 0 : prev.values[prev.values.length - 2]) || 0;
        const y1 = (prev == null ? void 0 : prev.values[prev.values.length - 1]) || 0;
        const [rx, ry, xrotate, largeArcFlag, sweepFlag, x, y] = it.values;
        const path = PathParser.arcToCurve(x1, y1, rx, ry, xrotate, largeArcFlag, sweepFlag, x, y);
        path.segments.forEach((seg) => {
          if (seg.command !== "M" || seg.command !== "Z")
            ;
        });
      }
    });
    return this;
  }
  convertGenerator() {
    var points = [];
    for (var index2 = 0, len2 = this.segments.length; index2 < len2; index2++) {
      var s = this.segments[index2];
      var nextSegment = this.segments[index2 + 1];
      const { command, values } = s;
      if (command === "M") {
        var [x, y] = values;
        points.push({
          command,
          originalCommand: command,
          startPoint: { x, y },
          endPoint: { x, y },
          reversePoint: { x, y },
          curve: false
        });
      } else if (command === "L") {
        var prevPoint = Point.getPrevPoint(points, points.length);
        if (prevPoint.curve) {
          var [x, y] = values;
          points.push({
            command,
            originalCommand: command,
            startPoint: { x, y },
            endPoint: { x, y },
            reversePoint: clone$1(prevPoint.endPoint),
            curve: true
          });
        } else {
          var [x, y] = values;
          points.push({
            command,
            originalCommand: command,
            startPoint: { x, y },
            endPoint: { x, y },
            reversePoint: { x, y },
            curve: false
          });
        }
      } else if (command === "Q") {
        var [cx1, cy1, x, y] = values;
        var prevPoint = Point.getPrevPoint(points, points.length);
        if (prevPoint.curve) {
          var startPoint = { x, y };
          var endPoint = { x, y };
          var reversePoint = { x, y };
          points.push({
            command: "L",
            originalCommand: command,
            startPoint,
            endPoint,
            reversePoint,
            curve: false
          });
          prevPoint.endPoint = { x: cx1, y: cy1 };
        } else {
          if (nextSegment && nextSegment.command === "L") {
            prevPoint.curve = true;
            prevPoint.endPoint = { x: cx1, y: cy1 };
            var startPoint = { x, y };
            var reversePoint = { x, y };
            var endPoint = { x, y };
            points.push({
              command: "L",
              originalCommand: command,
              curve: false,
              startPoint,
              endPoint,
              reversePoint
            });
          } else {
            var startPoint = { x, y };
            var reversePoint = { x: cx1, y: cy1 };
            var endPoint = { x, y };
            points.push({
              command,
              originalCommand: command,
              curve: true,
              startPoint,
              endPoint,
              reversePoint
            });
          }
        }
      } else if (command === "T") {
        var [x, y] = values;
        var prevSegment = this.segments[index2 - 1];
        if (prevSegment && prevSegment.command === "Q") {
          var [cx1, cy1, sx, sy] = prevSegment.values;
          var prevPoint = Point.getPrevPoint(points, points.length);
          prevPoint.endPoint = Point.getReversePoint({ x: sx, y: sy }, { x: cx1, y: cy1 });
          var startPoint = { x, y };
          var endPoint = { x, y };
          var reversePoint = { x, y };
          points.push({
            command: "L",
            originalCommand: command,
            startPoint,
            endPoint,
            reversePoint,
            curve: false
          });
        }
      } else if (command === "C") {
        var prevPoint = Point.getPrevPoint(points, points.length);
        var [cx1, cy1, cx2, cy2, x, y] = values;
        var startPoint = { x, y };
        var reversePoint = { x: cx2, y: cy2 };
        var endPoint = { x, y };
        points.push({
          command,
          originalCommand: command,
          curve: true,
          startPoint,
          endPoint,
          reversePoint
        });
        if (prevPoint) {
          prevPoint.curve = true;
          prevPoint.endPoint = { x: cx1, y: cy1 };
        }
      } else if (command === "S") {
        var [x, y] = values;
        var prevSegment = this.segments[index2 - 1];
        if (prevSegment && prevSegment.command === "C") {
          var [cx2, cy2, sx, sy] = prevSegment.values;
          var prevPoint = Point.getPrevPoint(points, points.length);
          prevPoint.endPoint = Point.getReversePoint(prevPoint.startPoint, prevPoint.reversePoint);
          var startPoint = { x, y };
          var endPoint = { x, y };
          var reversePoint = { x: cx2, y: cy2 };
          points.push({
            command: "Q",
            originalCommand: command,
            startPoint,
            endPoint,
            reversePoint,
            curve: false
          });
        }
      } else if (command === "Z") {
        var prevPoint = Point.getPrevPoint(points, points.length);
        var firstPoint = Point.getFirstPoint(points, points.length);
        if (Point.isEqual(prevPoint.startPoint, firstPoint.startPoint)) {
          prevPoint.connected = true;
          prevPoint.endPoint = clone$1(firstPoint.endPoint);
          firstPoint.reversePoint = clone$1(prevPoint.reversePoint);
        }
        prevPoint.close = true;
      }
    }
    points = points.filter((p) => !!p);
    return points;
  }
  setSegments(index2, seg) {
    this.segments[index2] = seg;
  }
  getSegments(index2) {
    if (isNotUndefined(index2)) {
      return this.segments[index2];
    }
    return this.segments;
  }
  joinPath(segments, split = "") {
    var list2 = segments || this.segments;
    return list2.map((it) => {
      return `${it.command} ${it.values.length ? it.values.join(" ") : ""}`;
    }).join(split);
  }
  each(callback, isReturn = false) {
    var newSegments = this.segments.map((segment, index2) => {
      return callback.call(this, segment, index2);
    });
    if (isReturn) {
      return newSegments;
    } else {
      this.segments = newSegments;
    }
    return this;
  }
  _loop(m, isReturn = false) {
    return this.each(function(segment) {
      var v = segment.values;
      var c2 = segment.command;
      switch (c2) {
        case "M":
        case "L":
          var result = m(v, 0);
          segment.values = [result[0], result[1]];
          break;
        case "V":
          var result = m([+v[0], 0]);
          segment.values = [result[0]];
          break;
        case "H":
          var result = m([0, +v[0]]);
          segment.values = [result[1]];
          break;
        case "C":
        case "S":
        case "T":
        case "Q":
          for (var i = 0, len2 = v.length; i < len2; i += 2) {
            var result = m(v, i);
            segment.values[i] = result[0];
            segment.values[i + 1] = result[1];
          }
          break;
      }
      return segment;
    }, isReturn);
  }
  clone() {
    const path = new PathParser();
    path.resetSegments(this.segments.map((it) => {
      return {
        command: it.command,
        values: it.values.slice()
      };
    }));
    return path;
  }
  translate(tx, ty) {
    this.transformMat4(fromTranslation([], [tx, ty, 0]));
    return this;
  }
  translateTo(tx, ty) {
    return this.joinPath(this.transformMat4(fromTranslation([], [tx, ty, 0]), true));
  }
  scale(sx, sy) {
    this.transformMat4(fromScaling([], [sx, sy, 1]));
    return this;
  }
  scaleTo(sx, sy) {
    return this.joinPath(this.transformMat4(fromScaling([], [sx, sy, 1]), true));
  }
  scaleWith(width2, height2) {
    const newPath = this.clone();
    const rect2 = vertiesToRectangle(newPath.getBBox());
    newPath.translate(-rect2.x, -rect2.y);
    const scale2 = Math.min(width2 / rect2.width, height2 / rect2.height);
    return newPath.scale(scale2, scale2).translate(width2 / 2 - rect2.width / 2 * scale2, height2 / 2 - rect2.height / 2 * scale2);
  }
  scaleFunc(xScale = (x) => x, yScale = (y) => y) {
    return this.each(function(segment) {
      var v = segment.values;
      var c2 = segment.command;
      switch (c2) {
        case "M":
        case "L":
          segment.values = [xScale(v[0]), yScale(v[1])];
          break;
        case "C":
        case "Q":
          for (var i = 0, len2 = v.length; i < len2; i += 2) {
            segment.values[i] = xScale(v[i]);
            segment.values[i + 1] = yScale(v[i + 1]);
          }
          break;
      }
      return segment;
    });
  }
  rotate(angle, centerX = 0, centerY = 0) {
    const view = create$4();
    multiply$1(view, view, fromTranslation([], [centerX, centerY, 0]));
    multiply$1(view, view, fromZRotation([], degreeToRadian(angle)));
    multiply$1(view, view, fromTranslation([], negate([], [centerX, centerY, 0])));
    this.transformMat4(view);
    return this;
  }
  rotateTo(angle, centerX = 0, centerY = 0) {
    const view = create$4();
    multiply$1(view, view, fromTranslation([], [centerX, centerY, 0]));
    multiply$1(view, view, fromZRotation([], degreeToRadian(angle)));
    multiply$1(view, view, fromTranslation([], negate([], [centerX, centerY, 0])));
    return this.joinPath(this.transformMat4(view, true));
  }
  reflectionOrigin() {
    this.transformMat4(fromScaling([], [-1, -1, 0]));
    return this;
  }
  reflectionOriginTo() {
    return this.joinPath(this.transformMat4(fromScaling([], [-1, -1, 0]), true));
  }
  flipX() {
    this.transformMat4(fromScaling([], [1, -1, 0]));
    return this;
  }
  flipXTo() {
    return this.joinPath(this.transformMat4(fromScaling([], [1, -1, 0]), true));
  }
  flipY() {
    this.transformMat4(fromScaling([], [-1, 1, 0]));
    return this;
  }
  flipYTo() {
    return this.joinPath(this.transformMat4(fromScaling([], [-1, 1, 0]), true));
  }
  skewX(angle) {
    this.transformMat4(fromValues$1(1, Math.tan(degreeToRadian(angle)), 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1));
    return this;
  }
  skewXTo(angle) {
    return this.joinPath(this.transformMat4(fromValues$1(1, Math.tan(degreeToRadian(angle)), 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), true));
  }
  skewY(angle) {
    this.transformMat4(fromValues$1(1, 0, 0, 0, Math.tan(degreeToRadian(angle)), 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1));
    return this;
  }
  skewYTo(angle) {
    return this.joinPath(this.transformMat4(fromValues$1(1, 0, 0, 0, Math.tan(degreeToRadian(angle)), 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), true));
  }
  forEachGroup(callback) {
    const groupList = this.getGroup();
    for (let i = 0, len2 = groupList.length; i < len2; i++) {
      const group2 = groupList[i];
      callback(group2, i, groupList);
    }
  }
  forEach(callback) {
    this.forEachGroup((segments, index2, groupList) => {
      for (let i = 0, len2 = segments.length; i < len2; i++) {
        const segment = segments[i];
        callback(segment, i, segments, groupList, index2);
      }
    });
  }
  normalize() {
    const allSegments = [];
    const groupList = this.getGroup();
    groupList.forEach((group2) => {
      const newSegments = [];
      group2.segments.forEach(({ segment }, index2) => {
        var _a;
        const prevSegment = (_a = group2.segments[index2 - 1]) == null ? void 0 : _a.segment;
        if (segment.command === "M") {
          newSegments.push(segment);
          return;
        } else if (segment.command === "L") {
          const localCurve = normalizeCurveForLine([
            [
              prevSegment.values[prevSegment.values.length - 2],
              prevSegment.values[prevSegment.values.length - 1],
              0
            ],
            [segment.values[0], segment.values[1], 0]
          ]);
          newSegments.push({
            command: "C",
            values: [
              localCurve[1][0],
              localCurve[1][1],
              localCurve[2][0],
              localCurve[2][1],
              localCurve[3][0],
              localCurve[3][1]
            ]
          });
          return;
        } else if (segment.command === "C") {
          newSegments.push(segment);
        } else if (segment.command === "Q") {
          const localCurve = normalizeCurveForQuard([
            [
              prevSegment.values[prevSegment.values.length - 2],
              prevSegment.values[prevSegment.values.length - 1],
              0
            ],
            [segment.values[0], segment.values[1], 0],
            [segment.values[2], segment.values[3], 0]
          ]);
          newSegments.push({
            command: "C",
            values: [
              localCurve[1][0],
              localCurve[1][1],
              localCurve[2][0],
              localCurve[2][1],
              localCurve[3][0],
              localCurve[3][1]
            ]
          });
        } else if (segment.command === "Z") {
          newSegments.push(segment);
        }
      });
      allSegments.push(...newSegments);
    });
    return PathParser.fromSegments(allSegments);
  }
  polygonal() {
    const pathList = this.toPathList();
    pathList.forEach((path) => {
      const newSegments = [];
      path.segments.forEach((segment, index2) => {
        const prevSegment = path.segments[index2 - 1];
        if (segment.command === "M") {
          newSegments.push(segment);
        } else if (segment.command === "L") {
          newSegments.push(segment);
        } else if (segment.command === "C") {
          newSegments.push(...polygonalForCurve([
            prevSegment.values[prevSegment.values.length - 2],
            prevSegment.values[prevSegment.values.length - 1],
            0
          ], [segment.values[0], segment.values[1], 0], [segment.values[2], segment.values[3], 0], [segment.values[4], segment.values[5], 0]).map((point2) => ({
            command: "L",
            values: [point2[0], point2[1], 0]
          })));
        } else if (segment.command === "Q") {
          newSegments.push(...polygonalForCurve(...normalizeCurveForQuard([
            [
              prevSegment.values[prevSegment.values.length - 2],
              prevSegment.values[prevSegment.values.length - 1],
              0
            ],
            [segment.values[0], segment.values[1], 0],
            [segment.values[2], segment.values[3], 0]
          ])).map((point2) => ({
            command: "L",
            values: [point2[0], point2[1], 0]
          })));
        } else if (segment.command === "Z") {
          newSegments.push(segment);
        }
      });
      path.resetSegments(newSegments);
    });
    return PathParser.joinPathList(pathList);
  }
  divideSegmentByCount(count = 1) {
    let allSegments = [];
    const groupList = this.getGroup();
    groupList.forEach((group2) => {
      const newSegments = [];
      group2.segments.forEach(({ segment }, index2) => {
        var _a;
        const prevSegment = (_a = group2.segments[index2 - 1]) == null ? void 0 : _a.segment;
        if (segment.command === "M") {
          newSegments.push(segment);
        } else if (segment.command === "L") {
          const linePoints = splitBezierPointsLineByCount([
            {
              x: prevSegment.values[prevSegment.values.length - 2],
              y: prevSegment.values[prevSegment.values.length - 1]
            },
            {
              x: segment.values[0],
              y: segment.values[1]
            }
          ], count);
          linePoints.forEach(([, end2]) => {
            newSegments.push(Segment.L(end2.x, end2.y));
          });
        } else if (segment.command === "Q") {
          const quardPoints = splitBezierPointsQuardByCount([
            {
              x: prevSegment.values[prevSegment.values.length - 2],
              y: prevSegment.values[prevSegment.values.length - 1]
            },
            {
              x: segment.values[0],
              y: segment.values[1]
            },
            {
              x: segment.values[2],
              y: segment.values[3]
            }
          ], count);
          quardPoints.forEach(([, middle2, end2]) => {
            newSegments.push(Segment.Q(middle2.x, middle2.y, end2.x, end2.y));
          });
        } else if (segment.command === "C") {
          const curvePoints = splitBezierPointsByCount([
            {
              x: prevSegment.values[prevSegment.values.length - 2],
              y: prevSegment.values[prevSegment.values.length - 1]
            },
            {
              x: segment.values[0],
              y: segment.values[1]
            },
            {
              x: segment.values[2],
              y: segment.values[3]
            },
            {
              x: segment.values[4],
              y: segment.values[5]
            }
          ], count);
          curvePoints.forEach(([, c1, c2, end2]) => {
            newSegments.push(Segment.C(c1.x, c1.y, c2.x, c2.y, end2.x, end2.y));
          });
        } else if (segment.command === "Z") {
          newSegments.push(segment);
        }
      });
      allSegments = allSegments.concat(newSegments);
    });
    return PathParser.fromSegments(allSegments);
  }
  getBBox() {
    let minX = Number.MAX_SAFE_INTEGER, minY = Number.MAX_SAFE_INTEGER;
    let maxX = Number.MIN_SAFE_INTEGER, maxY = Number.MIN_SAFE_INTEGER;
    this.each(function(segment, index2) {
      var v = segment.values;
      var c2 = segment.command;
      const prevSegment = this.segments[index2 - 1];
      switch (c2) {
        case "M":
        case "L":
          minX = Math.min(minX, v[0]);
          maxX = Math.max(maxX, v[0]);
          minY = Math.min(minY, v[1]);
          maxY = Math.max(maxY, v[1]);
          break;
        case "C":
          getCurveBBox([
            [
              prevSegment.values[prevSegment.values.length - 2],
              prevSegment.values[prevSegment.values.length - 1],
              0
            ],
            [v[0], v[1], 0],
            [v[2], v[3], 0],
            [v[4], v[5], 0]
          ]).forEach((p) => {
            minX = Math.min(minX, p[0]);
            maxX = Math.max(maxX, p[0]);
            minY = Math.min(minY, p[1]);
            maxY = Math.max(maxY, p[1]);
          });
          break;
        case "Q":
          getCurveBBox(normalizeCurveForQuard([
            [
              prevSegment.values[prevSegment.values.length - 2],
              prevSegment.values[prevSegment.values.length - 1],
              0
            ],
            [v[0], v[1], 0],
            [v[2], v[3], 0]
          ])).forEach((p) => {
            minX = Math.min(minX, p[0]);
            maxX = Math.max(maxX, p[0]);
            minY = Math.min(minY, p[1]);
            maxY = Math.max(maxY, p[1]);
          });
          break;
      }
      return segment;
    });
    return [
      [minX, minY, 0],
      [maxX, minY, 0],
      [maxX, maxY, 0],
      [minX, maxY, 0]
    ];
  }
  rect() {
    const bbox = this.getBBox();
    return {
      x: bbox[0][0],
      y: bbox[0][1],
      width: distance$1(bbox[0], bbox[1]),
      height: distance$1(bbox[0], bbox[3]),
      right: bbox[0][0] + distance$1(bbox[0], bbox[1]),
      bottom: bbox[0][1] + distance$1(bbox[0], bbox[3])
    };
  }
  getClosedPointInfo({ x, y }, count = 20) {
    let minDist = Number.MAX_SAFE_INTEGER;
    let targetInfo = {};
    let info = {};
    for (var i = 1, len2 = this.segments.length; i < len2; i++) {
      const segment = this.segments[i];
      const prev = this.segments[i - 1].values;
      const current = segment.values;
      const command = segment.command;
      const lastPoint = { x: prev[prev.length - 2], y: prev[prev.length - 1] };
      if (command === "C") {
        var points = [
          lastPoint,
          { x: current[0], y: current[1] },
          { x: current[2], y: current[3] },
          { x: current[4], y: current[5] }
        ];
        var curve = recoverBezier(...points, count);
        var t = curve(x, y);
        info = {
          segment,
          index: i,
          t,
          points,
          targetPoint: getBezierPoints(points, t).first[3]
        };
      } else if (command === "Q") {
        var points = [
          lastPoint,
          { x: current[0], y: current[1] },
          { x: current[2], y: current[3] }
        ];
        var curve = recoverBezierQuard(...points, count);
        var t = curve(x, y);
        info = {
          segment,
          index: i,
          t,
          points,
          targetPoint: getBezierPointsQuard(points, t).first[2]
        };
      } else if (command === "L") {
        var points = [lastPoint, { x: current[0], y: current[1] }];
        var curve = recoverBezierLine(...points, count);
        var t = curve(x, y);
        info = {
          segment,
          index: i,
          t,
          points,
          targetPoint: getBezierPointsLine(points, t).first[1]
        };
      }
      if (info) {
        var dist2 = Math.sqrt(Math.pow(info.targetPoint.x - x, 2) + Math.pow(info.targetPoint.y - y, 2));
        if (dist2 < minDist) {
          minDist = dist2;
          targetInfo = info;
        }
      }
    }
    return targetInfo;
  }
  getClosedPoint({ x, y }, count = 20) {
    const info = this.getClosedPointInfo({ x, y }, count);
    if (info.targetPoint) {
      return info.targetPoint;
    }
    return { x, y };
  }
  isPointInPath({ x, y }, dist$1 = 1) {
    const info = this.getClosedPointInfo({ x, y }, 20);
    if (info.targetPoint) {
      if (dist([info.targetPoint.x, info.targetPoint.y, 0], [x, y, 0]) <= dist$1) {
        return true;
      }
    }
    return false;
  }
  toString(split = "") {
    return this.joinPath(void 0, split);
  }
  toSVGString() {
    return this.d;
  }
  transformMat4(transformMatrix, isReturn = false) {
    return this.each(function(segment) {
      var v = segment.values;
      var c2 = segment.command;
      switch (c2) {
        case "M":
        case "L":
          var result = transformMat4([], [v[0], v[1], 0], transformMatrix);
          segment.values = [result[0], result[1]];
          break;
        case "C":
        case "Q":
          for (var i = 0, len2 = v.length; i < len2; i += 2) {
            var result = transformMat4([], [v[i], v[i + 1], 0], transformMatrix);
            segment.values[i] = result[0];
            segment.values[i + 1] = result[1];
          }
          break;
      }
      return segment;
    }, isReturn);
  }
  transform(customTransformFunction = ([x, y, z]) => [x, y, z]) {
    const bbox = vertiesToRectangle(this.getBBox());
    return this.each(function(segment) {
      var v = segment.values;
      var c2 = segment.command;
      switch (c2) {
        case "M":
        case "L":
        case "C":
        case "Q":
          for (var i = 0, len2 = v.length; i < len2; i += 2) {
            var result = customTransformFunction([v[i], v[i + 1], 0], { bbox });
            segment.values[i] = result[0];
            segment.values[i + 1] = result[1];
          }
          break;
      }
      return segment;
    });
  }
  invert(transformMatrix) {
    this.transformMat4(invert([], transformMatrix));
    return this;
  }
  round(k = 1) {
    this.each(function(segment) {
      segment.values = segment.values.map((it) => round(it, k));
      return segment;
    });
    return this;
  }
  reverseSegments(segments) {
    const newSegments = [];
    let lastIndex = segments.length - 1;
    for (var i = lastIndex; i > 0; i--) {
      const segment = segments[i];
      const v = segment.values;
      const c2 = segment.command;
      const prevSegment = segments[i - 1];
      const lastX = prevSegment.values[prevSegment.values.length - 2];
      const lastY = prevSegment.values[prevSegment.values.length - 1];
      switch (c2) {
        case "L":
          if (i === lastIndex) {
            newSegments.push(Segment.M(v[0], v[1]));
          }
          newSegments.push(Segment.L(lastX, lastY));
          break;
        case "C":
          if (i === lastIndex) {
            newSegments.push(Segment.M(v[4], v[5]));
          }
          newSegments.push(Segment.C(v[2], v[3], v[0], v[1], lastX, lastY));
          break;
        case "Q":
          if (i === lastIndex) {
            newSegments.push(Segment.M(v[2], v[3]));
          }
          newSegments.push(Segment.Q(v[0], v[1], lastX, lastY));
          break;
        case "Z":
          newSegments.push(segment);
          lastIndex = i - 1;
          break;
      }
    }
    if (newSegments[0].command === "Z") {
      newSegments.push(newSegments.shift());
    }
    return newSegments;
  }
  splitSegments() {
    const groupSegments = [];
    let newSegments = [];
    this.segments.forEach((s) => {
      if (s.command === "M") {
        newSegments = [s];
        groupSegments.push(newSegments);
      } else {
        newSegments.push(s);
      }
    });
    return groupSegments;
  }
  reverse(...groupIndexList) {
    const groupSegments = this.splitSegments();
    const newSegments = [];
    if (groupIndexList.length === 0) {
      groupSegments.forEach((segments) => {
        newSegments.push.apply(newSegments, this.reverseSegments(segments));
      });
    } else {
      groupSegments.forEach((segments, index2) => {
        if (groupIndexList.includes(index2)) {
          newSegments.push.apply(newSegments, this.reverseSegments(segments));
        } else {
          newSegments.push.apply(newSegments, segments);
        }
      });
    }
    return this.resetSegments(newSegments);
  }
  reversePathStringByFunc(func) {
    const pathList = this.toPathList().map((p, index2) => {
      if (func(p, index2)) {
        return p.reverse();
      }
      return p;
    });
    return PathParser.joinPathList(pathList).toSVGString();
  }
  getCenterPointers() {
    let arr = [];
    let lastValues = [];
    this.segments.forEach((segment, index2) => {
      var v = segment.values;
      var c2 = segment.command;
      switch (c2) {
        case "M":
        case "L":
          arr.push({
            index: index2,
            pointer: [...segment.values, 0]
          });
          break;
        case "V":
          arr.push({
            index: index2,
            pointer: [v[0], lastValues.pop(), 0]
          });
          break;
        case "H":
          lastValues.pop();
          arr.push({
            index: index2,
            pointer: [lastValues.pop(), v[0], 0]
          });
          break;
        case "C":
        case "S":
        case "T":
        case "Q":
          arr.push({
            index: index2,
            pointer: [v[v.length - 2], v[v.length - 1], 0]
          });
          break;
      }
      lastValues = clone$1(v);
    });
    return arr;
  }
  get points() {
    return this.getCenterPointers();
  }
  getSamePointers(pointer, dist2 = 0) {
    return this.getCenterPointers().filter((p) => {
      if (distance$1(p.pointer, pointer) <= dist2) {
        return true;
      }
    });
  }
  getGroup() {
    const groupSegments = [];
    let newSegments = [];
    this.segments.forEach((segment, index2) => {
      if (segment.command === "M") {
        newSegments = [
          {
            index: index2,
            segment
          }
        ];
        groupSegments.push({
          index: index2,
          groupIndex: groupSegments.length,
          segments: newSegments
        });
      } else {
        newSegments.push({
          index: index2,
          segment
        });
      }
    });
    return groupSegments;
  }
  createGroupPath(index2) {
    var _a, _b;
    const path = new PathParser();
    path.resetSegments(((_b = (_a = this.getGroup()[index2]) == null ? void 0 : _a.segments) == null ? void 0 : _b.map((it) => {
      return it.segment;
    })) || []);
    return path;
  }
  toPathList() {
    return this.getGroup().map((group2) => {
      return PathParser.fromSegments(group2.segments.map((it) => it.segment));
    });
  }
  replaceSegment(index2, ...segments) {
    const newSegments = [...this.segments];
    newSegments.splice(index2, 1, ...segments);
    this.resetSegments(newSegments);
  }
  splitSegmentByPoint(pos, dist2 = 0) {
    const closedPointInfo = this.getClosedPointInfo(pos, dist2);
    if (closedPointInfo && closedPointInfo.t > 0 && closedPointInfo.t < 1) {
      switch (closedPointInfo.segment.command) {
        case "C":
          var list2 = getBezierPoints(closedPointInfo.points, closedPointInfo.t);
          var first = list2.first;
          var firstSegment = Segment.C(first[1].x, first[1].y, first[2].x, first[2].y, first[3].x, first[3].y);
          var second2 = list2.second;
          var secondSegment = Segment.C(second2[1].x, second2[1].y, second2[2].x, second2[2].y, second2[3].x, second2[3].y);
          this.replaceSegment(closedPointInfo.index, firstSegment, secondSegment);
          break;
        case "Q":
          var list2 = getBezierPointsQuard(closedPointInfo.points, closedPointInfo.t);
          var first = list2.first;
          var firstSegment = Segment.Q(first[1].x, first[1].y, first[2].x, first[2].y);
          var second2 = list2.second;
          var secondSegment = Segment.Q(second2[1].x, second2[1].y, second2[2].x, second2[2].y);
          this.replaceSegment(closedPointInfo.index, firstSegment, secondSegment);
          break;
        case "L":
          var list2 = getBezierPointsLine(closedPointInfo.points, closedPointInfo.t);
          var first = list2.first;
          var firstSegment = Segment.L(first[1].x, first[1].y);
          var second2 = list2.second;
          var secondSegment = Segment.L(second2[1].x, second2[1].y);
          this.replaceSegment(closedPointInfo.index, firstSegment, secondSegment);
          break;
        default:
          return;
      }
      return closedPointInfo;
    }
  }
  toMultiSegmentPathList() {
    const paths = [];
    const group2 = this.getGroup();
    group2.forEach((group3) => {
      group3.segments.forEach((s, index2) => {
        var _a;
        const prevSegment = group3.segments[index2 - 1];
        const lastValues = ((_a = prevSegment == null ? void 0 : prevSegment.segment) == null ? void 0 : _a.values) || [];
        const lastX = lastValues[lastValues.length - 2];
        const lastY = lastValues[lastValues.length - 1];
        const values = s.segment.values;
        if (s.segment.command === "M")
          ;
        else if (s.segment.command === "L") {
          paths.push(new PathParser(`M ${lastX} ${lastY}L ${values.join(" ")}`));
        } else if (s.segment.command === "C") {
          paths.push(new PathParser(`M ${lastX} ${lastY}C ${values.join(" ")}`));
        } else if (s.segment.command === "Q") {
          paths.push(new PathParser(`M ${lastX} ${lastY}Q ${values.join(" ")}`));
        } else
          ;
      });
    });
    return paths;
  }
  simplify(tolerance = 0.1) {
    const newGroupSegments = [];
    const groupList = this.getGroup();
    groupList.forEach((group2) => {
      const points = [
        ...group2.segments.filter((it) => it.segment.command.toLowerCase() !== "z").map((it) => {
          return {
            x: it.segment.values[0],
            y: it.segment.values[1]
          };
        })
      ];
      const newPoints = Point.simply(points, tolerance);
      const newSegments = [];
      newPoints.forEach((p, index2) => {
        if (index2 === 0) {
          newSegments.push(Segment.M(p.x, p.y));
        } else {
          newSegments.push(Segment.L(p.x, p.y));
        }
      });
      newGroupSegments.push(...newSegments);
    });
    return PathParser.fromSegments(newGroupSegments);
  }
  smooth(error = 50) {
    let newGroupSegments = [];
    const groupList = this.getGroup();
    groupList.forEach((group2) => {
      const points = [
        ...group2.segments.filter((it) => it.segment.command.toLowerCase() !== "z").map((it) => {
          return [...it.segment.values, 0];
        })
      ];
      const bezierCurve = fitCurve(points, error);
      const newSegments = [];
      bezierCurve.forEach((curve, index2) => {
        if (index2 === 0) {
          newSegments.push(Segment.M(...curve[0]));
        }
        newSegments.push(Segment.C(curve[1][0], curve[1][1], curve[2][0], curve[2][1], curve[3][0], curve[3][1]));
      });
      if (group2.segments[group2.segments.length - 1].segment.command.toLowerCase() === "z") {
        newSegments.push(Segment.Z());
      }
      newGroupSegments = newGroupSegments.concat(newSegments);
    });
    return PathParser.fromSegments(newGroupSegments);
  }
  cardinalSplines(tension = 0.5) {
    const newGroupSegments = [];
    const groupList = this.getGroup();
    groupList.forEach((group2) => {
      const points = [
        ...group2.segments.filter((it) => it.segment.command.toLowerCase() !== "z").map((it) => {
          return [...it.segment.values, 0];
        })
      ];
      const newPoints = [];
      points.forEach((point2, index2) => {
        const prevPoint = points[index2 - 1];
        const nextPoint = points[index2 + 1];
        if (index2 === 0) {
          newPoints.push({ point: point2 });
        } else if (index2 === points.length - 1) {
          const firstPoint = points[0];
          if (equals$2(firstPoint, point2)) {
            const p0 = prevPoint;
            const p1 = point2;
            const p2 = points[1];
            const V1 = div$1([], subtract([], p2, p0), [2, 2, 1]);
            const V3 = multiply([], V1, [1 - tension, 1 - tension, 1]);
            const V2 = negate([], V3);
            newPoints.push({
              reversePoint: add$1([], p1, V2),
              point: p1,
              endPoint: add$1([], p1, V3)
            });
          } else {
            newPoints.push({ point: point2 });
          }
        } else {
          const p0 = prevPoint;
          const p1 = point2;
          const p2 = nextPoint;
          const V1 = div$1([], subtract([], p2, p0), [2, 2, 1]);
          const V3 = multiply([], V1, [1 - tension, 1 - tension, 1]);
          const V2 = negate([], V3);
          newPoints.push({
            reversePoint: add$1([], p1, V2),
            point: p1,
            endPoint: add$1([], p1, V3)
          });
        }
      });
      const newSegments = [];
      newPoints.forEach((p, index2) => {
        if (index2 === 0) {
          newSegments.push(Segment.M(p.point[0], p.point[1]));
        } else {
          const prevPoint = newPoints[index2 - 1] || newPoints[newPoints.length - 1];
          if (!prevPoint.endPoint) {
            if (index2 === 1) {
              const lastPoint = newPoints[newPoints.length - 1];
              if (lastPoint.endPoint) {
                newSegments.push(Segment.C(lastPoint.endPoint[0], lastPoint.endPoint[1], p.reversePoint[0], p.reversePoint[1], p.point[0], p.point[1]));
              } else {
                newSegments.push(Segment.Q(p.reversePoint[0], p.reversePoint[1], p.point[0], p.point[1]));
              }
            } else {
              newSegments.push(Segment.Q(p.reversePoint[0], p.reversePoint[1], p.point[0], p.point[1]));
            }
          } else if (!p.reversePoint) {
            newSegments.push(Segment.Q(prevPoint.endPoint[0], prevPoint.endPoint[1], p.point[0], p.point[1]));
          } else {
            newSegments.push(Segment.C(prevPoint.endPoint[0], prevPoint.endPoint[1], p.reversePoint[0], p.reversePoint[1], p.point[0], p.point[1]));
          }
        }
      });
      newGroupSegments.push(...newSegments);
    });
    const newPath = new PathParser();
    newPath.resetSegments(newGroupSegments);
    return newPath;
  }
  Z() {
    this.segments.push(Segment.Z());
    return this;
  }
  M(x, y) {
    this.segments.push(Segment.M(x, y));
    return this;
  }
  L(x, y) {
    this.segments.push(Segment.L(x, y));
    return this;
  }
  C(x1, y1, x2, y2, x, y) {
    this.segments.push(Segment.C(x1, y1, x2, y2, x, y));
    return this;
  }
  Q(x1, y1, x, y) {
    this.segments.push(Segment.Q(x1, y1, x, y));
    return this;
  }
  drawRect(x, y, width2, height2) {
    this.segments.push(Segment.M(x, y), Segment.L(x + width2, y), Segment.L(x + width2, y + height2), Segment.L(x, y + height2), Segment.L(x, y), Segment.Z());
    return this;
  }
  drawLine(x1, y1, x2, y2) {
    this.segments.push(Segment.M(x1, y1), Segment.L(x2, y2));
    return this;
  }
  drawCircleWithRect(x, y, width2, height2 = width2) {
    var segmentSize = 0.552284749831;
    const path = new PathParser();
    path.resetSegments([
      Segment.M(0, -1),
      Segment.C(segmentSize, -1, 1, -segmentSize, 1, 0),
      Segment.C(1, segmentSize, segmentSize, 1, 0, 1),
      Segment.C(-segmentSize, 1, -1, segmentSize, -1, 0),
      Segment.C(-1, -segmentSize, -segmentSize, -1, 0, -1),
      Segment.Z()
    ]);
    path.translate(1, 1).scale(width2 / 2, height2 / 2).translate(x, y);
    this.addPath(path);
    return this;
  }
  drawCircle(cx, cy, radius) {
    return this.drawCircleWithRect(cx - radius, cy - radius, radius * 2, radius * 2);
  }
  drawArc(rx, ry, xAxisRotation, largeArcFlag, sweepFlag, x, y) {
    const [x1, y1] = this.lastPoint;
    return this.addPath(PathParser.arcToCurve(x1, y1, rx, ry, xAxisRotation, largeArcFlag, sweepFlag, x, y));
  }
  get verties() {
    let arr = [];
    let lastValues = [];
    this.each(function(segment) {
      var v = segment.values;
      var c2 = segment.command;
      switch (c2) {
        case "M":
        case "L":
          arr.push([...segment.values, 0]);
          break;
        case "V":
          arr.push([v[0], lastValues.pop(), 0]);
          break;
        case "H":
          lastValues.pop();
          arr.push([lastValues.pop(), v[0], 0]);
          break;
        case "C":
        case "S":
        case "T":
        case "Q":
          for (var i = 0, len2 = v.length; i < len2; i += 2) {
            arr.push([v[i], v[i + 1], 0]);
          }
          break;
      }
      lastValues = v;
    });
    return arr;
  }
  get pathVerties() {
    const pathVerties = [];
    this.segments.forEach((segment, segmentIndex) => {
      const prevSegment = this.segments[segmentIndex - 1];
      const nextSegment = this.segments[segmentIndex + 1];
      if (segment.values.length > 0) {
        const arr = segment.values;
        for (var i = 0, len2 = arr.length; i < len2; i += 2) {
          pathVerties.push({
            prevSegment,
            nextSegment,
            segment,
            segmentIndex,
            valueIndex: i,
            vertex: [arr[i], arr[i + 1], 0],
            x: arr[i],
            y: arr[i + 1]
          });
        }
      }
    });
    return pathVerties;
  }
  get d() {
    return this.toString().trim();
  }
  get closed() {
    return this.segments.some((segment) => segment.command === "Z") && equals$1(this.lastPoint, this.firstPoint);
  }
  get opened() {
    return !this.closed;
  }
  get length() {
    let totalLength = 0;
    const group2 = this.getGroup();
    group2.forEach((group3) => {
      group3.segments.forEach((s, index2) => {
        var _a;
        const prevSegment = group3.segments[index2 - 1];
        const lastValues = ((_a = prevSegment == null ? void 0 : prevSegment.segment) == null ? void 0 : _a.values) || [];
        const lastX = lastValues[lastValues.length - 2];
        const lastY = lastValues[lastValues.length - 1];
        const values = s.segment.values;
        if (s.segment.command === "M")
          ;
        else if (s.segment.command === "L") {
          totalLength += getDist(lastX, lastY, values[0], values[1]);
        } else if (s.segment.command === "C") {
          totalLength += getCurveDist(lastX, lastY, values[0], values[1], values[2], values[3], values[4], values[5]);
        } else if (s.segment.command === "Q") {
          totalLength += getQuardDist(lastX, lastY, values[0], values[1], values[2], values[3]);
        } else
          ;
      });
    });
    return totalLength;
  }
  get lengthList() {
    let totalLengthList = [];
    const group2 = this.getGroup();
    group2.forEach((group3, groupIndex) => {
      group3.segments.forEach((s, index2) => {
        var _a;
        const prevSegment = group3.segments[index2 - 1];
        const lastValues = ((_a = prevSegment == null ? void 0 : prevSegment.segment) == null ? void 0 : _a.values) || [];
        const lastX = lastValues[lastValues.length - 2];
        const lastY = lastValues[lastValues.length - 1];
        const values = s.segment.values;
        if (s.segment.command === "M")
          ;
        else if (s.segment.command === "L") {
          totalLengthList.push({
            groupIndex,
            segmentIndex: index2,
            length: getDist(lastX, lastY, values[0], values[1])
          });
        } else if (s.segment.command === "C") {
          totalLengthList.push({
            groupIndex,
            segmentIndex: index2,
            length: getCurveDist(lastX, lastY, values[0], values[1], values[2], values[3], values[4], values[5])
          });
        } else if (s.segment.command === "Q") {
          totalLengthList.push({
            groupIndex,
            segmentIndex: index2,
            length: getQuardDist(lastX, lastY, values[0], values[1], values[2], values[3])
          });
        } else
          ;
      });
    });
    return totalLengthList;
  }
  get lastSegment() {
    const segment = this.segments[this.segments.length - 1];
    if (segment.command !== "Z") {
      return segment;
    }
    return this.segments[this.segments.length - 2];
  }
  get lastPoint() {
    const values = this.lastSegment.values;
    return [values[values.length - 2], values[values.length - 1]];
  }
  get firstSegment() {
    const segment = this.segments[0];
    return segment;
  }
  get firstPoint() {
    const values = this.firstSegment.values;
    return [values[0], values[1]];
  }
  static joinPathList(pathList = []) {
    const newPath = PathParser.fromSVGString();
    pathList.forEach((path) => {
      newPath.addPath(path);
    });
    return newPath;
  }
  static fromSegments(segments) {
    const path = new PathParser();
    path.resetSegments(segments);
    return path;
  }
  static fromStructuredVerties(verties) {
    const path = new PathParser();
    const segments = [];
    verties.forEach((v) => {
      if (!segments[v.segmentIndex]) {
        segments[v.segmentIndex] = {
          command: v.segment.command,
          values: []
        };
      }
      if (segments[v.segmentIndex].command !== PathSegmentType.CLOSEPATH) {
        segments[v.segmentIndex].values[v.valueIndex] = v.vertex[0];
        segments[v.segmentIndex].values[v.valueIndex + 1] = v.vertex[1];
      }
    });
    path.resetSegments(segments);
    return path;
  }
  static fromSVGString(d = "") {
    return new PathParser(d);
  }
  static makeRect(x, y, width2, height2) {
    return PathParser.fromSVGString().drawRect(x, y, width2, height2);
  }
  static makeLine(x, y, x2, y2) {
    return PathParser.fromSVGString().drawLine(x, y, x2, y2);
  }
  static makeCircle(x, y, width2, height2) {
    return PathParser.fromSVGString().drawCircleWithRect(x, y, width2, height2);
  }
  static makePathByPoints(points = []) {
    const segments = points.map((p, index2) => {
      if (index2 === 0) {
        return Segment.M(p.x, p.y);
      } else {
        return Segment.L(p.x, p.y);
      }
    });
    segments.push(Segment.Z());
    return PathParser.fromSegments(segments);
  }
  static makePathByVerties(verties = [], isClosed = true) {
    const segments = verties.map((v, index2) => {
      if (index2 === 0) {
        return Segment.M(v[0], v[1]);
      } else {
        return Segment.L(v[0], v[1]);
      }
    });
    if (isClosed) {
      segments.push(Segment.Z());
    }
    return PathParser.fromSegments(segments);
  }
  static makePolygon(width2, height2, count = 3) {
    const segments = [];
    const centerX = 1 / 2;
    const centerY = 1 / 2;
    for (var i = 0; i < count; i++) {
      var angle = i / count * Math.PI * 2 - Math.PI / 2;
      var x = Math.cos(angle) * centerX + centerX;
      var y = Math.sin(angle) * centerY + centerY;
      if (i === 0) {
        segments.push(Segment.M(x, y));
      } else {
        segments.push(Segment.L(x, y));
      }
    }
    segments.push(Segment.L(segments[0].values[0], segments[0].values[1]));
    segments.push(Segment.Z());
    return PathParser.fromSegments(segments).scale(width2, height2);
  }
  static makeStar(width2, height2, count = 5, radius = 0.5) {
    const segments = [];
    const centerX = 1 / 2;
    const centerY = 1 / 2;
    const outerRadius = Math.min(centerX, centerY);
    const innerRadius = outerRadius * radius;
    const npoints = count * 2;
    let firstX, firstY = 0;
    for (var i = 0; i < npoints; i++) {
      var angle = i / npoints * Math.PI * 2 - Math.PI / 2;
      var radius = i % 2 === 0 ? outerRadius : innerRadius;
      var x = Math.cos(angle) * radius + centerX;
      var y = Math.sin(angle) * radius + centerY;
      if (i === 0) {
        segments.push(Segment.M(x, y));
        firstX = x;
        firstY = y;
      } else {
        segments.push(Segment.L(x, y));
      }
    }
    segments.push(Segment.L(firstX, firstY));
    segments.push(Segment.Z());
    return PathParser.fromSegments(segments).scale(width2, height2);
  }
  static makeCurvedStar(width2, height2, count = 5, radius = 0.5, tension = 0.5) {
    const starPath = PathParser.makeStar(width2, height2, count, radius);
    return starPath.cardinalSplines(tension);
  }
  static arcToCurve(x1, y1, rx, ry, xAxisRotation, largeArcFlag, sweepFlag, x2, y2) {
    const bezierCurveList = arcToBezier({
      px: x1,
      py: y1,
      cx: x2,
      cy: y2,
      rx,
      ry,
      xAxisRotation,
      largeArcFlag,
      sweepFlag
    });
    const path = new PathParser();
    path.M(x1, y1);
    bezierCurveList.forEach((bezierCurve) => {
      path.C(bezierCurve.x1, bezierCurve.y1, bezierCurve.x2, bezierCurve.y2, bezierCurve.x, bezierCurve.y);
    });
    return path;
  }
  toCurveList() {
    const curveList = [];
    this.segments.forEach((segment, index2) => {
      if (index2 > 0) {
        const prevSegment = this.segments[index2 - 1];
        const lastPoint = [
          prevSegment.values[prevSegment.values.length - 2],
          prevSegment.values[prevSegment.values.length - 1]
        ];
        const points = [
          xy$2(lastPoint),
          xy$2([segment.values[0], segment.values[1]]),
          xy$2([segment.values[2], segment.values[3]]),
          xy$2([segment.values[4], segment.values[5]])
        ];
        curveList.push({
          points,
          curveFunction: createBezier(...points)
        });
      }
    });
    return curveList;
  }
  toInterpolateFunction() {
    const curveList = this.normalize().toCurveList().map((curve) => {
      return {
        points: curve.points,
        curveFunction: curve.curveFunction,
        start: curve.points[0].x,
        end: curve.points[curve.points.length - 1].x
      };
    });
    return (t) => {
      const currentCurve = curveList.find((it) => {
        return it.start <= t && t <= it.end;
      });
      if (currentCurve) {
        const point2 = currentCurve.curveFunction(t);
        return point2.y;
      }
      if (t === 0) {
        return curveList[0].points[0].y;
      }
      const points = curveList[curveList.length - 1].points;
      return points[points.length - 1].y;
    };
  }
}
function easeOutElastic() {
  return (rate) => {
    return Math.pow(2, -10 * rate) * Math.sin((rate - 0.1) * 5 * Math.PI) + 1;
  };
}
const stepTimingFunction = (step2 = 1, direction2 = "end") => {
  var stepDist = 1 / step2;
  return function(rate) {
    let pos = 0;
    const offset = round(rate / stepDist, 1e7);
    if (direction2 == "start") {
      pos = Math.ceil(offset);
    } else if (direction2 == "end") {
      if (rate === 0)
        return 0;
      else if (rate === 1)
        return 1;
      pos = Math.ceil(offset) - 1;
    }
    return Math.min(Math.max(stepDist * pos, 0), 1);
  };
};
function step(step2 = 1, direction2 = "end") {
  return stepTimingFunction(step2, direction2);
}
function stepStart() {
  return stepTimingFunction(1, "start");
}
function stepEnd() {
  return stepTimingFunction(1, "end");
}
var timingFunctions = {
  step,
  "step-start": stepStart,
  "step-end": stepEnd,
  stepStart,
  stepEnd,
  "ease-out-elastic": easeOutElastic,
  easeOutElastic
};
function createTimingFunction(timing = "linear") {
  var [funcName] = timing.split("(").map((it) => it.trim());
  var func = timingFunctions[funcName];
  if (func) {
    var args2 = timing.split("(")[1].split(")")[0].split(",").map((it) => it.trim());
    return func(...args2);
  } else {
    return createCurveFunction(timing);
  }
}
function createCurveFunction(timing) {
  var func = createBezierForPattern(timing);
  return (rate) => {
    return func(rate).y;
  };
}
const DEFINED_ANGLES$2 = {
  "to top": 0,
  "to top right": 45,
  "to right": 90,
  "to bottom right": 135,
  "to bottom": 180,
  "to bottom left": 225,
  "to left": 270,
  "to top left": 315
};
class Gradient extends ImageResource {
  isGradient() {
    return true;
  }
  toString() {
    return "none";
  }
  getDefaultObject(obj2 = {}) {
    return __spreadValues({
      itemType: "image-resource",
      type: "gradient",
      colorsteps: []
    }, obj2);
  }
  toCloneObject() {
    return __spreadProps(__spreadValues({}, super.toCloneObject()), {
      colorsteps: this.json.colorsteps.map((color2) => color2.clone())
    });
  }
  convert(json) {
    if (json.colorsteps[0] instanceof ColorStep)
      ;
    else {
      json.colorsteps = json.colorsteps.map((c2) => new ColorStep(c2));
    }
    return json;
  }
  calculateAngle() {
    var angle = this.json.angle;
    return isUndefined(DEFINED_ANGLES$2[angle]) ? angle : DEFINED_ANGLES$2[angle] || 0;
  }
  addColorStep(colorstep, isSort = true) {
    this.json.colorsteps.push(colorstep);
    if (isSort)
      this.sortColorStep();
    return colorstep;
  }
  pickColorStep(percent) {
    var colorsteps = this.colorsteps;
    if (!colorsteps.length) {
      return { percent: 0, color: "rgba(0,0,0,0)" };
    }
    if (percent < colorsteps[0].percent) {
      return {
        percent,
        color: colorsteps[0].color
      };
    }
    var lastIndex = colorsteps.length - 1;
    if (colorsteps[lastIndex].percent < percent) {
      return {
        percent,
        color: colorsteps[lastIndex].color
      };
    }
    for (var i = 0, len2 = colorsteps.length - 1; i < len2; i++) {
      var currentStep = colorsteps[i];
      var nextStep = colorsteps[i + 1];
      if (currentStep.percent <= percent && percent <= nextStep.percent) {
        const timing = nextStep.timing;
        switch (timing.name) {
          case TimingFunction.STEPS:
            var func = step(timing.count, timing.direction);
            break;
          case TimingFunction.PATH:
            var func = PathParser.fromSVGString(timing.d).toInterpolateFunction();
          default:
            var func = createTimingFunction(timing.matchedString);
            break;
        }
        var stopPercent = (percent - currentStep.percent) / (nextStep.percent - currentStep.percent);
        const color2 = mix(currentStep.color, nextStep.color, func(stopPercent));
        return {
          percent,
          color: color2
        };
      }
    }
  }
  insertColorStep(percent, startColor = "rgba(216,216,216,0)", endColor = "rgba(216,216,216,1)") {
    var colorsteps = this.colorsteps;
    if (!colorsteps.length) {
      this.addColorStepList([
        new ColorStep({ color: startColor, percent, index: 0 }),
        new ColorStep({ color: endColor, percent: 100, index: 100 })
      ]);
      return;
    }
    if (percent < colorsteps[0].percent) {
      colorsteps[0].index = 1;
      this.addColorStep(new ColorStep({ index: 0, color: colorsteps[0].color, percent }));
      return 0;
    }
    var lastIndex = colorsteps.length - 1;
    if (colorsteps[lastIndex].percent < percent) {
      var color2 = colorsteps[lastIndex].color;
      var index2 = colorsteps[lastIndex].index + 1;
      this.addColorStep(new ColorStep({ index: index2, color: color2, percent }));
      return index2;
    }
    for (var i = 0, len2 = colorsteps.length - 1; i < len2; i++) {
      var step2 = colorsteps[i];
      var nextStep = colorsteps[i + 1];
      if (step2.percent <= percent && percent <= nextStep.percent) {
        var color2 = mix(step2.color, nextStep.color, (percent - step2.percent) / (nextStep.percent - step2.percent), "rgb");
        this.addColorStep(new ColorStep({ index: step2.index + 1, color: color2, percent }));
        return i + 1;
      }
    }
  }
  sortColorStep() {
    var children2 = this.colorsteps;
    children2.sort((a, b) => {
      if (a.percent > b.percent)
        return 1;
      if (a.percent < b.percent)
        return -1;
      if (a.percent == b.percent) {
        if (a.index === b.index)
          return 0;
        return a.index > b.index ? 1 : -1;
      }
    });
    children2.forEach((it, index2) => {
      it.index = index2 * 100;
    });
  }
  sortToRight() {
    var children2 = this.colorsteps;
    const length2 = children2.length;
    const unit = 100 / length2;
    children2.forEach((it, index2) => {
      it.percent = unit * (index2 + 1);
    });
    this.sortColorStep();
  }
  sortToLeft() {
    var children2 = this.colorsteps;
    const length2 = children2.length;
    const unit = 100 / length2;
    children2.forEach((it, index2) => {
      it.percent = unit * index2;
    });
    this.sortColorStep();
  }
  addColorStepList(colorstepList = []) {
    colorstepList.forEach((c2) => {
      this.addColorStep(c2, false);
    });
    this.sortColorStep();
  }
  getColorStep(id) {
    return this.json.colorsteps.filter((c2) => c2.id == id)[0];
  }
  clear(...args2) {
    if (args2.length) {
      this.json.colorsteps.splice(+args2[0], 1);
    } else {
      this.json.colorsteps = [];
    }
  }
  removeColorStepByIndex(index2) {
    this.json.colorsteps.splice(index2, 1);
  }
  removeColorStep(id) {
    this.json.colorsteps = this.json.colorsteps.filter((it) => it.id != id);
  }
  get colorsteps() {
    return this.json.colorsteps;
  }
  makeTimingString(timing, timingCount = 1) {
    switch (timing.name) {
      case TimingFunction.LINEAR:
        return ``;
      case TimingFunction.EASE:
      case TimingFunction.EASE_IN:
      case TimingFunction.EASE_OUT:
      case TimingFunction.EASE_IN_OUT:
        return `${timing.name} ${timingCount}`;
      case TimingFunction.STEPS:
        return `steps(${timing.count}, ${timing.direction})`;
      case TimingFunction.PATH:
        return `path(${timing.d}) ${timingCount}`;
      default:
        return `cubic-bezier(${timing.x1}, ${timing.y1}, ${timing.x2}, ${timing.y2}) ${timingCount}`;
    }
  }
  getColorString() {
    return this.colorsteps.map((it) => {
      const { color: color2, percent, timing, timingCount } = it;
      return `${color2} ${percent}% ${this.makeTimingString(timing, timingCount)}`;
    }).join(",");
  }
  static makeColorStepList(colorsteps) {
    const results = [];
    colorsteps.forEach((it, index2) => {
      const { color: color2, percent, timing, timingCount } = it;
      var prevColorStep = colorsteps[index2 - 1];
      if (index2 === 0) {
        results.push({ color: color2, percent });
        return results;
      }
      switch (timing.name) {
        case TimingFunction.STEPS:
          var func = step(timing.count, timing.direction);
          var localColorSteps = [];
          for (var i = 0; i <= timing.count; i++) {
            var stopPercent = prevColorStep.percent + (percent - prevColorStep.percent) * (i / timing.count);
            var stopColor = mix(prevColorStep.color, color2, func(i / timing.count));
            localColorSteps.push({ percent: stopPercent, color: stopColor });
          }
          localColorSteps.forEach((obj2, index3) => {
            if (index3 === 0) {
              results.push({
                percent: prevColorStep.percent,
                color: obj2.color
              });
              results.push(obj2);
            } else {
              const prev = localColorSteps[index3 - 1];
              results.push({ percent: prev.percent, color: obj2.color });
              results.push(obj2);
            }
          });
          break;
        case TimingFunction.PATH:
          var func = PathParser.fromSVGString(timing.d).toInterpolateFunction();
          var localColorSteps = [];
          for (var i = 0; i <= timingCount; i++) {
            const stopPercent2 = prevColorStep.percent + (percent - prevColorStep.percent) * (i / timingCount);
            const stopColor2 = mix(prevColorStep.color, color2, func(i / timingCount));
            localColorSteps.push({ percent: stopPercent2, color: stopColor2 });
          }
          results.push(...localColorSteps);
          break;
        default:
          var func = createTimingFunction(timing.matchedString);
          var localColorSteps = [];
          for (var i = 0; i <= timingCount; i++) {
            const stopPercent2 = prevColorStep.percent + (percent - prevColorStep.percent) * (i / timingCount);
            const stopColor2 = mix(prevColorStep.color, color2, func(i / timingCount));
            localColorSteps.push({ percent: stopPercent2, color: stopColor2 });
          }
          results.push(...localColorSteps);
          break;
      }
    });
    return results;
  }
  static toCSSColorString(colorsteps = [], unit = "%", maxValue = 100) {
    const list2 = Gradient.makeColorStepList(colorsteps);
    return list2.map((it) => {
      const { color: color2, percent } = it;
      const pos = percent / 100 * maxValue;
      return `${color2} ${pos}${unit}`;
    }).join(",");
  }
  static parseColorSteps(colors2) {
    return colors2.map((it, index2) => {
      var _a, _b, _c;
      if (it.length === 1) {
        const prev = ((_a = colors2[index2 - 1]) == null ? void 0 : _a[1]) || { parsed: { value: 0 } };
        const next = ((_b = colors2[index2 + 1]) == null ? void 0 : _b[1]) || { parsed: { value: 100 } };
        let percent = 0;
        if (!colors2[index2 - 1]) {
          percent = 0;
        } else if (!colors2[index2 + 1]) {
          percent = 100;
        } else {
          percent = prev.parsed.value + (next.parsed.value - prev.parsed.value) * 0.5;
        }
        return new ColorStep({
          color: it[0].matchedString,
          percent,
          unit: "%",
          timing: parseOneValue("linear").parsed,
          timingCount: 1
        });
      }
      if (it.length === 2) {
        return new ColorStep({
          color: it[0].matchedString,
          percent: it[1].parsed.value,
          unit: it[1].parsed.unit,
          timing: parseOneValue("linear").parsed,
          timingCount: 1
        });
      } else if (it.length === 3) {
        if (it[2].parsed.funcType === FuncType.TIMING) {
          return new ColorStep({
            color: it[0].matchedString,
            percent: it[1].parsed.value,
            unit: it[1].parsed.unit,
            timing: it[2].parsed,
            timingCount: (_c = it[3]) == null ? void 0 : _c.parsed.value
          });
        }
        return new ColorStep({
          color: it[0].matchedString,
          percent: it[2].parsed.value,
          unit: it[2].parsed.unit,
          timing: parseOneValue(`steps(1, start)`).parsed
        });
      } else if (it.length === 4) {
        return new ColorStep({
          color: it[0].matchedString,
          percent: it[1].parsed.value,
          unit: it[1].parsed.unit,
          timing: it[2].parsed,
          timingCount: it[3].parsed.value
        });
      }
    });
  }
}
const DEFINED_POSITIONS$1 = {
  ["center"]: true,
  ["top"]: true,
  ["left"]: true,
  ["right"]: true,
  ["bottom"]: true
};
const DEFINED_ANGLES$1 = {
  "to top": 0,
  "to top right": 45,
  "to right": 90,
  "to bottom right": 135,
  "to bottom": 180,
  "to bottom left": 225,
  "to left": 270,
  "to top left": 315
};
class ConicGradient extends Gradient {
  getDefaultObject(obj2 = {}) {
    return super.getDefaultObject(__spreadValues({
      type: "conic-gradient",
      angle: 0,
      radialPosition: [Position.CENTER, Position.CENTER]
    }, obj2));
  }
  toCloneObject() {
    return __spreadProps(__spreadValues({}, super.toCloneObject()), {
      angle: this.json.angle,
      radialPosition: clone$1(this.json.radialPosition)
    });
  }
  hasAngle() {
    return true;
  }
  pickColorStep(percent) {
    return super.pickColorStep((percent + 100) % 100);
  }
  getStartEndPoint(result) {
    let startPoint, endPoint, shapePoint;
    let [rx, ry] = this.json.radialPosition;
    const backRect = result.backRect;
    const backVerties = rectToVerties(backRect.x, backRect.y, backRect.width, backRect.height);
    if (rx == "center")
      rx = Length.percent(50);
    if (ry == "center")
      ry = Length.percent(50);
    const newRx = rx.toPx(backRect.width);
    const newRy = ry.toPx(backRect.height);
    const centerPoisiton = [
      backRect.x + newRx.value,
      backRect.y + newRy.value,
      0
    ];
    let topLeftPoint = backVerties[0];
    let topRightPoint = backVerties[1];
    let bottomLeftPoint = backVerties[3];
    let bottomRightPoint = backVerties[2];
    const topLeftDist = dist(centerPoisiton, topLeftPoint);
    const topRightDist = dist(centerPoisiton, topRightPoint);
    const bottomLeftDist = dist(centerPoisiton, bottomLeftPoint);
    const bottomRightDist = dist(centerPoisiton, bottomRightPoint);
    startPoint = clone(centerPoisiton);
    const dist$1 = Math.max(topLeftDist, topRightDist, bottomLeftDist, bottomRightDist);
    endPoint = fromValues(startPoint[0] + dist$1, startPoint[1], startPoint[2]);
    shapePoint = fromValues(startPoint[0], startPoint[1] - dist$1, startPoint[2]);
    return {
      startPoint,
      endPoint,
      shapePoint
    };
  }
  toString() {
    var colorString = this.getColorString();
    var opt = [];
    var json = this.json;
    var conicAngle = json.angle;
    var conicPosition = json.radialPosition || Position.CENTER;
    conicPosition = DEFINED_POSITIONS$1[conicPosition] ? conicPosition : conicPosition.join(" ");
    if (isNotUndefined(conicAngle)) {
      conicAngle = +(DEFINED_ANGLES$1[conicAngle] || conicAngle);
      opt.push(`from ${conicAngle}deg`);
    }
    if (conicPosition) {
      opt.push(`at ${conicPosition}`);
    }
    var optString = opt.length ? opt.join(" ") + "," : "";
    return `${json.type}(${optString} ${colorString})`;
  }
  toCSSString() {
    if (this.colorsteps.length === 0)
      return "";
    var colorString = ConicGradient.toCSSColorString(this.colorsteps, "deg", 360);
    var opt = [];
    var json = this.json;
    var conicAngle = json.angle;
    var conicPosition = json.radialPosition || Position.CENTER;
    conicPosition = DEFINED_POSITIONS$1[conicPosition] ? conicPosition : conicPosition.join(" ");
    if (isNotUndefined(conicAngle)) {
      conicAngle = +(DEFINED_ANGLES$1[conicAngle] || conicAngle);
      opt.push(`from ${conicAngle}deg`);
    }
    if (conicPosition) {
      opt.push(`at ${conicPosition}`);
    }
    var optString = opt.length ? opt.join(" ") + "," : "";
    return `${json.type}(${optString} ${colorString})`;
  }
  static parse(str) {
    const result = parseOneValue(str);
    var opt = {
      angle: 0,
      radialPosition: ["center", "center"]
    };
    let [options2, ...colors2] = result.parameters;
    if (options2[0].func !== FuncType.COLOR) {
      let hasFrom = false;
      let hasAt = false;
      let positions = [];
      let angle = [];
      options2.forEach((it) => {
        if (it.func === FuncType.KEYWORD && it.matchedString === "from") {
          hasFrom = true;
        } else if (it.func === FuncType.KEYWORD && it.matchedString === "at") {
          hasAt = true;
        } else if (hasAt) {
          positions.push(it);
        } else if (hasFrom) {
          angle.push(it);
        }
      });
      opt.radialPosition = positions.map((it) => {
        if (it.func === FuncType.KEYWORD) {
          switch (it.matchedString) {
            case "top":
              return Length.percent(0);
            case "left":
              return Length.percent(0);
            case "right":
              return Length.percent(100);
            case "bottom":
              return Length.percent(100);
            case "center":
              return Length.percent(50);
          }
        }
        return it.parsed;
      });
      if (angle.length) {
        opt.angle = angle[0].parsed.value;
      }
    } else {
      colors2 = result.parameters;
    }
    const colorsteps = ConicGradient.parseColorSteps(colors2);
    return new ConicGradient(__spreadProps(__spreadValues({}, opt), { colorsteps }));
  }
}
const DEFINED_DIRECTIONS = {
  0: "to top",
  45: "to top right",
  90: "to right",
  135: "to bottom right",
  180: "to bottom",
  225: "to bottom left",
  270: "to left",
  315: "to top left"
};
const DEFINED_ANGLES = {
  "to top": 0,
  "to top right": 45,
  "to right": 90,
  "to bottom right": 135,
  "to bottom": 180,
  "to bottom left": 225,
  "to left": 270,
  "to top left": 315
};
class LinearGradient extends Gradient {
  getDefaultObject(obj2) {
    return super.getDefaultObject(__spreadValues({
      type: "linear-gradient",
      angle: 0
    }, obj2));
  }
  toCloneObject() {
    return __spreadProps(__spreadValues({}, super.toCloneObject()), {
      angle: this.json.angle
    });
  }
  isLinear() {
    return true;
  }
  hasAngle() {
    return true;
  }
  getRealAngle() {
    return this.json.angle;
  }
  get angle() {
    return this.getRealAngle();
  }
  toString() {
    if (this.colorsteps.length === 0)
      return "";
    var colorString = this.getColorString();
    var opt = "";
    var angle = this.json.angle || 0;
    opt = angle;
    if (isNumber(opt)) {
      opt = DEFINED_DIRECTIONS[`${opt}`] || opt;
    }
    if (isNumber(opt)) {
      opt = opt > 360 ? opt % 360 : opt;
      opt = `${opt}deg`;
    }
    var result = `${this.json.type}(${opt}, ${colorString})`;
    return result;
  }
  toCSSString() {
    if (this.colorsteps.length === 0)
      return "";
    var colorString = LinearGradient.toCSSColorString(this.colorsteps);
    var opt = "";
    var angle = this.json.angle || 0;
    opt = angle;
    if (isNumber(opt)) {
      opt = DEFINED_DIRECTIONS[`${opt}`] || opt;
    }
    if (isNumber(opt)) {
      opt = opt > 360 ? opt % 360 : opt;
      opt = `${opt}deg`;
    }
    var result = `${this.json.type}(${opt}, ${colorString})`;
    return result;
  }
  static parse(str) {
    const result = parseOneValue(str);
    var opt = {};
    let [options2, ...colors2] = result.parameters;
    const list2 = [];
    const keywords = [];
    if (options2[0].func !== FuncType.COLOR) {
      options2.forEach((it) => {
        if (it.func === FuncType.KEYWORD) {
          keywords.push(it);
        } else {
          list2.push(it);
        }
      });
    } else {
      colors2 = result.parameters;
    }
    let angle = keywords.map((it) => it.matchedString).join(" ");
    if (angle === "") {
      [angle] = list2.map((it) => it.parsed.value);
    } else {
      angle = DEFINED_ANGLES[angle];
    }
    opt = __spreadProps(__spreadValues({}, opt), {
      angle
    });
    const colorsteps = LinearGradient.parseColorSteps(colors2);
    return new LinearGradient(__spreadProps(__spreadValues({}, opt), { colorsteps }));
  }
}
const DEFINED_POSITIONS = {
  ["center"]: true,
  ["top"]: true,
  ["left"]: true,
  ["right"]: true,
  ["bottom"]: true
};
class RadialGradient extends Gradient {
  getDefaultObject(obj2 = {}) {
    return super.getDefaultObject(__spreadValues({
      type: "radial-gradient",
      radialType: "ellipse",
      radialSize: RadialGradientSizeType.FARTHEST_CORNER,
      radialPosition: [Position.CENTER, Position.CENTER]
    }, obj2));
  }
  toCloneObject() {
    return __spreadValues(__spreadValues({}, super.toCloneObject()), this.attrs("radialType", "radialSize", "radialPosition"));
  }
  getConerDist(result) {
    let topLeftPoint = result.backVerties[0];
    let topRightPoint = result.backVerties[1];
    let bottomLeftPoint = result.backVerties[3];
    let bottomRightPoint = result.backVerties[2];
    const topLeftDist = dist(result.radialCenterPosition, topLeftPoint);
    const topRightDist = dist(result.radialCenterPosition, topRightPoint);
    const bottomLeftDist = dist(result.radialCenterPosition, bottomLeftPoint);
    const bottomRightDist = dist(result.radialCenterPosition, bottomRightPoint);
    const cornerList = [
      ["top-left", topLeftPoint, topLeftDist],
      ["top-right", topRightPoint, topRightDist],
      ["bottom-left", bottomLeftPoint, bottomLeftDist],
      ["bottom-right", bottomRightPoint, bottomRightDist]
    ];
    cornerList.sort((a, b) => {
      return a[2] - b[2];
    });
    return {
      cornerList,
      topLeftDist,
      topRightDist,
      bottomLeftDist,
      bottomRightDist
    };
  }
  EllipseRadiusToSide(result, isClosest = true) {
    var dx1 = Math.abs(result.radialCenterPoint[0]);
    var dy1 = Math.abs(result.radialCenterPoint[1]);
    var dx2 = Math.abs(result.radialCenterPoint[0] - result.backRect.width);
    var dy2 = Math.abs(result.radialCenterPoint[1] - result.backRect.height);
    if (isClosest) {
      var dx = dx1 < dx2 ? dx1 : dx2;
      var dy = dy1 < dy2 ? dy1 : dy2;
    } else {
      var dx = dx1 > dx2 ? dx1 : dx2;
      var dy = dy1 > dy2 ? dy1 : dy2;
    }
    return { width: dx, height: dy };
  }
  EllipseRadius(newSize, result, isClosest = true) {
    const {
      cornerList,
      topLeftDist,
      topRightDist,
      bottomRightDist,
      bottomLeftDist
    } = this.getConerDist(result);
    const targetList = [
      topLeftDist,
      topRightDist,
      bottomLeftDist,
      bottomRightDist
    ];
    var raySize = isClosest ? Math.min(...targetList) : Math.max(...targetList);
    var point2 = cornerList.find((it) => it[2] === raySize)[1];
    var aspect_ratio = newSize.width / newSize.height;
    if (aspect_ratio === 0) {
      return;
    }
    var distPoint = subtract([], point2, result.radialCenterPosition);
    var a = Math.sqrt(Math.pow(distPoint[0], 2) + Math.pow(distPoint[1], 2) * Math.pow(aspect_ratio, 2));
    var b = a / aspect_ratio;
    return { width: a, height: b };
  }
  getStartEndPoint(result) {
    let startPoint, endPoint, shapePoint;
    const radialType = this.json.radialType;
    const radialSize = this.json.radialSize;
    let [rx, ry] = this.json.radialPosition;
    const backRect = result.backRect;
    const backVerties = rectToVerties(backRect.x, backRect.y, backRect.width, backRect.height);
    if (rx == "center")
      rx = Length.percent(50);
    if (ry == "center")
      ry = Length.percent(50);
    const newRx = rx.toPx(backRect.width);
    const newRy = ry.toPx(backRect.height);
    const centerPoisiton = [
      backRect.x + newRx.value,
      backRect.y + newRy.value,
      0
    ];
    let leftPoint = [backVerties[0][0], newRy.value, 0];
    let rightPoint = [backVerties[1][0], newRy.value, 0];
    let topPoint = [newRx.value, backVerties[0][1], 0];
    let bottomPoint = [newRx.value, backVerties[3][1], 0];
    const leftDist = dist(centerPoisiton, leftPoint);
    const rightDist = dist(centerPoisiton, rightPoint);
    const topDist = dist(centerPoisiton, topPoint);
    const bottomDist = dist(centerPoisiton, bottomPoint);
    const list2 = [
      ["top", topPoint, topDist],
      ["left", leftPoint, leftDist],
      ["right", rightPoint, rightDist],
      ["bottom", bottomPoint, bottomDist]
    ];
    list2.sort((a, b) => {
      return a[2] - b[2];
    });
    let topLeftPoint = backVerties[0];
    let topRightPoint = backVerties[1];
    let bottomLeftPoint = backVerties[3];
    let bottomRightPoint = backVerties[2];
    const topLeftDist = dist(centerPoisiton, topLeftPoint);
    const topRightDist = dist(centerPoisiton, topRightPoint);
    const bottomLeftDist = dist(centerPoisiton, bottomLeftPoint);
    const bottomRightDist = dist(centerPoisiton, bottomRightPoint);
    const cornerList = [
      ["top-left", topLeftPoint, topLeftDist],
      ["top-right", topRightPoint, topRightDist],
      ["bottom-left", bottomLeftPoint, bottomLeftDist],
      ["bottom-right", bottomRightPoint, bottomRightDist]
    ];
    cornerList.sort((a, b) => {
      return a[2] - b[2];
    });
    startPoint = clone(centerPoisiton);
    switch (radialType) {
      case RadialGradientType.CIRCLE:
        switch (radialSize) {
          case RadialGradientSizeType.CLOSEST_SIDE:
            var [, , dist$1] = list2[0];
            endPoint = fromValues(startPoint[0] + dist$1, startPoint[1], startPoint[2]);
            shapePoint = fromValues(startPoint[0], startPoint[1] + dist$1, startPoint[2]);
            break;
          case RadialGradientSizeType.CLOSEST_CORNER:
            var [, , dist$1] = cornerList[0];
            endPoint = fromValues(startPoint[0] + dist$1, startPoint[1], startPoint[2]);
            shapePoint = fromValues(startPoint[0], startPoint[1] + dist$1, startPoint[2]);
            break;
          case RadialGradientSizeType.FARTHEST_SIDE:
            var [, , dist$1] = list2[list2.length - 1];
            endPoint = fromValues(startPoint[0] + dist$1, startPoint[1], startPoint[2]);
            shapePoint = fromValues(startPoint[0], startPoint[1] + dist$1, startPoint[2]);
            break;
          case RadialGradientType.CIRCLE:
          case RadialGradientSizeType.FARTHEST_CORNER:
            var [, , dist$1] = cornerList[cornerList.length - 1];
            endPoint = fromValues(startPoint[0] + dist$1, startPoint[1], startPoint[2]);
            shapePoint = fromValues(startPoint[0], startPoint[1] + dist$1, startPoint[2]);
            break;
          default:
            var dist$1 = (radialSize[0] || radialSize).toPx(dist(result.backVerties[1], result.backVerties[0])).value;
            endPoint = fromValues(startPoint[0] + dist$1, startPoint[1], startPoint[2]);
            shapePoint = fromValues(startPoint[0], startPoint[1] + dist$1, startPoint[2]);
            break;
        }
        break;
      case RadialGradientType.ELLIPSE:
        switch (radialSize) {
          case RadialGradientSizeType.CLOSEST_SIDE:
            var newSize = this.EllipseRadiusToSide(result, true);
            endPoint = fromValues(startPoint[0] + newSize.width, startPoint[1], startPoint[2]);
            shapePoint = fromValues(startPoint[0], startPoint[1] + newSize.height, startPoint[2]);
            break;
          case RadialGradientSizeType.CLOSEST_CORNER:
            var newSize = this.EllipseRadiusToSide(result, true);
            var radius = this.EllipseRadius(newSize, result, true);
            endPoint = fromValues(startPoint[0] + radius.width, startPoint[1], startPoint[2]);
            shapePoint = fromValues(startPoint[0], startPoint[1] + radius.height, startPoint[2]);
            break;
          case RadialGradientSizeType.FARTHEST_SIDE:
            var newSize = this.EllipseRadiusToSide(result, false);
            endPoint = fromValues(startPoint[0] + newSize.width, startPoint[1], startPoint[2]);
            shapePoint = fromValues(startPoint[0], startPoint[1] + newSize.height, startPoint[2]);
            break;
          case RadialGradientSizeType.FARTHEST_CORNER:
            var newSize = this.EllipseRadiusToSide(result, false);
            var radius = this.EllipseRadius(newSize, result, false);
            endPoint = fromValues(startPoint[0] + radius.width, startPoint[1], startPoint[2]);
            shapePoint = fromValues(startPoint[0], startPoint[1] + radius.height, startPoint[2]);
            break;
          default:
            var raySize = radialSize[0].toPx(dist(result.backVerties[1], result.backVerties[0])).value;
            var shapeSize = radialSize[1].toPx(dist(result.backVerties[3], result.backVerties[0])).value;
            endPoint = fromValues(startPoint[0] + raySize, startPoint[1], startPoint[2]);
            shapePoint = fromValues(startPoint[0], startPoint[1] + shapeSize, startPoint[2]);
            break;
        }
        break;
    }
    return {
      startPoint,
      endPoint,
      shapePoint
    };
  }
  toString() {
    if (this.colorsteps.length === 0)
      return "";
    var colorString = this.getColorString();
    var json = this.json;
    var opt = "";
    var radialType = json.radialType || RadialGradientType.ELLIPSE;
    var radialSize = json.radialSize || RadialGradientSizeType.FARTHEST_CORNER;
    var radialPosition = json.radialPosition || ["center", "center"];
    radialPosition = DEFINED_POSITIONS[radialPosition] ? radialPosition : radialPosition.join(" ");
    radialSize = isArray(radialSize) ? radialSize.join(" ") : radialSize;
    opt = radialPosition ? `${radialType} ${radialSize} at ${radialPosition}` : `${radialType} ${radialSize}`;
    return `${json.type || "radial-gradient"}(${opt}, ${colorString})`;
  }
  toCSSString() {
    if (this.colorsteps.length === 0)
      return "";
    var colorString = RadialGradient.toCSSColorString(this.colorsteps);
    var json = this.json;
    var opt = "";
    var radialType = json.radialType || RadialGradientType.ELLIPSE;
    var radialSize = json.radialSize || RadialGradientSizeType.FARTHEST_CORNER;
    var radialPosition = json.radialPosition || ["center", "center"];
    radialPosition = DEFINED_POSITIONS[radialPosition] ? radialPosition : radialPosition.join(" ");
    radialSize = isArray(radialSize) ? radialSize.join(" ") : radialSize;
    opt = radialPosition ? `${radialType} ${radialSize} at ${radialPosition}` : `${radialType} ${radialSize}`;
    return `${json.type || "radial-gradient"}(${opt}, ${colorString})`;
  }
  static parse(str) {
    const result = parseOneValue(str);
    var opt = {
      radialType: RadialGradientType.ELLIPSE,
      radialSize: RadialGradientSizeType.FARTHEST_CORNER,
      radialPosition: ["center", "center"]
    };
    let [options2, ...colors2] = result.parameters;
    if (options2[0].func !== FuncType.COLOR) {
      let radialType = RadialGradientType.ELLIPSE;
      let hasAt = false;
      let positions = [];
      let sizeOption = [];
      options2.forEach((it) => {
        if (it.func === FuncType.KEYWORD && it.matchedString === "at") {
          hasAt = true;
        } else if (hasAt) {
          positions.push(it);
        } else {
          switch (it.matchedString) {
            case RadialGradientType.CIRCLE:
            case RadialGradientType.ELLIPSE:
              radialType = it.matchedString;
              break;
            default:
              sizeOption.push(it);
              break;
          }
        }
      });
      opt.radialType = radialType;
      opt.radialPosition = positions.map((it) => {
        if (it.func === FuncType.KEYWORD) {
          switch (it.matchedString) {
            case "top":
              return Length.percent(0);
            case "left":
              return Length.percent(0);
            case "right":
              return Length.percent(100);
            case "bottom":
              return Length.percent(100);
            case "center":
              return Length.percent(50);
          }
        }
        return it.parsed;
      });
      opt.radialSize = sizeOption.map((it) => {
        if (it.func === FuncType.KEYWORD)
          return it.matchedString;
        return it.parsed;
      });
      if (opt.radialSize.length === 1) {
        opt.radialSize = opt.radialSize[0];
      }
    } else {
      colors2 = result.parameters;
    }
    const colorsteps = RadialGradient.parseColorSteps(colors2);
    return new RadialGradient(__spreadProps(__spreadValues({}, opt), { colorsteps }));
  }
}
class RepeatingConicGradient extends ConicGradient {
  getDefaultObject() {
    return super.getDefaultObject({
      type: "repeating-conic-gradient",
      angle: 0,
      radialPosition: [Position.CENTER, Position.CENTER]
    });
  }
  static parse(str) {
    var conic2 = ConicGradient.parse(str);
    return new RepeatingConicGradient({
      angle: conic2.angle,
      radialPosition: conic2.radialPosition,
      colorsteps: conic2.colorsteps
    });
  }
}
class RepeatingLinearGradient extends LinearGradient {
  getDefaultObject() {
    return super.getDefaultObject({
      type: "repeating-linear-gradient",
      angle: 0
    });
  }
  static parse(str) {
    var linear2 = LinearGradient.parse(str);
    return new RepeatingLinearGradient({
      angle: linear2.angle,
      colorsteps: linear2.colorsteps
    });
  }
}
class RepeatingRadialGradient extends RadialGradient {
  getDefaultObject() {
    return super.getDefaultObject({
      type: "repeating-radial-gradient"
    });
  }
  static parse(str) {
    var radial2 = RadialGradient.parse(str);
    return new RepeatingRadialGradient({
      radialType: radial2.radialType,
      radialSize: radial2.radialSize,
      radialPosition: radial2.radialPosition,
      colorsteps: radial2.colorsteps
    });
  }
}
class StaticGradient extends Gradient {
  getDefaultObject() {
    return super.getDefaultObject({
      type: "static-gradient",
      static: true,
      colorsteps: [
        new ColorStep({ color: "red", percent: 0, index: 0 }),
        new ColorStep({ color: "red", percent: 100, index: 0 })
      ]
    });
  }
  toCloneObject() {
    return __spreadProps(__spreadValues({}, super.toCloneObject()), {
      static: true
    });
  }
  static parse(str) {
    const result = parseOneValue(str);
    var colorsteps = Gradient.parseColorSteps(result.parameters);
    return new StaticGradient({ colorsteps });
  }
  static create(color2 = "transparent") {
    return new StaticGradient({
      colorsteps: [
        new ColorStep({ color: color2, percent: 0, index: 0 }),
        new ColorStep({ color: color2, percent: 100, index: 1 })
      ]
    });
  }
  toString() {
    var color2 = this.json.colorsteps[0].color;
    return `static-gradient(${color2})`;
  }
  toCSSString() {
    if (this.colorsteps.length === 0)
      return "";
    const color2 = this.colorsteps[0].color || "black";
    return `linear-gradient(${color2} 0%, ${color2} 100%)`;
  }
}
const IMAGE_LIST$1 = ["jpg", "jpeg", "png", "gif", "svg"];
class URLImageResource extends ImageResource {
  getDefaultObject(obj2 = {}) {
    return super.getDefaultObject(__spreadValues({
      type: GradientType.URL,
      url: "",
      datauri: ""
    }, obj2));
  }
  toCloneObject() {
    return __spreadValues(__spreadValues({}, super.toCloneObject()), this.attrs("url", "datauri"));
  }
  static parse(str) {
    var url = str.split("(")[1].split(")")[0];
    return new URLImageResource({ url });
  }
  isUrl() {
    return true;
  }
  toString(url) {
    return `url(${url || this.json.url})`;
  }
  static isImageFile(fileExt) {
    return IMAGE_LIST$1.includes(fileExt);
  }
}
const RepeatList = [
  "repeat",
  "no-repeat",
  "repeat-x",
  "repeat-y",
  "round",
  "space"
];
class BackgroundImage extends PropertyItem {
  addImageResource(imageResource) {
    this.clear("image-resource");
    return this.addItem("image-resource", imageResource);
  }
  addGradient(gradient2) {
    return this.addImageResource(gradient2);
  }
  setImageUrl(data) {
    if (!data.images)
      return;
    if (!data.images.length)
      return;
    this.reset({
      type: "image",
      image: BackgroundImage.createImage(data.images[0])
    });
  }
  static createImage(url) {
    return new URLImageResource({ url });
  }
  setGradient(data) {
    this.reset({
      type: data.type,
      image: BackgroundImage.createGradient(data, this.json.image)
    });
  }
  static createGradient(data, gradient2) {
    const colorsteps = data.colorsteps || gradient2.colorsteps;
    const angle = data.angle || gradient2.angle;
    const radialType = data.radialType || gradient2.radialType;
    const radialPosition = data.radialPosition || gradient2.radialPosition;
    let json = gradient2.toJSON();
    delete json.itemType;
    delete json.type;
    switch (data.type) {
      case "static-gradient":
        return new StaticGradient(__spreadProps(__spreadValues({}, json), { colorsteps }));
      case "linear-gradient":
        return new LinearGradient(__spreadProps(__spreadValues({}, json), { colorsteps, angle }));
      case "repeating-linear-gradient":
        return new RepeatingLinearGradient(__spreadProps(__spreadValues({}, json), { colorsteps, angle }));
      case "radial-gradient":
        return new RadialGradient(__spreadProps(__spreadValues({}, json), {
          colorsteps,
          radialType,
          radialPosition
        }));
      case "repeating-radial-gradient":
        return new RepeatingRadialGradient(__spreadProps(__spreadValues({}, json), {
          colorsteps,
          radialType,
          radialPosition
        }));
      case "conic-gradient":
        return new ConicGradient(__spreadProps(__spreadValues({}, json), {
          colorsteps,
          angle,
          radialPosition
        }));
      case "repeating-conic-gradient":
        return new RepeatingConicGradient(__spreadProps(__spreadValues({}, json), {
          colorsteps,
          angle,
          radialPosition
        }));
    }
    return new Gradient();
  }
  getDefaultObject() {
    return super.getDefaultObject({
      itemType: "background-image",
      checked: false,
      blendMode: "normal",
      size: "auto",
      repeat: "repeat",
      width: Length.percent(100),
      height: Length.percent(100),
      x: Length.percent(0),
      y: Length.percent(0)
    });
  }
  toCloneObject() {
    var json = this.json;
    return __spreadProps(__spreadValues(__spreadValues({}, super.toCloneObject()), this.attrs("checked", "blendMode", "size", "repeat", "width", "height", "x", "y")), {
      image: json.image.toString()
    });
  }
  convert(json) {
    json.x = Length.parse(json.x);
    json.y = Length.parse(json.y);
    if (json.width)
      json.width = Length.parse(json.width);
    if (json.height)
      json.height = Length.parse(json.height);
    if (isString(json.image)) {
      json.image = BackgroundImage.parseImage(json.image);
    }
    return json;
  }
  get image() {
    return this.json.image;
  }
  set image(image2) {
    this.json.image = image2;
  }
  checkField(key, value) {
    if (key === "repeat") {
      return RepeatList.includes(value);
    }
    return super.checkField(key, value);
  }
  recoverOffset(newX, newY, contentBox, dx = 0, dy = 0, options2 = {}) {
    const { x, y, width: width2, height: height2 } = this.json;
    const newWidth = Math.floor(width2.toPx(contentBox.width).value + dx);
    const newHeight = options2.shiftKey ? newWidth : Math.floor(height2.toPx(contentBox.height).value + dy);
    newX -= contentBox.x;
    newY -= contentBox.y;
    if (newWidth < 0) {
      newX += newWidth;
    }
    if (newHeight < 0) {
      newY += newHeight;
    }
    let nextX = Length.px(newX);
    let nextY = Length.px(newY);
    const dist2 = 2;
    if (x.isPercent()) {
      if (Math.abs(newX) < dist2) {
        nextX = Length.percent(0);
      } else if (Math.abs(contentBox.width - newWidth - newX) < dist2) {
        nextX = Length.percent(100);
      } else if (Math.abs((contentBox.width - newWidth) / 2 - newX) < dist2) {
        nextX = Length.percent(50);
      } else {
        nextX = Length.makePercent(newX, contentBox.width - newWidth);
      }
    }
    if (y.isPercent()) {
      if (Math.abs(newY) < dist2) {
        nextY = Length.percent(0);
      } else if (Math.abs(contentBox.height - newHeight - newY) < dist2) {
        nextY = Length.percent(100);
      } else if (Math.abs((contentBox.height - newHeight) / 2 - newY) < dist2) {
        nextY = Length.percent(50);
      } else {
        nextY = Length.makePercent(newY, contentBox.height - newHeight);
      }
    }
    return {
      x: nextX,
      y: nextY,
      width: Length.px(Math.abs(newWidth)).to(width2.unit, contentBox.width),
      height: Length.px(Math.abs(newHeight)).to(height2.unit, contentBox.height)
    };
  }
  getOffset(contentBox) {
    const { x, y, width: width2, height: height2 } = this.json;
    const newWidth = width2.toPx(contentBox.width);
    const newHeight = height2.toPx(contentBox.height);
    const newX = x.toPx(contentBox.width);
    const newY = y.toPx(contentBox.height);
    return {
      x: contentBox.x + (x.isPercent() ? (contentBox.width - newWidth) * (x.value / 100) : newX),
      y: contentBox.y + (y.isPercent() ? (contentBox.height - newHeight) * (y.value / 100) : newY),
      width: newWidth.value,
      height: newHeight.value
    };
  }
  toBackgroundImageCSS() {
    if (!this.json.image)
      return {};
    return {
      "background-image": this.json.image.toCSSString()
    };
  }
  toBackgroundImageProperty() {
    if (!this.json.image)
      return {};
    return {
      "background-image": this.json.image.toString()
    };
  }
  toBackgroundPositionCSS() {
    var json = this.json;
    return {
      "background-position": `${json.x} ${json.y}`
    };
  }
  toBackgroundSizeCSS() {
    var json = this.json;
    var backgroundSize = "auto";
    if (json.size == "contain" || json.size == "cover") {
      backgroundSize = json.size;
    } else if (json.width.isPercent() && json.width.isPercent()) {
      if (+json.width !== 100 || +json.height !== 100) {
        backgroundSize = `${json.width} ${json.height}`;
      }
    } else {
      backgroundSize = `${json.width} ${json.height}`;
    }
    return {
      "background-size": backgroundSize
    };
  }
  toBackgroundRepeatCSS() {
    var json = this.json;
    return {
      "background-repeat": json.repeat
    };
  }
  toBackgroundBlendCSS() {
    var json = this.json;
    return {
      "background-blend-mode": json.blendMode
    };
  }
  toBackgroundVisibilityCSS() {
    var json = this.json;
    return {
      "background-visibility": json.visibility === VisibilityType.HIDDEN ? VisibilityType.HIDDEN : VisibilityType.VISIBLE
    };
  }
  toCSS() {
    const results = __spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues({}, this.toBackgroundImageCSS()), this.toBackgroundPositionCSS()), this.toBackgroundSizeCSS()), this.toBackgroundRepeatCSS()), this.toBackgroundBlendCSS()), this.toBackgroundVisibilityCSS());
    return results;
  }
  toProperty() {
    const results = __spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues({}, this.toBackgroundImageProperty()), this.toBackgroundPositionCSS()), this.toBackgroundSizeCSS()), this.toBackgroundRepeatCSS()), this.toBackgroundBlendCSS()), this.toBackgroundVisibilityCSS());
    return results;
  }
  toString() {
    return keyMap(this.toCSS(), (key, value) => {
      return `${key}: ${value}`;
    }).join(";");
  }
  toBackgroundCSS() {
    var obj2 = this.toCSS();
    return {
      background: `${obj2["background-image"]} `
    };
  }
  static parse(obj2) {
    return new BackgroundImage(obj2);
  }
  static parseImage(str) {
    const result = parseOneValue(str);
    let image2 = null;
    if (!result || str === "undefined") {
      return StaticGradient.create(str || "transparent");
    }
    switch (result.func) {
      case GradientType.LINEAR:
        image2 = LinearGradient.parse(result.matchedString);
        break;
      case GradientType.REPEATING_LINEAR:
        image2 = RepeatingLinearGradient.parse(result.matchedString);
        break;
      case GradientType.RADIAL:
        image2 = RadialGradient.parse(result.matchedString);
        break;
      case GradientType.REPEATING_RADIAL:
        image2 = RepeatingRadialGradient.parse(result.matchedString);
        break;
      case GradientType.CONIC:
        image2 = ConicGradient.parse(result.matchedString);
        break;
      case GradientType.REPEATING_CONIC:
        image2 = RepeatingConicGradient.parse(result.matchedString);
        break;
      case GradientType.URL:
        image2 = URLImageResource.parse(result.matchedString);
        break;
      default:
        image2 = StaticGradient.parse(result.matchedString);
        break;
    }
    return image2;
  }
  static changeImageType(options2) {
    switch (options2.type) {
      case GradientType.STATIC:
        return new StaticGradient(options2);
      case GradientType.LINEAR:
        return new LinearGradient(options2);
      case GradientType.REPEATING_LINEAR:
        return new RepeatingLinearGradient(options2);
      case GradientType.RADIAL:
        return new RadialGradient(options2);
      case GradientType.REPEATING_RADIAL:
        return new RepeatingRadialGradient(options2);
      case GradientType.CONIC:
        return new ConicGradient(options2);
      case GradientType.REPEATING_CONIC:
        return new RepeatingConicGradient(options2);
      case GradientType.URL:
        return new URLImageResource(options2);
    }
  }
  static parseStyle(style) {
    var backgroundImages = [];
    if (style["background-image"]) {
      const result = parseGroupValue(style["background-image"], "background-image");
      result.forEach((parsedValue, index2) => {
        const item = parsedValue[0];
        let image2;
        switch (item.func) {
          case GradientType.STATIC:
            image2 = StaticGradient.parse(item.matchedString);
            break;
          case GradientType.LINEAR:
            image2 = LinearGradient.parse(item.matchedString);
            break;
          case GradientType.REPEATING_LINEAR:
            image2 = RepeatingLinearGradient.parse(item.matchedString);
            break;
          case GradientType.RADIAL:
            image2 = RadialGradient.parse(item.matchedString);
            break;
          case GradientType.REPEATING_RADIAL:
            image2 = RepeatingRadialGradient.parse(item.matchedString);
            break;
          case GradientType.CONIC:
            image2 = ConicGradient.parse(item.matchedString);
            break;
          case GradientType.REPEATING_CONIC:
            image2 = RepeatingConicGradient.parse(item.matchedString);
            break;
          case GradientType.URL:
            image2 = URLImageResource.parse(item.matchedString);
            break;
        }
        backgroundImages[index2] = new BackgroundImage({
          type: image2.type,
          image: image2
        });
      });
    }
    if (style["background-repeat"]) {
      style["background-repeat"].split(",").map((it) => it.trim()).forEach((it, index2) => {
        if (backgroundImages[index2]) {
          backgroundImages[index2].repeat = it;
        }
      });
    }
    if (style["background-blend-mode"]) {
      style["background-blend-mode"].split(",").map((it) => it.trim()).forEach((it, index2) => {
        if (backgroundImages[index2]) {
          backgroundImages[index2].blendMode = it;
        }
      });
    }
    if (style["background-size"]) {
      style["background-size"].split(",").map((it) => it.trim()).forEach((it, index2) => {
        if (backgroundImages[index2]) {
          if (it == "cover" || it === "contain" || it === "auto") {
            backgroundImages[index2].size = it;
          } else {
            backgroundImages[index2].size = "auto";
            let [width2, height2] = it.split(" ");
            backgroundImages[index2].width = Length.parse(width2);
            backgroundImages[index2].height = Length.parse(height2);
          }
        }
      });
    }
    if (style["background-position"]) {
      style["background-position"].split(",").map((it) => it.trim()).forEach((it, index2) => {
        if (backgroundImages[index2]) {
          let [x, y] = it.split(" ");
          backgroundImages[index2].x = Length.parse(x);
          backgroundImages[index2].y = Length.parse(y);
        }
      });
    }
    if (style["background-visibility"]) {
      style["background-visibility"].split(",").map((it) => it.trim()).forEach((it, index2) => {
        if (backgroundImages[index2]) {
          backgroundImages[index2].visibility = it === VisibilityType.HIDDEN ? VisibilityType.HIDDEN : VisibilityType.VISIBLE;
        }
      });
    }
    return backgroundImages;
  }
  static toCSS(list2) {
    var results = {};
    list2.forEach((item) => {
      keyEach(item.toCSS(), (key, value) => {
        if (!results[key])
          results[key] = [];
        results[key].push(value);
      });
    });
    return combineKeyArray(results);
  }
  static toProperty(list2) {
    var results = {};
    list2.forEach((item) => {
      keyEach(item.toProperty(), (key, value) => {
        if (!results[key])
          results[key] = [];
        results[key].push(value);
      });
    });
    return combineKeyArray(results);
  }
  static join(list2) {
    return CSS_TO_STRING(BackgroundImage.toProperty(list2.map((it) => BackgroundImage.parse(it))));
  }
  static joinCSS(list2) {
    return BackgroundImage.toCSS(list2.map((it) => BackgroundImage.parse(it)));
  }
  static parseList(list2 = []) {
    return list2.map((it) => BackgroundImage.parse(it));
  }
}
class GradientEditor extends EditorElement {
  initState() {
    var _a;
    const image2 = BackgroundImage.parseImage(this.props.value || "static-gradient(#ececec)");
    const id = (_a = image2.colorsteps[this.props.index]) == null ? void 0 : _a.id;
    this.$context.selection.selectColorStep(id);
    if (id) {
      this.currentStep = image2.colorsteps.find((it) => this.$context.selection.isSelectedColorStep(it.id));
    }
    return {
      id,
      index: +(this.props.index || 0),
      value: this.props.value,
      image: image2
    };
  }
  setValue(value) {
    this.setState({
      image: BackgroundImage.parseImage(value)
    }, false);
    this.refresh();
  }
  template() {
    return `
        <div class='elf--gradient-editor'>
            <div class='gradient-steps' data-editor='gradient'>
                <div class="hue-container" ref="$back"></div>            
                <div class="hue" ref="$steps">
                    <div class='step-list' ref="$stepList" ></div>
                </div>
            </div>
        </div>
      `;
  }
  [CHANGE("$file")](e) {
    var project2 = this.$context.selection.currentProject;
    if (project2) {
      [...e.target.files].forEach((item) => {
        this.$commands.emit("updateImageAssetItem", item, (local) => {
          this.trigger("setImageUrl", local);
        });
      });
    }
  }
  [SUBSCRIBE_SELF("changeTabType")](type) {
    var _a, _b;
    const oldType = (_a = this.state.image) == null ? void 0 : _a.type;
    const colorsteps = ((_b = this.state.image) == null ? void 0 : _b.colorsteps) || [];
    if (oldType === GradientType.STATIC) {
      if (colorsteps.length === 0) {
        colorsteps.push(colorsteps[0], colorsteps[0]);
      } else if (colorsteps.length === 1) {
        colorsteps.push(colorsteps[0], colorsteps[0]);
      }
    }
    var url = type === "image-resource" ? this.state.image.url : this.state.url;
    this.state.image = BackgroundImage.changeImageType({
      type,
      url,
      colorsteps,
      angle: this.state.image.angle || 0,
      radialType: this.state.image.radialType || RadialGradientType.CIRCLE,
      radialPosition: this.state.image.radialPosition || ["50%", "50%"]
    });
    this.refresh();
    this.updateData();
  }
  [SUBSCRIBE_SELF("changeColorStepOffset")](key, value) {
    if (this.currentStep) {
      this.currentStep.percent = value.value;
      this.state.image.sortColorStep();
      this.refresh();
      this.updateData();
    }
  }
  [CLICK("$back")](e) {
    var rect2 = this.refs.$stepList.rect();
    var minX = rect2.x;
    var maxX = rect2.right;
    var x = e.xy.x;
    if (x < minX)
      x = minX;
    else if (x > maxX)
      x = maxX;
    var percent = (x - minX) / rect2.width * 100;
    this.state.image.insertColorStep(percent);
    this.state.image.sortColorStep();
    this.refresh();
    this.updateData();
  }
  [BIND("$el")]() {
    var type = this.state.image.type;
    if (type === "url") {
      type = "image-resource";
    }
    return {
      "data-selected-editor": type
    };
  }
  [BIND("$stepList")]() {
    return {
      style: {
        "background-image": this.getLinearGradient()
      }
    };
  }
  [LOAD("$stepList") + DOMDIFF]() {
    var _a;
    var colorsteps = ((_a = this.state.image) == null ? void 0 : _a.colorsteps) || [];
    return colorsteps.map((it) => {
      var selected = this.$context.selection.isSelectedColorStep(it.id) ? "selected" : "";
      return `
      <div class='step ${selected}' data-id='${it.id}' data-cut='${it.cut}' tabindex="-1" style='left: ${it.toLength()};'>
        <div class='color-view' style="background-color: ${it.color}">
          <span>${Math.floor(it.percent * 10) / 10}</span>
        </div>      
        <div class='arrow'></div>      
      </div>`;
    });
  }
  removeStep(id) {
    this.state.image.removeColorStep(id);
    this.refresh();
    this.updateData();
  }
  selectStep(id) {
    this.state.id = id;
    this.$context.selection.selectColorStep(id);
    if (this.state.image.colorsteps) {
      this.currentStep = this.state.image.colorsteps.find((it) => this.$context.selection.isSelectedColorStep(it.id));
      this.parent.trigger("selectColorStep", this.currentStep.color);
    }
    this.refresh();
  }
  [KEYUP("$el .step")](e) {
    const id = e.$dt.data("id");
    switch (e.code) {
      case "Delete":
      case "Backspace":
        this.removeStep(id);
        break;
      case "BracketRight":
        this.sortToRight(id);
        break;
      case "BracketLeft":
        this.sortToLeft(id);
        break;
      case "Equal":
        this.appendColorStep(id);
        break;
      case "Minus":
        this.prependColorStep(id);
        break;
    }
  }
  sortToRight(id) {
    this.state.image.sortToRight();
    this.refresh();
    this.updateData();
    this.doFocus(id);
  }
  sortToLeft(id) {
    this.state.image.sortToLeft();
    this.refresh();
    this.updateData();
    this.doFocus(id);
  }
  appendColorStep(id) {
    const currentIndex = this.state.image.colorsteps.findIndex((it) => it.id === id);
    const nextIndex = currentIndex + 1;
    const currentColorStep = this.state.image.colorsteps[currentIndex];
    const nextColorStep = this.state.image.colorsteps[nextIndex];
    if (!nextColorStep) {
      if (currentColorStep.percent !== 100) {
        this.state.image.insertColorStep(currentColorStep.percent + (100 - currentColorStep.percent) / 2);
      }
    } else {
      this.state.image.insertColorStep(currentColorStep.percent + (nextColorStep.percent - currentColorStep.percent) / 2);
    }
    this.refresh();
    this.updateData();
    this.doFocus(id);
  }
  doFocus(id) {
    this.nextTick(() => {
      this.refs.$stepList.$(".step[data-id='" + id + "']").focus();
    }, 100);
  }
  prependColorStep(id) {
    const currentIndex = this.state.image.colorsteps.findIndex((it) => it.id === id);
    const prevIndex = currentIndex - 1;
    const currentColorStep = this.state.image.colorsteps[currentIndex];
    const prevColorStep = this.state.image.colorsteps[prevIndex];
    if (!prevColorStep) {
      if (currentColorStep.percent !== 0) {
        this.state.image.insertColorStep(currentColorStep.percent);
      }
    } else {
      this.state.image.insertColorStep(prevColorStep.percent + (currentColorStep.percent - prevColorStep.percent) / 2);
    }
    this.refresh();
    this.updateData();
    this.doFocus(id);
  }
  [POINTERSTART("$stepList .step") + MOVE() + END()](e) {
    var id = e.$dt.attr("data-id");
    if (e.altKey) {
      this.removeStep(id);
      return false;
    } else {
      e.$dt.focus();
      this.isSelectedColorStep = this.$context.selection.isSelectedColorStep(id);
      this.selectStep(id);
      this.startXY = e.xy;
      this.cachedStepListRect = this.refs.$stepList.rect();
    }
  }
  getStepListRect() {
    return this.cachedStepListRect;
  }
  move(dx) {
    var rect2 = this.getStepListRect();
    var minX = rect2.x;
    var maxX = rect2.right;
    var x = this.startXY.x + dx;
    if (x < minX)
      x = minX;
    else if (x > maxX)
      x = maxX;
    var percent = (x - minX) / rect2.width * 100;
    if (this.$config.get("bodyEvent").shiftKey) {
      percent = Math.floor(percent);
    }
    this.currentStep.setValue(percent, rect2.width);
    this.state.image.sortColorStep();
    this.refresh();
    this.updateData();
  }
  end(dx, dy) {
    if (dx === 0 && dy === 0) {
      if (this.isSelectedColorStep) {
        if (this.currentStep) {
          this.currentStep.cut = !this.currentStep.cut;
          this.refresh();
          this.updateData();
        }
      }
    }
    this.doFocus(this.state.id);
  }
  getLinearGradient() {
    var { image: image2 } = this.state;
    return `linear-gradient(to right, ${Gradient.toCSSColorString(image2.colorsteps)})`;
  }
  [SUBSCRIBE_SELF("setColorStepColor")](color2) {
    if (this.state.image.type === "static-gradient") {
      this.state.image.colorsteps[0].color = color2;
      this.refresh();
      this.updateData();
    } else {
      if (this.currentStep) {
        this.currentStep.color = color2;
        this.refresh();
        this.updateData();
      }
    }
  }
  [SUBSCRIBE("setImageUrl")](url) {
    if (this.state.image) {
      this.state.url = url;
      this.state.image.reset({ url });
      this.refresh();
      this.updateData();
    }
  }
  updateData(data = {}) {
    this.setState(data, false);
    this.parent.trigger(this.props.onchange, this.state.image.toString());
  }
}
var IconListViewEditor$1 = "";
class IconListViewEditor extends EditorElement {
  initState() {
    return {
      value: this.props.value
    };
  }
  template() {
    return `<div class='select-editor elf--list-view-editor' ref='$body'></div>`;
  }
  [BIND("$body")]() {
    return {
      "data-column": this.props.column || 1
    };
  }
  [LOAD("$body")]() {
    return Object.keys(obj$3).map((key) => {
      var html = obj$3[key];
      var selected = key === this.state.value ? "selected" : "";
      return `<div class='list-view-item ${selected}'  data-key='${key}'>${html}</div>`;
    });
  }
  getValue() {
    return this.state.value;
  }
  setValue(value) {
    this.state.value = value;
    this.refresh();
  }
  [CLICK("$body .list-view-item")](e) {
    var key = e.$dt.attr("data-key");
    e.$dt.onlyOneClass("selected");
    this.updateData({
      value: key
    });
  }
  updateData(data) {
    this.setState(data, false);
    this.parent.trigger(this.props.onchange, this.props.key, this.state.value, this.props.params);
  }
}
class InputArrayEditor extends EditorElement {
  initState() {
    var values = this.props.values.split(" ").map((it) => +it);
    return {
      values,
      column: this.props.column
    };
  }
  template() {
    return `<div class='small-editor input-array-editor' ref='$body' ></div>`;
  }
  [BIND("$body")]() {
    return {
      cssText: `
                display: grid;
                grid-template-columns: repeat(${this.state.column}, 1fr);
                grid-column-gap: 2px;
                grid-row-gap: 2px;
            `
    };
  }
  [LOAD("$body")]() {
    var { values } = this.state;
    return values.map((value, index2) => {
      return `
                <div class='number-editor'>
                    <input type="number" value="${value}" step="0.01" data-index="${index2}" />
                </div>
            `;
    });
  }
  updateData(data) {
    this.setState(data, false);
    this.parent.trigger(this.props.onchange, this.props.key, this.state.values, this.props.params);
  }
  [INPUT("$body input")](e) {
    var $el = e.$dt;
    var index2 = +$el.attr("data-index");
    var value = +$el.value;
    this.state.values[index2] = value;
    this.updateData();
  }
}
var InputRangeEditor$1 = "";
class InputRangeEditor extends EditorElement {
  initState() {
    var units = this.props.units || ["px", "em", "%", "auto"];
    var value = Length.parse(this.props.value || "0px");
    let label = this.props.label || "";
    if (obj$3[label]) {
      label = obj$3[label];
    }
    return {
      removable: this.props.removable,
      label,
      compact: this.props.compact,
      wide: this.props.wide,
      min: +this.props.min || 0,
      max: +this.props.max || 100,
      step: +this.props.step || 1,
      key: this.props.key,
      params: this.props.params || "",
      layout: this.props.layout || "",
      disabled: this.props.disabled,
      title: this.props.title || "",
      units,
      value
    };
  }
  template() {
    return `<div class='small-editor' ref='$body'></div>`;
  }
  [LOAD("$body") + DOMDIFF]() {
    var {
      min,
      max,
      step: step2,
      label,
      title: title2,
      compact,
      wide,
      removable,
      layout: layout2,
      disabled
    } = this.state;
    var value = +this.state.value.value.toString();
    if (isNaN(value)) {
      value = 0;
    }
    var layoutClass = layout2;
    var realValue = (+value).toString();
    const units = this.state.units;
    return `
        <div 
            ref="$range",
            class="${classnames({
      "elf--input-range-editor": true,
      "has-label": !!label,
      compact: !!compact,
      wide: !!wide,
      "is-removable": removable,
      disabled,
      [layoutClass]: true
    })}"
        >
            ${label ? `<label title="${title2}">${label}</label>` : ""}
            <div class='range--editor-type' data-type='range'>
                <div class='area'>
                    <input type='number' class='property-number' ref='$propertyNumber' value="${realValue}" min="${min}" max="${max}" step="${step2}" tabIndex="1" />
                    
                    ${units.length === 1 ? `<span class='unit'>${units[0]}</span>` : createComponent("SelectEditor", {
      ref: "$unit",
      key: "unit",
      compact: true,
      value: this.state.selectedUnit || this.state.value.unit,
      options: this.state.units,
      onchange: "changeUnit"
    })}
                    
                    
                </div>
            </div>
            <button type='button' class='remove' ref='$remove' title='Remove'>${obj$3.remove}</button>
        </div>
    `;
  }
  getValue() {
    return this.state.value.clone();
  }
  setValue(value) {
    var _a;
    this.setState({
      value: Length.parse(value)
    }, false);
    this.refs.$propertyNumber.val(this.state.value.value);
    (_a = this.children.$unit) == null ? void 0 : _a.setValue(this.state.value.unit);
  }
  disabled() {
    this.setState({
      disabled: true
    });
  }
  enabled() {
    this.setState({
      disabled: false
    });
  }
  [CLICK("$remove")]() {
    this.updateData({
      value: ""
    });
  }
  getUnit() {
    var _a;
    return ((_a = this.children.$unit) == null ? void 0 : _a.getValue()) || this.state.value.unit;
  }
  updateData(data) {
    this.setState(data, false);
    this.parent.trigger(this.props.onchange, this.props.key, this.state.value, this.props.params);
  }
  initValue() {
    if (this.state.value == "") {
      this.state.value = new Length(0, this.getUnit());
    }
  }
  [INPUT("$body .property-number")](e) {
    var value = +e.$dt.value;
    this.initValue();
    this.updateData({
      value: new Length(value, this.getUnit())
    });
  }
  [SUBSCRIBE_SELF("changeUnit")](key, value) {
    this.initValue();
    this.updateData({
      value: this.state.value.toUnit(value)
    });
  }
  [FOCUSIN("$body input[type=number]")](e) {
    this.refs.$range.addClass("focused");
    e.$dt.select();
  }
  [FOCUSOUT("$body input[type=number]")]() {
    this.refs.$range.removeClass("focused");
  }
  [POINTERSTART("$body .elf--input-range-editor label") + MOVE("moveDrag") + END("moveDragEnd")]() {
    this.refs.$range.addClass("drag");
    this.initNumberValue = +this.refs.$propertyNumber.value;
    this.initUnit = this.state.value.unit;
    this.initUnits = this.state.units;
    this.refs.$propertyNumber.focus();
    this.refs.$propertyNumber.select();
  }
  moveDrag(dx) {
    let newValue = Math.floor(round(this.initNumberValue + dx * this.state.step, 100));
    newValue = Math.min(this.state.max, Math.max(this.state.min, newValue));
    this.updateData({
      value: new Length(newValue, this.getUnit())
    });
    this.refs.$propertyNumber.val(this.state.value.value);
  }
  moveDragEnd() {
    this.refs.$range.removeClass("drag");
  }
}
var RangeEditor$1 = "";
class RangeEditor extends EditorElement {
  initState() {
    var units = this.props.units || ["px", "em", "%"];
    var value = Length.parse(this.props.value || 0);
    return {
      removable: this.props.removable === "true",
      calc: this.props.calc === "true" ? true : false,
      compact: this.props.compact === "true" ? true : false,
      label: this.props.label || "",
      min: +this.props.min || 0,
      max: +this.props.max || 100,
      step: +this.props.step || 1,
      key: this.props.key,
      params: this.props.params || "",
      layout: this.props.layout || "",
      units,
      value
    };
  }
  template() {
    return `<div class='small-editor' ref='$body'></div>`;
  }
  [LOAD("$body")]() {
    var { min, max, step: step2, label, removable, layout: layout2, compact } = this.state;
    var value = +this.state.value.value.toString();
    if (isNaN(value)) {
      value = 0;
    }
    var layoutClass = layout2;
    var realValue = (+value).toString();
    if (this.state.units === "%") {
      throw new Error("%");
    }
    var units = this.state.units.map((it) => {
      let description = it;
      if (description === "number") {
        description = "";
      }
      return { value: it, text: description };
    });
    return `
        <div 
            ref="$range"
            class="${classnames({
      "elf--range--editor": true,
      "has-label": !!label,
      compact: !!compact,
      "is-removable": removable,
      [layoutClass]: true
    })}"
        >
            ${label ? `<label title="${label}">${label}</label>` : ""}
            <div class='range--editor-type' data-type='range'>
                <input type='range' ref='$property' value="${realValue}" min="${min}" max="${max}" step="${step2}" /> 
                <div class='area' ref='$rangeArea'>
                    <input type='number' ref='$propertyNumber' value="${realValue}" min="${min}" max="${max}" step="${step2}" tabIndex="1" />
                    ${createComponent("SelectEditor", {
      ref: "$unit",
      key: "unit",
      value: this.state.value.unit,
      options: units,
      onchange: "changeUnit"
    })}
                </div>
            </div>
            <button type='button' class='remove thin' ref='$remove' title='Remove'>${obj$3.remove}</button>
        </div>
    `;
  }
  getValue() {
    return this.state.value.clone();
  }
  setValue(value) {
    this.setState({
      value: Length.parse(value)
    });
  }
  [FOCUS('$body input[type="number"]')]() {
    this.refs.$rangeArea.addClass("focused");
  }
  [BLUR('$body input[type="number"]')]() {
    this.refs.$rangeArea.removeClass("focused");
  }
  updateData(data) {
    this.setState(data, false);
    this.parent.trigger(this.props.onchange, this.props.key, this.state.value, this.props.params);
  }
  initValue() {
    if (this.state.value == "") {
      this.state.value = new Length(0, this.children.$unit.getValue());
    }
  }
  [INPUT('$body input[type="number"]')]() {
    var value = +this.refs.$propertyNumber.value;
    this.getRef("$property").val(value);
    this.initValue();
    this.updateData({
      value: new Length(value, this.children.$unit.getValue())
    });
  }
  [INPUT('$body input[type="range"]')]() {
    this.trigger("changeRangeValue");
  }
  [POINTERSTART('$body input[type="range"]') + END()]() {
  }
  end() {
    this.trigger("changeRangeValue");
  }
  [SUBSCRIBE_SELF("changeRangeValue")]() {
    var value = +this.getRef("$property").value;
    this.refs.$propertyNumber.val(value);
    this.initValue();
    this.updateData({
      value: new Length(value, this.children.$unit.getValue())
    });
  }
  [SUBSCRIBE_SELF("changeUnit")](key, value) {
    this.initValue();
    this.updateData({
      value: this.state.value.toUnit(value)
    });
  }
}
class IterationCountEditor extends RangeEditor {
  initState() {
    var value = this.props.value;
    if (value === "infinite") {
      value = new Length(0, "infinite");
    } else {
      value = Length.number(value);
    }
    var units = this.props.units || ["px", "em", "%"];
    return __spreadValues(__spreadValues({}, super.initState()), {
      key: this.props.key,
      params: this.props.params || "",
      units,
      value
    });
  }
}
var MediaProgressEditor$1 = "";
class MediaProgressEditor extends EditorElement {
  initState() {
    const [start2, end2, duration] = (this.props.value || "").split(":");
    return {
      start: +(start2 || 0),
      end: +(end2 || 1),
      duration: +(duration || 1)
    };
  }
  refresh() {
    this.load();
    this.children.$s.setValue(this.state.start * this.state.duration);
    this.children.$e.setValue(this.state.end * this.state.duration);
    this.children.$s.setMax(this.state.duration);
    this.children.$e.setMax(this.state.duration);
  }
  template() {
    const { start: start2, end: end2, duration } = this.state;
    return `
            <div class='elf--media-progress-editor'>
                <div class='drag-area'>
                    <div class='progress-bar' ref='$progress'></div>
                    <div class='bar' ref='$bar'></div>                
                    <div class='drag-item start' ref='$start'></div>
                    <div class='drag-item end' ref='$end'></div>
                </div>
                <div class='item'>
                    ${createComponent("NumberRangeEditor", {
      ref: "$s",
      label: "Start",
      key: "start",
      min: 0,
      max: duration,
      step: 1e-3,
      value: start2 * duration,
      onchange: "changeValue"
    })}
                </div>
                <div class='item'>
                    ${createComponent("NumberRangeEditor", {
      ref: "$e",
      label: "End",
      key: "end",
      min: 0,
      max: duration,
      step: 1e-3,
      value: end2 * duration,
      onchange: "changeValue"
    })}
                </div>                
            </div>
        `;
  }
  [SUBSCRIBE_SELF("changeValue")](key, value) {
    this.updateData({
      [key]: value / this.state.duration
    }, true);
  }
  [POINTERSTART("$start") + MOVE("moveStart")]() {
    this.rect = this.refs.$progress.rect();
    this.pos = Length.parse(this.refs.$start.css("left")).toPx(this.rect.width);
    this.max = Length.parse(this.refs.$end.css("left")).toPx(this.rect.width);
  }
  moveStart(dx) {
    var realPos = Math.min(this.max.value, Math.max(0, this.pos.value + dx));
    this.state.start = realPos / this.rect.width;
    this.children.$s.setValue(this.state.start * this.state.duration);
    this.refresh();
    this.updateData();
  }
  [BIND("$start")]() {
    return {
      "data-info": this.state.start,
      style: {
        left: Length.percent((this.state.start || 0) * 100)
      }
    };
  }
  [POINTERSTART("$end") + MOVE("moveStartForEnd")]() {
    this.rect = this.refs.$progress.rect();
    this.pos = Length.parse(this.refs.$end.css("left")).toPx(this.rect.width);
    this.min = Length.parse(this.refs.$start.css("left")).toPx(this.rect.width);
    this.max = this.rect.width;
  }
  moveStartForEnd(dx) {
    var realPos = Math.max(this.min.value, Math.min(this.max.value, this.pos.value + dx));
    this.state.end = realPos / this.rect.width;
    this.children.$e.setValue(this.state.end * this.state.duration);
    this.refresh();
    this.updateData();
  }
  [BIND("$end")]() {
    return {
      "data-info": this.state.end,
      style: {
        left: Length.percent((this.state.end || 1) * 100)
      }
    };
  }
  [BIND("$bar")]() {
    const start2 = this.state.start || 0;
    const end2 = this.state.end || 1;
    return {
      style: {
        left: Length.percent(start2 * 100),
        width: Length.percent((end2 - start2) * 100)
      }
    };
  }
  getValue() {
    const { start: start2, end: end2, duration } = this.state;
    return `${start2}:${end2}:${duration}`;
  }
  setValue(value) {
    const [start2, end2, duration] = value.split(":");
    this.setState({
      start: Number(start2),
      end: Number(end2),
      duration: Number(duration)
    });
  }
  updateData(data = {}, isRefresh = false) {
    this.setState(data, isRefresh);
    this.parent.trigger(this.props.onchange, this.props.key, this.getValue(), this.props.params);
  }
}
var NumberInputEditor$1 = "";
class NumberInputEditor extends EditorElement {
  initState() {
    var value = +this.props.value;
    let label = this.props.label || "";
    if (obj$3[label]) {
      label = obj$3[label];
    }
    const compact = isBoolean(this.props.compact) ? this.props.compact : this.props.compact === "true";
    const wide = isBoolean(this.props.wide) ? this.props.wide : this.props.wide === "true";
    const mini = isBoolean(this.props.mini) ? this.props.mini : this.props.mini === "true";
    const trigger = this.props.trigger || "input";
    return {
      label,
      compact,
      wide,
      mini,
      trigger,
      min: +this.props.min || 0,
      max: +this.props.max || 100,
      step: +this.props.step || 1,
      key: this.props.key,
      params: this.props.params || "",
      layout: this.props.layout || "",
      value
    };
  }
  template() {
    return `<div class='small-editor' ref='$body'></div>`;
  }
  [LOAD("$body") + DOMDIFF]() {
    var {
      min,
      max,
      step: step2,
      label,
      type,
      layout: layout2,
      mini,
      compact,
      wide,
      disabled,
      removable
    } = this.state;
    var value = this.state.value;
    if (isNaN(value)) {
      value = 0;
    }
    var layoutClass = layout2;
    var realValue = (+value).toString();
    return `
        <div 
            class="${classnames({
      "elf--number-input-editor": true,
      "has-label": !!label,
      compact: !!compact,
      wide: !!wide,
      mini: !!mini,
      "is-removable": removable,
      disabled,
      [layoutClass]: true
    })}"
            ref="$range"
            data-selected-type='${type}'>
            ${label ? `<label>${label}</label>` : ""}
            <div class='range--editor-type' data-type='range'>
                <div class='area'>
                    <input type='number' ref='$propertyNumber' value="${realValue}" min="${min}" max="${max}" step="${step2}" />
                </div>
            </div>
        </div>
    `;
  }
  getValue() {
    return this.state.value || 0;
  }
  setValue(value) {
    this.setState({
      value
    }, false);
    this.refs.$propertyNumber.val(this.state.value);
  }
  updateData(data) {
    this.setState(data, false);
    this.parent.trigger(this.props.onchange, this.props.key, this.state.value, this.props.params);
  }
  [FOCUSIN("$body input[type=number]")](e) {
    this.refs.$range.addClass("focused");
    e.$dt.select();
  }
  [FOCUSOUT("$body input[type=number]")]() {
    this.refs.$range.removeClass("focused");
  }
  updateValue(e) {
    var value = +e.$dt.value;
    this.updateData({
      value
    });
  }
  isTriggerInput() {
    return this.state.trigger === "input";
  }
  isTriggerEnter() {
    return this.state.trigger === "enter";
  }
  [INPUT("$body input[type=number]") + IF("isTriggerInput") + DEBOUNCE(500)](e) {
    this.updateValue(e);
  }
  [KEYUP("$body input[type=number]") + IF("isTriggerEnter") + ENTER](e) {
    this.updateValue(e);
    e.$dt.select();
  }
  [POINTERSTART("$body label") + MOVE("moveDrag") + END("moveDragEnd")]() {
    this.refs.$range.addClass("drag");
    this.initValue = +this.refs.$propertyNumber.value;
  }
  moveDrag(dx) {
    let newValue = round(this.initValue + dx * this.state.step, 1 / this.state.step);
    newValue = Math.min(this.state.max, Math.max(this.state.min, newValue));
    this.updateData({
      value: newValue
    });
    this.refs.$propertyNumber.val(this.state.value);
  }
  moveDragEnd() {
    this.refs.$range.removeClass("drag");
  }
}
var NumberRangeEditor$1 = "";
class NumberRangeEditor extends EditorElement {
  initState() {
    var value = Length.parse(this.props.value || Length.number(0));
    value = value.toUnit("number");
    return {
      removable: this.props.removable === "true",
      compact: this.props.compact === "true",
      wide: this.props.wide === "true",
      clamp: this.props.clamp === "true",
      label: this.props.label || "",
      min: +this.props.min || 0,
      max: +this.props.max || 100,
      step: +this.props.step || 1,
      key: this.props.key,
      params: this.props.params || "",
      layout: this.props.layout || "",
      value
    };
  }
  template() {
    return `<div class='small-editor' ref='$body'></div>`;
  }
  [LOAD("$body")]() {
    var { min, max, step: step2, label, removable, layout: layout2, compact, wide, disabled } = this.state;
    var value = +this.state.value.value.toString();
    if (isNaN(value)) {
      value = 0;
    }
    var layoutClass = layout2;
    var realValue = (+value).toString();
    return `
        <div 
            class="${classnames({
      "elf--number-range-editor": true,
      "has-label": !!label,
      compact: !!compact,
      wide: !!wide,
      "is-removable": removable,
      disabled,
      [layoutClass]: true
    })}"
        >
            ${label ? `<label title="${label}">${label}</label>` : ""}
            <div class='range--editor-type' data-type='range'>
                <div class='area'>
                    <div>
                        <input type='range' ref='$property' value="${realValue}" min="${min}" max="${max}" step="${step2}" />
                    </div>
                    <div>
                        <input type='number' ref='$propertyNumber' value="${realValue}" min="${min}" max="${max}" step="${step2}" tabIndex="1" />
                    </div>
                </div>
            </div>
            <button type='button' class='remove' ref='$remove' title='Remove'>${obj$3.remove}</button>
        </div>
    `;
  }
  setMin(value) {
    this.setState({
      min: Length.parse(value)
    });
  }
  setMax(value) {
    this.setState({
      max: Length.parse(value)
    });
  }
  getValue() {
    if (this.state.clamp) {
      return this.state.value.clamp(this.state.min, this.state.max);
    }
    return this.state.value;
  }
  setValue(value) {
    console.log(value);
    this.setState({
      value: Length.parse(value)
    });
  }
  [FOCUS('$body input[type="number"]')]() {
    this.refs.$propertyNumber.addClass("focused");
  }
  [BLUR('$body input[type="number"]')]() {
    this.refs.$propertyNumber.removeClass("focused");
  }
  [CLICK("$remove")]() {
    this.updateData({
      value: ""
    });
  }
  updateData(data) {
    this.setState(data, false);
    this.parent.trigger(this.props.onchange, this.props.key, this.getValue(), this.props.params);
  }
  [INPUT('$body input[type="number"]')]() {
    var value = +this.refs.$propertyNumber.value;
    this.getRef("$property").val(value);
    this.updateData({
      value: this.state.value.set(value)
    });
  }
  [INPUT('$body input[type="range"]')]() {
    this.trigger("changeRangeValue");
  }
  [POINTERSTART('$body input[type="range"]') + END()]() {
  }
  end() {
    this.trigger("changeRangeValue");
  }
  [SUBSCRIBE_SELF("changeRangeValue")]() {
    var value = +this.getRef("$property").value;
    this.getRef("$propertyNumber").val(value);
    if (this.state.value === "") {
      this.state.value = Length.number(0);
    }
    this.updateData({
      value: this.state.value.set(value)
    });
  }
}
var PathEditor$1 = "";
class PathStringManager {
  constructor() {
    this.pathArray = [];
  }
  reset() {
    this.pathArray = [];
  }
  getPointString(values) {
    return values.map((v) => `${v.x} ${v.y}`).join(" ");
  }
  makeString(command, values = []) {
    this.pathArray.push(`${command} ${this.getPointString(values)}`);
    return this;
  }
  M(...values) {
    return this.makeString("M", values);
  }
  L(...values) {
    return this.makeString("L", values);
  }
  X(...values) {
    const dist2 = 3;
    const point2 = values[0];
    const topLeft = { x: point2.x - dist2, y: point2.y - dist2 };
    const topRight = { x: point2.x + dist2, y: point2.y - dist2 };
    const bottomLeft = { x: point2.x - dist2, y: point2.y + dist2 };
    const bottomRight = { x: point2.x + dist2, y: point2.y + dist2 };
    return this.M(topLeft).L(bottomRight).M(topRight).L(bottomLeft);
  }
  Q(...values) {
    return this.makeString("Q", values);
  }
  C(...values) {
    return this.makeString("C", values);
  }
  Z() {
    return this.makeString("Z");
  }
  get d() {
    return this.pathArray.join(" ").trim();
  }
  toString(className = "object") {
    return `<path d="${this.d}" class='${className}'/>`;
  }
}
class SegmentManager {
  constructor(viewport) {
    this.viewport = viewport;
    this.segmentList = [];
  }
  get hasViewport() {
    return Boolean(this.viewport);
  }
  reset() {
    this.segmentList = [];
    return this;
  }
  checkInViewport(point2) {
    if (!this.hasViewport)
      return true;
    const vertext = this.viewport.applyVertexInverse([point2.x, point2.y, 0]);
    return this.viewport.checkInViewport(vertext);
  }
  addLine(a, b) {
    if (this.hasViewport && getDist(a.x, a.y, b.x, b.y) < 1)
      return this;
    if (this.checkInViewport(a) || this.checkInViewport(b)) {
      this.segmentList.push({
        line: true,
        x1: a.x,
        y1: a.y,
        x2: b.x,
        y2: b.y
      });
    }
    return this;
  }
  addGuideLine(a, b) {
    if (this.hasViewport && getDist(a.x, a.y, b.x, b.y) < 1)
      return this;
    if (this.checkInViewport(a) || this.checkInViewport(b)) {
      this.segmentList.push({
        line: true,
        guide: true,
        x1: a.x,
        y1: a.y,
        x2: b.x,
        y2: b.y
      });
    }
    return this;
  }
  addDistanceLine(a, b) {
    if (this.hasViewport && getDist(a.x, a.y, b.x, b.y) < 1)
      return this;
    this.segmentList.push({
      line: true,
      distance: true,
      x1: a.x,
      y1: a.y,
      x2: b.x,
      y2: b.y
    });
    return this;
  }
  addDistanceAngle(center2, rx, ry, degree, last, line2) {
    this.segmentList.push({
      angle: true,
      rx,
      ry,
      line: line2,
      degree,
      center: center2,
      last
    });
    return this;
  }
  addPoint(obj2, point2, index2, segment, selected = false) {
    if (this.checkInViewport(point2)) {
      this.segmentList.push(__spreadProps(__spreadValues({}, obj2), {
        cx: point2.x,
        cy: point2.y,
        selected,
        index: index2,
        segment,
        isFirst: point2.isFirst,
        isLast: point2.isLast,
        isSecond: point2.isSecond
      }));
    }
    return this;
  }
  addStartPoint(obj2, point2) {
    if (this.checkInViewport(point2)) {
      this.segmentList.push(__spreadProps(__spreadValues({}, obj2), {
        cx: point2.x,
        cy: point2.y,
        start: true
      }));
    }
    return this;
  }
  addCurvePoint(point2, index2, segment, selected = false) {
    if (this.checkInViewport(point2)) {
      this.segmentList.push({
        curve: true,
        cx: point2.x,
        cy: point2.y,
        index: index2,
        selected,
        segment,
        isFirst: point2.isFirst,
        isLast: point2.isLast,
        isSecond: point2.isSecond
      });
    }
    return this;
  }
  addText(point2, text2) {
    this.segmentList.push({
      type: "text",
      cx: point2.x,
      cy: point2.y,
      text: text2 + ""
    });
    return this;
  }
  toString() {
    this.segmentList.sort((a, b) => {
      if (a.line && !b.line) {
        return -1;
      } else if (!a.line && b.line) {
        return 1;
      }
      return 0;
    });
    return this.segmentList.map((it) => {
      if (it.angle) {
        return `
                <path stroke-width='1' 
                    data-distance='true'
                    fill="rgba(0,0,0,0.5)"
                    d="M ${it.center.x},${it.center.y} A ${it.rx} ${it.ry},${it.degree},0,0,${it.last.x} ${it.last.y} L${it.line.x} ${it.line.y} Z"
                />`;
      } else if (it.line) {
        return `
                <line stroke-width='1' 
                    data-segment="true"
                    data-is-last="${it.isLast}"                
                    data-guide='${it.guide}'
                    data-distance='${it.distance}'
                    x1='${it.x1}' x2='${it.x2}' y1='${it.y1}' y2='${it.y2}' 
                />`;
      } else if (it.text) {
        return "";
      } else if (it.curve && it.segment !== "startPoint") {
        return `
                <path stroke-width='1'
                    class='curve' 
                    ${it.selected && `data-selected="true"`}
                    ${it.isLast && `data-is-last="true"`}
                    ${it.isFirst && `data-is-first="true"`}
                    ${it.isSecond && `data-is-second="true"`}
                    title="${it.segment} curve"  
                    data-index='${it.index}'
                    data-segment-point='${it.segment}'
                    data-segment="true" 
                    d="M ${it.cx} ${it.cy - 4}L ${it.cx + 4} ${it.cy} L ${it.cx} ${it.cy + 4} L ${it.cx - 4} ${it.cy} Z"
                />`;
      } else if (it.start) {
        return `
                <circle 
                    cx='${it.cx}' 
                    cy='${it.cy}' 
                    r='4'                    
                    class='segment'
                    data-selected='${it.selected}'
                    title="Center"
                    data-start="true" 
                    tabIndex="-1"
                />`;
      } else {
        return `
                <circle 
                    cx='${it.cx}' 
                    cy='${it.cy}' 
                    r='4'                    
                    class='segment'
                    data-selected='${it.selected}'
                    title="${it.segment}"
                    data-is-last="${it.isLast}"
                    data-is-first="${it.isFirst}"
                    data-is-second="${it.isSecond}"
                    data-index='${it.index}' 
                    data-segment-point='${it.segment}' 
                    data-segment="true" 
                    tabIndex="-1"                    
                />`;
      }
    }).join("");
  }
}
const SEGMENT_DIRECTION$1 = ["startPoint", "endPoint", "reversePoint"];
function calculateSnapPoint$1(points, sourceKey, target, distanceValue, dist2) {
  var checkedPointList = points.filter((p) => {
    if (!p)
      return false;
    return Math.abs(p[sourceKey] - target) <= dist2;
  }).map((p) => {
    return { dist: Math.abs(p[sourceKey] - target), point: p };
  });
  checkedPointList.sort((a, b) => {
    return a.dist < b.dist ? -1 : 1;
  });
  var point2 = null;
  if (checkedPointList.length) {
    point2 = checkedPointList[0].point;
    distanceValue += point2[sourceKey] - target;
  }
  return { point: point2, distanceValue };
}
function calculateMovePointSnap$1(points, moveXY, dist2 = 1) {
  var snapPointX = calculatePointDist$1(points, "x", moveXY.x, dist2);
  var snapPointY = calculatePointDist$1(points, "y", moveXY.y, dist2);
  var snapEndPoint = __spreadValues({}, moveXY);
  if (snapPointX) {
    snapEndPoint.x = snapPointX.x;
  }
  if (snapPointY) {
    snapEndPoint.y = snapPointY.y;
  }
  var snapPointList = [];
  if (snapPointX) {
    snapPointList.push({ startPoint: snapPointX, endPoint: snapEndPoint });
  }
  if (snapPointY) {
    snapPointList.push({ startPoint: snapPointY, endPoint: snapEndPoint });
  }
  return { snapPointList, moveXY: snapEndPoint };
}
function calculatePointDist$1(points, sourceKey, target, dist2) {
  var checkedPointList = [];
  var arr = SEGMENT_DIRECTION$1;
  points.filter((p) => p).forEach((p) => {
    arr.filter((key) => p[key]).forEach((key) => {
      var point2 = p[key];
      var tempDist = Math.abs(point2[sourceKey] - target);
      if (tempDist <= dist2) {
        checkedPointList.push({ dist: tempDist, point: point2 });
      }
    });
  });
  checkedPointList.sort((a, b) => {
    return a.dist > b.dist ? 1 : -1;
  });
  return checkedPointList.length ? checkedPointList[0].point : null;
}
function toPath$1(points, minX, minY, scale2 = 1) {
  var d = [];
  for (var index2 = 0, len2 = points.length; index2 < len2; index2++) {
    var currentIndex = index2;
    var current = points[currentIndex];
    if (!current)
      continue;
    if (current.command === "M") {
      d.push({ command: "M", values: [current.startPoint] });
    } else {
      var prevPoint = Point.getPrevPoint(points, index2);
      if (current.curve === false) {
        if (prevPoint.curve === false) {
          d.push({ command: "L", values: [current.startPoint] });
        } else {
          d.push({
            command: "Q",
            values: [prevPoint.endPoint, current.startPoint]
          });
        }
      } else {
        if (prevPoint.curve === false) {
          if (Point.isEqual(current.reversePoint, current.startPoint)) {
            d.push({ command: "L", values: [current.startPoint] });
          } else {
            d.push({
              command: "Q",
              values: [current.reversePoint, current.startPoint]
            });
          }
        } else {
          d.push({
            command: "C",
            values: [
              prevPoint.endPoint,
              current.reversePoint,
              current.startPoint
            ]
          });
        }
      }
    }
    if (current.close) {
      d.push({ command: "Z" });
    }
  }
  var dString = d.map((segment) => {
    return calculateRelativePosition$1(minX, minY, segment, scale2);
  }).join(" ");
  return {
    d: dString
  };
}
function calculateRelativePosition$1(minX, minY, segment, scale2 = 1) {
  var { command, values } = segment;
  switch (command) {
    case "Z":
      return "Z";
    default:
      var str = values.map((v) => {
        var tx = v.x - minX === 0 ? 0 : (v.x - minX) / scale2;
        var ty = v.y - minY === 0 ? 0 : (v.y - minY) / scale2;
        return `${tx} ${ty}`;
      }).join(" ");
      return `${command} ${str}`;
  }
}
function checkInArea$1(area2, point2) {
  if (area2.x2.value < point2.x) {
    return false;
  }
  if (area2.y2.value < point2.y) {
    return false;
  }
  if (area2.x.value > point2.x) {
    return false;
  }
  if (area2.y.value > point2.y) {
    return false;
  }
  return true;
}
class PurePathGenerator {
  generatorPathString(points, minX = 0, minY = 0, scale2 = 1) {
    return toPath$1(points, minX, minY, scale2).d;
  }
  constructor(pathEditor) {
    this.pathEditor = pathEditor;
    this.pathStringManager = new PathStringManager();
    this.guideLineManager = new PathStringManager();
    this.segmentManager = new SegmentManager(null);
    this.points = [];
    this.cachedSegmentKeys = {};
    this.initialize();
    this.initializeSelect();
  }
  initialize() {
    this.splitLines = [];
    this.guideLineManager.reset();
    this.segmentManager.reset();
    this.pathStringManager.reset();
  }
  initializeSelect(initPointList = []) {
    this.selectedPointKeys = {};
    this.selectedPointList = [];
    if (initPointList.length) {
      this.select(...initPointList.map((p) => {
        const checkedPoint = this.points[p.index][p.key];
        if (!checkedPoint)
          return void 0;
        return {
          x: checkedPoint.x,
          y: checkedPoint.y,
          key: p.key,
          index: checkedPoint.index
        };
      }).filter(Boolean));
    }
  }
  get state() {
    return this.pathEditor.state;
  }
  get clonePoints() {
    return [...this.points];
  }
  get length() {
    return this.points.length;
  }
  setPoints(points = []) {
    this.points = points;
    this.snapPointList = [];
    if (this.points.length === 0) {
      this.select();
      this.selectGroup(-1);
    }
  }
  selectInBox(box, isToggle = false) {
    var list2 = [];
    this.points.forEach((point2, index2) => {
      SEGMENT_DIRECTION$1.forEach((key) => {
        const p = point2[key];
        if (checkInArea$1(box, p)) {
          list2.push({ x: p.x, y: p.y, key, index: index2 });
        }
      });
    });
    if (isToggle) {
      list2 = list2.map((it) => {
        const selectedKey = this.makeSegmentKey(it);
        return __spreadProps(__spreadValues({}, it), {
          included: Boolean(this.selectedPointKeys[selectedKey])
        });
      });
      const includedList = list2.filter((it) => it.included);
      const notIncludedList = list2.filter((it) => !it.included);
      let uniqueList = [...this.selectedPointList];
      if (includedList.length) {
        uniqueList = this.selectedPointList.filter((it) => {
          const oldKey = this.makeSegmentKey(it);
          return Boolean(includedList.find((includeNode) => {
            return oldKey === this.makeSegmentKey(includeNode);
          })) === false;
        });
      }
      this.select(...uniqueList, ...notIncludedList);
    } else {
      this.select(...list2);
    }
  }
  makeSegmentKey(p) {
    return `${p.key}_${p.index}`;
  }
  select(...list2) {
    this.selectedPointKeys = {};
    this.selectedPointList = list2.map(({ x, y, key, index: index2 }) => ({
      x,
      y,
      key,
      index: +index2
    }));
    list2.forEach((it) => {
      var key = this.makeSegmentKey(it);
      this.selectedPointKeys[key] = true;
    });
  }
  convertPointsToSelectionList(points) {
    var list2 = [];
    points.forEach((point2) => {
      SEGMENT_DIRECTION$1.forEach((key) => {
        const { x, y } = point2[key];
        list2.push({ x, y, key, index: point2.index });
      });
    });
    return list2;
  }
  selectGroup(groupIndex) {
    const group2 = this.splitedGroupList[groupIndex];
    if (group2) {
      this.select(...this.convertPointsToSelectionList(group2.points));
    } else {
      this.select();
    }
  }
  getCacheSegmentKey(segmentKey, index2) {
    if (!this.cachedSegmentKeys[segmentKey]) {
      this.cachedSegmentKeys[segmentKey] = {};
    }
    if (!this.cachedSegmentKeys[segmentKey][index2]) {
      this.cachedSegmentKeys[segmentKey][index2] = this.makeSegmentKey({
        key: segmentKey,
        index: index2
      });
    }
    return this.cachedSegmentKeys[segmentKey][index2];
  }
  toggleSelect(key, index2) {
    if (this.points[index2]) {
      var point2 = this.points[index2][key];
      if (point2 && !this.isSelectedSegment(key, index2)) {
        this.select(...this.selectedPointList, {
          x: point2.x,
          y: point2.y,
          key,
          index: index2
        });
      } else {
        this.select(...this.selectedPointList.filter((it) => {
          return it.key !== key || it.index !== index2;
        }));
      }
    }
  }
  selectKeyIndex(key, index2) {
    if (this.points[index2]) {
      var point2 = this.points[index2][key];
      if (point2 && !this.isSelectedSegment(key, index2)) {
        this.select({ x: point2.x, y: point2.y, key, index: index2 });
      }
    }
  }
  reselect() {
    this.selectedPointList.filter(Boolean).forEach((it) => {
      var _a;
      var point2 = (_a = this.points[it.index]) == null ? void 0 : _a[it.key];
      if (point2) {
        it.x = point2.x;
        it.y = point2.y;
      }
    });
  }
  isSelectedSegment(segment, index2) {
    var key = this.getCacheSegmentKey(segment, index2);
    return this.selectedPointKeys[key];
  }
  commitTransformMatrix(point2, transformMatrix) {
    var result = transformMat4([], [point2.x, point2.y, 0], transformMatrix);
    return { x: result[0], y: result[1] };
  }
  transformMat4(transformMatrix) {
    this.transformPoints.forEach((p, index2) => {
      var realPoint = this.points[index2];
      Object.assign(realPoint.startPoint, this.commitTransformMatrix(p.startPoint, transformMatrix));
      Object.assign(realPoint.endPoint, this.commitTransformMatrix(p.endPoint, transformMatrix));
      Object.assign(realPoint.reversePoint, this.commitTransformMatrix(p.reversePoint, transformMatrix));
    });
  }
  transform(type) {
    var { x, y, width: width2, height: height2 } = this.transformRect;
    var view = create$4();
    translate(view, view, [x, y, 0]);
    switch (type) {
      case "flipX":
        scale$1(view, view, [-1, 1, 1]);
        translate(view, view, [-width2, 0, 0]);
        break;
      case "flipY":
        scale$1(view, view, [1, -1, 1]);
        translate(view, view, [0, -height2, 0]);
        break;
      case "flip":
        scale$1(view, view, [-1, -1, 1]);
        translate(view, view, [-width2, -height2, 0]);
        break;
    }
    translate(view, view, [-x, -y, 0]);
    this.transformMat4(view);
  }
  initTransform(rect2) {
    this.transformRect = clone$1(rect2);
    this.transformPoints = this.clonePoints.map((p) => {
      return {
        startPoint: clone$1(p.startPoint),
        endPoint: clone$1(p.endPoint),
        reversePoint: clone$1(p.reversePoint)
      };
    });
  }
  setConnectedPoint(dx, dy) {
    var state = this.state;
    var x = state.dragXY.x + dx;
    var y = state.dragXY.y + dy;
    var endPoint = { x, y };
    var reversePoint = { x, y };
    if (state.dragPoints) {
      state.reversePoint = Point.getReversePoint(state.startPoint, endPoint);
    }
    var point2 = {
      startPoint: state.startPoint,
      endPoint,
      curve: !!state.dragPoints,
      reversePoint,
      connected: true,
      close: true
    };
    this.points.push(point2);
  }
  setLastPoint(startPoint) {
    var endPoint = clone$1(startPoint);
    var reversePoint = clone$1(startPoint);
    var point2 = {
      startPoint,
      endPoint,
      curve: false,
      reversePoint,
      connected: false,
      close: false
    };
    this.points.push(point2);
  }
  getPrevPoint(index2) {
    return Point.getPrevPoint(this.points, index2);
  }
  getIndexPoint(index2) {
    return Point.getIndexPoint(this.points, index2);
  }
  getNextPoint(index2) {
    return Point.getNextPoint(this.points, index2);
  }
  getConnectedPointList(index2) {
    return Point.getConnectedPointList(this.points, index2);
  }
  isFirst(segment) {
    return Point.isFirst(segment);
  }
  getLastPoint(index2) {
    return Point.getLastPoint(this.points, index2);
  }
  setCachePoint(index2, segmentKey) {
    var state = this.state;
    this.snapPointList = [];
    this.selectedIndex = index2;
    state.connectedPoint = this.getPrevPoint(index2);
    state.connectedPointList = clone$1(Point.getConnectedPointList(this.points, this.selectedIndex));
    if (state.connectedPoint && !state.connectedPoint.connected) {
      state.connectedPoint = null;
    }
    state.segment = this.getIndexPoint(index2);
    if (state.segment.connected) {
      state.connectedPoint = this.getNextPoint(index2);
    }
    var isFirstSegment = this.isFirst(state.segment);
    if (isFirstSegment) {
      var lastPoint = this.getLastPoint(index2);
      if (lastPoint.connected) {
        state.connectedPoint = lastPoint;
      }
    }
    state.segmentKey = segmentKey;
    state.isCurveSegment = state.segment.curve && state.segmentKey != "startPoint";
    state.originalSegment = clone$1(state.segment);
    if (state.connectedPoint) {
      state.originalConnectedPoint = clone$1(state.connectedPoint);
    }
    state.cachedPoints = [];
    this.points.filter((p) => p && p != state.segment).forEach((p) => {
      state.cachedPoints.push(p.startPoint, p.reversePoint, p.endPoint);
    });
  }
  clamp(value, min, max) {
    if (isUndefined(min) || isUndefined(max)) {
      return value;
    }
    return Math.max(min, Math.min(max, value));
  }
  moveSegment(segmentKey, dx, dy, originSegment = void 0, maxWidth = void 0, maxHeight = void 0) {
    if (originSegment) {
      const segment = this.points[originSegment.index][segmentKey];
      segment.x = this.clamp(originSegment[segmentKey].x + dx, 0, maxWidth);
      segment.y = this.clamp(originSegment[segmentKey].y + dy, 0, maxHeight);
    } else {
      var state = this.state;
      var originPoint = state.originalSegment[segmentKey];
      var targetPoint = state.segment[segmentKey];
      if (originPoint) {
        targetPoint.x = this.clamp(originPoint.x + dx, 0, maxWidth);
        targetPoint.y = this.clamp(originPoint.y + dy, 0, maxHeight);
      }
    }
  }
  calculateToCurve(point2, nextPoint, prevPoint) {
    var centerX = (nextPoint.startPoint.x + prevPoint.startPoint.x) / 2;
    var centerY = (nextPoint.startPoint.y + prevPoint.startPoint.y) / 2;
    var dx = (nextPoint.startPoint.x - centerX) / 2;
    var dy = (nextPoint.startPoint.y - centerY) / 2;
    point2.endPoint = {
      x: point2.startPoint.x + dx,
      y: point2.startPoint.y + dy
    };
    point2.reversePoint = {
      x: point2.startPoint.x - dx,
      y: point2.startPoint.y - dy
    };
    return { dx, dy };
  }
  convertToCurve(index2) {
    var point2 = this.points[index2];
    if (point2.curve) {
      point2.curve = false;
      point2.reversePoint = clone$1(point2.startPoint);
      point2.endPoint = clone$1(point2.startPoint);
      if (point2.command === "M") {
        var lastPoint = Point.getPrevPoint(this.points, point2.index);
        if (lastPoint.connected) {
          lastPoint.curve = false;
          lastPoint.reversePoint = clone$1(lastPoint.startPoint);
          lastPoint.endPoint = clone$1(lastPoint.startPoint);
        }
      } else {
        var nextPoint = this.getNextPoint(index2);
        if (nextPoint && nextPoint.command === "M") {
          var firstPoint = nextPoint;
          firstPoint.curve = false;
          firstPoint.reversePoint = clone$1(firstPoint.startPoint);
          firstPoint.endPoint = clone$1(firstPoint.startPoint);
        }
      }
    } else {
      point2.curve = true;
      var prevPoint = this.getPrevPoint(index2);
      var nextPoint = this.getNextPoint(index2);
      if (nextPoint && nextPoint.index < index2 && nextPoint.command === "M") {
        var firstPoint = nextPoint;
        nextPoint = this.getNextPoint(firstPoint.index);
        this.calculateToCurve(point2, nextPoint, prevPoint);
        firstPoint.curve = true;
        firstPoint.endPoint = clone$1(point2.endPoint);
        firstPoint.reversePoint = clone$1(point2.reversePoint);
      } else if (nextPoint && nextPoint.index > index2 && nextPoint.command !== "M") {
        this.calculateToCurve(point2, nextPoint, prevPoint);
      } else if (!nextPoint && prevPoint) {
        var centerX = (point2.startPoint.x - prevPoint.startPoint.x) / 3;
        var centerY = (point2.startPoint.y - prevPoint.startPoint.y) / 3;
        point2.endPoint = {
          x: point2.startPoint.x + centerX,
          y: point2.startPoint.y + centerY
        };
        point2.reversePoint = Point.getReversePoint(point2.startPoint, point2.endPoint);
      } else if (!prevPoint && nextPoint) {
        var centerX = (point2.startPoint.x - nextPoint.startPoint.x) / 3;
        var centerY = (point2.startPoint.y - nextPoint.startPoint.y) / 3;
        point2.endPoint = {
          x: point2.startPoint.x + centerX,
          y: point2.startPoint.y + centerY
        };
        point2.reverse = Point.getReversePoint(point2.startPoint, point2.endPoint);
      }
    }
  }
  moveCurveSegment(segmentKey, dx, dy) {
    var state = this.state;
    this.moveSegment(segmentKey, dx, dy);
    var targetSegmentKey = segmentKey === "endPoint" ? "reversePoint" : "endPoint";
    state.segment[targetSegmentKey] = Point.getReversePoint(state.segment.startPoint, state.segment[segmentKey]);
  }
  rotateSegmentTarget(segmentKey, target) {
    var state = this.state;
    if (state.originalSegment && state.segment) {
      var { x: cx, y: cy } = state.originalSegment.startPoint;
      var { x: rx, y: ry } = state.segment[segmentKey];
      var { x: tx, y: ty } = state.originalSegment[target];
      var { x, y } = getXYInCircle(calculateAngle360(rx - cx, ry - cy), getDist(tx, ty, cx, cy), cx, cy);
      state.segment[target] = { x, y };
    }
  }
  rotateSegment(segmentKey) {
    this.rotateSegmentTarget(segmentKey, segmentKey === "endPoint" ? "reversePoint" : "endPoint");
  }
  calculateSnap(segmentKey, dx, dy, dist2 = 1) {
    var state = this.state;
    var cachedPoints = state.cachedPoints;
    var original = state.originalSegment[segmentKey];
    if (!segmentKey) {
      return { dx, dy, snapPointList: [] };
    }
    var realX = original.x + dx;
    var realY = original.y + dy;
    var { point: snapPointX, distanceValue: dx } = calculateSnapPoint$1(cachedPoints, "x", realX, dx, dist2);
    var { point: snapPointY, distanceValue: dy } = calculateSnapPoint$1(cachedPoints, "y", realY, dy, dist2);
    var snapEndPoint = {
      x: original.x + dx,
      y: original.y + dy
    };
    var snapPointList = [];
    if (snapPointX) {
      snapPointList.push({ startPoint: snapPointX, endPoint: snapEndPoint });
    }
    if (snapPointY) {
      snapPointList.push({ startPoint: snapPointY, endPoint: snapEndPoint });
    }
    return { dx, dy, snapPointList };
  }
  copySegment(from, to) {
    to.startPoint = clone$1(from.startPoint);
    to.endPoint = clone$1(from.endPoint);
    to.reversePoint = clone$1(from.reversePoint);
  }
  get selectedLength() {
    return this.selectedPointList.length;
  }
  moveSelectedSegment(dx, dy) {
    if (this.selectedPointList.length > 0) {
      this.selectedPointList.forEach((it) => {
        var target = this.points[it.index][it.key];
        target.x = it.x + dx;
        target.y = it.y + dy;
      });
    } else if (this.selectedGroup) {
      this.moveSelectedGroup(dx, dy);
    }
  }
  moveSelectedGroup(dx, dy, maxWidth, maxHeight) {
    this.selectedGroup.points.forEach((it) => {
      const target = this.points[it.index];
      target.startPoint.x = this.clamp(it.startPoint.x + dx, 0, maxWidth);
      target.startPoint.y = this.clamp(it.startPoint.y + dy, 0, maxHeight);
      target.endPoint.x = it.endPoint.x + dx;
      target.endPoint.y = it.endPoint.y + dy;
      target.reversePoint.x = it.reversePoint.x + dx;
      target.reversePoint.y = it.reversePoint.y + dy;
    });
  }
  get selectedGroup() {
    return this.splitedGroupList[this.state.selectedGroupIndex];
  }
  get splitedGroupList() {
    return Point.getSplitedGroupList(this.points);
  }
  get groupList() {
    return Point.getGroupList(this.points);
  }
  getGroup(groupList, pointIndex) {
    return Point.getGroup(groupList, pointIndex);
  }
  get selectedGroupIndexList() {
    const groupIndexList = /* @__PURE__ */ new Set();
    const groupList = this.groupList;
    if (this.selectedPointList.length === 0 && this.state.selectedGroupIndex < 0) {
      return groupList.map((group2) => group2.groupIndex);
    }
    const points = this.selectedPointList;
    points.forEach((it) => {
      const group2 = this.getGroup(groupList, it.index);
      if (group2) {
        groupIndexList.add(group2.groupIndex);
      }
    });
    return [.../* @__PURE__ */ new Set([...groupIndexList, this.state.selectedGroupIndex])];
  }
  removeSelectedSegment() {
    this.selectedPointList.forEach((it) => {
      var target = this.points[it.index][it.key];
      target.removed = true;
    });
    const pointGroup = Point.splitPoints(this.points);
    const newPoints = Point.recoverPoints(pointGroup.map((points) => {
      return points.filter((p) => !p.startPoint.removed).map((p) => {
        if (p.endPoint.removed) {
          p.endPoint = clone$1(p.startPoint);
        }
        if (p.reversePoint.removed) {
          p.reversePoint = clone$1(p.startPoint);
        }
        if (Point.isEqual(p.endPoint, p.startPoint, p.reversePoint)) {
          p.command = "L";
          p.curve = false;
        }
        return p;
      });
    }));
    this.points = newPoints;
    this.select();
  }
  move(dx, dy, e, maxWidth, maxHeight) {
    var state = this.state;
    var { isCurveSegment, segmentKey, connectedPoint } = state;
    if (this.selectedPointList.length > 1) {
      this.moveSelectedSegment(dx, dy, maxWidth, maxHeight);
    } else if (this.selectedPointList.length === 1) {
      var { dx, dy, snapPointList } = this.calculateSnap(segmentKey, dx, dy, 3);
      this.snapPointList = snapPointList || [];
      if (isCurveSegment) {
        if (e.altKey) {
          this.moveSegment(segmentKey, dx, dy);
          this.rotateSegment(segmentKey);
        } else if (e.shiftKey) {
          this.moveSegment(segmentKey, dx, dy);
        } else {
          this.moveSegment(segmentKey, dx, dy);
          var targetSegmentKey = segmentKey === "endPoint" ? "reversePoint" : "endPoint";
          state.segment[targetSegmentKey] = Point.getReversePoint(state.segment.startPoint, state.segment[segmentKey]);
        }
      } else {
        this.moveSegment("startPoint", dx, dy, null, maxWidth, maxHeight);
        this.moveSegment("endPoint", dx, dy);
        this.moveSegment("reversePoint", dx, dy);
        if (!e.altKey) {
          state.connectedPointList.forEach((it) => {
            this.moveSegment("startPoint", dx, dy, it, maxWidth, maxHeight);
            this.moveSegment("endPoint", dx, dy, it);
            this.moveSegment("reversePoint", dx, dy, it);
          });
        }
      }
      connectedPoint && this.copySegment(state.segment, state.connectedPoint);
    } else if (this.state.selectedGroupIndex > -1) {
      this.moveSelectedGroup(dx, dy, maxWidth, maxHeight);
    }
  }
  moveEnd(dx, dy) {
    var state = this.state;
    var points = this.points;
    var x = state.dragXY.x + dx;
    var y = state.dragXY.y + dy;
    var endPoint = { x, y };
    var reversePoint = { x, y };
    if (state.dragPoints) {
      reversePoint = Point.getReversePoint(state.startPoint, endPoint);
    }
    points.push({
      command: state.clickCount === 0 ? "M" : "",
      startPoint: state.startPoint,
      endPoint,
      curve: !!state.dragPoints,
      reversePoint
    });
    state.startPoint = null;
    state.dragPoints = false;
    state.moveXY = null;
  }
  setPoint(obj2) {
    var p0 = obj2.first[0];
    var p1 = obj2.second[obj2.second.length - 1];
    var allPoints = this.clonePoints;
    var firstItem = Point.getPoint(allPoints, p0);
    var secondItem = Point.getPoint(allPoints, p1);
    var newPoints = [
      __spreadProps(__spreadValues({}, firstItem), { endPoint: obj2.first[1] }),
      {
        startPoint: obj2.first[3],
        reversePoint: obj2.first[2],
        curve: true,
        endPoint: obj2.second[1]
      },
      __spreadProps(__spreadValues({}, secondItem), { reversePoint: obj2.second[2] })
    ];
    var firstIndex = Point.getIndex(allPoints, p0);
    allPoints.splice(firstIndex, 2, ...newPoints);
    this.points = allPoints;
    return firstIndex + 1;
  }
  setPointQuard(obj2) {
    var p0 = obj2.first[0];
    var p1 = obj2.second[obj2.second.length - 1];
    var allPoints = this.clonePoints;
    var firstItem = Point.getPoint(allPoints, p0);
    var secondItem = Point.getPoint(allPoints, p1);
    if (firstItem.curve && secondItem.curve === false) {
      var newPoints = [
        __spreadProps(__spreadValues({}, firstItem), { endPoint: firstItem.startPoint }),
        {
          startPoint: obj2.first[2],
          reversePoint: obj2.first[1],
          curve: true,
          endPoint: obj2.second[1]
        }
      ];
      var firstIndex = Point.getIndex(allPoints, p0);
      allPoints.splice(firstIndex, 1, ...newPoints);
    } else {
      var newPoints = [
        __spreadValues({}, firstItem),
        {
          startPoint: obj2.first[2],
          reversePoint: obj2.first[1],
          curve: true,
          endPoint: obj2.second[1]
        },
        __spreadProps(__spreadValues({}, secondItem), { reversePoint: obj2.second[1], curve: true })
      ];
      var firstIndex = Point.getIndex(allPoints, p0);
      allPoints.splice(firstIndex, 2, ...newPoints);
    }
    this.points = allPoints;
    return firstIndex + 1;
  }
  setPointLine(obj2) {
    var p0 = obj2.first[0];
    var allPoints = this.clonePoints;
    var newPoints = [
      {
        command: "L",
        startPoint: obj2.first[1],
        curve: false,
        endPoint: obj2.first[1],
        reversePoint: obj2.first[1]
      }
    ];
    var firstIndex = Point.getIndex(allPoints, p0);
    allPoints.splice(firstIndex + 1, 0, ...newPoints);
    this.points = allPoints;
    return firstIndex + 1;
  }
  toPath(minX = 0, minY = 0, scale2 = 1) {
    return toPath$1(this.clonePoints, minX, minY, scale2);
  }
  makeSVGPath() {
    this.initialize();
    this.makePointGuide(this.points);
    this.makeMovePositionGuide();
    return this.toSVGString();
  }
  makeTriangleDistancePointGuide(first, second2) {
    var minX = Math.min(first.startPoint.x, second2.startPoint.x);
    var maxX = Math.max(first.startPoint.x, second2.startPoint.x);
    var minY = Math.min(first.startPoint.y, second2.startPoint.y);
    var maxY = Math.max(first.startPoint.y, second2.startPoint.y);
    if (first.startPoint.x < second2.startPoint.x && first.startPoint.y < second2.startPoint.y) {
      this.segmentManager.addDistanceLine({ x: minX, y: minY }, { x: maxX, y: minY }).addDistanceLine({ x: maxX, y: minY }, { x: maxX, y: maxY });
      var centerX = minX;
      var centerY = minY;
      var angle = calculateAngle360(maxX - minX, maxY - minY) - 180;
      var dist2 = 20;
      var { x, y } = getXYInCircle(0, dist2, centerX, centerY);
      var last = getXYInCircle(angle, dist2, centerX, centerY);
      this.segmentManager.addDistanceAngle(last, dist2, dist2, angle, { x, y }, { x: x - dist2, y });
    } else if (first.startPoint.x < second2.startPoint.x && first.startPoint.y > second2.startPoint.y) {
      this.segmentManager.addDistanceLine({ x: minX, y: maxY }, { x: maxX, y: maxY }).addDistanceLine({ x: maxX, y: minY }, { x: maxX, y: maxY });
    } else if (first.startPoint.x > second2.startPoint.x && first.startPoint.y > second2.startPoint.y) {
      this.segmentManager.addDistanceLine({ x: minX, y: minY }, { x: minX, y: maxY }).addDistanceLine({ x: minX, y: maxY }, { x: maxX, y: maxY });
    } else if (first.startPoint.x > second2.startPoint.x && first.startPoint.y < second2.startPoint.y) {
      this.segmentManager.addDistanceLine({ x: minX, y: maxY }, { x: maxX, y: maxY }).addDistanceLine({ x: maxX, y: minY }, { x: maxX, y: maxY });
    }
  }
  makeDistancePointGuide(prevPoint, current, nextPoint) {
    if (current.selected) {
      if (prevPoint) {
        this.makeTriangleDistancePointGuide(prevPoint, current);
      }
      if (nextPoint) {
        this.makeTriangleDistancePointGuide(current, nextPoint);
      }
    }
  }
  makeStartPointGuide(prevPoint, current, nextPoint, index2) {
    current.startPoint.isFirst = true;
    if (current.curve === false) {
      this.segmentManager.addPoint({}, current.startPoint, index2, "startPoint", this.isSelectedSegment("startPoint", index2));
    } else {
      this.segmentManager.addPoint({}, current.startPoint, index2, "startPoint", this.isSelectedSegment("startPoint", index2)).addGuideLine(current.startPoint, current.endPoint);
      if (Point.isEqual(current.startPoint, current.endPoint) === false) {
        this.segmentManager.addCurvePoint(current.endPoint, index2, "endPoint", this.isSelectedSegment("endPoint", index2));
      }
    }
  }
  makeMiddlePointGuideSegment(prevPoint, current, nextPoint, index2) {
    var mng = this.segmentManager;
    if (current.curve === false) {
      if (prevPoint.curve === false) {
        mng.addPoint({}, current.startPoint, index2, "startPoint", this.isSelectedSegment("startPoint", index2));
      } else {
        mng.addGuideLine(prevPoint.startPoint, prevPoint.endPoint).addCurvePoint(current.startPoint, index2, "startPoint", this.isSelectedSegment("startPoint", index2));
        if (Point.isEqual(prevPoint.startPoint, prevPoint.endPoint) === false) {
          mng.addCurvePoint(prevPoint.endPoint, prevPoint.index, "endPoint", this.isSelectedSegment("endPoint", prevPoint.index));
        }
      }
    } else {
      if (prevPoint.curve === false) {
        if (Point.isEqual(current.reversePoint, current.startPoint)) {
          mng.addPoint({}, current.startPoint, index2, "startPoint", this.isSelectedSegment("startPoint", index2));
        } else {
          mng.addGuideLine(current.startPoint, current.reversePoint).addCurvePoint(current.startPoint, index2, "startPoint", this.isSelectedSegment("startPoint", index2));
          if (Point.isEqual(current.startPoint, current.reversePoint) === false) {
            mng.addCurvePoint(current.reversePoint, index2, "reversePoint", this.isSelectedSegment("reversePoint", index2));
          }
        }
      } else {
        if (current.connected) {
          mng.addGuideLine(prevPoint.startPoint, prevPoint.endPoint).addGuideLine(current.startPoint, current.reversePoint);
          if (Point.isEqual(prevPoint.startPoint, prevPoint.endPoint) === false) {
            mng.addCurvePoint(prevPoint.endPoint, prevPoint.index, "endPoint", this.isSelectedSegment("endPoint", prevPoint.index));
          }
          if (Point.isEqual(current.startPoint, current.reversePoint) === false) {
            mng.addCurvePoint(current.reversePoint, index2, "reversePoint", this.isSelectedSegment("reversePoint", index2));
          }
        } else {
          mng.addGuideLine(prevPoint.startPoint, prevPoint.endPoint).addGuideLine(current.startPoint, current.reversePoint).addCurvePoint(current.startPoint, index2, "startPoint", this.isSelectedSegment("startPoint", index2));
          if (Point.isEqual(prevPoint.startPoint, prevPoint.endPoint) === false) {
            mng.addCurvePoint(prevPoint.endPoint, prevPoint.index, "endPoint", this.isSelectedSegment("endPoint", prevPoint.index));
          }
          if (Point.isEqual(current.startPoint, current.reversePoint) === false) {
            mng.addCurvePoint(current.reversePoint, index2, "reversePoint", this.isSelectedSegment("reversePoint", index2));
          }
        }
      }
    }
  }
  makeMiddlePointGuideSplitLine(prevPoint, current) {
    const selected = "selected";
    if (current.curve === false) {
      if (prevPoint.curve === false) {
        this.splitLines.push(new PathStringManager().M(prevPoint.startPoint).L(current.startPoint).toString(`split-path ${selected}`));
      } else {
        this.splitLines.push(new PathStringManager().M(prevPoint.startPoint).Q(prevPoint.endPoint, current.startPoint).toString(`split-path ${selected}`));
      }
    } else {
      if (prevPoint.curve === false) {
        if (Point.isEqual(current.reversePoint, current.startPoint)) {
          this.splitLines.push(new PathStringManager().M(prevPoint.startPoint).L(current.startPoint).toString(`split-path ${selected}`));
        } else {
          this.splitLines.push(new PathStringManager().M(prevPoint.startPoint).Q(current.reversePoint, current.startPoint).toString(`split-path ${selected}`));
        }
      } else {
        this.splitLines.push(new PathStringManager().M(prevPoint.startPoint).C(prevPoint.endPoint, current.reversePoint, current.startPoint).toString(`split-path ${selected}`));
      }
    }
  }
  makePointGuide(points) {
    for (var index2 = 0, len2 = points.length; index2 < len2; index2++) {
      var currentIndex = index2;
      var current = points[currentIndex];
      if (!current)
        continue;
      var nextPoint = Point.getNextPoint(points, index2);
      var prevPoint = Point.getPrevPoint(points, index2);
      if (prevPoint && prevPoint.command === "M") {
        if (current.startPoint) {
          current.startPoint.isSecond = true;
        }
      }
      if (current.startPoint) {
        if (nextPoint) {
          current.startPoint.isLast = nextPoint.command === "M";
        } else {
          current.startPoint.isLast = index2 === len2 - 1;
        }
      }
      current.selected = this.selectedIndex === index2;
      if (current.command === "M") {
        this.makeStartPointGuide(prevPoint, current, nextPoint, index2);
      } else {
        this.makeMiddlePointGuideSplitLine(prevPoint, current, nextPoint, index2);
        this.makeMiddlePointGuideSegment(prevPoint, current, nextPoint, index2);
      }
      if (current.close) {
        this.pathStringManager.Z();
      }
    }
  }
  makeMovePositionGuide() {
    var state = this.state;
    var {
      startPoint,
      moveXY,
      dragPoints,
      snapPointList,
      isGroupSegment
    } = state;
    var points = this.points;
    if (moveXY) {
      snapPointList = snapPointList || [];
      var { snapPointList: movePointSnapPointList, moveXY: newMoveXY } = calculateMovePointSnap$1(points, moveXY, 3);
      snapPointList.push.apply(snapPointList, movePointSnapPointList);
      state.moveXY = newMoveXY;
      moveXY = newMoveXY;
      this.snapPointList = snapPointList;
      var prev = points[points.length - 1];
      if (dragPoints && !isGroupSegment) {
        if (!prev) {
          var { x, y } = Point.getReversePoint(startPoint, moveXY);
          this.guideLineManager.M(moveXY).L(startPoint).L({ x, y });
          this.segmentManager.addCurvePoint(startPoint).addCurvePoint(moveXY).addCurvePoint({ x, y });
        } else if (prev.curve) {
          var { x, y } = Point.getReversePoint(startPoint, moveXY);
          this.guideLineManager.M(prev.startPoint).C(prev.endPoint, { x, y }, startPoint);
          this.segmentManager.addGuideLine(prev.startPoint, prev.endPoint).addGuideLine(startPoint, { x, y }).addGuideLine(startPoint, moveXY).addCurvePoint(prev.endPoint).addCurvePoint({ x, y }).addCurvePoint(moveXY).addPoint(false, startPoint);
        } else if (prev.curve === false) {
          var { x, y } = Point.getReversePoint(startPoint, moveXY);
          this.guideLineManager.M(prev.startPoint).Q({ x, y }, startPoint);
          this.segmentManager.addGuideLine(moveXY, { x, y }).addPoint(false, startPoint).addCurvePoint({ x, y }).addCurvePoint(moveXY);
        }
      } else {
        if (!prev)
          ;
        else if (prev.curve) {
          this.guideLineManager.M(prev.startPoint).Q(prev.endPoint, moveXY);
          this.segmentManager.addGuideLine(prev.endPoint, prev.startPoint).addCurvePoint(prev.endPoint);
        } else {
          if (!prev.close) {
            this.guideLineManager.M(prev.startPoint).L(moveXY);
            this.segmentManager.addPoint(false, prev.startPoint);
          }
        }
      }
    }
  }
  makeSnapLines() {
    var snapLines = [];
    if (this.snapPointList) {
      var snapPath = new PathStringManager();
      snapLines = this.snapPointList.map((snapPoint) => {
        snapPath.reset();
        return snapPath.M(snapPoint.startPoint).L(snapPoint.endPoint).X(snapPoint.startPoint).toString("snap-path");
      });
    }
    return snapLines.join("");
  }
  makePathArea() {
    const pathList = this.splitedGroupList.map(({ startPointIndex, points }, groupIndex) => {
      const d = this.generatorPathString(points);
      const verties = toRectVerties(PathParser.fromSVGString(d).getBBox());
      return {
        points,
        startPointIndex,
        groupIndex,
        center: verties[4],
        d
      };
    });
    const pathCount = pathList.length;
    return `
            <g>
               ${pathList.map((it) => {
      const { center: center2 } = it;
      const [x, y] = center2;
      const selected = this.state.selectedGroupIndex === it.groupIndex;
      return `
                        <path class="path-area ${selected ? "selected" : ""}" 
                            d="${it.d}" 
                            data-point-index="${it.startPointIndex}" 
                            data-group-index="${it.groupIndex}" 
                        />

                        ${pathCount > 1 && `
                            <text class="path-area-text" x="${x}" y="${y}" >${it.groupIndex + 1}</text>
                        `}
                    `;
    }).join("")}
            </g>
        `;
  }
  toSVGString() {
    return `
        <svg width="100%" height="100%" class='svg-editor-canvas' tabIndex="-1">
            ${this.guideLineManager.toString("guide")}
            ${this.splitLines.join("")}
            ${this.makeSnapLines()}
            ${this.makePathArea()}
            ${this.segmentManager.toString()}
        </svg>
        `;
  }
}
function xy$1([x, y]) {
  return { x, y };
}
function scaleLinear(source2, target) {
  function targetScale(t) {
    if (target[0] < target[1]) {
      return target[0] + t * (target[1] - target[0]);
    } else if (target[0] > target[1]) {
      return target[0] - t * (target[0] - target[1]);
    }
  }
  function rate(v1, v2, current) {
    const minValue = Math.min(v1, v2);
    const maxValue = Math.max(v1, v2);
    return (current - minValue) / (maxValue - minValue);
  }
  return (x) => {
    if (source2[0] < source2[1]) {
      return targetScale(rate(source2[0], source2[1], x));
    } else if (source2[0] > source2[1]) {
      return targetScale(1 - rate(source2[0], source2[1], x));
    }
  };
}
const SegmentConvertor$1 = class extends EditorElement {
  convertToCurve(index2) {
    this.pathGenerator.convertToCurve(index2);
    this.renderPath();
    this.updatePathLayer();
  }
  isEditableSegment() {
    return this.state.disableCurve === false;
  }
  [DOUBLECLICK("$view [data-segment]") + IF("isEditableSegment") + PREVENT](e) {
    var index2 = +e.$dt.attr("data-index");
    this.convertToCurve(index2);
  }
  [DOUBLETAB("$view [data-segment]") + PREVENT + DELAY(300)](e) {
    var index2 = +e.$dt.attr("data-index");
    this.convertToCurve(index2);
  }
};
const PathCutter$1 = class extends SegmentConvertor$1 {
  calculatePointOnLine(d, clickPosition) {
    var parser = new PathParser(d);
    return parser.getClosedPoint(clickPosition);
  }
  [POINTERSTART("$view .split-path") + MOVE() + END()](e) {
    this.initRect();
    var parser = new PathParser(e.$dt.attr("d"));
    var clickPosition = {
      x: e.xy.x - this.state.rect.x,
      y: e.xy.y - this.state.rect.y
    };
    var selectedSegmentIndex = -1;
    if (this.isMode("path")) {
      this.state.dragXY = clickPosition;
      this.state.startPoint = this.state.dragXY;
      this.pathGenerator.setLastPoint(this.state.startPoint);
      this.state.isSplitPath = true;
      this.renderPath();
      if (this.state.current) {
        this.updatePathLayer();
      }
      return;
    } else {
      if (parser.segments[1].command === "C") {
        var points = [
          xy$1(parser.segments[0].values),
          xy$1(parser.segments[1].values.slice(0, 2)),
          xy$1(parser.segments[1].values.slice(2, 4)),
          xy$1(parser.segments[1].values.slice(4, 6))
        ];
        var curve = recoverBezier(...points, 20);
        var t = curve(clickPosition.x, clickPosition.y);
        selectedSegmentIndex = this.pathGenerator.setPoint(getBezierPoints(points, t));
      } else if (parser.segments[1].command === "Q") {
        var points = [
          xy$1(parser.segments[0].values),
          xy$1(parser.segments[1].values.slice(0, 2)),
          xy$1(parser.segments[1].values.slice(2, 4))
        ];
        var curve = recoverBezierQuard(...points, 20);
        var t = curve(clickPosition.x, clickPosition.y);
        selectedSegmentIndex = this.pathGenerator.setPointQuard(getBezierPointsQuard(points, t));
      } else if (parser.segments[1].command === "L") {
        var points = [
          xy$1(parser.segments[0].values),
          xy$1(parser.segments[1].values.slice(0, 2))
        ];
        var curve = recoverBezierLine(...points, 20);
        var t = curve(clickPosition.x, clickPosition.y);
        selectedSegmentIndex = this.pathGenerator.setPointLine(getBezierPointsLine(points, t));
        if (e.altKey) {
          this.pathGenerator.convertToCurve(selectedSegmentIndex);
        }
      }
      this.renderPath();
      this.updatePathLayer();
      this.changeMode("segment-move");
      this.pathGenerator.setCachePoint(selectedSegmentIndex, "startPoint");
      this.pathGenerator.selectKeyIndex("startPoint", selectedSegmentIndex);
    }
  }
};
class PathEditor extends PathCutter$1 {
  initialize() {
    super.initialize();
    this.pathParser = new PathParser();
    this.pathGenerator = new PurePathGenerator(this);
  }
  initState() {
    return {
      domain: this.props.domain || [0, 1],
      range: this.props.range || [1, 0],
      isControl: false,
      disableCurve: false,
      points: [],
      mode: "path",
      clickCount: 0,
      isSegment: false,
      isFirstSegment: false,
      current: null
    };
  }
  template() {
    return `
        <div class='elf--path-editor' tabIndex="-1">
            <style type="text/css" ref="$styleView"></style>
            <svg id='patternId' width='100%' height='100%' xmlns='http://www.w3.org/2000/svg'>
                <defs>
                    <pattern id='stripe' patternUnits='userSpaceOnUse' width='20' height='33' patternTransform='scale(1) rotate(135)'>
                        <path d='M0 8h20z'   stroke-width='1' stroke='#07A3FB' fill='none'/>
                        <path d='M0 16h20z'   stroke-width='1' stroke='#07A3FB' fill='none'/>
                        <path d='M0 24h20z'   stroke-width='1' stroke='#07A3FB' fill='none'/>
                        <path d='M0 32h20z'   stroke-width='1' stroke='#07A3FB' fill='none'/>
                    </pattern>
                </defs>    
            </svg>
            <div class='path-container' ref='$view'></div>
            <div class='path-container split-panel'>
                <svg width="100%" height="100%">
                    <circle ref='$splitCircle' class='split-circle' />
                </svg>
            </div>
            <div class='segment-box' ref='$segmentBox'></div>
        </div>`;
  }
  [BIND("$el")]() {
    return {
      style: {
        height: Length.px(this.props.height) || 200
      }
    };
  }
  initRect(isForce = false) {
    if (!this.state.rect || isForce || this.state.rect.width == 0 || this.state.rect.height == 0) {
      this.state.rect = this.refs.$view.rect();
    }
  }
  [SUBSCRIBE("PathEditorDone")]() {
    this.updatePathLayer();
  }
  [KEYUP() + ENTER]() {
    this.trigger("PathEditorDone");
  }
  [KEYUP() + ESCAPE]() {
    if (this.state.current) {
      this.updatePathLayer();
    }
  }
  [KEYUP() + DELETE]() {
    console.log("delete");
  }
  [KEYUP("$el .segment")](e) {
    const index2 = +e.$dt.data("index");
    console.log(index2);
    switch (e.code) {
      case "Delete":
      case "Backspace":
        this.trigger("deleteSegment");
        break;
    }
  }
  [SUBSCRIBE_SELF("deleteSegment")]() {
    this.pathGenerator.reselect();
    this.pathGenerator.removeSelectedSegment();
    this.renderPath();
    this.updatePathLayer();
  }
  [SUBSCRIBE_SELF("moveSegment")](dx, dy) {
    this.pathGenerator.reselect();
    this.pathGenerator.moveSelectedSegment(dx, dy);
    this.renderPath();
    this.updatePathLayer();
  }
  recoverAreaToPath(d) {
    this.initRect(true);
    var parser = new PathParser(d);
    parser.scaleFunc(this.state.domainScaleInvert, this.state.rangeScaleInvert);
    return parser.d;
  }
  updatePathLayer() {
    var { d } = this.pathGenerator.toPath();
    const value = this.recoverAreaToPath(d);
    this.parent.trigger(this.props.onchange, this.state.key, value);
  }
  changeMode(mode, obj2) {
    this.setState(__spreadValues({
      mode,
      clickCount: 0,
      moveXY: null
    }, obj2), false);
    if (obj2 == null ? void 0 : obj2.points) {
      this.pathGenerator.setPoints(obj2.points || []);
    }
  }
  isMode(mode) {
    return this.state.mode === mode;
  }
  convertPathToArea(obj2) {
    this.initRect(true);
    const width2 = this.state.rect.width;
    const height2 = this.state.rect.height;
    this.state.domainScale = scaleLinear([0, 1], [0, width2]);
    this.state.rangeScale = scaleLinear([1, 0], [0, height2]);
    this.state.domainScaleInvert = scaleLinear([0, width2], [0, 1]);
    this.state.rangeScaleInvert = scaleLinear([0, height2], [1, 0]);
    this.pathParser.reset(obj2.d).scaleFunc(this.state.domainScale, this.state.rangeScale);
  }
  refreshEditorView(obj2) {
    this.convertPathToArea(obj2);
    this.pathGenerator.setPoints(this.pathParser.convertGenerator());
    this.renderPath();
  }
  afterRender() {
    const { mode, value } = this.props;
    const obj2 = { d: value };
    if (mode === "move") {
      obj2.current = null;
      obj2.points = [];
    }
    this.changeMode(mode, obj2);
    window.setTimeout(() => {
      this.refreshEditorView(obj2, true);
    }, 10);
  }
  [BIND("$view")]() {
    var _a;
    const path = this.pathGenerator.makeSVGPath();
    const strokeWidth = Length.parse((_a = this.state.current) == null ? void 0 : _a["stroke-width"]).value || 0;
    return {
      class: {
        path: this.state.mode === "path",
        modify: this.state.mode === "modify",
        transform: this.state.mode === "transform",
        "segment-move": this.state.mode === "segment-move",
        "is-control": this.state.isControl,
        "has-one-stroke-width": strokeWidth === 1
      },
      htmlDiff: path
    };
  }
  [BIND("$splitCircle")]() {
    if (this.state.splitXY) {
      return {
        cx: this.state.splitXY.x,
        cy: this.state.splitXY.y,
        r: 5
      };
    } else {
      return {
        r: 0
      };
    }
  }
  renderPath() {
    this.bindData("$view");
  }
  get checkDistance() {
    return false;
  }
  getPathRect() {
    this.initRect(true);
    const { d } = this.pathGenerator.toPath();
    return vertiesToRectangle(PathParser.fromSVGString(d).getBBox());
  }
  resetTransformZone() {
    var rect2 = this.getPathRect();
    this.state.transformZoneRect = rect2;
  }
  [POINTERMOVE("$view") + PREVENT](e) {
    this.initRect();
    if (this.isMode("path") && this.state.rect) {
      this.state.moveXY = {
        x: e.xy.x - this.state.rect.x,
        y: e.xy.y - this.state.rect.y
      };
      this.state.altKey = e.altKey;
      this.renderPath();
    } else {
      var $target = Dom.create(e.target);
      var isSplitPath = $target.hasClass("split-path");
      if (isSplitPath) {
        this.state.splitXY = this.calculatePointOnLine($target.attr("d"), {
          x: e.xy.x - this.state.rect.x,
          y: e.xy.y - this.state.rect.y
        });
      } else {
        this.state.splitXY = null;
      }
      this.bindData("$splitCircle");
      this.state.altKey = false;
    }
  }
  [POINTERSTART("$view :not(.split-path)") + PREVENT + STOP + MOVE() + END()](e) {
    this.initRect();
    this.state.altKey = false;
    var isPathMode = this.isMode("path");
    this.$config.set("set.move.control.point", true);
    this.state.dragXY = {
      x: e.xy.x - this.state.rect.x,
      y: e.xy.y - this.state.rect.y
    };
    var $target = Dom.create(e.target);
    this.$segmentTarget = $target;
    if ($target.hasClass("svg-editor-canvas") && !isPathMode)
      ;
    else {
      this.pathGenerator.reselect();
      this.state.isSegment = $target.attr("data-segment") === "true";
      this.state.isFirstSegment = this.state.isSegment && $target.attr("data-is-first") === "true";
      this.state.selectedGroupIndex = -1;
      this.state.selectedPointIndex = -1;
    }
    if (isPathMode) {
      if (this.state.isFirstSegment) {
        var index2 = +$target.attr("data-index");
        this.state.startPoint = this.pathGenerator.points[index2].startPoint;
      } else {
        this.state.startPoint = this.state.dragXY;
      }
      this.state.dragPoints = false;
      this.state.endPoint = null;
    } else {
      if (this.state.isSegment) {
        this.changeMode("segment-move");
        var [index2, segmentKey] = $target.attrs("data-index", "data-segment-point");
        const localIndex = +index2;
        this.pathGenerator.setCachePoint(localIndex, segmentKey);
        this.pathGenerator.selectKeyIndex(segmentKey, localIndex);
        this.state.segmentKey = segmentKey;
        this.renderPath();
      }
    }
  }
  move(dx, dy) {
    const e = this.$config.get("bodyEvent");
    if (this.state.segmentKey === "startPoint") {
      const newXY = {
        x: Math.max(0, Math.min(this.state.rect.width, e.xy.x - this.state.rect.x)),
        y: Math.max(0, Math.min(this.state.rect.height, e.xy.y - this.state.rect.y))
      };
      dx = newXY.x - this.state.dragXY.x;
      dy = newXY.y - this.state.dragXY.y;
    }
    if (this.isMode("segment-move")) {
      this.pathGenerator.move(dx, dy, e, this.state.rect.width, this.state.rect.height);
      this.renderPath();
      this.updatePathLayer();
    } else if (this.isMode("path")) {
      const dist2 = getDist(dx, dy, 0, 0);
      if (dist2 >= 2) {
        this.state.dragPoints = e.altKey ? false : true;
      }
    }
  }
  renderSegment(callback) {
    if (this.pathGenerator.selectedLength) {
      this.pathGenerator.reselect();
      if (isFunction(callback))
        callback();
      this.renderPath();
      this.updatePathLayer();
    }
  }
  end(dx, dy) {
    this.$config.set("set.move.control.point", false);
    if (this.isMode("modify")) {
      this.pathGenerator.reselect();
    } else if (this.isMode("segment-move")) {
      this.changeMode("modify");
      this.pathGenerator.reselect();
      this.renderPath();
      this.updatePathLayer();
    } else if (this.isMode("path")) {
      if (this.state.isFirstSegment) {
        this.changeMode("modify");
        this.pathGenerator.setConnectedPoint(dx, dy);
        this.renderPath();
        if (this.state.current) {
          this.updatePathLayer();
        }
      } else {
        if (this.state.isSplitPath)
          ;
        else {
          this.pathGenerator.moveEnd(dx, dy);
          this.state.clickCount++;
          this.renderPath();
          this.pathGenerator.reselect();
        }
      }
      this.state.isSplitPath = false;
    }
  }
}
var PathDataEditor$1 = "";
class PathDataEditor extends EditorElement {
  initState() {
    var parser = new PathParser(this.props.value || "");
    return {
      parser
    };
  }
  makeSegments() {
    return this.refs.$data.$$(".segment").map(($segment) => {
      var $command = $segment.$(".command");
      var command = $command.attr("data-command");
      if (command === "Z" && $command.attr("data-toggle") === "false") {
        return null;
      }
      var values = $segment.$$(".values input[type=number]").map((it) => {
        return +it.value;
      });
      return {
        command,
        values
      };
    }).filter((it) => it);
  }
  updateData() {
    var segments = this.makeSegments();
    this.state.parser.resetSegments(segments);
    this.modifyPathData();
  }
  modifyPathData() {
    this.parent.trigger(this.props.onchange, this.props.key, this.getValue(), this.props.params);
  }
  setValue(value) {
    this.setState({
      parser: new PathParser(value)
    });
  }
  getValue() {
    return this.state.parser.joinPath();
  }
  template() {
    return `
            <div class='elf--path-data-editor'>
                <div class='data' ref='$data'></div>
            </div>
        `;
  }
  [LOAD("$data")]() {
    var segments = [];
    this.state.parser.segments.forEach((it, index2) => {
      var s = __spreadValues({}, it);
      segments.push(s);
      var next = this.state.parser.segments[index2 + 1];
      if (next && next.command === "M") {
        if (s.command !== "Z") {
          segments.push({ command: "Z", toggle: false, values: [] });
        } else {
          s.toggle = true;
        }
      }
    });
    var last = this.state.parser.segments[this.state.parser.segments.length - 1];
    if (last && last.command !== "Z") {
      segments.push({ command: "Z", toggle: false, values: [] });
    }
    var arr = segments.map((it) => {
      var cls = it.command === "M" ? "m" : "";
      return `
                <div class='segment ${cls}'>
                    <div class='command' data-command='${it.command}' data-toggle="${it.toggle}" title='Toggle'>${it.command}</div>
                    <div class='values'>
                        ${it.values.map((v) => {
        return `<input type="number" value="${v}" />`;
      }).join("")}

                        ${it.command === "Z" ? it.toggle === false ? "opened" : "closed" : ""}
                    </div>
                </div>
            `;
    });
    arr.unshift(`
            <div class='segment-empty'>
                <div class='command'></div>
                <div class='values'>
                    <span>X</span>
                    <span>Y</span>
                </div>
            </div>
        `);
    return arr;
  }
  [INPUT("$data input[type=number]") + DEBOUNCE(300)]() {
    this.updateData();
  }
  [CLICK("$data .command[data-toggle]")](e) {
    var [command, toggle] = e.$dt.attrs("data-command", "data-toggle");
    if (command === "Z") {
      if (toggle !== "false") {
        toggle = "false";
      } else {
        toggle = "true";
      }
      e.$dt.attr("data-toggle", toggle);
      this.updateData();
    }
  }
}
var PolygonDataEditor$1 = "";
const splitReg = /[\b\t ,]/g;
class PolygonParser extends PathParser {
  constructor(points = "") {
    super(points);
  }
  reset(points = "") {
    this.segments = [];
    this.points = points;
    this.parse();
  }
  resetSegments(segments = []) {
    this.segments = segments;
    this.points = this.joinPoints();
  }
  parse() {
    var points = this.points;
    if (Array.isArray(points)) {
      points = points.join(" ");
    }
    var arr = points.trim().split(splitReg).filter((it) => it);
    var segments = [];
    for (var i = 0, len2 = arr.length; i < len2; i += 2) {
      segments.push({ x: +arr[i], y: +arr[i + 1] });
    }
    this.segments = segments;
  }
  convertGenerator() {
    return this.segments;
  }
  length() {
    return this.segments.length;
  }
  toPathString() {
    var path = new PathStringManager();
    for (var i = 0, len2 = this.segments.length; i < len2; i++) {
      var s = this.segments[i];
      if (i === 0) {
        path.M(s);
      } else if (i === len2 - 1) {
        path.L(s).L(this.segments[0]).Z();
      } else {
        path.L(s);
      }
    }
    return path.d;
  }
  joinPath(segments) {
    return this.joinPoints(segments);
  }
  joinPoints(segments) {
    var list2 = segments || this.segments;
    return list2.map((it) => {
      return `${it.x},${it.y}`;
    }).join(" ");
  }
  each(callback, isReturn = false) {
    var newSegments = this.segments.map((segment) => {
      return callback.call(this, segment);
    });
    if (isReturn) {
      return newSegments;
    } else {
      this.segments = newSegments;
    }
  }
  _loop(m, isReturn = false) {
    return this.each(function(segment) {
      var [x, y] = m([segment.x, segment.y], 0);
      segment.x = x;
      segment.y = y;
      return segment;
    }, isReturn);
  }
  clone() {
    return new PolygonParser(this.joinPoints());
  }
  toString() {
    return this.joinPoints();
  }
}
class PolygonDataEditor extends EditorElement {
  initState() {
    var parser = new PolygonParser(this.props.value || "");
    return {
      parser
    };
  }
  makeSegments() {
    return this.refs.$data.$$(".segment").map(($segment) => {
      var x = +$segment.$('[data-key="x"]').value;
      var y = +$segment.$('[data-key="y"]').value;
      return { x, y };
    });
  }
  updateData() {
    var segments = this.makeSegments();
    this.state.parser.resetSegments(segments);
    this.modifyPolygonData();
  }
  modifyPolygonData() {
    this.parent.trigger(this.props.onchange, this.props.key, this.getValue(), this.props.params);
  }
  setValue(value) {
    this.setState({
      parser: new PolygonParser(value || "")
    });
  }
  getValue() {
    return this.state.parser.joinPoints();
  }
  template() {
    return `
            <div class='elf--polygon-data-editor'>
                <div class='data' ref='$data'></div>
            </div>
        `;
  }
  [LOAD("$data")]() {
    return this.state.parser.segments.map((it) => {
      return `
                <div class='segment'>
                    <div class='values'>
                        <label>X <input type="number" data-key="x" value="${it.x}" /></label>
                        <label>Y <input type="number" data-key="y" value="${it.y}" /></label>
                    </div>
                </div>
            `;
    });
  }
  [INPUT("$data input[type=number]") + DEBOUNCE(300)]() {
    this.updateData();
  }
}
var SelectIconEditor$1 = "";
class SelectIconEditor extends EditorElement {
  initState() {
    var splitChar = this.props.split || ",";
    var options2 = Array.isArray(this.props.options) ? this.props.options.map((it) => {
      if (isString(it)) {
        return { value: it, text: it };
      }
      return it;
    }) : (this.props.options || "").split(splitChar).map((it) => it.trim()).map((it) => {
      const [value2, text2] = it.split(":");
      return { value: value2, text: text2 };
    });
    var icons = this.props.icons || [];
    var colors2 = this.props.colors || [];
    var value = this.props.value || "";
    return {
      label: this.props.label || "",
      compact: isBoolean(this.props.compact) ? this.props.compact : this.props.compact === "true",
      options: options2,
      icons,
      colors: colors2,
      value,
      height: this.props.height
    };
  }
  template() {
    var { label, compact, height: height2 } = this.state;
    var hasLabel = label ? "has-label" : "";
    var hasCompact = compact ? "compact" : "";
    var heightVar = height2 ? `--elf--input-height: ${height2}px;` : "";
    return `
            <div class='elf--select-icon-editor ${hasLabel}' style="${heightVar}">
                ${label ? `<label title="${label}">${label}</label>` : ""}
                <div class='items ${hasCompact}' ref='$options'></div>
            </div>
        `;
  }
  [CLICK("$close")]() {
    this.updateData({
      value: ""
    });
    this.refresh();
  }
  getValue() {
    return this.state.value || "";
  }
  setValue(value) {
    this.setState({
      value
    });
  }
  [LOAD("$options") + DOMDIFF]() {
    return this.state.options.map((it, index2) => {
      var value = it.value;
      var label = it.text;
      var title2 = it.text;
      var iconClass = "";
      var isSelected = value === this.state.value;
      var selected = isSelected ? "selected" : "";
      if (it.value === "") {
        var label = "";
        title2 = "close";
        if (isNotUndefined(this.state.icons[index2])) {
          iconClass = "icon";
          label = iconBlank();
          value = "__blank__";
        }
      } else {
        var iconKey = this.state.icons[index2];
        if (obj$3[iconKey]) {
          iconClass = "icon";
        }
        title2 = label;
        label = obj$3[iconKey] || label || iconKey || it.text || it.value;
      }
      var color2 = this.state.colors[index2];
      var css = {};
      if (isSelected && color2) {
        css["background-color"] = color2;
      }
      return `<div class='select-icon-item ${selected} ${iconClass}' 
          style='${CSS_TO_STRING(css)}' 
          data-value="${value}" 
          data-tooltip='${title2}'
      >${label}</div>`;
    });
  }
  [CLICK("$options .select-icon-item")](e) {
    var value = e.$dt.attr("data-value");
    if (!value || value === "__blank__")
      return;
    this.updateData({
      value
    });
    this.refresh();
  }
  updateData(data) {
    this.setState(data, false);
    this.parent.trigger(this.props.onchange, this.props.key, this.getValue(), this.props.params);
  }
}
var StrokeDashArrayEditor$1 = "";
const dash_list = [
  [10, 5],
  [5, 1],
  [1, 5],
  [0.9],
  [15, 10, 5],
  [15, 10, 5, 10],
  [15, 10, 5, 10, 15],
  [5, 5, 1, 5]
];
class StrokeDashArrayEditor extends EditorElement {
  initState() {
    var value = isArray(this.props.value) ? this.props.value : this.generateValue(this.props.value || "");
    return {
      label: this.props.label || "",
      value,
      count: 1
    };
  }
  template() {
    const { label } = this.state;
    const hasLabel = !!label;
    return `
      <div class='elf--stroke-dasharray-editor'>
        <div class='tools ${hasLabel ? "has-label" : ""}'>
          ${hasLabel ? `<label class='label'>${label}</label>` : ""}
          <div class="buttons">
            <label ref='$add'>${obj$3.add}</label>          
          </div>
        </div>      
        <div ref='$body' class='dash-list'></div>
        <div ref='$list' class='dash-sample-list'></div>
      </div>
    `;
  }
  [CLICK("$el .tools label")]() {
    this.refs.$list.toggle();
  }
  getValue() {
    return this.state.value;
  }
  generateValue(value) {
    return value.split(" ").filter(Boolean).map((it) => +it);
  }
  setValue(value) {
    if (!isArray(value)) {
      value = this.generateValue(value);
    }
    this.setState({
      value
    });
  }
  [LOAD("$list")]() {
    return dash_list.map((value, index2) => {
      return `
        <div class='dash-sample' data-index='${index2}'>
          <div class='dash-sample-value'>
            <svg width="100" height="2">
              <line x1="5" y1="0" x2="95" y2="0" stroke-dasharray="${value.join(",")}" stroke-width="2" stroke="black" />
            </svg>
          </div>
        </div>
      `;
    });
  }
  [LOAD("$body")]() {
    this.state.count++;
    return this.state.value.map((value, index2) => {
      var num = index2 + 1;
      return `
        <div class='dasharray-item'>
          ${createComponent("NumberInputEditor", {
        ref: `$dash-${this.state.count}-${num}`,
        compact: true,
        key: index2,
        value,
        min: 0,
        max: 100,
        step: 1,
        onchange: "changeRangeEditor"
      })}  
          <button type="button" data-index="${index2}" class='delete'>${iconUse("close")}</button>
        </div>
      `;
    });
  }
  [SUBSCRIBE_SELF("changeRangeEditor")](key, value) {
    var index2 = +key;
    this.state.value[index2] = value;
    this.modifyStrokeDashArray();
  }
  [CLICK("$list .dash-sample")](e) {
    const value = dash_list[+e.$dt.data("index")];
    this.setState({ value }, false);
    this.refresh();
    this.modifyStrokeDashArray();
    this.refs.$list.toggle();
  }
  [CLICK("$add")]() {
    this.setState({
      value: [...this.state.value, 0]
    }, false);
    this.refresh();
    this.modifyStrokeDashArray();
  }
  [CLICK("$body .delete")](e) {
    const index2 = +e.$dt.attr("data-index");
    this.state.value.splice(index2, 1);
    this.refresh();
    this.modifyStrokeDashArray();
  }
  modifyStrokeDashArray() {
    this.parent.trigger(this.props.onchange, this.props.key, this.getValue(), this.props.params);
  }
  [POINTERSTART("document")](e) {
    const $target = Dom.create(e.target);
    const parent = $target.closest("elf--stroke-dasharray-editor");
    if (!parent) {
      this.refs.$list.hide();
    }
  }
}
var TextAreaEditor$1 = "";
class TextAreaEditor extends EditorElement {
  initState() {
    var value = this.props.value;
    return {
      label: this.props.label || "",
      height: 100,
      value
    };
  }
  template() {
    var { label, height: height2, value } = this.state;
    var hasLabel = label ? "has-label" : "";
    return `
            <div class='elf--text-area-editor ${hasLabel}'>
                ${label ? `<label>${label}</label>` : ""}
                <textarea ref='$text' style='height:${height2}'>${value}</textarea>
            </div>
        `;
  }
  getValue() {
    return this.refs.$options.value;
  }
  setValue(value, height2) {
    this.setState({ value }, false);
    if (height2) {
      this.setState({ height: height2 }, false);
    }
    this.refresh();
  }
  [BIND("$text")]() {
    return {
      text: this.state.value || "",
      style: {
        height: this.state.height
      }
    };
  }
  [INPUT("$text")]() {
    this.updateData({
      value: this.refs.$text.value
    });
  }
  updateData(data) {
    this.setState(data);
    this.parent.trigger(this.props.onchange, this.props.key, this.state.value, this.props.params);
  }
}
var TextEditor$1 = "";
class TextEditor extends EditorElement {
  initState() {
    var value = this.props.value;
    return {
      label: this.props.label || "",
      value
    };
  }
  template() {
    var { label, value } = this.state;
    var hasLabel = label ? "has-label" : "";
    return `
            <div class='elf--text-editor ${hasLabel}'>
                ${label ? `<label>${label}</label>` : ""}
                <div>
                    <input type='text' ref='$text' value="${value}" />
                </div>
            </div>
        `;
  }
  getValue() {
    return this.refs.$text.value;
  }
  setValue(value) {
    this.refs.$text.val(value);
    this.setState({
      value
    }, false);
  }
  [BIND("$text")]() {
    return {
      value: this.state.value
    };
  }
  [INPUT("$text")]() {
    this.updateData({
      value: this.refs.$text.value
    });
  }
  updateData(data) {
    this.setState(data, false);
    this.parent.trigger(this.props.onchange, this.props.key, this.getValue(), this.props.params);
  }
}
var TextShadowEditor$1 = "";
class TextShadow extends PropertyItem {
  static parse(obj2) {
    return new TextShadow(obj2);
  }
  static parseStyle(str = "") {
    var results = convertMatches(str);
    str = str.trim();
    var textShadows = results.str.split(",").filter((it) => it.trim()).map((shadow2) => {
      var values = shadow2.trim().split(" ");
      var colors2 = values.filter((it) => it.includes("@")).map((it) => {
        return reverseMatches(it, results.matches) || "black";
      });
      var numbers = values.filter((it) => {
        return !it.includes("@");
      });
      return TextShadow.parse({
        color: colors2[0] || "rgba(0, 0, 0, 1)",
        offsetX: Length.parse(numbers[0] || "0px"),
        offsetY: Length.parse(numbers[1] || "0px"),
        blurRadius: Length.parse(numbers[2] || "0px")
      });
    });
    return textShadows;
  }
  static join(list2) {
    return list2.map((it) => TextShadow.parse(it)).join(", ");
  }
  getDefaultObject() {
    return super.getDefaultObject({
      itemType: "text-shadow",
      offsetX: "0px",
      offsetY: "0px",
      blurRadius: "0px",
      color: "rgba(0, 0, 0, 1)"
    });
  }
  toCloneObject() {
    return __spreadValues(__spreadValues({}, super.toCloneObject()), this.attrs("offsetX", "offsetY", "blurRadius", "color"));
  }
  convert(json) {
    json = super.convert(json);
    if (isNumber(json.offsetX))
      json.offsetX = Length.px(json.offsetX);
    else if (json.offsetX)
      json.offsetX = Length.parse(json.offsetX);
    if (isNumber(json.offsetY))
      json.offsetY = Length.px(json.offsetY);
    else if (json.offsetY)
      json.offsetY = Length.parse(json.offsetY);
    if (isNumber(json.blurRadius))
      json.blurRadius = Length.px(json.blurRadius);
    else if (json.blurRadius)
      json.blurRadius = Length.parse(json.blurRadius);
    return json;
  }
  toCSS() {
    return {
      "text-shadow": this.toString()
    };
  }
  toString() {
    var { offsetX, offsetY, blurRadius, color: color2 } = this.json;
    if (isNumber(offsetX))
      offsetX = Length.px(offsetX);
    if (isNumber(offsetY))
      offsetY = Length.px(offsetY);
    if (isNumber(blurRadius))
      blurRadius = Length.px(blurRadius);
    return `${offsetX} ${offsetY} ${blurRadius} ${color2}`;
  }
}
class TextShadowEditor extends EditorElement {
  initState() {
    return {
      textShadows: TextShadow.parseStyle(this.props.value)
    };
  }
  template() {
    return `
      <div class="elf--text-shadow-editor" >
        <div class='text-shadow-list' ref='$shadowList'></div>
      </div>
    `;
  }
  [LOAD("$shadowList")]() {
    var arr = this.state.textShadows.map((shadow2, index2) => {
      return `
        <div class="shadow-item real" data-index="${index2}">
          <label draggable="true" data-index="${index2}">${iconUse("drag_indicator")}</label>
          ${createComponent("ColorViewEditor", {
        mini: true,
        key: "color",
        value: shadow2.color,
        params: index2,
        onchange: "changeKeyValue"
      })}
          ${createComponent("NumberInputEditor", {
        mini: true,
        key: "offsetX",
        label: "X",
        value: shadow2.offsetX,
        params: index2,
        onchange: "changeKeyValue"
      })}          
          ${createComponent("NumberInputEditor", {
        mini: true,
        key: "offsetY",
        label: "Y",
        value: shadow2.offsetY,
        params: index2,
        onchange: "changeKeyValue"
      })}                    
          ${createComponent("NumberInputEditor", {
        mini: true,
        label: "B",
        key: "blurRadius",
        value: shadow2.blurRadius,
        params: index2,
        onchange: "changeKeyValue"
      })}                    
          <div class="tools">
            <button type="button" class="remove" data-index="${index2}">
              ${iconUse("remove2")}
            </button>
          </div>
        </div>
      `;
    });
    return arr.join("");
  }
  modifyTextShadow() {
    var value = this.state.textShadows.join(", ");
    this.parent.trigger(this.props.onchange, this.props.key, value);
  }
  [SUBSCRIBE("add")](shadow2 = "") {
    if (shadow2) {
      this.state.textShadows = TextShadow.parseStyle(shadow2);
    } else {
      this.state.textShadows.push(new TextShadow());
    }
    this.refresh();
    this.modifyTextShadow();
  }
  [CLICK("$add")]() {
    this.trigger("add");
  }
  [DRAGSTART("$shadowList .shadow-item > label")](e) {
    this.startIndex = +e.$dt.attr("data-index");
  }
  [DRAGOVER("$shadowList .shadow-item") + PREVENT]() {
  }
  sortItem(arr, startIndex, targetIndex) {
    arr.splice(targetIndex + (startIndex < targetIndex ? -1 : 0), 0, ...arr.splice(startIndex, 1));
  }
  sortTextShadow(startIndex, targetIndex) {
    this.sortItem(this.state.textShadows, startIndex, targetIndex);
  }
  [DROP("$shadowList .shadow-item") + PREVENT](e) {
    var targetIndex = +e.$dt.attr("data-index");
    this.sortTextShadow(this.startIndex, targetIndex);
    this.refresh();
    this.modifyTextShadow();
  }
  [CLICK("$shadowList .remove")](e) {
    var index2 = +e.$dt.attr("data-index");
    this.state.textShadows.splice(index2, 1);
    this.refresh();
    this.modifyTextShadow();
  }
  [SUBSCRIBE_SELF("changeKeyValue")](key, value, index2) {
    var shadow2 = this.state.textShadows[index2];
    shadow2.reset({
      [key]: value
    });
    this.modifyTextShadow();
  }
}
var VarEditor$1 = "";
class VarEditor extends EditorElement {
  initState() {
    var values = this.props.value.split(";").filter((it) => it.trim()).map((it) => {
      let [key, value] = it.split(":");
      key = key.replace("--", "");
      return { key, value };
    });
    return {
      hideLabel: this.props.hideLabel == "true" ? true : false,
      params: this.props.params || "",
      values
    };
  }
  template() {
    var labelClass = this.state.hideLabel ? "hide" : "";
    return `
        <div class='elf--var-editor var-list'>
            <div class='label ${labelClass}' >
                <label>${this.props.title || ""}</label>
                <div class='tools'>
                    <button type="button" ref="$add" title="add Var">${obj$3.add}</button>
                </div>
            </div>
            <div class='var-list' ref='$varList'></div>
        </div>`;
  }
  [SUBSCRIBE("add")]() {
    this.state.values.push({
      key: "",
      value: ""
    });
    this.refresh();
    this.updateData();
  }
  [CLICK("$add")]() {
    this.trigger("add");
  }
  [LOAD("$varList")]() {
    return this.state.values.map((it, index2) => {
      return `
                <div class='var-item' >
                    <div>
                        <input type="text" data-type="key" value="${it.key}" data-index="${index2}"  placeholder="variable" />
                    </div>
                    <div>
                        <input type="text" data-type="value" value="${it.value}" data-index="${index2}"  placeholder="value" />
                    </div>
                    <div class="tools">
                        <button type="button" class="del" data-index="${index2}">
                        ${obj$3.remove2}
                        </button>
                    </div>
                </div>
            `;
    });
  }
  [CLICK("$varList .del")](e) {
    var index2 = +e.$dt.attr("data-index");
    this.state.values.splice(index2, 1);
    this.refresh();
    this.updateData();
  }
  [INPUT("$varList input")](e) {
    var index2 = +e.$dt.attr("data-index");
    var type = e.$dt.attr("data-type");
    this.state.values[index2][type] = e.$dt.value;
    this.updateData();
  }
  updateData() {
    var value = this.state.values.map((it) => {
      return `${it.key}:${it.value}`;
    }).join(";");
    this.parent.trigger(this.props.onchange, value, this.props.params);
  }
}
var propertyEditor$1 = {
  BlendSelectEditor,
  BoxShadowEditor,
  ColorAssetsEditor,
  ColorSingleEditor,
  ColorViewEditor,
  ComponentEditor,
  CSSPropertyEditor,
  CubicBezierEditor,
  DirectionEditor,
  FilterEditor,
  FontSelectEditor,
  GradientEditor,
  IconListViewEditor,
  InputArrayEditor,
  InputRangeEditor,
  IterationCountEditor,
  MediaProgressEditor,
  NumberInputEditor,
  NumberRangeEditor,
  PathEditor,
  PathDataEditor,
  PolygonDataEditor,
  RangeEditor,
  SelectEditor,
  SelectIconEditor,
  StrokeDashArrayEditor,
  TextAreaEditor,
  TextEditor,
  TextShadowEditor,
  VarEditor
};
function propertyEditor(editor) {
  editor.registerElement(propertyEditor$1);
  editor.registerAlias({
    "icon-list-view": "IconListViewEditor",
    "box-shadow": "BoxShadowEditor",
    "text-shadow": "TextShadowEditor",
    component: "ComponentEditor",
    "text-area": "TextAreaEditor",
    text: "TextEditor",
    "color-single": "ColorSingleEditor",
    "cubic-bezier": "CubicBezierEditor",
    path: "PathEditor",
    "clip-path": "ClipPathEditor",
    "color-view": "ColorViewEditor",
    var: "VarEditor",
    "path-data": "PathDataEditor",
    "polygon-data": "PolygonDataEditor",
    "input-array": "InputArrayEditor",
    "stroke-dash-array": "StrokeDashArrayEditor",
    "number-input": "NumberInputEditor",
    "number-range": "NumberRangeEditor",
    "media-progress": "MediaProgressEditor",
    "select-icon": "SelectIconEditor",
    "css-property": "CSSPropertyEditor",
    direction: "DirectionEditor",
    "iteration-count": "IterationCountEditor",
    gradient: "GradientEditor",
    filter: "FilterEditor",
    select: "SelectEditor",
    "blend-select": "BlendSelectEditor",
    range: "RangeEditor",
    "input-range": "InputRangeEditor",
    "color-assets": "ColorAssetsEditor",
    "font-select": "FontSelectEditor"
  });
}
var blankEditorPlugins = [
  defaultConfigs,
  defaultIcons,
  defaultMessages,
  baseEditor,
  propertyEditor
];
var Console$1 = {
  command: "Console",
  description: "do console.log()",
  execute: (editor, ...args2) => {
    console.log(...args2);
  }
};
var __glob_0_0$4 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": Console$1
}, Symbol.toStringTag, { value: "Module" }));
var history_redo$1 = {
  command: "history.redo",
  execute: function(editor) {
    editor.context.history.redo();
  }
};
var __glob_0_1$4 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": history_redo$1
}, Symbol.toStringTag, { value: "Module" }));
var history_undo$1 = {
  command: "history.undo",
  execute: function(editor) {
    editor.context.history.undo();
  }
};
var __glob_0_2$3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": history_undo$1
}, Symbol.toStringTag, { value: "Module" }));
var keymap_keydown$1 = {
  command: "keymap.keydown",
  execute: function(editor, e) {
    editor.context.keyboardManager.add(e.code, e.keyCode, e);
    if (editor.context.shortcuts) {
      editor.context.shortcuts.execute(e, "keydown");
    }
  }
};
var __glob_0_3$3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": keymap_keydown$1
}, Symbol.toStringTag, { value: "Module" }));
var keymap_keyup = {
  command: "keymap.keyup",
  execute: function(editor, e) {
    editor.context.keyboardManager.remove(e.key, e.keyCode);
    if (editor.context.shortcuts) {
      editor.context.shortcuts.execute(e, "keyup");
    }
  }
};
var __glob_0_4$3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": keymap_keyup
}, Symbol.toStringTag, { value: "Module" }));
var moveToCenter = {
  command: "moveToCenter",
  description: "Move Layer to Center on Viewport",
  execute: function(editor, areaVerties, withScale = false) {
    if (areaVerties) {
      editor.context.viewport.moveToCenter(areaVerties, withScale ? -0.2 : 0, withScale);
    }
  }
};
var __glob_0_5$3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": moveToCenter
}, Symbol.toStringTag, { value: "Module" }));
var pop_mode_view = {
  command: "pop.mode.view",
  execute: function(editor, modeView = void 0) {
    editor.context.modeViewManager.popMode(modeView);
  }
};
var __glob_0_6$3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": pop_mode_view
}, Symbol.toStringTag, { value: "Module" }));
var push_mode_view = {
  command: "push.mode.view",
  execute: function(editor, modeView = ViewModeType.CanvasView) {
    editor.context.modeViewManager.pushMode(modeView);
    editor.emit("updateModeView");
  }
};
var __glob_0_7$3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": push_mode_view
}, Symbol.toStringTag, { value: "Module" }));
var recoverCursor = {
  command: "recoverCursor",
  execute: function(editor) {
    editor.context.config.set("editor.cursor", "auto");
    editor.context.config.set("editor.cursor.args", []);
  }
};
var __glob_0_8$3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": recoverCursor
}, Symbol.toStringTag, { value: "Module" }));
var refreshCursor = {
  command: "refreshCursor",
  execute: function(editor, iconType, ...args2) {
    editor.context.config.set("editor.cursor", iconType);
    editor.context.config.set("editor.cursor.args", args2);
  }
};
var __glob_0_9$3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": refreshCursor
}, Symbol.toStringTag, { value: "Module" }));
var setLocale = {
  command: "setLocale",
  execute: function(editor, locale) {
    editor.setLocale(locale);
    editor.emit("changed.locale");
  }
};
var __glob_0_10$3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": setLocale
}, Symbol.toStringTag, { value: "Module" }));
var toggle_tool_hand = {
  command: "toggleToolHand",
  execute: function(editor) {
    editor.context.config.toggle("set.tool.hand");
  }
};
var __glob_0_11$3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": toggle_tool_hand
}, Symbol.toStringTag, { value: "Module" }));
var zoom_default$1 = {
  command: "zoom.default",
  execute: function(editor) {
    editor.context.viewport.zoomDefault();
  }
};
var __glob_0_12$3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": zoom_default$1
}, Symbol.toStringTag, { value: "Module" }));
var zoom_in$1 = {
  command: "zoom.in",
  execute: function(editor) {
    editor.context.viewport.zoomIn(0.02);
  }
};
var __glob_0_13$3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": zoom_in$1
}, Symbol.toStringTag, { value: "Module" }));
var zoom_out$1 = {
  command: "zoom.out",
  execute: function(editor) {
    editor.context.viewport.zoomOut(0.02);
  }
};
var __glob_0_14$3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": zoom_out$1
}, Symbol.toStringTag, { value: "Module" }));
const modules$4 = { "./command_list/Console.js": __glob_0_0$4, "./command_list/history.redo.js": __glob_0_1$4, "./command_list/history.undo.js": __glob_0_2$3, "./command_list/keymap.keydown.js": __glob_0_3$3, "./command_list/keymap.keyup.js": __glob_0_4$3, "./command_list/moveToCenter.js": __glob_0_5$3, "./command_list/pop.mode.view.js": __glob_0_6$3, "./command_list/push.mode.view.js": __glob_0_7$3, "./command_list/recoverCursor.js": __glob_0_8$3, "./command_list/refreshCursor.js": __glob_0_9$3, "./command_list/setLocale.js": __glob_0_10$3, "./command_list/toggle.tool.hand.js": __glob_0_11$3, "./command_list/zoom.default.js": __glob_0_12$3, "./command_list/zoom.in.js": __glob_0_13$3, "./command_list/zoom.out.js": __glob_0_14$3 };
const obj$2 = {};
Object.entries(modules$4).forEach(([key, value]) => {
  key = key.replace("./command_list/", "").replace(".js", "");
  obj$2[key] = value.default;
});
class AssetParser {
  static parse(datauri, enableParselocal = false) {
    var [, data] = datauri.split("data:");
    var [mediaType, ...content2] = data.split(",");
    var [mimeType, encoding] = mediaType.split(";");
    content2 = content2.join(",");
    return {
      mimeType,
      local: enableParselocal && AssetParser.getLink(mimeType, encoding, content2)
    };
  }
  static getLink(mimeType, encoding, content2) {
    if (encoding === "base64") {
      var binary = window.atob(content2);
      var len2 = binary.length;
      var unit8Array = new window.Uint8Array(len2);
      for (var i = 0; i < len2; i++) {
        unit8Array[i] = binary.charCodeAt(i);
      }
      var blob = new window.Blob([unit8Array], { type: mimeType });
      return window.URL.createObjectURL(blob);
    }
    return "";
  }
}
class AssetManager {
  constructor(editor) {
    this.$editor = editor;
  }
  get project() {
    return this.$editor.context.selection.currentProject;
  }
  revokeResource(value) {
    var json = JSON.parse(value || "[]");
    var assets = {};
    json.forEach((project2) => {
      project2.images.forEach((it) => {
        assets[`#${it.id}`] = it;
      });
    });
    Object.keys(assets).map((idString) => {
      var a = assets[idString];
      var info = AssetParser.parse(a.original, true);
      a.local = info.local;
    });
    json.forEach((project2) => {
      project2.layers = this.applyAsset(project2.layers, assets);
    });
    return json;
  }
  applyAsset(json, assets) {
    if (Array.isArray(json)) {
      json = json.map((it) => this.applyAsset(it, assets));
    } else if (isObject(json)) {
      Object.keys(json).forEach((key) => {
        json[key] = this.applyAsset(json[key], assets);
      });
    } else if (isString(json)) {
      Object.keys(assets).forEach((idString) => {
        var a = assets[idString];
        if (json.indexOf(`#${a.id}`) > -1) {
          json = json.replace(new RegExp(`#${a.id}`, "g"), a.local);
        }
      });
    }
    return json;
  }
}
class CommandMaker {
  constructor(editor) {
    this.editor = editor;
    this.commands = [];
  }
  log() {
    console.log(this.commands);
  }
  emit(...args2) {
    this.commands.push(args2);
  }
  run() {
    this.editor.emit(this.commands);
  }
  add(otherCommandMaker) {
    this.commands = this.commands.concat(otherCommandMaker.commands);
  }
}
class CommandManager {
  constructor(editor) {
    this.$editor = editor;
    this.promiseProxy = this.localCommands = {};
    this.loadCommands();
    return new Proxy(this, {
      get: (target, key) => {
        var originMethod = target[key];
        if (isFunction(originMethod)) {
          return (...args2) => {
            return originMethod.apply(target, args2);
          };
        } else {
          return this.makePromiseEvent(key);
        }
      }
    });
  }
  loadCommands(userCommands = {}) {
    Object.keys(userCommands).forEach((command) => {
      if (isFunction(userCommands[command])) {
        this.registerCommand(command, userCommands[command]);
      } else {
        this.registerCommand(userCommands[command]);
      }
    });
  }
  registerCommand(command, commandCallback) {
    if (this.localCommands[command]) {
      throw new Error(`command ${command} is already registered`);
    }
    if (arguments.length === 2) {
      const callback = (...args2) => {
        const result = commandCallback.call(this, this.$editor, ...args2);
        this.$editor.debug("command execute", this, ...args2);
        return result;
      };
      callback.source = command;
      this.localCommands[command] = callback;
    } else if (isObject(command)) {
      const callback = (...args2) => {
        const result = command.execute.call(command, this.$editor, ...args2);
        this.$editor.debug("command execute", command, ...args2);
        return result;
      };
      callback.source = command.command;
      this.localCommands[command.command] = callback;
    }
  }
  getCallback(command) {
    return this.localCommands[command];
  }
  makePromiseEvent(command) {
    const callback = this.getCallback(command);
    if (callback) {
      return (...args2) => new Promise((resolve) => {
        resolve(callback(...args2));
      });
    }
  }
  executeCommand(command, description, ...args2) {
    if (this.$editor.context.stateManager.isPointerUp) {
      command = `history.${command}`;
      const callback = this.getCallback(command);
      return callback(description, ...args2);
    } else {
      return this.emit(command, ...args2);
    }
  }
  emit(command, ...args2) {
    const callback = this.getCallback(command);
    if (callback) {
      return callback(...args2);
    }
  }
}
class ComponentManager {
  constructor(editor) {
    this.editor = editor;
    this.components = {};
    this.inspectors = {};
  }
  registerComponent(name, componentProperty) {
    this.components[name] = componentProperty;
  }
  registerInspector(name, inspectorCallback) {
    this.inspectors[name] = inspectorCallback;
  }
  getComponentClass(name) {
    return this.components[name] || this.components["rect"];
  }
  getInspector(name) {
    return this.inspectors[name];
  }
  createComponent(itemType, obj2 = {}) {
    var ComponentClass = this.getComponentClass(itemType);
    if (!ComponentClass) {
      throw new Error(`${itemType} type is not valid.`);
    }
    return new ComponentClass(obj2);
  }
  createInspector(item, name = "") {
    const inspector = this.getInspector(name || item.itemType);
    if (isFunction(inspector)) {
      return inspector(item) || [];
    }
    if (isFunction(item.getProps)) {
      return item.getProps() || [];
    }
    return [];
  }
}
class ConfigManager {
  constructor(editor) {
    this.editor = editor;
    this.configList = [];
    this.config = /* @__PURE__ */ new Map();
  }
  load() {
    const obj2 = this.editor.loadItem("config") || {};
    Object.keys(obj2).forEach((key) => {
      this.config.set(key, obj2[key]);
    });
  }
  get(key) {
    var _a;
    if (this.config.has(key) === false) {
      this.config.set(key, (_a = this.configList.find((it) => it.key == key)) == null ? void 0 : _a.defaultValue);
    }
    return this.config.get(key);
  }
  set(key, value, isSave = true) {
    const oldValue = this.config.get(key);
    if (oldValue !== value) {
      this.config.set(key, value);
      this.editor.emit("config:" + key, value, oldValue);
      if (isSave) {
        this.save();
      }
    }
  }
  push(key, value) {
    const list2 = this.get(key);
    const lastIndex = list2.length;
    this.setIndexValue(key, lastIndex, value);
    return lastIndex;
  }
  setIndexValue(key, index2, value) {
    const list2 = this.get(key);
    list2[index2] = value;
    this.set(key, [...list2]);
  }
  getIndexValue(key, index2) {
    const list2 = this.get(key);
    return list2[index2];
  }
  removeByIndex(key, index2) {
    const list2 = this.get(key);
    list2.splice(index2, 1);
    this.set(key, [...list2]);
  }
  init(key, value) {
    this.set(key, value, false);
  }
  save() {
    const obj2 = {};
    this.configList.filter((it) => it.storage !== "none").forEach((it) => {
      obj2[it.key] = this.get(it.key);
    });
    this.editor.saveItem("config", obj2);
  }
  setAll(obj2) {
    Object.keys(obj2).forEach((key) => {
      this.set(key, obj2[key]);
    });
  }
  getType(key) {
    var _a;
    return (_a = this.configList.find((it) => it.key == key)) == null ? void 0 : _a.type;
  }
  isType(key, type) {
    return this.getType(key) === type;
  }
  isBoolean(key) {
    return this.isType(key, "boolean");
  }
  toggle(key) {
    this.set(key, !this.get(key));
  }
  true(key) {
    return this.get(key) === true;
  }
  false(key) {
    return this.get(key) === false;
  }
  is(key, value) {
    return this.get(key) === value;
  }
  remove(key) {
    this.config.delete(key);
    this.editor.emit("config:" + key);
  }
  registerConfig(config) {
    this.config.set(config.key, config.defaultValue);
    this.configList.push(config);
  }
}
class CursorManager {
  async load(iconName = "default", ...args2) {
    if (obj$3[iconName]) {
      const iconContent = isFunction(obj$3[iconName]) ? obj$3[iconName].call(obj$3[iconName], ...args2) : obj$3[iconName];
      const blob = new window.Blob([iconContent], { type: "image/svg+xml" });
      return new Promise((resolve) => {
        const reader = new window.FileReader();
        reader.onload = (e) => {
          const datauri = e.target.result;
          resolve(`url(${datauri}) 12 12, auto`);
        };
        reader.readAsDataURL(blob);
      });
    } else {
      return iconName;
    }
  }
}
class I18nManager {
  constructor(editor) {
    this.editor = editor;
    this.locales = {};
    this.fallbackLang = "en_US";
  }
  getLang(lang = void 0) {
    return lang || this.fallbackLang;
  }
  setFallbackLang(lang) {
    this.fallbackLang = lang;
  }
  get(key, params = {}, lang = void 0) {
    var _a, _b;
    const currentLang = this.getLang(lang);
    const str = ((_a = this.locales[currentLang]) == null ? void 0 : _a[key]) || ((_b = this.locales[this.fallbackLang]) == null ? void 0 : _b[key]) || key || void 0;
    if (isFunction(str)) {
      return str(params);
    } else {
      let newValue = str;
      if (key === newValue) {
        return key.split(".").pop();
      }
      Object.entries(params).forEach(([key2, value]) => {
        newValue = newValue.replace(new RegExp(`{${key2}}`, "ig"), value);
      });
      return newValue;
    }
  }
  hasKey(key, lang = void 0) {
    const currentLang = this.getLang(lang);
    return !!(this.locales[currentLang][key] || this.locales[this.fallbackLang][key]);
  }
  registerI18nMessage(lang, messages) {
    if (!this.locales[lang]) {
      this.locales[lang] = {};
    }
    Object.assign(this.locales[lang], messages);
  }
}
class IconManager$1 {
  constructor(editor) {
    this.editor = editor;
    this.iconMap = {};
  }
  get(itemType, item) {
    const icon = this.iconMap[itemType];
    if (isFunction(icon)) {
      return icon(item);
    }
    return iconUse(icon || item.getIcon() || "rect");
  }
  set(itemType, value) {
    this.iconMap[itemType] = value;
  }
  registerIcon(itemType, iconOrFunction) {
    this.set(itemType, iconOrFunction);
  }
}
class InjectManager {
  constructor(editor) {
    this.editor = editor;
    this.ui = {};
  }
  registerUI(target, obj2 = {}, order = 1) {
    if (!this.ui[target]) {
      this.ui[target] = [];
    }
    Object.keys(obj2).forEach((refClass) => {
      const targetClass = this.ui[target].find((it) => it.refClass === refClass);
      if (targetClass) {
        targetClass.class = obj2[refClass];
      } else {
        this.ui[target].push({
          refClass,
          order,
          class: obj2[refClass]
        });
      }
    });
  }
  getTargetUI(target) {
    return this.ui[target] || [];
  }
  generate(target, hasRef = false) {
    const list2 = this.getTargetUI(target);
    list2.sort((a, b) => {
      if (a.order === b.order)
        return 0;
      return a.order > b.order ? 1 : -1;
    });
    return list2.map((it, index2) => {
      if (isArray(it.class)) {
        return createElementJsx(...it.class);
      } else {
        const props = {};
        if (hasRef) {
          props.ref = `$${it.refClass}-${index2}`;
        }
        return createComponent(it.refClass, props);
      }
    }).join("\n");
  }
}
class KeyBoardManager {
  constructor(editor) {
    this.editor = editor;
    this.codeSet = /* @__PURE__ */ new Set();
    this.keyCodeSet = /* @__PURE__ */ new Set();
    this.event = {};
  }
  add(key, keyCode, e) {
    if (this.codeSet.has(key) === false) {
      this.codeSet.add(key);
    }
    if (this.keyCodeSet.has(keyCode) === false) {
      this.keyCodeSet.add(keyCode);
    }
    this.event = e;
  }
  remove(key, keyCode) {
    this.codeSet.delete(key);
    this.keyCodeSet.delete(keyCode);
  }
  hasKey(keyOrKeyCode) {
    return this.codeSet.has(keyOrKeyCode) || this.keyCodeSet.has(keyOrKeyCode);
  }
  check(...args2) {
    return args2.some((keyOrKeyCode) => this.hasKey(keyOrKeyCode));
  }
  isShift() {
    return Boolean(this.event.shiftKey);
  }
  isCtrl() {
    return Boolean(this.event.ctrlKey);
  }
  isAlt() {
    return Boolean(this.event.altKey);
  }
  isMeta() {
    return Boolean(this.event.metaKey);
  }
}
class MenuManager {
  constructor(editor) {
    this.editor = editor;
    this.menus = {};
  }
  registerMenu(target, obj2 = [], order = 1) {
    if (!this.menus[target]) {
      this.menus[target] = [];
    }
    if (!isArray(obj2)) {
      obj2 = [obj2];
    }
    obj2.forEach((it) => {
      this.menus[target].push(it);
    });
    this.editor.emit("updateMenu", target);
  }
  getTargetMenu(target) {
    return this.menus[target] || [];
  }
}
class ModeViewManager {
  constructor(editor) {
    this.editor = editor;
    this.modes = [ViewModeType.CanvasView];
  }
  pushMode(mode) {
    if (!this.isCurrentMode(mode)) {
      this.modes.push(mode);
    }
  }
  popMode(mode = void 0) {
    if (mode) {
      if (this.isCurrentMode(mode)) {
        this.modes.pop();
      }
    } else {
      this.modes.pop();
    }
  }
  currentMode() {
    return this.modes[this.modes.length - 1];
  }
  isCurrentMode(mode) {
    return this.currentMode() === mode;
  }
}
class PluginManager {
  constructor(editor) {
    this.editor = editor;
    this.plugins = [];
  }
  registerPlugin(func) {
    this.plugins.push(func);
  }
  async initializePlugin(options2 = {}) {
    return await Promise.all(this.plugins.map(async (CreatePluginFunction) => {
      return await CreatePluginFunction(this.editor, options2);
    }));
  }
}
class RendererManager {
  constructor(editor) {
    this.editor = editor;
    this.renderers = {};
    this.rendererTypes = {};
  }
  getRenderType(rendererType) {
    if (!this.renderers[rendererType]) {
      this.renderers[rendererType] = {};
    }
    return this.renderers[rendererType];
  }
  registerRenderer(rendererType, name, rendererInstance) {
    const typedRenderer = this.getRenderType(rendererType);
    typedRenderer[name] = rendererInstance;
  }
  registerRendererType(rendererType, rendererTypeInstance) {
    this.rendererTypes[rendererType] = rendererTypeInstance;
  }
  getRenderer(rendererType) {
    return this.rendererTypes[rendererType];
  }
  getRendererInstance(rendererType, name) {
    const typedRenderer = this.getRenderType(rendererType);
    return typedRenderer[name];
  }
}
var add_artboard = {
  category: "Tool",
  key: "a",
  command: "addLayerView",
  args: ["artboard"],
  description: "Add ArtBoard",
  when: "CanvasView"
};
var __glob_0_0$3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": add_artboard
}, Symbol.toStringTag, { value: "Module" }));
var add_brush = {
  category: "Tool",
  key: "b",
  command: "addLayerView",
  args: ["brush"],
  description: "Draw SVG Path",
  when: "CanvasView"
};
var __glob_0_1$3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": add_brush
}, Symbol.toStringTag, { value: "Module" }));
var add_circle = {
  category: "Tool",
  key: "o",
  command: "addLayerView",
  args: ["circle"],
  description: "Add circle layer",
  when: "CanvasView"
};
var __glob_0_2$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": add_circle
}, Symbol.toStringTag, { value: "Module" }));
var add_circle_l = {
  category: "Tool",
  key: "l",
  command: "addLayerView",
  args: ["circle"],
  description: "Add circle layer",
  when: "CanvasView"
};
var __glob_0_3$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": add_circle_l
}, Symbol.toStringTag, { value: "Module" }));
var add_path = {
  category: "Tool",
  key: "p",
  command: "addLayerView",
  args: ["path"],
  description: "Add SVG Path layer",
  when: "CanvasView"
};
var __glob_0_4$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": add_path
}, Symbol.toStringTag, { value: "Module" }));
var add_rect = {
  category: "Tool",
  key: "r",
  command: "addLayerView",
  args: [
    "rect",
    {
      backgroundColor: "gray"
    }
  ],
  description: "Add rect layer",
  when: "CanvasView"
};
var __glob_0_5$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": add_rect
}, Symbol.toStringTag, { value: "Module" }));
var add_rect_m = {
  category: "Tool",
  key: "m",
  command: "addLayerView",
  args: ["rect"],
  description: "Add rect layer",
  when: "CanvasView"
};
var __glob_0_6$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": add_rect_m
}, Symbol.toStringTag, { value: "Module" }));
var add_text = {
  category: "Tool",
  key: "t",
  command: "addLayerView",
  args: ["text"],
  description: "Add text layer",
  when: "CanvasView"
};
var __glob_0_7$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": add_text
}, Symbol.toStringTag, { value: "Module" }));
var clipboard_copy$1 = {
  category: "Edit",
  key: "cmd+c",
  command: "clipboard.copy",
  description: "Copy objects",
  when: "CanvasView"
};
var __glob_0_8$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": clipboard_copy$1
}, Symbol.toStringTag, { value: "Module" }));
var clipboard_paste$1 = {
  category: "Edit",
  key: "cmd+v",
  win: "ctrl+v",
  command: "clipboard.paste",
  description: "Paste selected objects",
  when: "CanvasView"
};
var __glob_0_9$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": clipboard_paste$1
}, Symbol.toStringTag, { value: "Module" }));
var group_item$1 = {
  category: "Group",
  key: "cmd+g",
  win: "ctrl+g",
  command: "group.item",
  description: "Grouping selected items",
  when: "CanvasView"
};
var __glob_0_10$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": group_item$1
}, Symbol.toStringTag, { value: "Module" }));
var history_redo = {
  category: "History",
  key: "cmd+shift+z",
  win: "ctrl+shift+z",
  command: "history.redo",
  description: "redoing in history",
  when: "CanvasView"
};
var __glob_0_11$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": history_redo
}, Symbol.toStringTag, { value: "Module" }));
var history_undo = {
  category: "History",
  key: "cmd+z",
  win: "ctrl+z",
  command: "history.undo",
  description: "undoing in history",
  when: "CanvasView"
};
var __glob_0_12$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": history_undo
}, Symbol.toStringTag, { value: "Module" }));
var item_move_alt_down = {
  category: "Layer",
  key: "Alt+ArrowDown",
  command: "moveLayer",
  description: "move 5px to down",
  args: [0, 5],
  when: "CanvasView"
};
var __glob_0_13$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": item_move_alt_down
}, Symbol.toStringTag, { value: "Module" }));
var item_move_alt_left = {
  category: "Layer",
  key: "Alt+ArrowLeft",
  command: "moveLayer",
  description: "move 5px to left",
  args: [-5, 0],
  when: "CanvasView"
};
var __glob_0_14$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": item_move_alt_left
}, Symbol.toStringTag, { value: "Module" }));
var item_move_alt_right = {
  category: "Layer",
  key: "Alt+ArrowRight",
  command: "moveLayer",
  description: "move 5px to right",
  args: [5, 0],
  when: "CanvasView"
};
var __glob_0_15$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": item_move_alt_right
}, Symbol.toStringTag, { value: "Module" }));
var item_move_alt_up = {
  category: "Layer",
  key: "Alt+ArrowUp",
  command: "moveLayer",
  description: "move 5px to up",
  args: [0, -5],
  when: "CanvasView"
};
var __glob_0_16$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": item_move_alt_up
}, Symbol.toStringTag, { value: "Module" }));
var item_move_depth_down$1 = {
  category: "Layer",
  key: "ctrl+[",
  command: "history.send.backward",
  description: "move layer to below",
  args: ["send backward"],
  when: "CanvasView"
};
var __glob_0_17$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": item_move_depth_down$1
}, Symbol.toStringTag, { value: "Module" }));
var item_move_depth_up$1 = {
  category: "Layer",
  key: "ctrl+]",
  command: "history.bring.forward",
  description: "move layer to above",
  args: ["bring forward"],
  when: "CanvasView"
};
var __glob_0_18$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": item_move_depth_up$1
}, Symbol.toStringTag, { value: "Module" }));
var item_move_key_down = {
  category: "Layer",
  key: "ArrowDown",
  command: "moveLayer",
  description: "move 1px to down",
  args: [0, 1],
  when: "CanvasView"
};
var __glob_0_19$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": item_move_key_down
}, Symbol.toStringTag, { value: "Module" }));
var item_move_key_left = {
  category: "Layer",
  key: "ArrowLeft",
  command: "moveLayer",
  description: "move 1px to left",
  args: [-1, 0],
  when: "CanvasView"
};
var __glob_0_20$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": item_move_key_left
}, Symbol.toStringTag, { value: "Module" }));
var item_move_key_right = {
  category: "Layer",
  key: "ArrowRight",
  command: "moveLayer",
  description: "move 1px to right",
  args: [1, 0],
  when: "CanvasView"
};
var __glob_0_21$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": item_move_key_right
}, Symbol.toStringTag, { value: "Module" }));
var item_move_key_up = {
  category: "Layer",
  key: "ArrowUp",
  command: "moveLayer",
  description: "move 1px to up",
  args: [0, -1],
  when: "CanvasView"
};
var __glob_0_22$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": item_move_key_up
}, Symbol.toStringTag, { value: "Module" }));
var item_move_shift_down = {
  category: "Layer",
  key: "Shift+ArrowDown",
  command: "moveLayer",
  description: "move 10px to down",
  args: [0, 10],
  when: "CanvasView"
};
var __glob_0_23$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": item_move_shift_down
}, Symbol.toStringTag, { value: "Module" }));
var item_move_shift_left = {
  category: "Layer",
  key: "Shift+ArrowLeft",
  command: "moveLayer",
  description: "move 10px to left",
  args: [-10, 0],
  when: "CanvasView"
};
var __glob_0_24$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": item_move_shift_left
}, Symbol.toStringTag, { value: "Module" }));
var item_move_shift_right = {
  category: "Layer",
  key: "Shift+ArrowRight",
  command: "moveLayer",
  description: "move 10px to right",
  args: [10, 0],
  when: "CanvasView"
};
var __glob_0_25$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": item_move_shift_right
}, Symbol.toStringTag, { value: "Module" }));
var item_move_shift_up = {
  category: "Layer",
  key: "Shift+ArrowUp",
  command: "moveLayer",
  description: "move 10px to up",
  args: [0, -10],
  when: "CanvasView"
};
var __glob_0_26$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": item_move_shift_up
}, Symbol.toStringTag, { value: "Module" }));
var item_rotate_meta_left = {
  category: "Layer",
  key: "Meta+ArrowLeft",
  command: "rotateLayer",
  description: "rotate to left",
  args: [-5],
  when: "CanvasView"
};
var __glob_0_27$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": item_rotate_meta_left
}, Symbol.toStringTag, { value: "Module" }));
var item_rotate_meta_right = {
  category: "Layer",
  key: "Meta+ArrowRight",
  command: "rotateLayer",
  description: "rotate to right",
  args: [5],
  when: "CanvasView"
};
var __glob_0_28$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": item_rotate_meta_right
}, Symbol.toStringTag, { value: "Module" }));
var removeLayer$1 = {
  category: "Layer",
  key: "Backspace",
  command: "history.removeLayer",
  description: "Delete selected items",
  args: ["Delete selected items"],
  when: "CanvasView"
};
var __glob_0_29$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": removeLayer$1
}, Symbol.toStringTag, { value: "Module" }));
var removeLayerByDeleteKey = {
  category: "Layer",
  key: "Delete",
  command: "history.removeLayer",
  description: "Delete selected items",
  args: ["Delete selected items"],
  when: "CanvasView"
};
var __glob_0_30$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": removeLayerByDeleteKey
}, Symbol.toStringTag, { value: "Module" }));
var segment_delete$1 = {
  category: "Path",
  key: "Backspace",
  command: "segment.delete",
  description: "Delete selected segment",
  when: "PathEditorView"
};
var __glob_0_31$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": segment_delete$1
}, Symbol.toStringTag, { value: "Module" }));
var segment_move_alt_down = {
  category: "Path",
  key: "Alt+ArrowDown",
  command: "segment.move.down",
  description: "move 5px to down",
  args: [{ dy: 5 }],
  when: "PathEditorView"
};
var __glob_0_32$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": segment_move_alt_down
}, Symbol.toStringTag, { value: "Module" }));
var segment_move_alt_left = {
  category: "Path",
  key: "Alt+ArrowLeft",
  command: "segment.move.left",
  description: "move 5px to left",
  args: [{ dx: 5 }],
  when: "PathEditorView"
};
var __glob_0_33$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": segment_move_alt_left
}, Symbol.toStringTag, { value: "Module" }));
var segment_move_alt_right = {
  category: "Path",
  key: "Alt+ArrowRight",
  command: "segment.move.right",
  description: "move 5px to right",
  args: [{ dx: 5 }],
  when: "PathEditorView"
};
var __glob_0_34$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": segment_move_alt_right
}, Symbol.toStringTag, { value: "Module" }));
var segment_move_alt_up = {
  category: "Path",
  key: "Alt+ArrowUp",
  command: "segment.move.up",
  description: "move 5px to up ",
  args: [{ dy: 5 }],
  when: "PathEditorView"
};
var __glob_0_35$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": segment_move_alt_up
}, Symbol.toStringTag, { value: "Module" }));
var segment_move_key_down = {
  category: "Path",
  key: "ArrowDown",
  command: "segment.move.down",
  description: "move 1px to down",
  args: [{ dy: 1 }],
  when: "PathEditorView"
};
var __glob_0_36$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": segment_move_key_down
}, Symbol.toStringTag, { value: "Module" }));
var segment_move_key_left = {
  category: "Path",
  key: "ArrowLeft",
  command: "segment.move.left",
  description: "move 1px to left",
  args: [{ dx: 1 }],
  when: "PathEditorView"
};
var __glob_0_37$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": segment_move_key_left
}, Symbol.toStringTag, { value: "Module" }));
var segment_move_key_right = {
  category: "Path",
  key: "ArrowRight",
  command: "segment.move.right",
  description: "move 1px to right",
  args: [{ dx: 1 }],
  when: "PathEditorView"
};
var __glob_0_38$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": segment_move_key_right
}, Symbol.toStringTag, { value: "Module" }));
var segment_move_key_up = {
  category: "Path",
  key: "ArrowUp",
  command: "segment.move.up",
  description: "move 1px to up",
  args: [{ dy: 1 }],
  when: "PathEditorView"
};
var __glob_0_39$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": segment_move_key_up
}, Symbol.toStringTag, { value: "Module" }));
var segment_move_shift_down = {
  category: "Path",
  key: "Shift+ArrowDown",
  command: "segment.move.down",
  description: "move 10px to down",
  args: [{ dy: 10 }],
  when: "PathEditorView"
};
var __glob_0_40$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": segment_move_shift_down
}, Symbol.toStringTag, { value: "Module" }));
var segment_move_shift_left = {
  category: "Path",
  key: "Shift+ArrowLeft",
  command: "segment.move.left",
  description: "move 10px to left",
  args: [{ dx: 10 }],
  when: "PathEditorView"
};
var __glob_0_41$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": segment_move_shift_left
}, Symbol.toStringTag, { value: "Module" }));
var segment_move_shift_right = {
  category: "Path",
  key: "Shift+ArrowRight",
  command: "segment.move.right",
  description: "move 10px to right",
  args: [{ dx: 10 }],
  when: "PathEditorView"
};
var __glob_0_42$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": segment_move_shift_right
}, Symbol.toStringTag, { value: "Module" }));
var segment_move_shift_up = {
  category: "Path",
  key: "Shift+ArrowUp",
  command: "segment.move.up",
  description: "move 10px to up",
  args: [{ dy: 10 }],
  when: "PathEditorView"
};
var __glob_0_43$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": segment_move_shift_up
}, Symbol.toStringTag, { value: "Module" }));
var select_all$1 = {
  category: "Tool",
  key: "CMD+A",
  win: "CTRL+A",
  command: "select.all",
  description: "Selection all layers"
};
var __glob_0_44$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": select_all$1
}, Symbol.toStringTag, { value: "Module" }));
var select_view = {
  category: "Tool",
  key: "v",
  command: "addLayerView",
  args: "select",
  description: "Selection"
};
var __glob_0_45$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": select_view
}, Symbol.toStringTag, { value: "Module" }));
var set_tool_hand$1 = {
  category: "Tools",
  key: "h",
  command: "toggleToolHand",
  description: "set hand tool on",
  when: "CanvasView"
};
var __glob_0_46$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": set_tool_hand$1
}, Symbol.toStringTag, { value: "Module" }));
var show_pan = {
  category: "Tool",
  key: "space",
  command: "showPan",
  description: "Show panning area",
  when: "CanvasView"
};
var __glob_0_47$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": show_pan
}, Symbol.toStringTag, { value: "Module" }));
var ungroup_item$1 = {
  category: "Group",
  key: "shift+cmd+g",
  win: "shift+ctrl+g",
  command: "ungroup.item",
  description: "Ungrouping selected group layer",
  when: "CanvasView"
};
var __glob_0_48$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": ungroup_item$1
}, Symbol.toStringTag, { value: "Module" }));
var zoom_default = {
  category: "View",
  key: "0",
  command: "zoom.default",
  description: "zoom by scale 1",
  when: "CanvasView"
};
var __glob_0_49$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": zoom_default
}, Symbol.toStringTag, { value: "Module" }));
var zoom_in = {
  category: "View",
  key: "Equal",
  command: "zoom.in",
  description: "zoom in",
  when: "CanvasView"
};
var __glob_0_50$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": zoom_in
}, Symbol.toStringTag, { value: "Module" }));
var zoom_out = {
  category: "View",
  key: "minus",
  command: "zoom.out",
  description: "zoom Out",
  when: "CanvasView"
};
var __glob_0_51$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": zoom_out
}, Symbol.toStringTag, { value: "Module" }));
const modules$3 = { "./shortcuts_list/add.artboard.js": __glob_0_0$3, "./shortcuts_list/add.brush.js": __glob_0_1$3, "./shortcuts_list/add.circle.js": __glob_0_2$2, "./shortcuts_list/add.circle.l.js": __glob_0_3$2, "./shortcuts_list/add.path.js": __glob_0_4$2, "./shortcuts_list/add.rect.js": __glob_0_5$2, "./shortcuts_list/add.rect.m.js": __glob_0_6$2, "./shortcuts_list/add.text.js": __glob_0_7$2, "./shortcuts_list/clipboard.copy.js": __glob_0_8$2, "./shortcuts_list/clipboard.paste.js": __glob_0_9$2, "./shortcuts_list/group.item.js": __glob_0_10$2, "./shortcuts_list/history.redo.js": __glob_0_11$2, "./shortcuts_list/history.undo.js": __glob_0_12$2, "./shortcuts_list/item.move.alt.down.js": __glob_0_13$2, "./shortcuts_list/item.move.alt.left.js": __glob_0_14$2, "./shortcuts_list/item.move.alt.right.js": __glob_0_15$2, "./shortcuts_list/item.move.alt.up.js": __glob_0_16$2, "./shortcuts_list/item.move.depth.down.js": __glob_0_17$2, "./shortcuts_list/item.move.depth.up.js": __glob_0_18$2, "./shortcuts_list/item.move.key.down.js": __glob_0_19$2, "./shortcuts_list/item.move.key.left.js": __glob_0_20$2, "./shortcuts_list/item.move.key.right.js": __glob_0_21$2, "./shortcuts_list/item.move.key.up.js": __glob_0_22$2, "./shortcuts_list/item.move.shift.down.js": __glob_0_23$2, "./shortcuts_list/item.move.shift.left.js": __glob_0_24$2, "./shortcuts_list/item.move.shift.right.js": __glob_0_25$1, "./shortcuts_list/item.move.shift.up.js": __glob_0_26$1, "./shortcuts_list/item.rotate.meta.left.js": __glob_0_27$1, "./shortcuts_list/item.rotate.meta.right.js": __glob_0_28$1, "./shortcuts_list/removeLayer.js": __glob_0_29$1, "./shortcuts_list/removeLayerByDeleteKey.js": __glob_0_30$1, "./shortcuts_list/segment.delete.js": __glob_0_31$1, "./shortcuts_list/segment.move.alt.down.js": __glob_0_32$1, "./shortcuts_list/segment.move.alt.left.js": __glob_0_33$1, "./shortcuts_list/segment.move.alt.right.js": __glob_0_34$1, "./shortcuts_list/segment.move.alt.up.js": __glob_0_35$1, "./shortcuts_list/segment.move.key.down.js": __glob_0_36$1, "./shortcuts_list/segment.move.key.left.js": __glob_0_37$1, "./shortcuts_list/segment.move.key.right.js": __glob_0_38$1, "./shortcuts_list/segment.move.key.up.js": __glob_0_39$1, "./shortcuts_list/segment.move.shift.down.js": __glob_0_40$1, "./shortcuts_list/segment.move.shift.left.js": __glob_0_41$1, "./shortcuts_list/segment.move.shift.right.js": __glob_0_42$1, "./shortcuts_list/segment.move.shift.up.js": __glob_0_43$1, "./shortcuts_list/select.all.js": __glob_0_44$1, "./shortcuts_list/select.view.js": __glob_0_45$1, "./shortcuts_list/set.tool.hand.js": __glob_0_46$1, "./shortcuts_list/show.pan.js": __glob_0_47$1, "./shortcuts_list/ungroup.item.js": __glob_0_48$1, "./shortcuts_list/zoom.default.js": __glob_0_49$1, "./shortcuts_list/zoom.in.js": __glob_0_50$1, "./shortcuts_list/zoom.out.js": __glob_0_51$1 };
var shortcuts = Object.values(modules$3).map((it) => it.default);
function joinKeys(...args2) {
  return args2.filter(Boolean).join("+");
}
function generateKeyCode(code2) {
  return KEY_CODE[`${code2}`.toLowerCase()] || code2;
}
class ShortCutManager {
  constructor(editor) {
    this.$editor = editor;
    this.loadShortCuts();
  }
  getGeneratedKeyCode(code2) {
    return generateKeyCode(code2);
  }
  loadShortCuts() {
    this.list = [];
    this.commands = {};
    shortcuts.forEach((shortcut) => {
      this.registerShortCut(shortcut);
    });
    this.sort();
  }
  registerShortCut(shortcut) {
    const OSName2 = os();
    this.list.push(__spreadProps(__spreadValues({
      key: "",
      command: "",
      args: [],
      eventType: "keydown"
    }, shortcut), {
      checkKeyString: this.splitShortCut(shortcut[OSName2] || shortcut.key),
      whenFunction: this.makeWhenFunction(shortcut.command, shortcut.when || true)
    }));
    this.sort();
  }
  makeWhenFunction(command, when) {
    if (isBoolean(when) && when) {
      return () => true;
    }
    const editor = this.$editor;
    const whenList = when.split("|").map((it) => it.trim());
    return () => {
      return whenList.some((it) => editor.context.modeViewManager.isCurrentMode(it));
    };
  }
  sort() {
    this.commands = {};
    this.list.forEach((it) => {
      if (Array.isArray(this.commands[it.checkKeyString]) === false) {
        this.commands[it.checkKeyString] = [];
      }
      this.commands[it.checkKeyString].push(it);
    });
  }
  splitShortCut(key) {
    var arr = key.toUpperCase().split("+").map((it) => it.trim()).filter(Boolean);
    let isAlt = false;
    let isControl = false;
    let isShift = false;
    let isMeta = false;
    let restKeys = [];
    arr.forEach((key2) => {
      if (key2.includes("ALT"))
        isAlt = true;
      else if (key2.includes("CTRL"))
        isControl = true;
      else if (key2.includes("SHIFT"))
        isShift = true;
      else if (key2.includes("CMD") || key2.includes("WIN") || key2.includes("META"))
        isMeta = true;
      else
        restKeys.push(key2);
    });
    return joinKeys(isAlt ? "ALT" : "", isControl ? "CTRL" : "", isShift ? "SHIFT" : "", isMeta ? "META" : "", generateKeyCode(restKeys.join("")));
  }
  makeKeyString(e) {
    return joinKeys(e.altKey ? "ALT" : "", e.ctrlKey ? "CTRL" : "", e.shiftKey ? "SHIFT" : "", e.metaKey ? "META" : "", e.key.toUpperCase());
  }
  makeCodeString(e) {
    return joinKeys(e.altKey ? "ALT" : "", e.ctrlKey ? "CTRL" : "", e.shiftKey ? "SHIFT" : "", e.metaKey ? "META" : "", e.code.toUpperCase());
  }
  makeKeyCodeString(e) {
    return joinKeys(e.altKey ? "ALT" : "", e.ctrlKey ? "CTRL" : "", e.shiftKey ? "SHIFT" : "", e.metaKey ? "META" : "", e.keyCode);
  }
  checkShortCut(keyCodeString, keyString, codeString) {
    return this.commands[keyCodeString] || this.commands[keyString] || this.commands[codeString];
  }
  checkWhen(command) {
    return command.whenFunction();
  }
  execute(e, eventType = "keydown") {
    let commands2 = this.checkShortCut(this.makeKeyCodeString(e), this.makeKeyString(e), this.makeCodeString(e));
    if (commands2) {
      const filteredCommands = commands2.filter((it) => it.eventType === eventType).filter((it) => this.checkWhen(it));
      if (filteredCommands.length) {
        e.preventDefault();
        filteredCommands.forEach((it) => {
          this.$editor.context.commands.emit(it.command, ...it.args);
        });
      }
    }
  }
}
class StateManager {
  constructor(editor) {
    this.editor = editor;
  }
  get config() {
    return this.editor.context.config;
  }
  get zIndex() {
    return this.popupZIndex++;
  }
  get isPointerUp() {
    const e = this.config.get("bodyEvent");
    if (!e)
      return true;
    if (e.type === "pointerup")
      return true;
    else if (e.type === "pointermove" && e.buttons === 0)
      return true;
    return false;
  }
  get isPointerDown() {
    return !this.isPointerUp;
  }
  get isPointerMove() {
    if (!this.config.get("bodyEvent"))
      return false;
    return this.config.get("bodyEvent").type === "pointermove";
  }
}
class StorageManager {
  constructor(editor) {
    this.editor = editor;
    this.customAssetKey = "custom-assets";
  }
  async getCustomAssetList() {
    let isNew = false;
    const artboards = (this.editor.loadItem(this.customAssetKey) || []).map((it) => {
      if (!it.id) {
        it.id = uuid();
        isNew = true;
      }
      return it;
    });
    if (isNew) {
      await this.setCustomAssetList(artboards);
    }
    return artboards;
  }
  async setCustomAssetList(list2) {
    this.editor.saveItem(this.customAssetKey, list2);
  }
  async getCustomAsset(id) {
    const assetList = await this.getCustomAssetList();
    const it = assetList.find((it2) => it2.id === id);
    if (it && it.component) {
      return it.component;
    }
    return null;
  }
  async saveCustomAsset(datauri = "") {
    const current = this.editor.context.selection.current;
    if (current) {
      const assetList = await this.getCustomAssetList();
      const json = await this.editor.json.render(current);
      json.x = "0px";
      json.y = "0px";
      await this.setCustomAssetList([
        ...assetList,
        {
          id: uuid(),
          preview: datauri,
          component: json
        }
      ]);
    }
  }
  async removeCustomAsset(id) {
    const assetList = await this.getCustomAssetList();
    await this.setCustomAssetList(assetList.filter((it) => {
      return it.id !== id;
    }));
  }
}
class ViewportManager {
  constructor(editor) {
    this.editor = editor;
    this.context = this.editor.context;
    this.canvasSize = null;
    this.cachedViewport = rectToVerties(0, 0, 0, 0);
    this.mouse = create$3();
    this.scale = 1;
    this.translate = create$3(), this.transformOrigin = create$3(), this.maxScale = 250;
    this.minScale = 0.02;
    this.zoomFactor = 1;
    this.resetWorldMatrix();
  }
  setTransformOrigin(originVec) {
    this.transformOrigin = originVec;
    this.resetWorldMatrix();
  }
  setTransformOriginWithTranslate(newOrigin) {
    const oldOrigin = clone(this.transformOrigin);
    this.setTransformOrigin(newOrigin);
    this.setTranslate(add$1([], this.translate, subtract([], oldOrigin, newOrigin)));
  }
  setScale(scale2) {
    this.scale = Math.min(Math.max(this.minScale, scale2), this.maxScale);
    this.resetWorldMatrix();
  }
  setTranslate(translate2) {
    this.translate = translate2;
    this.resetWorldMatrix();
  }
  resetWorldMatrix() {
    this.translate = this.translate.map((it) => +it.toFixed(4));
    this.transformOrigin = this.transformOrigin.map((it) => +it.toFixed(4));
    this.scale = +this.scale.toFixed(4);
    this.matrix = calculateMatrix(fromTranslation([], this.translate), fromTranslation([], this.transformOrigin), fromScaling([], [this.scale, this.scale, 1]), fromTranslation([], negate([], this.transformOrigin)));
    this.matrixInverse = invert([], this.matrix);
    this.scaleMatrix = calculateMatrix(fromScaling([], [this.scale, this.scale, 1]));
    this.scaleMatrixInverse = invert([], this.scaleMatrix);
    this.refresh();
  }
  refreshCanvasSize(rect2) {
    if (this.canvasSize) {
      this.canvasSize = rect2;
      this.cachedViewport = rectToVerties(0, 0, this.canvasSize.width, this.canvasSize.height);
      const newVerties = transformMat4([], [this.canvasSize.width, this.canvasSize.height, 0], this.scaleMatrixInverse);
      const newTransformOrigin = add$1([], this.verties[0], [
        newVerties[0] / 2,
        newVerties[1] / 2,
        0
      ]);
      const newTranslate = getTranslation([], calculateMatrix(this.matrix, calculateMatrixInverse(fromTranslation([], newTransformOrigin), this.scaleMatrix, invert([], fromTranslation([], newTransformOrigin)))));
      this.setTranslate(newTranslate);
      this.setTransformOrigin(newTransformOrigin);
    } else {
      this.canvasSize = rect2;
      this.cachedViewport = rectToVerties(0, 0, this.canvasSize.width, this.canvasSize.height);
      this.setTransformOrigin([
        this.canvasSize.width / 2,
        this.canvasSize.height / 2,
        0
      ]);
    }
    this.editor.emit(UPDATE_VIEWPORT);
  }
  refresh() {
    if (this.cachedViewport) {
      this.verties = vertiesMap(this.cachedViewport, this.matrixInverse);
      this.originVerties = this.verties.filter((_, index2) => index2 < 4);
      this.originRect = vertiesToRectangle(this.originVerties);
    }
  }
  getWorldPosition(e) {
    e = e || this.context.config.get("bodyEvent");
    if (!e) {
      return this.createWorldPosition(0, 0);
    }
    return this.createWorldPosition(e.clientX, e.clientY);
  }
  createWorldPosition(x, y) {
    if (!this.canvasSize) {
      return create$3();
    }
    const origin = {
      x: x - this.canvasSize.x,
      y: y - this.canvasSize.y
    };
    const mouseX = this.verties[0][0] + (this.verties[2][0] - this.verties[0][0]) * (origin.x / this.canvasSize.width);
    const mouseY = this.verties[0][1] + (this.verties[2][1] - this.verties[0][1]) * (origin.y / this.canvasSize.height);
    return [mouseX, mouseY, 0];
  }
  setMousePoint(x, y) {
    this.mouse = this.createWorldPosition(x, y);
    this.setTransformOriginWithTranslate(lerp$1([], this.verties[0], this.verties[2], 0.5));
    this.editor.emit(UPDATE_VIEWPORT);
  }
  zoom(zoomFactor) {
    const oldScale = this.scale;
    const newScale = oldScale * zoomFactor;
    this.setScale(newScale);
    const newZoomFactor = this.scale / oldScale;
    this.zoomFactor = newZoomFactor;
    if (newZoomFactor !== 1) {
      this.setTransformOriginWithTranslate(lerp$1([], this.mouse, this.transformOrigin, 1 / zoomFactor));
      this.editor.emit(UPDATE_VIEWPORT);
    }
  }
  pan(x, y, z = 0) {
    this.setTransformOriginWithTranslate(add$1([], this.transformOrigin, [x, y, 0]));
    this.editor.emit(UPDATE_VIEWPORT);
  }
  moveToCenter(areaVerties, scaleRate = -0.2, withScale = true) {
    if (!this.canvasSize)
      return;
    const areaCenter = lerp$1([], areaVerties[0], areaVerties[2], 0.5);
    const width2 = dist(areaVerties[0], areaVerties[1]);
    const height2 = dist(areaVerties[0], areaVerties[3]);
    const viewportCenter = lerp$1([], this.verties[0], this.verties[2], 0.5);
    const viewportWidth = dist(this.verties[0], this.verties[1]);
    const viewportHeight = dist(this.verties[0], this.verties[3]);
    const minRate = withScale ? Math.min(viewportWidth / width2, viewportHeight / height2) + scaleRate : 1;
    this.setTranslate(add$1([], this.translate, subtract([], viewportCenter, areaCenter)));
    this.setTransformOrigin(areaCenter);
    this.setScale(this.scale * minRate);
    this.editor.emit(UPDATE_VIEWPORT);
  }
  get pos() {
    const mouseX = (this.mouse[0] - this.verties[0][0]) / (this.verties[2][0] - this.verties[0][0]) * 100;
    const mouseY = (this.mouse[1] - this.verties[0][1]) / (this.verties[2][1] - this.verties[0][1]) * 100;
    return [mouseX, mouseY, 0];
  }
  get minX() {
    return this.verties[0][0];
  }
  get maxX() {
    return this.verties[2][0];
  }
  get minY() {
    return this.verties[0][1];
  }
  get maxY() {
    return this.verties[2][1];
  }
  get center() {
    return this.verties[4];
  }
  get height() {
    return this.maxY - this.minY;
  }
  get width() {
    return this.maxX - this.minX;
  }
  get pixelSize() {
    return Math.round(this.width / this.canvasSize.width);
  }
  checkInViewport(pointVertex) {
    const xInViewport = this.minX < pointVertex[0] && pointVertex[0] < this.maxX;
    const yInViewport = this.minY < pointVertex[1] && pointVertex[1] < this.maxY;
    return xInViewport && yInViewport;
  }
  checkInViewportArea(verties = []) {
    const source2 = vertiesToRectangle(verties);
    const target = this.originRect;
    return rectRect(source2.x, source2.y, source2.width, source2.height, target.x, target.y, target.width, target.height);
  }
  applyVertex(vertex2) {
    return transformMat4([], vertex2, this.matrix);
  }
  applyVertexInverse(vertex2) {
    return transformMat4([], vertex2, this.matrixInverse);
  }
  applyScaleVertex(vertex2) {
    return transformMat4([], vertex2, this.scaleMatrix);
  }
  applyScaleVertexInverse(vertex2) {
    return transformMat4([], vertex2, this.scaleMatrixInverse);
  }
  applyVerties(verties) {
    return vertiesMap(verties, this.matrix);
  }
  applyScaleVerties(verties) {
    return vertiesMap(verties, this.scaleMatrix);
  }
  applyVertiesInverse(verties) {
    return vertiesMap(verties, this.matrixInverse);
  }
  applyScaleVertiesInverse(verties) {
    return vertiesMap(verties, this.scaleMatrixInverse);
  }
  createAreaVerties(x, y, width2, height2) {
    return this.applyVertiesInverse(rectToVertiesForArea(x, y, width2, height2));
  }
  zoomIn(zoomFactor = 0.01) {
    this.setScale(this.scale + zoomFactor);
    this.editor.emit(UPDATE_VIEWPORT);
  }
  zoomOut(zoomFactor = 0.01) {
    this.zoomIn(-zoomFactor);
  }
  zoomDefault() {
    this.setScale(1);
    this.editor.emit(UPDATE_VIEWPORT);
  }
}
var dark = {
  left_size: 250,
  left_max_size: 400,
  bottom_size: 150,
  bottom_max_size: 500,
  timeline_grid_font_color: "#ececec",
  timeline_line_color: "red",
  timeline_timeview_bottom_color: "black"
};
var light = {
  left_size: 250,
  left_max_size: 400,
  bottom_size: 150,
  bottom_max_size: 500,
  timeline_grid_font_color: "black",
  timeline_line_color: "#4778d4",
  timeline_timeview_bottom_color: "#ececec"
};
var theme = {
  dark,
  light
};
class Editor {
  constructor(opt = {}) {
    this.EDITOR_ID = uuid();
    this.projects = [];
    this.popupZIndex = 1e4;
    this.symbols = {};
    this.images = {};
    this.openRightPanel = true;
    this.ignoreManagers = opt.ignoreManagers || [];
    this.context = {};
    this.loadManagers();
  }
  loadManagers() {
    this.registerManager({
      store: BaseStore,
      config: ConfigManager,
      commands: CommandManager,
      keyboardManager: KeyBoardManager,
      viewport: ViewportManager,
      storageManager: StorageManager,
      modeViewManager: ModeViewManager,
      cursorManager: CursorManager,
      assetManager: AssetManager,
      injectManager: InjectManager,
      components: ComponentManager,
      pluginManager: PluginManager,
      renderers: RendererManager,
      i18n: I18nManager,
      icon: IconManager$1,
      stateManager: StateManager,
      menuManager: MenuManager
    });
    if (this.ignoreManagers.includes("ShortCutManager") === false) {
      this.registerManager({
        shortcuts: ShortCutManager
      });
    }
    this.loadCommands(obj$2);
    this.initPlugins();
    this.initStorage();
  }
  registerManager(obj2 = {}) {
    Object.keys(obj2).forEach((name) => {
      const DataManagerClass = obj2[name];
      Object.defineProperty(this.context, name, {
        value: new DataManagerClass(this),
        writable: false
      });
    });
  }
  initStorage() {
    this.locale = this.loadItem("locale") || "en_US";
    this.layout = this.loadItem("layout") || "all";
  }
  createProject() {
    return this.createModel({ itemType: "project" });
  }
  getI18nMessage(key, params = {}, locale) {
    return this.context.i18n.get(key, params, locale || this.locale);
  }
  $i18n(key, params = {}, locale) {
    return this.getI18nMessage(key, params, locale);
  }
  hasI18nkey(key, locale) {
    return this.context.i18n.hasKey(key, locale || this.locale);
  }
  initI18nMessage(root = "") {
    return (key, params = {}, locale) => {
      const i18nKey = `${root}.${key}`;
      if (this.hasI18nkey(i18nKey, locale)) {
        return this.context.i18(`${root}.${key}`, params, locale);
      } else {
        return this.context.i18(`${key}`, params, locale);
      }
    };
  }
  setLocale(locale = "en_US") {
    this.locale = locale;
    this.saveItem("locale", this.locale);
  }
  setUser(user) {
    this.user = user;
  }
  async initPlugins(options2 = {}) {
    await this.context.pluginManager.initializePlugin(options2);
  }
  themeValue(key, defaultValue2 = "") {
    return theme[this.context.config.get("editor.theme")][key] || defaultValue2;
  }
  get zIndex() {
    return this.popupZIndex++;
  }
  getFile(url) {
    return this.images[url] || url;
  }
  setStore(store) {
    this.store = store;
  }
  emit(...args2) {
    this.context.store.source = this.EDITOR_ID;
    this.context.store.emit(...args2);
  }
  on(...args2) {
    const [name, callback, context, ...rest] = args2;
    return this.context.store.on(name, callback, context || this, ...rest);
  }
  off(...args2) {
    this.context.store.off(...args2);
  }
  offAll(...args2) {
    this.context.store.offAll(...args2);
  }
  debug() {
  }
  command(command, message, ...args2) {
    console.warn("command", command, message, args2);
    if (this.context.stateManager.isPointerUp) {
      return this.context.store.emit(`history.${command}`, message, ...args2);
    } else {
      return this.context.store.emit(command, ...args2);
    }
  }
  nextTick(callback, delay = 0) {
    if (this.context.store) {
      window.setTimeout(() => {
        this.context.store.nextTick(callback);
      }, delay);
    }
  }
  get(idOrModel) {
    return this.context.modelManager.get((idOrModel == null ? void 0 : idOrModel.id) || idOrModel);
  }
  replaceLocalUrltoRealUrl(str) {
    var project2 = this.context.selection.currentProject;
    var images = {};
    project2.images.forEach((a) => {
      if (str.indexOf(a.local) > -1) {
        images[a.local] = a.original;
      }
    });
    Object.keys(images).forEach((local) => {
      if (str.indexOf(local) > -1) {
        str = str.replace(new RegExp(local, "g"), images[local]);
      }
    });
    return str;
  }
  createModel(itemObject, isRegister = true) {
    return this.context.modelManager.createModel(itemObject, isRegister);
  }
  searchItem(id) {
    return this.context.modelManager.searchItem(id);
  }
  get storeKey() {
    return `__els__.${this.context.config.get("store.key")}`;
  }
  saveItem(key, value) {
    window.localStorage.setItem(`${this.storeKey}.${key}`, JSON.stringify(value));
  }
  loadItem(key) {
    return JSON.parse(window.localStorage.getItem(`${this.storeKey}.${key}`) || JSON.stringify(""));
  }
  createCommandMaker() {
    return new CommandMaker(this);
  }
  registerElement(obj2) {
    registElement(obj2);
  }
  registerAlias(obj2) {
    Object.entries(obj2).forEach(([key, value]) => {
      registAlias(key, value);
    });
  }
  registerUI(target, obj2 = {}, order = 1) {
    this.context.injectManager.registerUI(target, obj2, order);
    this.registerElement(obj2);
  }
  registerComponent(name, component2) {
    this.context.components.registerComponent(name, component2);
  }
  registerItem(name, item) {
    this.registerComponent(name, item);
  }
  registerInspector(name, inspectorCallback) {
    this.context.components.registerInspector(name, inspectorCallback);
  }
  registerRenderer(rendererType, name, rendererInstance) {
    this.context.renderers.registerRenderer(rendererType, name, rendererInstance);
  }
  registerRendererType(rendererType, rendererTypeInstance) {
    this.context.renderers.registerRendererType(rendererType, rendererTypeInstance);
  }
  getRendererInstance(rendererType, itemType) {
    return this.context.renderers.getRendererInstance(rendererType, itemType);
  }
  renderer(rendererType) {
    return this.context.renderers.getRenderer(rendererType);
  }
  get html() {
    return this.renderer("html");
  }
  get svg() {
    return this.renderer("svg");
  }
  get json() {
    return this.renderer("json");
  }
  loadCommands(userCommands) {
    return this.context.commands.loadCommands(userCommands);
  }
  registerCommand(commandObject) {
    return this.context.commands.registerCommand(commandObject);
  }
  registerShortCut(shortcut) {
    this.context.shortcuts.registerShortCut(shortcut);
  }
  registerPlugin(createPluginFunction) {
    this.context.pluginManager.registerPlugin(createPluginFunction);
  }
  registerPluginList(plugins = []) {
    plugins.forEach((p) => this.registerPlugin(p));
  }
  registerConfig(config) {
    this.context.config.registerConfig(config);
  }
  registerI18nMessage(locale, messages) {
    this.context.i18n.registerI18nMessage(locale, messages);
  }
  registerI18nMessageWithLocale(messages) {
    Object.entries(messages).forEach(([locale, messages2]) => {
      this.registerI18nMessage(locale, messages2);
    });
  }
  registerIcon(itemType, iconOrFunction) {
    this.context.icon.registerIcon(itemType, iconOrFunction);
  }
  registerMenu(target, menu) {
    this.context.menuManager.registerMenu(target, menu);
  }
}
const EMPTY_POS = { x: 0, y: 0 };
const DEFAULT_POS = { x: Number.MAX_SAFE_INTEGER, y: Number.MAX_SAFE_INTEGER };
const MOVE_CHECK_MS = 0;
class BaseLayout extends EditorElement {
  async created() {
    this.$editor.registerManager(this.getManagers());
    this.$editor.registerPluginList(this.getPlugins());
    if (Array.isArray(this.opt.plugins)) {
      this.$editor.registerPluginList(this.opt.plugins);
    }
    await this.$editor.initPlugins();
    this.$config.load();
    if (isObject(this.opt.config)) {
      this.$config.setAll(this.opt.config || {});
    }
    this._isPluginLoaded = true;
  }
  get isPreLoaded() {
    return Boolean(this._isPluginLoaded);
  }
  get $editor() {
    if (!this.__editorInstance) {
      this.__editorInstance = this.createEditorInstance();
    }
    return this.__editorInstance;
  }
  createEditorInstance() {
    return new Editor();
  }
  afterRender() {
    super.afterRender();
    this.$el.attr("data-theme", this.$config.get("editor.theme"));
    this.$el.addClass(window.navigator.userAgent.includes("Windows") ? "ua-window" : "ua-default");
    this.trigger("initialize");
  }
  initialize() {
    super.initialize();
    this.__initBodyMoves();
  }
  [CONFIG("editor.theme")]() {
    this.$el.attr("data-theme", this.$config.get("editor.theme"));
  }
  getPlugins() {
    return [];
  }
  getManagers() {
    return {};
  }
  __initBodyMoves() {
    this.__firstMove = /* @__PURE__ */ new Set();
    this.__moves = /* @__PURE__ */ new Set();
    this.__ends = /* @__PURE__ */ new Set();
    this.__modifyBodyMoveSecond(MOVE_CHECK_MS);
  }
  __modifyBodyMoveSecond(ms = MOVE_CHECK_MS) {
    this.$config.set("body.move.ms", ms);
    const callback = ms === 0 ? this.__loopBodyMoves.bind(this) : debounce(this.__loopBodyMoves.bind(this), this.$config.get("body.move.ms"));
    this.__funcBodyMoves = callback;
  }
  __loopBodyMoves() {
    var pos = this.pos;
    var e = this.$config.get("bodyEvent");
    var lastPos = this.lastPos || DEFAULT_POS;
    var isNotEqualLastPos = !(lastPos.x === pos.x && lastPos.y === pos.y);
    if (isNotEqualLastPos && this.__firstMove.size) {
      let i = 0;
      this.__firstMove.forEach((v) => {
        const dist2 = getDist(pos.x, pos.y, v.xy.x, v.xy.y);
        if (Math.abs(dist2) > 0) {
          var dx = pos.x - v.xy.x;
          var dy = pos.y - v.xy.y;
          v.func.call(v.context, dx, dy, "move", e.pressure);
          i++;
        }
      });
      if (i > 0) {
        this.__firstMove.clear();
      }
    }
    if (isNotEqualLastPos && this.__moves.size) {
      this.__moves.forEach((v) => {
        const dist2 = getDist(pos.x, pos.y, v.xy.x, v.xy.y);
        if (Math.abs(dist2) > 0.5) {
          var dx = pos.x - v.xy.x;
          var dy = pos.y - v.xy.y;
          v.func.call(v.context, dx, dy, "move", e.pressure);
        }
      });
      this.lastPos = pos;
    }
    window.requestAnimationFrame(this.__funcBodyMoves);
  }
  __removeBodyMoves() {
    var pos = this.lastPos;
    var e = this.$config.get("bodyEvent");
    if (pos) {
      this.__ends.forEach((v) => {
        v.func.call(v.context, pos.x - v.xy.x, pos.y - v.xy.y, "end", e.pressure);
      });
    }
    this.__firstMove.clear();
    this.__moves.clear();
    this.__ends.clear();
  }
  [SUBSCRIBE_ALL(ADD_BODY_FIRST_MOUSEMOVE)](func, context, xy2) {
    this.__firstMove.add({ func, context, xy: xy2 });
  }
  [SUBSCRIBE_ALL(ADD_BODY_MOUSEMOVE)](func, context, xy2) {
    this.__moves.add({ func, context, xy: xy2 });
  }
  [SUBSCRIBE_ALL(ADD_BODY_MOUSEUP)](func, context, xy2) {
    this.__ends.add({ func, context, xy: xy2 });
  }
  [POINTERSTART()](e) {
    var newPos = e.xy || EMPTY_POS;
    this.$config.init("bodyEvent", e);
    this.pos = newPos;
  }
  [POINTERMOVE()](e) {
    var newPos = e.xy || EMPTY_POS;
    this.$config.init("bodyEvent", e);
    this.$commands.emit("change.bodyEvent");
    this.pos = newPos;
    if (!this.__requestId) {
      this.__requestId = window.requestAnimationFrame(this.__funcBodyMoves);
    }
  }
  [POINTEREND()](e) {
    this.$config.set("bodyEvent", e);
    this.__removeBodyMoves();
    window.cancelAnimationFrame(this.__requestId);
    this.__requestId = null;
  }
  [RESIZE("window") + DEBOUNCE(100)]() {
    this.emit(RESIZE_WINDOW);
  }
  [SUBSCRIBE("refreshAll")]() {
    this.emit("refreshProjectList");
    this.$commands.emit("refreshArtboard");
  }
  [SUBSCRIBE("changed.locale")]() {
    this.rerender();
  }
}
class IconManager extends EditorElement {
  template() {
    return `
      <svg viewBox="0 0 30 10" xmlns="http://www.w3.org/2000/svg" ref="$list" style="display:none;">
      </svg>
    `;
  }
  [LOAD("$list")]() {
    return Object.entries(obj$3).map(([key, value]) => {
      if (isString(value) === false)
        return "";
      return value.replace(/\<svg/g, `<svg id="icon-${key}"`);
    });
  }
}
const formElements = ["TEXTAREA", "INPUT", "SELECT"];
class KeyboardManager extends EditorElement {
  template() {
    return `
      <div class="keyboard-manager"></div>
    `;
  }
  isNotFormElement(e) {
    var tagName = e.target.tagName;
    if (formElements.includes(tagName))
      return false;
    else if (Dom.create(e.target).attr("contenteditable") === "true")
      return false;
    return true;
  }
  [KEYDOWN("document") + IF("isNotFormElement")](e) {
    this.$commands.emit("keymap.keydown", e);
  }
  [KEYUP("document") + IF("isNotFormElement")](e) {
    this.$commands.emit("keymap.keyup", e);
  }
}
var PopupManager$1 = "";
var NotificationView$1 = "";
class NotificationView extends EditorElement {
  template() {
    return `
            <div class='elf--notification-view'>
            </div>
        `;
  }
  [TRANSITIONEND("$el")](e) {
    Dom.create(e.target).remove();
  }
  [CLICK("$el .item > .icon")](e) {
    e.$dt.parent().remove();
  }
  getMessageTemplate(type, title2, description, duration = 1e3) {
    return `
        <div class='item ${type}' style='transition-duration: ${duration}ms;'>
            <div class='title'>${title2}</div> 
            <div class='description'>${description}</div>
            <span class='icon'>${iconUse("close")}</span>
        </div>
    `;
  }
  [SUBSCRIBE(SHOW_NOTIFY)](type, title2, description, duration = 1e3) {
    const $dom = Dom.createByHTML(this.getMessageTemplate(type, title2, description, 1e3));
    this.$el.prepend($dom);
    window.setTimeout(($dom2) => {
      $dom2.css("opacity", 0);
    }, duration, $dom);
  }
}
var BaseWindow$1 = "";
class BaseWindow extends EditorElement {
  template() {
    return `
      <div class='elf--window-background'>
        <div class='window ${this.getClassName()}'>
            <div class='window-title' ref="$title">
                <label>${this.getTitle()}</label>
                <span class="tools">
                  ${this.getTools()}
                  <button type='button' class='close' ref='$close'>${iconUse("close")}</button>
                </span>
            </div>
            <div class='window-body'>${this.getBody()}</div>
        </div>
      </div>
        `;
  }
  getClassName() {
    return "";
  }
  getTitle() {
    return "";
  }
  getTools() {
    return "";
  }
  getBody() {
    return "";
  }
  [CLICK("$close")]() {
    this.$el.hide();
  }
  show() {
    this.$el.show("block");
  }
  hide() {
    this.$el.hide();
  }
}
var ExportWindow$1 = "";
class EmbedEditorWindow extends BaseWindow {
  getClassName() {
    return "elf--export-window";
  }
  getTitle() {
    return "Mini Editor";
  }
  initState() {
    return {
      selectedIndex: 1
    };
  }
  refresh() {
    if (this.$el.isShow()) {
      createDesignEditor({
        container: this.refs.$body.el,
        config: {
          "editor.design.mode": "item"
        }
      });
    }
  }
  getBody() {
    return `
        <div class="test" ref="$body">

      </div>
        `;
  }
  [SUBSCRIBE("showEmbedEditorWindow")]() {
    this.show();
    this.refresh();
  }
}
registElement({ EmbedEditorWindow });
class ExportWindow extends BaseWindow {
  getClassName() {
    return "elf--export-window";
  }
  getTitle() {
    return "Export";
  }
  initState() {
    return {
      selectedIndex: 1
    };
  }
  getBody() {
    return `
        <div class="tab" ref="$tab">
            <div class="tab-header full" ref="$header">
                <div class="tab-item selected" data-value="1">
                    <label>HTML</label>
                </div>
                <div class="tab-item" data-value="2">
                    <label>CSS</label>
                </div>                
                <div class="tab-item" data-value="6">
                    <label>SVG Image</label>
                </div>     
            </div>
            <div class="tab-body" ref="$body">
                <div class="tab-content selected" data-value="1" ref="$html">
                </div>
                <div class='tab-content' data-value='2' ref="$css">
                </div>                        
                <div class="tab-content" data-value="6" ref="$svgimage">
                </div>                                                                       
            </div>
      </div>
        `;
  }
  [SUBSCRIBE("showExportWindow")]() {
    this.show();
    this.refresh();
  }
  refresh() {
    var project2 = this.$context.selection.currentProject || { layers: [] };
    var css = `
${this.makeStyle(project2)}
${project2.layers.map((item) => this.makeStyle(item)).join("\n")}
`;
    var html = `
${this.$editor.html.renderSVG(project2)}
${this.$editor.html.render(project2)}
        `;
    var svgData = project2.layers.map((item) => {
      return this.$editor.svg.render(item);
    });
    if (shiki) {
      shiki.getHighlighter({
        theme: "light-plus"
      }).then((highlighter) => {
        if (html_beautify) {
          html = html_beautify(html, { indent: 2 });
          const changedHtml = highlighter.codeToHtml(html, "html");
          this.refs.$html.html(changedHtml);
          css = html_beautify(css, { indent: 2 });
          const changedCss = highlighter.codeToHtml(css, "html");
          this.refs.$css.html(changedCss);
          svgData = html_beautify(svgData.join(""), { indent: 2 });
          const changedSvgData = highlighter.codeToHtml(svgData, "html");
          this.refs.$svgimage.html(changedSvgData);
        }
      });
    }
  }
  makeStyle(item) {
    return this.$editor.html.toExportStyle(item, null);
  }
  makeHTML(item) {
    return this.$editor.html.render(item);
  }
  [CLICK("$header .tab-item")](e) {
    var selectedIndex = +e.$dt.attr("data-value");
    if (this.state.selectedIndex === selectedIndex) {
      return;
    }
    this.$el.$$(`[data-value="${this.state.selectedIndex}"]`).forEach((it) => it.removeClass("selected"));
    this.$el.$$(`[data-value="${selectedIndex}"]`).forEach((it) => it.addClass("selected"));
    this.setState({ selectedIndex }, false);
  }
}
registElement({ ExportWindow });
var ProjectWindow$1 = "";
class ProjectWindow extends BaseWindow {
  getClassName() {
    return "elf--project-window";
  }
  getTitle() {
    return "Project Manager";
  }
  initState() {
    return {
      selectedIndex: 1
    };
  }
  getBody() {
    return `
        <div class="project-container">
            <div class="project-menu left">
                Project Menu
            </div>
            <div class="project-list right">
                Project List
            </div>
        </div>
        `;
  }
  [SUBSCRIBE("open.projects")]() {
    this.show();
    this.refresh();
  }
  refresh() {
  }
}
registElement({ ProjectWindow });
var ShortcutWindow$1 = "";
const categories = /* @__PURE__ */ new Set();
shortcuts.forEach((it) => {
  categories.add(it.category);
});
const keys = {};
categories.forEach((it) => {
  shortcuts.filter((item) => item.category === it).forEach((item) => {
    if (!keys[item.category]) {
      keys[item.category] = [];
    }
    keys[item.category].push(item);
  });
});
const keyAlias = {
  ARROWRIGHT: "\u2192",
  ARROWLEFT: "\u2190",
  ARROWUP: "\u2191",
  ARROWDOWN: "\u2192",
  BACKSPACE: "\u232B",
  CMD: "\u2318"
};
const OSName = os();
class ShortcutWindow extends BaseWindow {
  getClassName() {
    return "elf--shortcut-window";
  }
  getTitle() {
    return "ShortCuts";
  }
  getKeyString(os2, item) {
    return (item[os2] || item.key).split("+").map((it) => it.trim()).map((it) => {
      const keyString = it.toUpperCase();
      return `<span>${keyAlias[keyString] || keyString}</span>`;
    }).join(" + ");
  }
  getTemplateForShortcutItem(item) {
    return `
            <div class='shortcut-view-item'>
                <div class='title'>${item.description}</div>
                <div class='os-item'>${this.getKeyString(OSName, item)}</div>
            </div>                        
        `;
  }
  getTemplateForCategory(category, list2 = []) {
    return `
            <div class='item'>
                <h2>${category}</h2>
                <div>
                    ${list2.map((it) => this.getTemplateForShortcutItem(it)).join("")}
                </div>
            </div>
        `;
  }
  getTemplateForLayer() {
    return `
            <div class='item'>
                <h2>Layer</h2>
                <div>
                    <div class='shortcut-view-item'>
                        <div class='title'>
                            Add Rect
                            <span class='description'>fdsafdsfdf</span>
                        </div>

                        <div class='os-item mac'><span>CTRL</span>+<span>R</span></div>
                        <div class='os-item win'>R</div>
                        <div class='os-item linux'>R</div>
                    </div>
                </div>
            </div>
        `;
  }
  getBody() {
    return `
        <div class="list">
            ${Object.keys(keys).map((category) => {
      return this.getTemplateForCategory(category, keys[category]);
    }).join("")}
        </div>
        `;
  }
  [SUBSCRIBE("showShortcutWindow")]() {
    this.show();
  }
}
registElement({ ShortcutWindow });
class PopupManager extends EditorElement {
  components() {
    return {
      NotificationView
    };
  }
  template() {
    return /* @__PURE__ */ createElementJsx("div", {
      class: "elf--popup-manager"
    }, createComponent("ExportWindow"), createComponent("EmbedEditorWindow"), createComponent("ProjectWindow"), createComponent("ShortcutWindow"), createComponent("NotificationView"), this.$injectManager.generate("popup", true));
  }
}
class BlankEditor extends BaseLayout {
  afterRender() {
    super.afterRender();
    this.$config.init("editor.layout.elements", this.refs);
  }
  components() {
    return {
      BlankLayerTab,
      BlankToolBar,
      BlankInspector,
      BlankBodyPanel,
      PopupManager,
      KeyboardManager,
      IconManager
    };
  }
  getPlugins() {
    return blankEditorPlugins;
  }
  initState() {
    return {
      leftSize: 340,
      rightSize: 280,
      bottomSize: 0,
      lastBottomSize: 150
    };
  }
  template() {
    return `
      <div class="elf-studio blank-editor">
        <div class="layout-main">
          <div class='layout-top' ref='$top'>
            ${createComponent("BlankToolBar")}
          </div>
          <div class="layout-middle" ref='$middle'>      
            <div class="layout-body" ref='$bodyPanel'>
              ${createComponent("BlankBodyPanel")}
            </div>                           
            <div class='layout-left' ref='$leftPanel'>
              ${createComponent("BlankLayerTab")}
            </div>
            <div class="layout-right" ref='$rightPanel'>
              ${createComponent("BlankInspector")}
            </div>
            <div class='splitter' ref='$splitter'></div>            
          </div>
          ${createComponent("KeyboardManager")}
        </div>
        ${createComponent("PopupManager")}
        ${createComponent("IconManager")}
      </div>
    `;
  }
  [BIND("$el")]() {
    return {
      "data-design-mode": this.$config.get("editor.design.mode")
    };
  }
  [BIND("$splitter")]() {
    let left2 = this.state.leftSize;
    if (this.$config.false("show.left.panel")) {
      left2 = 0;
    }
    return {
      style: {
        left: left2
      }
    };
  }
  [BIND("$leftArrow")]() {
    let left2 = this.state.leftSize;
    if (this.$config.false("show.left.panel")) {
      left2 = 0;
    }
    return {
      style: {
        left: left2
      }
    };
  }
  [BIND("$leftPanel")]() {
    let left2 = `0px`;
    let width2 = this.state.leftSize;
    let bottom2 = this.state.bottomSize;
    if (this.$config.false("show.left.panel")) {
      left2 = `-${this.state.leftSize}px`;
    }
    return {
      style: { left: left2, width: width2, bottom: bottom2 }
    };
  }
  [BIND("$rightPanel")]() {
    let right2 = 0;
    let bottom2 = this.state.bottomSize;
    if (this.$config.false("show.right.panel")) {
      right2 = -this.state.rightSize;
    }
    return {
      style: {
        right: right2,
        bottom: bottom2
      }
    };
  }
  [BIND("$bodyPanel")]() {
    let left2 = this.state.leftSize;
    let right2 = this.state.rightSize;
    let bottom2 = this.state.bottomSize;
    if (this.$config.false("show.left.panel")) {
      left2 = 0;
    }
    if (this.$config.false("show.right.panel")) {
      right2 = 0;
    }
    return {
      style: {
        left: left2,
        right: right2,
        bottom: bottom2
      }
    };
  }
  [POINTERSTART("$splitter") + MOVE("moveSplitter") + END("moveEndSplitter")]() {
    this.minSize = this.$theme("left_size");
    this.maxSize = this.$theme("left_max_size");
    this.leftSize = Length.parse(this.refs.$splitter.css("left")).value;
    this.refs.$splitter.addClass("selected");
  }
  moveSplitter(dx) {
    this.setState({
      leftSize: Math.max(Math.min(this.leftSize + dx, this.maxSize), this.minSize)
    });
  }
  moveEndSplitter() {
    this.refs.$splitter.removeClass("selected");
  }
  refresh() {
    this.bindData("$el");
    this.bindData("$splitter");
    this.bindData("$headerPanel");
    this.bindData("$leftPanel");
    this.bindData("$rightPanel");
    this.bindData("$bodyPanel");
    this.emit("resizeEditor");
  }
  [CONFIG("show.left.panel")]() {
    this.refresh();
    this.nextTick(() => {
      this.emit(RESIZE_CANVAS);
    });
  }
  [CONFIG("show.right.panel")]() {
    this.refresh();
    this.nextTick(() => {
      this.emit(RESIZE_CANVAS);
    });
  }
  [CONFIG("editor.design.mode")]() {
    this.bindData("$el");
  }
  [DRAGOVER("$middle") + PREVENT]() {
  }
  [DROP("$middle") + PREVENT]() {
  }
  [SUBSCRIBE(TOGGLE_FULLSCREEN)]() {
    this.$el.toggleFullscreen();
  }
  [SUBSCRIBE("getLayoutElement")](callback) {
    if (isFunction(callback)) {
      callback(this.refs);
    }
  }
}
var layout$4 = "";
class ColorInformation extends EditorElement {
  template() {
    return `
        <div class="information hex">
            <div ref="$informationChange" class="information-change">
                <button ref="$formatChangeButton" type="button" class="format-change-button">
                    ${iconUse("unfold")}
                </button>
            </div>
            <div class="information-item hex">
                <div class="input-field hex">
                    <input ref="$hexCode" class="input" type="text" />
                    <div class="title">HEX</div>
                </div>
            </div>
            <div class="information-item rgb">
                <div class="input-field rgb-r">
                    <input ref="$rgb_r" class="input" type="number" step="1" min="0" max="255" />
                    <div class="title">R</div>
                </div>
                <div class="input-field rgb-g">
                    <input ref="$rgb_g" class="input" type="number" step="1" min="0" max="255" />
                    <div class="title">G</div>
                </div>
                <div class="input-field rgb-b">
                    <input ref="$rgb_b" class="input" type="number" step="1" min="0" max="255" />
                    <div class="title">B</div>
                </div>          
                <div class="input-field rgb-a">
                    <input ref="$rgb_a" class="input" type="number" step="0.01" min="0" max="1" />
                    <div class="title">A</div>
                </div>                                                            
            </div>
            <div class="information-item hsl">
                <div class="input-field hsl-h">
                    <input ref="$hsl_h" class="input" type="number" step="1" min="0" max="360" />
                    <div class="title">H</div>
                </div>
                <div class="input-field hsl-s">
                    <input ref="$hsl_s" class="input" type="number" step="1" min="0" max="100" />
                    <div class="postfix">%</div>
                    <div class="title">S</div>
                </div>
                <div class="input-field hsl-l">
                    <input ref="$hsl_l" class="input" type="number" step="1" min="0" max="100" />
                    <div class="postfix">%</div>                        
                    <div class="title">L</div>
                </div>
                <div class="input-field hsl-a">
                    <input ref="$hsl_a" class="input" type="number" step="0.01" min="0" max="1" />
                    <div class="title">A</div>
                </div>
            </div>
        </div>
        `;
  }
  get manager() {
    return this.parent.manager;
  }
  setCurrentFormat(format2) {
    this.format = format2;
    this.initFormat();
  }
  initFormat() {
    var current_format = this.format || "hex";
    ["hex", "rgb", "hsl"].filter((it) => it !== current_format).forEach((formatString) => {
      this.$el.removeClass(formatString);
    });
    this.$el.addClass(current_format);
  }
  nextFormat() {
    var current_format = this.format || "hex";
    var next_format = "hex";
    if (current_format == "hex") {
      next_format = "rgb";
    } else if (current_format == "rgb") {
      next_format = "hsl";
    } else if (current_format == "hsl") {
      if (this.parent.alpha == 1) {
        next_format = "hex";
      } else {
        next_format = "rgb";
      }
    }
    this.format = next_format;
    this.initFormat();
    this.parent.changeFormat(this.format);
  }
  goToFormat(to_format) {
    this.format = to_format;
    if (to_format === "rgb" || to_format === "hsl") {
      this.initFormat();
    }
    this.parent.changeFormat(this.format);
  }
  getFormat() {
    return this.format || "hex";
  }
  changeRgbColor() {
    this.parent.lastUpdateColor({
      type: "rgb",
      r: this.refs.$rgb_r.int(),
      g: this.refs.$rgb_g.int(),
      b: this.refs.$rgb_b.int(),
      a: this.refs.$rgb_a.float()
    });
  }
  changeHslColor() {
    this.parent.lastUpdateColor({
      type: "hsl",
      h: this.refs.$hsl_h.int(),
      s: this.refs.$hsl_s.int(),
      l: this.refs.$hsl_l.int(),
      a: this.refs.$hsl_a.float()
    });
  }
  hasValue(e) {
    if (e.target.value === "") {
      return false;
    }
    return true;
  }
  [INPUT("$rgb_r") + IF("hasValue")]() {
    this.changeRgbColor();
  }
  [INPUT("$rgb_g") + IF("hasValue")]() {
    this.changeRgbColor();
  }
  [INPUT("$rgb_b") + IF("hasValue")]() {
    this.changeRgbColor();
  }
  [INPUT("$rgb_a") + IF("hasValue")]() {
    this.changeRgbColor();
  }
  [INPUT("$hsl_h") + IF("hasValue")]() {
    this.changeHslColor();
  }
  [INPUT("$hsl_s") + IF("hasValue")]() {
    this.changeHslColor();
  }
  [INPUT("$hsl_l") + IF("hasValue")]() {
    this.changeHslColor();
  }
  [INPUT("$hsl_a") + IF("hasValue")]() {
    this.changeHslColor();
  }
  [KEYUP("$hexCode") + IF("hasValue")]() {
    var code2 = this.refs.$hexCode.val();
    if (code2.charAt(0) == "#" && (code2.length == 7 || code2.length === 9)) {
      this.parent.lastUpdateColor(code2);
    }
  }
  [PASTE("$hexCode") + IF("hasValue")]() {
    var code2 = this.refs.$hexCode.val();
    if (code2.charAt(0) == "#" && (code2.length == 7 || code2.length === 9)) {
      this.parent.lastUpdateColor(code2);
    }
  }
  [CLICK("$formatChangeButton")]() {
    this.nextFormat();
  }
  [CLICK("$el .information-item.hex .input-field .title")]() {
    this.goToFormat("hex");
  }
  [CLICK("$el .information-item.rgb .input-field .title")]() {
    this.goToFormat("hsl");
  }
  [CLICK("$el .information-item.hsl .input-field .title")]() {
    this.goToFormat("rgb");
  }
  setRGBInput() {
    this.refs.$rgb_r.val(this.manager.rgb.r);
    this.refs.$rgb_g.val(this.manager.rgb.g);
    this.refs.$rgb_b.val(this.manager.rgb.b);
    this.refs.$rgb_a.val(this.manager.alpha);
  }
  setHSLInput() {
    this.refs.$hsl_h.val(this.manager.hsl.h);
    this.refs.$hsl_s.val(this.manager.hsl.s);
    this.refs.$hsl_l.val(this.manager.hsl.l);
    this.refs.$hsl_a.val(this.manager.alpha);
  }
  setHexInput() {
    this.refs.$hexCode.val(this.manager.toString("hex"));
  }
  setValue() {
    this.refresh();
  }
  refresh() {
    this.setCurrentFormat(this.manager.format);
    this.setRGBInput();
    this.setHSLInput();
    this.setHexInput();
  }
}
class ColorPalette extends EditorElement {
  initState() {
    return {
      hueColor: "rgba(0, 0, 0, 1)",
      s: 0,
      v: 0
    };
  }
  template() {
    return `
        <div class="color-panel">
            <div ref="$saturation" class="saturation">
                <div ref="$value" class="value">
                    <div ref="$drag_pointer" class="drag-pointer"></div>
                </div>
            </div>        
        </div>        
        `;
  }
  afterRender() {
    this.rect = this.$el.rect();
  }
  [BIND("$el")]() {
    return {
      style: {
        "background-color": this.state.hueColor
      }
    };
  }
  [BIND("$drag_pointer")]() {
    if (!this.rect || this.rect.width === 0) {
      this.rect = this.$el.rect();
    }
    const x = this.rect.width * this.state.s;
    const y = this.rect.height * (1 - this.state.v);
    return {
      style: {
        left: x,
        top: y
      }
    };
  }
  [POINTERSTART("$el") + MOVE("movePointer") + END("moveEndPointer")]() {
    this.rect = this.$el.rect();
    this.refreshColorUI();
  }
  movePointer() {
    this.refreshColorUI();
  }
  moveEndPointer() {
    this.parent.changeEndColor();
  }
  refreshColorUI() {
    const e = this.$config.get("bodyEvent");
    const minX = this.rect.left;
    const maxX = this.rect.right;
    const minY = this.rect.top;
    const maxY = this.rect.bottom;
    const currentX = Math.min(maxX, Math.max(minX, e.clientX));
    const currentY = Math.min(maxY, Math.max(minY, e.clientY));
    const width2 = maxX - minX;
    const height2 = maxY - minY;
    var s = (currentX - minX) / width2;
    var v = (height2 - (currentY - minY)) / height2;
    this.parent.changeColor({
      type: "hsv",
      s,
      v
    });
  }
  setValue(s, v, hueColor) {
    this.setState({
      s,
      v,
      hueColor
    });
  }
}
class ColorView extends EditorElement {
  initState() {
    return {
      value: "rgba(0, 0, 0, 1)"
    };
  }
  template() {
    return `<div class='color'></div>`;
  }
  [BIND("$el")]() {
    return {
      style: {
        "background-color": this.state.value
      }
    };
  }
  setValue(value) {
    this.setState({
      value
    });
  }
}
class Hue extends EditorElement {
  initState() {
    return {
      hue: 0,
      minValue: 0,
      maxValue: 360
    };
  }
  template() {
    return `
            <div class="hue">
                <div ref="$container" class="hue-container">
                    <div ref="$bar" class="drag-bar"></div>
                </div>
            </div>
        `;
  }
  [BIND("$bar")]() {
    const hue = this.state.hue;
    return {
      style: {
        left: Length.makePercent(hue, 360)
      },
      class: {
        first: hue <= this.state.minValue,
        last: hue >= this.state.maxValue
      }
    };
  }
  [POINTERSTART("$container") + MOVE("movePointer") + END("moveEndPointer")]() {
    this.rect = this.refs.$container.rect();
    this.refreshColorUI();
  }
  movePointer() {
    this.refreshColorUI();
  }
  refreshColorUI() {
    const minX = this.rect.left;
    const maxX = this.rect.right;
    const currentX = Math.max(Math.min(maxX, this.$config.get("bodyEvent").clientX), minX);
    const rate = (currentX - minX) / (maxX - minX);
    this.parent.changeColor({
      h: rate * this.state.maxValue,
      type: "hsv"
    });
  }
  setValue(hue) {
    this.setState({
      hue
    });
  }
}
class Opacity extends EditorElement {
  initState() {
    return {
      colorbar: parse("rgba(0, 0, 0, 1)"),
      opacity: 0,
      minValue: 0,
      maxValue: 100
    };
  }
  template() {
    return `
        <div class="opacity">
            <div ref="$container" class="opacity-container">
                <div ref="$colorbar" class="color-bar"></div>
                <div ref="$bar" class="drag-bar2"></div>
            </div>
        </div>
        `;
  }
  [BIND("$colorbar")]() {
    const rgb2 = clone$1(this.state.colorbar);
    rgb2.a = 0;
    const start2 = format(rgb2, "rgb");
    rgb2.a = 1;
    const end2 = format(rgb2, "rgb");
    return {
      style: {
        background: `linear-gradient(to right, ${start2}, ${end2})`
      }
    };
  }
  [BIND("$bar")]() {
    const opacity2 = this.state.opacity * 100;
    return {
      style: {
        left: Length.percent(opacity2)
      },
      class: {
        first: opacity2 <= this.state.minValue,
        last: opacity2 >= this.state.maxValue
      }
    };
  }
  [POINTERSTART("$container") + MOVE("movePointer") + END("moveEndPointer")]() {
    this.rect = this.refs.$container.rect();
    this.refreshColorUI();
  }
  movePointer() {
    this.refreshColorUI();
  }
  refreshColorUI() {
    const minX = this.rect.left;
    const maxX = this.rect.right;
    const currentX = Math.max(Math.min(maxX, this.$config.get("bodyEvent").clientX), minX);
    const rate = (currentX - minX) / (maxX - minX);
    this.parent.changeColor({
      a: rate.toFixed(2)
    });
  }
  setValue(colorbar, opacity2) {
    this.setState({
      opacity: opacity2,
      colorbar
    });
  }
}
class ColorManagerV2 {
  constructor() {
    this.initialize();
  }
  initialize() {
    this.state = {
      rgb: {},
      hsl: {},
      hsv: {},
      alpha: 1,
      format: "hex"
    };
  }
  get hsv() {
    return this.state.hsv;
  }
  get rgb() {
    return this.state.rgb;
  }
  get hsl() {
    return this.state.hsl;
  }
  get hex() {
    return this.state.hex;
  }
  get alpha() {
    if (typeof this.state.alpha === "undefined")
      return 1;
    return this.state.alpha;
  }
  get format() {
    return this.state.format;
  }
  changeFormat(format2) {
    this.state.format = format2;
  }
  initColor(colorObj) {
    this.changeColor(colorObj);
  }
  changeColor(colorObj) {
    colorObj = colorObj || "#FF0000";
    if (typeof colorObj === "string") {
      colorObj = parse(colorObj);
    }
    this.state.alpha = typeof colorObj.a !== "undefined" ? colorObj.a : this.state.alpha;
    this.state.format = colorObj.type != "hsv" ? colorObj.type || this.state.format : this.state.format;
    if (colorObj.type == "hsl") {
      this.state.hsl = __spreadValues(__spreadValues({}, this.state.hsl), colorObj);
      this.state.rgb = HSLtoRGB(this.state.hsl);
      this.state.hsv = HSLtoHSV(colorObj);
    } else if (colorObj.type == "hex") {
      this.state.rgb = __spreadValues(__spreadValues({}, this.state.rgb), colorObj);
      this.state.hsl = RGBtoHSL(this.state.rgb);
      this.state.hsv = RGBtoHSV(colorObj);
    } else if (colorObj.type == "rgb") {
      this.state.rgb = __spreadValues(__spreadValues({}, this.state.rgb), colorObj);
      this.state.hsl = RGBtoHSL(this.state.rgb);
      this.state.hsv = RGBtoHSV(colorObj);
    } else if (colorObj.type == "hsv") {
      this.state.hsv = __spreadValues(__spreadValues({}, this.state.hsv), colorObj);
      this.state.rgb = HSVtoRGB(this.state.hsv);
      this.state.hsl = HSVtoHSL(this.state.hsv);
    }
  }
  getHueColor() {
    return checkHueColor(this.state.hsv.h / 360);
  }
  toString(type) {
    type = type || this.state.format;
    var colorObj = this.state[type] || this.state.rgb;
    return format(__spreadProps(__spreadValues({}, colorObj), { a: this.state.alpha }), type);
  }
  toColor(type) {
    type = (type || this.state.format).toLowerCase();
    return this.toString(type);
  }
}
class ColorPickerEditor extends EditorElement {
  created() {
    this.manager = new ColorManagerV2();
  }
  initState() {
    const value = this.props.value || "rgba(0, 0, 0, 1)";
    this.manager.initColor(value);
    return {
      key: this.props.key,
      value: this.manager.toString()
    };
  }
  updateData(opt = {}) {
    this.setState(opt, false);
    this.modifyColorPicker();
  }
  modifyColorPicker() {
    this.parent.trigger(this.props.onchange, this.props.key, this.state.value, this.props.params);
  }
  initColor(newColor, format2) {
    this.manager.changeColor(newColor, format2);
    this.refresh();
  }
  changeColor(newColor, format2) {
    this.manager.changeColor(newColor, format2);
    this.refresh();
    this.updateData({
      value: this.manager.toColor()
    });
  }
  [SUBSCRIBE_SELF("selectColorAssets")](key, color2) {
    this.lastUpdateColor(color2);
  }
  changeFormat(format2) {
    this.manager.changeFormat(format2);
    this.setState({
      value: this.manager.toColor()
    }, false);
    this.modifyColorPicker();
    this.changeEndColor();
  }
  lastUpdateColor(newColor, format2) {
    this.manager.changeColor(newColor, format2);
    this.refresh();
    this.setState({
      value: this.manager.toColor()
    }, false);
    this.modifyColorPicker();
    this.changeEndColor();
  }
  changeEndColor() {
    this.parent.trigger(this.props.onchangeend, this.props.key, this.state.value, this.props.params);
  }
  refresh() {
    const color2 = this.manager.toColor();
    this.children.$palette.setValue(this.manager.hsv.s, this.manager.hsv.v, this.manager.getHueColor());
    this.children.$opacity.setValue(this.manager.rgb, this.manager.alpha);
    this.children.$hue.setValue(this.manager.hsv.h);
    this.children.$colorview.setValue(color2);
    this.children.$information.setValue();
  }
  components() {
    return {
      Hue,
      Opacity,
      ColorView,
      Palette: ColorPalette,
      ColorInformation
    };
  }
  template() {
    return `
        <div class='colorpicker sketch inline'>
            <div class='colorpicker-body'>
                ${createComponent("Palette", { ref: "$palette" })}
                <div class="control">
                    ${createComponent("Hue", { ref: "$hue" })}
                    ${createComponent("Opacity", { ref: "$opacity" })}
                    <div class="empty"></div>
                    ${createComponent("ColorView", {
      ref: "$colorview"
    })}                    
                </div>
                ${createComponent("ColorInformation", {
      ref: "$information"
    })}                
                ${this.$context.injectManager.generate("colorpicker")}
                ${createComponent("ColorAssetsEditor", {
      ref: "$colorAsset",
      key: "colorAssets",
      onchange: "selectColorAssets"
    })}
            </div>
        </div>
      `;
  }
}
var ColorPickerPopup$1 = "";
var BasePopup$1 = "";
class BasePopup extends EditorElement {
  template() {
    return `
        <div class='elf--popup ${this.getClassName()}'>
            <div class='popup-title' ref="$title">
                <label>${this.getTitle()}</label>
                <span class="tools">
                  ${this.getTools()}
                  <button type='button' class='close' ref='$close'>${iconUse("close")}</button>
                </span>
            </div>
            <div class='popup-body'>${this.getBody()}</div>
            <!--<div class='popup-resizer' ref='$resizer'></div> -->
        </div>
        `;
  }
  getClassName() {
    return "";
  }
  getTitle() {
    return "";
  }
  getTools() {
    return "";
  }
  getBody() {
    return "";
  }
  onClose() {
  }
  [CLICK("$close")]() {
    this.$el.hide();
    this.onClose();
  }
  setTitle(title2) {
    this.refs.$title.$("label").text(title2);
  }
  [POINTERSTART("$title") + MOVE("movePopupTitle") + END("endPopupTitle")]() {
    this.x = Length.parse(this.$el.css("left"));
    this.y = Length.parse(this.$el.css("top"));
  }
  movePopupTitle(dx, dy) {
    var left2 = Length.px(this.x.value + dx);
    var top2 = Length.px(this.y.value + dy);
    this.$el.css({ left: left2, top: top2, right: "auto", bottom: "auto" });
  }
  show(width2 = 200) {
    var popupPadding = 28;
    var rightPosition = 320;
    var top2 = this.$el.css("top");
    var left2 = this.$el.css("left");
    var realTop = top2 !== "auto" ? Length.parse(top2) : 110;
    var realLeft = left2 !== "auto" ? Length.parse(left2) : document.body.clientWidth - rightPosition - popupPadding - width2;
    this.$el.css({
      top: Length.px(realTop),
      left: Length.px(realLeft),
      "z-index": this.$editor.zIndex
    }).show("inline-block");
  }
  makeRect(width2, height2, rect2) {
    const elements = this.$config.get("editor.layout.elements");
    const bodyRect = elements.$bodyPanel.rect();
    let left2 = bodyRect.left + bodyRect.width - width2 - 10;
    let top2 = rect2.top + height2 > bodyRect.top + bodyRect.height ? bodyRect.top + bodyRect.height - height2 - 10 : rect2.top;
    if (top2 < 10) {
      top2 = 10;
    }
    return {
      top: top2,
      left: left2,
      width: width2,
      height: height2
    };
  }
  showByRect(rect2) {
    this.$el.css({
      top: Length.px(rect2.top),
      left: Length.px(rect2.left),
      width: Length.px(rect2.width),
      height: Length.px(rect2.height),
      "z-index": this.$editor.zIndex
    }).show("inline-block");
  }
  hide() {
    this.$el.hide();
  }
  [SUBSCRIBE("hidePropertyPopup")]() {
    this.hide();
  }
  [POINTERSTART("$resizer") + MOVE("moveResizer")]() {
    this.width = Length.parse(this.$el.css("width"));
    this.height = Length.parse(this.$el.css("height"));
  }
  moveResizer(dx, dy) {
    this.$el.css({
      width: Math.min(this.width + dx, 1e3),
      height: Math.min(this.height + dy, 700)
    });
  }
}
class ColorPickerPopup extends BasePopup {
  getTitle() {
    return this.$i18n("colorpicker.popup.title");
  }
  getClassName() {
    return "compact elf--colorpicker-popup";
  }
  initState() {
    return {
      color: "rgba(0, 0, 0, 1)"
    };
  }
  updateData(opt = {}) {
    this.setState(opt, false);
    if (this.state.target) {
      this.state.target.trigger(this.state.changeEvent, this.state.color, this.params);
    }
  }
  updateEndData(opt = {}) {
    this.setState(opt, false);
    if (this.state.target) {
      this.state.target.trigger(this.state.changeEndEvent, this.state.color, this.params);
    }
  }
  getBody() {
    return `
    <div>
      <div class='box'>
        ${createComponent("EmbedColorPicker", {
      ref: "$color",
      value: this.state.color,
      onchange: (color2) => this.updateData({ color: color2 }),
      onchangeend: (color2) => this.updateEndData({ color: color2 })
    })}
    </div>
  `;
  }
  [LOAD("$projectColors")]() {
    var project2 = this.$context.selection.currentProject || { colors: [] };
    var colors2 = project2.colors;
    return colors2.map((color2) => {
      return `
      <div class='color-item' title='${color2.name}'>
        <div class='color-view' data-color='${color2.color}' style='background-color: ${color2.color}'></div>
      </div>`;
    });
  }
  [CLICK("$projectColors .color-view")](e) {
    this.updateData({
      color: e.$dt.attr("data-color")
    });
    this.children.$color.setValue(this.state.color);
  }
  [SUBSCRIBE("showColorPickerPopup")](data, params, rect2) {
    data.changeEvent = data.changeEvent || "changeFillPopup";
    if (!(data.target instanceof UIElement)) {
      throw new Error("ColorPicker needs data.target");
    }
    this.params = params;
    this.setState(data, false);
    this.children.$color.setValue(this.state.color);
    this.showByRect(this.makeRect(245, 500, rect2));
  }
  [SUBSCRIBE("hideColorPickerPopup")]() {
    this.hide();
  }
}
class EmbedColorPicker extends EditorElement {
  initState() {
    return {
      value: this.props.value || "rgba(0, 0, 0, 1)"
    };
  }
  template() {
    return `
        <div class='embed-color-picker'>
          ${createComponent("ColorPickerEditor", {
      ref: "$colorpicker",
      key: "colorpicker",
      value: this.state.value,
      onchange: "localChangeColor",
      onchangeend: "localLastUpdate"
    })}
        </div>
      `;
  }
  [SUBSCRIBE_SELF("localChangeColor")](key, color2) {
    this.parent.trigger(this.props.onchange, color2);
  }
  [SUBSCRIBE_SELF("localLastUpdate")](key, color2) {
    this.parent.trigger(this.props.onchangeend, color2);
  }
  setValue(color2) {
    this.state.value = color2;
    this.children.$colorpicker.initColor(color2);
  }
  refresh() {
    this.children.$colorpicker.initColor(this.props.value);
  }
}
function color(editor) {
  editor.registerElement({
    ColorPickerEditor,
    EmbedColorPicker
  });
  editor.registerUI("popup", {
    ColorPickerPopup
  });
}
var dataEditorPlugins = [
  defaultConfigs,
  defaultIcons,
  defaultMessages,
  baseEditor,
  propertyEditor,
  color
];
class DataEditor extends BaseLayout {
  components() {
    return {
      PopupManager,
      KeyboardManager,
      IconManager
    };
  }
  getPlugins() {
    return dataEditorPlugins;
  }
  createEditorInstance() {
    return new Editor({
      ignoreManagers: ["ShortCutManager"]
    });
  }
  afterRender() {
    super.afterRender();
    this.$config.init("editor.layout.elements", this.refs);
  }
  initState() {
    return {
      inspector: this.props.inspector || [],
      onChange: this.props.onChange || (() => true),
      open: isBoolean(this.props.open) && this.props.open === false ? false : true,
      leftSize: 340,
      rightSize: 280,
      bottomSize: 0,
      lastBottomSize: 150
    };
  }
  template() {
    return `
      <div class="elf-studio dataeditor" ref="$bodyPanel">
        <div class="layout-main" ref="$main">
            <div class='control-view' ref="$body"></div>
            <div class='close' ref="$close">Close Controls</div>        
        </div>

        ${createComponent("KeyboardManager")}        
        ${createComponent("PopupManager")}
        ${createComponent("IconManager")}
      </div>
    `;
  }
  [CLICK("$close")]() {
    this.setState({
      open: !this.state.open
    }, false);
    this.bindData("$main");
    this.bindData("$close");
  }
  [BIND("$main")]() {
    return {
      "data-open-status": this.state.open
    };
  }
  [BIND("$close")]() {
    return {
      text: this.state.open ? "Close Controls" : "Open Controls"
    };
  }
  [LOAD("$body")]() {
    const inspector = this.state.inspector;
    return createComponent("ComponentEditor", {
      ref: "$comp",
      inspector,
      onchange: "changeComponent"
    });
  }
  getValue() {
    return this.children.$comp.getValue();
  }
  [SUBSCRIBE_SELF("changeComponent")](key, value) {
    if (isFunction(this.state.onChange)) {
      this.emit(this.state.onChange, this, key, value);
    }
  }
}
var layout$3 = "";
class ClipboardManager {
  constructor(editor) {
    this.editor = editor;
    this.clipboard = [];
  }
  get length() {
    return this.clipboard.length;
  }
  clear() {
    this.clipboard = [];
  }
  get isEmpty() {
    return this.clipboard.length == 0;
  }
  get last() {
    return this.clipboard[this.clipboard.length - 1];
  }
  push(data) {
    this.clipboard.push(data);
  }
  pop() {
    return this.clipboard.pop();
  }
}
class HistoryManager {
  constructor(editor) {
    this.$editor = editor;
    this.$context = editor.context;
    this.currentIndex = -1;
    this.undoHistories = [];
    this.redoHistories = [];
    this.selection = {};
  }
  get length() {
    return this.undoHistories.length;
  }
  get selectedIds() {
    return Object.keys(this.selection);
  }
  createCommand(commandString) {
    return this.$context.stateManager.isPointerUp ? `history.${commandString}` : commandString;
  }
  saveSelection(obj2 = {}) {
    this.selection = this.$editor.context.selection.toCloneObject();
  }
  getUndoValues(multiAttrs = {}) {
    let result = {};
    Object.keys(multiAttrs).forEach((id) => {
      result[id] = {};
      const selectedObject = this.selection[id] || this.$editor.context.selection.itemsByIds(id)[0];
      const attrs = multiAttrs[id];
      Object.keys(attrs).forEach((key) => {
        result[id][key] = selectedObject[key];
      });
    });
    return result;
  }
  add(message, command, data) {
    const time = window.performance.now();
    const lastUndoObject = this.undoHistories[this.undoHistories.length - 1];
    const historyObject = { message, command, data, time };
    if (lastUndoObject && lastUndoObject.message === message && time - lastUndoObject.time < this.$editor.context.config.get("history.delay.ms")) {
      this.undoHistories[this.undoHistories.length - 1] = historyObject;
    } else {
      this.undoHistories.push(historyObject);
      this.currentIndex++;
      this.undoHistories.length = this.currentIndex + 1;
    }
    this.$context.commands.emit("refreshHistory", command.command);
    this.$editor.emit("refreshHistoryList");
    return historyObject;
  }
  map(callback) {
    let results = [
      ...this.undoHistories.map(callback),
      "-",
      ...this.redoHistories.map(callback)
    ].reverse();
    return results;
  }
  undo() {
    if (this.currentIndex < -1)
      return;
    if (this.currentIndex === this.length) {
      this.currentIndex--;
    }
    const commandObject = this.undoHistories[this.currentIndex];
    if (commandObject && commandObject.command) {
      commandObject.command.undo(this.$editor, commandObject.data);
      this.currentIndex--;
      this.$editor.nextTick(() => {
        this.$context.commands.emit("refreshHistory", commandObject.command);
        this.$editor.emit("refreshHistoryList");
      });
    }
  }
  redo() {
    if (this.currentIndex > this.length)
      return;
    if (this.currentIndex < 0) {
      this.currentIndex++;
    }
    const commandObject = this.undoHistories[this.currentIndex];
    if (commandObject && commandObject.command) {
      this.currentIndex++;
      commandObject.command.redo(this.$editor, commandObject.data);
      this.$editor.debug(commandObject);
      this.$editor.nextTick(() => {
        this.$context.commands.emit("refreshHistory", commandObject.command);
        this.$editor.emit("refreshHistoryList");
      });
    }
  }
}
class LockManager {
  constructor(editor) {
    this.editor = editor;
    this.lockList = {};
  }
  get(key) {
    return this.lockList[key];
  }
  set(key, value) {
    this.lockList[key] = true;
  }
  toggle(key) {
    if (this.lockList[key]) {
      delete this.lockList[key];
    } else {
      this.lockList[key] = true;
    }
  }
}
const identity$1 = () => true;
class ModelManager {
  constructor(editor) {
    this.editor = editor;
    this.context = this.editor.context;
    this.version = "0.0.0";
    this.name = "";
    this.description = "";
    this.items = /* @__PURE__ */ new Map();
    this.projects = [];
  }
  load(doc2 = void 0, context = { origin: "*" }) {
    var _a;
    const newDoc = doc2 || this.editor.loadItem("model");
    this.items.clear();
    this.version = newDoc == null ? void 0 : newDoc.version;
    this.name = newDoc == null ? void 0 : newDoc.name;
    this.description = newDoc == null ? void 0 : newDoc.description;
    (_a = newDoc == null ? void 0 : newDoc.projects) == null ? void 0 : _a.forEach((project2) => {
      this.createModel(project2);
    });
    if (this.projects.length === 0) {
      this.createProject();
    }
  }
  createProject() {
    this.createModel({
      itemType: "project",
      name: "New Project"
    });
  }
  getProjectByIndex(index2 = 0) {
    return this.get(this.projects[index2]);
  }
  get(id) {
    return this.items.get(id);
  }
  set(id, item) {
    this.items.set(id, item);
    this.setChanged("set", id, item);
  }
  remove(id) {
    const obj2 = this.items.get(id);
    const children2 = obj2.parent.children;
    const index2 = children2.indexOf(id);
    obj2.reset({
      removed: true,
      removedIndex: index2,
      removedLeftSibling: index2 > 0 ? children2[index2 - 1] : null,
      removedRightSibling: index2 < children2.length - 1 ? children2[index2 + 1] : null
    });
    this.setChanged("remove", id);
  }
  recover(id) {
    const obj2 = this.items.get(id);
    const parent = this.getParent(id);
    if (!obj2.get("removedLeftSibling") && obj2.get("removedRightSibling")) {
      parent.children.splice(parent.children.findIndex(() => obj2.get("removedRightSibling")) - 1, 0, id);
    } else if (obj2.get("removedLeftSibling") && !obj2.get("removedRightSibling")) {
      parent.children.splice(parent.children.findIndex(() => obj2.get("removedLeftSibling")) + 1, 0, id);
    } else {
      parent.children.splice(obj2.get("removedIndex"), 0, id);
    }
    obj2.removeField("removed");
    obj2.removeField("removedLeftSibling");
    obj2.removeField("removedRightSibling");
    obj2.removeField("removedIndex");
    this.setChanged("recover", id);
  }
  clear() {
    this.items.clear();
  }
  toJSON() {
    return {
      version: this.version,
      name: this.name,
      description: this.description,
      projects: this.projects.map((id) => {
        return this.get(id).toJSON();
      })
    };
  }
  setChanged(type, id, obj2) {
    this.editor.emit("changed", type, id, obj2);
  }
  removeChild(rootId, childId) {
    const obj2 = this.get(rootId);
    obj2.reset({
      children: obj2.children.filter((it) => it !== childId)
    });
    this.setChanged("removeChild", rootId, { childId });
  }
  hasParent(rootId, parentId) {
    const obj2 = this.get(rootId);
    const isParent = obj2.parentId === parentId;
    if (!isParent && obj2.parent.is("project") === false)
      return this.hasParent(obj2.parentId, parentId);
    return isParent;
  }
  get components() {
    return this.context.components;
  }
  searchItem(id) {
    return this.get(id);
  }
  searchLayers(rootId, childId) {
    const obj2 = this.get(rootId);
    return this.get(obj2.children.find((it) => it === childId));
  }
  searchItemsById(ids) {
    return ids.map((id) => this.get(id));
  }
  hasPathOf(targetItems, searchItem) {
    const path = this.getPath(searchItem.id, searchItem);
    return targetItems.filter((it) => it.id !== searchItem.id).some((target) => {
      return path.find((it) => it.id === target.id);
    });
  }
  findGroupItem(rootId) {
    const obj2 = this.get(rootId);
    if (obj2.hasChildren()) {
      return obj2;
    }
    if (obj2.parent && (obj2.parent.is("project") || obj2.parent.is("artboard") || obj2.isBooleanItem)) {
      return obj2;
    }
    return obj2.parent && this.findGroupItem(obj2.parentId);
  }
  convertGroupItems(items) {
    const objectList = {};
    items.forEach((item) => {
      if (item.parent && item.isNot("project") && item.parent.hasLayout()) {
        const groupItem = item.parent;
        objectList[groupItem.id] = groupItem;
      } else {
        const groupItem = this.findGroupItem(item.id) || item;
        objectList[groupItem.id] = groupItem;
      }
    });
    return Object.values(objectList).filter((it) => it.isNot("project"));
  }
  searchLiveItemsById(ids) {
    return ids.map((id) => this.get(id)).filter((it) => !it.removed);
  }
  markRemove(ids = []) {
    ids.forEach((id) => {
      this.remove(id);
    });
    this.setChanged("markRemove", ids, { isLayer: true });
  }
  markRemoveProject(id) {
    const index2 = this.projects.findIndex((it) => it === id);
    this.projects.splice(index2, 1);
    this.get(id).removed = true;
    this.setChanged("markRemoveProject", [id], { isProject: true });
    return index2;
  }
  unmarkRemove(ids = []) {
    ids.forEach((id) => {
      this.recover(id);
    });
    this.setChanged("unmarkRemove", ids, { isLayer: true });
  }
  unmarkRemoveProject(id, index2) {
    this.projects.splice(index2, 0, id);
    this.get(id).removed = false;
    this.setChanged("unmarkRemoveProject", [id], {
      removed: true,
      isProject: true
    });
  }
  createModel(itemObject, isRegister = true, context = { origin: "*" }) {
    const layers2 = itemObject.layers;
    delete itemObject.layers;
    let item;
    if (this.get(itemObject.id)) {
      item = this.get(itemObject.id);
      item.reset(itemObject);
    } else {
      item = this.components.createComponent(itemObject.itemType, __spreadValues({}, itemObject));
      item.setModelManager(this);
    }
    if (isRegister) {
      this.set(item.id, item);
      if (item.is("project")) {
        this.projects = [.../* @__PURE__ */ new Set([...this.projects, item.id])];
      }
    }
    const children2 = (layers2 || []).map((it) => {
      return this.createModel(__spreadProps(__spreadValues({}, it), { parentId: item.id }), true, context);
    });
    if (children2.length) {
      item.reset({
        children: children2.map((it) => {
          return it.id;
        })
      }, context);
    }
    return item;
  }
  getAllLayers(rootId, filterCallback = identity$1) {
    var results = [];
    const obj2 = this.get(rootId);
    let len2 = obj2.children.length;
    for (let start2 = len2; start2--; ) {
      let id = obj2.children[start2];
      results.push(...this.getAllLayers(id, filterCallback));
    }
    if (isFunction(filterCallback) && filterCallback(obj2)) {
      results.push(obj2);
    }
    return results;
  }
  getLayers(rootId) {
    var _a;
    const obj2 = this.get(rootId);
    return ((_a = obj2 == null ? void 0 : obj2.children) == null ? void 0 : _a.map((childId) => this.get(childId))) || [];
  }
  eachLayers(rootId, callback) {
    const obj2 = this.get(rootId);
    let len2 = obj2.children.length;
    for (let start2 = len2; start2--; ) {
      let id = obj2.children[start2];
      callback(this.get(id));
    }
  }
  mapLayers(rootId, callback) {
    const obj2 = this.get(rootId);
    return obj2.children.map((childId) => {
      return callback(this.get(childId));
    });
  }
  getParent(rootId) {
    var _a;
    return this.get((_a = this.get(rootId)) == null ? void 0 : _a.parentId);
  }
  getDepth(rootId) {
    const parent = this.getParent(rootId);
    if (!parent)
      return 1;
    return this.getDepth(parent.id) + 1;
  }
  getRoot(rootId) {
    const obj2 = this.get(rootId);
    const parent = this.getParent(rootId);
    if (!parent)
      return obj2;
    let localParent = parent;
    do {
      const nextParent = this.getParent(localParent.id);
      if (!nextParent) {
        return localParent;
      }
      localParent = nextParent;
    } while (localParent);
  }
  getPath(rootId, defaultRef = null) {
    const obj2 = this.get(rootId) || defaultRef;
    const parent = this.getParent(rootId);
    if (!parent)
      return [obj2];
    const list2 = this.getPath(parent.id);
    list2.push(obj2);
    return list2;
  }
  getModelTypeInPath(rootId, itemType) {
    return this.getPath(rootId).find((it) => it && it.is(itemType));
  }
  getItemInPath(rootId, targetId) {
    return this.getPath(rootId).find((it) => it && it.id === targetId);
  }
  getProject(rootId) {
    return this.getModelTypeInPath(rootId, "project");
  }
  getArtBoard(rootId) {
    return this.getModelTypeInPath(rootId, "artboard");
  }
  is(rootId, checkItemType) {
    const obj2 = this.get(rootId);
    return checkItemType === obj2.itemType;
  }
  isNot(rootId, checkItemType) {
    return this.is(rootId, checkItemType) === false;
  }
  attrs(rootId, ...args2) {
    const obj2 = this.get(rootId);
    const result = {};
    args2.forEach((field) => {
      result[field] = clone$1(obj2[field]);
    });
    return result;
  }
  hasChildren(rootId) {
    var _a;
    return ((_a = this.get(rootId)) == null ? void 0 : _a.children.length) > 0;
  }
  clone(rootId, isDeep = true) {
    const obj2 = this.get(rootId);
    const json = obj2.toCloneObject(isDeep);
    const item = this.createModel(json);
    item.setParentId(obj2.parentId);
    return item;
  }
  reset(rootId, obj2) {
    var _a;
    return (_a = this.get(rootId)) == null ? void 0 : _a.reset(obj2);
  }
  replaceByType(rootId, itemType) {
    const item = this.get(rootId);
    if (item) {
      const json = item.toCloneObject(false);
      delete json.itemType;
      const newInstance = this.components.createComponent(itemType, json);
      newInstance.setModelManager(this);
      this.set(rootId, newInstance);
    }
  }
}
var pathkit = { exports: {} };
var __viteBrowserExternal = {};
var __viteBrowserExternal$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": __viteBrowserExternal
}, Symbol.toStringTag, { value: "Module" }));
var require$$0 = /* @__PURE__ */ getAugmentedNamespace(__viteBrowserExternal$1);
(function(module, exports) {
  var PathKitInit2 = function() {
    var _scriptDir = typeof document !== "undefined" && document.currentScript ? document.currentScript.src : void 0;
    if (typeof __filename !== "undefined")
      _scriptDir = _scriptDir || __filename;
    return function(PathKitInit3) {
      PathKitInit3 = PathKitInit3 || {};
      var d;
      d || (d = typeof PathKitInit3 !== "undefined" ? PathKitInit3 : {});
      var aa;
      d.ready = new Promise(function(a) {
        aa = a;
      });
      (function(a) {
        var b = {};
        a.loadCmdsTypedArray = function(h) {
          for (var k = 0, l = 0; l < h.length; l++)
            k += h[l].length;
          if (b[k])
            var n = b[k];
          else
            n = new Float32Array(k), b[k] = n;
          var p = 0;
          for (l = 0; l < h.length; l++)
            for (var q = 0; q < h[l].length; q++) {
              var t = h[l][q];
              typeof t === "string" && (t = a.SkBits2FloatUnsigned(parseInt(t)));
              n[p] = t;
              p++;
            }
          h = a._malloc(n.length * n.BYTES_PER_ELEMENT);
          a.HEAPF32.set(n, h / n.BYTES_PER_ELEMENT);
          return [h, k];
        };
        a.FromCmds = function(h) {
          h = a.loadCmdsTypedArray(h);
          var k = a._FromCmds(h[0], h[1]);
          a._free(h[0]);
          return k;
        };
        var c2, e, f, g, m;
        a.cubicYFromX = function(h, k, l, n, p) {
          c2 && e === h && f === k && g === l && m === n || (c2 && c2.delete(), c2 = new a._SkCubicMap([h, k], [l, n]), e = h, f = k, g = l, m = n);
          return c2.computeYFromX(p);
        };
        a.cubicPtFromT = function(h, k, l, n, p) {
          c2 && e === h && f === k && g === l && m === n || (c2 && c2.delete(), c2 = new a._SkCubicMap([h, k], [l, n]), e = h, f = k, g = l, m = n);
          return c2.computePtFromT(p);
        };
      })(d);
      (function(a) {
        a.onRuntimeInitialized = function() {
          a.SkPath.prototype.addPath = function() {
            var b = arguments[0];
            if (arguments.length === 1)
              this._addPath(b, 1, 0, 0, 0, 1, 0, 0, 0, 1);
            else if (arguments.length === 2) {
              var c2 = arguments[1];
              this._addPath(b, c2.a, c2.c, c2.e, c2.b, c2.d, c2.f, 0, 0, 1);
            } else if (arguments.length === 7)
              c2 = arguments, this._addPath(b, c2[1], c2[3], c2[5], c2[2], c2[4], c2[6], 0, 0, 1);
            else if (arguments.length === 10)
              c2 = arguments, this._addPath(b, c2[1], c2[2], c2[3], c2[4], c2[5], c2[6], c2[7], c2[8], c2[9]);
            else
              return console.Fb("addPath expected to take 1, 2, 7, or 10 args. Got " + arguments.length), null;
            return this;
          };
          a.SkPath.prototype.arc = function(b, c2, e, f, g, m) {
            this._arc(b, c2, e, f, g, !!m);
            return this;
          };
          a.SkPath.prototype.arcTo = function(b, c2, e, f, g) {
            this._arcTo(b, c2, e, f, g);
            return this;
          };
          a.SkPath.prototype.bezierCurveTo = function(b, c2, e, f, g, m) {
            this._cubicTo(b, c2, e, f, g, m);
            return this;
          };
          a.SkPath.prototype.close = function() {
            this._close();
            return this;
          };
          a.SkPath.prototype.closePath = function() {
            this._close();
            return this;
          };
          a.SkPath.prototype.conicTo = function(b, c2, e, f, g) {
            this._conicTo(b, c2, e, f, g);
            return this;
          };
          a.SkPath.prototype.cubicTo = function(b, c2, e, f, g, m) {
            this._cubicTo(b, c2, e, f, g, m);
            return this;
          };
          a.SkPath.prototype.dash = function(b, c2, e) {
            return this._dash(b, c2, e) ? this : null;
          };
          a.SkPath.prototype.ellipse = function(b, c2, e, f, g, m, h, k) {
            this._ellipse(b, c2, e, f, g, m, h, !!k);
            return this;
          };
          a.SkPath.prototype.lineTo = function(b, c2) {
            this._lineTo(b, c2);
            return this;
          };
          a.SkPath.prototype.moveTo = function(b, c2) {
            this._moveTo(b, c2);
            return this;
          };
          a.SkPath.prototype.op = function(b, c2) {
            return this._op(b, c2) ? this : null;
          };
          a.SkPath.prototype.quadraticCurveTo = function(b, c2, e, f) {
            this._quadTo(b, c2, e, f);
            return this;
          };
          a.SkPath.prototype.quadTo = function(b, c2, e, f) {
            this._quadTo(b, c2, e, f);
            return this;
          };
          a.SkPath.prototype.rect = function(b, c2, e, f) {
            this._rect(b, c2, e, f);
            return this;
          };
          a.SkPath.prototype.simplify = function() {
            return this._simplify() ? this : null;
          };
          a.SkPath.prototype.stroke = function(b) {
            b = b || {};
            b.width = b.width || 1;
            b.miter_limit = b.miter_limit || 4;
            b.cap = b.cap || a.StrokeCap.BUTT;
            b.join = b.join || a.StrokeJoin.MITER;
            return this._stroke(b) ? this : null;
          };
          a.SkPath.prototype.transform = function() {
            if (arguments.length === 1)
              this._transform(arguments[0]);
            else if (arguments.length === 9) {
              var b = arguments;
              this._transform(b[0], b[1], b[2], b[3], b[4], b[5], b[6], b[7], b[8]);
            } else
              return console.Fb("transform expected to take 1 or 9 arguments. Got " + arguments.length), null;
            return this;
          };
          a.SkPath.prototype.trim = function(b, c2, e) {
            return this._trim(b, c2, !!e) ? this : null;
          };
        };
      })(d);
      var r = {}, v;
      for (v in d)
        d.hasOwnProperty(v) && (r[v] = d[v]);
      var ba = false, w = false, ca = false, da = false;
      ba = typeof window === "object";
      w = typeof importScripts === "function";
      ca = typeof process === "object" && typeof process.versions === "object" && typeof process.versions.node === "string";
      da = !ba && !ca && !w;
      var x = "", ea, fa, ha, ia;
      if (ca)
        x = w ? require$$0.dirname(x) + "/" : __dirname + "/", ea = function(a, b) {
          ha || (ha = require$$0);
          ia || (ia = require$$0);
          a = ia.normalize(a);
          return ha.readFileSync(a, b ? null : "utf8");
        }, fa = function(a) {
          a = ea(a, true);
          a.buffer || (a = new Uint8Array(a));
          assert(a.buffer);
          return a;
        }, 1 < process.argv.length && process.argv[1].replace(/\\/g, "/"), process.argv.slice(2), process.on("uncaughtException", function(a) {
          throw a;
        }), process.on("unhandledRejection", y), d.inspect = function() {
          return "[Emscripten Module object]";
        };
      else if (da)
        typeof read != "undefined" && (ea = function(a) {
          return read(a);
        }), fa = function(a) {
          if (typeof readbuffer === "function")
            return new Uint8Array(readbuffer(a));
          a = read(a, "binary");
          assert(typeof a === "object");
          return a;
        }, typeof print !== "undefined" && (typeof console === "undefined" && (console = {}), console.log = print, console.warn = console.error = typeof printErr !== "undefined" ? printErr : print);
      else if (ba || w)
        w ? x = self.location.href : document.currentScript && (x = document.currentScript.src), _scriptDir && (x = _scriptDir), x.indexOf("blob:") !== 0 ? x = x.substr(0, x.lastIndexOf("/") + 1) : x = "", ea = function(a) {
          var b = new XMLHttpRequest();
          b.open("GET", a, false);
          b.send(null);
          return b.responseText;
        }, w && (fa = function(a) {
          var b = new XMLHttpRequest();
          b.open("GET", a, false);
          b.responseType = "arraybuffer";
          b.send(null);
          return new Uint8Array(b.response);
        });
      var ja = d.print || console.log.bind(console), z = d.printErr || console.warn.bind(console);
      for (v in r)
        r.hasOwnProperty(v) && (d[v] = r[v]);
      r = null;
      var ka;
      d.wasmBinary && (ka = d.wasmBinary);
      d.noExitRuntime && d.noExitRuntime;
      typeof WebAssembly !== "object" && z("no native wasm support detected");
      var la, ma = new WebAssembly.Table({ initial: 309, maximum: 309, element: "anyfunc" }), na = false;
      function assert(a, b) {
        a || y("Assertion failed: " + b);
      }
      var oa = typeof TextDecoder !== "undefined" ? new TextDecoder("utf8") : void 0;
      function pa(a, b, c2) {
        var e = b + c2;
        for (c2 = b; a[c2] && !(c2 >= e); )
          ++c2;
        if (16 < c2 - b && a.subarray && oa)
          return oa.decode(a.subarray(b, c2));
        for (e = ""; b < c2; ) {
          var f = a[b++];
          if (f & 128) {
            var g = a[b++] & 63;
            if ((f & 224) == 192)
              e += String.fromCharCode((f & 31) << 6 | g);
            else {
              var m = a[b++] & 63;
              f = (f & 240) == 224 ? (f & 15) << 12 | g << 6 | m : (f & 7) << 18 | g << 12 | m << 6 | a[b++] & 63;
              65536 > f ? e += String.fromCharCode(f) : (f -= 65536, e += String.fromCharCode(55296 | f >> 10, 56320 | f & 1023));
            }
          } else
            e += String.fromCharCode(f);
        }
        return e;
      }
      function qa(a, b, c2) {
        var e = B;
        if (0 < c2) {
          c2 = b + c2 - 1;
          for (var f = 0; f < a.length; ++f) {
            var g = a.charCodeAt(f);
            if (55296 <= g && 57343 >= g) {
              var m = a.charCodeAt(++f);
              g = 65536 + ((g & 1023) << 10) | m & 1023;
            }
            if (127 >= g) {
              if (b >= c2)
                break;
              e[b++] = g;
            } else {
              if (2047 >= g) {
                if (b + 1 >= c2)
                  break;
                e[b++] = 192 | g >> 6;
              } else {
                if (65535 >= g) {
                  if (b + 2 >= c2)
                    break;
                  e[b++] = 224 | g >> 12;
                } else {
                  if (b + 3 >= c2)
                    break;
                  e[b++] = 240 | g >> 18;
                  e[b++] = 128 | g >> 12 & 63;
                }
                e[b++] = 128 | g >> 6 & 63;
              }
              e[b++] = 128 | g & 63;
            }
          }
          e[b] = 0;
        }
      }
      var ra = typeof TextDecoder !== "undefined" ? new TextDecoder("utf-16le") : void 0;
      function sa(a, b) {
        var c2 = a >> 1;
        for (var e = c2 + b / 2; !(c2 >= e) && ta[c2]; )
          ++c2;
        c2 <<= 1;
        if (32 < c2 - a && ra)
          return ra.decode(B.subarray(a, c2));
        c2 = 0;
        for (e = ""; ; ) {
          var f = D[a + 2 * c2 >> 1];
          if (f == 0 || c2 == b / 2)
            return e;
          ++c2;
          e += String.fromCharCode(f);
        }
      }
      function ua(a, b, c2) {
        c2 === void 0 && (c2 = 2147483647);
        if (2 > c2)
          return 0;
        c2 -= 2;
        var e = b;
        c2 = c2 < 2 * a.length ? c2 / 2 : a.length;
        for (var f = 0; f < c2; ++f)
          D[b >> 1] = a.charCodeAt(f), b += 2;
        D[b >> 1] = 0;
        return b - e;
      }
      function va(a) {
        return 2 * a.length;
      }
      function wa(a, b) {
        for (var c2 = 0, e = ""; !(c2 >= b / 4); ) {
          var f = E[a + 4 * c2 >> 2];
          if (f == 0)
            break;
          ++c2;
          65536 <= f ? (f -= 65536, e += String.fromCharCode(55296 | f >> 10, 56320 | f & 1023)) : e += String.fromCharCode(f);
        }
        return e;
      }
      function xa(a, b, c2) {
        c2 === void 0 && (c2 = 2147483647);
        if (4 > c2)
          return 0;
        var e = b;
        c2 = e + c2 - 4;
        for (var f = 0; f < a.length; ++f) {
          var g = a.charCodeAt(f);
          if (55296 <= g && 57343 >= g) {
            var m = a.charCodeAt(++f);
            g = 65536 + ((g & 1023) << 10) | m & 1023;
          }
          E[b >> 2] = g;
          b += 4;
          if (b + 4 > c2)
            break;
        }
        E[b >> 2] = 0;
        return b - e;
      }
      function ya(a) {
        for (var b = 0, c2 = 0; c2 < a.length; ++c2) {
          var e = a.charCodeAt(c2);
          55296 <= e && 57343 >= e && ++c2;
          b += 4;
        }
        return b;
      }
      var za, Aa, B, D, ta, E, F, Ba, Ca, Da = d.INITIAL_MEMORY || 16777216;
      d.wasmMemory ? la = d.wasmMemory : la = new WebAssembly.Memory({ initial: Da / 65536, maximum: Da / 65536 });
      la && (za = la.buffer);
      Da = za.byteLength;
      var G = za;
      za = G;
      d.HEAP8 = Aa = new Int8Array(G);
      d.HEAP16 = D = new Int16Array(G);
      d.HEAP32 = E = new Int32Array(G);
      d.HEAPU8 = B = new Uint8Array(G);
      d.HEAPU16 = ta = new Uint16Array(G);
      d.HEAPU32 = F = new Uint32Array(G);
      d.HEAPF32 = Ba = new Float32Array(G);
      d.HEAPF64 = Ca = new Float64Array(G);
      E[3e3] = 5255040;
      function Ea(a) {
        for (; 0 < a.length; ) {
          var b = a.shift();
          if (typeof b == "function")
            b(d);
          else {
            var c2 = b.Jb;
            typeof c2 === "number" ? b.tb === void 0 ? d.dynCall_v(c2) : d.dynCall_vi(c2, b.tb) : c2(b.tb === void 0 ? null : b.tb);
          }
        }
      }
      var Fa = [], Ga = [], Ha = [], Ia = [];
      function Ja() {
        var a = d.preRun.shift();
        Fa.unshift(a);
      }
      var H = 0, La = null;
      d.preloadedImages = {};
      d.preloadedAudios = {};
      function y(a) {
        if (d.onAbort)
          d.onAbort(a);
        ja(a);
        z(a);
        na = true;
        throw new WebAssembly.RuntimeError("abort(" + a + "). Build with -s ASSERTIONS=1 for more info.");
      }
      function Ma(a) {
        var b = I;
        return String.prototype.startsWith ? b.startsWith(a) : b.indexOf(a) === 0;
      }
      function Na() {
        return Ma("data:application/octet-stream;base64,");
      }
      var I = "pathkit.wasm";
      if (!Na()) {
        var Oa = I;
        I = d.locateFile ? d.locateFile(Oa, x) : x + Oa;
      }
      function Pa() {
        try {
          if (ka)
            return new Uint8Array(ka);
          if (fa)
            return fa(I);
          throw "both async and sync fetching of the wasm failed";
        } catch (a) {
          y(a);
        }
      }
      function Qa() {
        return ka || !ba && !w || typeof fetch !== "function" || Ma("file://") ? new Promise(function(a) {
          a(Pa());
        }) : fetch(I, { credentials: "same-origin" }).then(function(a) {
          if (!a.ok)
            throw "failed to load wasm binary file at '" + I + "'";
          return a.arrayBuffer();
        }).catch(function() {
          return Pa();
        });
      }
      Ga.push({ Jb: function() {
        Ra();
      } });
      var Sa = {};
      function Ta(a) {
        for (; a.length; ) {
          var b = a.pop();
          a.pop()(b);
        }
      }
      function J(a) {
        return this.fromWireType(F[a >> 2]);
      }
      var K = {}, L = {}, Ua = {};
      function Va(a) {
        if (a === void 0)
          return "_unknown";
        a = a.replace(/[^a-zA-Z0-9_]/g, "$");
        var b = a.charCodeAt(0);
        return 48 <= b && 57 >= b ? "_" + a : a;
      }
      function Wa(a, b) {
        a = Va(a);
        return new Function("body", "return function " + a + '() {\n    "use strict";    return body.apply(this, arguments);\n};\n')(b);
      }
      function Xa(a) {
        var b = Error, c2 = Wa(a, function(e) {
          this.name = a;
          this.message = e;
          e = Error(e).stack;
          e !== void 0 && (this.stack = this.toString() + "\n" + e.replace(/^Error(:[^\n]*)?\n/, ""));
        });
        c2.prototype = Object.create(b.prototype);
        c2.prototype.constructor = c2;
        c2.prototype.toString = function() {
          return this.message === void 0 ? this.name : this.name + ": " + this.message;
        };
        return c2;
      }
      var Ya = void 0;
      function Za(a) {
        throw new Ya(a);
      }
      function N(a, b, c2) {
        function e(h) {
          h = c2(h);
          h.length !== a.length && Za("Mismatched type converter count");
          for (var k = 0; k < a.length; ++k)
            O(a[k], h[k]);
        }
        a.forEach(function(h) {
          Ua[h] = b;
        });
        var f = Array(b.length), g = [], m = 0;
        b.forEach(function(h, k) {
          L.hasOwnProperty(h) ? f[k] = L[h] : (g.push(h), K.hasOwnProperty(h) || (K[h] = []), K[h].push(function() {
            f[k] = L[h];
            ++m;
            m === g.length && e(f);
          }));
        });
        g.length === 0 && e(f);
      }
      var $a = {};
      function ab(a) {
        switch (a) {
          case 1:
            return 0;
          case 2:
            return 1;
          case 4:
            return 2;
          case 8:
            return 3;
          default:
            throw new TypeError("Unknown type size: " + a);
        }
      }
      var bb = void 0;
      function P(a) {
        for (var b = ""; B[a]; )
          b += bb[B[a++]];
        return b;
      }
      var Q = void 0;
      function R(a) {
        throw new Q(a);
      }
      function O(a, b, c2) {
        c2 = c2 || {};
        if (!("argPackAdvance" in b))
          throw new TypeError("registerType registeredInstance requires argPackAdvance");
        var e = b.name;
        a || R('type "' + e + '" must have a positive integer typeid pointer');
        if (L.hasOwnProperty(a)) {
          if (c2.Mb)
            return;
          R("Cannot register type '" + e + "' twice");
        }
        L[a] = b;
        delete Ua[a];
        K.hasOwnProperty(a) && (b = K[a], delete K[a], b.forEach(function(f) {
          f();
        }));
      }
      function cb(a) {
        return { count: a.count, lb: a.lb, nb: a.nb, bb: a.bb, cb: a.cb, gb: a.gb, ib: a.ib };
      }
      function db(a) {
        R(a.$a.cb.ab.name + " instance already deleted");
      }
      var eb = false;
      function fb() {
      }
      function gb(a) {
        --a.count.value;
        a.count.value === 0 && (a.gb ? a.ib.hb(a.gb) : a.cb.ab.hb(a.bb));
      }
      function hb(a) {
        if (typeof FinalizationGroup === "undefined")
          return hb = function(b) {
            return b;
          }, a;
        eb = new FinalizationGroup(function(b) {
          for (var c2 = b.next(); !c2.done; c2 = b.next())
            c2 = c2.value, c2.bb ? gb(c2) : console.warn("object already deleted: " + c2.bb);
        });
        hb = function(b) {
          eb.register(b, b.$a, b.$a);
          return b;
        };
        fb = function(b) {
          eb.unregister(b.$a);
        };
        return hb(a);
      }
      var ib = void 0, jb = [];
      function kb() {
        for (; jb.length; ) {
          var a = jb.pop();
          a.$a.lb = false;
          a["delete"]();
        }
      }
      function S() {
      }
      var lb = {};
      function mb(a, b, c2) {
        if (a[b].eb === void 0) {
          var e = a[b];
          a[b] = function() {
            a[b].eb.hasOwnProperty(arguments.length) || R("Function '" + c2 + "' called with an invalid number of arguments (" + arguments.length + ") - expects one of (" + a[b].eb + ")!");
            return a[b].eb[arguments.length].apply(this, arguments);
          };
          a[b].eb = [];
          a[b].eb[e.qb] = e;
        }
      }
      function nb(a, b, c2) {
        d.hasOwnProperty(a) ? ((c2 === void 0 || d[a].eb !== void 0 && d[a].eb[c2] !== void 0) && R("Cannot register public name '" + a + "' twice"), mb(d, a, a), d.hasOwnProperty(c2) && R("Cannot register multiple overloads of a function with the same number of arguments (" + c2 + ")!"), d[a].eb[c2] = b) : (d[a] = b, c2 !== void 0 && (d[a].Sb = c2));
      }
      function ob(a, b, c2, e, f, g, m, h) {
        this.name = a;
        this.constructor = b;
        this.mb = c2;
        this.hb = e;
        this.jb = f;
        this.Kb = g;
        this.pb = m;
        this.Hb = h;
        this.Pb = [];
      }
      function pb(a, b, c2) {
        for (; b !== c2; )
          b.pb || R("Expected null or instance of " + c2.name + ", got an instance of " + b.name), a = b.pb(a), b = b.jb;
        return a;
      }
      function qb(a, b) {
        if (b === null)
          return this.xb && R("null is not a valid " + this.name), 0;
        b.$a || R('Cannot pass "' + U(b) + '" as a ' + this.name);
        b.$a.bb || R("Cannot pass deleted object as a pointer of type " + this.name);
        return pb(b.$a.bb, b.$a.cb.ab, this.ab);
      }
      function rb(a, b) {
        if (b === null) {
          this.xb && R("null is not a valid " + this.name);
          if (this.sb) {
            var c2 = this.ob();
            a !== null && a.push(this.hb, c2);
            return c2;
          }
          return 0;
        }
        b.$a || R('Cannot pass "' + U(b) + '" as a ' + this.name);
        b.$a.bb || R("Cannot pass deleted object as a pointer of type " + this.name);
        !this.rb && b.$a.cb.rb && R("Cannot convert argument of type " + (b.$a.ib ? b.$a.ib.name : b.$a.cb.name) + " to parameter type " + this.name);
        c2 = pb(b.$a.bb, b.$a.cb.ab, this.ab);
        if (this.sb)
          switch (b.$a.gb === void 0 && R("Passing raw pointer to smart pointer is illegal"), this.Rb) {
            case 0:
              b.$a.ib === this ? c2 = b.$a.gb : R("Cannot convert argument of type " + (b.$a.ib ? b.$a.ib.name : b.$a.cb.name) + " to parameter type " + this.name);
              break;
            case 1:
              c2 = b.$a.gb;
              break;
            case 2:
              if (b.$a.ib === this)
                c2 = b.$a.gb;
              else {
                var e = b.clone();
                c2 = this.Qb(c2, V(function() {
                  e["delete"]();
                }));
                a !== null && a.push(this.hb, c2);
              }
              break;
            default:
              R("Unsupporting sharing policy");
          }
        return c2;
      }
      function sb(a, b) {
        if (b === null)
          return this.xb && R("null is not a valid " + this.name), 0;
        b.$a || R('Cannot pass "' + U(b) + '" as a ' + this.name);
        b.$a.bb || R("Cannot pass deleted object as a pointer of type " + this.name);
        b.$a.cb.rb && R("Cannot convert argument of type " + b.$a.cb.name + " to parameter type " + this.name);
        return pb(b.$a.bb, b.$a.cb.ab, this.ab);
      }
      function tb(a, b, c2) {
        if (b === c2)
          return a;
        if (c2.jb === void 0)
          return null;
        a = tb(a, b, c2.jb);
        return a === null ? null : c2.Hb(a);
      }
      var ub = {};
      function vb(a, b) {
        for (b === void 0 && R("ptr should not be undefined"); a.jb; )
          b = a.pb(b), a = a.jb;
        return ub[b];
      }
      function wb(a, b) {
        b.cb && b.bb || Za("makeClassHandle requires ptr and ptrType");
        !!b.ib !== !!b.gb && Za("Both smartPtrType and smartPtr must be specified");
        b.count = { value: 1 };
        return hb(Object.create(a, { $a: { value: b } }));
      }
      function W(a, b, c2, e) {
        this.name = a;
        this.ab = b;
        this.xb = c2;
        this.rb = e;
        this.sb = false;
        this.hb = this.Qb = this.ob = this.Eb = this.Rb = this.Ob = void 0;
        b.jb !== void 0 ? this.toWireType = rb : (this.toWireType = e ? qb : sb, this.fb = null);
      }
      function xb(a, b, c2) {
        d.hasOwnProperty(a) || Za("Replacing nonexistant public symbol");
        d[a].eb !== void 0 && c2 !== void 0 ? d[a].eb[c2] = b : (d[a] = b, d[a].qb = c2);
      }
      function X(a, b) {
        a = P(a);
        var c2 = d["dynCall_" + a];
        for (var e = [], f = 1; f < a.length; ++f)
          e.push("a" + f);
        f = "return function dynCall_" + (a + "_" + b) + "(" + e.join(", ") + ") {\n";
        f += "    return dynCall(rawFunction" + (e.length ? ", " : "") + e.join(", ") + ");\n";
        c2 = new Function("dynCall", "rawFunction", f + "};\n")(c2, b);
        typeof c2 !== "function" && R("unknown function pointer with signature " + a + ": " + b);
        return c2;
      }
      var yb = void 0;
      function zb(a) {
        a = Ab(a);
        var b = P(a);
        Y(a);
        return b;
      }
      function Db(a, b) {
        function c2(g) {
          f[g] || L[g] || (Ua[g] ? Ua[g].forEach(c2) : (e.push(g), f[g] = true));
        }
        var e = [], f = {};
        b.forEach(c2);
        throw new yb(a + ": " + e.map(zb).join([", "]));
      }
      function Eb(a, b) {
        for (var c2 = [], e = 0; e < a; e++)
          c2.push(E[(b >> 2) + e]);
        return c2;
      }
      function Fb(a) {
        var b = Function;
        if (!(b instanceof Function))
          throw new TypeError("new_ called with constructor type " + typeof b + " which is not a function");
        var c2 = Wa(b.name || "unknownFunctionName", function() {
        });
        c2.prototype = b.prototype;
        c2 = new c2();
        a = b.apply(c2, a);
        return a instanceof Object ? a : c2;
      }
      function Gb(a, b, c2, e, f) {
        var g = b.length;
        2 > g && R("argTypes array size mismatch! Must at least get return value and 'this' types!");
        var m = b[1] !== null && c2 !== null, h = false;
        for (c2 = 1; c2 < b.length; ++c2)
          if (b[c2] !== null && b[c2].fb === void 0) {
            h = true;
            break;
          }
        var k = b[0].name !== "void", l = "", n = "";
        for (c2 = 0; c2 < g - 2; ++c2)
          l += (c2 !== 0 ? ", " : "") + "arg" + c2, n += (c2 !== 0 ? ", " : "") + "arg" + c2 + "Wired";
        a = "return function " + Va(a) + "(" + l + ") {\nif (arguments.length !== " + (g - 2) + ") {\nthrowBindingError('function " + a + " called with ' + arguments.length + ' arguments, expected " + (g - 2) + " args!');\n}\n";
        h && (a += "var destructors = [];\n");
        var p = h ? "destructors" : "null";
        l = "throwBindingError invoker fn runDestructors retType classParam".split(" ");
        e = [R, e, f, Ta, b[0], b[1]];
        m && (a += "var thisWired = classParam.toWireType(" + p + ", this);\n");
        for (c2 = 0; c2 < g - 2; ++c2)
          a += "var arg" + c2 + "Wired = argType" + c2 + ".toWireType(" + p + ", arg" + c2 + "); // " + b[c2 + 2].name + "\n", l.push("argType" + c2), e.push(b[c2 + 2]);
        m && (n = "thisWired" + (0 < n.length ? ", " : "") + n);
        a += (k ? "var rv = " : "") + "invoker(fn" + (0 < n.length ? ", " : "") + n + ");\n";
        if (h)
          a += "runDestructors(destructors);\n";
        else
          for (c2 = m ? 1 : 2; c2 < b.length; ++c2)
            g = c2 === 1 ? "thisWired" : "arg" + (c2 - 2) + "Wired", b[c2].fb !== null && (a += g + "_dtor(" + g + "); // " + b[c2].name + "\n", l.push(g + "_dtor"), e.push(b[c2].fb));
        k && (a += "var ret = retType.fromWireType(rv);\nreturn ret;\n");
        l.push(a + "}\n");
        return Fb(l).apply(null, e);
      }
      var Hb = [], Z = [{}, { value: void 0 }, { value: null }, { value: true }, { value: false }];
      function Ib(a) {
        4 < a && --Z[a].yb === 0 && (Z[a] = void 0, Hb.push(a));
      }
      function V(a) {
        switch (a) {
          case void 0:
            return 1;
          case null:
            return 2;
          case true:
            return 3;
          case false:
            return 4;
          default:
            var b = Hb.length ? Hb.pop() : Z.length;
            Z[b] = { yb: 1, value: a };
            return b;
        }
      }
      function Jb(a, b, c2) {
        switch (b) {
          case 0:
            return function(e) {
              return this.fromWireType((c2 ? Aa : B)[e]);
            };
          case 1:
            return function(e) {
              return this.fromWireType((c2 ? D : ta)[e >> 1]);
            };
          case 2:
            return function(e) {
              return this.fromWireType((c2 ? E : F)[e >> 2]);
            };
          default:
            throw new TypeError("Unknown integer type: " + a);
        }
      }
      function Kb(a, b) {
        var c2 = L[a];
        c2 === void 0 && R(b + " has unknown type " + zb(a));
        return c2;
      }
      function U(a) {
        if (a === null)
          return "null";
        var b = typeof a;
        return b === "object" || b === "array" || b === "function" ? a.toString() : "" + a;
      }
      function Lb(a, b) {
        switch (b) {
          case 2:
            return function(c2) {
              return this.fromWireType(Ba[c2 >> 2]);
            };
          case 3:
            return function(c2) {
              return this.fromWireType(Ca[c2 >> 3]);
            };
          default:
            throw new TypeError("Unknown float type: " + a);
        }
      }
      function Mb(a, b, c2) {
        switch (b) {
          case 0:
            return c2 ? function(e) {
              return Aa[e];
            } : function(e) {
              return B[e];
            };
          case 1:
            return c2 ? function(e) {
              return D[e >> 1];
            } : function(e) {
              return ta[e >> 1];
            };
          case 2:
            return c2 ? function(e) {
              return E[e >> 2];
            } : function(e) {
              return F[e >> 2];
            };
          default:
            throw new TypeError("Unknown integer type: " + a);
        }
      }
      var Nb = {};
      function Ob(a) {
        var b = Nb[a];
        return b === void 0 ? P(a) : b;
      }
      var Pb = [];
      function Qb(a) {
        a || R("Cannot use deleted val. handle = " + a);
        return Z[a].value;
      }
      function Rb() {
        return typeof globalThis === "object" ? globalThis : Function("return this")();
      }
      function Sb(a) {
        var b = Pb.length;
        Pb.push(a);
        return b;
      }
      function Tb(a, b) {
        for (var c2 = Array(a), e = 0; e < a; ++e)
          c2[e] = Kb(E[(b >> 2) + e], "parameter " + e);
        return c2;
      }
      var Ub = {}, Vb = [null, [], []];
      Ya = d.InternalError = Xa("InternalError");
      for (var Wb = Array(256), Xb = 0; 256 > Xb; ++Xb)
        Wb[Xb] = String.fromCharCode(Xb);
      bb = Wb;
      Q = d.BindingError = Xa("BindingError");
      S.prototype.isAliasOf = function(a) {
        if (!(this instanceof S && a instanceof S))
          return false;
        var b = this.$a.cb.ab, c2 = this.$a.bb, e = a.$a.cb.ab;
        for (a = a.$a.bb; b.jb; )
          c2 = b.pb(c2), b = b.jb;
        for (; e.jb; )
          a = e.pb(a), e = e.jb;
        return b === e && c2 === a;
      };
      S.prototype.clone = function() {
        this.$a.bb || db(this);
        if (this.$a.nb)
          return this.$a.count.value += 1, this;
        var a = hb(Object.create(Object.getPrototypeOf(this), { $a: { value: cb(this.$a) } }));
        a.$a.count.value += 1;
        a.$a.lb = false;
        return a;
      };
      S.prototype["delete"] = function() {
        this.$a.bb || db(this);
        this.$a.lb && !this.$a.nb && R("Object already scheduled for deletion");
        fb(this);
        gb(this.$a);
        this.$a.nb || (this.$a.gb = void 0, this.$a.bb = void 0);
      };
      S.prototype.isDeleted = function() {
        return !this.$a.bb;
      };
      S.prototype.deleteLater = function() {
        this.$a.bb || db(this);
        this.$a.lb && !this.$a.nb && R("Object already scheduled for deletion");
        jb.push(this);
        jb.length === 1 && ib && ib(kb);
        this.$a.lb = true;
        return this;
      };
      W.prototype.Lb = function(a) {
        this.Eb && (a = this.Eb(a));
        return a;
      };
      W.prototype.Cb = function(a) {
        this.hb && this.hb(a);
      };
      W.prototype.argPackAdvance = 8;
      W.prototype.readValueFromPointer = J;
      W.prototype.deleteObject = function(a) {
        if (a !== null)
          a["delete"]();
      };
      W.prototype.fromWireType = function(a) {
        function b() {
          return this.sb ? wb(this.ab.mb, { cb: this.Ob, bb: c2, ib: this, gb: a }) : wb(this.ab.mb, { cb: this, bb: a });
        }
        var c2 = this.Lb(a);
        if (!c2)
          return this.Cb(a), null;
        var e = vb(this.ab, c2);
        if (e !== void 0) {
          if (e.$a.count.value === 0)
            return e.$a.bb = c2, e.$a.gb = a, e.clone();
          e = e.clone();
          this.Cb(a);
          return e;
        }
        e = this.ab.Kb(c2);
        e = lb[e];
        if (!e)
          return b.call(this);
        e = this.rb ? e.Gb : e.pointerType;
        var f = tb(c2, this.ab, e.ab);
        return f === null ? b.call(this) : this.sb ? wb(e.ab.mb, { cb: e, bb: f, ib: this, gb: a }) : wb(e.ab.mb, { cb: e, bb: f });
      };
      d.getInheritedInstanceCount = function() {
        return Object.keys(ub).length;
      };
      d.getLiveInheritedInstances = function() {
        var a = [], b;
        for (b in ub)
          ub.hasOwnProperty(b) && a.push(ub[b]);
        return a;
      };
      d.flushPendingDeletes = kb;
      d.setDelayFunction = function(a) {
        ib = a;
        jb.length && ib && ib(kb);
      };
      yb = d.UnboundTypeError = Xa("UnboundTypeError");
      d.count_emval_handles = function() {
        for (var a = 0, b = 5; b < Z.length; ++b)
          Z[b] !== void 0 && ++a;
        return a;
      };
      d.get_first_emval = function() {
        for (var a = 5; a < Z.length; ++a)
          if (Z[a] !== void 0)
            return Z[a];
        return null;
      };
      var Zb = {
        s: function(a) {
          var b = Sa[a];
          delete Sa[a];
          var c2 = b.elements, e = c2.length, f = c2.map(function(h) {
            return h.wb;
          }).concat(c2.map(function(h) {
            return h.Ab;
          })), g = b.ob, m = b.hb;
          N([a], f, function(h) {
            c2.forEach(function(k, l) {
              var n = h[l], p = k.ub, q = k.vb, t = h[l + e], u = k.zb, M = k.Bb;
              k.read = function(A) {
                return n.fromWireType(p(q, A));
              };
              k.write = function(A, T) {
                var C = [];
                u(M, A, t.toWireType(C, T));
                Ta(C);
              };
            });
            return [{ name: b.name, fromWireType: function(k) {
              for (var l = Array(e), n = 0; n < e; ++n)
                l[n] = c2[n].read(k);
              m(k);
              return l;
            }, toWireType: function(k, l) {
              if (e !== l.length)
                throw new TypeError("Incorrect number of tuple elements for " + b.name + ": expected=" + e + ", actual=" + l.length);
              for (var n = g(), p = 0; p < e; ++p)
                c2[p].write(n, l[p]);
              k !== null && k.push(m, n);
              return n;
            }, argPackAdvance: 8, readValueFromPointer: J, fb: m }];
          });
        },
        v: function(a) {
          var b = $a[a];
          delete $a[a];
          var c2 = b.ob, e = b.hb, f = b.Db, g = f.map(function(m) {
            return m.wb;
          }).concat(f.map(function(m) {
            return m.Ab;
          }));
          N([a], g, function(m) {
            var h = {};
            f.forEach(function(k, l) {
              var n = m[l], p = k.ub, q = k.vb, t = m[l + f.length], u = k.zb, M = k.Bb;
              h[k.Ib] = { read: function(A) {
                return n.fromWireType(p(q, A));
              }, write: function(A, T) {
                var C = [];
                u(M, A, t.toWireType(C, T));
                Ta(C);
              } };
            });
            return [{ name: b.name, fromWireType: function(k) {
              var l = {}, n;
              for (n in h)
                l[n] = h[n].read(k);
              e(k);
              return l;
            }, toWireType: function(k, l) {
              for (var n in h)
                if (!(n in l))
                  throw new TypeError("Missing field");
              var p = c2();
              for (n in h)
                h[n].write(p, l[n]);
              k !== null && k.push(e, p);
              return p;
            }, argPackAdvance: 8, readValueFromPointer: J, fb: e }];
          });
        },
        G: function(a, b, c2, e, f) {
          var g = ab(c2);
          b = P(b);
          O(a, {
            name: b,
            fromWireType: function(m) {
              return !!m;
            },
            toWireType: function(m, h) {
              return h ? e : f;
            },
            argPackAdvance: 8,
            readValueFromPointer: function(m) {
              if (c2 === 1)
                var h = Aa;
              else if (c2 === 2)
                h = D;
              else if (c2 === 4)
                h = E;
              else
                throw new TypeError("Unknown boolean type size: " + b);
              return this.fromWireType(h[m >> g]);
            },
            fb: null
          });
        },
        k: function(a, b, c2, e, f, g, m, h, k, l, n, p, q) {
          n = P(n);
          g = X(f, g);
          h && (h = X(m, h));
          l && (l = X(k, l));
          q = X(p, q);
          var t = Va(n);
          nb(t, function() {
            Db("Cannot construct " + n + " due to unbound types", [e]);
          });
          N([a, b, c2], e ? [e] : [], function(u) {
            u = u[0];
            if (e) {
              var M = u.ab;
              var A = M.mb;
            } else
              A = S.prototype;
            u = Wa(t, function() {
              if (Object.getPrototypeOf(this) !== T)
                throw new Q("Use 'new' to construct " + n);
              if (C.kb === void 0)
                throw new Q(n + " has no accessible constructor");
              var Bb = C.kb[arguments.length];
              if (Bb === void 0)
                throw new Q("Tried to invoke ctor of " + n + " with invalid number of parameters (" + arguments.length + ") - expected (" + Object.keys(C.kb).toString() + ") parameters instead!");
              return Bb.apply(this, arguments);
            });
            var T = Object.create(A, { constructor: { value: u } });
            u.prototype = T;
            var C = new ob(n, u, T, q, M, g, h, l);
            M = new W(n, C, true, false);
            A = new W(n + "*", C, false, false);
            var Cb = new W(n + " const*", C, false, true);
            lb[a] = { pointerType: A, Gb: Cb };
            xb(t, u);
            return [M, A, Cb];
          });
        },
        h: function(a, b, c2, e, f, g) {
          assert(0 < b);
          var m = Eb(b, c2);
          f = X(e, f);
          var h = [g], k = [];
          N([], [a], function(l) {
            l = l[0];
            var n = "constructor " + l.name;
            l.ab.kb === void 0 && (l.ab.kb = []);
            if (l.ab.kb[b - 1] !== void 0)
              throw new Q("Cannot register multiple constructors with identical number of parameters (" + (b - 1) + ") for class '" + l.name + "'! Overload resolution is currently only performed using the parameter count, not actual type info!");
            l.ab.kb[b - 1] = function() {
              Db("Cannot construct " + l.name + " due to unbound types", m);
            };
            N([], m, function(p) {
              l.ab.kb[b - 1] = function() {
                arguments.length !== b - 1 && R(n + " called with " + arguments.length + " arguments, expected " + (b - 1));
                k.length = 0;
                h.length = b;
                for (var q = 1; q < b; ++q)
                  h[q] = p[q].toWireType(k, arguments[q - 1]);
                q = f.apply(null, h);
                Ta(k);
                return p[0].fromWireType(q);
              };
              return [];
            });
            return [];
          });
        },
        a: function(a, b, c2, e, f, g, m, h) {
          var k = Eb(c2, e);
          b = P(b);
          g = X(f, g);
          N([], [a], function(l) {
            function n() {
              Db("Cannot call " + p + " due to unbound types", k);
            }
            l = l[0];
            var p = l.name + "." + b;
            h && l.ab.Pb.push(b);
            var q = l.ab.mb, t = q[b];
            t === void 0 || t.eb === void 0 && t.className !== l.name && t.qb === c2 - 2 ? (n.qb = c2 - 2, n.className = l.name, q[b] = n) : (mb(q, b, p), q[b].eb[c2 - 2] = n);
            N([], k, function(u) {
              u = Gb(p, u, l, g, m);
              q[b].eb === void 0 ? (u.qb = c2 - 2, q[b] = u) : q[b].eb[c2 - 2] = u;
              return [];
            });
            return [];
          });
        },
        M: function(a, b, c2) {
          a = P(a);
          N([], [b], function(e) {
            e = e[0];
            d[a] = e.fromWireType(c2);
            return [];
          });
        },
        E: function(a, b) {
          b = P(b);
          O(a, { name: b, fromWireType: function(c2) {
            var e = Z[c2].value;
            Ib(c2);
            return e;
          }, toWireType: function(c2, e) {
            return V(e);
          }, argPackAdvance: 8, readValueFromPointer: J, fb: null });
        },
        g: function(a, b, c2, e) {
          function f() {
          }
          c2 = ab(c2);
          b = P(b);
          f.values = {};
          O(a, { name: b, constructor: f, fromWireType: function(g) {
            return this.constructor.values[g];
          }, toWireType: function(g, m) {
            return m.value;
          }, argPackAdvance: 8, readValueFromPointer: Jb(b, c2, e), fb: null });
          nb(b, f);
        },
        j: function(a, b, c2) {
          var e = Kb(a, "enum");
          b = P(b);
          a = e.constructor;
          e = Object.create(e.constructor.prototype, { value: { value: c2 }, constructor: { value: Wa(e.name + "_" + b, function() {
          }) } });
          a.values[c2] = e;
          a[b] = e;
        },
        p: function(a, b, c2) {
          c2 = ab(c2);
          b = P(b);
          O(a, { name: b, fromWireType: function(e) {
            return e;
          }, toWireType: function(e, f) {
            if (typeof f !== "number" && typeof f !== "boolean")
              throw new TypeError('Cannot convert "' + U(f) + '" to ' + this.name);
            return f;
          }, argPackAdvance: 8, readValueFromPointer: Lb(b, c2), fb: null });
        },
        f: function(a, b, c2, e, f, g) {
          var m = Eb(b, c2);
          a = P(a);
          f = X(e, f);
          nb(a, function() {
            Db("Cannot call " + a + " due to unbound types", m);
          }, b - 1);
          N([], m, function(h) {
            h = [h[0], null].concat(h.slice(1));
            xb(a, Gb(a, h, null, f, g), b - 1);
            return [];
          });
        },
        e: function(a, b, c2, e, f) {
          function g(l) {
            return l;
          }
          b = P(b);
          f === -1 && (f = 4294967295);
          var m = ab(c2);
          if (e === 0) {
            var h = 32 - 8 * c2;
            g = function(l) {
              return l << h >>> h;
            };
          }
          var k = b.indexOf("unsigned") != -1;
          O(a, { name: b, fromWireType: g, toWireType: function(l, n) {
            if (typeof n !== "number" && typeof n !== "boolean")
              throw new TypeError('Cannot convert "' + U(n) + '" to ' + this.name);
            if (n < e || n > f)
              throw new TypeError('Passing a number "' + U(n) + '" from JS side to C/C++ side to an argument of type "' + b + '", which is outside the valid range [' + e + ", " + f + "]!");
            return k ? n >>> 0 : n | 0;
          }, argPackAdvance: 8, readValueFromPointer: Mb(b, m, e !== 0), fb: null });
        },
        b: function(a, b, c2) {
          function e(g) {
            g >>= 2;
            return new f(za, F[g + 1], F[g]);
          }
          var f = [Int8Array, Uint8Array, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array][b];
          c2 = P(c2);
          O(a, { name: c2, fromWireType: e, argPackAdvance: 8, readValueFromPointer: e }, { Mb: true });
        },
        q: function(a, b) {
          b = P(b);
          var c2 = b === "std::string";
          O(a, { name: b, fromWireType: function(e) {
            var f = F[e >> 2];
            if (c2)
              for (var g = e + 4, m = 0; m <= f; ++m) {
                var h = e + 4 + m;
                if (B[h] == 0 || m == f) {
                  g = g ? pa(B, g, h - g) : "";
                  if (k === void 0)
                    var k = g;
                  else
                    k += String.fromCharCode(0), k += g;
                  g = h + 1;
                }
              }
            else {
              k = Array(f);
              for (m = 0; m < f; ++m)
                k[m] = String.fromCharCode(B[e + 4 + m]);
              k = k.join("");
            }
            Y(e);
            return k;
          }, toWireType: function(e, f) {
            f instanceof ArrayBuffer && (f = new Uint8Array(f));
            var g = typeof f === "string";
            g || f instanceof Uint8Array || f instanceof Uint8ClampedArray || f instanceof Int8Array || R("Cannot pass non-string to std::string");
            var m = (c2 && g ? function() {
              for (var l = 0, n = 0; n < f.length; ++n) {
                var p = f.charCodeAt(n);
                55296 <= p && 57343 >= p && (p = 65536 + ((p & 1023) << 10) | f.charCodeAt(++n) & 1023);
                127 >= p ? ++l : l = 2047 >= p ? l + 2 : 65535 >= p ? l + 3 : l + 4;
              }
              return l;
            } : function() {
              return f.length;
            })(), h = Yb(4 + m + 1);
            F[h >> 2] = m;
            if (c2 && g)
              qa(f, h + 4, m + 1);
            else if (g)
              for (g = 0; g < m; ++g) {
                var k = f.charCodeAt(g);
                255 < k && (Y(h), R("String has UTF-16 code units that do not fit in 8 bits"));
                B[h + 4 + g] = k;
              }
            else
              for (g = 0; g < m; ++g)
                B[h + 4 + g] = f[g];
            e !== null && e.push(Y, h);
            return h;
          }, argPackAdvance: 8, readValueFromPointer: J, fb: function(e) {
            Y(e);
          } });
        },
        l: function(a, b, c2) {
          c2 = P(c2);
          if (b === 2) {
            var e = sa;
            var f = ua;
            var g = va;
            var m = function() {
              return ta;
            };
            var h = 1;
          } else
            b === 4 && (e = wa, f = xa, g = ya, m = function() {
              return F;
            }, h = 2);
          O(a, { name: c2, fromWireType: function(k) {
            for (var l = F[k >> 2], n = m(), p, q = k + 4, t = 0; t <= l; ++t) {
              var u = k + 4 + t * b;
              if (n[u >> h] == 0 || t == l)
                q = e(q, u - q), p === void 0 ? p = q : (p += String.fromCharCode(0), p += q), q = u + b;
            }
            Y(k);
            return p;
          }, toWireType: function(k, l) {
            typeof l !== "string" && R("Cannot pass non-string to C++ string type " + c2);
            var n = g(l), p = Yb(4 + n + b);
            F[p >> 2] = n >> h;
            f(l, p + 4, n + b);
            k !== null && k.push(Y, p);
            return p;
          }, argPackAdvance: 8, readValueFromPointer: J, fb: function(k) {
            Y(k);
          } });
        },
        u: function(a, b, c2, e, f, g) {
          Sa[a] = { name: P(b), ob: X(c2, e), hb: X(f, g), elements: [] };
        },
        t: function(a, b, c2, e, f, g, m, h, k) {
          Sa[a].elements.push({ wb: b, ub: X(c2, e), vb: f, Ab: g, zb: X(m, h), Bb: k });
        },
        w: function(a, b, c2, e, f, g) {
          $a[a] = { name: P(b), ob: X(c2, e), hb: X(f, g), Db: [] };
        },
        i: function(a, b, c2, e, f, g, m, h, k, l) {
          $a[a].Db.push({ Ib: P(b), wb: c2, ub: X(e, f), vb: g, Ab: m, zb: X(h, k), Bb: l });
        },
        H: function(a, b) {
          b = P(b);
          O(a, { Nb: true, name: b, argPackAdvance: 0, fromWireType: function() {
          }, toWireType: function() {
          } });
        },
        d: function(a, b, c2, e) {
          a = Pb[a];
          b = Qb(b);
          c2 = Ob(c2);
          a(b, c2, null, e);
        },
        N: Ib,
        z: function(a) {
          if (a === 0)
            return V(Rb());
          a = Ob(a);
          return V(Rb()[a]);
        },
        c: function(a, b) {
          b = Tb(a, b);
          for (var c2 = b[0], e = c2.name + "_$" + b.slice(1).map(function(l) {
            return l.name;
          }).join("_") + "$", f = ["retType"], g = [c2], m = "", h = 0; h < a - 1; ++h)
            m += (h !== 0 ? ", " : "") + "arg" + h, f.push("argType" + h), g.push(b[1 + h]);
          e = "return function " + Va("methodCaller_" + e) + "(handle, name, destructors, args) {\n";
          var k = 0;
          for (h = 0; h < a - 1; ++h)
            e += "    var arg" + h + " = argType" + h + ".readValueFromPointer(args" + (k ? "+" + k : "") + ");\n", k += b[h + 1].argPackAdvance;
          e += "    var rv = handle[name](" + m + ");\n";
          for (h = 0; h < a - 1; ++h)
            b[h + 1].deleteObject && (e += "    argType" + h + ".deleteObject(arg" + h + ");\n");
          c2.Nb || (e += "    return retType.toWireType(destructors, rv);\n");
          f.push(e + "};\n");
          a = Fb(f).apply(null, g);
          return Sb(a);
        },
        n: function(a) {
          4 < a && (Z[a].yb += 1);
        },
        x: function(a, b, c2, e) {
          a = Qb(a);
          var f = Ub[b];
          if (!f) {
            f = "";
            for (var g = 0; g < b; ++g)
              f += (g !== 0 ? ", " : "") + "arg" + g;
            var m = "return function emval_allocator_" + b + "(constructor, argTypes, args) {\n";
            for (g = 0; g < b; ++g)
              m += "var argType" + g + " = requireRegisteredType(Module['HEAP32'][(argTypes >>> 2) + " + g + '], "parameter ' + g + '");\nvar arg' + g + " = argType" + g + ".readValueFromPointer(args);\nargs += argType" + g + "['argPackAdvance'];\n";
            f = new Function("requireRegisteredType", "Module", "__emval_register", m + ("var obj = new constructor(" + f + ");\nreturn __emval_register(obj);\n}\n"))(Kb, d, V);
            Ub[b] = f;
          }
          return f(a, c2, e);
        },
        O: function() {
          return V([]);
        },
        F: function(a) {
          return V(Ob(a));
        },
        L: function(a, b) {
          a = Kb(a, "_emval_take_value");
          a = a.readValueFromPointer(b);
          return V(a);
        },
        m: function() {
          y();
        },
        B: function(a, b, c2) {
          B.copyWithin(a, b, b + c2);
        },
        C: function() {
          y("OOM");
        },
        D: function() {
          return 0;
        },
        y: function() {
        },
        o: function(a, b, c2, e) {
          for (var f = 0, g = 0; g < c2; g++) {
            for (var m = E[b + 8 * g >> 2], h = E[b + (8 * g + 4) >> 2], k = 0; k < h; k++) {
              var l = B[m + k], n = Vb[a];
              l === 0 || l === 10 ? ((a === 1 ? ja : z)(pa(n, 0)), n.length = 0) : n.push(l);
            }
            f += h;
          }
          E[e >> 2] = f;
          return 0;
        },
        memory: la,
        K: function() {
        },
        r: function() {
        },
        J: function() {
        },
        I: function() {
        },
        A: function() {
        },
        table: ma
      }, $b = function() {
        function a(f) {
          d.asm = f.exports;
          H--;
          d.monitorRunDependencies && d.monitorRunDependencies(H);
          H == 0 && (La && (f = La, La = null, f()));
        }
        function b(f) {
          a(f.instance);
        }
        function c2(f) {
          return Qa().then(function(g) {
            return WebAssembly.instantiate(g, e);
          }).then(f, function(g) {
            z("failed to asynchronously prepare wasm: " + g);
            y(g);
          });
        }
        var e = { a: Zb };
        H++;
        d.monitorRunDependencies && d.monitorRunDependencies(H);
        if (d.instantiateWasm)
          try {
            return d.instantiateWasm(e, a);
          } catch (f) {
            return z("Module.instantiateWasm callback failed with error: " + f), false;
          }
        (function() {
          if (ka || typeof WebAssembly.instantiateStreaming !== "function" || Na() || Ma("file://") || typeof fetch !== "function")
            return c2(b);
          fetch(I, { credentials: "same-origin" }).then(function(f) {
            return WebAssembly.instantiateStreaming(f, e).then(b, function(g) {
              z("wasm streaming compile failed: " + g);
              z("falling back to ArrayBuffer instantiation");
              c2(b);
            });
          });
        })();
        return {};
      }();
      d.asm = $b;
      var Ra = d.___wasm_call_ctors = function() {
        return (Ra = d.___wasm_call_ctors = d.asm.P).apply(null, arguments);
      };
      d.__Z6ToCmdsRK6SkPath = function() {
        return (d.__Z6ToCmdsRK6SkPath = d.asm.Q).apply(null, arguments);
      };
      d.__Z8FromCmdsmi = function() {
        return (d.__Z8FromCmdsmi = d.asm.R).apply(null, arguments);
      };
      d.__Z7NewPathv = function() {
        return (d.__Z7NewPathv = d.asm.S).apply(null, arguments);
      };
      d.__Z8CopyPathRK6SkPath = function() {
        return (d.__Z8CopyPathRK6SkPath = d.asm.T).apply(null, arguments);
      };
      d.__Z6EqualsRK6SkPathS1_ = function() {
        return (d.__Z6EqualsRK6SkPathS1_ = d.asm.U).apply(null, arguments);
      };
      d.__Z11ToSVGStringRK6SkPath = function() {
        return (d.__Z11ToSVGStringRK6SkPath = d.asm.V).apply(null, arguments);
      };
      d.__Z13FromSVGStringNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEE = function() {
        return (d.__Z13FromSVGStringNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEE = d.asm.W).apply(null, arguments);
      };
      d.__Z13ApplySimplifyR6SkPath = function() {
        return (d.__Z13ApplySimplifyR6SkPath = d.asm.X).apply(null, arguments);
      };
      d.__Z11ApplyPathOpR6SkPathRKS_8SkPathOp = function() {
        return (d.__Z11ApplyPathOpR6SkPathRKS_8SkPathOp = d.asm.Y).apply(null, arguments);
      };
      d.__Z10MakeFromOpRK6SkPathS1_8SkPathOp = function() {
        return (d.__Z10MakeFromOpRK6SkPathS1_8SkPathOp = d.asm.Z).apply(null, arguments);
      };
      d.__Z14ResolveBuilderR11SkOpBuilder = function() {
        return (d.__Z14ResolveBuilderR11SkOpBuilder = d.asm._).apply(null, arguments);
      };
      d.__Z8ToCanvasRK6SkPathN10emscripten3valE = function() {
        return (d.__Z8ToCanvasRK6SkPathN10emscripten3valE = d.asm.$).apply(null, arguments);
      };
      d.__Z8ToPath2DRK6SkPath = function() {
        return (d.__Z8ToPath2DRK6SkPath = d.asm.aa).apply(null, arguments);
      };
      var Y = d._free = function() {
        return (Y = d._free = d.asm.ba).apply(null, arguments);
      }, Yb = d._malloc = function() {
        return (Yb = d._malloc = d.asm.ca).apply(null, arguments);
      }, Ab = d.___getTypeName = function() {
        return (Ab = d.___getTypeName = d.asm.da).apply(null, arguments);
      };
      d.___embind_register_native_and_builtin_types = function() {
        return (d.___embind_register_native_and_builtin_types = d.asm.ea).apply(null, arguments);
      };
      d.dynCall_vi = function() {
        return (d.dynCall_vi = d.asm.fa).apply(null, arguments);
      };
      d.dynCall_iiiii = function() {
        return (d.dynCall_iiiii = d.asm.ga).apply(null, arguments);
      };
      d.dynCall_ii = function() {
        return (d.dynCall_ii = d.asm.ha).apply(null, arguments);
      };
      d.dynCall_i = function() {
        return (d.dynCall_i = d.asm.ia).apply(null, arguments);
      };
      d.dynCall_viifffffffff = function() {
        return (d.dynCall_viifffffffff = d.asm.ja).apply(null, arguments);
      };
      d.dynCall_vifffffi = function() {
        return (d.dynCall_vifffffi = d.asm.ka).apply(null, arguments);
      };
      d.dynCall_vifffff = function() {
        return (d.dynCall_vifffff = d.asm.la).apply(null, arguments);
      };
      d.dynCall_viffffff = function() {
        return (d.dynCall_viffffff = d.asm.ma).apply(null, arguments);
      };
      d.dynCall_vifffffffi = function() {
        return (d.dynCall_vifffffffi = d.asm.na).apply(null, arguments);
      };
      d.dynCall_viff = function() {
        return (d.dynCall_viff = d.asm.oa).apply(null, arguments);
      };
      d.dynCall_viffff = function() {
        return (d.dynCall_viffff = d.asm.pa).apply(null, arguments);
      };
      d.dynCall_vii = function() {
        return (d.dynCall_vii = d.asm.qa).apply(null, arguments);
      };
      d.dynCall_iii = function() {
        return (d.dynCall_iii = d.asm.ra).apply(null, arguments);
      };
      d.dynCall_iifff = function() {
        return (d.dynCall_iifff = d.asm.sa).apply(null, arguments);
      };
      d.dynCall_iiffi = function() {
        return (d.dynCall_iiffi = d.asm.ta).apply(null, arguments);
      };
      d.dynCall_vifffffffff = function() {
        return (d.dynCall_vifffffffff = d.asm.ua).apply(null, arguments);
      };
      d.dynCall_iiii = function() {
        return (d.dynCall_iiii = d.asm.va).apply(null, arguments);
      };
      d.dynCall_viii = function() {
        return (d.dynCall_viii = d.asm.wa).apply(null, arguments);
      };
      d.dynCall_viiii = function() {
        return (d.dynCall_viiii = d.asm.xa).apply(null, arguments);
      };
      d.dynCall_fif = function() {
        return (d.dynCall_fif = d.asm.ya).apply(null, arguments);
      };
      d.dynCall_viif = function() {
        return (d.dynCall_viif = d.asm.za).apply(null, arguments);
      };
      d.dynCall_fi = function() {
        return (d.dynCall_fi = d.asm.Aa).apply(null, arguments);
      };
      d.dynCall_viiifffffffff = function() {
        return (d.dynCall_viiifffffffff = d.asm.Ba).apply(null, arguments);
      };
      d.dynCall_viifffffi = function() {
        return (d.dynCall_viifffffi = d.asm.Ca).apply(null, arguments);
      };
      d.dynCall_viifffff = function() {
        return (d.dynCall_viifffff = d.asm.Da).apply(null, arguments);
      };
      d.dynCall_viiffffff = function() {
        return (d.dynCall_viiffffff = d.asm.Ea).apply(null, arguments);
      };
      d.dynCall_viifffffffi = function() {
        return (d.dynCall_viifffffffi = d.asm.Fa).apply(null, arguments);
      };
      d.dynCall_viiff = function() {
        return (d.dynCall_viiff = d.asm.Ga).apply(null, arguments);
      };
      d.dynCall_viiffff = function() {
        return (d.dynCall_viiffff = d.asm.Ha).apply(null, arguments);
      };
      d.dynCall_iiifff = function() {
        return (d.dynCall_iiifff = d.asm.Ia).apply(null, arguments);
      };
      d.dynCall_iiiffi = function() {
        return (d.dynCall_iiiffi = d.asm.Ja).apply(null, arguments);
      };
      d.dynCall_fii = function() {
        return (d.dynCall_fii = d.asm.Ka).apply(null, arguments);
      };
      d.dynCall_iiffff = function() {
        return (d.dynCall_iiffff = d.asm.La).apply(null, arguments);
      };
      d.dynCall_fiif = function() {
        return (d.dynCall_fiif = d.asm.Ma).apply(null, arguments);
      };
      d.dynCall_iiif = function() {
        return (d.dynCall_iiif = d.asm.Na).apply(null, arguments);
      };
      d.dynCall_vifii = function() {
        return (d.dynCall_vifii = d.asm.Oa).apply(null, arguments);
      };
      d.dynCall_viifd = function() {
        return (d.dynCall_viifd = d.asm.Pa).apply(null, arguments);
      };
      d.dynCall_viid = function() {
        return (d.dynCall_viid = d.asm.Qa).apply(null, arguments);
      };
      d.dynCall_viddi = function() {
        return (d.dynCall_viddi = d.asm.Ra).apply(null, arguments);
      };
      d.dynCall_iidi = function() {
        return (d.dynCall_iidi = d.asm.Sa).apply(null, arguments);
      };
      d.dynCall_viffi = function() {
        return (d.dynCall_viffi = d.asm.Ta).apply(null, arguments);
      };
      d.dynCall_fffff = function() {
        return (d.dynCall_fffff = d.asm.Ua).apply(null, arguments);
      };
      d.dynCall_viiiii = function() {
        return (d.dynCall_viiiii = d.asm.Va).apply(null, arguments);
      };
      d.dynCall_viiiiiffii = function() {
        return (d.dynCall_viiiiiffii = d.asm.Wa).apply(null, arguments);
      };
      d.dynCall_iiiiii = function() {
        return (d.dynCall_iiiiii = d.asm.Xa).apply(null, arguments);
      };
      d.dynCall_iiiiiii = function() {
        return (d.dynCall_iiiiiii = d.asm.Ya).apply(null, arguments);
      };
      d.dynCall_iidiiii = function() {
        return (d.dynCall_iidiiii = d.asm.Za).apply(null, arguments);
      };
      d.dynCall_jiji = function() {
        return (d.dynCall_jiji = d.asm._a).apply(null, arguments);
      };
      d.asm = $b;
      var ac;
      La = function bc() {
        ac || cc();
        ac || (La = bc);
      };
      function cc() {
        function a() {
          if (!ac && (ac = true, d.calledRun = true, !na)) {
            Ea(Ga);
            Ea(Ha);
            aa(d);
            if (d.onRuntimeInitialized)
              d.onRuntimeInitialized();
            if (d.postRun)
              for (typeof d.postRun == "function" && (d.postRun = [d.postRun]); d.postRun.length; ) {
                var b = d.postRun.shift();
                Ia.unshift(b);
              }
            Ea(Ia);
          }
        }
        if (!(0 < H)) {
          if (d.preRun)
            for (typeof d.preRun == "function" && (d.preRun = [d.preRun]); d.preRun.length; )
              Ja();
          Ea(Fa);
          0 < H || (d.setStatus ? (d.setStatus("Running..."), setTimeout(function() {
            setTimeout(function() {
              d.setStatus("");
            }, 1);
            a();
          }, 1)) : a());
        }
      }
      d.run = cc;
      if (d.preInit)
        for (typeof d.preInit == "function" && (d.preInit = [d.preInit]); 0 < d.preInit.length; )
          d.preInit.pop()();
      cc();
      return PathKitInit3.ready;
    };
  }();
  module.exports = PathKitInit2;
})(pathkit);
var PathKitInit = pathkit.exports;
class PathKitManager {
  constructor(editor) {
    this.editor = editor;
    this.pathkit = null;
  }
  async load() {
    this.registerPathKit(await PathKitInit());
  }
  registerPathKit(pathkit2) {
    this.pathkit = pathkit2;
    this.editor.emit("updatePathKit");
  }
  has() {
    return !!this.pathkit;
  }
  booleanOperation(first, second2, pathOp) {
    const PathKit = this.pathkit;
    return PathKit.MakeFromOp(PathKit.FromSVGString(first), PathKit.FromSVGString(second2), pathOp).toSVGString();
  }
  intersection(first, second2) {
    const PathKit = this.pathkit;
    if (!PathKit)
      return;
    return this.reversePathString(this.booleanOperation(first, second2, PathKit.PathOp.INTERSECT));
  }
  union(first, second2) {
    const PathKit = this.pathkit;
    if (!PathKit)
      return;
    return this.booleanOperation(first, second2, PathKit.PathOp.UNION);
  }
  difference(first, second2) {
    const PathKit = this.pathkit;
    if (!PathKit)
      return;
    return this.reversePathString(this.booleanOperation(first, second2, PathKit.PathOp.DIFFERENCE));
  }
  reverseDifference(first, second2) {
    const PathKit = this.pathkit;
    if (!PathKit)
      return;
    return this.reversePathString(this.booleanOperation(first, second2, PathKit.PathOp.REVERSE_DIFFERENCE));
  }
  xor(first, second2) {
    const PathKit = this.pathkit;
    if (!PathKit)
      return;
    return this.reversePathString(this.booleanOperation(first, second2, PathKit.PathOp.XOR));
  }
  reversePathString(pathString2) {
    return PathParser.fromSVGString(pathString2).reversePathStringByFunc((_, index2) => index2 % 2 === 0);
  }
  isValidPath(path) {
    const PathKit = this.pathkit;
    let pathKitPath = PathKit.FromSVGString(path);
    return pathKitPath.isValid();
  }
  simplify(path) {
    const PathKit = this.pathkit;
    const pathObject = PathKit.FromSVGString(path);
    return pathObject.simplify().toSVGString();
  }
  convertLineJoin(lineJoin) {
    const PathKit = this.pathkit;
    switch (lineJoin) {
      case "miter":
        return PathKit.StrokeJoin.MITER;
      case "round":
        return PathKit.StrokeJoin.ROUND;
      case "bevel":
        return PathKit.StrokeJoin.BEVEL;
    }
  }
  convertLineCap(lineCap) {
    const PathKit = this.pathkit;
    switch (lineCap) {
      case "butt":
        return PathKit.StrokeCap.BUTT;
      case "round":
        return PathKit.StrokeCap.ROUND;
      case "square":
        return PathKit.StrokeCap.SQUARE;
    }
  }
  stroke(path, opt = { width: 1, miter_limit: 4 }) {
    const PathKit = this.pathkit;
    const pathObject = PathKit.FromSVGString(path);
    if (isArray(opt["stroke-dasharray"])) {
      const arr = opt["stroke-dasharray"];
      if (arr.length >= 2) {
        pathObject.dash(arr[0], arr[1], +(opt["stroke-dashoffset"] || 0));
      }
    }
    let newPathObject = pathObject.stroke({
      width: +opt["stroke-width"],
      join: this.convertLineJoin(opt["stroke-linejoin"]),
      cap: this.convertLineCap(opt["stroke-linecap"])
    });
    newPathObject.setFillType(PathKit.FillType.WINDING);
    return newPathObject.simplify().toSVGString();
  }
  round(path, opt = { width: 1, miter_limit: 4 }) {
    return this.stroke(path, __spreadProps(__spreadValues({}, opt), {
      "stroke-linejoin": "round"
    }));
  }
  grow(path, opt = { width: 1, miter_limit: 4 }) {
    const PathKit = this.pathkit;
    const pathObject = PathKit.FromSVGString(path);
    return pathObject.copy().stroke(opt).op(pathObject, PathKit.PathOp.DIFFERENCE).toSVGString();
  }
  shrink(path, opt = { width: 1, miter_limit: 4 }) {
    const PathKit = this.pathkit;
    const pathObject = PathKit.FromSVGString(path);
    const simplifyPath = pathObject.copy().simplify();
    return pathObject.copy().stroke(opt).op(simplifyPath, PathKit.PathOp.DIFFERENCE).toSVGString();
  }
  dash(path, on, off, phase = 1) {
    const PathKit = this.pathkit;
    const pathObject = PathKit.FromSVGString(path);
    return pathObject.dash(on, off, phase).toSVGString();
  }
  trim(path, startT, stopT, isComplement = false) {
    const PathKit = this.pathkit;
    const pathObject = PathKit.FromSVGString(path);
    return pathObject.trim(startT, stopT, isComplement).toSVGString();
  }
}
class SegmentSelectionManager {
  constructor(editor) {
    this.$editor = editor;
    this.selectedPointKeys = {};
    this.selectedPointList = [];
  }
  get length() {
    return this.selectedPointList.length;
  }
  initialize() {
    this.selectedPointKeys = {};
    this.selectedPointList = [];
  }
  makeSegmentKey(index2, key) {
    return `${index2}_${key}`;
  }
  select(...list2) {
    this.selectedPointKeys = {};
    this.selectedPointList = list2.map(({ key, index: index2 }) => ({
      key,
      index: +index2 || 0
    }));
    list2.forEach((it) => {
      var key = this.makeSegmentKey(it.index, it.key);
      this.selectedPointKeys[key] = it;
    });
  }
  toggleSegment(index2, key) {
    if (!this.isSelectedSegment(key, index2)) {
      this.select(...this.selectedPointList, { key, index: index2 });
    } else {
      this.select(...this.selectedPointList.filter((it) => {
        return it.key !== key || it.index !== index2;
      }));
    }
  }
  toggleSelect(...list2) {
    list2 = list2.map((it) => {
      return __spreadProps(__spreadValues({}, it), { included: this.isSelectedSegment(it.index, it.key) });
    });
    const includedList = list2.filter((it) => it.included);
    const notIncludedList = list2.filter((it) => !it.included);
    let uniqueList = [...this.selectedPointList];
    if (includedList.length) {
      uniqueList = this.selectedPointList.filter((it) => {
        const oldKey = this.makeSegmentKey(it);
        return Boolean(includedList.find((includeNode) => {
          return oldKey === this.makeSegmentKey(includeNode);
        })) === false;
      });
    }
    this.select(...uniqueList, ...notIncludedList);
  }
  selectKeyIndex(index2, key) {
    if (!this.isSelectedSegment(index2, key)) {
      this.select({ key, index: index2 });
    }
  }
  isSelectedSegment(index2, key) {
    var key = this.makeSegmentKey(index2, key);
    return !!this.selectedPointKeys[key];
  }
}
class SelectionManager {
  constructor(editor) {
    this.$editor = editor;
    this.$context = this.$editor.context;
    this.project = null;
    this.itemKeys = {};
    this.hoverId = "";
    this.hoverItems = [];
    this.ids = [];
    this.colorsteps = [];
    this.ghosts = [];
    this.cachedItemMatrices = [];
    this.cachedArtBoardVerties = [];
    this.cachedVerties = rectToVerties(0, 0, 0, 0, "50% 50% 0px");
    this.gridInformation = {};
    this.dragTargetItem = null;
    this.$editor.on("config:bodyEvent", () => {
      this.refreshMousePosition();
    });
  }
  refreshMousePosition() {
    const areaWidth = this.$context.config.get("area.width");
    const pos = this.$context.viewport.getWorldPosition();
    this.pos = pos;
    const [row, column] = area$1(pos[0], pos[1], areaWidth);
    this.row = row;
    this.column = column;
  }
  get modelManager() {
    return this.$context.modelManager;
  }
  get lockManager() {
    return this.$context.lockManager;
  }
  get items() {
    return this.modelManager.searchLiveItemsById(this.ids);
  }
  get current() {
    return this.modelManager.searchItem(this.ids[0]);
  }
  get currentProject() {
    if (!this.project) {
      this.project = this.modelManager.getProjectByIndex();
    }
    return this.project;
  }
  get isEmpty() {
    return !this.length;
  }
  get isOne() {
    if (this.length === 1 && this.current.is("artboard"))
      return true;
    return this.length === 1;
  }
  get isMany() {
    return this.length > 1;
  }
  get length() {
    return this.ids.length;
  }
  get isLayoutItem() {
    var _a;
    return (_a = this.current) == null ? void 0 : _a.isLayoutItem();
  }
  get allLayers() {
    return this.currentProject.allLayers || [];
  }
  get filteredLayers() {
    var _a;
    const areaWidth = this.$editor.context.config.get("area.width");
    return ((_a = this.currentProject) == null ? void 0 : _a.filteredAllLayers((item) => {
      if (item.is("project"))
        return false;
      const areaPosition = item.getAreaPosition(areaWidth);
      if (!areaPosition) {
        return false;
      }
      const { column, row } = areaPosition;
      return column[0] <= this.column && this.column <= column[1] && row[0] <= this.row && this.row <= row[1];
    }).filter((item) => {
      return item.isPointInRect(this.pos[0], this.pos[1]);
    })) || [];
  }
  get notSelectedLayers() {
    return this.filteredLayers.filter((it) => this.check(it) === false);
  }
  get selectedArtboards() {
    return [...new Set(this.items.map((it) => it.artboard))];
  }
  hasChangedField(...args2) {
    if (this.current) {
      return this.current.hasChangedField(...args2);
    }
    return false;
  }
  getRootItem(current) {
    var rootItem = current;
    if (current && current.parentId) {
      rootItem = current.parent;
    }
    return rootItem;
  }
  selectColorStep(...args2) {
    this.colorsteps = args2;
  }
  isSelectedColorStep(id) {
    return this.colorsteps.includes(id);
  }
  selectProject(project2) {
    if (isString(project2)) {
      project2 = this.modelManager.get(project2);
    }
    this.project = project2;
    this.select();
  }
  isSameIds(newIds) {
    if (this.ids.length != newIds.length) {
      return false;
    }
    if (this.ids.filter((id) => newIds.includes(id)).length === this.ids.length) {
      return true;
    }
    return false;
  }
  filterIds(ids = []) {
    return ids.map((it) => it.id || it).filter(Boolean);
  }
  selectByGroup(...ids) {
    var list2 = this.modelManager.searchItemsById(this.filterIds(ids || [])).filter((it) => {
      return !this.lockManager.get(it.id);
    });
    const newSelectedItems = this.modelManager.convertGroupItems(list2);
    return this.select(...newSelectedItems);
  }
  select(...ids) {
    var list2 = this.modelManager.searchItemsById(this.filterIds(ids || [])).filter((it) => !it.lock && it.isAbsolute);
    const newSelectedItems = list2.filter((it) => {
      return it.path.filter((element) => list2.includes(element)).length < 2;
    });
    const newSelectedIds = newSelectedItems.map((it) => it.id);
    if (this.isSameIds(newSelectedIds)) {
      return false;
    }
    this.itemKeys = {};
    newSelectedItems.forEach((item) => {
      this.itemKeys[item.id] = item;
    });
    this.ids = newSelectedIds;
    this.setRectCache();
    return true;
  }
  reload() {
    return this.select(...this.ids);
  }
  reselect() {
    this.setRectCache();
  }
  check(item) {
    return !!this.itemKeys[item.id];
  }
  hasPathOf(item) {
    return this.modelManager.hasPathOf(this.items.filter((it) => it.isNot("artboard")), item);
  }
  hasParent(parentId) {
    return this.items.some((it) => it.hasParent(parentId));
  }
  get(id) {
    return this.itemKeys[id];
  }
  empty() {
    this.select();
  }
  itemsByIds(ids = null) {
    let itemIdList = [];
    if (Array.isArray(ids)) {
      itemIdList = ids;
    } else if (isString(ids) || isObject(ids)) {
      itemIdList = [ids];
    }
    return this.modelManager.searchItemsById(itemIdList);
  }
  selectById(id) {
    this.select(id);
  }
  selectAfterCopy() {
    this.select(...this.items.map((it) => it.copy()));
  }
  addById(id) {
    if (this.itemKeys[id])
      return;
    this.select(...this.ids, id);
  }
  removeById(id) {
    let ids = id;
    if (isString(id)) {
      ids = [id];
    }
    const filteredItems = this.ids.filter((id2) => ids.includes(id2) === false);
    this.select(...filteredItems);
  }
  toggleById(id) {
    if (this.itemKeys[id]) {
      this.removeById(id);
    } else {
      this.addById(id);
    }
  }
  getArtboardByPoint(vec) {
    return this.currentProject.artboards.find((artboard2) => {
      return polyPoint(artboard2.originVerties, ...vec);
    });
  }
  changeInLayoutArea() {
    let checkedParentChange = false;
    this.each((instance) => {
      if (instance.is("artboard") === false) {
        if (instance.artboard) {
          const localArtboardVerties = instance.artboard.originVerties;
          const isInArtboard = polyPoint(localArtboardVerties, this.pos[0], this.pos[1]);
          if (isInArtboard) {
            return false;
          }
        }
        const selectedArtBoard = this.cachedArtBoardVerties.find((artboard2) => {
          return polyPoint(artboard2.matrix.originVerties, this.pos[0], this.pos[1]);
        });
        if (selectedArtBoard) {
          if (selectedArtBoard.item !== instance.artboard && selectedArtBoard.item.hasLayout() === false) {
            selectedArtBoard.item.appendChild(instance);
            checkedParentChange = true;
          }
        } else {
          if (instance.artboard) {
            this.currentProject.appendChild(instance);
            checkedParentChange = true;
          }
        }
      }
    });
    return checkedParentChange;
  }
  setRectCache() {
    if (this.isEmpty) {
      this.cachedVerties = [];
      this.cachedRectVerties = [];
      this.cachedItemMatrices = [];
      this.ghosts = [];
      this.cachedArtBoardVerties = this.currentProject.artboards.map((item) => {
        return { item, matrix: item.matrix };
      });
      return;
    }
    this.cachedVerties = this.verties;
    this.cachedRectVerties = toRectVerties(this.verties);
    this.cachedItemMatrices = [];
    this.cachedChildren = [];
    this.ghosts = [];
    this.items.forEach((it) => {
      if (it.is("artboard")) {
        this.cachedItemMatrices.push(it.matrix);
      } else if (it.hasChildren()) {
        const list2 = this.modelManager.getAllLayers(it.id).map((it2) => it2.matrix);
        this.cachedChildren.push(...list2.map((it2) => it2.id));
        this.cachedItemMatrices.push(...list2);
      } else {
        this.cachedItemMatrices.push(it.matrix);
      }
      this.ghosts.push(it.absoluteMatrix);
    });
    this.cachedArtBoardVerties = this.currentProject.artboards.map((item) => {
      return { item, matrix: item.matrix };
    });
  }
  startToCacheChildren() {
    this.items.forEach((item) => {
      item.startToCacheChildren();
    });
  }
  recoverChildren() {
    this.items.forEach((item) => {
      item.recoverChildren();
    });
  }
  get verties() {
    if (this.isOne) {
      return this.current.verties;
    } else {
      return this.rectVerties;
    }
  }
  get targetVerties() {
    if (this.isOne) {
      return this.current.originVerties;
    } else {
      return targetItemsToRectVerties(this.items);
    }
  }
  get originVerties() {
    return this.rectVerties.filter((_, index2) => index2 < 4);
  }
  get rectVerties() {
    if (this.isEmpty) {
      return [];
    }
    return itemsToRectVerties(this.items);
  }
  get itemRect() {
    const verties = this.verties;
    return {
      x: verties[0][0],
      y: verties[0][1],
      width: distance$1(verties[0], verties[1]),
      height: distance$1(verties[0], verties[3])
    };
  }
  toCloneObject() {
    let data = {};
    this.each((item) => {
      data[item.id] = item.toCloneObject(false);
    });
    return data;
  }
  pack(...keys2) {
    let data = {};
    this.each((item) => {
      data[item.id] = {};
      keys2.forEach((key) => {
        data[item.id][key] = item[key];
      });
    });
    return data;
  }
  packByIds(ids, ...keys2) {
    let data = {};
    let localItems = [];
    if (ids === null) {
      localItems = this.items;
    } else if (isString(ids) || Array.isArray(ids)) {
      localItems = this.itemsByIds(ids);
    }
    const valueObject = {};
    keys2.forEach((it) => {
      valueObject[it] = true;
    });
    localItems.forEach((item) => {
      data[item.id] = item.attrs(...keys2);
    });
    return data;
  }
  packByValue(valueObject, ids = null) {
    let data = {};
    let localItems = [];
    if (ids === null) {
      localItems = this.items;
    } else if (isString(ids) || Array.isArray(ids)) {
      localItems = this.itemsByIds(ids);
    }
    localItems.forEach((item) => {
      data[item.id] = {};
      Object.keys(valueObject).forEach((key) => {
        data[item.id][key] = isFunction(valueObject[key]) ? valueObject[key].call(valueObject, item) : valueObject[key];
      });
    });
    return data;
  }
  each(callback) {
    if (isFunction(callback)) {
      this.items.forEach((item) => {
        callback(item);
      });
    }
  }
  map(callback) {
    if (isFunction(callback)) {
      return this.items.map((item, index2) => {
        return callback(item, index2);
      });
    }
    return this.items;
  }
  reset(obj2) {
    Object.entries(obj2).forEach(([id, attrs]) => {
      var _a;
      (_a = this.get(id)) == null ? void 0 : _a.reset(attrs);
    });
  }
  resetCallback(callback) {
    this.each((item) => item.reset(callback(item)));
  }
  resize() {
    this.each((item) => item.resize());
  }
  remove() {
    this.each((item) => item.remove());
    this.empty();
  }
  copy() {
    console.warn("copy is deprecated");
    this.copyItems = this.items.map((item) => item);
  }
  paste() {
    console.warn("paste is deprecated. use copy and paste");
    this.select(...this.copyItems.map((item) => item.copy(10)));
    this.copy();
  }
  hasPoint(point2) {
    var _a;
    if (this.isMany) {
      return polyPoint(this.originVerties, point2[0], point2[1]);
    } else {
      return (_a = this.current) == null ? void 0 : _a.hasPoint(point2[0], point2[1]);
    }
  }
  hasChildrenPoint(point2) {
    return this.cachedChildren.some((it) => {
      var _a;
      return (_a = this.modelManager.get(it)) == null ? void 0 : _a.hasPoint(point2[0], point2[1]);
    });
  }
  checkChildren(childId) {
    return this.cachedChildren.includes(childId);
  }
  checkHover(itemOrId) {
    if (isString(itemOrId)) {
      return this.hoverId === itemOrId;
    } else {
      return this.hoverItems.findIndex((it) => it.id === itemOrId.id) > -1;
    }
  }
  hasHoverItem() {
    return this.hoverId !== "";
  }
  selectHoverItem() {
    this.select(this.hoverId);
  }
  setHoverId(id) {
    let isChanged = false;
    if (!id || this.itemKeys[id]) {
      if (this.hoverId != "") {
        isChanged = true;
      }
      this.hoverId = "";
      this.hoverItems = [];
    } else if (this.cachedArtBoardVerties.find((it) => it.item.id === id)) {
      if (this.hoverId != "") {
        isChanged = true;
      }
      this.hoverId = "";
      this.hoverItems = [];
    } else {
      if (this.hoverId != id) {
        isChanged = true;
      }
      this.hoverId = id;
      this.hoverItems = this.itemsByIds([id]).filter((it) => it.isNot("artboard"));
      if (this.hoverItems.length === 0) {
        this.hoverId = "";
        isChanged = true;
      }
    }
    if (isChanged) {
      this.$editor.emit("changeHoverItem");
    }
    return isChanged;
  }
  is(...args2) {
    var _a;
    return args2.includes((_a = this.current) == null ? void 0 : _a.itemType);
  }
  isAll(...args2) {
    return this.items.every((it) => args2.includes(it.itemType));
  }
  updateGridInformation(obj2 = {}) {
    this.gridInformation = obj2;
  }
  updateDragTargetItem(item) {
    this.dragTargetItem = item;
  }
}
const MAX_SNAP_DISTANCE = 3;
const DEFAULT_DIST_VECTOR = { dist: fromValues(0, 0, 0) };
const AXIS_X = "x";
const AXIS_Y = "y";
function checkXAxis(sourceVertex, targetVertex, dist2 = 1) {
  return Math.abs(sourceVertex[0] - targetVertex[0]) < dist2;
}
function checkYAxis(sourceVertex, targetVertex, dist2 = 1) {
  return Math.abs(sourceVertex[1] - targetVertex[1]) < dist2;
}
class SnapManager {
  constructor(editor, snapDistance = MAX_SNAP_DISTANCE) {
    this.editor = editor;
    this.context = this.editor.context;
    this.map = /* @__PURE__ */ new Map();
    this.snapTargetLayers = [];
    this.snapDistance = snapDistance;
  }
  get dist() {
    return this.context.config.get("snap.distance") || this.snapDistance;
  }
  get gridSize() {
    return this.context.config.get("snap.grid") || 50;
  }
  makeSnapTargetLayers() {
    if (!this.context.selection.currentProject)
      return [];
    return this.context.selection.currentProject.allLayers.filter((item) => {
      if (item.is("project"))
        return false;
      if (this.context.selection.check(item))
        return false;
      const inViewport = this.context.viewport.checkInViewportArea(item.originVerties);
      return inViewport;
    });
  }
  clear() {
    this.snapTargetLayers = this.makeSnapTargetLayers();
  }
  convertMatrix(item) {
    const verties = this.convertGuideAndPathMatrix(item);
    const xList = verties.map((it) => it[0]);
    const yList = verties.map((it) => it[1]);
    return {
      id: item.id,
      xList,
      yList,
      verties,
      rectVerties: toRectVertiesWithoutTransformOrigin(item.originVerties)
    };
  }
  convertGuideAndPathMatrix(item) {
    const guideVerties = item.guideVerties;
    return [...guideVerties];
  }
  get snapTargetLayersWithSelection() {
    if (!this.context.selection.currentProject)
      return [];
    return this.context.selection.currentProject.allLayers.filter((item) => {
      if (item.is("project"))
        return false;
      const inViewport = item.verties.some((v) => {
        return this.context.viewport.checkInViewport(v);
      });
      return inViewport;
    });
  }
  getSnapPoints() {
    const points = [];
    this.snapTargetLayersWithSelection.forEach((it) => {
      points.push.apply(points, this.convertGuideAndPathMatrix(it));
    });
    return points;
  }
  checkX(targetXList, sourceXList, dist2 = 0) {
    const checkXList = [];
    targetXList.forEach((targetX, targetIndex) => {
      sourceXList.forEach((sourceX, sourceIndex) => {
        if (Math.abs(targetX - sourceX) <= dist2) {
          checkXList.push({
            targetX,
            sourceX,
            sourceIndex,
            targetIndex,
            dx: targetX - sourceX
          });
        }
      });
    });
    return checkXList;
  }
  checkY(targetYList, sourceYList, dist2 = 0) {
    const checkYList = [];
    targetYList.forEach((targetY, targetIndex) => {
      sourceYList.forEach((sourceY, sourceIndex) => {
        const localDistY = targetY - sourceY;
        if (Math.abs(localDistY) <= dist2) {
          checkYList.push({
            targetY,
            sourceY,
            sourceIndex,
            targetIndex,
            dy: localDistY
          });
        }
      });
    });
    return checkYList;
  }
  check(sourceVerties, dist2 = 0) {
    const snaps = [];
    const sourceXList = sourceVerties.map((it) => it[0]);
    const sourceYList = sourceVerties.map((it) => it[1]);
    const guideXList = this.context.config.get("horizontal.line");
    const guideYList = this.context.config.get("vertical.line");
    const x = this.checkX(guideXList, sourceXList, dist2)[0];
    const y = this.checkY(guideYList, sourceYList, dist2)[0];
    const distVector = fromValues(x ? x.dx : 0, y ? y.dy : 0, 0);
    if (isNotZero(distVector[0]) || isNotZero(distVector[1])) {
      snaps.push({ target: null, dist: distVector });
    }
    this.snapTargetLayers.forEach((target) => {
      const x2 = this.checkX(target.xList, sourceXList, dist2)[0];
      const y2 = this.checkY(target.yList, sourceYList, dist2)[0];
      const distVector2 = fromValues(x2 ? x2.dx : 0, y2 ? y2.dy : 0, 0);
      if (isNotZero(distVector2[0]) || isNotZero(distVector2[1])) {
        snaps.push({ target, dist: distVector2 });
      }
    });
    return snaps.find((it) => isNotZero(it[0]) || isNotZero(it[1])) || DEFAULT_DIST_VECTOR;
  }
  checkPoint(sourceVertex) {
    const snap = this.check([sourceVertex]);
    return add$1([], sourceVertex, snap.dist);
  }
  getGuidesByPointPoint(sourceVerties, targetVerties, dist$1 = 0) {
    const points = [];
    const groupPoints = {};
    let sourceVertex, targetVertex;
    for (let sourceIndex = 0, sourceLength = sourceVerties.length; sourceIndex < sourceLength; sourceIndex++) {
      sourceVertex = sourceVerties[sourceIndex];
      const keyX = `${sourceVertex[0]}_x`;
      const keyY = `${sourceVertex[1]}_y`;
      if (!groupPoints[keyX]) {
        groupPoints[keyX] = [];
      }
      if (!groupPoints[keyY]) {
        groupPoints[keyY] = [];
      }
      for (let targetIndex = 0, targetLength = targetVerties.length; targetIndex < targetLength; targetIndex++) {
        targetVertex = targetVerties[targetIndex];
        if (checkXAxis(sourceVertex, targetVertex, dist$1)) {
          groupPoints[keyX].push([
            sourceVertex,
            targetVertex,
            AXIS_X,
            dist(sourceVertex, targetVertex)
          ]);
        }
        if (checkYAxis(sourceVertex, targetVertex, dist$1)) {
          groupPoints[keyY].push([
            sourceVertex,
            targetVertex,
            AXIS_Y,
            dist(sourceVertex, targetVertex)
          ]);
        }
      }
    }
    Object.keys(groupPoints).forEach((key) => {
      if (groupPoints[key] && groupPoints[key].length) {
        const sorted = groupPoints[key].sort((a, b) => a[3] - b[3]);
        points.push(...sorted);
      }
    });
    return points;
  }
  findGuide(sourceVerties, dist2 = 0) {
    const guides = [];
    this.snapTargetLayers.forEach((target) => {
      const points = this.getGuidesByPointPoint(sourceVerties, target.guideVerties, dist2);
      guides.push.apply(guides, points);
    });
    guides.sort((a, b) => {
      return a[3] - b[3];
    });
    return guides.filter((_, index2) => index2 < 10);
  }
  findGuideOne(sourceVerties) {
    return [this.findGuide(sourceVerties)[0]];
  }
  getWorldPosition() {
    const pos = round$2([], this.context.viewport.getWorldPosition());
    const snap = this.check([pos], 3 / this.context.viewport.scale);
    const newPos = add$1([], snap.dist, pos);
    return newPos;
  }
  getSnapTarget() {
    const pos = round$2([], this.context.viewport.getWorldPosition());
    const snap = this.check([pos], 3 / this.context.viewport.scale);
    const newPos = add$1([], snap.dist, pos);
    return {
      vertex: newPos,
      snap
    };
  }
}
class TimelineSelectionManager {
  constructor(editor) {
    this.$editor = editor;
    this.items = [];
    this.itemKeys = {};
  }
  initialize() {
    this.items = [];
    this.itemKeys = {};
  }
  currentProject(callback) {
    var project2 = this.$editor.context.selection.currentProject;
    if (project2) {
      callback && callback(project2);
    }
  }
  empty() {
    this.select();
  }
  each(callback) {
    this.items.forEach((item, index2) => {
      callback && callback(item, index2);
    });
  }
  refreshCache(list2) {
    this.items = list2;
    this.itemKeys = {};
    this.items.forEach((it) => {
      this.itemKeys[it.id] = it;
    });
  }
  cachedList() {
    return this.items.map((it) => {
      return __spreadValues({}, it);
    });
  }
  checked(id) {
    return !!this.itemKeys[id];
  }
  selectLayer(layerId) {
    this.currentProject((project2) => {
      var list2 = project2.getKeyframeListReturnArray().filter((it) => {
        return it.layerId === layerId;
      });
      this.refreshCache(list2);
    });
  }
  toggleLayerContainer(animationId) {
    this.currentProject((project2) => {
      project2.getSelectedTimeline().animations.filter((it) => {
        return it.id === animationId;
      }).forEach((it) => {
        it.collapsed = !it.collapsed;
      });
    });
  }
  selectProperty(layerId, property) {
    this.currentProject((project2) => {
      var list2 = project2.getKeyframeListReturnArray().filter((it) => {
        return it.layerId === layerId && it.property === property;
      });
      this.refreshCache(list2);
    });
  }
  select(...args2) {
    this.refreshCache(args2);
  }
  selectBySearch(list2, startTime, endTime) {
    this.currentProject((project2) => {
      var totalList = [];
      list2.forEach((it) => {
        var results = [];
        if (it.property) {
          var p = project2.getTimelineProperty(it.layerId, it.property);
          results = p.keyframes.filter((keyframe2) => {
            return startTime <= keyframe2.time && keyframe2.time <= endTime;
          });
        } else {
          var p = project2.getTimelineObject(it.layerId);
          p.properties.filter((property) => {
            return property.property === it.property;
          }).forEach((property) => {
            results.push.apply(results, property.keyframes.filter((keyframe2) => {
              return startTime <= keyframe2.time && keyframe2.time <= endTime;
            }));
          });
        }
        totalList.push.apply(totalList, results);
      });
      var uniqueOffset = {};
      totalList.forEach((it) => {
        uniqueOffset[it.id] = it;
      });
      this.select(...Object.values(uniqueOffset));
    });
  }
  checkLayer(layerId) {
    return Object.keys(this.itemKeys).some((key) => {
      return this.itemKeys[key].layerId === layerId;
    });
  }
  checkProperty(layerId, property) {
    return Object.keys(this.itemKeys).some((key) => {
      return this.itemKeys[key].layerId === layerId && this.itemKeys[key].property === property;
    });
  }
}
class VisibleManager {
  constructor(editor) {
    this.editor = editor;
    this.hiddenList = {};
  }
  get list() {
    return Object.keys(this.hiddenList);
  }
  get(key) {
    return !this.hiddenList[key];
  }
  set(key, value) {
    if (value) {
      delete this.hiddenList[key];
    } else {
      this.hiddenList[key] = true;
    }
  }
  toggle(key) {
    if (this.get(key)) {
      this.set(key, false);
    } else {
      this.set(key, true);
    }
  }
}
var ContextMenuRenderer$1 = "";
class ContextDropdownMenu extends DropdownMenuList {
  template() {
    return `
      <div class="dropdown-menu opened flat">
          <ul>
              ${this.props.items.map((child, index2) => makeMenuItem(child, `${this.groupId}-${index2}`)).join("")}
          </ul>
      </div>
    `;
  }
}
class ContextMenuRenderer extends EditorElement {
  checkProps(props = {}) {
    return props;
  }
  components() {
    return {
      ContextDropdownMenu,
      ToolbarButtonMenuItem
    };
  }
  template() {
    return `<div class="elf--context-menu-renderer"></div>`;
  }
  [LOAD("$el")]() {
    var _a;
    return (_a = this.props.items) == null ? void 0 : _a.map((item, index2) => {
      return this.renderMenuItem(item, index2);
    });
  }
  renderMenuItem(item, index2) {
    switch (item.type) {
      case MenuItemType.LINK:
        return this.renderLink(item, index2);
      case MenuItemType.SUBMENU:
        return this.renderMenu(item, index2);
      case MenuItemType.BUTTON:
        return this.renderButton(item, index2);
      case MenuItemType.DROPDOWN:
        return this.renderDropdown(item, index2);
      default:
        return this.renderButton(item, index2);
    }
  }
  renderButton(item, index2) {
    return createComponent("ToolbarButtonMenuItem", {
      ref: "$button-" + index2,
      title: item.title,
      icon: item.icon,
      command: item.command,
      shortcut: item.shortcut,
      args: item.args,
      nextTick: item.nextTick,
      disabled: item.disabled,
      selected: item.selected,
      selectedKey: item.selectedKey,
      checked: item.checked,
      action: item.action,
      events: item.events,
      style: item.style
    });
  }
  renderDropdown(item, index2) {
    return createComponent("ContextDropdownMenu", __spreadProps(__spreadValues({
      ref: "$dropdown-" + index2
    }, item), {
      items: item.items,
      icon: item.icon,
      title: item.title,
      events: item.events || []
    }));
  }
}
var ContextMenuView$1 = "";
class ContextMenuView extends EditorElement {
  template() {
    return /* @__PURE__ */ createElementJsx("div", {
      class: "elf--context-menu-view"
    });
  }
  [BIND("$el")]() {
    const contextMenuOpenInfo = this.$context.config.get("context.menu.open");
    if (!contextMenuOpenInfo) {
      return;
    }
    return {
      style: {
        left: Length.px(contextMenuOpenInfo.x),
        top: Length.px(contextMenuOpenInfo.y + 10)
      }
    };
  }
  [LOAD("$el")]() {
    const info = this.$context.config.get("context.menu.open");
    if (!info)
      return;
    const items = this.$menu.getTargetMenu(info.target) || [];
    return /* @__PURE__ */ createElementJsx(ContextMenuRenderer, {
      items: [{ type: "dropdown", items: [...items, ...info.items || []] }]
    });
  }
  [CONFIG("context.menu.open")]() {
    this.refresh();
    if (this.$context.config.get("context.menu.open")) {
      this.$el.show();
    } else {
      this.$el.hide();
    }
  }
  close() {
    this.$el.hide();
    this.$context.config.set("context.menu.open", null);
  }
  [POINTERSTART("document")](e) {
    const $target = Dom.create(e.target);
    const $dropdown = $target.closest("elf--context-menu-view");
    if (!$dropdown) {
      this.close();
    } else if ($dropdown.el !== this.$el.el) {
      this.close();
    }
  }
}
var AlignmentProperty$1 = "";
class BottomAlign extends MenuItem {
  getIconString() {
    return "align_vertical_bottom";
  }
  getTitle() {
    return "Bottom";
  }
  isHideTitle() {
    return true;
  }
  clickButton() {
    this.$commands.emit("sort.bottom");
  }
}
class CenterAlign extends MenuItem {
  getIconString() {
    return "align_horizontal_center";
  }
  getTitle() {
    return "Center";
  }
  isHideTitle() {
    return true;
  }
  clickButton() {
    this.$commands.emit("sort.center");
  }
}
class LeftAlign extends MenuItem {
  getIconString() {
    return "align_horizontal_left";
  }
  getTitle() {
    return "Left";
  }
  isHideTitle() {
    return true;
  }
  clickButton() {
    this.$commands.emit("sort.left");
  }
}
class MiddleAlign extends MenuItem {
  getIconString() {
    return "align_vertical_center";
  }
  getTitle() {
    return "middle";
  }
  isHideTitle() {
    return true;
  }
  clickButton() {
    this.$commands.emit("sort.middle");
  }
}
class RightAlign extends MenuItem {
  getIconString() {
    return "align_horizontal_right";
  }
  getTitle() {
    return "Right";
  }
  isHideTitle() {
    return true;
  }
  clickButton() {
    this.$commands.emit("sort.right");
  }
}
class SameHeight extends MenuItem {
  getIconString() {
    return "vertical_distribute";
  }
  getTitle() {
    return "height";
  }
  isHideTitle() {
    return true;
  }
  clickButton() {
    this.$commands.emit("same.height");
  }
}
class SameWidth extends MenuItem {
  getIconString() {
    return "horizontal_distribute";
  }
  getTitle() {
    return "width";
  }
  isHideTitle() {
    return true;
  }
  clickButton() {
    this.$commands.emit("same.width");
  }
}
class TopAlign extends MenuItem {
  getIconString() {
    return "align_vertical_top";
  }
  getTitle() {
    return "Top";
  }
  isHideTitle() {
    return true;
  }
  clickButton() {
    this.$commands.emit("sort.top");
  }
}
var BaseProperty$1 = "";
class BaseProperty extends EditorElement {
  onToggleShow() {
  }
  template() {
    return `
        <div class='elf--property ${this.isHideHeader() ? "no-title" : ""} ${this.getClassName()} ${this.isFirstShow() ? "show" : ""}'>
            ${this.isHideHeader() ? "" : `
            <div class='property-title ${this.getTitleClassName()}' ref="$title">
                <label class="${this.hasKeyframe() ? "has-keyframe" : ""}"> 
                  ${this.hasKeyframe() ? `
                      <span class='add-timeline-property' data-property='${this.getKeyframeProperty()}'></span>
                    ` : ""} 
                  <span ref='$propertyTitle'>${this.getTitle()}</span>
                </label>
                <span class="tools">${this.getTools()}</span>
            </div>`}
            <div class='property-body ${this.getBodyClassName()}'>${this.getBody()}</div>
            ${this.getFooter() ? `<div class='property-footer'>${this.getFooter()}</div>` : ""}
        </div>
        `;
  }
  [BIND("$el")]() {
    return {
      style: {
        "--property-order": this.order
      }
    };
  }
  setTitle(title2) {
    this.refs.$propertyTitle.html(title2);
  }
  hasKeyframe() {
    return false;
  }
  isHideHeader() {
    return false;
  }
  isFirstShow() {
    return true;
  }
  getClassName() {
    return "";
  }
  getTitleClassName() {
    return "";
  }
  getBodyClassName() {
    return "";
  }
  getKeyframeProperty() {
    return "";
  }
  getTitle() {
    return "";
  }
  getTools() {
    return "";
  }
  getBody() {
    return "";
  }
  getFooter() {
    return "";
  }
  isPropertyShow() {
    return this.$el.hasClass("show");
  }
  toggle(isShow) {
    this.$el.toggle(isShow);
  }
  hide() {
    this.$el.hide();
  }
  show() {
    this.$el.show();
  }
  onShowTitle() {
  }
  refreshShowIsNot(type = "", isRefresh = true) {
    var current = this.$context.selection.current;
    if (current) {
      if (type.includes(current.itemType)) {
        this.hide();
      } else {
        this.show();
        if (isRefresh)
          this.refresh();
      }
    }
  }
  refreshShow(type, isRefresh = true) {
    var current = this.$context.selection.current;
    if (current) {
      if (isFunction(type) && type()) {
        this.show();
        if (isRefresh)
          this.refresh();
      } else {
        if (!isFunction(type) && type.includes(current.itemType)) {
          this.show();
          if (isRefresh)
            this.refresh();
        } else {
          this.hide();
        }
      }
    } else {
      this.hide();
    }
  }
  startInputEditing(input2) {
    if (!input2)
      return;
    input2.attr("contenteditable", true);
    input2.css({
      "background-color": "white",
      outline: "1px auto black",
      color: "black"
    });
    input2.focus();
  }
  endInputEditing(input2, callback) {
    if (!input2)
      return;
    input2.attr("contenteditable", false);
    input2.css({
      "background-color": null,
      outline: null,
      color: null
    });
    var index2 = input2.attr("data-index");
    callback && callback(index2, input2.text().trim());
    input2.blur();
  }
  get editableProperty() {
    return "";
  }
  get order() {
    return 1e3;
  }
  checkShow() {
    if (!this.$context.selection.current) {
      this.hide();
      return false;
    }
    if (this.$context.selection.current.editable(this.editableProperty)) {
      this.show();
      return true;
    } else {
      this.hide();
      return false;
    }
  }
}
class AlignmentProperty extends BaseProperty {
  components() {
    return {
      LeftAlign,
      CenterAlign,
      RightAlign,
      TopAlign,
      MiddleAlign,
      BottomAlign,
      SameWidth,
      SameHeight
    };
  }
  getTitle() {
    return this.$i18n("alignment.property.title");
  }
  isHideHeader() {
    return true;
  }
  getBody() {
    return `
      <div class="elf--alignment-item">
        ${createComponentList("LeftAlign", "CenterAlign", "RightAlign", "TopAlign", "MiddleAlign", "BottomAlign", ["SameWidth", { direction: "bottom" }], "SameHeight")}
      </div>
    `;
  }
}
function alignment(editor) {
  editor.registerUI("inspector.tab.style", {
    AlignmentProperty
  });
}
var AnimationProperty$1 = "";
function getCustomParseIndexString(it, prefix = "@") {
  return `${prefix}${it.startIndex}`.padEnd(10, "0");
}
function customParseMatches(str, regexp) {
  const matches2 = str.match(regexp);
  let result = [];
  if (!matches2) {
    return result;
  }
  for (var i = 0, len2 = matches2.length; i < len2; i++) {
    result.push({ parsedString: matches2[i] });
  }
  var pos = { next: 0 };
  result.forEach((item) => {
    const startIndex = str.indexOf(item.parsedString, pos.next);
    item.startIndex = startIndex;
    item.endIndex = startIndex + item.parsedString.length;
    pos.next = item.endIndex;
  });
  return result;
}
function customParseConvertMatches(str, regexp) {
  const m = customParseMatches(str, regexp);
  m.forEach((it) => {
    str = str.replace(it.parsedString, getCustomParseIndexString(it));
  });
  return { str, matches: m };
}
function customParseReverseMatches(str, matches2) {
  matches2.forEach((it) => {
    str = str.replace(getCustomParseIndexString(it), it.parsedString);
  });
  return str;
}
const ANIMATION_TIMING_REG = /((cubic-bezier|steps)\(([^)]*)\))/gi;
class Animation extends PropertyItem {
  static parse(obj2) {
    return new Animation(obj2);
  }
  getDefaultObject() {
    return {
      itemType: "animation",
      checked: true,
      name: "none",
      direction: "normal",
      duration: Length.second(0),
      timingFunction: "linear",
      delay: Length.second(0),
      iterationCount: Length.string("infinite"),
      playState: "running",
      fillMode: "none"
    };
  }
  convert(json) {
    json = super.convert(json);
    json.duration = Length.parse(json.duration);
    json.iterationCount = Length.parse(json.iterationCount);
    return json;
  }
  toCloneObject() {
    return __spreadValues({}, this.attrs("name", "direction", "duration", "timingFunction", "delay", "iterationCount", "playState", "fillMode"));
  }
  togglePlayState(forcedValue) {
    if (forcedValue) {
      this.reset({
        playState: forcedValue === "running" ? "running" : "paused"
      });
    } else {
      if (this.json.playState === "paused") {
        this.reset({ playState: "running" });
      } else {
        this.reset({ playState: "paused" });
      }
    }
  }
  toCSS() {
    if (!this.json.name)
      return {};
    return {
      animation: this.toString()
    };
  }
  toString() {
    var json = this.json;
    return [
      json.duration,
      json.timingFunction,
      json.delay,
      json.iterationCount,
      json.direction,
      json.fillMode,
      json.playState,
      json.name
    ].join(" ");
  }
  static join(list2) {
    return list2.map((it) => new Animation(it).toString()).join(",");
  }
  static add(animation2, item = {}) {
    const list2 = Animation.parseStyle(animation2);
    list2.push(Animation.parse(item));
    return Animation.join(list2);
  }
  static remove(animation2, removeIndex) {
    return Animation.filter(animation2, (it, index2) => {
      return removeIndex != index2;
    });
  }
  static filter(animation2, filterFunction) {
    return Animation.join(Animation.parseStyle(animation2).filter((it) => filterFunction(it)));
  }
  static replace(animation2, replaceIndex, valueObject) {
    var list2 = Animation.parseStyle(animation2);
    if (list2[replaceIndex]) {
      list2[replaceIndex] = valueObject;
    } else {
      list2.push(valueObject);
    }
    return Animation.join(list2);
  }
  static get(animation2, index2) {
    var arr = Animation.parseStyle(animation2);
    return arr[index2];
  }
  static parseStyle(animation2) {
    var list2 = [];
    if (!animation2)
      return list2;
    const result = customParseConvertMatches(animation2, ANIMATION_TIMING_REG);
    list2 = result.str.split(",").map((it) => {
      const fields2 = it.split(" ").filter(Boolean);
      if (fields2.length >= 7) {
        return {
          duration: Length.parse(fields2[0]),
          timingFunction: customParseReverseMatches(fields2[1], result.matches),
          delay: Length.parse(fields2[2]),
          iterationCount: fields2[3] === "infinite" ? Length.string("infinite") : Length.parse(fields2[3]),
          direction: fields2[4],
          fillMode: fields2[5],
          playState: fields2[6],
          name: fields2[7]
        };
      } else if (fields2.length >= 3) {
        return {
          duration: Length.parse(fields2[0]),
          timingFunction: customParseReverseMatches(fields2[1], result.matches),
          delay: Length.parse(fields2[2]),
          name: fields2[3]
        };
      } else if (fields2.length >= 1) {
        return {
          duration: Length.parse(fields2[0]),
          name: fields2[1]
        };
      } else {
        return {};
      }
    });
    return list2.map((it) => Animation.parse(it));
  }
}
class AnimationProperty extends BaseProperty {
  getTitle() {
    return this.$i18n("animation.property.title");
  }
  getBody() {
    return `<div class='animation-list' ref='$animationList'></div>`;
  }
  getTools() {
    return `
        <button type="button" ref="$add" title="add Fill">${iconUse("add")}</button>
    `;
  }
  isFirstShow() {
    return true;
  }
  [LOAD("$animationList") + DOMDIFF]() {
    var current = this.$context.selection.current;
    if (!current)
      return "";
    return Animation.parseStyle(current.animation).map((it, index2) => {
      const selectedClass = this.state.selectedIndex === index2 ? "selected" : "";
      const path = curveToPath(it.timingFunction, 30, 30);
      return `
      <div class='animation-group-item'>
        <div class='animation-item ${selectedClass}' 
             data-index='${index2}' 
             ref="animationIndex${index2}" 
          >
            <div class='timing preview' data-index='${index2}' ref='$preview${index2}'>
              <svg class='item-canvas' width="30" height="30" viewBox="0 0 30 30">
                <path d="${path}" stroke="white" stroke-width="1" fill='none' />
              </svg>
            </div>
            <div class='name'>
              <div class='title' ref="animationName${index2}">
                ${it.name ? it.name : `&lt; ${this.$i18n("animation.property.select a keyframe")} &gt;`}
              </div>
              <div class='labels'>
                <label class='count' title='${this.$i18n("animation.property.iteration.count")}'><small>${it.iterationCount}</small></label>
                <label class='delay' title='${this.$i18n("animation.property.delay")}'><small>${it.delay}</small></label>
                <label class='duration' title='${this.$i18n("animation.property.duration")}'><small>${it.duration}</small></label>
                <label class='direction' title='${this.$i18n("animation.property.direction")}'><small>${it.direction}</small></label>
                <label class='fill-mode' title='${this.$i18n("animation.property.fill.mode")}'><small>${it.fillMode}</small></label>
                <label class='play-state' title='${this.$i18n("animation.property.play.state")}' data-index='${index2}' data-play-state-selected-value="${it.playState}">
                  <small data-play-state-value='running'>${iconUse("play")}</small>
                  <small data-play-state-value='paused'>${iconUse("pause")}</small>
                </label>
              </div>
            </div>
            <div class='tools'>
                <button type="button" class="del" data-index="${index2}">
                  ${iconUse("remove2")}
                </button>
            </div>
        </div>
      </div>        
      `;
    });
  }
  [SUBSCRIBE(REFRESH_SELECTION) + DEBOUNCE(100)]() {
    const current = this.$context.selection.current;
    if (current && current.hasChangedField("animation")) {
      this.refresh();
    }
    this.emit("hideAnimationPropertyPopup");
  }
  [CLICK("$add")]() {
    var current = this.$context.selection.current;
    if (current) {
      this.$commands.executeCommand("setAttribute", "add animation property", this.$context.selection.packByValue({
        animation: (item) => Animation.add(item.animation, { name: null })
      }));
      this.nextTick(() => {
        window.setTimeout(() => {
          this.refresh();
        }, 100);
      });
    } else {
      window.alert("Select a layer");
    }
  }
  [CLICK("$animationList .tools .del")](e) {
    var removeIndex = e.$dt.attr("data-index");
    var current = this.$context.selection.current;
    if (!current)
      return;
    current.reset({
      animation: Animation.remove(current.animation, removeIndex)
    });
    this.$commands.emit("setAttribute", this.$context.selection.packByValue({
      animation: Animation.remove(current.animation, removeIndex)
    }));
    this.refresh();
  }
  [CLICK("$animationList .play-state")](e) {
    var index2 = +e.$dt.attr("data-index");
    var current = this.$context.selection.current;
    if (!current)
      return;
    const list2 = Animation.parseStyle(current.animation);
    var animation2 = list2[index2];
    if (animation2) {
      animation2.togglePlayState();
      e.$dt.attr("data-play-state-selected-value", animation2.playState);
      this.$commands.emit("setAttribute", this.$context.selection.packByValue({
        animation: Animation.join(list2)
      }));
    }
  }
  selectItem(selectedIndex, isSelected = true) {
    if (isSelected) {
      this.refs[`animationIndex${selectedIndex}`].addClass("selected");
    } else {
      this.refs[`animationIndex${selectedIndex}`].removeClass("selected");
    }
  }
  viewAnimationPicker($preview) {
    if (typeof this.selectedIndex === "number") {
      this.selectItem(this.selectedIndex, false);
    }
    this.selectedIndex = +$preview.attr("data-index");
    this.current = this.$context.selection.current;
    if (!this.current)
      return;
    this.currentAnimation = Animation.get(this.current.animation, this.selectedIndex);
    this.viewAnimationPropertyPopup();
  }
  viewAnimationPropertyPopup() {
    if (!this.currentAnimation)
      return;
    const animation2 = this.currentAnimation;
    this.emit("showAnimationPropertyPopup", {
      changeEvent: "changeAnimationPropertyPopup",
      data: animation2.toCloneObject(),
      instance: this
    });
  }
  [CLICK("$animationList .preview")](e) {
    this.viewAnimationPicker(e.$dt);
  }
  getRef(...args2) {
    return this.refs[args2.join("")];
  }
  [SUBSCRIBE("changeAnimationPropertyPopup")](data) {
    if (this.currentAnimation) {
      this.currentAnimation.reset(__spreadValues({}, data));
      if (this.current) {
        this.$commands.executeCommand("setAttribute", "change animation property", this.$context.selection.packByValue({
          animation: (item) => Animation.replace(item.animation, this.selectedIndex, this.currentAnimation)
        }));
        this.refresh();
      }
    }
  }
}
var AnimationPropertyPopup$1 = "";
class AnimationPropertyPopup extends BasePopup {
  getTitle() {
    return this.$i18n("animation.property.popup.title");
  }
  initState() {
    return {
      changeEvent: "",
      instance: {},
      data: {}
    };
  }
  updateData(opt) {
    this.state.data = __spreadValues(__spreadValues({}, this.state.data), opt);
    if (this.state.instance) {
      this.state.instance.trigger(this.state.changeEvent, this.state.data);
    }
  }
  getBody() {
    return `<div class='elf--animation-property-popup' ref='$popup'></div>`;
  }
  [LOAD("$popup")]() {
    return `
      <div class="box">
        ${this.templateForKeyframe()}
        ${this.templateForTimingFunction()}
        ${this.templateForIterationCount()}
        ${this.templateForDelay()}
        ${this.templateForDuration()}
        ${this.templateForDirection()}
        ${this.templateForFillMode()}
        ${this.templateForPlayState()}
      </div>
    `;
  }
  templateForTimingFunction() {
    return `
    <div class='timing-function'>
      <label>${this.$i18n("animation.property.popup.timing.function")}</label>
      ${createComponent("CubicBezierEditor", {
      ref: "$cubicBezierEditor",
      key: "timingFunction",
      value: this.state.data.timingFunction || "linear",
      onChange: "changeCubicBezier"
    })}
    </div>
    `;
  }
  templateForKeyframe() {
    return `
      <div class='name'>
        <label>${this.$i18n("animation.property.popup.keyframe")}</label>
        <div class='input grid-1'>
          <select ref='$name'></select>
        </div>
      </div>
    `;
  }
  [LOAD("$name")]() {
    var current = this.$context.selection.currentProject;
    var names2 = [];
    if (current && current.keyframes) {
      names2 = current.keyframes.map((it) => {
        return { key: it.name, value: it.name };
      });
    }
    names2.unshift({ key: "Select a keyframe", value: "" });
    return names2.map((it) => {
      var selected = it.value === this.name ? "selected" : "";
      var label = this.$i18n(it.key);
      return `<option value='${it.value}' ${selected}>${label}</option>`;
    });
  }
  [CHANGE("$name")]() {
    this.updateData({ name: this.refs.$name.value });
  }
  templateForDirection() {
    var options2 = "normal,reverse,alternate,alternate-reverse".split(",").map((it) => {
      return `${it}:${this.$i18n(it)}`;
    }).join(",");
    return `
      <div class='direction'>
        ${createComponent("SelectEditor", {
      label: this.$i18n("animation.property.popup.direction"),
      ref: "$direction",
      key: "direction",
      value: this.state.data.direction,
      options: options2,
      onChange: "changeSelect"
    })}
      </div>
    `;
  }
  [SUBSCRIBE_SELF("changeSelect")](key, value) {
    this.updateData({ [key]: value });
  }
  templateForPlayState() {
    return `
    <div class='play-state'>
      ${createComponent("SelectEditor", {
      label: this.$i18n("animation.property.popup.play.state"),
      ref: "$playState",
      key: "playState",
      value: this.state.data.playState,
      options: ["paused", "running"],
      onChange: "changeSelect"
    })}
    </div>
  `;
  }
  templateForFillMode() {
    var options2 = "none,forwards,backwards,both".split(",").map((it) => {
      return `${it}:${this.$i18n(it)}`;
    }).join(",");
    return `
    <div class='fill-mode'>
      ${createComponent("SelectEditor", {
      label: this.$i18n("animation.property.popup.fill.mode"),
      ref: "$fillMode",
      key: "fillMode",
      value: this.state.data.fillMode,
      options: options2,
      onChange: "changeSelect"
    })}
    </div>
  `;
  }
  templateForDelay() {
    return `
    <div class='delay'>
      ${createComponent("RangeEditor", {
      ref: "$delay",
      label: this.$i18n("animation.property.popup.delay"),
      key: "delay",
      value: this.state.data.delay,
      units: ["s", "ms"],
      onChange: "changeRangeEditor"
    })} 
    </div>
    `;
  }
  templateForDuration() {
    return `
    <div class='duration'>
      ${createComponent("RangeEditor", {
      ref: "$duration",
      label: this.$i18n("animation.property.popup.duration"),
      key: "duration",
      value: this.state.data.duration,
      units: ["s", "ms"],
      onChange: "changeRangeEditor"
    })} 
    </div>
    `;
  }
  templateForIterationCount() {
    return `
      <div class='iteration-count'>
        ${createComponent("IterationCountEditor", {
      ref: "$iterationCount",
      label: this.$i18n("animation.property.popup.iteration"),
      key: "iterationCount",
      value: this.state.iterationCount || 0,
      units: ["normal", "infinite"],
      onChange: "changeRangeEditor"
    })}
      </div>
    `;
  }
  [SUBSCRIBE_SELF("changeRangeEditor")](key, value) {
    if (key === "iterationCount") {
      if (value.unit === "normal") {
        value = Length.number(value.value);
      } else {
        value = Length.string(value.unit);
      }
    }
    this.updateData({ [key]: value });
  }
  [SUBSCRIBE_SELF("changeCubicBezier")](key, value) {
    this.updateData({ [key]: value });
  }
  [SUBSCRIBE("showAnimationPropertyPopup")](data) {
    this.setState(data);
    this.show(250);
    this.children.$cubicBezierEditor.trigger("showCubicBezierEditor", data.data.timingFunction);
  }
  [SUBSCRIBE("hideAnimationPropertyPopup")]() {
    this.$el.hide();
  }
}
function animation(editor) {
  editor.registerUI("inspector.tab.transition", {
    AnimationProperty
  });
  editor.registerUI("popup", {
    AnimationPropertyPopup
  });
}
class ObjectProperty {
  static create(json) {
    return class extends BaseProperty {
      getTitle() {
        return json.title;
      }
      getClassName() {
        return json.className || "item";
      }
      get editableProperty() {
        return json.editableProperty;
      }
      get order() {
        return isUndefined(json.order) ? 1e3 : json.order;
      }
      afterComponentRendering($dom, refName, instance) {
        var _a;
        if (refName == "$comp") {
          const current = ((_a = this.$context.selection) == null ? void 0 : _a.current) || {};
          const inspector = isFunction(json.inspector) ? json.inspector(current) : this.$context.components.createInspector(current, json.editableProperty);
          instance.setInspector(inspector);
        }
      }
      refresh() {
        const current = this.$context.selection.current || {};
        if (current || json.visible) {
          this.setTitle(json.title || current.getDefaultTitle() || current.itemType || current.name);
          this.load();
        }
      }
      [SUBSCRIBE(REFRESH_SELECTION) + IF("checkShow")]() {
        if (json.preventUpdate) {
          if (this.$stateManager.isPointerUp) {
            this.refresh();
          }
        } else {
          this.refresh();
        }
      }
      [LOAD("$body")]() {
        var _a;
        var current = (_a = this.$context.selection) == null ? void 0 : _a.current;
        if (!current && !json.visible)
          return "";
        const inspector = isFunction(json.inspector) ? json.inspector(current || {}) : this.$context.components.createInspector(current || {}, json.editableProperty);
        return createComponent("ComponentEditor", {
          ref: "$comp",
          inspector,
          onchange: "changeComponentProperty"
        });
      }
      getBody() {
        return `<div ref='$body'></div>`;
      }
      [SUBSCRIBE_SELF("changeComponentProperty")](key, value) {
        if (json.action) {
          this.$commands.executeCommand(json.action, `change attribute : ${key}`, key, value);
        } else {
          this.$commands.executeCommand("setAttribute", `change attribute : ${key}`, this.$context.selection.packByValue({
            [key]: value
          }));
        }
      }
    };
  }
}
function appearance(editor) {
  editor.registerUI("inspector.tab.style", {
    AppearanceProperty: ObjectProperty.create({
      title: editor.$i18n("background.color.property.title"),
      editableProperty: "appearance",
      preventUpdate: true,
      inspector: (current) => {
        return [
          {
            type: "column",
            size: [1, 1],
            columns: [
              {
                key: "backgroundColor",
                editor: "color-view",
                editorOptions: {
                  compact: true,
                  format: true
                },
                defaultValue: current.backgroundColor
              },
              {
                key: "mixBlendMode",
                editor: "blend-select",
                editorOptions: {
                  label: "tonality",
                  compact: true
                },
                defaultValue: current.mixBlendMode || BlendMode.NORMAL
              }
            ]
          },
          {
            key: "overflow",
            editor: "select",
            editorOptions: {
              label: editor.$i18n("background.color.property.overflow"),
              options: [
                Overflow.VISIBLE,
                Overflow.HIDDEN,
                Overflow.SCROLL,
                Overflow.AUTO
              ].map((it) => {
                return {
                  value: it,
                  text: editor.$i18n(`background.color.property.overflow.${it}`)
                };
              })
            },
            defaultValue: current.overflow
          }
        ];
      }
    })
  });
}
var ArtBoardSizeProperty$1 = "";
var artboardSize = [
  {
    category: "Web",
    groups: [
      {
        group: "Landscape",
        devices: [
          { device: "Web Small", size: "1024x600" },
          { device: "Web Medium", size: "1280x800" },
          { device: "Web Large", size: "1440x900" },
          { device: "Web X Large", size: "1920x1200" }
        ]
      },
      {
        group: "Portrait",
        devices: [
          { device: "Web Small", size: "600x1024" },
          { device: "Web Medium", size: "800x1280" },
          { device: "Web Large", size: "900x1440" },
          { device: "Web X Large", size: "1200x1920" }
        ]
      }
    ]
  },
  {
    category: "Apple Devices",
    groups: [
      {
        group: "iphone",
        devices: [
          { device: "iPhone 8", size: "375x667" },
          { device: "iPhone 8 Plus", size: "414x736" },
          { device: "iPhone SE", size: "320x568" },
          { device: "iPhone XS", size: "375x812" },
          { device: "iPhone XR", size: "414x896" },
          { device: "iPhone XS Max", size: "414x896" }
        ]
      },
      {
        group: "ipad",
        devices: [
          { device: "iPad", size: "768x1024" },
          { device: "iPad Pro", size: "1024x1366" }
        ]
      },
      {
        group: "apple watch",
        devices: [
          { device: "Apple Watch 38nm", size: "272x340" },
          { device: "Apple Watch 40nm", size: "326x394" },
          { device: "Apple Watch 42nm", size: "313x390" },
          { device: "Apple Watch 44nm", size: "368x448" }
        ]
      },
      {
        group: "apple tv",
        devices: [{ device: "Apple TV", size: "1920x1080" }]
      },
      { group: "MAC", devices: [{ device: "Touch Bar", size: "1085x30" }] }
    ]
  },
  {
    category: "Android Devices",
    groups: [
      {
        group: "android mobile",
        devices: [{ device: "Android Mobile", size: "360x640" }]
      },
      {
        group: "android tablet",
        devices: [{ device: "Android Tablet", size: "768x1024" }]
      }
    ]
  }
];
class ArtBoardSizeProperty extends BaseProperty {
  getClassName() {
    return "elf--artboard-size-list";
  }
  get editableProperty() {
    return "artboardSize";
  }
  [SUBSCRIBE(REFRESH_SELECTION) + IF("checkShow")]() {
    this.refresh();
  }
  initState() {
    return {
      selectedIndex: 0
    };
  }
  getTitle() {
    return "ArtBoard Preset";
  }
  getTools() {
    var categories2 = artboardSize.map((it, index2) => {
      return { category: it.category, index: index2 };
    });
    return createComponent("SelectEditor", {
      ref: "$select",
      value: categories2[0].category,
      options: categories2.map((it) => it.category),
      onchange: "changeSizeIndex"
    });
  }
  [SUBSCRIBE_SELF("changeSizeIndex")](key, value) {
    var selectedIndex = this.state.selectedIndex;
    artboardSize.forEach((it, index2) => {
      if (it.category === value) {
        selectedIndex = index2;
      }
    });
    this.state.selectedIndex = selectedIndex;
    this.refresh();
  }
  getBody() {
    return `
      <div class='artboard-size-item' ref='$list'></div>
    `;
  }
  makeDevice(device) {
    return `
      <div class='device-item' data-size='${device.size}'>
        <div class='title'>${device.device}</div>
        <div class='size'>${device.size}</div>
      </div>
    `;
  }
  [CLICK("$list .device-item")](e) {
    var size2 = e.$dt.attr("data-size");
    this.$commands.emit("resizeArtBoard", size2);
  }
  makeGroup(group2) {
    return `
      <div class='group-item'>
        <div class='title'>${group2.group}</div>
      </div>
      <div class='devices'>
        ${group2.devices.map((device) => this.makeDevice(device)).join("")}
      </div>
    `;
  }
  makeCategory(category) {
    return `
      <div class='category'>
        <div class='title'>${category.category}</div>
      </div>
      <div class='groups'>
        ${category.groups.map((group2) => this.makeGroup(group2)).join("")}
      </div>
    `;
  }
  [LOAD("$list") + DOMDIFF]() {
    var category = artboardSize[this.state.selectedIndex];
    return category.groups.map((group2) => this.makeGroup(group2));
  }
}
function artboard(editor) {
  editor.registerUI("inspector.tab.style", {
    ArtBoardSizeProperty
  });
}
var BackdropFilterProperty$1 = "";
const filter_list$1 = [
  "blur",
  "grayscale",
  "hue-rotate",
  "invert",
  "brightness",
  "contrast",
  "drop-shadow",
  "opacity",
  "saturate",
  "sepia",
  "svg"
];
class BackdropFilterProperty extends BaseProperty {
  getTitle() {
    return this.$i18n("backdrop.filter.property.title");
  }
  getTitleClassName() {
    return "filter";
  }
  getBodyClassName() {
    return "no-padding";
  }
  getBody() {
    return `<div class='full filter-property' ref='$body'></div>`;
  }
  getTools() {
    return `
      <select class="filter-select" ref="$filterSelect"></select>
      <button type="button" ref="$add" title="add Filter">${iconUse("add")}</button>
    `;
  }
  [CLICK("$add")]() {
    var filterType = this.refs.$filterSelect.value;
    this.children.$filterEditor.trigger("add", filterType);
  }
  [LOAD("$filterSelect")]() {
    var list2 = filter_list$1.map((it) => {
      return { title: this.$i18n(`filter.property.${it}`), value: it };
    });
    var svgFilterList = this.getSVGFilterList();
    var totalList = [];
    if (svgFilterList.length) {
      totalList = [...list2, { title: "-------", value: "" }, ...svgFilterList];
    } else {
      totalList = [...list2];
    }
    return totalList.map((it) => {
      var { title: title2, value } = it;
      return `<option value='${value}'>${title2}</option>`;
    });
  }
  getSVGFilterList() {
    var current = this.$context.selection.currentProject;
    var arr = [];
    if (current) {
      arr = current.svgfilters.map((it) => {
        return {
          title: `svg - #${it.id}`,
          value: it.id
        };
      });
    }
    return arr;
  }
  [LOAD("$body")]() {
    var current = this.$context.selection.current || {};
    var value = current.backdropFilter;
    return `
      <div>
        ${createComponent("FilterEditor", {
      ref: "$filterEditor",
      key: "backdropFilter",
      value,
      hideLabel: true,
      onchange: "changeFilterEditor"
    })}
      </div>
    `;
  }
  [SUBSCRIBE_SELF("changeFilterEditor")](key, filter2) {
    this.$commands.executeCommand("setAttribute", "change backdrop filter", this.$context.selection.packByValue({
      [key]: filter2
    }));
  }
  get editableProperty() {
    return "backdropFilter";
  }
  [SUBSCRIBE(REFRESH_SELECTION) + IF("checkShow") + DEBOUNCE(1e3)]() {
    this.refresh();
  }
}
function backdropFilter(editor) {
  editor.registerUI("inspector.tab.style", {
    BackdropFilterProperty
  });
}
class BackgroundClipProperty extends BaseProperty {
  getTitle() {
    return "Background Clip";
  }
  isFirstShow() {
    return false;
  }
  getTools() {
    return `<div ref='$backgroundClip' style='padding-top: 3px;'></div>`;
  }
  [LOAD("$backgroundClip")]() {
    var current = this.$context.selection.current || {};
    var clip = current.backgroundClip || "";
    return createComponent("SelectEditor", {
      ref: "$1",
      key: "backgroundClip",
      icon: true,
      value: clip,
      options: ["", "paddinb-box", "border-box", "content-box", "text"],
      onchange: "changeSelect"
    });
  }
  [SUBSCRIBE_SELF("changeSelect")](key, value) {
    this.$commands.executeCommand("setAttribute", "change background clip", this.$context.selection.packByValue({
      [key]: value
    }));
  }
  [SUBSCRIBE(REFRESH_SELECTION) + DEBOUNCE(100)]() {
    this.refreshShow(["rect", "circle", "text"]);
  }
}
function backgroundClip(editor) {
  editor.registerElement({
    BackgroundClipProperty
  });
}
var BackgroundImageEditor$1 = "";
const types = {
  image: "image",
  "image-resource": "image",
  url: "image",
  "static-gradient": "gradient",
  "linear-gradient": "gradient",
  "repeating-linear-gradient": "gradient",
  "radial-gradient": "gradient",
  "repeating-radial-gradient": "gradient",
  "conic-gradient": "gradient",
  "repeating-conic-gradient": "gradient"
};
class BackgroundImageEditor extends EditorElement {
  initState() {
    return {
      hideLabel: this.props.hideLabel || false,
      value: this.props.value,
      images: this.parseBackgroundImage(this.props.value)
    };
  }
  parseBackgroundImage(str) {
    if (str === "")
      return [];
    return BackgroundImage.parseStyle(STRING_TO_CSS(str));
  }
  setValue(value) {
    this.setState({
      value,
      images: this.parseBackgroundImage(value)
    });
  }
  template() {
    return `
            <div class='elf--background-image-editor' >
                <div class='fill-list' ref='$fillList'></div>
            </div>
        `;
  }
  [LOAD("$fillList") + DOMDIFF]() {
    const current = this.$context.selection.current || { color: "black" };
    return this.state.images.map((it, index2) => {
      var image2 = it.image;
      var backgroundType = types[image2.type];
      const selectedClass = it.selected ? "selected" : "";
      if (it.selected) {
        this.selectedIndex = index2;
      }
      return `
            <div class='fill-item ${selectedClass}' data-index='${index2}' ref="fillIndex${index2}"  draggable='true' data-fill-type="${backgroundType}" >
                <label draggable="true" data-index="${index2}">${iconUse("drag_indicator")}</label>
                ${createComponentList([
        "BackgroundPositionEditor",
        {
          key: "background-position",
          index: index2,
          ref: `$bp${index2}`,
          x: it.x,
          y: it.y,
          width: it.width,
          height: it.height,
          repeat: it.repeat,
          size: it.size,
          blendMode: it.blendMode,
          onchange: "changePattern"
        }
      ], [
        "GradientSingleEditor",
        {
          index: index2,
          ref: `$gse${index2}`,
          image: it.image,
          color: current.color,
          key: "background-image",
          onchange: "changePattern"
        }
      ])}
                <div class='fill-info'>
                  <div class='gradient-info'>
                    <div class='blend'>
                        ${createComponent("BlendSelectEditor", {
        ref: `$blend_${index2}`,
        key: "blendMode",
        value: it.blendMode,
        params: index2,
        compact: true,
        onchange: "changeRangeEditor"
      })}
                    </div>
                    <div class='tools'>
                      <button type="button" class='visibility' data-index='${index2}' title="Visibility">${iconUse(it.visibility === VisibilityType.HIDDEN ? "visible_off" : "visible")}</button>
                    </div>                                       
                    <div class='tools'>
                      <button type="button" class='copy' data-index='${index2}' title="Copy Item">${iconUse("add")}</button>
                    </div>                    
                    <div class='tools'>
                      <button type="button" class='remove' data-index='${index2}' title="Remove Item">${iconUse("remove2")}</button>
                    </div>
                  </div>
                </div>
            </div>
            `;
    });
  }
  modifyBackgroundImage() {
    var value = CSS_TO_STRING(BackgroundImage.toProperty(this.state.images));
    this.parent.trigger(this.props.onchange, this.props.key, value);
  }
  makeGradient(type) {
    switch (type) {
      case "static-gradient":
        return `static-gradient(black)`;
      case "linear-gradient":
        return `linear-gradient(90deg, white 0%, black 100%)`;
      case "repeating-linear-gradient":
        return `repeating-linear-gradient(90deg, white 2%, black 4%)`;
      case "radial-gradient":
        return `radial-gradient(circle, white 0%, black 100%)`;
      case "repeating-radial-gradient":
        return `repeating-radial-gradient(circle, white 2%, black 4%)`;
      case "conic-gradient":
        return `conic-gradient(white 0%, black 100%)`;
      case "repeating-conic-gradient":
        return `repeating-conic-gradient(white 50%, black 100%)`;
    }
  }
  [SUBSCRIBE("add")](gradientType) {
    this.state.images.unshift(new BackgroundImage({
      image: BackgroundImage.parseImage(this.makeGradient(gradientType))
    }));
    this.refresh();
    this.modifyBackgroundImage();
  }
  [CLICK("$add")]() {
    this.trigger("add");
  }
  [DRAGSTART("$fillList .fill-item > label")](e) {
    this.startIndex = +e.$dt.attr("data-index");
  }
  [DRAGOVER("$fillList .fill-item") + PREVENT]() {
  }
  sortItem(arr, startIndex, targetIndex) {
    arr.splice(targetIndex + (startIndex < targetIndex ? -1 : 0), 0, ...arr.splice(startIndex, 1));
  }
  sortBackgroundImage(startIndex, targetIndex) {
    this.sortItem(this.state.images, startIndex, targetIndex);
  }
  [DROP("$fillList .fill-item") + PREVENT](e) {
    var targetIndex = +e.$dt.attr("data-index");
    this.selectItem(this.startIndex, true);
    this.sortBackgroundImage(this.startIndex, targetIndex);
    this.refresh();
    this.modifyBackgroundImage();
  }
  getCurrentBackgroundImage() {
    return this.state.images[this.selectedIndex];
  }
  [CLICK("$fillList .tools .remove")](e) {
    var removeIndex = +e.$dt.attr("data-index");
    this.state.images.splice(removeIndex, 1);
    this.refresh();
    this.modifyBackgroundImage();
  }
  [CLICK("$fillList .tools .visibility")](e) {
    var index2 = +e.$dt.attr("data-index");
    this.state.images[index2].visibility = this.state.images[index2].visibility === VisibilityType.HIDDEN ? VisibilityType.VISIBLE : VisibilityType.HIDDEN;
    this.refresh();
    this.modifyBackgroundImage();
  }
  [CLICK("$fillList .tools .copy")](e) {
    var index2 = +e.$dt.attr("data-index");
    const current = this.state.images[index2];
    this.state.images.splice(index2, 0, current);
    this.refresh();
    this.modifyBackgroundImage();
  }
  selectItem(selectedIndex, isSelected = true) {
    if (isSelected) {
      this.refs[`fillIndex${selectedIndex}`].addClass("selected");
    } else {
      this.refs[`fillIndex${selectedIndex}`].removeClass("selected");
    }
    this.state.images.forEach((it, index2) => {
      it.selected = index2 === selectedIndex;
    });
  }
  [SUBSCRIBE("selectFillPopupTab")](type) {
    var typeName = types[type];
    var $fillItem = this.refs[`fillIndex${this.selectedIndex}`];
    $fillItem.attr("data-fill-type", typeName);
  }
  [SUBSCRIBE_SELF("changeRangeEditor")](key, value, params) {
    this.trigger("changePattern", key, { [key]: value }, params);
  }
  [SUBSCRIBE_SELF("changePattern")](key, value, params) {
    var index2 = +params;
    var image2 = this.state.images[index2];
    image2.reset(value);
    this.modifyBackgroundImage();
    this.refresh();
  }
}
var BackgroundImagePositionPopup$1 = "";
class BackgroundImagePositionPopup extends BasePopup {
  get localeKey() {
    return "background.image.position.popup";
  }
  getTitle() {
    return this.$i18n("title");
  }
  initState() {
    return {
      size: this.props.size || "auto",
      repeat: this.props.repeat || "repeat",
      x: this.props.x || 0,
      y: this.props.y || 0,
      width: this.props.width || 0,
      height: this.props.height || 0,
      blendMode: this.props.blendMode
    };
  }
  updateData(opt = {}) {
    this.setState(opt, false);
    this.emit(this.state.changeEvent, opt, this.state.params);
  }
  templateForSize() {
    return createComponent("SelectEditor", {
      label: this.$i18n("size"),
      ref: "$size",
      key: "size",
      value: this.state.size,
      options: ["contain", "cover", "auto"],
      onchange: "changeRangeEditor"
    });
  }
  [SUBSCRIBE_SELF("changeRangeEditor")](key, value) {
    this.updateData({ [key]: value });
  }
  templateForX() {
    return createComponent("InputRangeEditor", {
      label: "X",
      compact: true,
      ref: "$x",
      key: "x",
      value: this.state.x,
      min: -1e3,
      max: 1e3,
      step: 1,
      onchange: "changeRangeEditor"
    });
  }
  templateForY() {
    return createComponent("InputRangeEditor", {
      label: "Y",
      compact: true,
      ref: "$y",
      key: "y",
      value: this.state.y,
      min: -1e3,
      max: 1e3,
      step: 1,
      onchange: "changeRangeEditor"
    });
  }
  templateForWidth() {
    return createComponent("InputRangeEditor", {
      label: "W",
      compact: true,
      ref: "$width",
      key: "width",
      value: this.state.width,
      min: 0,
      max: 500,
      step: 1,
      onchange: "changeRangeEditor"
    });
  }
  templateForHeight() {
    return createComponent("InputRangeEditor", {
      label: "H",
      compact: true,
      ref: "$height",
      key: "height",
      value: this.state.height,
      min: 0,
      max: 500,
      step: 1,
      onchange: "changeRangeEditor"
    });
  }
  templateForRepeat() {
    return `
    <div class='grid'>
      <label>${this.$i18n("repeat")}</label>
    </div>
    <div class='repeat-list' ref="$repeat" data-value='${this.state.repeat}'>
        <button type="button" value='no-repeat' title="${this.$i18n("type.no-repeat")}"></button>
        <button type="button" value='repeat' title="${this.$i18n("type.repeat")}"></button>
        <button type="button" value='repeat-x' title="${this.$i18n("type.repeat-x")}"></button>
        <button type="button" value='repeat-y' title="${this.$i18n("type.repeat-y")}"></button>
        <button type="button" value='space' title="${this.$i18n("type.space")}"></button>
        <button type="button" value='round' title="${this.$i18n("type.round")}"></button>
    </div>
    `;
  }
  [CLICK("$repeat button")]({ $dt: $t }) {
    this.refs.$repeat.attr("data-value", $t.value);
    this.updateData({ repeat: $t.value });
  }
  getBody() {
    return `
      <div class="elf--background-image-position-picker" ref='$picker'></div>
    `;
  }
  [LOAD("$picker") + DOMDIFF]() {
    return `
      
      <div class='box'>

        <div class='background-property'>
          ${this.templateForSize()}      
          ${this.templateForX()}
          ${this.templateForY()}
          ${this.templateForWidth()}
          ${this.templateForHeight()}
          ${this.templateForRepeat()}
        </div>
      </div>
    `;
  }
  [SUBSCRIBE("showBackgroundImagePositionPopup")](data, params, rect2) {
    this.state.changeEvent = data.changeEvent || "changeFillPopup";
    this.state.params = params;
    this.setState(data.data);
    this.showByRect(this.makeRect(180, 310, rect2));
  }
}
var BackgroundImageProperty$1 = "";
class BackgroundImageProperty extends BaseProperty {
  getTitle() {
    return this.$i18n("background.image.property.title");
  }
  afterRender() {
    this.show();
  }
  getClassName() {
    return "background-image";
  }
  getBodyClassName() {
    return "no-padding";
  }
  getBody() {
    return /* @__PURE__ */ createElementJsx("div", {
      class: "full",
      ref: "$property"
    });
  }
  getTools() {
    return /* @__PURE__ */ createElementJsx("div", {
      class: "fill-sample-list",
      ref: "$add"
    }, /* @__PURE__ */ createElementJsx("button", {
      type: "button",
      class: "fill",
      "data-value": "static-gradient"
    }, iconUse("add")));
  }
  [CLICK("$add [data-value]")](e) {
    this.children.$backgroundImageEditor.trigger("add", e.$dt.data("value"));
  }
  [LOAD("$property")]() {
    var current = this.$context.selection.current || {};
    var value = current.backgroundImage || "";
    return createComponent("BackgroundImageEditor", {
      ref: "$backgroundImageEditor",
      key: "backgroundImage",
      value,
      onchange: "changeBackgroundImage"
    });
  }
  get editableProperty() {
    return "backgroundImage";
  }
  [SUBSCRIBE(REFRESH_SELECTION) + IF("checkShow")]() {
    this.refresh();
  }
  checkCurrentItem(item) {
    return this.$context.selection.current === item;
  }
  [SUBSCRIBE(UPDATE_CANVAS) + IF("checkCurrentItem") + DEBOUNCE(100)]() {
    if (this.$context.selection.current) {
      if (this.$context.selection.hasChangedField("backgroundImage")) {
        this.refresh();
      }
    }
  }
  [SUBSCRIBE_SELF("changeBackgroundImage")](key, value) {
    this.$commands.executeCommand("setAttribute", "change background image", this.$context.selection.packByValue({
      [key]: value
    }));
  }
}
var BackgroundPositionEditor$1 = "";
class BackgroundPositionEditor extends EditorElement {
  initState() {
    return {
      index: this.props.index,
      x: this.props.x,
      y: this.props.y,
      width: this.props.width,
      height: this.props.height,
      repeat: this.props.repeat,
      size: this.props.size,
      blendMode: this.props.blendMode
    };
  }
  updateData(opt = {}) {
    this.setState(opt, false);
    this.modifyValue(opt);
  }
  modifyValue(value) {
    this.parent.trigger(this.props.onchange, this.props.key, value, this.state.index);
  }
  setValue(obj2) {
    this.setState(__spreadValues({}, obj2));
  }
  [BIND("$miniView")]() {
    return {
      style: {
        "background-image": "linear-gradient(to top right, black, white)",
        "background-repeat": this.state.repeat,
        "background-size": "10px 10px"
      }
    };
  }
  template() {
    return `
            <div class='elf--background-position-editor'>
                <div class='preview' ref='$preview'>
                    <div class='mini-view'>
                        <div class='color-view' ref='$miniView'></div>
                    </div>
                </div>
            </div>
        `;
  }
  [CLICK("$preview")]() {
    this.viewBackgroundPositionPopup();
  }
  viewBackgroundPositionPopup() {
    this.emit("showBackgroundImagePositionPopup", {
      changeEvent: "changeBackgroundPositionPattern",
      data: this.state
    }, {
      id: this.id
    }, this.$el.rect());
  }
  [SUBSCRIBE("changeBackgroundPositionPattern")](pattern, params) {
    if (params.id === this.id) {
      this.updateData(__spreadValues({}, pattern));
    }
  }
}
function backgroundImage(editor) {
  editor.registerElement({
    BackgroundImageEditor,
    BackgroundPositionEditor
  });
  editor.registerUI("inspector.tab.style", {
    BackgroundImageProperty
  });
  editor.registerUI("popup", {
    BackgroundImagePositionPopup
  });
}
var BorderEditor$1 = "";
var BorderStyles = {
  none: true,
  hidden: true,
  dotted: true,
  dashed: true,
  solid: true,
  double: true,
  groove: true,
  ridge: true,
  inset: true,
  outset: true
};
class Border {
  static parseStyle(str) {
    return STRING_TO_CSS(str);
  }
  static parseValue(str = "") {
    var style = "";
    var width2 = "";
    var color2 = "";
    str.split(" ").filter((it) => it.trim()).forEach((value) => {
      if (BorderStyles[value]) {
        style = value;
      } else if (isColor(value)) {
        color2 = value;
      } else {
        width2 = Length.parse(value).value;
      }
    });
    return {
      style,
      color: color2,
      width: width2
    };
  }
  static joinValue(obj2) {
    return `${obj2.width}px ${obj2.style || "solid"} ${obj2.color}`;
  }
  static join(obj2) {
    var arr = [
      obj2["border"] ? `border: ${obj2["border"]}` : "",
      obj2["border-top"] ? `border-top: ${obj2["border-top"]}` : "",
      obj2["border-left"] ? `border-left: ${obj2["border-left"]}` : "",
      obj2["border-right"] ? `border-right: ${obj2["border-right"]}` : "",
      obj2["border-bottom"] ? `border-bottom: ${obj2["border-bottom"]}` : ""
    ].filter((it) => it);
    return arr.join(";");
  }
}
const borderTypeList = [
  "border"
];
const borderTypeTitle = {
  border: "all",
  "border-top": "top",
  "border-right": "right",
  "border-bottom": "bottom",
  "border-left": "left"
};
class BorderEditor extends EditorElement {
  initState() {
    var borders = Border.parseStyle(this.props.value);
    var direction2 = Object.keys(borders)[0] || "border";
    return {
      direction: direction2,
      borders
    };
  }
  updateData(obj2) {
    this.setState(obj2, false);
    this.parent.trigger(this.props.onchange, this.props.key, this.getValue(), this.props.params);
  }
  getValue() {
    return Border.join(this.state.borders);
  }
  setValue(value) {
    this.state.borders = Border.parseStyle(value);
    this.refresh();
  }
  [LOAD("$editorArea")]() {
    return borderTypeList.map((type) => {
      var label = borderTypeTitle[type] || type;
      label = this.$i18n("border.editor." + label);
      return `
      <div>
        ${createComponent("BorderValueEditor", {
        ref: `$${type}`,
        label,
        key: type,
        value: this.state.borders[type],
        onchange: "changeKeyValue"
      })}
      </div>
      `;
    });
  }
  template() {
    return `
      <div class="elf--border-editor">
        <div class='editor-area' ref='$editorArea'>

        </div>
      </div>
    `;
  }
  [SUBSCRIBE_SELF("changeKeyValue")](key, value) {
    var borders = this.state.borders;
    borders[key] = value;
    this.updateData({ borders });
  }
}
var BorderProperty$1 = "";
class BorderProperty extends BaseProperty {
  getTitle() {
    return this.$i18n("border.property.title");
  }
  getBody() {
    return `<div class="property-item full border-item" ref='$body'></div>`;
  }
  [LOAD("$body")]() {
    var current = this.$context.selection.current || {};
    var value = current.border || "";
    return createComponent("BorderEditor", {
      ref: "$1",
      key: "border",
      value,
      onchange: "changeKeyValue"
    });
  }
  get editableProperty() {
    return "border";
  }
  [SUBSCRIBE(REFRESH_SELECTION) + DEBOUNCE(100) + IF("checkShow")]() {
    this.refresh();
  }
  [SUBSCRIBE_SELF("changeKeyValue")](key, value) {
    this.$commands.executeCommand("setAttribute", "change border", this.$context.selection.packByValue({
      [key]: value
    }));
  }
}
var BorderValueEditor$1 = "";
const borderStyleList = [
  BorderStyle.NONE,
  BorderStyle.HIDDEN,
  BorderStyle.SOLID,
  BorderStyle.DASHED,
  BorderStyle.DOTTED,
  BorderStyle.DOUBLE,
  BorderStyle.GROOVE,
  BorderStyle.RIDGE,
  BorderStyle.INSET,
  BorderStyle.OUTSET
].join(",");
class BorderValueEditor extends EditorElement {
  initState() {
    return {
      value: Border.parseValue(this.props.value)
    };
  }
  updateData(obj2) {
    this.setState(obj2, false);
    this.parent.trigger(this.props.onchange, this.props.key, this.getValue(), this.props.params);
  }
  getValue() {
    return Border.joinValue(this.state.value);
  }
  setValue(value) {
    this.state.value = Border.parseValue(value);
    this.refresh();
  }
  refresh() {
    const width2 = Length.parse(this.state.value.width === "undefined" ? 0 : this.state.value.width);
    this.children.$width.setValue(width2.value || 0);
    this.children.$style.setValue(this.state.value.style || "solid");
    this.children.$color.setValue(this.state.value.color || "rgba(0, 0, 0, 1)");
  }
  template() {
    var { width: width2, style, color: color2 } = this.state.value;
    return `
      <div class="elf--border-value-editor">
        <div class='editor-area'>
          ${createComponent("NumberInputEditor", {
      label: iconUse("line_weight"),
      compact: true,
      ref: "$width",
      min: 0,
      max: 100,
      step: 1,
      key: "width",
      value: width2,
      onchange: "changeKeyValue"
    })}
          ${createComponent("SelectEditor", {
      ref: "$style",
      key: "style",
      label: iconUse("line_style"),
      title: "Style",
      compact: true,
      options: borderStyleList,
      value: style || "solid",
      onchange: "changeKeyValue"
    })}
          ${createComponent("ColorViewEditor", {
      ref: "$color",
      key: "color",
      mini: true,
      value: color2 || "rgba(0, 0, 0, 1)",
      onchange: "changeKeyValue"
    })}
        </div>
      </div>
    `;
  }
  [SUBSCRIBE_SELF("changeKeyValue")](key, v) {
    var value = this.state.value;
    value[key] = v;
    this.updateData({ value });
  }
}
function border(editor) {
  editor.registerElement({
    BorderEditor,
    BorderValueEditor
  });
  editor.registerUI("inspector.tab.style", {
    BorderProperty
  });
}
const typeList$1 = [
  { key: "top", title: "Top" },
  { key: "bottom", title: "Bottom" },
  { key: "left", title: "Left" },
  { key: "right", title: "Right" }
];
const keyList$1 = typeList$1.map((it) => it.key);
const names = {
  image: "Image",
  "static-gradient": "Static",
  "linear-gradient": "Linear",
  "repeating-linear-gradient": `${obj$3.repeat} Linear`,
  "radial-gradient": "Radial",
  "repeating-radial-gradient": `${obj$3.repeat} Radial`,
  "conic-gradient": "Conic",
  "repeating-conic-gradient": `${obj$3.repeat} Conic`
};
class BorderImageProperty extends BaseProperty {
  getTitle() {
    return "Border Image";
  }
  [SUBSCRIBE(REFRESH_SELECTION)]() {
    this.refresh();
  }
  getTools() {
    var current = this.$context.selection.current || {};
    var appliedBorderImage = current.appliedBorderImage || false;
    return `
      <label><input type='checkbox' ${appliedBorderImage ? "checked" : ""} ref='$apply' /> Apply</label>
    `;
  }
  [CLICK("$apply")]() {
    var current = this.$context.selection.current;
    if (!current)
      return;
    var applyBorderImage = this.refs.$apply.checked();
    this.$commands.executeCommand("setAttribute", this.$context.selection.packByValue({
      applyBorderImage
    }));
  }
  getColorStepList(image2) {
    switch (image2.type) {
      case "static-gradient":
      case "linear-gradient":
      case "repeating-linear-gradient":
      case "radial-gradient":
      case "repeating-radial-gradient":
      case "conic-gradient":
      case "repeating-conic-gradient":
        return this.getColorStepString(image2.colorsteps);
    }
    return "";
  }
  getColorStepString(colorsteps) {
    return colorsteps.map((step2) => {
      return `<div class='step' data-colorstep-id="${step2.id}" data-selected='${step2.selected}' style='background-color:${step2.color};'></div>`;
    }).join("");
  }
  [LOAD("$borderImageView")]() {
    var current = this.$context.selection.current || {
      borderImage: { image: {} }
    };
    var borderImage2 = current.borderImage;
    var backgroundTypeName = borderImage2.type ? names[borderImage2.type] : "";
    const imageCSS = `background-image: ${borderImage2.image.toString()}; background-size: cover;`;
    return ` 
      <div class='preview' ref="$preview">
        <div class='mini-view'>
          <div class='color-view'  style="${imageCSS}" ref="$miniView"></div>
        </div>
      </div> 
      <div class='fill-info'>
        <div class='gradient-info'>
          <div class='fill-title' ref="$fillTitle">${backgroundTypeName}</div>
          <div class='colorsteps' ref="$colorsteps">
            ${this.getColorStepList(borderImage2.image)}
          </div>
        </div>
      </div>
    `;
  }
  [SUBSCRIBE_SELF("changeBorderImage")](key, value) {
    if (key === "border-image-slice") {
      keyList$1.forEach((type) => {
        this.children[`$${type}Slice`].setValue(value);
      });
    }
    this.setBorderImageProperty();
  }
  getBody() {
    return `
      <div class="property-item border-image-item" ref='$borderImageView'></div>    
      <div class="property-item border-slice-item">
        <div class="slice-selector" data-selected-value="all" ref="$selector">
          <button type="button" data-value="all">${obj$3.border_all}</button>
          <button type="button" data-value="partitial">
            ${obj$3.border_inner}
          </button>
        </div>
        <div class="slice-value">
          ${createComponent("RangeEditor", {
      ref: "$allSlice",
      key: "border-image-slice",
      onchange: "changeBorderImage"
    })}
        </div>
      </div>
      <div
        class="property-item border-slice-item full has-list"
        ref="$partitialSetting"
        style="display: none;"
      >
        <div class="slice-setting-box" ref="$sliceSettingBox">
          ${typeList$1.map((it) => {
      return `
              <div>
                <label class='title'>${it.title}</label>
              </div>
              <div>
                ${createComponent("RangeEditor", {
        ref: `$${it.key}Slice`,
        label: "Slice",
        key: `border-image-slice-${it.key}`,
        onchange: "changeBorderImage"
      })}
              </div>  
              <div>
                ${createComponent("RangeEditor", {
        ref: `$${it.key}Width`,
        label: "Width",
        key: `border-image-width-${it.key}`,
        onchange: "changeBorderImage"
      })}              
              </div>                
            `;
    }).join("")}
        </div>
      </div>
    `;
  }
  [CHANGE("$sliceSettingBox select")]() {
    this.setBorderImageProperty();
  }
  [CLICK("$borderImageView .preview")]() {
    this.viewFillPopup(this.refs.$preview, "");
  }
  [CLICK("$borderImageView .colorsteps .step")](e) {
    this.refs.$colorsteps.$(`[data-selected="true"]`).removeAttr("data-selected");
    var selectColorStepId = e.$dt.attr("data-colorstep-id");
    e.$dt.attr("data-selected", true);
    var $preview = e.$dt.closest("border-image-item").$(".preview");
    this.viewFillPopup($preview, selectColorStepId);
  }
  getFillData(borderImage2) {
    let data = {
      type: borderImage2.type
    };
    switch (data.type) {
      case "image":
        data.url = borderImage2.image ? borderImage2.image.url : "";
        break;
      default:
        if (borderImage2.image) {
          const image2 = borderImage2.image;
          data.type = image2.type;
          data.colorsteps = [...image2.colorsteps];
          data.angle = image2.angle;
          data.radialType = image2.radialType || "ellipse";
          data.radialPosition = image2.radialPosition || Position.CENTER;
        } else {
          data.colorsteps = [];
          data.angle = 0;
          data.radialType = "ellipse";
          data.radialPosition = Position.CENTER;
        }
        break;
    }
    return data;
  }
  viewFillPopup($preview, selectColorStepId) {
    var current = this.$context.selection.current;
    if (!current)
      return;
    this.emit("showFillPopup", __spreadProps(__spreadValues({
      changeEvent: "changeBorderImageFillPopup"
    }, this.getFillData(current.borderImage)), {
      selectColorStepId,
      refresh: true
    }));
  }
  viewChangeImage() {
    var current = this.$context.selection.current;
    if (!current)
      return;
    var borderImage2 = current.borderImage;
    if (!borderImage2)
      return;
    var $el = this.getRef("$miniView");
    if ($el && borderImage2.image) {
      $el.css({
        "background-image": borderImage2.image.toString(),
        "background-size": "cover"
      });
    }
    var $el = this.getRef("$fillTitle");
    if ($el) {
      $el.html(names["image"]);
    }
    var $el = this.getRef("$colorsteps", this.selectedIndex);
    if ($el) {
      $el.empty();
    }
  }
  setImage(data) {
    var current = this.$context.selection.current;
    if (!current)
      return;
    current.borderImage.setImageUrl(data);
    this.viewChangeImage(data);
    this.$commands.executeCommand("setAttribute", this.$context.selection.pack("borderImage"));
  }
  viewChangeGradient(data) {
    var current = this.$context.selection.current;
    if (!current)
      return;
    var borderImage2 = current.borderImage;
    if (!borderImage2)
      return;
    var $el = this.getRef("$miniView");
    if ($el) {
      $el.css({
        "background-image": borderImage2.image.toString(),
        "background-size": "cover"
      });
    }
    var $el = this.getRef("$fillTitle");
    if ($el) {
      $el.html(names[data.type]);
    }
    var $el = this.getRef("$colorsteps", this.selectedIndex);
    if ($el) {
      $el.html(this.getColorStepString(data.colorsteps));
    }
  }
  setGradient(data) {
    var current = this.$context.selection.current;
    if (!current)
      return;
    current.borderImage.setGradient(data);
    this.viewChangeGradient(data);
    this.$commands.executeCommand("setAttribute", this.$context.selection.pack("borderImage"));
  }
  [SUBSCRIBE("changeBorderImageFillPopup")](data) {
    switch (data.type) {
      case "image":
        this.setImage(data);
        break;
      default:
        this.setGradient(data);
        break;
    }
  }
  setBorderImageProperty() {
    var current = this.$context.selection.current;
    if (!current)
      return;
    var borderImage2 = current.borderImage;
    var type = this.refs.$selector.attr("data-selected-value");
    if (type === "all") {
      var len2 = this.children.$allSlice.getValue();
      borderImage2.reset({
        slice: {
          top: len2.clone(),
          right: len2.clone(),
          bottom: len2.clone(),
          left: len2.clone()
        }
      });
    } else {
      keyList$1.forEach((type2) => {
        borderImage2.slice[type2] = this.children[`$${type2}Slice`].getValue();
        borderImage2.width[type2] = this.children[`$${type2}Width`].getValue();
      });
    }
    this.$commands.executeCommand("setAttribute", this.$context.selection.pack("borderImage"));
  }
  [CLICK("$selector button")](e) {
    var type = e.$dt.attr("data-value");
    this.refs.$selector.attr("data-selected-value", type);
    if (type === "all") {
      this.refs.$partitialSetting.hide();
    } else {
      this.refs.$partitialSetting.show("grid");
    }
    this.setBorderImageProperty();
  }
}
function borderImage(editor) {
  editor.registerElement({
    BorderImageProperty
  });
}
var BorderRadiusEditor$1 = "";
class BorderRadius {
  static parseStyle(str = "") {
    var obj2 = {
      isAll: true,
      "border-radius": 0,
      "border-top-left-radius": 0,
      "border-top-right-radius": 0,
      "border-bottom-right-radius": 0,
      "border-bottom-left-radius": 0
    };
    var arr = str.split(" ").map((it) => Length.parse(it));
    if (arr.length === 1) {
      obj2.isAll = true;
      obj2["border-radius"] = arr[0];
    } else {
      obj2.isAll = false;
      obj2["border-top-left-radius"] = arr[0];
      obj2["border-top-right-radius"] = arr[1];
      obj2["border-bottom-right-radius"] = arr[2];
      obj2["border-bottom-left-radius"] = arr[3];
      if (arr[0].equals(arr[1]) && arr[0].equals(arr[2]) && arr[0].equals(arr[3])) {
        obj2.isAll = true;
        obj2["border-radius"] = arr[0];
      }
    }
    return obj2;
  }
}
const typeList = [
  { key: "border-top-left-radius", title: "topLeft", label: "TL" },
  { key: "border-top-right-radius", title: "topRight", label: "TR" },
  { key: "border-bottom-left-radius", title: "bottomLeft", label: "BL" },
  { key: "border-bottom-right-radius", title: "bottomRight", label: "BR" }
];
const keyList = typeList.map((it) => it.key);
const BorderGroup = {
  ALL: "all",
  PARTITIAL: "partial"
};
class BorderRadiusEditor extends EditorElement {
  initState() {
    return __spreadValues({}, BorderRadius.parseStyle(this.props.value));
  }
  template() {
    return `<div class='elf--border-radius-editor' ref='$body'></div>`;
  }
  [SUBSCRIBE_SELF("changeBorderRadius")](key, value) {
    if (key === "border-radius") {
      keyList.forEach((type) => {
        this.children[`$${type}`].setValue(value.clone());
      });
    }
    this.setBorderRadius();
  }
  [LOAD("$body") + DOMDIFF]() {
    var borderRadius2 = this.state["border-radius"];
    return `
      <div class="border-radius-item">
        <div class="radius-value">
          ${createComponent("InputRangeEditor", {
      label: iconUse("outline_rect"),
      ref: "$all",
      compact: "true",
      key: "border-radius",
      value: borderRadius2,
      min: 0,
      onchange: "changeBorderRadius"
    })}
        </div>
        <div></div>

          ${createComponent("ToggleButton", {
      compact: true,
      ref: "$toggle",
      key: "border-all",
      checkedValue: BorderGroup.PARTITIAL,
      value: BorderGroup.ALL,
      toggleLabels: [iconUse("border_inner"), iconUse("border_inner")],
      toggleValues: [BorderGroup.ALL, BorderGroup.PARTITIAL],
      onchange: "changeKeyValue"
    })}
      </div>
      <div
        class="full border-radius-item"
        ref="$partitialSetting"
        style="display: none;"
      >
        <div class="radius-setting-box" ref="$radiusSettingBox">
          <div>
            ${typeList.map((it) => {
      var value = this.state[it.key];
      var title2 = this.$i18n("border.radius.editor." + it.title);
      var label = it.label;
      return `
                <div>
                  ${createComponent("InputRangeEditor", {
        compact: true,
        ref: `$${it.key}`,
        label,
        title: title2,
        key: it.key,
        value,
        min: 0,
        step: 1,
        onchange: "changeBorderRadius"
      })}
                </div>  
              `;
    }).join("")}
          </div>
        </div>
      </div>
    `;
  }
  [INPUT("$radiusSettingBox input")]() {
    this.setBorderRadius();
  }
  [CHANGE("$radiusSettingBox select")]() {
    this.setBorderRadius();
  }
  setBorderRadius() {
    var type = this.selectedValue;
    if (type === BorderGroup.ALL) {
      this.state["border-radius"] = this.children[`$all`].getValue();
    } else {
      keyList.forEach((key) => {
        this.state[key] = this.children[`$${key}`].getValue();
      });
    }
    this.modifyBorderRadius();
  }
  modifyBorderRadius() {
    var value = "";
    if (this.selectedValue === BorderGroup.ALL) {
      value = this.state["border-radius"] + "";
    } else {
      value = keyList.map((key) => `${this.state[key]}`).join(" ");
    }
    this.parent.trigger(this.props.onchange, value);
  }
  [SUBSCRIBE_SELF("changeKeyValue")](key, value) {
    const type = value;
    if (type === BorderGroup.PARTITIAL) {
      this.selectedValue = BorderGroup.PARTITIAL;
      this.refs.$partitialSetting.show();
    } else {
      this.selectedValue = BorderGroup.ALL;
      this.refs.$partitialSetting.hide();
    }
    this.setBorderRadius();
  }
}
class BorderRadiusProperty extends BaseProperty {
  getTitle() {
    return this.$i18n("border.radius.property.title");
  }
  getBody() {
    return `<div class="property-item full border-radius-item" ref='$body'></div>`;
  }
  [LOAD("$body")]() {
    var current = this.$context.selection.current || {};
    var value = current.borderRadius || "0px";
    return createComponent("BorderRadiusEditor", {
      ref: "$1",
      value,
      onchange: "changeBorderRadius"
    });
  }
  get editableProperty() {
    return "borderRadius";
  }
  [SUBSCRIBE(REFRESH_SELECTION) + DEBOUNCE(100) + IF("checkShow")]() {
    if (this.$context.selection.hasChangedField("borderRadius")) {
      this.refresh();
    }
  }
  [SUBSCRIBE_SELF("changeBorderRadius")](value) {
    this.$commands.executeCommand("setAttribute", "change border radius", this.$context.selection.packByValue({
      borderRadius: value
    }));
  }
}
function borderRadius(editor) {
  editor.registerElement({
    BorderRadiusEditor
  });
  editor.registerUI("inspector.tab.style", {
    BorderRadiusProperty
  });
}
var BoxModelProperty$1 = "";
const fields = ["margin", "padding"];
let styleKeys = [];
fields.forEach((field) => {
  styleKeys.push.apply(styleKeys, ["-top", "-bottom", "-left", "-right"].map((it) => field + it));
});
class BoxModelProperty extends BaseProperty {
  getTitle() {
    return this.$i18n("box.model.property.title");
  }
  get editableProperty() {
    return "boxModel";
  }
  [SUBSCRIBE(REFRESH_SELECTION) + DEBOUNCE(100) + IF("checkShow")]() {
    this.refresh();
  }
  checkCurrentItem(item) {
    return this.$context.selection.current === item;
  }
  [SUBSCRIBE(UPDATE_CANVAS) + IF("checkCurrentItem") + DEBOUNCE(100)]() {
    const current = this.$context.selection.current;
    if (current == null ? void 0 : current.hasChangedField("padding-left", "padding-right", "padding-top", "padding-bottom")) {
      this.refresh();
    }
  }
  getBody() {
    return `<div class="property-item elf--box-model-item" ref="$boxModelItem"></div>`;
  }
  templateInput(key, current) {
    var value = Length.parse(current[key] || 0);
    return `<input type="number" ref="$${key}" value="${value.value}" tabIndex="1" />`;
  }
  [LOAD("$boxModelItem") + DOMDIFF]() {
    var current = this.$context.selection.current;
    if (!current)
      return "";
    return `
      <div>
        <div class="margin" data-title="${this.$i18n("box.model.property.margin")}">
          <div data-value="top">
            ${this.templateInput("margin-top", current)}
          </div>
          <div data-value="bottom">
            ${this.templateInput("margin-bottom", current)}
          </div>
          <div data-value="left">
            ${this.templateInput("margin-left", current)}
          </div>
          <div data-value="right">
            ${this.templateInput("margin-right", current)}
          </div>
        </div>
        <div class="padding" data-title="${this.$i18n("box.model.property.padding")}">
          <div data-value="top">
            ${this.templateInput("padding-top", current)}
          </div>
          <div data-value="bottom">
            ${this.templateInput("padding-bottom", current)}
          </div>
          <div data-value="left">
            ${this.templateInput("padding-left", current)}
          </div>
          <div data-value="right">
            ${this.templateInput("padding-right", current)}
          </div>
        </div>
        <div class='content' title='Content'>
        
        </div>
      </div>
    `;
  }
  [INPUT("$boxModelItem input")]() {
    this.resetBoxModel();
  }
  resetBoxModel() {
    var data = {};
    styleKeys.forEach((key) => {
      data[key] = this.refs["$" + key].value;
    });
    this.$commands.executeCommand("setAttribute", "change padding or margin", this.$context.selection.packByValue(data));
  }
}
function boxModel(editor) {
  editor.registerUI("inspector.tab.style", {
    BoxModelProperty
  });
}
var boxShadow$1 = [
  { name: "Box", shadow: `0px 3px 3px 0px rgba(0,0,0,0.2)` },
  {
    name: "Shadow-4",
    shadow: `
        0px 1px 1px 0px rgba(0,0,0,0.15), 
        0px 2px 2px 0px rgba(0,0,0,0.15), 
        0px 4px 4px 0px rgba(0,0,0,0.15), 
        0px 8px 8px 0px rgba(0,0,0,0.15)
    `
  },
  {
    name: "Shadow-5",
    shadow: `
        0px  1px 1px 0px rgba(0,0,0,0.12), 
        0px  2px 2px 0px rgba(0,0,0,0.12), 
        0px  4px 4px 0px rgba(0,0,0,0.12), 
        0px  8px 8px 0px rgba(0,0,0,0.12),
        0px  16px 16px 0px rgba(0,0,0,0.12)
    `
  },
  {
    name: "Shadow-6",
    shadow: `
        0px 1px 1px 0px rgba(0,0,0,0.11), 
        0px 2px 2px 0px rgba(0,0,0,0.11), 
        0px 4px 4px 0px rgba(0,0,0,0.11), 
        0px 8px 8px 0px rgba(0,0,0,0.11), 
        0px 16px 16px 0px rgba(0,0,0,0.11), 
        0px 32px 32px 0px rgba(0,0,0,0.11)
    `
  },
  {
    name: "Sharp",
    shadow: `
        0px 1px 1px 0px rgba(0,0,0,0.25), 
        0px 2px 2px 0px rgba(0,0,0,0.20), 
        0px 4px 4px 0px rgba(0,0,0,0.15), 
        0px 8px 8px 0px rgba(0,0,0,0.10),
        0px 16px 16px 0px rgba(0,0,0,0.05)
    `
  },
  {
    name: "Diffuse",
    shadow: `
        0px 1px 1px 0px rgba(0,0,0,0.08), 
        0px 2px 2px 0px rgba(0,0,0,0.12), 
        0px 4px 4px 0px rgba(0,0,0,0.16), 
        0px 8px 8px 0px rgba(0,0,0,0.20)
    `
  }
];
var BoxShadowProperty$1 = "";
class BoxShadowProperty extends BaseProperty {
  getTitle() {
    return this.$i18n("boxshadow.property.title");
  }
  getBody() {
    return `
      <div class="full box-shadow-item" ref="$shadowList"></div>
    `;
  }
  getTools() {
    return `
      <select class='box-shadow-samples' ref="$select">
      ${boxShadow$1.map((item, index2) => {
      return `
          <option value="${index2}">${item.name}</option>
        `;
    }).join("")}
      </select>
      <button type="button" ref='$add'>${obj$3.add}</button>
    `;
  }
  [CLICK("$add")]() {
    const index2 = +this.refs.$select.value;
    this.children.$boxshadow.trigger("add", boxShadow$1[index2].shadow);
  }
  [LOAD("$shadowList")]() {
    var current = this.$context.selection.current || {};
    return createComponent("BoxShadowEditor", {
      ref: "$boxshadow",
      key: "boxShadow",
      value: current.boxShadow,
      onchange: (key, value) => {
        this.$commands.executeCommand("setAttribute", "change box shadow", this.$context.selection.packByValue({
          [key]: value
        }));
      }
    });
  }
  get editableProperty() {
    return "boxShadow";
  }
  [SUBSCRIBE(REFRESH_SELECTION) + DEBOUNCE(100) + IF("checkShow")]() {
    this.refresh();
  }
}
function boxShadow(editor) {
  editor.registerUI("inspector.tab.style", {
    BoxShadowProperty
  });
}
var polygon = {
  key: "polygon",
  title: "Polygon",
  execute: function() {
    return [
      { name: "Triangle", polygon: "50% 0%, 0% 100%, 100% 100%" },
      { name: "Trapezoid", polygon: "20% 0%, 80% 0%, 100% 100%, 0% 100%" },
      {
        name: "Parallelogram",
        polygon: "25% 0%, 100% 0%, 75% 100%, 0% 100%"
      },
      {
        name: "Rhombus",
        polygon: "50% 0%, 100% 50%, 50% 100%, 0% 50%"
      },
      {
        name: "Pentagon",
        polygon: "50% 0%, 100% 38%, 82% 100%, 18% 100%, 0% 38%"
      },
      {
        name: "Hexagon",
        polygon: "50% 0%, 100% 25%, 100% 75%, 50% 100%, 0% 75%, 0% 25%"
      },
      {
        name: "Heptagon",
        polygon: "50% 0%, 90% 20%, 100% 60%, 75% 100%, 25% 100%, 0% 60%, 10% 20%"
      },
      {
        name: "Octagon",
        polygon: "30% 0%, 70% 0%, 100% 30%, 100% 70%, 70% 100%, 30% 100%, 0% 70%, 0% 30%"
      }
    ];
  }
};
var ClipPathProperty$1 = "";
const CLIPPATH_REG = /(content-box|padding-box|border-box|margin-box|view-box|stroke-box|fill-box|none|(inset|circle|ellipse|polygon|path|svg|url)(\(([^)]*)\))?)/gi;
class ClipPath extends PropertyItem {
  getDefaultObject(obj2 = {}) {
    return super.getDefaultObject(__spreadValues({
      itemType: "clip-path",
      type: "none",
      value: ""
    }, obj2));
  }
  toCloneObject() {
    return __spreadValues(__spreadValues({}, super.toCloneObject()), this.attrs("value"));
  }
  toString() {
    var type = this.json.type;
    var value = this.json.value;
    var box = this.json.box;
    var results = "";
    switch (type) {
      case "circle":
      case "inset":
      case "ellipse":
      case "polygon":
      case "path":
        results = `${type}(${value})`;
        break;
      case "svg":
        results = `url(#${value})`;
        break;
      default:
        results = "none";
        break;
    }
    return box ? `${box} ${results}` : results;
  }
  toCSS() {
    return {
      "clip-path": this.toString()
    };
  }
  static toCSS(obj2) {
    return new ClipPath(obj2).toCSS();
  }
  static toString(obj2) {
    return ClipPath.toCSS(obj2)["clip-path"];
  }
  static parse(obj2) {
    return new ClipPath(obj2);
  }
  static parseStyle(str) {
    var clippath = {};
    if (!str)
      return {};
    var matches2 = str.match(CLIPPATH_REG) || [];
    matches2.forEach((value) => {
      if (value.includes("-box")) {
        clippath.box = value;
      } else {
        var [clipPathName, clipPathValue] = value.split("(");
        clipPathValue = clipPathValue || "";
        if (clipPathName === "none") {
          clipPathValue = "";
        } else {
          clipPathValue = clipPathValue.split(")")[0];
        }
        clippath.type = clipPathName;
        clippath.value = clipPathValue;
      }
    });
    return clippath;
  }
  static parseStyleForCircle(str = "50% at 50% 50%") {
    var radius = new Length("", "closest-side"), position2 = "";
    str = str || "50% at 50% 50%";
    if (str.includes("at")) {
      [radius, position2] = str.split("at").map((it) => it.trim());
    } else {
      position2 = str.trim();
    }
    var [x, y] = position2.split(" ");
    if (isUndefined(y)) {
      y = x;
    }
    radius = Length.parse(radius);
    x = Length.parse(x);
    y = Length.parse(y);
    return {
      radius,
      x,
      y
    };
  }
  static parseStyleForEllipse(str = "50% 50%") {
    var radius = `50% 50%`, position2 = "";
    str = str || "50%";
    if (str.includes("at")) {
      [radius, position2] = str.split("at").map((it) => it.trim());
    } else {
      position2 = str.trim();
    }
    var [x, y] = position2.split(" ");
    if (isUndefined(y)) {
      y = x;
    }
    x = Length.parse(x);
    y = Length.parse(y);
    var [radiusX, radiusY] = radius.split(" ");
    if (isUndefined(radiusY)) {
      radiusY = radiusX;
    }
    radiusX = Length.parse(radiusX);
    radiusY = Length.parse(radiusY);
    return {
      radiusX,
      radiusY,
      x,
      y
    };
  }
  static parseStyleForInset(str = "") {
    var [inset, round2] = str.split("round");
    var [_count, top2, right2, bottom2, left2] = DirectionLength.parse(inset);
    if (round2) {
      var [_roundCount, topRadius, rightRadius, bottomRadius, leftRadius] = DirectionLength.parse(round2);
    }
    return {
      isAll: _count === 1,
      top: top2,
      right: right2,
      bottom: bottom2,
      left: left2,
      round: round2,
      isAllRadius: _roundCount === 1,
      topRadius,
      rightRadius,
      bottomRadius,
      leftRadius
    };
  }
  static parseStyleForPolygon(str = "") {
    return str.split(",").filter((it) => it.trim()).map((it) => {
      var [x, y] = it.trim().split(" ");
      return {
        x: Length.parse(x),
        y: Length.parse(y)
      };
    });
  }
}
const ClipPathSample = {
  [ClipPathType.CIRCLE]: "circle(50% at 50% 50%)",
  [ClipPathType.ELLIPSE]: "ellipse(50% 50% at 50% 50%)",
  [ClipPathType.INSET]: "inset(0% 0% 0% 0%)",
  [ClipPathType.POLYGON]: "polygon(0% 0%, 100% 0%, 100% 100%, 0% 100%)",
  [ClipPathType.PATH]: "path()"
};
class ClipPathProperty extends BaseProperty {
  getTitle() {
    return this.$i18n("clippath.property.title");
  }
  getClassName() {
    return "clip-path-property";
  }
  getBody() {
    return `<div class='elf--clip-path-list' ref='$clippathList'></div>`;
  }
  getTools() {
    return `
      <div ref="$tools" class="add-tools">
        <button type="button" data-value='circle' data-tooltip="Circle">${iconUse("outline_circle")}</button>
        <button type="button" data-value='ellipse' data-tooltip="Ellipse">${iconUse("outline_circle", "scale(1 0.7) translate(0 5)")}</button>
        <button type="button" data-value='inset' data-tooltip="Inset">${iconUse("outline_rect")}</button>
        <button type="button" data-value='polygon' data-tooltip="Polygon">${iconUse("polygon")}</button>
        <button type="button" data-value='path' data-tooltip="Path">${iconUse("pentool")}</button>
        <button type="button" data-value='svg' data-tooltip="SVG">${iconUse("image")}</button>
      </div>
    `;
  }
  makeClipPathTemplate(clippath, func) {
    const isPath = clippath === "path";
    const isPolygon = clippath === "polygon";
    let newPathString = "";
    if (isPath) {
      const pathString2 = func.split("(")[1].split(")")[0];
      let pathObject = PathParser.fromSVGString(pathString2);
      const bbox = pathObject.getBBox();
      const rectangle = vertiesToRectangle(bbox);
      const rate = 260 / rectangle.width;
      const hRate = 150 / rectangle.height;
      const lastRate = Math.min(rate, hRate);
      pathObject = pathObject.translate(-bbox[0][0], -bbox[0][1]).scale(lastRate, lastRate);
      const newBBox = pathObject.getBBox();
      const newRectangle = vertiesToRectangle(newBBox);
      newPathString = pathObject.translate(260 / 2 - newRectangle.width / 2, 0).d;
    }
    let polygonSelect = "";
    if (isPolygon) {
      const polygonList = polygon.execute();
      polygonSelect = createComponent("SelectEditor", {
        ref: "$polygonSelect",
        options: ["", ...polygonList.map((it) => it.name)],
        onchange: (key, value) => {
          const polygon2 = polygonList.find((it) => it.name === value);
          if (polygon2) {
            this.updatePathInfo({
              "clip-path": `polygon(${polygon2.polygon})`
            });
          }
        }
      });
    }
    return `
      <div>
        <div class='clippath-item'>
          <label>${iconUse("drag_indicator")}</label>
          <div class='title'>
            <div class='name'>${clippath}</div>
            ${isPolygon ? polygonSelect : ""}
          </div>
          <div class='tools'>
            <button type="button" class="del">${obj$3.remove2}</button>
          </div>        
        </div>
        ${isPath ? `<svg><path d="${newPathString}" fill="transparent" stroke="currentColor" /></svg>` : ""}
      </div>

    `;
  }
  [CLICK("$clippathList .clippath-item .title .name")]() {
    var current = this.$context.selection.current;
    if (!current)
      return;
    this.viewClipPathPicker();
  }
  [CLICK("$clippathList .del") + PREVENT]() {
    var current = this.$context.selection.current;
    if (!current)
      return;
    this.$commands.executeCommand("setAttribute", "delete clip-path", this.$context.selection.packByValue({
      clipPath: ""
    }));
    this.emit("hideClipPathPopup");
    window.setTimeout(() => {
      this.refresh();
    }, 100);
  }
  get editableProperty() {
    return "clipPath";
  }
  [SUBSCRIBE(REFRESH_SELECTION) + IF("checkShow")]() {
    this.refresh();
  }
  [LOAD("$clippathList")]() {
    var current = this.$context.selection.current;
    if (!current)
      return "";
    if (!current.clipPath)
      return "";
    return this.makeClipPathTemplate(current.clipPath.split("(")[0], current.clipPath);
  }
  [CLICK("$tools [data-value]")](e) {
    var current = this.$context.selection.current;
    if (!current)
      return;
    if (current.clipPath) {
      window.alert("clip-path is already exists.");
      return;
    }
    if (current) {
      current.reset({
        clipPath: ClipPathSample[e.$dt.data("value")]
      });
      this.$commands.executeCommand("setAttribute", "change clipPath", this.$context.selection.pack("clipPath"));
    }
    this.refresh();
  }
  viewClipPathPicker() {
    var current = this.$context.selection.current;
    if (!current)
      return;
    var obj2 = ClipPath.parseStyle(current.clipPath);
    switch (obj2.type) {
      case "path":
        var d = current.absolutePath(current.clipPathString).d;
        var mode = d ? "modify" : "path";
        this.emit("showPathEditor", mode, {
          changeEvent: (data) => {
            data.d = current.invertPath(data.d).d;
            this.updatePathInfo({
              clipPath: `path(${data.d})`
            });
          },
          current,
          d
        });
        break;
    }
  }
  updatePathInfo(data) {
    if (!data)
      return;
    var current = this.$context.selection.current;
    if (!current)
      return;
    current.reset(data);
    this.refresh();
    this.$commands.executeCommand("setAttribute", "change clipPath", this.$context.selection.packByValue(data));
  }
}
function clipPath(editor) {
  editor.registerUI("inspector.tab.style", {
    ClipPathProperty
  });
}
var ClippathEditorView$2 = "";
class ClippathPolygonEditorView extends EditorElement {
  initializePolygon() {
    const current = this.$context.selection.current;
    this.state.current = current;
    this.state.width = current.screenWidth;
    this.state.height = current.screenHeight;
    this.state.clippath = ClipPath.parseStyle(current["clip-path"]);
    this.state.clippath.value = ClipPath.parseStyleForPolygon(this.state.clippath.value);
    this.screenPoints = this.$viewport.applyVerties(vertiesMap(this.state.clippath.value.map((point2) => {
      const { x, y } = point2;
      const newX = x.toPx(this.state.width);
      const newY = y.toPx(this.state.height);
      return fromValues(newX, newY, 0);
    }), current.absoluteMatrix));
    this.clonedScreenPoints = clone$1(this.screenPoints);
  }
  [POINTERSTART("$el .polygon .polygon-pointer") + MOVE("movePolygonPointer") + END("moveEndPolygonPointer")](e) {
    this.initializePolygon();
    this.polygonTargetIndex = +e.$dt.data("index");
  }
  movePolygonPointer(dx, dy) {
    this.clonedScreenPoints[this.polygonTargetIndex] = add$1([], this.screenPoints[this.polygonTargetIndex], [dx, dy, 0]);
    this.updatePolygon(this.clonedScreenPoints);
  }
  moveEndPolygonPointer() {
    const value = ClipPath.toCSS(this.state.clippath);
    this.$commands.executeCommand("setAttribute", "change clippath", this.$context.selection.packByValue(value));
  }
  [POINTERSTART("$el .polygon .polygon-line")](e) {
    this.initializePolygon();
    const index2 = +e.$dt.data("index");
    this.polygonTargetIndex = index2;
    const current = this.screenPoints[this.polygonTargetIndex];
    const next = this.screenPoints[(this.polygonTargetIndex + 1) % this.screenPoints.length];
    const newPoint = lerp$1([], current, next, 0.5);
    this.screenPoints.splice(this.polygonTargetIndex + 1, 0, newPoint);
    this.updatePolygon(this.screenPoints);
  }
  updatePolygon(screenPoints) {
    const newWorldPoints = this.$viewport.applyVertiesInverse(screenPoints);
    const inverseMatrix = this.$context.selection.current.absoluteMatrixInverse;
    const newLocalPoints = vertiesMap(newWorldPoints, inverseMatrix);
    this.state.clippath.value = newLocalPoints.map((p) => {
      return [
        Length.makePercent(p[0], this.state.width),
        Length.makePercent(p[1], this.state.height)
      ].join(" ");
    }).join(",");
    const value = ClipPath.toCSS(this.state.clippath);
    this.$commands.emit("setAttribute", this.$context.selection.packByValue(value));
  }
  [POINTERSTART("$el .polygon .polygon-center") + MOVE("movePolygonCenter") + END("moveEndPolygonCenter")]() {
    this.initializePolygon();
  }
  movePolygonCenter(dx, dy) {
    const newScreenPoints = this.screenPoints.map((p) => {
      return add$1([], p, [dx, dy, 0]);
    });
    this.updatePolygon(newScreenPoints);
  }
  moveEndPolygonCenter(dx, dy) {
    if (dx == 0 && dy == 0) {
      switch (this.state.clippath.type) {
        case ClipPathType.POLYGON:
          const value2 = ClipPath.toCSS({
            type: ClipPathType.CIRCLE,
            value: `50% at 50% 50%`
          });
          this.$commands.executeCommand("setAttribute", "change clippath", this.$context.selection.packByValue(value2));
          break;
      }
      return;
    }
    const value = ClipPath.toCSS(this.state.clippath);
    this.$commands.executeCommand("setAttribute", "change clippath", this.$context.selection.packByValue(value));
  }
  templatePolygon(clippath) {
    const current = this.$context.selection.current;
    const points = ClipPath.parseStyleForPolygon(clippath.value).map((point2) => [
      point2.x.toPx(current.screenWidth).value,
      point2.y.toPx(current.screenHeight).value,
      0
    ]);
    const centerPoint = toRectVerties(points)[4];
    const screenPoints = this.$viewport.applyVerties(vertiesMap(points, current.absoluteMatrix));
    const screenCenter = this.$viewport.applyVerties(vertiesMap([centerPoint], current.absoluteMatrix))[0];
    return /* @__PURE__ */ createElementJsx("div", {
      class: "polygon"
    }, /* @__PURE__ */ createElementJsx("div", {
      class: "polygon-back"
    }, /* @__PURE__ */ createElementJsx("svg", {
      style: "position:absolute;width:100%;height:100%;"
    }, /* @__PURE__ */ createElementJsx("polygon", {
      points: `${screenPoints.map((it) => [it[0], it[1]].join(",")).join(" ")}`
    }), screenPoints.map((it, index2) => {
      const nextIndex = (index2 + 1) % screenPoints.length;
      const nextPoint = screenPoints[nextIndex];
      return /* @__PURE__ */ createElementJsx("line", {
        x1: it[0],
        y1: it[1],
        x2: nextPoint[0],
        y2: nextPoint[1],
        class: "polygon-line",
        "data-index": index2
      });
    }), screenPoints.map((it, index2) => {
      return /* @__PURE__ */ createElementJsx("circle", {
        cx: it[0],
        cy: it[1],
        r: 3,
        class: "polygon-pointer",
        "data-index": index2
      });
    }))), /* @__PURE__ */ createElementJsx("div", {
      class: "polygon-center",
      style: {
        left: Length.px(screenCenter[0]),
        top: Length.px(screenCenter[1])
      }
    }));
  }
}
class ClippathInsetEditorView extends ClippathPolygonEditorView {
  initializeInset() {
    const current = this.$context.selection.current;
    this.state.current;
    this.state.width = current.screenWidth;
    this.state.height = current.screenHeight;
    this.state.clippath = ClipPath.parseStyle(current["clip-path"]);
    this.state.clippath.value = ClipPath.parseStyleForInset(this.state.clippath.value);
    this.state.inset = this.state.clippath.value;
    const inset = this.state.inset;
    const top2 = inset.top.toPx(current.screenHeight);
    const left2 = inset.left.toPx(current.screenWidth);
    const right2 = Length.px(current.screenWidth - inset.right.toPx(current.screenWidth));
    const bottom2 = Length.px(current.screenHeight - inset.bottom.toPx(current.screenHeight));
    const verties = this.$viewport.applyVerties(vertiesMap([
      [left2, top2, 0],
      [right2, top2, 0],
      [right2, bottom2, 0],
      [left2, bottom2, 0]
    ], current.absoluteMatrix));
    const leftPoint = lerp$1([], verties[0], verties[3], 0.5);
    const topPoint = lerp$1([], verties[0], verties[1], 0.5);
    const rightPoint = lerp$1([], verties[1], verties[2], 0.5);
    const bottomPoint = lerp$1([], verties[2], verties[3], 0.5);
    const centerPoint = lerp$1([], verties[0], verties[2], 0.5);
    this.screenPoints = [
      leftPoint,
      topPoint,
      rightPoint,
      bottomPoint,
      centerPoint
    ];
  }
  [POINTERSTART("$el .inset .inset-direction") + LEFT_BUTTON + MOVE("moveInsetRadius") + END("moveEndInsetRadius")](e) {
    this.initializeInset();
    this.insetTarget = e.$dt.data("direction");
  }
  moveInsetRadius(dx, dy) {
    const { left: left2, top: top2, right: right2, bottom: bottom2 } = this.state.inset;
    let [leftPoint, topPoint, rightPoint, bottomPoint] = this.screenPoints;
    if (this.insetTarget == "left")
      leftPoint = add$1([], leftPoint, [dx, dy, 0]);
    else if (this.insetTarget == "top")
      topPoint = add$1([], topPoint, [dx, dy, 0]);
    else if (this.insetTarget == "right")
      rightPoint = add$1([], rightPoint, [dx, dy, 0]);
    else if (this.insetTarget == "bottom")
      bottomPoint = add$1([], bottomPoint, [dx, dy, 0]);
    const newLeftPoint = this.$viewport.applyVertexInverse(leftPoint);
    const newTopPoint = this.$viewport.applyVertexInverse(topPoint);
    const newRightPoint = this.$viewport.applyVertexInverse(rightPoint);
    const newBottomPoint = this.$viewport.applyVertexInverse(bottomPoint);
    const inverseMatrix = this.$context.selection.current.absoluteMatrixInverse;
    const [
      relativeLeftPosition,
      relativeTopPosition,
      relativeRightPosition,
      relativeBottomPosition
    ] = vertiesMap([newLeftPoint, newTopPoint, newRightPoint, newBottomPoint], inverseMatrix);
    this.state.clippath.value = [
      top2.isPercent() ? Length.makePercent(relativeTopPosition[1], this.state.height) : Length.px(relativeTopPosition[1]),
      right2.isPercent() ? Length.makePercent(this.state.width - relativeRightPosition[0], this.state.width) : Length.px(this.state.width - relativeRightPosition[0]),
      bottom2.isPercent() ? Length.makePercent(this.state.height - relativeBottomPosition[1], this.state.height) : Length.px(this.state.height - relativeBottomPosition[1]),
      left2.isPercent() ? Length.makePercent(relativeLeftPosition[0], this.state.width) : Length.px(relativeLeftPosition[0])
    ].join(" ");
    const value = ClipPath.toCSS(this.state.clippath);
    this.$commands.emit("setAttribute", this.$context.selection.packByValue(value));
  }
  moveEndInsetRadius() {
    const value = ClipPath.toCSS(this.state.clippath);
    this.$commands.executeCommand("setAttribute", "change clippath", this.$context.selection.packByValue(value));
  }
  [POINTERSTART("$el .inset .inset-center") + LEFT_BUTTON + MOVE("moveInsetCenter") + END("moveEndInsetCenter")]() {
    this.initializeInset();
  }
  moveInsetCenter(dx, dy) {
    const { left: left2, top: top2, right: right2, bottom: bottom2 } = this.state.inset;
    let [leftPoint, topPoint, rightPoint, bottomPoint] = this.screenPoints;
    leftPoint = add$1([], leftPoint, [dx, dy, 0]);
    topPoint = add$1([], topPoint, [dx, dy, 0]);
    rightPoint = add$1([], rightPoint, [dx, dy, 0]);
    bottomPoint = add$1([], bottomPoint, [dx, dy, 0]);
    const newLeftPoint = this.$viewport.applyVertexInverse(leftPoint);
    const newTopPoint = this.$viewport.applyVertexInverse(topPoint);
    const newRightPoint = this.$viewport.applyVertexInverse(rightPoint);
    const newBottomPoint = this.$viewport.applyVertexInverse(bottomPoint);
    const inverseMatrix = this.$context.selection.current.absoluteMatrixInverse;
    const [
      relativeLeftPosition,
      relativeTopPosition,
      relativeRightPosition,
      relativeBottomPosition
    ] = vertiesMap([newLeftPoint, newTopPoint, newRightPoint, newBottomPoint], inverseMatrix);
    this.state.clippath.value = [
      top2.isPercent() ? Length.makePercent(relativeTopPosition[1], this.state.height) : Length.px(relativeTopPosition[1]),
      right2.isPercent() ? Length.makePercent(this.state.width - relativeRightPosition[0], this.state.width) : Length.px(this.state.width - relativeRightPosition[0]),
      bottom2.isPercent() ? Length.makePercent(this.state.height - relativeBottomPosition[1], this.state.height) : Length.px(this.state.height - relativeBottomPosition[1]),
      left2.isPercent() ? Length.makePercent(relativeLeftPosition[0], this.state.width) : Length.px(relativeLeftPosition[0])
    ].join(" ");
    const value = ClipPath.toCSS(this.state.clippath);
    this.$commands.emit("setAttribute", this.$context.selection.packByValue(value));
  }
  moveEndInsetCenter(dx, dy) {
    if (dx == 0 && dy == 0) {
      switch (this.state.clippath.type) {
        case ClipPathType.INSET:
          const value2 = ClipPath.toCSS({
            type: ClipPathType.POLYGON,
            value: `0% 0%, 100% 0%, 100% 100%, 0% 100%`
          });
          this.$commands.executeCommand("setAttribute", "change clippath", this.$context.selection.packByValue(value2));
          break;
      }
      return;
    }
    const value = ClipPath.toCSS(this.state.clippath);
    this.$commands.executeCommand("setAttribute", "change clippath", this.$context.selection.packByValue(value));
  }
  templateInset(clippath) {
    const current = this.$context.selection.current;
    clippath.value = ClipPath.parseStyleForInset(clippath.value);
    const top2 = clippath.value.top.toPx(current.screenHeight);
    const left2 = clippath.value.left.toPx(current.screenWidth);
    const right2 = Length.px(current.screenWidth - clippath.value.right.toPx(current.screenWidth));
    const bottom2 = Length.px(current.screenHeight - clippath.value.bottom.toPx(current.screenHeight));
    const verties = this.$viewport.applyVerties(vertiesMap([
      [left2, top2, 0],
      [right2, top2, 0],
      [right2, bottom2, 0],
      [left2, bottom2, 0]
    ], current.absoluteMatrix));
    const leftPoint = lerp$1([], verties[0], verties[3], 0.5);
    const topPoint = lerp$1([], verties[0], verties[1], 0.5);
    const rightPoint = lerp$1([], verties[1], verties[2], 0.5);
    const bottomPoint = lerp$1([], verties[2], verties[3], 0.5);
    const centerPoint = lerp$1([], verties[0], verties[2], 0.5);
    return /* @__PURE__ */ createElementJsx("div", {
      class: "inset"
    }, /* @__PURE__ */ createElementJsx("div", {
      class: "inset-back"
    }, /* @__PURE__ */ createElementJsx("svg", {
      style: "position:absolute;width:100%;height:100%;"
    }, /* @__PURE__ */ createElementJsx("path", {
      d: `
            M ${verties[0][0]} ${verties[0][1]}
            L ${verties[1][0]} ${verties[1][1]}
            L ${verties[2][0]} ${verties[2][1]}
            L ${verties[3][0]} ${verties[3][1]}
            Z
          `
    }))), /* @__PURE__ */ createElementJsx("div", {
      class: "inset-direction",
      "data-direction": "left",
      style: {
        left: Length.px(leftPoint[0]),
        top: Length.px(leftPoint[1])
      }
    }), /* @__PURE__ */ createElementJsx("div", {
      class: "inset-direction",
      "data-direction": "top",
      style: { left: Length.px(topPoint[0]), top: Length.px(topPoint[1]) }
    }), /* @__PURE__ */ createElementJsx("div", {
      class: "inset-direction",
      "data-direction": "right",
      style: {
        left: Length.px(rightPoint[0]),
        top: Length.px(rightPoint[1])
      }
    }), /* @__PURE__ */ createElementJsx("div", {
      class: "inset-direction",
      "data-direction": "bottom",
      style: {
        left: Length.px(bottomPoint[0]),
        top: Length.px(bottomPoint[1])
      }
    }), /* @__PURE__ */ createElementJsx("div", {
      class: "inset-center",
      style: {
        left: Length.px(centerPoint[0]),
        top: Length.px(centerPoint[1])
      }
    }));
  }
}
class ClippathCircleEditorView extends ClippathInsetEditorView {
  [POINTERSTART("$el .circle .circle-radius") + LEFT_BUTTON + MOVE("moveCircleRadius") + END("moveEndCircleRadius")]() {
    const current = this.$context.selection.current;
    this.state.current;
    this.state.width = current.screenWidth;
    this.state.height = current.screenHeight;
    this.state.clippath = ClipPath.parseStyle(current["clip-path"]);
    this.state.circle = ClipPath.parseStyleForCircle(this.state.clippath.value);
  }
  moveCircleRadius(dx, dy) {
    const current = this.$context.selection.current;
    const { radius, x, y } = this.state.circle;
    const oldX = x.toPx(current.screenWidth);
    const oldY = y.toPx(current.screenHeight);
    const r = Math.sqrt(Math.pow(current.screenWidth, 2) + Math.pow(current.screenHeight, 2)) / Math.sqrt(2);
    const oldRadius = radius.toPx(current.screenWidth);
    const verties = this.$viewport.applyVerties(vertiesMap([[oldX.value + oldRadius.value, oldY, 0]], current.absoluteMatrix));
    const newRadius = verties[0];
    const newX = newRadius[0] + dx;
    const newY = newRadius[1] + dy;
    const localPosition = this.$viewport.applyVertexInverse([newX, newY, 0]);
    const relativePosition = vertiesMap([localPosition], this.$context.selection.current.absoluteMatrixInverse)[0];
    const distX = Math.abs(relativePosition[0] - oldX);
    const result = [
      radius.isPercent() ? Length.makePercent(distX, r) : Length.px(distX),
      x,
      y
    ];
    this.state.clippath.value = `${result[0]} at ${result[1]} ${result[2]}`;
    const value = ClipPath.toCSS(this.state.clippath);
    this.$commands.emit("setAttribute", this.$context.selection.packByValue(value));
  }
  moveEndCircleRadius() {
    const value = ClipPath.toCSS(this.state.clippath);
    this.$commands.executeCommand("setAttribute", "change clippath", this.$context.selection.packByValue(value));
  }
  [POINTERSTART("$el .circle .circle-center") + LEFT_BUTTON + MOVE("moveCircleCenter") + END("moveEndCircleCenter")]() {
    const current = this.$context.selection.current;
    this.state.current;
    this.state.width = current.screenWidth;
    this.state.height = current.screenHeight;
    this.state.clippath = ClipPath.parseStyle(current["clip-path"]);
    this.state.circle = ClipPath.parseStyleForCircle(this.state.clippath.value);
  }
  moveCircleCenter(dx, dy) {
    const current = this.$context.selection.current;
    const { radius, x, y } = this.state.circle;
    const oldX = x.toPx(current.screenWidth);
    const oldY = y.toPx(current.screenHeight);
    const verties = this.$viewport.applyVerties(vertiesMap([[oldX, oldY, 0]], current.absoluteMatrix));
    const center2 = verties[0];
    const newX = center2[0] + dx;
    const newY = center2[1] + dy;
    const localPosition = this.$viewport.applyVertexInverse([newX, newY, 0]);
    const relativePosition = vertiesMap([localPosition], this.$context.selection.current.absoluteMatrixInverse)[0];
    const result = [
      radius,
      x.isPercent() ? Length.makePercent(relativePosition[0], this.state.width) : Length.px(relativePosition[0]),
      y.isPercent() ? Length.makePercent(relativePosition[1], this.state.height) : Length.px(relativePosition[1])
    ];
    this.state.clippath.value = `${radius} at ${result[1]} ${result[2]}`;
    const value = ClipPath.toCSS(this.state.clippath);
    this.$commands.emit("setAttribute", this.$context.selection.packByValue(value));
  }
  moveEndCircleCenter(dx, dy) {
    if (dx == 0 && dy == 0) {
      switch (this.state.clippath.type) {
        case ClipPathType.CIRCLE:
          const value2 = ClipPath.toCSS({
            type: ClipPathType.ELLIPSE,
            value: `${this.state.circle.radius} ${this.state.circle.radius} at ${this.state.circle.x} ${this.state.circle.y}`
          });
          this.$commands.executeCommand("setAttribute", "change clippath", this.$context.selection.packByValue(value2));
          break;
      }
      return;
    }
    const value = ClipPath.toCSS(this.state.clippath);
    this.$commands.executeCommand("setAttribute", "change clippath", this.$context.selection.packByValue(value));
  }
  templateCircle(clippath) {
    const current = this.$context.selection.current;
    const r = Math.sqrt(Math.pow(current.screenWidth, 2) + Math.pow(current.screenHeight, 2)) / Math.sqrt(2);
    const radius = clippath.value.radius.toPx(r);
    const x = clippath.value.x.toPx(current.screenWidth);
    const y = clippath.value.y.toPx(current.screenHeight);
    const verties = this.$viewport.applyVerties(vertiesMap([
      [x, y, 0],
      [x.value + radius.value, y, 0]
    ], current.absoluteMatrix));
    const center2 = verties[0];
    const radiusPos = verties[1];
    const dist$1 = dist(center2, radiusPos);
    return /* @__PURE__ */ createElementJsx("div", {
      class: "circle"
    }, /* @__PURE__ */ createElementJsx("div", {
      class: "circle-back",
      style: {
        left: Length.px(center2[0]),
        top: Length.px(center2[1]),
        width: Length.px(dist$1 * 2),
        height: Length.px(dist$1 * 2)
      }
    }), /* @__PURE__ */ createElementJsx("div", {
      class: "circle-center",
      style: {
        left: center2[0] + "px",
        top: center2[1] + "px"
      }
    }), /* @__PURE__ */ createElementJsx("div", {
      class: "circle-radius",
      style: {
        left: radiusPos[0] + "px",
        top: radiusPos[1] + "px"
      }
    }));
  }
}
class ClippathEllipseEditorView extends ClippathCircleEditorView {
  [POINTERSTART("$el .ellipse .ellipse-radius-x") + LEFT_BUTTON + MOVE("moveEllipseRadiusX") + END("moveEndEllipseRadiusX")]() {
    const current = this.$context.selection.current;
    this.state.current;
    this.state.width = current.screenWidth;
    this.state.height = current.screenHeight;
    this.state.clippath = ClipPath.parseStyle(current["clip-path"]);
    this.state.ellipse = ClipPath.parseStyleForEllipse(this.state.clippath.value);
  }
  moveEllipseRadiusX(dx, dy) {
    const current = this.$context.selection.current;
    const { radiusX, radiusY, x, y } = this.state.ellipse;
    const oldX = x.toPx(current.screenWidth);
    const oldY = y.toPx(current.screenHeight);
    const oldRadiusX = radiusX.toPx(current.screenWidth);
    const verties = this.$viewport.applyVerties(vertiesMap([[oldX.value + oldRadiusX.value, oldY, 0]], current.absoluteMatrix));
    const newRadius = verties[0];
    const newX = newRadius[0] + dx;
    const newY = newRadius[1] + dy;
    const localPosition = this.$viewport.applyVertexInverse([newX, newY, 0]);
    const relativePosition = vertiesMap([localPosition], this.$context.selection.current.absoluteMatrixInverse)[0];
    const distX = Math.abs(relativePosition[0] - oldX);
    const result = [
      radiusX.isPercent() ? Length.makePercent(distX, this.state.width) : Length.px(distX),
      x,
      y
    ];
    this.state.clippath.value = `${result[0]} ${radiusY} at ${result[1]} ${result[2]}`;
    const value = ClipPath.toCSS(this.state.clippath);
    this.$commands.emit("setAttribute", this.$context.selection.packByValue(value));
  }
  [POINTERSTART("$el .ellipse .ellipse-radius-y") + LEFT_BUTTON + MOVE("moveEllipseRadiusY") + END("moveEndEllipseRadiusX")]() {
    const current = this.$context.selection.current;
    this.state.current;
    this.state.width = current.screenWidth;
    this.state.height = current.screenHeight;
    this.state.clippath = ClipPath.parseStyle(current["clip-path"]);
    this.state.ellipse = ClipPath.parseStyleForEllipse(this.state.clippath.value);
  }
  moveEllipseRadiusY(dx, dy) {
    const current = this.$context.selection.current;
    const { radiusX, radiusY, x, y } = this.state.ellipse;
    const oldX = x.toPx(current.screenWidth);
    const oldY = y.toPx(current.screenHeight);
    const oldRadiusY = radiusY.toPx(current.screenHeight);
    const verties = this.$viewport.applyVerties(vertiesMap([[oldX.value, oldY.value + oldRadiusY.value, 0]], current.absoluteMatrix));
    const newRadius = verties[0];
    const newX = newRadius[0] + dx;
    const newY = newRadius[1] + dy;
    const localPosition = this.$viewport.applyVertexInverse([newX, newY, 0]);
    const relativePosition = vertiesMap([localPosition], this.$context.selection.current.absoluteMatrixInverse)[0];
    const distY = Math.abs(relativePosition[1] - oldY);
    const result = [
      radiusY.isPercent() ? Length.makePercent(distY, this.state.height) : Length.px(distY),
      x,
      y
    ];
    this.state.clippath.value = `${radiusX} ${result[0]} at ${x} ${y}`;
    const value = ClipPath.toCSS(this.state.clippath);
    this.$commands.emit("setAttribute", this.$context.selection.packByValue(value));
  }
  moveEndEllipseRadiusX() {
    const value = ClipPath.toCSS(this.state.clippath);
    this.$commands.executeCommand("setAttribute", "change clippath", this.$context.selection.packByValue(value));
  }
  [POINTERSTART("$el .ellipse .ellipse-center") + LEFT_BUTTON + MOVE("moveEllipseCenter") + END("moveEndEllipseCenter")](e) {
    const current = this.$context.selection.current;
    this.state.current;
    this.state.width = current.screenWidth;
    this.state.height = current.screenHeight;
    this.state.clippath = ClipPath.parseStyle(current["clip-path"]);
    this.state.ellipse = ClipPath.parseStyleForEllipse(this.state.clippath.value);
    this.state.left = Length.parse(e.$dt.css("left")).value;
    this.state.top = Length.parse(e.$dt.css("top")).value;
  }
  moveEllipseCenter(dx, dy) {
    const { radiusX, radiusY, x, y } = this.state.ellipse;
    const newLeft = this.state.left + dx;
    const newTop = this.state.top + dy;
    const worldPosition = this.$viewport.applyVertexInverse([
      newLeft,
      newTop,
      0
    ]);
    const relativePosition = vertiesMap([worldPosition], this.$context.selection.current.absoluteMatrixInverse)[0];
    const result = [
      radiusX,
      radiusY,
      x.isPercent() ? Length.makePercent(relativePosition[0], this.state.width) : Length.px(relativePosition[0]),
      y.isPercent() ? Length.makePercent(relativePosition[1], this.state.height) : Length.px(relativePosition[1])
    ];
    this.state.clippath.value = `${radiusX} ${radiusY} at ${result[2]} ${result[3]}`;
    const value = ClipPath.toCSS(this.state.clippath);
    this.$commands.emit("setAttribute", this.$context.selection.packByValue(value));
  }
  moveEndEllipseCenter(dx, dy) {
    if (dx == 0 && dy == 0) {
      switch (this.state.clippath.type) {
        case ClipPathType.ELLIPSE:
          const value2 = ClipPath.toCSS({
            type: ClipPathType.INSET,
            value: ""
          });
          this.$commands.executeCommand("setAttribute", "change clippath", this.$context.selection.packByValue(value2));
          break;
      }
      return;
    }
    const value = ClipPath.toCSS(this.state.clippath);
    this.$commands.executeCommand("setAttribute", "change clippath", this.$context.selection.packByValue(value));
  }
  templateEllipse(clippath) {
    const current = this.$context.selection.current;
    const radiusX = clippath.value.radiusX.toPx(current.screenWidth);
    const radiusY = clippath.value.radiusY.toPx(current.screenHeight);
    const x = clippath.value.x.toPx(current.screenWidth);
    const y = clippath.value.y.toPx(current.screenHeight);
    const verties = this.$viewport.applyVerties(vertiesMap([
      [x, y, 0],
      [x.value + radiusX.value, y, 0],
      [x.value, y.value + radiusY.value, 0]
    ], current.absoluteMatrix));
    const center2 = verties[0];
    const radiusXPos = verties[1];
    const radiusYPos = verties[2];
    const distX = dist(center2, radiusXPos);
    const distY = dist(center2, radiusYPos);
    const direction2 = subtract([], radiusXPos, center2);
    const angle = calculateAngle(direction2[0], direction2[1]);
    return /* @__PURE__ */ createElementJsx("div", {
      class: "ellipse"
    }, /* @__PURE__ */ createElementJsx("div", {
      class: "ellipse-back"
    }, /* @__PURE__ */ createElementJsx("svg", {
      style: "position:absolute;width:100%;height:100%;"
    }, /* @__PURE__ */ createElementJsx("ellipse", {
      cx: center2[0],
      cy: center2[1],
      rx: distX,
      ry: distY,
      transform: `rotate(${angle} ${center2[0]} ${center2[1]})`
    }))), /* @__PURE__ */ createElementJsx("div", {
      class: "ellipse-center",
      style: {
        left: center2[0] + "px",
        top: center2[1] + "px"
      }
    }), /* @__PURE__ */ createElementJsx("div", {
      class: "ellipse-radius ellipse-radius-x",
      style: {
        left: radiusXPos[0] + "px",
        top: radiusXPos[1] + "px"
      }
    }), /* @__PURE__ */ createElementJsx("div", {
      class: "ellipse-radius ellipse-radius-y",
      style: {
        left: radiusYPos[0] + "px",
        top: radiusYPos[1] + "px"
      }
    }));
  }
}
class ClippathEditorView$1 extends ClippathEllipseEditorView {
  template() {
    return /* @__PURE__ */ createElementJsx("div", {
      class: "elf--clippath-editor-view "
    });
  }
  [LOAD("$el") + DOMDIFF]() {
    const current = this.$context.selection.current;
    if (!current) {
      return "";
    }
    const clippath = ClipPath.parseStyle(current["clip-path"]);
    switch (clippath.type) {
      case ClipPathType.CIRCLE:
        clippath.value = ClipPath.parseStyleForCircle(clippath.value);
        return this.templateCircle(clippath);
      case ClipPathType.ELLIPSE:
        clippath.value = ClipPath.parseStyleForEllipse(clippath.value);
        return this.templateEllipse(clippath);
      case ClipPathType.POLYGON:
        return this.templatePolygon(clippath);
      case ClipPathType.INSET:
        return this.templateInset(clippath);
    }
    return /* @__PURE__ */ createElementJsx("div", null);
  }
  [SUBSCRIBE(REFRESH_SELECTION) + DEBOUNCE(100)]() {
    this.refresh();
  }
  [SUBSCRIBE(UPDATE_VIEWPORT)]() {
    this.refresh();
  }
  checkClipPath() {
    if (this.$el.isShow() === false)
      return false;
    const current = this.$context.selection.current;
    if (!current)
      return false;
    return this.$context.selection.current.hasChangedField("clip-path", "angle", "x", "y", "width", "height");
  }
  [SUBSCRIBE(UPDATE_CANVAS) + IF("checkClipPath") + DEBOUNCE(10)]() {
    this.refresh();
  }
  [CLICK("$el")](e) {
    if (Dom.create(e.target).isTag("svg") || Dom.create(e.target).hasClass("elf--clippath-editor-view")) {
      this.trigger("hideClippathEditorView");
    }
  }
  [SUBSCRIBE("hideClippathEditorView")]() {
    this.$el.hide();
  }
  [SUBSCRIBE("showClippathEditorView")]() {
    this.$el.show();
    this.refresh();
  }
}
function ClippathEditorView(editor) {
  editor.registerUI("canvas.view", {
    ClippathEditorView: ClippathEditorView$1
  });
}
var CodeViewProperty$1 = "";
class CodeViewProperty extends BaseProperty {
  getTitle() {
    return this.$i18n("code.view.property.title");
  }
  checkConfig() {
    return this.$config.is("inspector.selectedValue", "code");
  }
  [CONFIG("inspector.selectedValue")]() {
    this.refresh();
  }
  [SUBSCRIBE(UPDATE_CANVAS, REFRESH_SELECTION) + IF("checkConfig") + DEBOUNCE(100)]() {
    this.refresh();
  }
  getBody() {
    return `
      <div class="property-item elf--code-view-item" ref='$body'>
        <div class="elf--code-view-item-code" ref='$code'></div>
        <div class="elf--code-view-item-svg" ref='$svg'></div>
      </div>
    `;
  }
  [LOAD("$code") + DOMDIFF]() {
    return [this.$editor.html.codeview(this.$context.selection.current)];
  }
  [LOAD("$svg") + DOMDIFF]() {
    return [this.$editor.svg.codeview(this.$context.selection.current)];
  }
}
function codeview(editor) {
  editor.registerUI("inspector.tab.code", {
    CodeViewProperty
  });
}
var Console = {
  command: "Console",
  description: "do console.log()",
  execute: (editor, ...args2) => {
    console.log(...args2);
  }
};
var __glob_0_0$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": Console
}, Symbol.toStringTag, { value: "Module" }));
function _currentProject(editor, callback) {
  var project2 = editor.context.selection.currentProject;
  if (project2) {
    var timeline = project2.getSelectedTimeline();
    callback && callback(project2, timeline);
  }
}
var __glob_0_1$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": _currentProject
}, Symbol.toStringTag, { value: "Module" }));
function _doForceRefreshSelection(editor) {
  editor.emit("refreshAll");
}
var __glob_0_2$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": _doForceRefreshSelection
}, Symbol.toStringTag, { value: "Module" }));
var addArtBoard = {
  command: "addArtBoard",
  execute: (editor, obj2 = {}, center2 = null) => {
    var project2 = editor.context.selection.currentProject;
    if (!project2) {
      project2 = editor.add(editor.createModel({ itemType: "project" }));
      editor.context.selection.selectProject(project2);
    }
    var artboard2 = project2.appendChild(editor.createModel(__spreadValues({
      itemType: "artboard",
      x: 300,
      y: 200,
      width: 375,
      height: 667
    }, obj2)));
    if (center2) {
      artboard2.reset({
        x: 0,
        y: 0
      });
      artboard2.moveByCenter(center2);
    }
    editor.context.selection.select(artboard2);
    _doForceRefreshSelection(editor);
  }
};
var __glob_0_3$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": addArtBoard
}, Symbol.toStringTag, { value: "Module" }));
var addBackgroundColor = {
  command: "addBackgroundColor",
  execute: function(editor, color2, id = null) {
    editor.context.commands.executeCommand("setAttribute", "add background color", editor.context.selection.packByValue({
      backgroundColor: color2
    }, id));
  }
};
var __glob_0_4$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": addBackgroundColor
}, Symbol.toStringTag, { value: "Module" }));
var addBackgroundImageAsset = {
  command: "addBackgroundImageAsset",
  execute: function(editor, url, id = null) {
    var items = editor.context.selection.itemsByIds(id);
    let itemsMap = {};
    items.forEach((item) => {
      let images = BackgroundImage.parseStyle(STRING_TO_CSS(item.backgroundImage));
      images.unshift(new BackgroundImage({
        image: new URLImageResource({ url })
      }));
      itemsMap[item.id] = {
        "background-image": BackgroundImage.join(images)
      };
    });
    editor.context.commands.emit("history.setAttribute", "add background image", itemsMap);
  }
};
var __glob_0_5$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": addBackgroundImageAsset
}, Symbol.toStringTag, { value: "Module" }));
var addBackgroundImageGradient = {
  command: "addBackgroundImageGradient",
  execute: function(editor, gradient2, id = null) {
    var items = editor.context.selection.itemsByIds(id);
    let itemsMap = {};
    items.forEach((item) => {
      let images = BackgroundImage.parseStyle(STRING_TO_CSS(item.backgroundImage));
      images.unshift(new BackgroundImage({
        image: BackgroundImage.parseImage(gradient2)
      }));
      itemsMap[item.id] = {
        "background-image": BackgroundImage.join(images)
      };
    });
    editor.context.commands.emit("history.setAttribute", "add gradient", itemsMap);
  }
};
var __glob_0_6$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": addBackgroundImageGradient
}, Symbol.toStringTag, { value: "Module" }));
const MAX_CACHE_COUNT$1 = 1e3;
const cachedPatternMap = /* @__PURE__ */ new Map();
class PatternCache {
  static has(key) {
    return cachedPatternMap.has(key);
  }
  static get(key) {
    return cachedPatternMap.get(key);
  }
  static set(key, parsedValue) {
    if (cachedPatternMap.size > MAX_CACHE_COUNT$1) {
      cachedPatternMap.clear();
    }
    cachedPatternMap.set(key, parsedValue);
  }
}
const customFuncMap = {
  check: makeGroupFunction("check"),
  grid: makeGroupFunction("grid"),
  dot: makeGroupFunction("dot"),
  "cross-dot": makeGroupFunction("cross-dot"),
  "diagonal-line": makeGroupFunction("diagonal-line"),
  "vertical-line": makeGroupFunction("vertical-line"),
  "horizontal-line": makeGroupFunction("horizontal-line")
};
class Pattern extends PropertyItem {
  getDefaultObject(obj2 = {}) {
    return super.getDefaultObject(__spreadValues({
      itemType: "pattern"
    }, obj2));
  }
  toString() {
    return `${this.json.type}(${this.json.value || ""})`;
  }
  static parse(obj2) {
    var PatternClass = PatternClassName[obj2.type];
    if (PatternClass) {
      return new PatternClass(obj2);
    }
  }
  static parseStyle(pattern) {
    var patterns2 = [];
    if (!pattern || pattern === "undefined")
      return patterns2;
    pattern = pattern.trim();
    if (PatternCache.has(pattern)) {
      return PatternCache.get(pattern);
    }
    const result = parseValue(pattern, {
      customFuncMap
    });
    result.forEach((item, index2) => {
      const [
        size2,
        position2,
        foreColor,
        backColor,
        blendMode = [{ matchedString: "normal" }],
        lineSize = [
          { parsed: Length.parse("1px") },
          { parsed: Length.parse("1px") }
        ]
      ] = item.parameters;
      patterns2[index2] = Pattern.parse({
        type: item.type,
        x: position2[0].parsed,
        y: position2[1].parsed,
        width: size2[0].parsed,
        height: size2[1].parsed,
        foreColor: foreColor[0].matchedString,
        backColor: backColor[0].matchedString,
        blendMode: blendMode[0].matchedString,
        lineWidth: lineSize[0].parsed,
        lineHeight: lineSize[1].parsed
      });
    });
    PatternCache.set(pattern, patterns2);
    return patterns2;
  }
  static join(list2) {
    return list2.map((it) => Pattern.parse(it)).join(" ");
  }
  static toCSS(str) {
    let list2 = [];
    Pattern.parseStyle(str).forEach((it) => {
      list2.push.apply(list2, BackgroundImage.parseStyle(STRING_TO_CSS(it.toCSS())));
    });
    return BackgroundImage.joinCSS(list2);
  }
}
class BasePattern extends Pattern {
  getDefaultObject() {
    return super.getDefaultObject({
      type: "base",
      x: 0,
      y: 0,
      width: 20,
      height: 20,
      lineWidth: 1,
      lineHeight: 1,
      foreColor: "black",
      backColor: "white",
      blendMode: "normal"
    });
  }
  convert(json) {
    json = super.convert(json);
    json.width = Length.parse(json.width);
    json.height = Length.parse(json.height);
    json.lineWidth = Length.parse(json.lineWidth);
    json.lineHeight = Length.parse(json.lineHeight);
    json.x = Length.parse(json.x);
    json.y = Length.parse(json.y);
    return json;
  }
  toString() {
    var {
      type,
      width: width2,
      height: height2,
      x,
      y,
      foreColor,
      backColor,
      blendMode,
      lineWidth,
      lineHeight
    } = this.json;
    return `${type}(${width2} ${height2}, ${x} ${y}, ${foreColor}, ${backColor}, ${blendMode}, ${lineWidth} ${lineHeight})`;
  }
}
class CheckPattern extends BasePattern {
  getDefaultObject() {
    return super.getDefaultObject({
      type: "check"
    });
  }
  toCSS() {
    let { width: width2, height: height2, x, y, backColor, foreColor, blendMode } = this.json;
    backColor = backColor || "transparent";
    foreColor = foreColor || "black";
    return `
      background-image: repeating-linear-gradient(45deg, ${foreColor} 25%, ${backColor} 25%, ${backColor} 75%, ${foreColor} 75%, ${foreColor} 100%),repeating-linear-gradient(45deg, ${foreColor} 25%, ${backColor} 25%, ${backColor} 75%, ${foreColor} 75%, ${foreColor} 100%);
      background-position: 0px 0px, ${x} ${y};
      background-size: ${width2} ${height2}, ${width2} ${height2};
      background-blend-mode: ${blendMode}, ${blendMode};
    `;
  }
}
class GridPattern extends BasePattern {
  getDefaultObject() {
    return super.getDefaultObject({
      type: "grid"
    });
  }
  toCSS() {
    let {
      width: width2,
      height: height2,
      lineWidth,
      lineHeight,
      backColor,
      foreColor,
      blendMode
    } = this.json;
    backColor = backColor || "transparent";
    foreColor = foreColor || "black";
    return `
      background-image: linear-gradient(to bottom,${foreColor} ${lineHeight}, ${backColor} ${lineHeight}),linear-gradient(to right, ${foreColor} ${lineWidth}, ${backColor} ${lineWidth});
      background-size: ${width2 / 2}px ${height2 / 2}px, ${width2 / 2}px ${height2 / 2}px;      
      background-blend-mode: ${blendMode}, ${blendMode};      
    `;
  }
}
class DotPattern extends BasePattern {
  getDefaultObject() {
    return super.getDefaultObject({
      type: "dot"
    });
  }
  toCSS() {
    let { width: width2, height: height2, lineWidth, backColor, foreColor, blendMode } = this.json;
    backColor = backColor || "transparent";
    foreColor = foreColor || "black";
    return `
      background-image: radial-gradient(${foreColor} ${lineWidth}, ${backColor} ${lineWidth});
      background-size: ${width2 / 2}px ${height2 / 2}px;          
      background-blend-mode: ${blendMode};      
    `;
  }
}
class CrossDotPattern extends BasePattern {
  getDefaultObject() {
    return super.getDefaultObject({
      type: "cross-dot"
    });
  }
  toCSS() {
    let { width: width2, height: height2, x, y, lineWidth, backColor, foreColor, blendMode } = this.json;
    backColor = backColor || "transparent";
    foreColor = foreColor || "black";
    return `
      background-image: radial-gradient(${foreColor} ${lineWidth}, ${backColor} ${lineWidth}),radial-gradient(${foreColor} ${lineWidth}, ${backColor} ${lineWidth});
      background-size: ${width2} ${height2},${width2} ${height2};
      background-position: 0px 0px, ${x} ${y};      
      background-blend-mode: multiply, ${blendMode};
    `;
  }
}
class DiagonalLinePattern extends BasePattern {
  getDefaultObject() {
    return super.getDefaultObject({
      type: "diagonal-line"
    });
  }
  toCSS() {
    let { width: width2, height: height2, x, lineWidth, backColor, foreColor, blendMode } = this.json;
    backColor = backColor || "transparent";
    foreColor = foreColor || "black";
    return `
    background-image: repeating-linear-gradient(${x}, ${foreColor} 0px, ${foreColor} ${lineWidth}, ${backColor} 0px, ${backColor} 50%);
    background-size: ${width2} ${height2};      
    background-blend-mode: ${blendMode};
  `;
  }
}
class VerticalLinePattern extends BasePattern {
  getDefaultObject() {
    return super.getDefaultObject({
      type: "vertical-line"
    });
  }
  toCSS() {
    let { width: width2, height: height2, x, y, lineWidth, backColor, foreColor, blendMode } = this.json;
    backColor = backColor || "transparent";
    foreColor = foreColor || "black";
    return `
      background-image: repeating-linear-gradient(to right, ${foreColor} 0px, ${foreColor} ${lineWidth}, ${backColor} ${lineWidth}, ${backColor} 100%);
      background-size: ${width2} ${height2}; 
      background-position: ${x} ${y};        
      background-blend-mode: ${blendMode};
    `;
  }
}
class HorizontalLinePattern extends BasePattern {
  getDefaultObject() {
    return super.getDefaultObject({
      type: "horizontal-line"
    });
  }
  toCSS() {
    let { width: width2, height: height2, x, y, lineWidth, backColor, foreColor, blendMode } = this.json;
    backColor = backColor || "transparent";
    foreColor = foreColor || "black";
    return `
      background-image: repeating-linear-gradient( to bottom, ${foreColor} 0px, ${foreColor} ${lineWidth}, ${backColor} ${lineWidth}, ${backColor} 100%);    
      background-position: ${x} ${y};
      background-size: ${width2} ${height2};   
      background-blend-mode: ${blendMode};
    `;
  }
}
const PatternClassName = {
  check: CheckPattern,
  grid: GridPattern,
  dot: DotPattern,
  "cross-dot": CrossDotPattern,
  "diagonal-line": DiagonalLinePattern,
  "vertical-line": VerticalLinePattern,
  "horizontal-line": HorizontalLinePattern
};
var addBackgroundImagePattern = {
  command: "addBackgroundImagePattern",
  execute: function(editor, pattern, id = null) {
    var items = editor.context.selection.itemsByIds(id);
    let itemsMap = {};
    items.forEach((item) => {
      itemsMap[item.id] = {
        pattern: Pattern.join([
          ...Pattern.parseStyle(pattern),
          ...Pattern.parseStyle(item.pattern)
        ])
      };
    });
    editor.context.commands.emit("history.setAttribute", "add pattern", itemsMap);
  }
};
var __glob_0_7$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": addBackgroundImagePattern
}, Symbol.toStringTag, { value: "Module" }));
function addCustomComponent(editor, obj2 = {}, center2 = null) {
  var project2 = editor.context.selection.currentProject;
  var customComponent = project2.appendChild(editor.createModel(__spreadValues({
    x: 300,
    y: 200,
    width: 375,
    height: 667
  }, obj2)));
  if (center2) {
    customComponent.reset({
      x: 0,
      y: 0
    });
    customComponent.moveByCenter(center2);
  }
  editor.context.selection.select(customComponent);
  _doForceRefreshSelection(editor);
}
var __glob_0_8$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": addCustomComponent
}, Symbol.toStringTag, { value: "Module" }));
function addImage(editor, rect2 = {}, containerItem = void 0) {
  editor.context.commands.emit("newComponent", "image", rect2, true, containerItem);
}
var __glob_0_9$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": addImage
}, Symbol.toStringTag, { value: "Module" }));
function loadOriginalImage(obj2, callback) {
  var img = new window.Image();
  img.onload = () => {
    var info = {
      id: obj2.id,
      local: obj2.local,
      naturalWidth: img.naturalWidth,
      naturalHeight: img.naturalHeight,
      width: img.naturalWidth,
      height: img.naturalHeight
    };
    callback && callback(info, img);
  };
  img.onerror = (e) => {
    console.log(e, e.message);
  };
  img.src = obj2.local;
}
var addImageAssetItem = {
  command: "addImageAssetItem",
  execute: function(editor, imageObject, rect2 = {}, containerItem = void 0) {
    var project2 = editor.context.selection.currentProject;
    if (project2) {
      project2.createImage(imageObject);
      editor.context.commands.emit("addImageAsset");
      loadOriginalImage(imageObject, (info) => {
        const rate = rect2.width / info.width;
        const width2 = rect2.width;
        const height2 = info.height * rate;
        editor.context.commands.emit("addImage", __spreadProps(__spreadValues(__spreadValues({
          src: imageObject.id
        }, info), rect2), {
          width: width2,
          height: height2
        }), containerItem);
      });
    }
  }
};
var __glob_0_10$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": addImageAssetItem
}, Symbol.toStringTag, { value: "Module" }));
function addLayer(editor, layer, isSelected = true, containerItem) {
  if (!containerItem) {
    containerItem = editor.context.selection.current || editor.context.selection.currentProject;
  }
  if (containerItem) {
    if (containerItem.isNot("project") && !containerItem.enableHasChildren()) {
      containerItem = containerItem.parent;
    }
    containerItem.appendChild(layer);
    if (isSelected) {
      editor.context.selection.select(layer);
    }
    _doForceRefreshSelection(editor);
  }
}
var __glob_0_11$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": addLayer
}, Symbol.toStringTag, { value: "Module" }));
var addLayerView = {
  command: "addLayerView",
  execute: async function(editor, type, data = {}) {
    editor.context.selection.empty();
    await editor.emit(REFRESH_SELECTION);
    await editor.emit("hideAddViewLayer");
    await editor.emit("removeGuideLine");
    editor.context.config.set("editing.mode.itemType", type);
    if (type === "select") {
      editor.context.config.set("editing.mode", EditingMode.SELECT);
    } else if (type === "brush") {
      editor.context.config.set("editing.mode", EditingMode.DRAW);
      await editor.emit("showPathDrawEditor");
    } else if (type === "path") {
      editor.context.config.set("editing.mode", EditingMode.PATH);
      await editor.emit("showPathEditor", "path");
    } else {
      editor.context.config.set("editing.mode", EditingMode.APPEND);
      await editor.emit("showLayerAppendView", type, data);
    }
  }
};
var __glob_0_12$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": addLayerView
}, Symbol.toStringTag, { value: "Module" }));
function addProject(editor, obj2 = {}) {
  var project2 = editor.createModel(__spreadValues({
    itemType: "project"
  }, obj2));
  editor.context.selection.selectProject(project2);
  _doForceRefreshSelection(editor);
}
var __glob_0_13$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": addProject
}, Symbol.toStringTag, { value: "Module" }));
var addSVGFilterAssetItem = {
  command: "addSVGFilterAssetItem",
  execute: function(editor, callback) {
    var project2 = editor.context.selection.currentProject;
    if (project2) {
      var id = uuidShort();
      var index2 = project2.createSVGFilter({ id, filters: [] });
      callback && callback(index2, id);
    }
  }
};
var __glob_0_14$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": addSVGFilterAssetItem
}, Symbol.toStringTag, { value: "Module" }));
function addText(editor, rect2 = {}) {
  editor.context.commands.emit("newComponent", "text", __spreadValues({
    content: "Insert a text",
    width: 300,
    height: 50,
    "font-size": 30
  }, rect2), rect2);
}
var __glob_0_15$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": addText
}, Symbol.toStringTag, { value: "Module" }));
var addTimelineCurrentProperty = {
  command: "addTimelineCurrentProperty",
  execute: function(editor, options2 = { timing: "linear" }) {
    _currentProject(editor, (project2) => {
      var list2 = [];
      editor.context.selection.each((item) => {
        var keyframeObj = {
          layerId: item.id,
          property: options2.property,
          value: item[options2.property] + "",
          timing: options2.timing,
          editor: options2.editor
        };
        var obj2 = project2.addTimelineKeyframe(keyframeObj);
        if (obj2) {
          list2.push(obj2);
        }
      });
      editor.context.timeline.select(...list2);
      editor.emit("refreshTimeline");
      editor.emit("refreshSelectedOffset");
    });
  }
};
var __glob_0_16$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": addTimelineCurrentProperty
}, Symbol.toStringTag, { value: "Module" }));
var addTimelineItem = {
  command: "addTimelineItem",
  execute: function(editor, layerId) {
    _currentProject(editor, (project2) => {
      if (layerId) {
        project2.addTimelineLayer(layerId);
      } else {
        project2.addTimeline();
      }
      editor.emit("refreshTimeline");
      editor.emit("addTimeline");
    });
  }
};
var __glob_0_17$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": addTimelineItem
}, Symbol.toStringTag, { value: "Module" }));
var addTimelineKeyframe = {
  command: "addTimelineKeyframe",
  execute: function(editor, options2 = { timing: "linear" }) {
    _currentProject(editor, (project2) => {
      var item = editor.context.modelManager.get(options2.layerId);
      var keyframeObj = {
        layerId: options2.layerId,
        property: options2.property,
        time: options2.time,
        value: item[options2.property] + "",
        timing: options2.timing,
        editor: options2.editor
      };
      var obj2 = project2.addTimelineKeyframe(keyframeObj);
      editor.timeline.select(obj2);
      editor.emit("refreshTimeline");
      editor.emit("refreshSelectedOffset");
    });
  }
};
var __glob_0_18$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": addTimelineKeyframe
}, Symbol.toStringTag, { value: "Module" }));
var addTimelineProperty = {
  command: "addTimelineProperty",
  execute: function(editor, layerList, options2 = { timing: "linear" }) {
    _currentProject(editor, (project2) => {
      if (Array.isArray(layerList) === false) {
        layerList = [layerList];
      }
      var list2 = [];
      layerList.forEach((layerId) => {
        var keyframeObj = {
          layerId,
          property: options2.property,
          value: options2.value + "",
          timing: options2.timing,
          editor: options2.editor
        };
        var obj2 = project2.addTimelineKeyframe(keyframeObj);
        if (obj2) {
          list2.push(obj2);
        }
      });
      editor.timeline.select(...list2);
      editor.emit("refreshTimeline");
      editor.emit("refreshSelectedOffset");
    });
  }
};
var __glob_0_19$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": addTimelineProperty
}, Symbol.toStringTag, { value: "Module" }));
function addVideo(editor, rect2 = {}, containerItem = void 0) {
  editor.context.commands.emit("newComponent", "video", rect2, true, containerItem);
}
var __glob_0_20$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": addVideo
}, Symbol.toStringTag, { value: "Module" }));
function loadOriginalVideo(obj2, callback) {
  var video2 = document.createElement("video");
  video2.onloadeddata = () => {
    var info = {
      local: obj2.local,
      naturalWidth: video2.videoWidth,
      naturalHeight: video2.videoHeight,
      width: video2.videoWidth,
      height: video2.videoHeight,
      duration: video2.duration,
      playTime: `0:1:${video2.duration}`,
      volume: video2.volume,
      muted: video2.muted,
      placebackRate: video2.playbackRate
    };
    callback && callback(info, video2);
  };
  video2.src = obj2.local;
}
var addVideoAssetItem = {
  command: "addVideoAssetItem",
  execute: function(editor, videoObject, rect2 = {}, containerItem = void 0) {
    var project2 = editor.context.selection.currentProject;
    if (project2) {
      project2.createVideo(videoObject);
      editor.emit("addVideoAsset");
      loadOriginalVideo(videoObject, (info) => {
        editor.context.commands.emit("addVideo", __spreadValues(__spreadValues({ src: videoObject.id }, info), rect2), containerItem);
      });
    }
  }
};
var __glob_0_21$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": addVideoAssetItem
}, Symbol.toStringTag, { value: "Module" }));
var clipboard_copy = {
  command: "clipboard.copy",
  title: "Copy",
  description: "Copy",
  execute: function(editor) {
    editor.context.clipboard.push({
      type: ClipboardActionType.COPY,
      data: editor.context.selection.ids
    });
  }
};
var __glob_0_22$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": clipboard_copy
}, Symbol.toStringTag, { value: "Module" }));
var clipboard_paste = {
  command: "clipboard.paste",
  execute: async function(editor) {
    if (!editor.context.clipboard.isEmpty) {
      editor.context.commands.emit("history.clipboard.paste", "paste");
    } else {
      var text2 = await window.navigator.clipboard.readText();
      if (text2) {
        editor.context.commands.emit("convertPasteText", text2);
      }
    }
  }
};
var __glob_0_23$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": clipboard_paste
}, Symbol.toStringTag, { value: "Module" }));
var convert_flatten_path = {
  command: "convert.flatten.path",
  description: "flatten selected multi path",
  execute: (editor) => {
    const current = editor.context.selection.current;
    if (!current)
      return;
    let newPath;
    if (current.is("boolean-path") || current.isBooleanItem) {
      let parent = current;
      if (current.isBooleanItem) {
        parent = current.parent;
      }
      newPath = parent.absolutePath(parent["boolean-path"]);
      newPath = parent.invertPath(newPath.d);
      const newLayerAttrs = parent.layers[0].toCloneObject();
      delete newLayerAttrs.id;
      delete newLayerAttrs.parentId;
      delete newLayerAttrs.transform;
      delete newLayerAttrs["boolean-path"];
      delete newLayerAttrs["boolean-operation"];
      const parentParent = parent.parent;
      const newRectInfo = parent.updatePath(newPath.d);
      editor.context.commands.executeCommand("removeLayer", "remove selected layers", [parent.id]);
      editor.nextTick(() => {
        editor.context.commands.executeCommand("addLayer", `add layer - path`, editor.createModel(__spreadValues(__spreadValues({}, newLayerAttrs), newRectInfo)), true, parentParent);
      });
    } else {
      newPath = PathParser.fromSVGString();
      editor.context.selection.each((item) => {
        newPath.addPath(item.absolutePath());
      });
      newPath = current.invertPath(newPath.d);
      const parent = current.parent;
      const newPathInfo = current.updatePath(newPath.d);
      const newLayerAttrs = current.toCloneObject();
      delete newLayerAttrs.id;
      editor.context.commands.executeCommand("removeLayer", "remove selected layers");
      editor.nextTick(() => {
        editor.context.commands.executeCommand("addLayer", `add layer - path`, editor.createModel(__spreadValues(__spreadValues({}, newLayerAttrs), newPathInfo)), true, parent);
      });
    }
  }
};
var __glob_0_24$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": convert_flatten_path
}, Symbol.toStringTag, { value: "Module" }));
var convert_no_transform_path = {
  command: "convert.no.transform.path",
  description: "remove transform(rotate, translate, scale) inforation in path layer",
  execute: (editor) => {
    const current = editor.context.selection.current;
    if (!current)
      return;
    const parent = current.parent;
    const childPath = current.absolutePath();
    if (parent.is("project")) {
      const verties = childPath.getBBox();
      const newRect = vertiesToRectangle(verties);
      editor.context.commands.executeCommand("setAttribute", "remove transform for path", editor.context.selection.packByValue(__spreadProps(__spreadValues({}, newRect), {
        rotate: 0,
        d: childPath.d
      })));
    } else {
      childPath.transformMat4(parent.absoluteMatrixInverse);
      const newRect = parent.updatePath(childPath.d);
      editor.context.commands.executeCommand("setAttribute", "remove transform for path", editor.context.selection.packByValue(__spreadProps(__spreadValues({}, newRect), {
        rotate: 0,
        d: childPath.d
      })));
    }
  }
};
var __glob_0_25 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": convert_no_transform_path
}, Symbol.toStringTag, { value: "Module" }));
var convert_normalize_path = {
  command: "convert.normalize.path",
  description: "convert segments to bezier curve",
  execute: (editor) => {
    const current = editor.context.selection.current;
    if (!current)
      return;
    editor.context.commands.executeCommand("setAttribute", "normalize path string", editor.context.selection.packByValue(current.updatePath(PathParser.fromSVGString(current.d).normalize().d)));
  }
};
var __glob_0_26 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": convert_normalize_path
}, Symbol.toStringTag, { value: "Module" }));
var convert_path_operation = {
  command: "convert.path.operation",
  description: "apply path boolean operation",
  execute: (editor, booleanOperation) => {
    var _a;
    const current = editor.context.selection.current;
    if (!current)
      return;
    const changeBooleanOperation = (booleanOperation2) => {
      editor.context.commands.executeCommand("setAttribute", "change boolean operation", editor.context.selection.packByValue({
        booleanOperation: booleanOperation2
      }));
      recoverBooleanPath2();
    };
    const recoverBooleanPath2 = () => {
      editor.nextTick(() => {
        editor.context.commands.emit("recoverBooleanPath");
        editor.nextTick(() => {
          editor.emit(REFRESH_SELECTION);
        });
      });
    };
    if (current.is("boolean-path") || current.isBooleanItem) {
      let parent = current;
      if (current.isBooleanItem) {
        parent = current.parent;
      }
      editor.context.selection.select(parent);
      changeBooleanOperation(booleanOperation);
    } else {
      if ((_a = editor.context.selection.current) == null ? void 0 : _a.isNot("boolean-path")) {
        editor.context.commands.emit("group.item", {
          itemType: "boolean-path",
          title: "Intersection"
        });
      }
      editor.nextTick(() => {
        var _a2;
        if ((_a2 = editor.context.selection.current) == null ? void 0 : _a2.is("boolean-path")) {
          changeBooleanOperation(booleanOperation);
        }
      }, 10);
    }
  }
};
var __glob_0_27 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": convert_path_operation
}, Symbol.toStringTag, { value: "Module" }));
var convert_polygonal_path = {
  command: "convert.polygonal.path",
  description: "convert path to polygonal path",
  execute: (editor) => {
    const current = editor.context.selection.current;
    if (!current)
      return;
    editor.context.commands.executeCommand("setAttribute", "polygonal path string", editor.context.selection.packByValue(current.updatePath(PathParser.fromSVGString(current.d).polygonal().d)));
  }
};
var __glob_0_28 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": convert_polygonal_path
}, Symbol.toStringTag, { value: "Module" }));
var convert_simplify_path = {
  command: "convert.simplify.path",
  execute: (editor) => {
    const current = editor.context.selection.current;
    if (!current)
      return;
    editor.context.commands.executeCommand("setAttribute", "change path string", editor.context.selection.packByValue(current.updatePath(editor.pathKitManager.simplify(current.d))));
  }
};
var __glob_0_29 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": convert_simplify_path
}, Symbol.toStringTag, { value: "Module" }));
var convert_smooth_path = {
  command: "convert.smooth.path",
  description: "convert path to smooth",
  execute: (editor, divideCount = 5, tolerance = 0.1, tension = 0.5) => {
    const current = editor.context.selection.current;
    if (!current)
      return;
    const smoothedPath = PathParser.fromSVGString(current.d).divideSegmentByCount(divideCount).simplify(tolerance).cardinalSplines(tension).d;
    editor.context.commands.executeCommand("setAttribute", "smooth path string", editor.context.selection.packByValue(current.updatePath(smoothedPath)));
  }
};
var __glob_0_30 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": convert_smooth_path
}, Symbol.toStringTag, { value: "Module" }));
var convert_stroke_to_path = {
  command: "convert.stroke.to.path",
  execute: async (editor) => {
    const current = editor.context.selection.current;
    if (!current)
      return;
    const attrs = current.attrs("d", "stroke-width", "stroke-dasharray", "stroke-dashoffset", "stroke-linejoin", "stroke-linecap");
    const pathAttrs = current.convertStrokeToPath();
    let newD = editor.pathKitManager.stroke(current.d || attrs.d, {
      "stroke-width": Length.parse(attrs["stroke-width"]).value,
      "stroke-linejoin": attrs["stroke-linejoin"],
      "stroke-linecap": attrs["stroke-linecap"],
      "stroke-dasharray": attrs["stroke-dasharray"],
      "stroke-dashoffset": attrs["stroke-dashoffset"],
      "fill-rule": "nonezero"
    });
    pathAttrs["fill-rule"] = "nonzero";
    newD = PathParser.fromSVGString(newD).reversePathStringByFunc((_, index2) => index2 % 2 === 0);
    editor.context.commands.executeCommand("addLayer", `add layer - path`, editor.createModel(__spreadValues(__spreadValues({}, pathAttrs), current.updatePath(newD))), true, current.parent);
  }
};
var __glob_0_31 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": convert_stroke_to_path
}, Symbol.toStringTag, { value: "Module" }));
var jsVideoUrlParser = { exports: {} };
(function(module, exports) {
  (function(global2, factory) {
    module.exports = factory();
  })(commonjsGlobal, function() {
    function _typeof(obj2) {
      "@babel/helpers - typeof";
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof = function(obj3) {
          return typeof obj3;
        };
      } else {
        _typeof = function(obj3) {
          return obj3 && typeof Symbol === "function" && obj3.constructor === Symbol && obj3 !== Symbol.prototype ? "symbol" : typeof obj3;
        };
      }
      return _typeof(obj2);
    }
    var getQueryParams = function getQueryParams2(qs) {
      if (typeof qs !== "string") {
        return {};
      }
      qs = qs.split("+").join(" ");
      var params = {};
      var match = qs.match(/(?:[?](?:[^=]+)=(?:[^&#]*)(?:[&](?:[^=]+)=(?:[^&#]*))*(?:[#].*)?)|(?:[#].*)/);
      var split;
      if (match === null) {
        return {};
      }
      split = match[0].substr(1).split(/[&#=]/);
      for (var i = 0; i < split.length; i += 2) {
        params[decodeURIComponent(split[i])] = decodeURIComponent(split[i + 1] || "");
      }
      return params;
    };
    var combineParams = function combineParams2(params, hasParams) {
      if (_typeof(params) !== "object") {
        return "";
      }
      var combined = "";
      var i = 0;
      var keys2 = Object.keys(params);
      if (keys2.length === 0) {
        return "";
      }
      keys2.sort();
      if (!hasParams) {
        combined += "?" + keys2[0] + "=" + params[keys2[0]];
        i += 1;
      }
      for (; i < keys2.length; i += 1) {
        combined += "&" + keys2[i] + "=" + params[keys2[i]];
      }
      return combined;
    };
    function getLetterTime(timeString) {
      var totalSeconds = 0;
      var timeValues = {
        "s": 1,
        "m": 1 * 60,
        "h": 1 * 60 * 60,
        "d": 1 * 60 * 60 * 24,
        "w": 1 * 60 * 60 * 24 * 7
      };
      var timePairs;
      timeString = timeString.replace(/([smhdw])/g, " $1 ").trim();
      timePairs = timeString.split(" ");
      for (var i = 0; i < timePairs.length; i += 2) {
        totalSeconds += parseInt(timePairs[i], 10) * timeValues[timePairs[i + 1] || "s"];
      }
      return totalSeconds;
    }
    function getColonTime(timeString) {
      var totalSeconds = 0;
      var timeValues = [1, 1 * 60, 1 * 60 * 60, 1 * 60 * 60 * 24, 1 * 60 * 60 * 24 * 7];
      var timePairs = timeString.split(":");
      for (var i = 0; i < timePairs.length; i++) {
        totalSeconds += parseInt(timePairs[i], 10) * timeValues[timePairs.length - i - 1];
      }
      return totalSeconds;
    }
    var getTime = function getTime2(timeString) {
      if (typeof timeString === "undefined") {
        return 0;
      }
      if (timeString.match(/^(\d+[smhdw]?)+$/)) {
        return getLetterTime(timeString);
      }
      if (timeString.match(/^(\d+:?)+$/)) {
        return getColonTime(timeString);
      }
      return 0;
    };
    var util = {
      getQueryParams,
      combineParams,
      getTime
    };
    var getQueryParams$1 = util.getQueryParams;
    function UrlParser() {
      for (var _i = 0, _arr = ["parseProvider", "parse", "bind", "create"]; _i < _arr.length; _i++) {
        var key = _arr[_i];
        this[key] = this[key].bind(this);
      }
      this.plugins = {};
    }
    var urlParser2 = UrlParser;
    UrlParser.prototype.parseProvider = function(url) {
      var match = url.match(/(?:(?:https?:)?\/\/)?(?:[^.]+\.)?(\w+)\./i);
      return match ? match[1] : void 0;
    };
    UrlParser.prototype.parse = function(url) {
      if (typeof url === "undefined") {
        return void 0;
      }
      var provider = this.parseProvider(url);
      var result;
      var plugin2 = this.plugins[provider];
      if (!provider || !plugin2 || !plugin2.parse) {
        return void 0;
      }
      result = plugin2.parse.call(plugin2, url, getQueryParams$1(url));
      if (result) {
        result = removeEmptyParameters(result);
        result.provider = plugin2.provider;
      }
      return result;
    };
    UrlParser.prototype.bind = function(plugin2) {
      this.plugins[plugin2.provider] = plugin2;
      if (plugin2.alternatives) {
        for (var i = 0; i < plugin2.alternatives.length; i += 1) {
          this.plugins[plugin2.alternatives[i]] = plugin2;
        }
      }
    };
    UrlParser.prototype.create = function(op) {
      if (_typeof(op) !== "object" || _typeof(op.videoInfo) !== "object") {
        return void 0;
      }
      var vi = op.videoInfo;
      var params = op.params;
      var plugin2 = this.plugins[vi.provider];
      params = params === "internal" ? vi.params : params || {};
      if (plugin2) {
        op.format = op.format || plugin2.defaultFormat;
        if (plugin2.formats.hasOwnProperty(op.format)) {
          return plugin2.formats[op.format].apply(plugin2, [vi, Object.assign({}, params)]);
        }
      }
      return void 0;
    };
    function removeEmptyParameters(result) {
      if (result.params && Object.keys(result.params).length === 0) {
        delete result.params;
      }
      return result;
    }
    var parser = new urlParser2();
    var base = parser;
    var combineParams$1 = util.combineParams;
    function CanalPlus() {
      this.provider = "canalplus";
      this.defaultFormat = "embed";
      this.formats = {
        embed: this.createEmbedUrl
      };
      this.mediaTypes = {
        VIDEO: "video"
      };
    }
    CanalPlus.prototype.parseParameters = function(params) {
      delete params.vid;
      return params;
    };
    CanalPlus.prototype.parse = function(url, params) {
      var _this = this;
      var result = {
        mediaType: this.mediaTypes.VIDEO,
        id: params.vid
      };
      result.params = _this.parseParameters(params);
      if (!result.id) {
        return void 0;
      }
      return result;
    };
    CanalPlus.prototype.createEmbedUrl = function(vi, params) {
      if (!vi.id || vi.mediaType !== this.mediaTypes.VIDEO) {
        return void 0;
      }
      var url = "http://player.canalplus.fr/embed/";
      params.vid = vi.id;
      url += combineParams$1(params);
      return url;
    };
    base.bind(new CanalPlus());
    var combineParams$2 = util.combineParams;
    function Coub() {
      this.provider = "coub";
      this.defaultFormat = "long";
      this.formats = {
        "long": this.createLongUrl,
        embed: this.createEmbedUrl
      };
      this.mediaTypes = {
        VIDEO: "video"
      };
    }
    Coub.prototype.parseUrl = function(url) {
      var match = url.match(/(?:embed|view)\/([a-zA-Z\d]+)/i);
      return match ? match[1] : void 0;
    };
    Coub.prototype.parse = function(url, params) {
      var result = {
        mediaType: this.mediaTypes.VIDEO,
        params,
        id: this.parseUrl(url)
      };
      if (!result.id) {
        return void 0;
      }
      return result;
    };
    Coub.prototype.createUrl = function(baseUrl, vi, params) {
      if (!vi.id || vi.mediaType !== this.mediaTypes.VIDEO) {
        return void 0;
      }
      var url = baseUrl + vi.id;
      url += combineParams$2(params);
      return url;
    };
    Coub.prototype.createLongUrl = function(vi, params) {
      return this.createUrl("https://coub.com/view/", vi, params);
    };
    Coub.prototype.createEmbedUrl = function(vi, params) {
      return this.createUrl("//coub.com/embed/", vi, params);
    };
    base.bind(new Coub());
    var combineParams$3 = util.combineParams, getTime$1 = util.getTime;
    function Dailymotion() {
      this.provider = "dailymotion";
      this.alternatives = ["dai"];
      this.defaultFormat = "long";
      this.formats = {
        "short": this.createShortUrl,
        "long": this.createLongUrl,
        embed: this.createEmbedUrl,
        image: this.createImageUrl
      };
      this.mediaTypes = {
        VIDEO: "video"
      };
    }
    Dailymotion.prototype.parseParameters = function(params) {
      return this.parseTime(params);
    };
    Dailymotion.prototype.parseTime = function(params) {
      if (params.start) {
        params.start = getTime$1(params.start);
      }
      return params;
    };
    Dailymotion.prototype.parseUrl = function(url) {
      var match = url.match(/(?:\/video|ly)\/([A-Za-z0-9]+)/i);
      return match ? match[1] : void 0;
    };
    Dailymotion.prototype.parse = function(url, params) {
      var _this = this;
      var result = {
        mediaType: this.mediaTypes.VIDEO,
        params: _this.parseParameters(params),
        id: _this.parseUrl(url)
      };
      return result.id ? result : void 0;
    };
    Dailymotion.prototype.createUrl = function(base2, vi, params) {
      if (!vi.id || vi.mediaType !== this.mediaTypes.VIDEO) {
        return void 0;
      }
      return base2 + vi.id + combineParams$3(params);
    };
    Dailymotion.prototype.createShortUrl = function(vi, params) {
      return this.createUrl("https://dai.ly/", vi, params);
    };
    Dailymotion.prototype.createLongUrl = function(vi, params) {
      return this.createUrl("https://dailymotion.com/video/", vi, params);
    };
    Dailymotion.prototype.createEmbedUrl = function(vi, params) {
      return this.createUrl("https://www.dailymotion.com/embed/video/", vi, params);
    };
    Dailymotion.prototype.createImageUrl = function(vi, params) {
      delete params.start;
      return this.createUrl("https://www.dailymotion.com/thumbnail/video/", vi, params);
    };
    base.bind(new Dailymotion());
    var combineParams$4 = util.combineParams, getTime$2 = util.getTime;
    function Twitch() {
      this.provider = "twitch";
      this.defaultFormat = "long";
      this.formats = {
        "long": this.createLongUrl,
        embed: this.createEmbedUrl
      };
      this.mediaTypes = {
        VIDEO: "video",
        STREAM: "stream",
        CLIP: "clip"
      };
    }
    Twitch.prototype.seperateId = function(id) {
      return {
        pre: id[0],
        id: id.substr(1)
      };
    };
    Twitch.prototype.parseChannel = function(result, params) {
      var channel = params.channel || params.utm_content || result.channel;
      delete params.utm_content;
      delete params.channel;
      return channel;
    };
    Twitch.prototype.parseUrl = function(url, result, params) {
      var match;
      match = url.match(/(clips\.)?twitch\.tv\/(?:(?:videos\/(\d+))|(\w+)(?:\/clip\/(\w+))?)/i);
      if (match && match[2]) {
        result.id = "v" + match[2];
      } else if (params.video) {
        result.id = params.video;
        delete params.video;
      } else if (params.clip) {
        result.id = params.clip;
        result.isClip = true;
        delete params.clip;
      } else if (match && match[1] && match[3]) {
        result.id = match[3];
        result.isClip = true;
      } else if (match && match[3] && match[4]) {
        result.channel = match[3];
        result.id = match[4];
        result.isClip = true;
      } else if (match && match[3]) {
        result.channel = match[3];
      }
      return result;
    };
    Twitch.prototype.parseMediaType = function(result) {
      var mediaType;
      if (result.id) {
        if (result.isClip) {
          mediaType = this.mediaTypes.CLIP;
          delete result.isClip;
        } else {
          mediaType = this.mediaTypes.VIDEO;
        }
      } else if (result.channel) {
        mediaType = this.mediaTypes.STREAM;
      }
      return mediaType;
    };
    Twitch.prototype.parseParameters = function(params) {
      if (params.t) {
        params.start = getTime$2(params.t);
        delete params.t;
      }
      return params;
    };
    Twitch.prototype.parse = function(url, params) {
      var _this = this;
      var result = {};
      result = _this.parseUrl(url, result, params);
      result.channel = _this.parseChannel(result, params);
      result.mediaType = _this.parseMediaType(result);
      result.params = _this.parseParameters(params);
      return result.channel || result.id ? result : void 0;
    };
    Twitch.prototype.createLongUrl = function(vi, params) {
      var url = "";
      if (vi.mediaType === this.mediaTypes.STREAM && vi.channel) {
        url = "https://twitch.tv/" + vi.channel;
      } else if (vi.mediaType === this.mediaTypes.VIDEO && vi.id) {
        var sep = this.seperateId(vi.id);
        url = "https://twitch.tv/videos/" + sep.id;
        if (params.start) {
          params.t = params.start + "s";
          delete params.start;
        }
      } else if (vi.mediaType === this.mediaTypes.CLIP && vi.id) {
        if (vi.channel) {
          url = "https://www.twitch.tv/" + vi.channel + "/clip/" + vi.id;
        } else {
          url = "https://clips.twitch.tv/" + vi.id;
        }
      } else {
        return void 0;
      }
      url += combineParams$4(params);
      return url;
    };
    Twitch.prototype.createEmbedUrl = function(vi, params) {
      var url = "https://player.twitch.tv/";
      if (vi.mediaType === this.mediaTypes.STREAM && vi.channel) {
        params.channel = vi.channel;
      } else if (vi.mediaType === this.mediaTypes.VIDEO && vi.id) {
        params.video = vi.id;
        if (params.start) {
          params.t = params.start + "s";
          delete params.start;
        }
      } else if (vi.mediaType === this.mediaTypes.CLIP && vi.id) {
        url = "https://clips.twitch.tv/embed";
        params.clip = vi.id;
      } else {
        return void 0;
      }
      url += combineParams$4(params);
      return url;
    };
    base.bind(new Twitch());
    var combineParams$5 = util.combineParams, getTime$3 = util.getTime;
    function Vimeo() {
      this.provider = "vimeo";
      this.alternatives = ["vimeopro"];
      this.defaultFormat = "long";
      this.formats = {
        "long": this.createLongUrl,
        embed: this.createEmbedUrl
      };
      this.mediaTypes = {
        VIDEO: "video"
      };
    }
    Vimeo.prototype.parseUrl = function(url) {
      var match = url.match(/(?:\/(?:channels\/[\w]+|(?:(?:album\/\d+|groups\/[\w]+)\/)?videos?))?\/(\d+)/i);
      return match ? match[1] : void 0;
    };
    Vimeo.prototype.parseParameters = function(params) {
      return this.parseTime(params);
    };
    Vimeo.prototype.parseTime = function(params) {
      if (params.t) {
        params.start = getTime$3(params.t);
        delete params.t;
      }
      return params;
    };
    Vimeo.prototype.parse = function(url, params) {
      var result = {
        mediaType: this.mediaTypes.VIDEO,
        params: this.parseParameters(params),
        id: this.parseUrl(url)
      };
      return result.id ? result : void 0;
    };
    Vimeo.prototype.createUrl = function(baseUrl, vi, params) {
      if (!vi.id || vi.mediaType !== this.mediaTypes.VIDEO) {
        return void 0;
      }
      var url = baseUrl + vi.id;
      var startTime = params.start;
      delete params.start;
      url += combineParams$5(params);
      if (startTime) {
        url += "#t=" + startTime;
      }
      return url;
    };
    Vimeo.prototype.createLongUrl = function(vi, params) {
      return this.createUrl("https://vimeo.com/", vi, params);
    };
    Vimeo.prototype.createEmbedUrl = function(vi, params) {
      return this.createUrl("//player.vimeo.com/video/", vi, params);
    };
    base.bind(new Vimeo());
    var combineParams$6 = util.combineParams, getTime$4 = util.getTime;
    function Wistia() {
      this.provider = "wistia";
      this.alternatives = [];
      this.defaultFormat = "long";
      this.formats = {
        "long": this.createLongUrl,
        embed: this.createEmbedUrl,
        embedjsonp: this.createEmbedJsonpUrl
      };
      this.mediaTypes = {
        VIDEO: "video",
        EMBEDVIDEO: "embedvideo"
      };
    }
    Wistia.prototype.parseUrl = function(url) {
      var match = url.match(/(?:(?:medias|iframe)\/|wvideo=)([\w-]+)/);
      return match ? match[1] : void 0;
    };
    Wistia.prototype.parseChannel = function(url) {
      var match = url.match(/(?:(?:https?:)?\/\/)?([^.]*)\.wistia\./);
      var channel = match ? match[1] : void 0;
      if (channel === "fast" || channel === "content") {
        return void 0;
      }
      return channel;
    };
    Wistia.prototype.parseParameters = function(params, result) {
      if (params.wtime) {
        params.start = getTime$4(params.wtime);
        delete params.wtime;
      }
      if (params.wvideo === result.id) {
        delete params.wvideo;
      }
      return params;
    };
    Wistia.prototype.parseMediaType = function(result) {
      if (result.id && result.channel) {
        return this.mediaTypes.VIDEO;
      } else if (result.id) {
        delete result.channel;
        return this.mediaTypes.EMBEDVIDEO;
      } else {
        return void 0;
      }
    };
    Wistia.prototype.parse = function(url, params) {
      var result = {
        id: this.parseUrl(url),
        channel: this.parseChannel(url)
      };
      result.params = this.parseParameters(params, result);
      result.mediaType = this.parseMediaType(result);
      if (!result.id) {
        return void 0;
      }
      return result;
    };
    Wistia.prototype.createUrl = function(vi, params, url) {
      if (params.start) {
        params.wtime = params.start;
        delete params.start;
      }
      url += combineParams$6(params);
      return url;
    };
    Wistia.prototype.createLongUrl = function(vi, params) {
      if (!vi.id || vi.mediaType !== this.mediaTypes.VIDEO) {
        return void 0;
      }
      var url = "https://" + vi.channel + ".wistia.com/medias/" + vi.id;
      return this.createUrl(vi, params, url);
    };
    Wistia.prototype.createEmbedUrl = function(vi, params) {
      if (!vi.id || !(vi.mediaType === this.mediaTypes.VIDEO || vi.mediaType === this.mediaTypes.EMBEDVIDEO)) {
        return void 0;
      }
      var url = "https://fast.wistia.com/embed/iframe/" + vi.id;
      return this.createUrl(vi, params, url);
    };
    Wistia.prototype.createEmbedJsonpUrl = function(vi) {
      if (!vi.id || !(vi.mediaType === this.mediaTypes.VIDEO || vi.mediaType === this.mediaTypes.EMBEDVIDEO)) {
        return void 0;
      }
      return "https://fast.wistia.com/embed/medias/" + vi.id + ".jsonp";
    };
    base.bind(new Wistia());
    var combineParams$7 = util.combineParams;
    function Youku() {
      this.provider = "youku";
      this.defaultFormat = "long";
      this.formats = {
        embed: this.createEmbedUrl,
        "long": this.createLongUrl,
        flash: this.createFlashUrl,
        "static": this.createStaticUrl
      };
      this.mediaTypes = {
        VIDEO: "video"
      };
    }
    Youku.prototype.parseUrl = function(url) {
      var match = url.match(/(?:(?:embed|sid)\/|v_show\/id_|VideoIDS=)([a-zA-Z0-9]+)/);
      return match ? match[1] : void 0;
    };
    Youku.prototype.parseParameters = function(params) {
      if (params.VideoIDS) {
        delete params.VideoIDS;
      }
      return params;
    };
    Youku.prototype.parse = function(url, params) {
      var _this = this;
      var result = {
        mediaType: this.mediaTypes.VIDEO,
        id: _this.parseUrl(url),
        params: _this.parseParameters(params)
      };
      if (!result.id) {
        return void 0;
      }
      return result;
    };
    Youku.prototype.createUrl = function(baseUrl, vi, params) {
      if (!vi.id || vi.mediaType !== this.mediaTypes.VIDEO) {
        return void 0;
      }
      var url = baseUrl + vi.id;
      url += combineParams$7(params);
      return url;
    };
    Youku.prototype.createEmbedUrl = function(vi, params) {
      return this.createUrl("http://player.youku.com/embed/", vi, params);
    };
    Youku.prototype.createLongUrl = function(vi, params) {
      return this.createUrl("http://v.youku.com/v_show/id_", vi, params);
    };
    Youku.prototype.createStaticUrl = function(vi, params) {
      return this.createUrl("http://static.youku.com/v1.0.0638/v/swf/loader.swf?VideoIDS=", vi, params);
    };
    Youku.prototype.createFlashUrl = function(vi, params) {
      if (!vi.id || vi.mediaType !== this.mediaTypes.VIDEO) {
        return void 0;
      }
      var url = "http://player.youku.com/player.php/sid/" + vi.id + "/v.swf";
      url += combineParams$7(params);
      return url;
    };
    base.bind(new Youku());
    var combineParams$8 = util.combineParams, getTime$5 = util.getTime;
    function YouTube() {
      this.provider = "youtube";
      this.alternatives = ["youtu", "ytimg"];
      this.defaultFormat = "long";
      this.formats = {
        "short": this.createShortUrl,
        "long": this.createLongUrl,
        embed: this.createEmbedUrl,
        shortImage: this.createShortImageUrl,
        longImage: this.createLongImageUrl
      };
      this.imageQualities = {
        "0": "0",
        "1": "1",
        "2": "2",
        "3": "3",
        DEFAULT: "default",
        HQDEFAULT: "hqdefault",
        SDDEFAULT: "sddefault",
        MQDEFAULT: "mqdefault",
        MAXRESDEFAULT: "maxresdefault"
      };
      this.defaultImageQuality = this.imageQualities.HQDEFAULT;
      this.mediaTypes = {
        VIDEO: "video",
        PLAYLIST: "playlist",
        SHARE: "share",
        CHANNEL: "channel"
      };
    }
    YouTube.prototype.parseVideoUrl = function(url) {
      var match = url.match(/(?:(?:v|vi|be|videos|embed)\/(?!videoseries)|(?:v|ci)=)([\w-]{11})/i);
      return match ? match[1] : void 0;
    };
    YouTube.prototype.parseChannelUrl = function(url) {
      var match = url.match(/\/channel\/([\w-]+)/);
      if (match) {
        return {
          id: match[1],
          mediaType: this.mediaTypes.CHANNEL
        };
      }
      match = url.match(/\/(?:c|user)\/([\w-]+)/);
      if (match) {
        return {
          name: match[1],
          mediaType: this.mediaTypes.CHANNEL
        };
      }
    };
    YouTube.prototype.parseParameters = function(params, result) {
      if (params.start || params.t) {
        params.start = getTime$5(params.start || params.t);
        delete params.t;
      }
      if (params.v === result.id) {
        delete params.v;
      }
      if (params.list === result.id) {
        delete params.list;
      }
      return params;
    };
    YouTube.prototype.parseMediaType = function(result) {
      if (result.params.list) {
        result.list = result.params.list;
        delete result.params.list;
      }
      if (result.id && !result.params.ci) {
        result.mediaType = this.mediaTypes.VIDEO;
      } else if (result.list) {
        delete result.id;
        result.mediaType = this.mediaTypes.PLAYLIST;
      } else if (result.params.ci) {
        delete result.params.ci;
        result.mediaType = this.mediaTypes.SHARE;
      } else {
        return void 0;
      }
      return result;
    };
    YouTube.prototype.parse = function(url, params) {
      var channelResult = this.parseChannelUrl(url);
      if (channelResult) {
        return channelResult;
      } else {
        var result = {
          params,
          id: this.parseVideoUrl(url)
        };
        result.params = this.parseParameters(params, result);
        result = this.parseMediaType(result);
        return result;
      }
    };
    YouTube.prototype.createShortUrl = function(vi, params) {
      if (!vi.id || vi.mediaType !== this.mediaTypes.VIDEO) {
        return void 0;
      }
      var url = "https://youtu.be/" + vi.id;
      if (params.start) {
        url += "#t=" + params.start;
      }
      return url;
    };
    YouTube.prototype.createLongUrl = function(vi, params) {
      var url = "";
      var startTime = params.start;
      delete params.start;
      if (vi.mediaType === this.mediaTypes.CHANNEL) {
        if (vi.id) {
          url += "https://www.youtube.com/channel/" + vi.id;
        } else if (vi.name) {
          url += "https://www.youtube.com/c/" + vi.name;
        } else {
          return void 0;
        }
      } else if (vi.mediaType === this.mediaTypes.PLAYLIST && vi.list) {
        params.feature = "share";
        url += "https://www.youtube.com/playlist";
      } else if (vi.mediaType === this.mediaTypes.VIDEO && vi.id) {
        params.v = vi.id;
        url += "https://www.youtube.com/watch";
      } else if (vi.mediaType === this.mediaTypes.SHARE && vi.id) {
        params.ci = vi.id;
        url += "https://www.youtube.com/shared";
      } else {
        return void 0;
      }
      if (vi.list) {
        params.list = vi.list;
      }
      url += combineParams$8(params);
      if (vi.mediaType !== this.mediaTypes.PLAYLIST && startTime) {
        url += "#t=" + startTime;
      }
      return url;
    };
    YouTube.prototype.createEmbedUrl = function(vi, params) {
      var url = "https://www.youtube.com/embed";
      if (vi.mediaType === this.mediaTypes.PLAYLIST && vi.list) {
        params.listType = "playlist";
      } else if (vi.mediaType === this.mediaTypes.VIDEO && vi.id) {
        url += "/" + vi.id;
        if (params.loop === "1") {
          params.playlist = vi.id;
        }
      } else {
        return void 0;
      }
      if (vi.list) {
        params.list = vi.list;
      }
      url += combineParams$8(params);
      return url;
    };
    YouTube.prototype.createImageUrl = function(baseUrl, vi, params) {
      if (!vi.id || vi.mediaType !== this.mediaTypes.VIDEO) {
        return void 0;
      }
      var url = baseUrl + vi.id + "/";
      var quality = params.imageQuality || this.defaultImageQuality;
      return url + quality + ".jpg";
    };
    YouTube.prototype.createShortImageUrl = function(vi, params) {
      return this.createImageUrl("https://i.ytimg.com/vi/", vi, params);
    };
    YouTube.prototype.createLongImageUrl = function(vi, params) {
      return this.createImageUrl("https://img.youtube.com/vi/", vi, params);
    };
    base.bind(new YouTube());
    var combineParams$9 = util.combineParams, getTime$6 = util.getTime;
    function SoundCloud() {
      this.provider = "soundcloud";
      this.defaultFormat = "long";
      this.formats = {
        "long": this.createLongUrl,
        embed: this.createEmbedUrl
      };
      this.mediaTypes = {
        TRACK: "track",
        PLAYLIST: "playlist",
        APITRACK: "apitrack",
        APIPLAYLIST: "apiplaylist"
      };
    }
    SoundCloud.prototype.parseUrl = function(url, result) {
      var match = url.match(/(?:m\.)?soundcloud\.com\/(?:([\w-]+)\/(sets\/)?)([\w-]+)/i);
      if (!match) {
        return result;
      }
      result.channel = match[1];
      if (match[1] === "playlists" || match[2]) {
        result.list = match[3];
      } else {
        result.id = match[3];
      }
      return result;
    };
    SoundCloud.prototype.parseParameters = function(params) {
      if (params.t) {
        params.start = getTime$6(params.t);
        delete params.t;
      }
      return params;
    };
    SoundCloud.prototype.parseMediaType = function(result) {
      if (result.id) {
        if (result.channel === "tracks") {
          delete result.channel;
          delete result.params.url;
          result.mediaType = this.mediaTypes.APITRACK;
        } else {
          result.mediaType = this.mediaTypes.TRACK;
        }
      }
      if (result.list) {
        if (result.channel === "playlists") {
          delete result.channel;
          delete result.params.url;
          result.mediaType = this.mediaTypes.APIPLAYLIST;
        } else {
          result.mediaType = this.mediaTypes.PLAYLIST;
        }
      }
      return result;
    };
    SoundCloud.prototype.parse = function(url, params) {
      var result = {};
      result = this.parseUrl(url, result);
      result.params = this.parseParameters(params);
      result = this.parseMediaType(result);
      if (!result.id && !result.list) {
        return void 0;
      }
      return result;
    };
    SoundCloud.prototype.createLongUrl = function(vi, params) {
      var url = "";
      var startTime = params.start;
      delete params.start;
      if (vi.mediaType === this.mediaTypes.TRACK && vi.id && vi.channel) {
        url = "https://soundcloud.com/" + vi.channel + "/" + vi.id;
      } else if (vi.mediaType === this.mediaTypes.PLAYLIST && vi.list && vi.channel) {
        url = "https://soundcloud.com/" + vi.channel + "/sets/" + vi.list;
      } else if (vi.mediaType === this.mediaTypes.APITRACK && vi.id) {
        url = "https://api.soundcloud.com/tracks/" + vi.id;
      } else if (vi.mediaType === this.mediaTypes.APIPLAYLIST && vi.list) {
        url = "https://api.soundcloud.com/playlists/" + vi.list;
      } else {
        return void 0;
      }
      url += combineParams$9(params);
      if (startTime) {
        url += "#t=" + startTime;
      }
      return url;
    };
    SoundCloud.prototype.createEmbedUrl = function(vi, params) {
      var url = "https://w.soundcloud.com/player/";
      delete params.start;
      if (vi.mediaType === this.mediaTypes.APITRACK && vi.id) {
        params.url = "https%3A//api.soundcloud.com/tracks/" + vi.id;
      } else if (vi.mediaType === this.mediaTypes.APIPLAYLIST && vi.list) {
        params.url = "https%3A//api.soundcloud.com/playlists/" + vi.list;
      } else {
        return void 0;
      }
      url += combineParams$9(params);
      return url;
    };
    base.bind(new SoundCloud());
    var combineParams$a = util.combineParams;
    function TeacherTube() {
      this.provider = "teachertube";
      this.alternatives = [];
      this.defaultFormat = "long";
      this.formats = {
        "long": this.createLongUrl,
        embed: this.createEmbedUrl
      };
      this.mediaTypes = {
        VIDEO: "video",
        AUDIO: "audio",
        DOCUMENT: "document",
        CHANNEL: "channel",
        COLLECTION: "collection",
        GROUP: "group"
      };
    }
    TeacherTube.prototype.parse = function(url, params) {
      var result = {};
      result.list = this.parsePlaylist(params);
      result.params = params;
      var match = url.match(/\/(audio|video|document|user\/channel|collection|group)\/(?:[\w-]+-)?(\w+)/);
      if (!match) {
        return void 0;
      }
      result.mediaType = this.parseMediaType(match[1]);
      result.id = match[2];
      return result;
    };
    TeacherTube.prototype.parsePlaylist = function(params) {
      if (params["playlist-id"]) {
        var list2 = params["playlist-id"];
        delete params["playlist-id"];
        return list2;
      }
      return void 0;
    };
    TeacherTube.prototype.parseMediaType = function(mediaTypeMatch) {
      switch (mediaTypeMatch) {
        case "audio":
          return this.mediaTypes.AUDIO;
        case "video":
          return this.mediaTypes.VIDEO;
        case "document":
          return this.mediaTypes.DOCUMENT;
        case "user/channel":
          return this.mediaTypes.CHANNEL;
        case "collection":
          return this.mediaTypes.COLLECTION;
        case "group":
          return this.mediaTypes.GROUP;
      }
    };
    TeacherTube.prototype.createLongUrl = function(vi, params) {
      if (!vi.id) {
        return void 0;
      }
      var url = "https://www.teachertube.com/";
      if (vi.list) {
        params["playlist-id"] = vi.list;
      }
      if (vi.mediaType === this.mediaTypes.CHANNEL) {
        url += "user/channel/";
      } else {
        url += vi.mediaType + "/";
      }
      url += vi.id;
      url += combineParams$a(params);
      return url;
    };
    TeacherTube.prototype.createEmbedUrl = function(vi, params) {
      if (!vi.id) {
        return void 0;
      }
      var url = "https://www.teachertube.com/embed/";
      if (vi.mediaType === this.mediaTypes.VIDEO || vi.mediaType === this.mediaTypes.AUDIO) {
        url += vi.mediaType + "/" + vi.id;
      } else {
        return void 0;
      }
      url += combineParams$a(params);
      return url;
    };
    base.bind(new TeacherTube());
    var combineParams$b = util.combineParams;
    function TikTok() {
      this.provider = "tiktok";
      this.defaultFormat = "long";
      this.formats = {
        "long": this.createLongUrl
      };
      this.mediaTypes = {
        VIDEO: "video"
      };
    }
    TikTok.prototype.parse = function(url, params) {
      var result = {
        params,
        mediaType: this.mediaTypes.VIDEO
      };
      var match = url.match(/@([^/]+)\/video\/(\d{19})/);
      if (!match) {
        return;
      }
      result.channel = match[1];
      result.id = match[2];
      return result;
    };
    TikTok.prototype.createLongUrl = function(vi, params) {
      var url = "";
      if (vi.mediaType === this.mediaTypes.VIDEO && vi.id && vi.channel) {
        url += "https://www.tiktok.com/@".concat(vi.channel, "/video/").concat(vi.id);
      } else {
        return void 0;
      }
      url += combineParams$b(params);
      return url;
    };
    base.bind(new TikTok());
    var combineParams$c = util.combineParams;
    function Ted() {
      this.provider = "ted";
      this.formats = {
        "long": this.createLongUrl,
        embed: this.createEmbedUrl
      };
      this.mediaTypes = {
        VIDEO: "video",
        PLAYLIST: "playlist"
      };
    }
    Ted.prototype.parseUrl = function(url, result) {
      var match = url.match(/\/(talks|playlists\/(\d+))\/([\w-]+)/);
      var channel = match ? match[1] : void 0;
      if (!channel) {
        return result;
      }
      result.channel = channel.split("/")[0];
      result.id = match[3];
      if (result.channel === "playlists") {
        result.list = match[2];
      }
      return result;
    };
    Ted.prototype.parseMediaType = function(result) {
      if (result.id && result.channel === "playlists") {
        delete result.channel;
        result.mediaType = this.mediaTypes.PLAYLIST;
      }
      if (result.id && result.channel === "talks") {
        delete result.channel;
        result.mediaType = this.mediaTypes.VIDEO;
      }
      return result;
    };
    Ted.prototype.parse = function(url, params) {
      var result = {
        params
      };
      result = this.parseUrl(url, result);
      result = this.parseMediaType(result);
      if (!result.id) {
        return void 0;
      }
      return result;
    };
    Ted.prototype.createLongUrl = function(vi, params) {
      var url = "";
      if (vi.mediaType === this.mediaTypes.VIDEO && vi.id) {
        url += "https://ted.com/talks/" + vi.id;
      } else if (vi.mediaType === this.mediaTypes.PLAYLIST && vi.id) {
        url += "https://ted.com/playlists/" + vi.list + "/" + vi.id;
      } else {
        return void 0;
      }
      url += combineParams$c(params);
      return url;
    };
    Ted.prototype.createEmbedUrl = function(vi, params) {
      var url = "https://embed.ted.com/";
      if (vi.mediaType === this.mediaTypes.PLAYLIST && vi.id) {
        url += "playlists/" + vi.list + "/" + vi.id;
      } else if (vi.mediaType === this.mediaTypes.VIDEO && vi.id) {
        url += "talks/" + vi.id;
      } else {
        return void 0;
      }
      url += combineParams$c(params);
      return url;
    };
    base.bind(new Ted());
    var lib = base;
    return lib;
  });
})(jsVideoUrlParser);
var urlParser = jsVideoUrlParser.exports;
var convertPasteText = {
  command: "convertPasteText",
  execute: async (editor, text2) => {
    const embedUrl = urlParser.create({
      videoInfo: urlParser.parse(text2),
      format: "embed",
      mediaType: "clip"
    });
    if (embedUrl) {
      const center2 = editor.context.viewport.center;
      const width2 = 300;
      const height2 = 200;
      editor.context.commands.emit("newComponent", "iframe", {
        x: center2[0] - width2 / 2,
        y: center2[1] - height2 / 2,
        width: width2,
        height: height2,
        backgroundColor: "transparent",
        url: embedUrl
      });
    }
  }
};
var __glob_0_32 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": convertPasteText
}, Symbol.toStringTag, { value: "Module" }));
function convertPath(editor, pathString2, rect2 = null) {
  var current = editor.context.selection.current;
  if (current) {
    if (current.is("svg-path", "svg-brush", "svg-textpath")) {
      var d = pathString2;
      if (rect2) {
        var parser = new PathParser(pathString2);
        parser.scale(current.width / rect2.width, current.height / rect2.height);
        d = parser.d;
      }
      editor.context.commands.executeCommand("setAttribute", "set attribute -d", editor.context.selection.packByValue({ d }, current.id));
    } else if (current.clipPath.includes("path")) {
      var d = pathString2;
      if (rect2) {
        var parser = new PathParser(pathString2);
        parser.scale(current.width / rect2.width, current.height / rect2.height);
        d = parser.d;
      }
      editor.context.commands.executeCommand("setAttribute", "change clip path", editor.context.selection.packByValue({ clipPath: `path(${d})` }, current.id));
    }
  }
}
var __glob_0_33 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": convertPath
}, Symbol.toStringTag, { value: "Module" }));
var copy_path = {
  command: "copy.path",
  description: "copy as path for item with path string(d attribute)",
  execute: function(editor) {
    const current = editor.context.selection.current;
    if (current) {
      let newPath = PathParser.fromSVGString(current.d);
      try {
        const newLayerAttrs = current.toSVGPath();
        editor.context.commands.executeCommand("addLayer", `copy path`, editor.createModel(__spreadValues(__spreadValues({
          itemType: "svg-path"
        }, newLayerAttrs), current.updatePath(newPath.d))), true, current.parent);
      } catch (e) {
        console.error(e);
      }
    }
  }
};
var __glob_0_34 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": copy_path
}, Symbol.toStringTag, { value: "Module" }));
var copyTimelineProperty = {
  command: "copyTimelineProperty",
  execute: function(editor, layerId, property, newTime = null) {
    _currentProject(editor, (project2) => {
      project2.copyTimelineKeyframe(layerId, property, newTime);
      editor.emit("refreshTimeline");
    });
  }
};
var __glob_0_35 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": copyTimelineProperty
}, Symbol.toStringTag, { value: "Module" }));
var deleteTimelineKeyframe = {
  command: "deleteTimelineKeyframe",
  execute: function(editor) {
    _currentProject(editor, (project2) => {
      editor.timeline.each((item) => {
        project2.deleteTimelineKeyframe(item.layerId, item.property, item.id);
      });
      editor.timeline.empty();
      editor.emit("refreshTimeline");
      editor.emit("refreshSelectedOffset");
    });
  }
};
var __glob_0_36 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": deleteTimelineKeyframe
}, Symbol.toStringTag, { value: "Module" }));
var doubleclick_item = {
  command: "doubleclick.item",
  execute: function(editor, evt, id) {
    const item = editor.get(id);
    if (editor.context.selection.isOne && item) {
      if (editor.context.selection.checkChildren(item.id)) {
        editor.context.selection.select(item);
        editor.emit(REFRESH_SELECTION);
      } else {
        if (editor.context.selection.check(item)) {
          editor.context.commands.emit("open.editor");
          editor.emit("removeGuideLine");
        } else {
          this.selectInWorldPosition(editor, evt, item);
        }
      }
    } else {
      this.selectInWorldPosition(editor, evt, item);
    }
  },
  selectInWorldPosition: function(editor, evt, item) {
    const point2 = editor.context.viewport.getWorldPosition(evt);
    if (editor.context.selection.hasPoint(point2) || editor.context.selection.hasChildrenPoint(point2)) {
      editor.context.selection.select(item);
      editor.snapManager.clear();
      editor.context.commands.emit("history.refreshSelection");
    }
  }
};
var __glob_0_37 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": doubleclick_item
}, Symbol.toStringTag, { value: "Module" }));
function downloadFile(datauri, filename = "elf.json") {
  var a = document.createElement("a");
  a.href = datauri;
  a.download = filename;
  a.click();
}
var downloadJSON = {
  command: "downloadJSON",
  execute: function(editor, filename) {
    var json = JSON.stringify(editor.context.modelManager.toJSON());
    var datauri = "data:application/json;base64," + window.btoa(unescape(encodeURIComponent(json)));
    downloadFile(datauri, filename || "elf.json");
  }
};
var __glob_0_38 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": downloadJSON
}, Symbol.toStringTag, { value: "Module" }));
var ExportManager = {
  makeProjectStyle(item) {
    const keyframeString = item.toKeyframeString();
    const rootVariable = item.toRootVariableCSS();
    return `
      :root {
        ${CSS_TO_STRING(rootVariable)}
      }
      /* keyframe */
      ${keyframeString}
    `;
  },
  makeStyle(item, appendCSS = "") {
    if (item.is("project")) {
      return this.makeProjectStyle(item);
    }
    const cssString = item.generateView(`[data-id='${item.id}']`, appendCSS);
    return `
    ${cssString}
    ` + item.layers.map((it) => {
      return this.makeStyle(it);
    }).join("");
  },
  makeSvg(project2) {
    const SVGString = project2.toSVGString ? project2.toSVGString() : "";
    return `
      ${SVGString ? `<svg width="0" height="0">${SVGString}</svg>` : ""}
    `;
  },
  generateSVG(editor, rootItem) {
    return editor.replaceLocalUrltoRealUrl(editor.svg.render(rootItem));
  }
};
function createImagePng(img, callback, imageType = "image/png") {
  var canvas = Dom.create("canvas");
  var { width: width2, height: height2 } = img;
  canvas.resize({ width: width2, height: height2 });
  canvas.drawImage(img);
  callback && callback(canvas.toDataURL(imageType));
}
var downloadPNG = {
  command: "downloadPNG",
  execute: function(editor) {
    const item = editor.context.selection.current;
    if (item) {
      const svgString = ExportManager.generateSVG(editor, item).trim();
      const datauri = "data:image/svg+xml;base64," + window.btoa(svgString);
      const filename = item.id;
      loadOriginalImage({ local: datauri }, (info, img) => {
        createImagePng(img, (pngDataUri) => {
          downloadFile(pngDataUri, filename);
        });
      });
    }
  }
};
var __glob_0_39 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": downloadPNG
}, Symbol.toStringTag, { value: "Module" }));
var downloadSVG = {
  command: "downloadSVG",
  execute: function(editor) {
    const item = editor.context.selection.current;
    if (item) {
      var svgString = ExportManager.generateSVG(editor, item).trim();
      var datauri = "data:image/svg+xml;base64," + window.btoa(svgString);
      var filename = item.id;
      downloadFile(datauri, filename);
    }
  }
};
var __glob_0_40 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": downloadSVG
}, Symbol.toStringTag, { value: "Module" }));
var drop_asset = {
  command: "drop.asset",
  execute: async function(editor, obj2, id = null) {
    if (obj2.color) {
      editor.context.commands.emit("addBackgroundColor", obj2.color, id);
    } else if (obj2.gradient) {
      editor.context.commands.emit("addBackgroundImageGradient", obj2.gradient, id);
    } else if (obj2.pattern) {
      editor.context.commands.emit("addBackgroundImagePattern", obj2.pattern, id);
    } else if (obj2.imageUrl) {
      editor.context.commands.emit("addBackgroundImageAsset", obj2.imageUrl, id);
    } else if (obj2.asset) {
      const assetData = await editor.storageManager.getCustomAsset(obj2.asset.id);
      if (assetData) {
        editor.context.commands.emit("addArtBoard", assetData, obj2.asset.center);
      }
    }
    _doForceRefreshSelection(editor);
  }
};
var __glob_0_41 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": drop_asset
}, Symbol.toStringTag, { value: "Module" }));
var dropImageUrl = {
  command: "dropImageUrl",
  execute: function(editor, imageUrl) {
    loadOriginalImage({ local: imageUrl }, (info) => {
      editor.context.commands.emit("addImage", __spreadValues({ src: info.local }, info));
    });
  }
};
var __glob_0_42 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": dropImageUrl
}, Symbol.toStringTag, { value: "Module" }));
var editor_config_body_event$1 = {
  command: "change.bodyEvent",
  description: "fire when bodyEvent was set",
  execute: function(editor) {
    const $target = Dom.create(editor.context.config.get("bodyEvent").target);
    editor.context.config.init("onMouseMovepageContainer", $target);
  }
};
var __glob_0_43 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": editor_config_body_event$1
}, Symbol.toStringTag, { value: "Module" }));
var fileDropItems = {
  command: "fileDropItems",
  execute: function(editor, items = []) {
    editor.context.commands.emit("updateResource", items);
  }
};
var __glob_0_44 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": fileDropItems
}, Symbol.toStringTag, { value: "Module" }));
function second(fps, timecode2) {
  if (isString(timecode2)) {
    var [hour, minute, second2, frame] = timecode2.split(":");
    hour = parseInt(hour, 10);
    minute = parseInt(minute, 10);
    second2 = parseInt(second2, 10);
    frame = parseInt(frame, 10);
    return hour * 3600 + minute * 60 + second2 + frame * (1 / fps);
  } else if (isNumber(timecode2)) {
    return timecode2 / fps;
  }
  return 0;
}
function timecode(fps, seconds) {
  var h = Math.floor(seconds / 3600);
  var m = Math.floor(seconds / 60 % 60);
  var s = Math.floor(seconds % 60);
  var f = Math.round((seconds - Math.floor(seconds)) * fps);
  if (f === fps) {
    f = 0;
    s += 1;
    if (s === 60) {
      m += 1;
      if (m === 60) {
        h += 1;
      }
    }
  }
  return [h, m, s, f].map((t) => {
    return (t + "").padStart(2, "0");
  }).join(":");
}
function framesToTimecode(fps, frames, start2 = null) {
  return timecode(fps, second(fps, frames) - second(fps, start2));
}
function makeTimer(opt) {
  var timer2 = {
    id: 0,
    start: 0,
    speed: opt.speed || 1,
    elapsed: opt.elapsed || 0,
    duration: opt.duration || 0,
    iterationStartCount: 1,
    iterationCount: opt.iterationCount || Number.MAX_SAFE_INTEGER,
    direction: opt.direction || "normal",
    log: [],
    logIndex: 0,
    tick: opt.tick || (() => {
    }),
    startCallback: opt.start || (() => {
    }),
    endCallback: opt.end || (() => {
    }),
    firstCallback: opt.first || (() => {
    }),
    lastCallback: opt.last || (() => {
    })
  };
  const isForward = () => {
    if (timer2.direction === "normal") {
      return true;
    } else if (timer2.direction === "reverse") {
      return false;
    } else if (timer2.direction === "alternate") {
      return timer2.iterationStartCount % 2 === 1;
    } else if (timer2.direction === "alternate-reverse") {
      return timer2.iterationStartCount % 2 === 0;
    }
  };
  const calculateForDirection = (rate) => {
    return isForward() ? rate : 1 - rate;
  };
  const tick = (now) => {
    var isStart = false;
    if (timer2.start === null) {
      timer2.start = now;
      isStart = true;
    }
    const dt = now - timer2.start;
    timer2.elapsed += dt * timer2.speed;
    timer2.start = now;
    if (timer2.elapsed > timer2.duration) {
      timer2.elapsed = timer2.duration;
    }
    var elapsed = calculateForDirection(timer2.elapsed / timer2.duration) * timer2.duration;
    if (isStart)
      timer2.startCallback(elapsed, timer2);
    timer2.log[timer2.logIndex++] = { elapsed, dt: timer2.lastTime - elapsed };
    timer2.lastTime = elapsed;
    timer2.tick(elapsed, timer2);
    if (timer2.elapsed === timer2.duration) {
      end2();
    } else {
      frameStart();
    }
  };
  const frameStart = () => {
    timer2.id = window.requestAnimationFrame(tick);
  };
  const end2 = () => {
    timer2.endCallback(timer2.elapsed, timer2);
    timer2.iterationStartCount++;
    if (timer2.iterationStartCount > timer2.iterationCount) {
      timer2.lastCallback(timer2.elapsed, timer2);
      window.cancelAnimationFrame(timer2.id);
    } else {
      timer2.start = null;
      timer2.elapsed = 0;
      frameStart();
    }
  };
  const play2 = (opt2 = {}) => {
    timer2.start = null;
    timer2.iterationStartCount = 1;
    timer2.log = [];
    timer2.lastTime = 0;
    timer2.logIndex = 0;
    if (isNumber(opt2.elapsed))
      timer2.elapsed = opt2.elapsed;
    if (isNumber(opt2.speed))
      timer2.speed = opt2.speed;
    if (isNumber(opt2.duration))
      timer2.duration = opt2.duration;
    if (isNumber(opt2.iterationCount))
      timer2.iterationCount = opt2.iterationCount || Number.MAX_SAFE_INTEGER;
    if (isString(opt2.direction))
      timer2.direction = opt2.direction;
    if (isFunction(opt2.tick))
      timer2.tick = opt2.tick;
    if (isFunction(opt2.start))
      timer2.startCallback = opt2.start;
    if (isFunction(opt2.end))
      timer2.endCallback = opt2.end;
    if (isFunction(opt2.first))
      timer2.firstCallback = opt2.first;
    if (isFunction(opt2.last))
      timer2.lastCallback = opt2.last;
    if (isFunction(opt2.stop))
      timer2.stopCallback = opt2.stop;
    timer2.firstCallback(timer2.elapsed, timer2);
    frameStart();
  };
  const stop = () => {
    timer2.stopCallback(timer2.elapsed, timer2);
    window.cancelAnimationFrame(timer2.id);
  };
  const seek = (t) => {
    timer2.elapsed = t;
    timer2.tick(timer2.elapsed, timer2);
  };
  const first = () => {
    seek(0);
  };
  const last = () => {
    seek(timer2.duration);
  };
  return {
    play: play2,
    stop,
    tick,
    first,
    last,
    seek,
    timer: timer2
  };
}
var firstTimelineItem = {
  command: "firstTimelineItem",
  execute: function(editor) {
    _currentProject(editor, (project2, timeline) => {
      var firstTime = project2.getSelectedTimelineFirstTime();
      project2.setTimelineCurrentTime(timecode(timeline.fps, firstTime));
      project2.seek();
      editor.emit("playTimeline");
    });
  }
};
var __glob_0_45 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": firstTimelineItem
}, Symbol.toStringTag, { value: "Module" }));
var group_item = {
  command: "group.item",
  execute: function(editor, opt = {}) {
    if (editor.context.selection.length === 0)
      return;
    const project2 = editor.context.selection.currentProject;
    if (project2) {
      project2.generateListNumber();
      const list2 = editor.context.selection.map((item) => {
        return { depth: item.depth, item };
      });
      list2.sort((a, b) => {
        if (a.depth === b.depth) {
          return a.no > b.no ? -1 : 1;
        }
        return a.depth > b.depth ? 1 : -1;
      });
      const groupLayer = editor.createModel(__spreadValues(__spreadValues({
        itemType: "rect"
      }, editor.context.selection.itemRect), opt));
      list2[0].item.insertAfter(groupLayer);
      list2.forEach(({ item }) => {
        groupLayer.appendChild(item);
      });
      editor.context.selection.select(groupLayer);
      editor.emit("refreshAll");
    }
  }
};
var __glob_0_46 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": group_item
}, Symbol.toStringTag, { value: "Module" }));
var history_addLayer = {
  command: "history.addLayer",
  description: "add layer in history ",
  execute: function(editor, message, layer, isSelected = true, containerItem) {
    editor.context.commands.emit("addLayer", layer, isSelected, containerItem);
    editor.nextTick(() => {
      editor.context.history.add(message, this, {
        currentValues: [layer, isSelected, containerItem],
        undoValues: [layer.id]
      });
    });
    editor.nextTick(() => {
      editor.context.history.saveSelection();
    });
  },
  redo: function(editor, { currentValues }) {
    editor.context.commands.emit("addLayer", ...currentValues);
    editor.nextTick(() => {
      editor.emit("refreshAll");
    });
  },
  undo: function(editor, { undoValues }) {
    const ids = undoValues;
    const items = editor.context.selection.itemsByIds(ids);
    items.forEach((item) => {
      if (item) {
        item.remove();
      }
    });
    editor.nextTick(() => {
      editor.context.selection.empty();
      editor.emit("refreshAll");
    });
  }
};
var __glob_0_47 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": history_addLayer
}, Symbol.toStringTag, { value: "Module" }));
var history_bring_forward = {
  command: "history.bring.forward",
  description: "bring forward",
  execute: function(editor, message, layer = editor.context.selection.current) {
    const currentLayer = editor.get(layer);
    const lastValues = currentLayer.hierarchy;
    const oldParentLayer = currentLayer.parent;
    let currentValues = {};
    let nextParentLayer = null;
    if (currentLayer.isLast) {
      nextParentLayer = oldParentLayer.next;
      if (nextParentLayer.enableHasChildren()) {
        nextParentLayer.appendChild(currentLayer);
        currentValues = currentLayer.hierarchy;
      } else {
        nextParentLayer.insertAfter(currentLayer);
        currentValues = currentLayer.hierarchy;
      }
    } else {
      currentLayer.parent.bringForward(currentLayer.id);
      currentValues = currentLayer.hierarchy;
    }
    editor.context.commands.emit("setAttribute", __spreadValues(__spreadValues(__spreadValues({}, oldParentLayer.attrsWithId("children")), currentLayer.attrsWithId("x", "y", "angle")), currentLayer.parent.attrsWithId("children")));
    editor.nextTick(() => {
      editor.context.history.add(message, this, {
        currentValues: [currentValues],
        undoValues: [lastValues]
      });
    });
    editor.nextTick(() => {
      editor.context.history.saveSelection();
    });
  },
  redo: function(editor, { currentValues: [newValues], undoValues: [lastValues] }) {
    const currentLayer = editor.get(newValues.id);
    const currentTarget = editor.get(newValues.parentId);
    const lastParent = editor.get(lastValues.parentId);
    currentTarget.insertChild(currentLayer, newValues.index);
    currentLayer.reset(newValues.attrs);
    editor.context.commands.emit("setAttribute", __spreadValues(__spreadValues(__spreadValues({}, lastParent.attrsWithId("children")), currentLayer.attrsWithId("x", "y", "angle")), currentTarget.attrsWithId("children")));
  },
  undo: function(editor, { currentValues: [newValues], undoValues: [lastValues] }) {
    const currentLayer = lastValues;
    const lastLayer = editor.get(currentLayer.id);
    const lastParent = editor.get(currentLayer.parentId);
    const currentParent = editor.get(newValues.parentId);
    const lastIndex = currentLayer.index;
    lastParent.insertChild(lastLayer, lastIndex);
    lastLayer.reset(lastValues.attrs);
    editor.context.commands.emit("setAttribute", __spreadValues(__spreadValues(__spreadValues({}, lastLayer.attrsWithId("x", "y", "angle")), lastParent.attrsWithId("children")), currentParent.attrsWithId("children")));
  }
};
var __glob_0_48 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": history_bring_forward
}, Symbol.toStringTag, { value: "Module" }));
var history_bring_front = {
  command: "history.bring.front",
  description: "bring front",
  execute: function(editor, message, layer = editor.context.selection.current) {
    const currentLayer = editor.get(layer);
    const lastValues = currentLayer.hierachy;
    const oldParentLayer = currentLayer.parent;
    let currentValues = {};
    if (currentLayer.isLast) {
      return;
    } else {
      currentLayer.parent.bringFront(currentLayer.id);
      currentValues = currentLayer.hierarchy;
    }
    editor.context.commands.emit("setAttribute", __spreadValues(__spreadValues({}, oldParentLayer.attrsWithId("children")), currentLayer.attrsWithId("x", "y", "angle")));
    editor.nextTick(() => {
      editor.context.history.add(message, this, {
        currentValues: [currentValues],
        undoValues: [lastValues]
      });
    });
    editor.nextTick(() => {
      editor.context.history.saveSelection();
    });
  },
  redo: function(editor, { currentValues: [newValues] }) {
    const currentLayer = editor.get(newValues.id);
    const currentTarget = editor.get(newValues.parentId);
    currentTarget.insertChild(currentLayer, newValues.index);
    currentLayer.reset(newValues.attrs);
    editor.context.commands.emit("setAttribute", __spreadValues(__spreadValues({}, currentLayer.attrsWithId("x", "y", "angle")), currentTarget.attrsWithId("children")));
  },
  undo: function(editor, { undoValues: [lastValues] }) {
    const currentLayer = lastValues;
    const lastLayer = editor.get(currentLayer.id);
    const lastParent = editor.get(currentLayer.parentId);
    const lastIndex = currentLayer.index;
    lastParent.insertChild(lastLayer, lastIndex);
    editor.context.commands.emit("setAttribute", __spreadValues(__spreadValues({}, lastLayer.attrsWithId("x", "y", "angle")), lastParent.attrsWithId("children")));
  }
};
var __glob_0_49 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": history_bring_front
}, Symbol.toStringTag, { value: "Module" }));
var history_clipboard_paste = {
  command: "history.clipboard.paste",
  description: "paste in clipboard ",
  description_ko: ["\uD074\uB9BD\uBCF4\uB4DC \uB370\uC774\uD0C0\uB97C \uAE30\uC900\uC73C\uB85C paste \uB97C \uC801\uC6A9\uD55C\uB2E4. "],
  execute: async function(editor, message, clipboardData = void 0, hasHistory = true) {
    const data = clipboardData || editor.context.clipboard.last;
    if (data.type == ClipboardActionType.COPY) {
      const ids = data.data;
      const items = await editor.json.renderAll(ids.map((it) => editor.get(it)));
      const newIds = [];
      const itemList = {};
      const parentList = {};
      let updateData = {};
      items.forEach((itemJSON) => {
        const referenceId = itemJSON.referenceId;
        const sourceItem = editor.get(referenceId);
        parentList[sourceItem.parentId] = sourceItem.parent;
        const model = editor.createModel(itemJSON);
        model.renameWithCount();
        model.absoluteMove([
          10 / editor.context.viewport.scale,
          10 / editor.context.viewport.scale,
          0
        ]);
        sourceItem.insertAfter(model);
        newIds.push(model.id);
        itemList[model.id] = itemJSON;
        updateData[model.id] = model.toCloneObject();
      });
      Object.values(parentList).forEach((parent) => {
        updateData = __spreadValues(__spreadValues({}, updateData), parent.attrsWithId("children"));
      });
      editor.context.commands.emit("setAttribute", updateData);
      editor.nextTick(() => {
        editor.context.selection.select(...newIds);
        if (hasHistory) {
          editor.context.history.add(message, this, {
            currentValues: [data],
            undoValues: [newIds, editor.context.selection.ids]
          });
        }
        editor.context.history.saveSelection();
        editor.emit(REFRESH_SELECTION);
      });
    }
  },
  redo: function(editor, { currentValues: [data] }) {
    editor.context.commands.emit("history.clipboard.paste", "paste", data, false);
  },
  undo: function(editor, { currentValues: [data], undoValues: [newIds, selectedIds] }) {
    if (data.type === ClipboardActionType.COPY) {
      const parentList = {};
      newIds.forEach((id) => {
        const item = editor.get(id);
        parentList[item.parentId] = item.parent;
        if (item) {
          item.remove();
        }
      });
      let updateData = {};
      Object.values(parentList).forEach((parent) => {
        updateData = __spreadValues(__spreadValues({}, updateData), parent.attrsWithId("children"));
      });
      editor.context.selection.select(...selectedIds);
      editor.context.commands.emit("setAttribute", updateData);
    }
  }
};
var __glob_0_50 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": history_clipboard_paste
}, Symbol.toStringTag, { value: "Module" }));
var history_group_item = {
  command: "history.group.item",
  description: "History Group Item",
  execute: function(editor, message = "selection") {
    var _a;
    const currentValues = editor.context.selection.ids;
    const projectId = (_a = editor.context.selection.currentProject) == null ? void 0 : _a.id;
    const undoValues = editor.context.history.selectedIds;
    if (isArrayEquals(currentValues, undoValues)) {
      return;
    }
    editor.context.history.add(message, this, {
      currentValues: {
        ids: currentValues,
        projectId
      },
      undoValues: {
        ids: undoValues,
        projectId
      }
    });
  },
  redo: function(editor, { currentValues: [ids, projectId] }) {
  },
  undo: function(editor, { undoValues: [ids, projectId] }) {
  }
};
var __glob_0_51 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": history_group_item
}, Symbol.toStringTag, { value: "Module" }));
var history_moveLayer = {
  command: "history.moveLayer",
  description: "move layer in world ",
  execute: function(editor, message, layers2 = [], dist2 = [0, 0, 0]) {
    if (isArray(layers2) === false) {
      layers2 = [layers2];
    }
    const targetItems = editor.context.selection.itemsByIds(layers2);
    const lastValues = {};
    const currentValues = {};
    targetItems.forEach((it) => {
      const oldPosition = it.absoluteMove(dist2);
      const newPosition = it.attrs("x", "y");
      lastValues[it.id] = oldPosition;
      currentValues[it.id] = newPosition;
    });
    editor.context.commands.emit("setAttribute", currentValues);
    editor.nextTick(() => {
      editor.context.history.add(message, this, {
        currentValues: [layers2, dist2],
        undoValues: [lastValues]
      });
    });
    editor.nextTick(() => {
      editor.context.history.saveSelection();
    });
  },
  redo: function(editor, { currentValues: [layers2, dist2] }) {
    const targetItems = editor.context.selection.itemsByIds(layers2);
    const localChanges = {};
    targetItems.forEach((it) => {
      it.absoluteMove(dist2);
      const newPosition = it.attrs("x", "y");
      localChanges[it.id] = newPosition;
    });
    editor.context.commands.emit("setAttribute", localChanges);
  },
  undo: function(editor, { undoValues: [lastValues] }) {
    editor.context.commands.emit("setAttribute", lastValues);
  }
};
var __glob_0_52 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": history_moveLayer
}, Symbol.toStringTag, { value: "Module" }));
var history_moveLayerToTarget = {
  command: "history.moveLayerToTarget",
  description: "move layer to target in world ",
  execute: function(editor, message, layer, target, dist2 = [0, 0, 0], targetAction = TargetActionType.APPEND_CHILD) {
    const currentLayer = editor.get(layer) || layer;
    const currentParentLayer = currentLayer.parent;
    const currentTarget = editor.get(target);
    const lastValues = currentLayer.hierachy;
    if (dist2) {
      currentLayer.absoluteMove(dist2);
    }
    let currentValues = {};
    if (targetAction === TargetActionType.APPEND_CHILD) {
      currentTarget.appendChild(currentLayer);
      currentValues = currentTarget.attrsWithId("children");
    } else if (targetAction === TargetActionType.INSERT_BEFORE) {
      currentTarget.insertBefore(currentLayer);
      currentValues = currentTarget.parent.attrsWithId("children");
    } else if (targetAction === TargetActionType.INSERT_AFTER) {
      currentTarget.insertAfter(currentLayer);
      currentValues = currentTarget.parent.attrsWithId("children");
    }
    editor.context.commands.emit("setAttribute", __spreadValues(__spreadValues(__spreadValues({}, currentLayer.attrsWithId("x", "y", "angle", "parentId")), currentValues), currentParentLayer && currentParentLayer.isNot("project") ? currentParentLayer.attrsWithId("children") : {}));
    editor.nextTick(() => {
      editor.context.history.add(message, this, {
        currentValues: [currentLayer.hierachy],
        undoValues: [lastValues, currentLayer.parentId]
      });
    });
    editor.nextTick(() => {
      editor.context.history.saveSelection();
    });
  },
  redo: function(editor, { currentValues: [info] }) {
    const currentLayer = editor.get(info.id);
    const currentTarget = editor.get(info.parentId);
    currentTarget.insertChild(currentLayer, info.index);
    currentLayer.reset(info.attrs);
    editor.context.commands.emit("setAttribute", __spreadValues(__spreadValues({}, currentLayer.attrsWithId("x", "y", "angle", "parentId")), currentTarget.attrsWithId("children")));
  },
  undo: function(editor, { undoValues: [lastValues, currentParentId] }) {
    const currentLayer = lastValues;
    const lastLayer = editor.get(currentLayer.id);
    const lastParent = editor.get(currentLayer.parentId);
    const currentParent = editor.get(currentParentId);
    const lastIndex = currentLayer.index;
    lastParent.insertChild(lastLayer, lastIndex);
    lastLayer.reset(lastValues.attrs);
    editor.context.commands.emit("setAttribute", __spreadValues(__spreadValues(__spreadValues({}, lastLayer.attrsWithId("x", "y", "angle")), lastParent.attrsWithId("children")), currentParent.attrsWithId("children")));
  }
};
var __glob_0_53 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": history_moveLayerToTarget
}, Symbol.toStringTag, { value: "Module" }));
var history_refreshSelection = {
  command: "history.refreshSelection",
  description: `save selection in history `,
  description_ko: "Selection \uC815\uBCF4\uB97C \uAC31\uC2E0\uD558\uBA74\uC11C History \uC5D0 \uC800\uC7A5\uD55C\uB2E4",
  execute: function(editor, message = "selection") {
    var _a;
    const currentValues = editor.context.selection.ids;
    const projectId = (_a = editor.context.selection.currentProject) == null ? void 0 : _a.id;
    const undoValues = editor.context.history.selectedIds;
    if (isArrayEquals(currentValues, undoValues)) {
      return;
    }
    editor.context.history.add(message, this, {
      currentValues: [currentValues, projectId],
      undoValues: [undoValues, projectId]
    });
    this.nextAction(editor);
  },
  nextAction(editor) {
    editor.nextTick(() => {
      editor.context.history.saveSelection();
      editor.emit(REFRESH_SELECTION);
    });
  },
  redo: function(editor, { currentValues: [ids, projectId] }) {
    editor.context.selection.selectProject(projectId);
    editor.context.selection.select(...ids);
    this.nextAction(editor);
  },
  undo: function(editor, { undoValues: [ids, projectId] }) {
    editor.context.selection.selectProject(projectId);
    editor.context.selection.select(...ids);
    this.nextAction(editor);
  }
};
var __glob_0_54 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": history_refreshSelection
}, Symbol.toStringTag, { value: "Module" }));
var history_refreshSelectionProject = {
  command: "history.refreshSelectionPorject",
  description: `save project selection in history `,
  description_ko: "Project Selection \uC815\uBCF4\uB97C \uAC31\uC2E0\uD558\uBA74\uC11C History \uC5D0 \uC800\uC7A5\uD55C\uB2E4",
  execute: function(editor, message = "selection", projectId) {
    var _a;
    const currentValues = [projectId];
    const undoValues = [(_a = editor.context.selection.currentProject) == null ? void 0 : _a.id];
    if (isArrayEquals(currentValues, undoValues)) {
      return;
    }
    editor.context.selection.selectProject(projectId);
    editor.context.history.add(message, this, {
      currentValues,
      undoValues
    });
    this.nextAction(editor);
  },
  nextAction(editor) {
    editor.nextTick(() => {
      editor.emit("refreshAll");
      editor.emit("refreshProjectList");
    });
  },
  redo: function(editor, { currentValues: [projectId] }) {
    editor.context.selection.selectProject(projectId);
    this.nextAction(editor);
  },
  undo: function(editor, { undoValues: [projectId] }) {
    editor.context.selection.selectProject(projectId);
    this.nextAction(editor);
  }
};
var __glob_0_55 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": history_refreshSelectionProject
}, Symbol.toStringTag, { value: "Module" }));
function filterChildren(items = []) {
  return items.filter((item) => {
    let total = 0;
    item.path.forEach((treeItem) => {
      total += items.filter((it) => it.id === treeItem.id).length ? 1 : 0;
    });
    return total === 1;
  });
}
var history_removeLayer = {
  command: "history.removeLayer",
  description: "remove layer",
  execute: function(editor, message, ids = void 0) {
    let items = editor.context.selection.itemsByIds(ids || editor.context.selection.ids);
    items = filterChildren(items);
    const filtedIds = items.map((it) => it.id);
    editor.context.modelManager.markRemove(filtedIds);
    const parentIds = items.map((it) => it.parentId);
    items.forEach((item) => {
      item.remove();
      editor.context.selection.removeById(item.id);
    });
    editor.context.history.add(message, this, {
      currentValues: [filtedIds, parentIds],
      undoValues: filtedIds
    });
    editor.nextTick(() => {
      editor.context.selection.removeById(filtedIds);
      parentIds.forEach((parentId) => {
        editor.context.commands.emit("update", parentId, {
          changedChildren: true
        });
      });
      editor.emit("refreshAll");
      editor.emit("removeGuideLine");
      editor.nextTick(() => {
        editor.context.history.saveSelection();
      });
    });
  },
  redo: function(editor, { currentValues }) {
    const ids = currentValues[0];
    let items = editor.context.selection.itemsByIds(ids || editor.context.selection.ids);
    items = filterChildren(items);
    editor.context.modelManager.markRemove(items.map((it) => it.id));
    items.forEach((item) => item.remove());
    editor.nextTick(() => {
      editor.emit("refreshAll");
    });
  },
  undo: function(editor, { undoValues: recoverIds }) {
    editor.context.modelManager.unmarkRemove(recoverIds);
    editor.nextTick(() => {
      editor.emit("refreshAll");
    });
  }
};
var __glob_0_56 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": history_removeLayer
}, Symbol.toStringTag, { value: "Module" }));
var history_removeProject = {
  command: "history.removeProject",
  description: "remove project",
  execute: function(editor, message, projectId) {
    const index2 = editor.context.modelManager.markRemoveProject(projectId);
    editor.context.history.add(message, this, {
      currentValues: [projectId],
      undoValues: [projectId, index2]
    });
    editor.nextTick(() => {
      editor.context.selection.selectProject(editor.context.modelManager.projects[0]);
      editor.emit("refreshAll");
      editor.emit("removeGuideLine");
      editor.nextTick(() => {
        editor.context.history.saveSelection();
      });
    });
  },
  redo: function(editor, { currentValues: [projectId] }) {
    editor.context.modelManager.markRemoveProject(projectId);
    editor.nextTick(() => {
      editor.emit("refreshAll");
    });
  },
  undo: function(editor, { undoValues: [projectId, index2] }) {
    editor.context.modelManager.unmarkRemoveProject(projectId, index2);
    editor.nextTick(() => {
      editor.context.selection.selectProject(projectId);
      editor.emit("refreshAll");
    });
  }
};
var __glob_0_57 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": history_removeProject
}, Symbol.toStringTag, { value: "Module" }));
var history_send_back = {
  command: "history.send.back",
  description: "send back",
  execute: function(editor, message, layer = editor.context.selection.current) {
    const currentLayer = editor.get(layer);
    const lastValues = currentLayer.hierarchy;
    const oldParentLayer = currentLayer.parent;
    let currentValues = {};
    if (currentLayer.isFirst()) {
      return;
    } else {
      currentLayer.parent.sendBack(currentLayer.id);
      currentValues = currentLayer.hierarchy;
    }
    editor.context.commands.emit("setAttribute", __spreadValues(__spreadValues({}, oldParentLayer.attrsWithId("children")), currentLayer.attrsWithId("x", "y", "angle", "parentId")));
    editor.nextTick(() => {
      editor.context.history.add(message, this, {
        currentValues: [currentValues],
        undoValues: [lastValues]
      });
    });
    editor.nextTick(() => {
      editor.context.history.saveSelection();
    });
  },
  redo: function(editor, { currentValues: [newValues] }) {
    const currentLayer = editor.get(newValues.id);
    const currentTarget = editor.get(newValues.parentId);
    currentTarget.insertChild(currentLayer, newValues.index);
    currentLayer.reset(newValues.attrs);
    editor.context.commands.emit("setAttribute", __spreadValues(__spreadValues({}, currentLayer.attrsWithId("x", "y", "angle", "parentId")), currentTarget.attrsWithId("children")));
  },
  undo: function(editor, { undoValues: [lastValues] }) {
    const currentLayer = lastValues;
    const lastLayer = editor.get(currentLayer.id);
    const lastParent = editor.get(currentLayer.parentId);
    const lastIndex = currentLayer.index;
    lastParent.insertChild(lastLayer, lastIndex);
    editor.context.commands.emit("setAttribute", __spreadValues(__spreadValues({}, lastLayer.attrsWithId("x", "y", "angle", "parentId")), lastParent.attrsWithId("children")));
  }
};
var __glob_0_58 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": history_send_back
}, Symbol.toStringTag, { value: "Module" }));
var history_send_backward = {
  command: "history.send.backward",
  description: "send backward",
  execute: function(editor, message, layer = editor.context.selection.current) {
    const currentLayer = editor.get(layer);
    const lastValues = currentLayer.hierarchy;
    const oldParentLayer = currentLayer.parent;
    let currentValues = {};
    let prevParentLayer = null;
    if (currentLayer.isFirst()) {
      prevParentLayer = oldParentLayer.prev;
      prevParentLayer.insertBefore(currentLayer);
      currentValues = currentLayer.hierarchy;
    } else {
      currentLayer.parent.sendBackward(currentLayer.id);
      currentValues = currentLayer.hierarchy;
    }
    editor.context.commands.emit("setAttribute", __spreadValues(__spreadValues(__spreadValues({}, oldParentLayer.attrsWithId("children")), currentLayer.attrsWithId("x", "y", "angle", "parentId")), currentLayer.parent.attrsWithId("children")));
    editor.nextTick(() => {
      editor.context.history.add(message, this, {
        currentValues: [currentValues],
        undoValues: [lastValues]
      });
    });
    editor.nextTick(() => {
      editor.context.history.saveSelection();
    });
  },
  redo: function(editor, { currentValues: [newValues], undoValues: [lastValues] }) {
    const currentLayer = editor.get(newValues.id);
    const currentTarget = editor.get(newValues.parentId);
    const lastParent = editor.get(lastValues.parentId);
    currentTarget.insertChild(currentLayer, newValues.index);
    currentLayer.reset(newValues.attrs);
    editor.context.commands.emit("setAttribute", __spreadValues(__spreadValues(__spreadValues({}, lastParent.attrsWithId("children")), currentLayer.attrsWithId("x", "y", "angle", "parentId")), currentTarget.attrsWithId("children")));
  },
  undo: function(editor, { currentValues: [newValues], undoValues: [lastValues] }) {
    const currentLayer = lastValues;
    const lastLayer = editor.get(currentLayer.id);
    const lastParent = editor.get(currentLayer.parentId);
    const currentParent = editor.get(newValues.parentId);
    const lastIndex = currentLayer.index;
    lastParent.insertChild(lastLayer, lastIndex);
    lastLayer.reset(lastValues.attrs);
    editor.context.commands.emit("setAttribute", __spreadValues(__spreadValues(__spreadValues({}, lastLayer.attrsWithId("x", "y", "angle")), lastParent.attrsWithId("children")), currentParent.attrsWithId("children")));
  }
};
var __glob_0_59 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": history_send_backward
}, Symbol.toStringTag, { value: "Module" }));
var history_setAttribute = {
  command: "history.setAttribute",
  execute: function(editor, message, multiAttrs = {}, context = { origin: "*" }) {
    editor.context.commands.emit("setAttribute", multiAttrs, context);
    editor.context.history.add(message, this, {
      currentValues: [multiAttrs],
      undoValues: editor.context.history.getUndoValues(multiAttrs)
    });
    editor.nextTick(() => {
      editor.context.history.saveSelection();
    });
  },
  redo: function(editor, { currentValues }) {
    editor.context.commands.emit("setAttribute", ...currentValues);
    editor.nextTick(() => {
      editor.context.selection.reselect();
      editor.emit("refreshAll");
    });
  },
  undo: function(editor, { undoValues }) {
    const ids = Object.keys(undoValues);
    const items = editor.context.selection.itemsByIds(ids);
    items.forEach((item) => {
      item.reset(undoValues[item.id]);
    });
    editor.context.selection.reselect();
    editor.nextTick(() => {
      editor.emit("refreshAll");
    });
  }
};
var __glob_0_60 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": history_setAttribute
}, Symbol.toStringTag, { value: "Module" }));
var item_move_depth_down = {
  command: "item.move.depth.down",
  execute: function(editor) {
    const current = editor.context.selection.current;
    if (current) {
      current.orderPrev();
    }
    _doForceRefreshSelection(editor);
  }
};
var __glob_0_61 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": item_move_depth_down
}, Symbol.toStringTag, { value: "Module" }));
var item_move_depth_first = {
  command: "item.move.depth.first",
  execute: function(editor) {
    const current = editor.context.selection.current;
    if (current) {
      current.orderFirst();
    }
    _doForceRefreshSelection(editor);
  }
};
var __glob_0_62 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": item_move_depth_first
}, Symbol.toStringTag, { value: "Module" }));
var item_move_depth_last = {
  command: "item.move.depth.last",
  execute: function(editor) {
    const current = editor.context.selection.current;
    if (current) {
      current.orderLast();
    }
    _doForceRefreshSelection(editor);
  }
};
var __glob_0_63 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": item_move_depth_last
}, Symbol.toStringTag, { value: "Module" }));
var item_move_depth_up = {
  command: "item.move.depth.up",
  execute: function(editor) {
    const current = editor.context.selection.current;
    if (current) {
      current.orderNext();
    }
    _doForceRefreshSelection(editor);
  }
};
var __glob_0_64 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": item_move_depth_up
}, Symbol.toStringTag, { value: "Module" }));
var keymap_keydown = {
  command: "keymap.keydown",
  execute: function(editor, e) {
    editor.context.keyboardManager.add(e.code, e.keyCode, e);
    if (editor.context.shortcuts) {
      editor.context.shortcuts.execute(e, "keydown");
    }
  }
};
var __glob_0_65 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": keymap_keydown
}, Symbol.toStringTag, { value: "Module" }));
var lastTimelineItem = {
  command: "lastTimelineItem",
  execute: function(editor) {
    _currentProject(editor, (project2, timeline) => {
      var lastTime = project2.getSelectedTimelineLastTime();
      project2.setTimelineCurrentTime(timecode(timeline.fps, lastTime));
      project2.seek();
      editor.emit("playTimeline");
    });
  }
};
var __glob_0_66 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": lastTimelineItem
}, Symbol.toStringTag, { value: "Module" }));
var load_json = {
  command: "load.json",
  execute: function(editor, json, context = { origin: "*" }) {
    editor.context.modelManager.load(json, context);
    _doForceRefreshSelection(editor);
  }
};
var __glob_0_67 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": load_json
}, Symbol.toStringTag, { value: "Module" }));
var moveLayer = {
  command: "moveLayer",
  description: "move layer by keydown with matrix ",
  execute: function(editor, dx = 0, dy = 0) {
    const absoluteDist = [dx, dy, 0];
    editor.context.selection.items.forEach((it) => {
      it.absoluteMove(absoluteDist);
    });
    editor.context.commands.executeCommand("setAttribute", "item move down", editor.context.selection.pack("x", "y"));
    editor.nextTick(() => {
      editor.context.selection.reselect();
    });
  }
};
var __glob_0_68 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": moveLayer
}, Symbol.toStringTag, { value: "Module" }));
var moveLayerForItems = {
  command: "moveLayerForItems",
  description: "mova layer by multi items ",
  execute: function(editor, moveItems = []) {
    const itemsMap = {};
    moveItems.forEach((it) => {
      it.item.absoluteMove(it.dist);
      itemsMap[it.item.id] = it.item.attrs("x", "y");
    });
    editor.context.commands.emit("history.setAttribute", "item move", itemsMap);
    editor.nextTick(() => {
      editor.context.selection.reselect();
    });
  }
};
var __glob_0_69 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": moveLayerForItems
}, Symbol.toStringTag, { value: "Module" }));
var moveSelectionToCenter = {
  command: "moveSelectionToCenter",
  description: "Move selection project or artboards to center on Viewport",
  execute: function(editor, withScale = true) {
    var _a, _b, _c, _d, _e;
    let areaVerties = [];
    if ((_a = editor.context.selection) == null ? void 0 : _a.isEmpty) {
      if (((_c = (_b = editor.context.selection) == null ? void 0 : _b.currentProject) == null ? void 0 : _c.layers.length) > 0) {
        areaVerties = itemsToRectVerties((_d = editor.context.selection) == null ? void 0 : _d.currentProject.layers);
      } else {
        areaVerties = rectToVerties(0, 0, 100, 100);
      }
    } else {
      areaVerties = itemsToRectVerties((_e = editor.context.selection) == null ? void 0 : _e.items);
    }
    editor.context.commands.emit("moveToCenter", areaVerties, withScale);
  }
};
var __glob_0_70 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": moveSelectionToCenter
}, Symbol.toStringTag, { value: "Module" }));
function newComponent(editor, itemType, obj2, isSelected = true, containerItem = void 0) {
  if (itemType === "svg-textpath") {
    obj2 = __spreadProps(__spreadValues({}, obj2), {
      fontSize: obj2.height,
      textLength: "100%",
      d: PathParser.makeLine(0, obj2.height, obj2.width, obj2.height).d
    });
  } else if (itemType === "svg-circle") {
    itemType = "svg-path";
    obj2 = __spreadProps(__spreadValues({}, obj2), {
      backgroundColor: void 0,
      fill: `#C4C4C4`,
      d: PathParser.makeCircle(0, 0, obj2.width, obj2.height).d
    });
  } else if (itemType === "svg-rect") {
    itemType = "svg-path";
    obj2 = __spreadProps(__spreadValues({}, obj2), {
      backgroundColor: void 0,
      fill: `#C4C4C4`,
      d: PathParser.makeRect(0, 0, obj2.width, obj2.height).d
    });
  } else if (itemType === "text") {
    obj2 = __spreadValues({
      width: 300,
      height: 50
    }, obj2);
  } else if (itemType === "artboard") {
    obj2 = __spreadProps(__spreadValues({}, obj2), {
      backgroundColor: "white"
    });
  }
  const newObjAttrs = __spreadValues({ itemType }, obj2);
  const item = editor.createModel(newObjAttrs);
  editor.context.commands.executeCommand("moveLayerToTarget", `add layer - ${itemType}`, item, containerItem);
  editor.nextTick(() => {
    editor.emit("appendLayer", item);
    if (isSelected) {
      editor.context.selection.select(item);
      editor.emit(REFRESH_SELECTION);
    }
  });
}
var __glob_0_71 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": newComponent
}, Symbol.toStringTag, { value: "Module" }));
var nextTimelineItem = {
  command: "nextTimelineItem",
  execute: function(editor) {
    _currentProject(editor, (project2, timeline) => {
      var nextTime = project2.getSelectedTimelineNextTime();
      project2.setTimelineCurrentTime(timecode(timeline.fps, nextTime));
      project2.seek();
      editor.emit("playTimeline");
    });
  }
};
var __glob_0_72 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": nextTimelineItem
}, Symbol.toStringTag, { value: "Module" }));
var open_editor = {
  command: "open.editor",
  description: "Open custom editor for item  when doubleclick is fired",
  execute: function(editor, current) {
    if (!current && editor.context.selection.isOne === false)
      return;
    current = current || editor.context.selection.current;
    if (current) {
      if (current.editablePath) {
        editor.emit("showPathEditor", "modify", {
          box: "canvas",
          current,
          matrix: current.matrix,
          isControl: true,
          disableCurve: true,
          d: current.editablePath,
          changeEvent: (data) => {
            editor.context.commands.executeCommand("setAttribute", "change editable path", editor.context.selection.packByValue(__spreadValues({}, current.recoverEditablePath(data.d)), [current.id]));
            editor.nextTick(() => {
              if (editor.context.stateManager.isPointerUp) {
                editor.context.commands.emit("recoverBooleanPath");
              }
            });
          }
        });
        editor.emit("hideSelectionToolView");
      } else if (current.d) {
        editor.emit("showPathEditor", "modify", {
          box: "canvas",
          current,
          matrix: current.matrix,
          d: current.absolutePath().d,
          changeEvent: (data) => {
            const newCurrent = editor.context.selection.current;
            if (newCurrent.isSVG() && newCurrent.isNot("svg-path")) {
              const newPathData = newCurrent.toSVGPath();
              const newPath = editor.createModel(__spreadValues({
                itemType: "svg-path"
              }, newPathData));
              editor.context.selection.select(newPath);
              newCurrent.insertAfter(newPath);
              editor.nextTick(() => {
                editor.context.commands.emit("removeLayer", [newCurrent.id]);
                editor.context.commands.emit("updatePathItem", data);
              });
            } else {
              editor.context.commands.emit("updatePathItem", data);
              editor.nextTick(() => {
                if (editor.context.stateManager.isPointerUp) {
                  editor.context.commands.emit("recoverBooleanPath");
                }
              });
            }
          }
        });
        editor.emit("hideSelectionToolView");
      } else if (current.clipPath) {
        var obj2 = ClipPath.parseStyle(current.clipPath);
        if (obj2.type === "path") {
          var d = current.absolutePath(current.clipPathString).d;
          var mode = d ? "modify" : "path";
          editor.emit("showPathEditor", mode, {
            changeEvent: (data) => {
              const resultPath = current.invertPath(data.d).d;
              editor.context.commands.executeCommand("setAttribute", "change clip-path", editor.context.selection.packByValue({
                clipPath: `path(${resultPath})`
              }));
            },
            current,
            d
          });
          editor.emit("hideSelectionToolView");
        } else if (obj2.type === "svg")
          ;
        else {
          editor.emit("showClippathEditorView");
        }
      } else
        ;
    }
  }
};
var __glob_0_73 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": open_editor
}, Symbol.toStringTag, { value: "Module" }));
var pauseTimelineItem = {
  command: "pauseTimelineItem",
  execute: function(editor) {
    if (editor.timer) {
      editor.timer.stop();
    }
  }
};
var __glob_0_74 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": pauseTimelineItem
}, Symbol.toStringTag, { value: "Module" }));
var playTimelineItem = {
  command: "playTimelineItem",
  description: "Play button action",
  execute: function(editor, speed2 = 1, iterationCount = 1, direction2 = "normal") {
    editor.context.selection.empty();
    editor.emit(REFRESH_SELECTION);
    _currentProject(editor, (project2, timeline) => {
      var lastTime = project2.getSelectedTimelineLastTime();
      if (editor.timer) {
        editor.timer.stop();
      } else {
        editor.timer = makeTimer({
          elapsed: timeline.currentTime * 1e3,
          speed: speed2,
          duration: lastTime * 1e3,
          iterationCount,
          direction: direction2
        });
      }
      editor.timer.play({
        duration: lastTime * 1e3,
        elapsed: timeline.currentTime * 1e3,
        speed: speed2,
        iterationCount,
        direction: direction2,
        tick: (elapsed) => {
          project2.seek(timecode(timeline.fps, elapsed / 1e3));
          editor.emit("playTimeline");
        },
        last: (elapsed) => {
          project2.seek(timecode(timeline.fps, elapsed / 1e3));
          editor.emit("playTimeline");
          editor.nextTick(() => {
            editor.emit("stopTimeline");
          });
        },
        stop: (elapsed) => {
          project2.stop(timecode(timeline.fps, elapsed / 1e3));
          editor.emit("stopTimeline");
        }
      });
    });
  }
};
var __glob_0_75 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": playTimelineItem
}, Symbol.toStringTag, { value: "Module" }));
var prevTimelineItem = {
  command: "prevTimelineItem",
  execute: function(editor) {
    _currentProject(editor, (project2, timeline) => {
      var prevTime = project2.getSelectedTimelinePrevTime();
      project2.setTimelineCurrentTime(timecode(timeline.fps, prevTime));
      project2.seek();
      editor.emit("playTimeline");
    });
  }
};
var __glob_0_76 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": prevTimelineItem
}, Symbol.toStringTag, { value: "Module" }));
var recoverBooleanPath = {
  command: "recoverBooleanPath",
  description: "recover box rectangle for boolean path result",
  execute: function(editor) {
    const current = editor.context.selection.current;
    let booleanContainer;
    if (current && current.isBooleanItem) {
      booleanContainer = current.parent;
    } else if (current && current.is("boolean-path")) {
      booleanContainer = current;
    }
    if (booleanContainer) {
      const isBooleanItem = typeof current.isBooleanItem === "boolean" && current.isBooleanItem;
      const booleanPath = booleanContainer.d;
      if (!booleanPath) {
        return;
      }
      const layersCache = booleanContainer.layers.map((it) => {
        return {
          item: it,
          matrix: it.matrix
        };
      });
      const newBooleanContainerRect = booleanContainer.updatePath(booleanPath);
      delete newBooleanContainerRect.d;
      booleanContainer.reset(newBooleanContainerRect);
      layersCache.forEach((it) => {
        booleanContainer.resetMatrix(it.item);
      });
      const ids = [...layersCache.map((it) => it.item.id), booleanContainer.id];
      const data = editor.context.selection.packByIds(ids, "x", "y", "width", "height");
      editor.context.commands.executeCommand("setAttribute", "fit boolean path", data, {
        origin: "*",
        doNotChildrenScale: isBooleanItem
      });
    }
  }
};
var __glob_0_77 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": recoverBooleanPath
}, Symbol.toStringTag, { value: "Module" }));
var refreshArtboard = {
  command: "refreshArtboard",
  execute: function(editor) {
    const command = editor.createCommandMaker();
    command.emit("refreshLayerTreeView");
    command.emit("refreshAllCanvas");
    command.emit(UPDATE_CANVAS);
    command.emit("refreshAllElementBoundSize");
    command.emit(REFRESH_SELECTION);
    command.run();
  }
};
var __glob_0_78 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": refreshArtboard
}, Symbol.toStringTag, { value: "Module" }));
var refreshElement = {
  command: "refreshElement",
  execute: function(editor, current, checkRefreshCanvas = true) {
    var _a;
    const maker = editor.createCommandMaker();
    if (isArray(current)) {
      if (checkRefreshCanvas) {
        maker.emit("refreshAllCanvas");
      }
      maker.emit(UPDATE_CANVAS, current);
    } else {
      if (checkRefreshCanvas) {
        if (current && current.hasChangedField("children", "changedChildren", "parentId")) {
          maker.emit("refreshAllCanvas");
        }
      }
      maker.emit(UPDATE_CANVAS, current);
      if (current.hasLayout()) {
        maker.emit("refreshElementBoundSize", current);
      } else {
        if (current && (current.isLayoutItem() || ((_a = current.parent) == null ? void 0 : _a.is("boolean-path")))) {
          maker.emit("refreshElementBoundSize", current.parent);
        } else {
          maker.emit("refreshElementBoundSize", current);
        }
      }
    }
    maker.run();
  }
};
var __glob_0_79 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": refreshElement
}, Symbol.toStringTag, { value: "Module" }));
function refreshHistory(editor) {
  editor.context.commands.emit("saveJSON");
}
var __glob_0_80 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": refreshHistory
}, Symbol.toStringTag, { value: "Module" }));
var refreshSelectedOffset = {
  command: "refreshSelectedOffset",
  execute: function(editor) {
    var offset = editor.timeline.items[0];
    if (offset) {
      editor.emit("refreshOffsetValue", offset);
    }
  }
};
var __glob_0_81 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": refreshSelectedOffset
}, Symbol.toStringTag, { value: "Module" }));
var removeAnimationItem = {
  command: "removeAnimationItem",
  execute: function(editor, id) {
    const project2 = editor.context.selection.currentProject;
    if (project2) {
      project2.removeAnimationItem(id);
      editor.timeline.empty();
      editor.emit("refreshTimeline");
      editor.emit("removeAnimation");
    }
  }
};
var __glob_0_82 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": removeAnimationItem
}, Symbol.toStringTag, { value: "Module" }));
var removeLayer = {
  command: "removeLayer",
  execute: function(editor, ids = void 0) {
    const currentIds = ids || editor.context.selection.ids;
    const removedIds = [];
    editor.context.selection.itemsByIds(currentIds).forEach((item) => {
      removedIds.push(item.id);
      item.remove();
    });
    editor.context.selection.removeById(removedIds);
    editor.nextTick(() => {
      editor.emit("refreshAll");
    });
  }
};
var __glob_0_83 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": removeLayer
}, Symbol.toStringTag, { value: "Module" }));
var removeTimeline = {
  command: "removeTimeline",
  execute: function(editor, layerId) {
    const project2 = editor.context.selection.currentProject;
    if (project2) {
      project2.removeTimeline(layerId);
      editor.timeline.empty();
      editor.emit("refreshTimeline");
      editor.emit("refreshSelectedOffset");
    }
  }
};
var __glob_0_84 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": removeTimeline
}, Symbol.toStringTag, { value: "Module" }));
var removeTimelineProperty = {
  command: "removeTimelineProperty",
  execute: function(editor, layerId, property) {
    const project2 = editor.context.selection.currentProject;
    if (project2) {
      project2.removeTimelineProperty(layerId, property);
      editor.timeline.empty();
      editor.emit("refreshTimeline");
      editor.emit("refreshSelectedOffset");
    }
  }
};
var __glob_0_85 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": removeTimelineProperty
}, Symbol.toStringTag, { value: "Module" }));
function resizeArtBoard(editor, size2 = "") {
  var current = editor.context.selection.current;
  if (current && current.is("artboard")) {
    if (!size2.trim())
      return;
    var [width2, height2] = size2.split("x");
    width2 = +width2;
    height2 = +height2;
    current.resize(width2, height2);
    editor.context.selection.select(current);
    _doForceRefreshSelection(editor);
  }
}
var __glob_0_86 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": resizeArtBoard
}, Symbol.toStringTag, { value: "Module" }));
var rotateLayer = {
  command: "rotateLayer",
  description: "rotate layer by keydown with matrix ",
  execute: function(editor, distAngle = 0) {
    editor.context.commands.executeCommand("setAttribute", "change rotate", editor.context.selection.packByValue({
      angle: editor.context.selection.current.angle + distAngle
    }));
  }
};
var __glob_0_87 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": rotateLayer
}, Symbol.toStringTag, { value: "Module" }));
var same_height = {
  command: "same.height",
  description: "fit at the same height",
  execute: function(editor) {
    var len2 = editor.context.selection.length;
    if (len2 == 1)
      ;
    else if (len2 > 1) {
      const rect2 = vertiesToRectangle(editor.context.selection.verties);
      editor.context.commands.executeCommand("setAttribute", "fit at the same height", editor.context.selection.packByValue({
        y: rect2.y,
        height: rect2.height
      }));
    }
  }
};
var __glob_0_88 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": same_height
}, Symbol.toStringTag, { value: "Module" }));
var same_width = {
  command: "same.width",
  description: "fit at the same width",
  execute: function(editor) {
    if (editor.context.selection.isMany) {
      const rect2 = vertiesToRectangle(editor.context.selection.verties);
      editor.context.commands.executeCommand("setAttribute", "fit at the same width", editor.context.selection.packByValue({
        x: rect2.x,
        width: rect2.width
      }));
    }
  }
};
var __glob_0_89 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": same_width
}, Symbol.toStringTag, { value: "Module" }));
var saveJSON = {
  command: "saveJSON",
  execute: function(editor) {
    editor.saveItem("model", editor.context.modelManager.toJSON());
  }
};
var __glob_0_90 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": saveJSON
}, Symbol.toStringTag, { value: "Module" }));
var savePNG = {
  command: "savePNG",
  execute: function(editor, callbackCommand = "") {
    const item = editor.context.selection.current;
    if (item) {
      const svgString = ExportManager.generateSVG(editor, item).trim();
      const datauri = "data:image/svg+xml;base64," + window.btoa(svgString);
      loadOriginalImage({ local: datauri }, (info, img) => {
        createImagePng(img, (pngDataUri) => {
          if (callbackCommand) {
            editor.emit(callbackCommand, pngDataUri);
          }
        });
      });
    }
  }
};
var __glob_0_91 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": savePNG
}, Symbol.toStringTag, { value: "Module" }));
var segment_delete = {
  command: "segment.delete",
  execute: function(editor) {
    editor.emit("deleteSegment");
  }
};
var __glob_0_92 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": segment_delete
}, Symbol.toStringTag, { value: "Module" }));
var segment_move_down = {
  command: "segment.move.down",
  execute: function(editor, obj2 = { dy: 1 }) {
    const dy = +obj2.dy;
    editor.emit("moveSegment", 0, dy);
  }
};
var __glob_0_93 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": segment_move_down
}, Symbol.toStringTag, { value: "Module" }));
var segment_move_left = {
  command: "segment.move.left",
  execute: function(editor, obj2 = { dx: 1 }) {
    const dx = +obj2.dx;
    editor.emit("moveSegment", -1 * dx, 0);
  }
};
var __glob_0_94 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": segment_move_left
}, Symbol.toStringTag, { value: "Module" }));
var segment_move_right = {
  command: "segment.move.right",
  execute: function(editor, obj2 = { dx: 1 }) {
    const dx = +obj2.dx;
    editor.emit("moveSegment", dx, 0);
  }
};
var __glob_0_95 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": segment_move_right
}, Symbol.toStringTag, { value: "Module" }));
var segment_move_up = {
  command: "segment.move.up",
  execute: function(editor, obj2 = { dy: 1 }) {
    const dy = +obj2.dy;
    editor.emit("moveSegment", 0, -1 * dy);
  }
};
var __glob_0_96 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": segment_move_up
}, Symbol.toStringTag, { value: "Module" }));
var select_all = {
  command: "select.all",
  execute: function(editor) {
    var project2 = editor.context.selection.currentProject;
    if (project2) {
      editor.context.selection.select(...project2.layers);
      editor.context.commands.emit("history.refreshSelection");
    }
  }
};
var __glob_0_97 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": select_all
}, Symbol.toStringTag, { value: "Module" }));
var selectTimelineItem = {
  command: "selectTimelineItem",
  execute: function(editor, selectedId) {
    const project2 = editor.context.selection.currentProject;
    if (project2) {
      project2.selectTimeline(selectedId);
      editor.emit("refreshTimeline");
      editor.emit("selectTimeline");
    }
  }
};
var __glob_0_98 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": selectTimelineItem
}, Symbol.toStringTag, { value: "Module" }));
var setAttribute = {
  command: "setAttribute",
  execute: function(editor, multiAttrs = {}, context = { origin: "*" }) {
    const messages = [];
    Object.entries(multiAttrs).forEach(([id, attrs]) => {
      const item = editor.get(id);
      const newAttrs = {};
      Object.entries(attrs).forEach(([key, value]) => {
        newAttrs[key] = isFunction(value) ? value(item) : value;
      });
      messages.push({ id: item.id, parentId: item.parentId, attrs: newAttrs });
    });
    if (messages.length == 0) {
      return;
    }
    let hasRefreshCanvas = false;
    const children2 = [];
    messages.forEach((message) => {
      const item = editor.get(message.id);
      if (item) {
        item.reset(message.attrs, context);
        if (item.hasChangedField("layout")) {
          item.layers.forEach((child) => {
            if (child.isLayout(Layout.DEFAULT))
              ;
            else if (child.isLayout(Layout.FLEX))
              ;
            else if (child.isLayout(Layout.GRID))
              ;
            editor.context.commands.emit("refreshElement", child);
          });
        }
        children2.push(item);
        if (item.hasChangedHirachy) {
          hasRefreshCanvas = true;
        }
      }
      if (item.is("project")) {
        return;
      }
      if (item.parent && item.parent.is("project")) {
        return;
      }
      if (item.isLayoutItem() || item.isBooleanItem) {
        const parent = editor.get(message.parentId);
        if (message.parentId && (parent == null ? void 0 : parent.isNot("project"))) {
          parent.reset({ changedChildren: true }, context);
          hasRefreshCanvas = true;
        }
      }
    });
    if (children2.length) {
      editor.context.commands.emit("refreshElement", children2, false);
    }
    if (hasRefreshCanvas) {
      editor.emit("refreshAllCanvas");
    }
  }
};
var __glob_0_99 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": setAttribute
}, Symbol.toStringTag, { value: "Module" }));
var setTimelineOffset = {
  command: "setTimelineOffset",
  debounce: 100,
  execute: function(editor, obj2) {
    const project2 = editor.context.selection.currentProject;
    if (project2) {
      project2.setTimelineKeyframeOffsetValue(obj2.layerId, obj2.property, obj2.id, obj2.value, obj2.timing, obj2.time);
      editor.emit("refreshTimeline");
    }
  }
};
var __glob_0_100 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": setTimelineOffset
}, Symbol.toStringTag, { value: "Module" }));
var showExportView = {
  command: "showExportView",
  execute: function(editor) {
    editor.emit("showExportWindow");
  }
};
var __glob_0_101 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": showExportView
}, Symbol.toStringTag, { value: "Module" }));
var sort_bottom = {
  command: "sort.bottom",
  execute: function(editor) {
    if (editor.context.selection.isOne) {
      const current = editor.context.selection.current;
      if (current.parent.is("project"))
        ;
      else {
        const parent = current.parent;
        const distY = getVertiesMaxY(parent.verties) - getVertiesMaxY(editor.context.selection.verties);
        editor.context.commands.emit("moveLayer", 0, distY);
      }
    } else if (editor.context.selection.isMany) {
      let maxRightY = getVertiesMaxY(editor.context.selection.verties);
      editor.context.commands.emit("moveLayerForItems", editor.context.selection.map((item) => {
        let itemRightY = getVertiesMaxY(item.verties);
        return { item, dist: [0, maxRightY - itemRightY, 0, 0] };
      }));
    }
  }
};
var __glob_0_102 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": sort_bottom
}, Symbol.toStringTag, { value: "Module" }));
var sort_center = {
  command: "sort.center",
  execute: function(editor) {
    if (editor.context.selection.isOne) {
      const current = editor.context.selection.current;
      if (current.parent.is("project"))
        ;
      else if (current.artboard) {
        const distX = getVertiesCenterX(current.artboard.verties) - getVertiesCenterX(editor.context.selection.verties);
        editor.context.commands.emit("moveLayer", distX, 0);
      }
    } else if (editor.context.selection.isMany) {
      let maxRightX = getVertiesCenterX(editor.context.selection.verties);
      editor.context.commands.emit("moveLayerForItems", editor.context.selection.map((item) => {
        let itemRightX = getVertiesCenterX(item.verties);
        return { item, dist: [maxRightX - itemRightX, 0, 0] };
      }));
    }
  }
};
var __glob_0_103 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": sort_center
}, Symbol.toStringTag, { value: "Module" }));
var sort_left = {
  command: "sort.left",
  execute: function(editor) {
    if (editor.context.selection.isOne) {
      const current = editor.context.selection.current;
      if (current.parent.is("project"))
        ;
      else {
        const parent = current.parent;
        const distX = getVertiesMinX(parent.verties) - getVertiesMinX(editor.context.selection.verties);
        editor.context.commands.emit("moveLayer", distX, 0);
      }
    } else if (editor.context.selection.isMany) {
      let maxRightX = getVertiesMinX(editor.context.selection.verties);
      editor.context.commands.emit("moveLayerForItems", editor.context.selection.map((item) => {
        let itemRightX = getVertiesMinX(item.verties);
        return { item, dist: [maxRightX - itemRightX, 0, 0] };
      }));
    }
  }
};
var __glob_0_104 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": sort_left
}, Symbol.toStringTag, { value: "Module" }));
var sort_middle = {
  command: "sort.middle",
  execute: function(editor) {
    if (editor.context.selection.isOne) {
      const current = editor.context.selection.current;
      if (current.parent.is("project"))
        ;
      else if (current.artboard) {
        const distY = getVertiesCenterY(current.artboard.verties) - getVertiesCenterY(editor.context.selection.verties);
        editor.context.commands.emit("moveLayer", 0, distY);
      }
    } else if (editor.context.selection.isMany) {
      let maxRightY = getVertiesCenterY(editor.context.selection.verties);
      editor.context.commands.emit("moveLayerForItems", editor.context.selection.map((item) => {
        let itemRightY = getVertiesCenterY(item.verties);
        return { item, dist: [0, maxRightY - itemRightY, 0, 0] };
      }));
    }
  }
};
var __glob_0_105 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": sort_middle
}, Symbol.toStringTag, { value: "Module" }));
var sort_right = {
  command: "sort.right",
  execute: function(editor) {
    if (editor.context.selection.isOne) {
      const current = editor.context.selection.current;
      if (current.parent.is("project"))
        ;
      else {
        const parent = current.parent;
        const distX = getVertiesMaxX(parent.verties) - getVertiesMaxX(editor.context.selection.verties);
        editor.context.commands.emit("moveLayer", distX, 0);
      }
    } else if (editor.context.selection.isMany) {
      let maxRightX = getVertiesMaxX(editor.context.selection.verties);
      editor.context.commands.emit("moveLayerForItems", editor.context.selection.map((item) => {
        let itemRightX = getVertiesMaxX(item.verties);
        return { item, dist: [maxRightX - itemRightX, 0, 0] };
      }));
    }
  }
};
var __glob_0_106 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": sort_right
}, Symbol.toStringTag, { value: "Module" }));
var sort_top = {
  command: "sort.top",
  execute: function(editor) {
    if (editor.context.selection.isOne) {
      const current = editor.context.selection.current;
      if (current.parent.is("project"))
        ;
      else {
        const parent = current.parent;
        const distY = getVertiesMinY(parent.verties) - getVertiesMinY(editor.context.selection.verties);
        editor.context.commands.emit("moveLayer", 0, distY);
      }
    } else if (editor.context.selection.isMany) {
      let maxRightY = getVertiesMinY(editor.context.selection.verties);
      editor.context.commands.emit("moveLayerForItems", editor.context.selection.map((item) => {
        let itemRightY = getVertiesMinY(item.verties);
        return { item, dist: [0, maxRightY - itemRightY, 0, 0] };
      }));
    }
  }
};
var __glob_0_107 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": sort_top
}, Symbol.toStringTag, { value: "Module" }));
var switch_path = {
  command: "switch.path",
  execute: async (editor) => {
    const current = editor.context.selection.current;
    if (!current)
      return;
    if (current.is("boolean-path") || current.isBooleanItem) {
      let parent = current;
      if (current.isBooleanItem) {
        parent = current.parent;
      }
      editor.context.selection.select(parent);
      editor.context.commands.executeCommand("setAttribute", "change boolean operation", editor.context.selection.packByValue({
        booleanOperation: parent["boolean-operation"],
        children: parent.children.reverse()
      }));
      editor.nextTick(() => {
        editor.context.commands.emit("recoverBooleanPath");
        editor.context.selection.select(current);
        editor.emit(REFRESH_SELECTION);
      });
    }
  }
};
var __glob_0_108 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": switch_path
}, Symbol.toStringTag, { value: "Module" }));
var ungroup_item = {
  command: "ungroup.item",
  execute: function(editor) {
    if (editor.context.selection.length === 0)
      return;
    const current = editor.context.selection.current;
    if (current) {
      let groupLayer = current;
      let layers2 = [...groupLayer.layers];
      layers2.reverse();
      layers2.forEach((child) => {
        groupLayer.insertBefore(child);
      });
      editor.context.selection.select(...layers2);
      editor.emit("refreshAll");
    }
  }
};
var __glob_0_109 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": ungroup_item
}, Symbol.toStringTag, { value: "Module" }));
var updateClipPath = {
  command: "updateClipPath",
  description: "update clip-path property ",
  execute: function(editor, pathObject) {
    editor.context.commands.executeCommand("setAttribute", "change clip-path", editor.context.selection.packByValue({
      clipPath: `path(${pathObject.d})`
    }));
  }
};
var __glob_0_110 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": updateClipPath
}, Symbol.toStringTag, { value: "Module" }));
var updateImage = {
  command: "updateImage",
  execute: function(editor, imageFileOrBlob, rect2, containerItem) {
    var reader = new window.FileReader();
    reader.onload = (e) => {
      var datauri = e.target.result;
      var local = window.URL.createObjectURL(imageFileOrBlob);
      editor.context.commands.emit("addImageAssetItem", {
        id: uuidShort(),
        type: imageFileOrBlob.type,
        name: imageFileOrBlob.name,
        original: datauri,
        local
      }, rect2, containerItem);
    };
    reader.readAsDataURL(imageFileOrBlob);
  }
};
var __glob_0_111 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": updateImage
}, Symbol.toStringTag, { value: "Module" }));
var updateImageAssetItem = {
  command: "updateImageAssetItem",
  execute: function(editor, item, callback) {
    var reader = new window.FileReader();
    reader.onload = (e) => {
      var datauri = e.target.result;
      var local = window.URL.createObjectURL(item);
      var project2 = editor.context.selection.currentProject;
      if (project2) {
        const image2 = project2.createImage({
          id: uuidShort(),
          type: item.type,
          name: item.name,
          original: datauri,
          local
        });
        editor.context.commands.emit("addImageAsset");
        isFunction(callback) && callback(image2.id);
      }
    };
    reader.readAsDataURL(item);
  }
};
var __glob_0_112 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": updateImageAssetItem
}, Symbol.toStringTag, { value: "Module" }));
const MAX_CACHE_COUNT = 1e3;
const cachedTransformMap = /* @__PURE__ */ new Map();
class TransformCache {
  static has(key) {
    return cachedTransformMap.has(key);
  }
  static get(key) {
    return cachedTransformMap.get(key);
  }
  static set(key, parsedValue) {
    if (cachedTransformMap.size > MAX_CACHE_COUNT) {
      cachedTransformMap.clear();
    }
    cachedTransformMap.set(key, parsedValue);
  }
}
const TRANSFORM_REG = /((matrix|translate(X|Y|Z|3d)?|scale(X|Y|Z|3d)?|rotate(X|Y|Z|3d)?|skew(X|Y)?|matrix(3d)?|perspective)\(([^)]*)\))/gi;
class Transform extends PropertyItem {
  getDefaultObject() {
    return {
      itemType: "transform",
      value: []
    };
  }
  toCloneObject() {
    return __spreadValues({}, this.attrs("itemType", "type", "value"));
  }
  toString() {
    return `${this.json.type}(${this.json.value.join(", ") || ""})`;
  }
  static join(list2) {
    var firstType = "perspective";
    var lastType = "matrix3d";
    var arr = list2.filter((it) => it.type === firstType);
    var last = list2.filter((it) => it.type === lastType);
    var arr2 = list2.filter((it) => it.type !== firstType && it.type !== lastType);
    return [...arr, ...arr2, ...last].map((it) => new Transform(it).toString()).join(" ");
  }
  hasNumberValue() {
    var type = this.json.type;
    return type.includes("matrix") || type.includes("scale");
  }
  static parse(transform2) {
    return new Transform(transform2);
  }
  static remove(transform2, type = []) {
    if (typeof type === "string") {
      type = [type];
    }
    return Transform.filter(transform2, (it) => {
      return type.includes(it.type) === false;
    });
  }
  static filter(transform2, filterFunction) {
    return Transform.join(Transform.parseStyle(transform2, false).filter((it) => filterFunction(it)));
  }
  static replace(transform2, valueObject) {
    var obj2 = Transform.parseStyle(transform2, false);
    var tObject = obj2.find((t) => t.type === valueObject.type);
    if (tObject) {
      tObject.value = valueObject.value;
    } else {
      obj2.push(valueObject);
    }
    return Transform.join(obj2);
  }
  static replaceAll(oldTransform, newTransform) {
    var oldT = Transform.parseStyle(oldTransform, false);
    var newT = Transform.parseStyle(newTransform);
    for (var i = 0, len2 = newT.length; i < len2; i++) {
      var newObject = newT[i];
      var oldObject = oldT.find((t) => t.type === newObject.type);
      if (oldObject) {
        oldObject.value = newObject.value;
      } else {
        oldT.push(newObject);
      }
    }
    return Transform.join(oldT);
  }
  static addTransform(oldTransform, newTransform) {
    var oldT = Transform.parseStyle(oldTransform, false);
    var newT = Transform.parseStyle(newTransform);
    for (var i = 0, len2 = newT.length; i < len2; i++) {
      var newObject = newT[i];
      var oldObject = oldT.find((t) => t.type === newObject.type);
      if (oldObject) {
        newObject.value.forEach((v, i2) => {
          oldObject.value[i2].value += v.value;
        });
      } else {
        oldT.push(newObject);
      }
    }
    return Transform.join(oldT);
  }
  static get(transform2, type) {
    var arr = Transform.parseStyle(transform2, true);
    if (typeof type === "function") {
      arr = arr.find(type);
    } else {
      arr = arr.find((it) => it.type === type);
    }
    if (arr) {
      return arr.value;
    }
    return void 0;
  }
  static createRotateKey(transform2, angle, field) {
    return `${transform2}:::${field}(${angle})`;
  }
  static rotate(transform2, angle, field = "rotate") {
    const key = Transform.createRotateKey(transform2, angle, field);
    if (TransformCache.has(key))
      return TransformCache.get(key);
    TransformCache.set(key, Transform.replace(transform2, { type: field, value: [angle] }));
    return TransformCache.get(key);
  }
  static rotateZ(transform2, angle) {
    return Transform.rotate(transform2, angle, "rotateZ");
  }
  static rotateX(transform2, angle) {
    return Transform.rotate(transform2, angle, "rotateX");
  }
  static rotateY(transform2, angle) {
    return Transform.rotate(transform2, angle, "rotateY");
  }
  static parseStyle(transform2, doCache = true) {
    var transforms = [];
    if (!transform2)
      return transforms;
    if (doCache && TransformCache.has(transform2)) {
      return TransformCache.get(transform2);
    }
    var matches2 = transform2.match(TRANSFORM_REG) || [];
    matches2.forEach((value, index2) => {
      var [transformName, transformValue] = value.split("(");
      transformValue = transformValue.split(")")[0];
      var arr = transformValue.split(",");
      if (transformValue.includes("matrix") || transformValue.includes("scale")) {
        arr = arr.map((it) => Length.number(it.trim()));
      } else {
        arr = arr.map((it) => Length.parse(it.trim()));
      }
      transforms[index2] = Transform.parse({
        type: transformName,
        value: arr
      });
    });
    if (doCache) {
      TransformCache.set(transform2, transforms);
    }
    return transforms;
  }
  static createTransformMatrix(parsedTransformList, width2, height2) {
    const view = create$4();
    for (let i = 0, len2 = parsedTransformList.length; i < len2; i++) {
      const it = parsedTransformList[i];
      switch (it.type) {
        case "translate":
        case "translateX":
        case "translateY":
        case "translateZ":
          var values = it.value;
          if (it.type === "translate") {
            values = [
              values[0].toPx(width2).value,
              values[1].toPx(height2).value,
              0
            ];
          } else if (it.type === "translateX") {
            values = [values[0].toPx(width2).value, 0, 0];
          } else if (it.type === "translateY") {
            values = [0, values[0].toPx(height2).value, 0];
          } else if (it.type === "translateZ") {
            values = [0, 0, values[0].toPx().value];
          }
          translate(view, view, values);
          break;
        case "rotate":
        case "rotateZ":
          rotateZ(view, view, degreeToRadian(it.value[0].value));
          break;
        case "rotateX":
          rotateX(view, view, degreeToRadian(it.value[0].value));
          break;
        case "rotateY":
          rotateY(view, view, degreeToRadian(it.value[0].value));
          break;
        case "rotate3d":
          var values = it.value;
          rotate$1(view, view, degreeToRadian(it.value[3].value), [
            values[0].value,
            values[1].value,
            values[2].value
          ]);
          break;
        case "scale":
          scale$1(view, view, [it.value[0].value, it.value[1].value, 1]);
          break;
        case "scaleX":
          scale$1(view, view, [it.value[0].value, 1, 1]);
          break;
        case "scaleY":
          scale$1(view, view, [1, it.value[0].value, 1]);
          break;
        case "scaleZ":
          scale$1(view, view, [1, 1, it.value[0].value]);
          break;
        case "skewX":
          var rad = it.value[0].toDeg().toRad();
          multiply$1(view, view, fromValues$1(1, 0, 0, 0, Math.tan(rad.value), 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1));
          break;
        case "skewY":
          var rad = it.value[0].toDeg().toRad();
          multiply$1(view, view, fromValues$1(1, Math.tan(rad.value), 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1));
          break;
        case "skew":
          const skewX = it.value[0].toDeg().toRad();
          const skewY = it.value.length > 1 ? it.value[1].toDeg().toRad() : skewX;
          multiply$1(view, view, fromValues$1(1, Math.tan(skewY.value), 0, 0, Math.tan(skewX.value), 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1));
          break;
        case "matrix":
          var values = it.value;
          values = [
            values[0].value,
            values[1].value,
            0,
            0,
            values[2].value,
            values[3].value,
            0,
            0,
            0,
            0,
            1,
            0,
            values[4].value,
            values[5].value,
            0,
            1
          ];
          multiply$1(view, view, values);
          break;
        case "matrix3d":
          var values = it.value.map((it2) => it2.value);
          multiply$1(view, view, values);
          break;
        case "perspective":
          var values = it.value;
          perspective(view, Math.PI * 0.5, width2 / height2, 1, values[0].value);
          break;
      }
    }
    return view;
  }
  static fromScale(scale2) {
    if (scale2[0] === 1 && scale2[1] === 1) {
      return "";
    }
    const list2 = [];
    if (scale2[0] != 1)
      list2.push(`scaleX(${scale2[0]})`);
    if (scale2[1] != 1)
      list2.push(`scaleY(${scale2[1]})`);
    if (scale2[2] != 1)
      list2.push(`scaleZ(${scale2[2]})`);
    return list2.join(" ");
  }
}
var updatePathItem = {
  command: "updatePathItem",
  description: "Update path string for selected svg path item",
  execute: function(editor, pathObject) {
    const current = editor.context.selection.current;
    if (current) {
      if (pathObject.box === "box") {
        const newPath = current.invertPath(pathObject.d);
        editor.context.commands.executeCommand("setAttribute", "change local path", editor.context.selection.packByValue({
          d: newPath.d
        }));
      } else {
        const newPath = new PathParser(pathObject.d);
        newPath.transformMat4(pathObject.matrix.absoluteMatrixInverse);
        let bbox = newPath.getBBox();
        const newWidth = distance$1(bbox[1], bbox[0]);
        const newHeight = distance$1(bbox[3], bbox[0]);
        let oldBBox = vertiesMap(rectToVerties(bbox[0][0], bbox[0][1], newWidth, newHeight), pathObject.matrix.absoluteMatrix);
        let newBBox = vertiesMap(oldBBox, calculateMatrixInverse(fromTranslation([], oldBBox[4]), Transform.createTransformMatrix(Transform.parseStyle(pathObject.matrix.transform), newWidth, newHeight), fromTranslation([], negate([], oldBBox[4]))));
        const worldMatrix = calculateMatrix(fromTranslation([], newBBox[0]), current.getLocalTransformMatrix(newWidth, newHeight));
        const realXY = getTranslation([], calculateMatrix(pathObject.matrix.parentMatrixInverse, worldMatrix, invert([], current.getLocalTransformMatrix(newWidth, newHeight))));
        editor.context.commands.executeCommand("setAttribute", "change path", editor.context.selection.packByValue({
          d: newPath.translate(-bbox[0][0], -bbox[0][1]).d,
          x: realXY[0],
          y: realXY[1],
          width: newWidth,
          height: newHeight
        }));
      }
    }
  }
};
var __glob_0_113 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": updatePathItem
}, Symbol.toStringTag, { value: "Module" }));
var updateResource = {
  command: "updateResource",
  execute: function(editor, items) {
    items.forEach((item) => {
      switch (item.type) {
        case "image/svg+xml":
        case "image/png":
        case "image/gif":
        case "image/jpg":
        case "image/jpeg":
          editor.context.commands.emit("updateImage", item);
          break;
        case "text/plain":
        case "text/html":
          editor.context.commands.emit("addText", {
            content: item.data
          });
          break;
        case "text/uri-list":
          editor.context.commands.emit("updateUriList", item);
          break;
      }
    });
  }
};
var __glob_0_114 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": updateResource
}, Symbol.toStringTag, { value: "Module" }));
var updateUriList = {
  command: "updateUriList",
  execute: function(editor, item) {
    var datauri = item.data;
    if (datauri.indexOf("data:") > -1) {
      var info = AssetParser.parse(datauri, true);
      switch (info.mimeType) {
        case "image/png":
        case "image/gif":
        case "image/jpg":
        case "image/jpeg":
          editor.context.commands.emit("addImageAssetItem", {
            id: uuidShort(),
            type: info.mimeType,
            name: "",
            original: datauri,
            local: info.local
          });
          break;
      }
    } else {
      var ext = item.data.split(".").pop();
      var name = item.data.split("/").pop();
      switch (ext) {
        case "png":
        case "jpg":
        case "gif":
        case "svg":
          editor.context.commands.emit("addImageAssetItem", {
            id: uuidShort(),
            type: "image/" + ext,
            name,
            original: item.data,
            local: item.data
          });
          break;
      }
    }
  }
};
var __glob_0_115 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": updateUriList
}, Symbol.toStringTag, { value: "Module" }));
var updateVideo = {
  command: "updateVideo",
  execute: function(editor, item, rect2, containerItem = void 0) {
    var reader = new window.FileReader();
    reader.onload = (e) => {
      var datauri = e.target.result;
      var local = window.URL.createObjectURL(item);
      editor.context.commands.emit("addVideoAssetItem", {
        id: uuidShort(),
        type: item.type,
        name: item.name,
        original: datauri,
        local
      }, rect2, containerItem);
    };
    reader.readAsDataURL(item);
  }
};
var __glob_0_116 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": updateVideo
}, Symbol.toStringTag, { value: "Module" }));
var updateVideoAssetItem = {
  command: "updateVideoAssetItem",
  execute: function(editor, item, callback) {
    var reader = new window.FileReader();
    reader.onload = (e) => {
      var datauri = e.target.result;
      var local = window.URL.createObjectURL(item);
      var project2 = editor.context.selection.currentProject;
      if (project2) {
        project2.createVideo({
          id: uuidShort(),
          type: item.type,
          name: item.name,
          original: datauri,
          local
        });
        editor.emit("addVideoAsset");
        isFunction(callback) && callback(local);
      }
    };
    reader.readAsDataURL(item);
  }
};
var __glob_0_117 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": updateVideoAssetItem
}, Symbol.toStringTag, { value: "Module" }));
var update = {
  command: "update",
  description: "Update the model",
  execute: function(editor, id = null, attrs = {}, context = { origin: "*" }) {
    const item = editor.get(id);
    console.log(item);
    if (item) {
      const isChanged = item.reset(attrs, context);
      console.log(item, attrs, isChanged);
      if (isChanged) {
        editor.context.commands.emit("refreshElement", item);
      }
    }
  }
};
var __glob_0_118 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": update
}, Symbol.toStringTag, { value: "Module" }));
const modules$2 = { "./command_list/Console.js": __glob_0_0$2, "./command_list/_currentProject.js": __glob_0_1$2, "./command_list/_doForceRefreshSelection.js": __glob_0_2$1, "./command_list/addArtBoard.js": __glob_0_3$1, "./command_list/addBackgroundColor.js": __glob_0_4$1, "./command_list/addBackgroundImageAsset.js": __glob_0_5$1, "./command_list/addBackgroundImageGradient.js": __glob_0_6$1, "./command_list/addBackgroundImagePattern.js": __glob_0_7$1, "./command_list/addCustomComponent.js": __glob_0_8$1, "./command_list/addImage.js": __glob_0_9$1, "./command_list/addImageAssetItem.js": __glob_0_10$1, "./command_list/addLayer.js": __glob_0_11$1, "./command_list/addLayerView.js": __glob_0_12$1, "./command_list/addProject.js": __glob_0_13$1, "./command_list/addSVGFilterAssetItem.js": __glob_0_14$1, "./command_list/addText.js": __glob_0_15$1, "./command_list/addTimelineCurrentProperty.js": __glob_0_16$1, "./command_list/addTimelineItem.js": __glob_0_17$1, "./command_list/addTimelineKeyframe.js": __glob_0_18$1, "./command_list/addTimelineProperty.js": __glob_0_19$1, "./command_list/addVideo.js": __glob_0_20$1, "./command_list/addVideoAssetItem.js": __glob_0_21$1, "./command_list/clipboard.copy.js": __glob_0_22$1, "./command_list/clipboard.paste.js": __glob_0_23$1, "./command_list/convert.flatten.path.js": __glob_0_24$1, "./command_list/convert.no.transform.path.js": __glob_0_25, "./command_list/convert.normalize.path.js": __glob_0_26, "./command_list/convert.path.operation.js": __glob_0_27, "./command_list/convert.polygonal.path.js": __glob_0_28, "./command_list/convert.simplify.path.js": __glob_0_29, "./command_list/convert.smooth.path.js": __glob_0_30, "./command_list/convert.stroke.to.path.js": __glob_0_31, "./command_list/convertPasteText.js": __glob_0_32, "./command_list/convertPath.js": __glob_0_33, "./command_list/copy.path.js": __glob_0_34, "./command_list/copyTimelineProperty.js": __glob_0_35, "./command_list/deleteTimelineKeyframe.js": __glob_0_36, "./command_list/doubleclick.item.js": __glob_0_37, "./command_list/downloadJSON.js": __glob_0_38, "./command_list/downloadPNG.js": __glob_0_39, "./command_list/downloadSVG.js": __glob_0_40, "./command_list/drop.asset.js": __glob_0_41, "./command_list/dropImageUrl.js": __glob_0_42, "./command_list/editor.config.body.event.js": __glob_0_43, "./command_list/fileDropItems.js": __glob_0_44, "./command_list/firstTimelineItem.js": __glob_0_45, "./command_list/group.item.js": __glob_0_46, "./command_list/history.addLayer.js": __glob_0_47, "./command_list/history.bring.forward.js": __glob_0_48, "./command_list/history.bring.front.js": __glob_0_49, "./command_list/history.clipboard.paste.js": __glob_0_50, "./command_list/history.group.item.js": __glob_0_51, "./command_list/history.moveLayer.js": __glob_0_52, "./command_list/history.moveLayerToTarget.js": __glob_0_53, "./command_list/history.refreshSelection.js": __glob_0_54, "./command_list/history.refreshSelectionProject.js": __glob_0_55, "./command_list/history.removeLayer.js": __glob_0_56, "./command_list/history.removeProject.js": __glob_0_57, "./command_list/history.send.back.js": __glob_0_58, "./command_list/history.send.backward.js": __glob_0_59, "./command_list/history.setAttribute.js": __glob_0_60, "./command_list/item.move.depth.down.js": __glob_0_61, "./command_list/item.move.depth.first.js": __glob_0_62, "./command_list/item.move.depth.last.js": __glob_0_63, "./command_list/item.move.depth.up.js": __glob_0_64, "./command_list/keymap.keydown.js": __glob_0_65, "./command_list/lastTimelineItem.js": __glob_0_66, "./command_list/load.json.js": __glob_0_67, "./command_list/moveLayer.js": __glob_0_68, "./command_list/moveLayerForItems.js": __glob_0_69, "./command_list/moveSelectionToCenter.js": __glob_0_70, "./command_list/newComponent.js": __glob_0_71, "./command_list/nextTimelineItem.js": __glob_0_72, "./command_list/open.editor.js": __glob_0_73, "./command_list/pauseTimelineItem.js": __glob_0_74, "./command_list/playTimelineItem.js": __glob_0_75, "./command_list/prevTimelineItem.js": __glob_0_76, "./command_list/recoverBooleanPath.js": __glob_0_77, "./command_list/refreshArtboard.js": __glob_0_78, "./command_list/refreshElement.js": __glob_0_79, "./command_list/refreshHistory.js": __glob_0_80, "./command_list/refreshSelectedOffset.js": __glob_0_81, "./command_list/removeAnimationItem.js": __glob_0_82, "./command_list/removeLayer.js": __glob_0_83, "./command_list/removeTimeline.js": __glob_0_84, "./command_list/removeTimelineProperty.js": __glob_0_85, "./command_list/resizeArtBoard.js": __glob_0_86, "./command_list/rotateLayer.js": __glob_0_87, "./command_list/same.height.js": __glob_0_88, "./command_list/same.width.js": __glob_0_89, "./command_list/saveJSON.js": __glob_0_90, "./command_list/savePNG.js": __glob_0_91, "./command_list/segment.delete.js": __glob_0_92, "./command_list/segment.move.down.js": __glob_0_93, "./command_list/segment.move.left.js": __glob_0_94, "./command_list/segment.move.right.js": __glob_0_95, "./command_list/segment.move.up.js": __glob_0_96, "./command_list/select.all.js": __glob_0_97, "./command_list/selectTimelineItem.js": __glob_0_98, "./command_list/setAttribute.js": __glob_0_99, "./command_list/setTimelineOffset.js": __glob_0_100, "./command_list/showExportView.js": __glob_0_101, "./command_list/sort.bottom.js": __glob_0_102, "./command_list/sort.center.js": __glob_0_103, "./command_list/sort.left.js": __glob_0_104, "./command_list/sort.middle.js": __glob_0_105, "./command_list/sort.right.js": __glob_0_106, "./command_list/sort.top.js": __glob_0_107, "./command_list/switch.path.js": __glob_0_108, "./command_list/ungroup.item.js": __glob_0_109, "./command_list/updateClipPath.js": __glob_0_110, "./command_list/updateImage.js": __glob_0_111, "./command_list/updateImageAssetItem.js": __glob_0_112, "./command_list/updatePathItem.js": __glob_0_113, "./command_list/updateResource.js": __glob_0_114, "./command_list/updateUriList.js": __glob_0_115, "./command_list/updateVideo.js": __glob_0_116, "./command_list/updateVideoAssetItem.js": __glob_0_117, "./command_list/model/update.js": __glob_0_118 };
const obj$1 = {};
Object.entries(modules$2).forEach(([key, value]) => {
  key = key.replace("./command_list/", "").replace(".js", "");
  obj$1[key] = value.default;
});
function commands$1(editor) {
  editor.loadCommands(obj$1);
}
var area_width = {
  key: "area.width",
  defaultValue: 100,
  title: "Area Width to find layers fastly",
  description: "Set area width/height",
  type: "number"
};
var __glob_0_0$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": area_width
}, Symbol.toStringTag, { value: "Module" }));
var debug_mode = {
  key: "debug.mode",
  defaultValue: false,
  title: "debug mode",
  description: "Set debug mode to on ",
  type: "boolean"
};
var __glob_0_1$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": debug_mode
}, Symbol.toStringTag, { value: "Module" }));
var editing_css_itemType = {
  key: "editing.css.itemType",
  defaultValue: "rect",
  title: "set item type for  editing css",
  description: "set item type for  editing css",
  type: "string"
};
var __glob_0_2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": editing_css_itemType
}, Symbol.toStringTag, { value: "Module" }));
var editing_draw_itemType = {
  key: "editing.draw.itemType",
  defaultValue: "path",
  title: "set item type for  editing draw",
  description: "set item type for  editing draw",
  type: "string"
};
var __glob_0_3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": editing_draw_itemType
}, Symbol.toStringTag, { value: "Module" }));
var editing_mode_itemType = {
  key: "editing.mode.itemType",
  defaultValue: "select",
  title: "set item type for  editing mode",
  description: "set item type for  editing mode",
  type: "string"
};
var __glob_0_4 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": editing_mode_itemType
}, Symbol.toStringTag, { value: "Module" }));
var editing_mode = {
  key: "editing.mode",
  defaultValue: EditingMode.SELECT,
  title: "set editing mode for Editor",
  description: "set editing mode (select, append, draw, path)",
  type: "string"
};
var __glob_0_5 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": editing_mode
}, Symbol.toStringTag, { value: "Module" }));
var editing_svg_itemType = {
  key: "editing.svg.itemType",
  defaultValue: "svg-rect",
  title: "set item type for  editing svg",
  description: "set item type for  editing svg",
  type: "string"
};
var __glob_0_6 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": editing_svg_itemType
}, Symbol.toStringTag, { value: "Module" }));
var editor_design_mode = {
  key: "editor.design.mode",
  defaultValue: "design",
  title: "Editor Design Mode ",
  description: "Set editor's design mode",
  options: ["design", "item"],
  type: "select"
};
var __glob_0_7 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": editor_design_mode
}, Symbol.toStringTag, { value: "Module" }));
var editor_layout_mode = {
  key: "editor.layout.mode",
  defaultValue: "all",
  title: "Editor Layout Mode ",
  description: "Set editor's layout mode",
  type: "string"
};
var __glob_0_8 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": editor_layout_mode
}, Symbol.toStringTag, { value: "Module" }));
var fixed_angle = {
  key: "fixed.angle",
  defaultValue: 15,
  title: "fixed angle count",
  description: "Set fixed angle",
  type: "number"
};
var __glob_0_9 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": fixed_angle
}, Symbol.toStringTag, { value: "Module" }));
var fixed_gradient_angle = {
  key: "fixed.gradient.angle",
  defaultValue: 1,
  title: "fixed gradient angle count",
  description: "Set fixed gradient angle",
  type: "number"
};
var __glob_0_10 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": fixed_gradient_angle
}, Symbol.toStringTag, { value: "Module" }));
var history_delay_ms = {
  key: "history.delay.ms",
  defaultValue: 500,
  title: "history delay milliseconds",
  description: "Set history delay time",
  type: "number"
};
var __glob_0_11 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": history_delay_ms
}, Symbol.toStringTag, { value: "Module" }));
var horizontal_line = {
  key: "horizontal.line",
  defaultValue: [],
  title: "horizontal guide line for snap ",
  description: "horizontal guide line for snap",
  type: "array"
};
var __glob_0_12 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": horizontal_line
}, Symbol.toStringTag, { value: "Module" }));
var horizontal_line_selected_index = {
  key: "horizontal.line.selected.index",
  defaultValue: -1,
  title: "selected horizontal guide line index",
  description: "selected horizontal guide line index",
  type: "number"
};
var __glob_0_13 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": horizontal_line_selected_index
}, Symbol.toStringTag, { value: "Module" }));
var set_drag_path_area = {
  key: "set.drag.path.area",
  defaultValue: false,
  title: "Drag path area",
  description: "Drag path area",
  type: "boolean",
  storage: "none"
};
var __glob_0_14 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": set_drag_path_area
}, Symbol.toStringTag, { value: "Module" }));
var set_move_control_point = {
  key: "set.move.control.point",
  defaultValue: false,
  title: "Moving Control Point",
  description: "Moving Control Point",
  type: "boolean",
  storage: "none"
};
var __glob_0_15 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": set_move_control_point
}, Symbol.toStringTag, { value: "Module" }));
var set_tool_hand = {
  key: "set.tool.hand",
  defaultValue: false,
  title: "Hand tool",
  description: "Hand tool is on",
  type: "boolean",
  storage: "none"
};
var __glob_0_16 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": set_tool_hand
}, Symbol.toStringTag, { value: "Module" }));
var show_left_panel = {
  key: "show.left.panel",
  defaultValue: true,
  title: "Show left panel",
  description: "Set left panel visibility to on",
  type: "boolean"
};
var __glob_0_17 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": show_left_panel
}, Symbol.toStringTag, { value: "Module" }));
var show_outline = {
  key: "show.outline",
  defaultValue: false,
  title: "Show outline",
  description: "Set outline visibility to on",
  type: "boolean"
};
var __glob_0_18 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": show_outline
}, Symbol.toStringTag, { value: "Module" }));
var show_right_panel = {
  key: "show.right.panel",
  defaultValue: true,
  title: "Show right panel",
  description: "Set right panel visibility to on",
  type: "boolean"
};
var __glob_0_19 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": show_right_panel
}, Symbol.toStringTag, { value: "Module" }));
var show_ruler = {
  key: "show.ruler",
  defaultValue: true,
  title: "Show ruler",
  description: "Set ruler visibility to on",
  type: "boolean"
};
var __glob_0_20 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": show_ruler
}, Symbol.toStringTag, { value: "Module" }));
var snap_distance = {
  key: "snap.distance",
  defaultValue: 3,
  title: "Snap distance between objects",
  description: "Set snap distance",
  type: "number"
};
var __glob_0_21 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": snap_distance
}, Symbol.toStringTag, { value: "Module" }));
var snap_grid = {
  key: "snap.grid",
  defaultValue: 50,
  title: "Snap grid size between objects",
  description: "Set snap grid size",
  type: "number"
};
var __glob_0_22 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": snap_grid
}, Symbol.toStringTag, { value: "Module" }));
var vertical_line = {
  key: "vertical.line",
  defaultValue: [],
  title: "vertical guide line for snap ",
  description: "vertical guide line for snap",
  type: "array"
};
var __glob_0_23 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": vertical_line
}, Symbol.toStringTag, { value: "Module" }));
var vertical_line_selected_index = {
  key: "vertical.line.selected.index",
  defaultValue: -1,
  title: "selected vertical guide line index",
  description: "selected vertical guide line index",
  type: "number"
};
var __glob_0_24 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": vertical_line_selected_index
}, Symbol.toStringTag, { value: "Module" }));
const modules$1 = { "./config_list/area.width.js": __glob_0_0$1, "./config_list/debug.mode.js": __glob_0_1$1, "./config_list/editing.css.itemType.js": __glob_0_2, "./config_list/editing.draw.itemType.js": __glob_0_3, "./config_list/editing.mode.itemType.js": __glob_0_4, "./config_list/editing.mode.js": __glob_0_5, "./config_list/editing.svg.itemType.js": __glob_0_6, "./config_list/editor.design.mode.js": __glob_0_7, "./config_list/editor.layout.mode.js": __glob_0_8, "./config_list/fixed.angle.js": __glob_0_9, "./config_list/fixed.gradient.angle.js": __glob_0_10, "./config_list/history.delay.ms.js": __glob_0_11, "./config_list/horizontal.line.js": __glob_0_12, "./config_list/horizontal.line.selected.index.js": __glob_0_13, "./config_list/set.drag.path.area.js": __glob_0_14, "./config_list/set.move.control.point.js": __glob_0_15, "./config_list/set.tool.hand.js": __glob_0_16, "./config_list/show.left.panel.js": __glob_0_17, "./config_list/show.outline.js": __glob_0_18, "./config_list/show.right.panel.js": __glob_0_19, "./config_list/show.ruler.js": __glob_0_20, "./config_list/snap.distance.js": __glob_0_21, "./config_list/snap.grid.js": __glob_0_22, "./config_list/vertical.line.js": __glob_0_23, "./config_list/vertical.line.selected.index.js": __glob_0_24 };
var configs$1 = Object.values(modules$1).map((it) => it.default);
function configs(editor) {
  configs$1.forEach((config) => {
    editor.registerConfig(config);
  });
}
class Selector extends PropertyItem {
  static parse(obj2) {
    return new Selector(obj2);
  }
  getDefaultObject(obj2) {
    return super.getDefaultObject(__spreadValues({
      itemType: "selector",
      selector: "",
      properties: []
    }, obj2));
  }
  toCloneObject() {
    return __spreadValues(__spreadValues({}, super.toCloneObject()), this.attrs("selector", "properties"));
  }
  isMultiStyle(key) {
    switch (key) {
      case "background-image":
      case "var":
        return true;
    }
    return false;
  }
  getMultiStyleString(p) {
    switch (p.key) {
      case "background-image":
        return p.value.toString() + ";";
    }
    return p.value.toString() + " !important;";
  }
  toPropertyString() {
    return this.json.properties.map((p) => {
      if (this.isMultiStyle(p.key)) {
        return this.getMultiStyleString(p);
      } else {
        var value = p.value.toString();
        if (value) {
          var key = p.key;
          if (key === "x")
            key = "left";
          else if (key === "y")
            key = "top";
          return `${key}: ${value} !important;`;
        } else {
          return "";
        }
      }
    }).join("\n");
  }
  toCSSText(prefix = "") {
    return `${prefix}${this.json.selector} {
    ${this.toPropertyString()}
}`;
  }
  toCSS() {
    return {};
  }
  toString(prefix = "") {
    return this.toCSSText(prefix);
  }
}
var DefaultLayoutEngine = {
  startCache(container) {
    container.addCache("cachedSize", {
      width: container.width,
      height: container.height
    });
    container.addCache("cachedLayerMatrix", container.layers.map((child) => {
      child.startToCacheChildren();
      const { x, y, width: width2, height: height2 } = child.attrs("x", "y", "width", "height");
      return {
        id: child.id,
        matrix: { x, y, width: width2, height: height2 },
        constraints: {
          horizontal: child[ConstraintsDirection.HORIZONTAL],
          vertical: child[ConstraintsDirection.VERTICAL]
        }
      };
    }));
  },
  recover(container) {
    const obj2 = {
      width: container.width,
      height: container.height
    };
    const currentContainerWidth = obj2.width;
    const currentContainerHeight = obj2.height;
    const cachedSize = container.getCache("cachedSize");
    const oldContainerWidth = cachedSize.width;
    const oldContainerHeight = cachedSize.height;
    const scaleX = currentContainerWidth / oldContainerWidth;
    const scaleY = currentContainerHeight / oldContainerHeight;
    const cachedLayerMatrix = container.getCache("cachedLayerMatrix");
    cachedLayerMatrix.forEach(({ id, matrix, constraints }) => {
      const item = container.find(id);
      const { x, y, width: width2, height: height2 } = matrix;
      const left2 = x;
      const right2 = oldContainerWidth - x - width2;
      const top2 = y;
      const bottom2 = oldContainerHeight - y - height2;
      const localObj = {};
      switch (constraints.horizontal) {
        case Constraints.MIN:
          localObj.x = left2;
          break;
        case Constraints.MAX:
          localObj.x = currentContainerWidth - right2 - width2;
          break;
        case Constraints.STRETCH:
          localObj.x = left2;
          localObj.width = currentContainerWidth - left2 - right2;
          break;
        case Constraints.SCALE:
          localObj.x = left2 * scaleX;
          localObj.width = width2 * scaleX;
          break;
        case Constraints.CENTER:
          const halfWidth = width2 / 2;
          const scaleNew = (x + halfWidth) / oldContainerWidth;
          localObj.x = scaleNew * currentContainerWidth - halfWidth;
          break;
      }
      switch (constraints.vertical) {
        case Constraints.MIN:
          localObj.y = top2;
          break;
        case Constraints.MAX:
          localObj.y = currentContainerHeight - bottom2 - height2;
          break;
        case Constraints.STRETCH:
          localObj.y = top2;
          localObj.height = currentContainerHeight - top2 - bottom2;
          break;
        case Constraints.SCALE:
          localObj.y = top2 * scaleY;
          localObj.height = height2 * scaleY;
          break;
        case Constraints.CENTER:
          const halfHeight = height2 / 2;
          const scaleNew = (y + halfHeight) / oldContainerHeight;
          localObj.y = scaleNew * currentContainerHeight - halfHeight;
          break;
      }
      item.reset(localObj);
      item.recoverChildren();
    });
  }
};
var GridLayoutEngine = {
  startCache() {
  },
  recover() {
  },
  updateGridArea(currentItem, gridInformation, scale2 = 1) {
    if (currentItem.isInGrid() === false)
      return;
    const lastVerties = currentItem.originVerties;
    const targetRect = vertiesToRectangle(lastVerties);
    const { items } = gridInformation;
    const epsilon = IntersectEpsilonNumberType.RECT / scale2;
    const checkedGridRowColumnList = items.filter((it) => {
      return polyPoly(lastVerties, it.originVerties);
    }).filter((it) => {
      const intersect = intersectRectRect(it.originRect, targetRect);
      return Math.floor(intersect.width) > epsilon && Math.floor(intersect.height) > epsilon;
    });
    if (checkedGridRowColumnList.length === 0)
      return;
    const rows = checkedGridRowColumnList.map((it) => it.row);
    rows.sort((a, b) => a - b);
    const columns = checkedGridRowColumnList.map((it) => it.column);
    columns.sort((a, b) => a - b);
    const gridColumnStart = columns[0];
    const gridColumnEnd = columns[columns.length - 1];
    const gridRowStart = rows[0];
    const gridRowEnd = rows[rows.length - 1];
    const gridArea = {
      "grid-column-start": gridColumnStart,
      "grid-column-end": gridColumnEnd + 1,
      "grid-row-start": gridRowStart,
      "grid-row-end": gridRowEnd + 1
    };
    currentItem.reset(gridArea);
    return gridArea;
  }
};
class Offset extends PropertyItem {
  static parse(obj2) {
    return new Offset(obj2);
  }
  getDefaultObject() {
    return super.getDefaultObject({
      itemType: "offset",
      offset: Length.percent(0),
      color: "rgba(255, 255, 255, 1)",
      properties: []
    });
  }
  toCloneObject() {
    return __spreadValues(__spreadValues({}, super.toCloneObject()), this.attrs("offset", "color", "properties"));
  }
  convert(json) {
    json = super.convert(json);
    json.offset = Length.parse(json.offset);
    return json;
  }
  toCSSText() {
    return `${this.json.offset} ${CSS_TO_STRING(this.toCSS())}`;
  }
  createProperty(data = {}) {
    return this.addProperty(__spreadValues({
      checked: true,
      value: 0
    }, data));
  }
  addProperty(property) {
    this.json.properties.push(property);
  }
  removeProperty(removeIndex) {
    this.json.properties.splice(removeIndex, 1);
  }
  sortItem(arr, startIndex, targetIndex) {
    arr.splice(targetIndex + (startIndex < targetIndex ? -1 : 0), 0, ...arr.splice(startIndex, 1));
  }
  sortProperty(startIndex, targetIndex) {
    this.sortItem(this.json.properties, startIndex, targetIndex);
  }
  updateProperty(index2, data = {}) {
    Object.assign(this.json.properties[+index2], __spreadValues({}, data));
  }
  updatePropertyByKey(key, data = {}) {
    var arr = this.json.properties;
    var index2 = -1;
    for (var i = 0, len2 = arr.length; i < len2; i++) {
      if (this.json.properties[i].key === key) {
        index2 = i;
        break;
      }
    }
    Object.assign(this.json.properties[+index2], __spreadValues({}, data));
  }
  toCSS() {
    var obj2 = {};
    this.json.properties.forEach((it) => {
      obj2 = __spreadValues(__spreadValues({}, obj2), it.toCSS());
    });
    return obj2;
  }
  toString() {
    return this.toCSSText();
  }
}
class Keyframe extends PropertyItem {
  static parse(obj2) {
    return new Keyframe(obj2);
  }
  static parseStyle(style) {
    var keyframes = [];
    var keyframeKeys = {};
    if (style["keyframe"]) {
      var results = convertMatches(style["keyframe"]);
      results.str.split("|").map((it) => it.trim()).forEach((frameInfo, index2) => {
        var [name, offset, property, ...values] = frameInfo.split(" ");
        var propertyValue = values.join(" ");
        if (!keyframeKeys[name]) {
          keyframeKeys[name] = new Keyframe({
            name
          });
          keyframes[index2] = name;
        }
        var filteredOffset = keyframeKeys[name].offsets.filter((it) => {
          return it.offset.equals(Length.parse(offset));
        });
        var offsetObj = null;
        if (filteredOffset.length) {
          offsetObj = filteredOffset[0];
        } else {
          offsetObj = new Offset({
            offset: Length.parse(offset)
          });
          keyframeKeys[name].offsets.push(offsetObj);
        }
        offsetObj.addProperty({
          key: property,
          value: reverseMatches(propertyValue, results.matches)
        });
      });
    }
    return keyframes.map((name) => {
      keyframeKeys[name].offsets.forEach((offset) => {
        var vars = [];
        var properties = [];
        offset.properties.forEach((p) => {
          if (p.key.includes("--")) {
            vars.push(p);
          } else {
            properties.push(p);
          }
        });
        let varValue = vars.map((it) => `${it.key}:${it.value}`).join(";");
        if (vars.length) {
          properties.push({ key: "var", value: varValue });
        }
        offset.properties = properties;
      });
      return keyframeKeys[name];
    });
  }
  getDefaultObject() {
    return super.getDefaultObject({
      itemType: "keyframe",
      name: "sample",
      selectedType: "list",
      offsets: []
    });
  }
  toCloneObject() {
    var { offsets } = this.json;
    return __spreadProps(__spreadValues(__spreadValues({}, super.toCloneObject()), this.attrs("name", "selectedType")), {
      offsets: offsets.map((offset) => offset.clone())
    });
  }
  isMultiStyle(key) {
    switch (key) {
      case "background-image":
      case "var":
        return true;
    }
    return false;
  }
  getMultiStyleString(p) {
    switch (p.key) {
      case "background-image":
        return p.value.toString() + ";";
      case "var":
        var value = (p.value + "").split(";").map((str) => {
          return `--` + str;
        }).join(";");
        return value + ";";
    }
    return p.value.toString() + ";";
  }
  toOffsetString(it) {
    var tabString = "      ";
    return `${it.offset.toString()} {
${tabString}${it.properties.map((p) => {
      if (this.isMultiStyle(p.key)) {
        return this.getMultiStyleString(p);
      } else {
        var value = (p.value || "").toString();
        if (value) {
          var key = p.key;
          if (key === "x")
            key = "left";
          else if (key === "y")
            key = "top";
          return `${key}: ${value};`;
        } else {
          return "";
        }
      }
    }).join("").replace(/;/g, ";\n" + tabString).trim()}
  }`;
  }
  toOffsetText() {
    var offsets = this.json.offsets.map((it) => {
      return it;
    });
    offsets.sort((a, b) => {
      return a.offset.value > b.offset.value ? 1 : -1;
    });
    return offsets.map((it) => {
      if (it.properties.length === 0)
        return "";
      return this.toOffsetString(it);
    }).join("\n");
  }
  toCSSText() {
    var offsets = this.json.offsets.map((it) => {
      return it;
    });
    offsets.sort((a, b) => {
      return a.offset.value > b.offset.value ? 1 : -1;
    });
    return `
@keyframes ${this.json.name} {

  ${this.toOffsetText()}

}
`;
  }
  createOffset(data = {}) {
    return this.addOffset(new Offset(__spreadValues({
      checked: true
    }, data)));
  }
  addOffset(offset) {
    this.json.offsets.push(offset);
  }
  removeOffset(removeIndex) {
    this.json.offsets.splice(removeIndex, 1);
  }
  sortItem(arr, startIndex, targetIndex) {
    arr.splice(targetIndex + (startIndex < targetIndex ? -1 : 0), 0, ...arr.splice(startIndex, 1));
  }
  sortOffset(startIndex, targetIndex) {
    this.sortItem(this.json.offsets, startIndex, targetIndex);
  }
  updateOffset(index2, data = {}) {
    this.json.offsets[+index2].reset(data);
  }
  toCSS() {
    return {};
  }
  toString() {
    return this.toCSSText();
  }
}
class BaseModel {
  constructor(json = {}, modelManager) {
    __privateAdd(this, _modelManager, null);
    __privateAdd(this, _json, {});
    __privateAdd(this, _cachedValue, {});
    __privateAdd(this, _timestamp2, 0);
    __privateAdd(this, _lastChangedField, {});
    __privateAdd(this, _collapsed, false);
    this.setModelManager(modelManager);
    this.initializeModel(json);
  }
  initializeModel(json) {
    __privateSet(this, _json, this.convert(Object.assign(this.getDefaultObject(), json)));
  }
  get manager() {
    return __privateGet(this, _modelManager);
  }
  setModelManager(modelManager) {
    __privateSet(this, _modelManager, modelManager);
  }
  getDefaultTitle() {
    return "Item";
  }
  getIcon() {
    return "";
  }
  isChanged(timestamp) {
    console.log("isChanged", timestamp);
    return this.timestamp != Number(timestamp);
  }
  changed() {
    __privateSet(this, _timestamp2, __privateGet(this, _timestamp2) + Date.now());
  }
  get timestamp() {
    return __privateGet(this, _timestamp2);
  }
  get title() {
    return this.name || this.getDefaultTitle();
  }
  get itemType() {
    return this.get("itemType");
  }
  get name() {
    return this.get("name");
  }
  get children() {
    return this.get("children");
  }
  get collapsed() {
    return __privateGet(this, _collapsed);
  }
  set collapsed(value) {
    __privateSet(this, _collapsed, value);
  }
  renameWithCount() {
    let arr = __privateGet(this, _json).name.split(" ");
    if (arr.length < 2) {
      return;
    }
    let last = arr.pop();
    let lastNumber = +last;
    if (isNumber(lastNumber) && isNaN(lastNumber) === false) {
      lastNumber++;
    } else {
      lastNumber = last;
    }
    const nextName = [...arr, lastNumber].join(" ");
    this.reset({
      name: nextName
    });
  }
  get allLayers() {
    return this.manager.getAllLayers(this.id);
  }
  get layers() {
    return this.manager.getLayers(this.id) || [];
  }
  filteredAllLayers(filterCallback) {
    return this.manager.getAllLayers(this.id, filterCallback);
  }
  get id() {
    return __privateGet(this, _json).id;
  }
  get parentId() {
    const parentId = __privateGet(this, _json).parentId;
    if (parentId === this.id)
      return void 0;
    return parentId;
  }
  get parent() {
    if (!this.parentId)
      return void 0;
    return this.manager.get(this.parentId);
  }
  get depth() {
    return this.manager.getDepth(this.id);
  }
  get top() {
    return this.manager.getRoot(this.id);
  }
  get project() {
    return this.manager.getProject(this.id);
  }
  get artboard() {
    return this.manager.getArtBoard(this.id);
  }
  get path() {
    return this.manager.getPath(this.id);
  }
  get pathIds() {
    return this.path.map((it) => it.id);
  }
  setParentId(parentId) {
    this.reset({ parentId });
    this.manager.setChanged("setParentId", this.id, { parentId });
  }
  get childrenLength() {
    return __privateGet(this, _json).children.length;
  }
  get index() {
    return this.parent.findIndex(this);
  }
  get isFirst() {
    return this.index === 0;
  }
  get isLast() {
    return this.index === this.parent.childrenLength - 1;
  }
  get first() {
    return this.parent.layers[0];
  }
  get last() {
    const parent = this.parent;
    return parent.layers[parent.childrenLength - 1];
  }
  get prev() {
    const index2 = this.index;
    if (this.isFirst) {
      return this;
    }
    return this.parent.layers[index2 - 1];
  }
  get next() {
    const index2 = this.index;
    if (this.isLast) {
      return this;
    }
    return this.parent.layers[index2 + 1];
  }
  get hierarchy() {
    return this.getInformationForHierarchy("x", "y", "angle");
  }
  getInformationForHierarchy(...args2) {
    const parent = this.parent;
    const index2 = this.index;
    return {
      id: this.id,
      index: index2,
      parentId: this.parentId,
      prev: index2 === 0 ? void 0 : parent.children[index2 - 1],
      next: index2 === parent.childrenLength - 1 ? void 0 : parent.children[index2 + 1],
      attrs: this.attrs(...args2)
    };
  }
  getInnerId(postfix = "") {
    return __privateGet(this, _json).id + postfix;
  }
  is(checkItemType) {
    return __privateGet(this, _json).itemType === checkItemType;
  }
  isNot(checkItemType) {
    return this.is(checkItemType) === false;
  }
  get(key) {
    return __privateGet(this, _json)[key];
  }
  removeField(key) {
    delete __privateGet(this, _json)[key];
  }
  set(key, value) {
    this.reset({ [key]: value });
  }
  isSVG() {
    return false;
  }
  addCache(key, value) {
    __privateGet(this, _cachedValue)[key] = value;
  }
  getCache(key) {
    return __privateGet(this, _cachedValue)[key];
  }
  hasCache(key) {
    return Boolean(__privateGet(this, _cachedValue)[key]);
  }
  computed(key, newValueCallback, isForce = false) {
    const cachedKey = `__cachedKey_${key}`;
    const parsedKey = `${cachedKey}__parseValue`;
    const value = __privateGet(this, _json)[key];
    if (isForce)
      ;
    else {
      if (this.getCache(cachedKey) === value && this.getCache(parsedKey)) {
        return this.getCache(parsedKey);
      }
    }
    this.addCache(cachedKey, value);
    this.addCache(parsedKey, newValueCallback(value, this));
    return this.getCache(parsedKey);
  }
  computedValue(key) {
    const cachedKey = `__cachedKey_${key}`;
    const parsedKey = `${cachedKey}__parseValue`;
    return this.getCache(parsedKey);
  }
  editable() {
    return true;
  }
  generateListNumber() {
    this.layers.forEach((it, index2) => {
      it.no = index2;
      it.generateListNumber();
    });
  }
  convert(json = {}) {
    return json;
  }
  setCache() {
  }
  toCloneObject(isDeep = true) {
    const json = {};
    Object.keys(__privateGet(this, _json)).forEach((field) => {
      if (isNotUndefined(this.get(field))) {
        json[field] = clone$1(this.get(field));
      }
    });
    if (isDeep) {
      json.layers = this.layers.map((layer) => {
        return layer.clone(isDeep);
      });
    }
    return json;
  }
  clone(isDeep = true) {
    return __privateGet(this, _modelManager).clone(this.id, isDeep);
  }
  reset(obj2, context = { origin: "*" }) {
    var _a;
    __privateSet(this, _json, this.convert(Object.assign(__privateGet(this, _json), obj2)));
    __privateSet(this, _lastChangedField, obj2);
    if (context.origin === "*") {
      (_a = __privateGet(this, _modelManager)) == null ? void 0 : _a.setChanged("reset", this.id, obj2);
    }
    this.changed();
    return true;
  }
  hasChangedField(...args2) {
    return args2.some((it) => __privateGet(this, _lastChangedField)[it] !== void 0);
  }
  get hasChangedHirachy() {
    return this.hasChangedField("children", "parentId");
  }
  getDefaultObject(obj2 = {}) {
    var id = obj2.id || uuid();
    return __spreadValues({
      id,
      name: "",
      itemType: "base",
      children: [],
      parentId: ""
    }, obj2);
  }
  attrs(...args2) {
    const result = {};
    args2.forEach((field) => {
      if (isNotUndefined(this.get(field))) {
        result[field] = clone$1(this.get(field));
      }
    });
    return result;
  }
  attrsWithId(...args2) {
    return {
      [this.id]: this.attrs(...args2)
    };
  }
  hasChildren() {
    return this.children.length > 0;
  }
  appendChild(layer) {
    if (layer.parentId === this.id) {
      const hasId = this.children.find((it) => it === layer.id);
      if (Boolean(hasId) === false) {
        this.children.push(layer.id);
        __privateGet(this, _modelManager).setChanged("appendChild", this.id, {
          child: layer.id,
          oldParentId: layer.parentId
        });
      }
      return layer;
    }
    this.resetMatrix(layer);
    if (layer.parent) {
      layer.remove();
    }
    layer.setParentId(this.id);
    this.children.push(layer.id);
    return layer;
  }
  resetMatrix() {
  }
  refreshMatrixCache() {
  }
  insertChild(layer, index2 = 0) {
    var _a;
    this.resetMatrix(layer);
    if (layer.parent && ((_a = layer.parent) == null ? void 0 : _a.id) !== this.id) {
      layer.remove();
    }
    layer.setParentId(this.id);
    let list2 = this.children.map((id, childIndex) => {
      return { id, index: childIndex };
    });
    const childItem = list2.find((it) => it.id === layer.id);
    const targetIndex = index2 - 0.5;
    if (childItem) {
      childItem.index = targetIndex;
    } else {
      list2.push({ id: layer.id, index: targetIndex });
    }
    list2.sort((a, b) => {
      return a.index - b.index;
    });
    this.reset({
      children: list2.map((it) => it.id)
    });
    __privateGet(this, _modelManager).setChanged("insertChild", this.id, {
      childId: layer.id,
      index: 0
    });
    return layer;
  }
  insertAfter(layer) {
    this.parent.insertChild(layer, this.index + 1);
    return layer;
  }
  insertBefore(layer) {
    this.parent.insertChild(layer, this.index);
    return layer;
  }
  toggle(field, toggleValue) {
    if (isUndefined(toggleValue)) {
      this.reset({
        [field]: !this.get(field)
      });
    } else {
      this.reset({
        [field]: !!toggleValue
      });
    }
  }
  isTreeItemHide() {
    let currentParent = this.parent;
    let collapsedList = [];
    do {
      if (currentParent.is("project"))
        break;
      collapsedList.push(Boolean(currentParent.collapsed));
      currentParent = currentParent.parent;
    } while (currentParent);
    return Boolean(collapsedList.filter(Boolean).length);
  }
  expectJSON(key) {
    if (isUndefined(this.get(key)))
      return false;
    return true;
  }
  toJSON() {
    const json = __privateGet(this, _json);
    let newJSON = {};
    Object.keys(json).filter((key) => this.expectJSON(key)).forEach((key) => {
      newJSON[key] = json[key];
    });
    if (this.hasChildren()) {
      newJSON.layers = this.layers.map((layer) => {
        return layer.toJSON();
      });
    }
    return newJSON;
  }
  resize() {
  }
  copy(dist2 = 0) {
    return this.parent.copyItem(this.id, dist2);
  }
  findIndex(child) {
    return this.children.indexOf(child.id);
  }
  find(id) {
    return __privateGet(this, _modelManager).get(id);
  }
  copyItem(childItemId, dist2 = 10) {
    const childItem = this.find(childItemId);
    var child = childItem.clone();
    child.renameWithCount();
    child.absoluteMove([dist2, dist2, 0]);
    var childIndex = this.findIndex(childItem);
    if (childIndex > -1) {
      this.children.push(child.id);
    }
    return child;
  }
  remove() {
    this.parent.removeChild(this.id);
  }
  removeChild(childItemId) {
    return __privateGet(this, _modelManager).removeChild(this.id, childItemId);
  }
  hasParent(parentId) {
    return __privateGet(this, _modelManager).hasParent(this.id, parentId);
  }
  hasChild(childId) {
    return this.children.includes(childId);
  }
  to() {
  }
  sendBackward(targetId) {
    const siblings = this.children;
    const result = {};
    let selectedIndex = -1;
    siblings.forEach((id, index2) => {
      result[id] = { id, index: index2 };
      if (id === targetId) {
        selectedIndex = index2;
      }
    });
    result[targetId].index = selectedIndex - 1.5;
    const children2 = Object.values(result).sort((a, b) => a.index - b.index).map((it) => it.id);
    this.reset({
      children: children2
    });
  }
  sendBack(targetId) {
    const siblings = this.children;
    const result = {};
    siblings.forEach((id, index2) => {
      result[id] = { id, index: index2 };
    });
    result[targetId].index = -1;
    const children2 = Object.values(result).sort((a, b) => a.index - b.index).map((it) => it.id);
    this.reset({
      children: children2
    });
  }
  bringForward(targetId) {
    const siblings = this.children;
    const result = {};
    let selectedIndex = -1;
    siblings.forEach((id, index2) => {
      result[id] = { id, index: index2 };
      if (id === targetId) {
        selectedIndex = index2;
      }
    });
    result[targetId].index = selectedIndex + 1.5;
    const children2 = Object.values(result).sort((a, b) => a.index - b.index).map((it) => it.id);
    this.reset({
      children: children2
    });
  }
  bringFront(targetId) {
    const siblings = this.children;
    const result = {};
    siblings.forEach((id, index2) => {
      result[id] = { id, index: index2 };
    });
    result[targetId].index = Number.MAX_SAFE_INTEGER;
    const children2 = Object.values(result).sort((a, b) => a.index - b.index).map((it) => it.id);
    this.reset({
      children: children2
    });
  }
}
_modelManager = new WeakMap();
_json = new WeakMap();
_cachedValue = new WeakMap();
_timestamp2 = new WeakMap();
_lastChangedField = new WeakMap();
_collapsed = new WeakMap();
class BaseAssetModel extends BaseModel {
  getDefaultObject(obj2 = {}) {
    return super.getDefaultObject(__spreadValues({
      svgfilters: [],
      keyframes: []
    }, obj2));
  }
  get keyframes() {
    return this.get("keyframes");
  }
  get svgfilters() {
    return this.get("svgfilters");
  }
  addKeyframe(keyframe2) {
    this.keyframes.push(keyframe2);
    return keyframe2;
  }
  createKeyframe(data = {}) {
    return this.addKeyframe(new Keyframe(__spreadValues({
      checked: true
    }, data)));
  }
  removeKeyframe(removeIndex) {
    this.removePropertyList(this.keyframes, removeIndex);
  }
  sortItem(arr, startIndex, targetIndex) {
    arr.splice(targetIndex + (startIndex < targetIndex ? -1 : 0), 0, ...arr.splice(startIndex, 1));
  }
  sortKeyframe(startIndex, targetIndex) {
    this.sortItem(this.keyframes, startIndex, targetIndex);
  }
  updateKeyframe(index2, data = {}) {
    this.keyframes[+index2].reset(data);
  }
  toKeyframeString(isAnimate = false) {
    return this.keyframes.map((keyframe2) => keyframe2.toString(isAnimate)).join("\n\n");
  }
  copyPropertyList(arr, index2) {
    var copyObject = __spreadValues({}, arr[index2]);
    arr.splice(index2, 0, copyObject);
  }
  removePropertyList(arr, removeIndex) {
    arr.splice(removeIndex, 1);
  }
  getSVGFilterIndex(id) {
    var _a;
    var filter2 = this.svgfilters.map((it, index2) => {
      return { id: it.id, index: index2 };
    }).filter((it) => {
      return it.id === id;
    });
    return filter2.length ? (_a = filter2 == null ? void 0 : filter2[0]) == null ? void 0 : _a.index : -1;
  }
  removeSVGFilter(removeIndex) {
    this.removePropertyList(this.svgfilters, removeIndex);
  }
  copySVGFilter(index2) {
    this.copyPropertyList(this.svgfilters, index2);
  }
  sortSVGFilter(startIndex, targetIndex) {
    this.sortItem(this.svgfilters, startIndex, targetIndex);
  }
  setSVGFilterValue(index2, value) {
    this.svgfilters[index2] = __spreadValues(__spreadValues({}, this.svgfilters[index2]), value);
  }
  addSVGFilter(obj2 = {}) {
    this.svgfilters.push(obj2);
    var index2 = this.svgfilters.length - 1;
    return index2;
  }
  createSVGFilter(data = {}) {
    return this.addSVGFilter(__spreadValues({
      id: uuidShort()
    }, data));
  }
}
class MovableModel extends BaseAssetModel {
  getDefaultObject(obj2 = {}) {
    return super.getDefaultObject(__spreadValues({
      angle: 0,
      x: 0,
      y: 0,
      width: 300,
      height: 300,
      position: "absolute",
      perspective: "",
      perspectiveOrigin: "",
      transformOrigin: "50% 50% 0px"
    }, obj2));
  }
  get isAbsolute() {
    return this.position === "absolute";
  }
  get isDragSelectable() {
    return true;
  }
  get isBooleanItem() {
    return void 0;
  }
  get resizableWitChildren() {
    return false;
  }
  get perspective() {
    return this.get("perspective");
  }
  get perspectiveOrigin() {
    return this.get("perspectiveOrigin");
  }
  get transform() {
    return `rotateZ(${Length.deg(this.angle)})`;
  }
  get localMatrix() {
    if (!this.hasCache("localTransform")) {
      this.addCache("localTransform", this.getLocalTransformMatrix());
    }
    return this.getCache("localTransform") || this.getLocalTransformMatrix();
  }
  get localMatrixInverse() {
    if (!this.hasCache("localTransformInverse")) {
      this.addCache("localTransformInverse", this.getLocalTransformMatrixInverse());
    }
    return this.getCache("localTransformInverse") || this.getLocalTransformMatrixInverse();
  }
  get transformWithTranslate() {
    if (!this.hasCache("transformWithTranslate")) {
      this.addCache("transformWithTranslate", this.getTransformWithTranslate(this));
    }
    return this.getCache("transformWithTranslate") || this.getTransformWithTranslate(this);
  }
  get transformWithTranslateToTranspose() {
    if (!this.hasCache("transformWithTranslateTranspose")) {
      this.addCache("transformWithTranslateTranspose", this.getTransformWithTranslate(this));
    }
    return this.getCache("transformWithTranslateTranspose") || transpose([], this.getTransformWithTranslate(this));
  }
  get transformWithTranslateInverse() {
    if (!this.hasCache("transformWithTranslateInverse")) {
      this.addCache("transformWithTranslateInverse", this.getTransformWithTranslate(this));
    }
    return this.getCache("transformWithTranslateInverse") || invert([], this.getTransformWithTranslate(this));
  }
  get itemMatrix() {
    if (!this.hasCache("itemTransform")) {
      this.addCache("itemTransform", this.getItemTransformMatrix());
    }
    return this.getCache("itemTransform") || this.getItemTransformMatrix();
  }
  get itemMatrixInverse() {
    if (!this.hasCache("itemTransformInverse")) {
      this.addCache("itemTransformInverse", this.getItemTransformMatrixInverse());
    }
    return this.getCache("itemTransformInverse") || this.getItemTransformMatrixInverse();
  }
  get absoluteMatrix() {
    if (!this.hasCache("absoluteMatrix")) {
      this.addCache("absoluteMatrix", this.getAbsoluteMatrix());
    }
    return this.getCache("absoluteMatrix") || this.getAbsoluteMatrix();
  }
  get absoluteMatrixInverse() {
    if (!this.hasCache("absoluteMatrixInverse")) {
      this.addCache("absoluteMatrixInverse", this.getAbsoluteMatrixInverse());
    }
    return this.getCache("absoluteMatrixInverse") || this.getAbsoluteMatrixInverse();
  }
  get relativeMatrix() {
    if (!this.hasCache("relativeMatrix")) {
      this.addCache("relativeMatrix", this.getRelativeMatrix());
    }
    return this.getCache("relativeMatrix") || this.getRelativeMatrix();
  }
  get relativeMatrixInverse() {
    if (!this.hasCache("relativeMatrixInverse")) {
      this.addCache("relativeMatrixInverse", this.getRelativeMatrixInverse());
    }
    return this.getCache("relativeMatrixInverse") || this.getRelativeMatrixInverse();
  }
  get verties() {
    if (!this.hasCache("verties")) {
      this.addCache("verties", this.getVerties());
    }
    return this.getCache("verties") || this.getVerties();
  }
  get contentVerties() {
    if (!this.hasCache("contentVerties")) {
      this.addCache("contentVerties", this.getContentVerties());
    }
    return this.getCache("contentVerties") || this.getContentVerties();
  }
  get originVerties() {
    if (!this.hasCache("vertiesWithoutTransformOrigin")) {
      this.addCache("vertiesWithoutTransformOrigin", this.rectVerties());
    }
    return this.getCache("vertiesWithoutTransformOrigin") || this.rectVerties();
  }
  get localVerties() {
    if (!this.hasCache("localVerties")) {
      this.addCache("localVerties", this.getLocalVerties());
    }
    return this.getCache("localVerties") || this.getLocalVerties();
  }
  get guideVerties() {
    if (!this.hasCache("guideVerties")) {
      this.addCache("guideVerties", this.getGuideVerties());
    }
    return this.getCache("guideVerties") || this.getGuideVerties();
  }
  get xList() {
    if (!this.hasCache("xList")) {
      this.addCache("xList", this.getXList());
    }
    return this.getCache("xList") || this.getXList();
  }
  get yList() {
    if (!this.hasCache("yList")) {
      this.addCache("yList", this.getYList());
    }
    return this.getCache("yList") || this.getYList();
  }
  get areaPosition() {
    if (!this.hasCache("areaPosition")) {
      this.addCache("areaPosition", this.getAreaPosition(100));
    }
    return this.getCache("areaPosition") || this.getAreaPosition(100);
  }
  get offsetX() {
    return this.x;
  }
  get offsetY() {
    return this.y;
  }
  get screenWidth() {
    return this.width;
  }
  get screenHeight() {
    return this.height;
  }
  get y() {
    return this.get("y");
  }
  set y(value) {
    this.set("y", value);
  }
  get x() {
    return this.get("x");
  }
  set x(value) {
    this.set("x", value);
  }
  get width() {
    return this.get("width");
  }
  set width(value) {
    this.set("width", value);
  }
  get height() {
    return this.get("height");
  }
  set height(value) {
    this.set("height", value);
  }
  get angle() {
    return this.get("angle");
  }
  set angle(value) {
    this.set("angle", value);
  }
  get position() {
    return this.get("position");
  }
  set position(value) {
    this.set("position", value);
  }
  get transformOrigin() {
    return this.get("transformOrigin");
  }
  set transformOrigin(value) {
    this.reset({
      transformOrigin: value
    });
  }
  get translate() {
    return [0, 0, 0];
  }
  get scale() {
    return [1, 1, 1];
  }
  get rotate() {
    return [0, 0, degreeToRadian(this.angle)];
  }
  get origin() {
    return TransformOrigin.scale(this.transformOrigin || "50% 50% 0px", this.screenWidth, this.screenHeight);
  }
  get absoluteOrigin() {
    return vertiesMap([this.origin], this.absoluteMatrix)[0];
  }
  get quat() {
    return fromEuler(create$1(), 0, 0, this.angle);
  }
  getAreaPosition(areaSize = 100) {
    const verties = this.getVerties();
    const rect2 = toRectVerties(verties);
    const [startRow, startColumn] = area$1(rect2[0][0], rect2[0][1], areaSize);
    const [endRow, endColumn] = area$1(rect2[2][0], rect2[2][1], areaSize);
    return {
      column: [startColumn, endColumn],
      row: [startRow, endRow]
    };
  }
  reset(obj2, context = { origin: "*" }) {
    const isChanged = super.reset(obj2, context);
    if (this.hasChangedField("children", "x", "y", "width", "height", "boxModel", "angle", "transformOrigin", "resizingVertical", "resizingHorizontal", "contraintsVertical", "contraintsHorizontal") || this.changedLayout) {
      this.refreshMatrixCache();
    }
    return isChanged;
  }
  changed() {
    super.changed();
    this.changedRect = this.hasChangedField("children", "x", "y", "width", "height", "angle", "transformOrigin", "resizingVertical", "resizingHorizontal", "contraintsVertical", "contraintsHorizontal");
  }
  setParentId(otherParentId) {
    super.setParentId(otherParentId);
    this.refreshMatrixCache();
  }
  refreshMatrixCache() {
    this.setCacheItemTransformMatrix();
    this.setCacheLocalTransformMatrix();
    this.setCacheAbsoluteMatrix();
    this.setCacheLocalVerties();
    this.setCacheVerties();
    this.setCacheGuideVerties();
    this.setCacheAreaPosition();
    this.layers.forEach((it) => {
      it.refreshMatrixCache();
    });
  }
  setCacheItemTransformMatrix() {
    this.addCache("itemTransform", this.getItemTransformMatrix());
    this.addCache("itemTransformInverse", invert([], this.getCache("itemTransform")));
  }
  setCacheLocalTransformMatrix() {
    this.addCache("localTransform", this.getLocalTransformMatrix());
    this.addCache("localTransformInverse", invert([], this.getCache("localTransform")));
    this.addCache("transformWithTranslate", this.getTransformWithTranslate(this));
    this.addCache("transformWithTranslateInverse", invert([], this.getCache("transformWithTranslate")));
    this.addCache("transformWithTranslateTranspose", transpose([], this.getCache("transformWithTranslate")));
  }
  setCacheAbsoluteMatrix() {
    this.addCache("absoluteMatrix", this.getAbsoluteMatrix());
    this.addCache("absoluteMatrixInverse", invert([], this.getCache("absoluteMatrix")));
    this.addCache("relativeMatrix", this.getRelativeMatrix());
    this.addCache("relativeMatrixInverse", invert([], this.getCache("relativeMatrix")));
  }
  setCacheVerties() {
    this.addCache("verties", this.getVerties());
    this.addCache("contentVerties", this.getContentVerties());
    this.addCache("vertiesWithoutTransformOrigin", this.rectVerties());
  }
  setCacheLocalVerties() {
    this.addCache("localVerties", this.getLocalVerties());
  }
  setCacheGuideVerties() {
    this.addCache("guideVerties", this.getGuideVerties());
    this.addCache("xList", this.getXList());
    this.addCache("yList", this.getYList());
  }
  setCacheAreaPosition() {
    this.addCache("areaPosition", this.getAreaPosition(100));
  }
  move(distVector = [0, 0, 0]) {
    this.reset({
      x: round(this.offsetX + distVector[0]),
      y: round(this.offsetY + distVector[1])
    });
  }
  moveByCenter(newCenter = [0, 0, 0]) {
    this.reset({
      x: newCenter[0] - this.screenWidth / 2,
      y: newCenter[1] - this.screenHeight / 2
    });
  }
  absoluteMove(absoluteDist = [0, 0, 0]) {
    var _a;
    const oldVertex = this.verties[4];
    const newVertex = add$1([], oldVertex, absoluteDist);
    const newVerties = vertiesMap([oldVertex, newVertex], ((_a = this.parent) == null ? void 0 : _a.absoluteMatrixInverse) || identity$3([]));
    const newDist = subtract([], newVerties[1], newVerties[0]);
    const oldPosition = this.attrs("x", "y");
    this.move(newDist);
    return oldPosition;
  }
  startToCacheChildren() {
  }
  recoverChildren() {
  }
  resize(width2, height2) {
    this.startToCacheChildren();
    this.reset({ width: width2, height: height2 });
    this.recoverChildren();
  }
  setAngle(angle = 0) {
    this.reset({
      angle
    });
  }
  addAngle(angle = 0) {
    this.setAngle(this.angle + angle);
  }
  checkInArea(areaVerties) {
    return polyPoly(areaVerties, this.originVerties);
  }
  hasPoint(x, y) {
    return this.isPointInRect(x, y);
  }
  isPointInRect(x, y) {
    return polyPoint(this.originVerties, x, y);
  }
  isIncludeByArea(areaVerties) {
    return this.originVerties.map((vector) => {
      return polyPoint(areaVerties, ...vector);
    }).filter(Boolean).length === 4;
  }
  getPerspectiveMatrix() {
    const hasPerspective = this.perspective;
    if (!hasPerspective) {
      return void 0;
    }
    let [
      perspectiveOriginX = Length.percent(50),
      perspectiveOriginY = Length.percent(50)
    ] = TransformOrigin.parseStyle(this.perspectiveOrigin);
    const width2 = this.screenWidth;
    const height2 = this.screenHeight;
    perspectiveOriginX = perspectiveOriginX.toPx(width2).value;
    perspectiveOriginY = perspectiveOriginY.toPx(height2).value;
    const view = create$4();
    translate(view, view, [perspectiveOriginX, perspectiveOriginY, 0]);
    if (this.perspective && this.perspective != "none") {
      multiply$1(view, view, fromValues$1(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, -1 / Length.parse(this.perspective).value, 1));
    } else {
      return void 0;
    }
    translate(view, view, [-perspectiveOriginX, -perspectiveOriginY, 0]);
    return view;
  }
  getItemTransformMatrix() {
    const list2 = Transform.parseStyle(this.transform);
    const width2 = this.screenWidth;
    const height2 = this.screenHeight;
    return Transform.createTransformMatrix(list2, width2, height2);
  }
  getItemTransformMatrixInverse() {
    return invert([], this.getItemTransformMatrix());
  }
  getLocalTransformMatrix(width2, height2) {
    const origin = TransformOrigin.scale(this.transformOrigin || "50% 50% 0px", isUndefined(width2) ? this.screenWidth : width2, isUndefined(height2) ? this.screenHeight : height2);
    const view = create$4();
    translate(view, view, origin);
    multiply$1(view, view, this.itemMatrix);
    translate(view, view, negate([], origin));
    return view;
  }
  getLocalTransformMatrixInverse(width2, height2) {
    return invert([], this.getLocalTransformMatrix(width2, height2));
  }
  getDirectionTransformMatrix(vertexOffset, width2, height2) {
    const x = this.offsetX;
    const y = this.offsetY;
    const center2 = add$1([], TransformOrigin.scale(this.transformOrigin || "50% 50% 0px", width2, height2), negate([], vertexOffset));
    const view = create$4();
    translate(view, view, [x, y, 0]);
    translate(view, view, vertexOffset);
    translate(view, view, center2);
    multiply$1(view, view, this.itemMatrix);
    translate(view, view, negate([], center2));
    return view;
  }
  getDirectionTopLeftMatrix(width2, height2) {
    return this.getDirectionTransformMatrix([0, 0, 0], width2, height2);
  }
  getDirectionLeftMatrix(width2, height2) {
    return this.getDirectionTransformMatrix([0, height2 / 2, 0], width2, height2);
  }
  getDirectionTopMatrix(width2, height2) {
    return this.getDirectionTransformMatrix([width2 / 2, 0, 0], width2, height2);
  }
  getDirectionBottomLeftMatrix(width2, height2) {
    return this.getDirectionTransformMatrix([0, height2, 0], width2, height2);
  }
  getDirectionTopRightMatrix(width2, height2) {
    return this.getDirectionTransformMatrix([width2, 0, 0], width2, height2);
  }
  getDirectionRightMatrix(width2, height2) {
    return this.getDirectionTransformMatrix([width2, height2 / 2, 0], width2, height2);
  }
  getDirectionBottomRightMatrix(width2, height2) {
    return this.getDirectionTransformMatrix([width2, height2, 0], width2, height2);
  }
  getDirectionBottomMatrix(width2, height2) {
    return this.getDirectionTransformMatrix([width2 / 2, height2, 0], width2, height2);
  }
  getAbsoluteMatrix() {
    let transform2 = create$4();
    if (this.parent) {
      multiply$1(transform2, transform2, this.parent.absoluteMatrix);
      if (isFunction(this.parent.getPerspectiveMatrix)) {
        const perspectiveMatrix = this.parent.getPerspectiveMatrix();
        if (perspectiveMatrix) {
          multiply$1(transform2, transform2, perspectiveMatrix);
        }
      }
    }
    multiply$1(transform2, transform2, this.getRelativeMatrix());
    if (transform2.filter((it) => !isNaN(it)).length === 0) {
      return create$4();
    }
    return transform2;
  }
  getRelativeMatrix() {
    let transform2 = create$4();
    const offsetX = this.offsetX;
    const offsetY = this.offsetY;
    translate(transform2, transform2, [offsetX, offsetY, 0]);
    multiply$1(transform2, transform2, this.localMatrix);
    return transform2;
  }
  getRelativeMatrixInverse() {
    return invert([], this.getRelativeMatrix());
  }
  getTransformWithTranslate(item) {
    item = item || this;
    let view = create$4();
    const offsetX = item.offsetX;
    const offsetY = item.offsetY;
    translate(view, view, [offsetX, offsetY, 0]);
    multiply$1(view, view, item.localMatrix);
    return view;
  }
  getAbsoluteMatrixInverse() {
    return invert([], this.getAbsoluteMatrix());
  }
  getLocalVerties(width2, height2) {
    width2 = isNotUndefined(width2) ? width2 : this.screenWidth;
    height2 = isNotUndefined(height2) ? height2 : this.screenHeight;
    let model = rectToVerties(0, 0, width2, height2, this.transformOrigin);
    return model;
  }
  getVerties(width2, height2) {
    width2 = isNotUndefined(width2) ? width2 : this.screenWidth;
    height2 = isNotUndefined(height2) ? height2 : this.screenHeight;
    let x = 0;
    let y = 0;
    if (this.parent && this.parent.is("project") === false) {
      const contentBox = this.parent.contentBox;
      x = contentBox.x;
      y = contentBox.y;
    }
    let model = rectToVerties(x, y, width2, height2, this.transformOrigin);
    return vertiesMap(model, this.absoluteMatrix);
  }
  getContentVerties(width2, height2) {
    width2 = isNotUndefined(width2) ? width2 : this.screenWidth;
    height2 = isNotUndefined(height2) ? height2 : this.screenHeight;
    const center2 = TransformOrigin.scale(this.transformOrigin, width2, height2);
    const paddingTop = this.get("padding-top") || 0;
    const paddingRight = this.get("padding-right") || 0;
    const paddingBottom = this.get("padding-bottom") || 0;
    const paddingLeft = this.get("padding-left") || 0;
    const model = rectToVerties(0 + paddingLeft, 0 + paddingTop, width2 - paddingLeft - paddingRight, height2 - paddingTop - paddingBottom, this.transformOrigin);
    model[4] = center2;
    return vertiesMap(model, this.absoluteMatrix);
  }
  rectVerties() {
    return this.verties.filter((_, index2) => index2 < 4);
  }
  getGuideVerties() {
    const verties = this.originVerties;
    return [
      ...verties,
      lerp$1([], verties[0], verties[1], 0.5),
      lerp$1([], verties[1], verties[2], 0.5),
      lerp$1([], verties[2], verties[3], 0.5),
      lerp$1([], verties[3], verties[0], 0.5)
    ];
  }
  getXList() {
    return [...new Set(this.guideVerties.map((it) => it[0]))];
  }
  getYList() {
    return [...new Set(this.guideVerties.map((it) => it[1]))];
  }
  get nestedAngle() {
    if (this.parent) {
      return this.parent.nestedAngle + this.angle;
    }
    return this.angle || 0;
  }
  get toRectVerties() {
    return itemsToRectVerties([this]);
  }
  get matrix() {
    const id = this.id;
    const x = this.offsetX;
    const y = this.offsetY;
    const width2 = this.screenWidth;
    const height2 = this.screenHeight;
    const originalTransform = this.transform;
    const originalTransformOrigin = this.transformOrigin || "50% 50% 0px";
    const transformOriginMatrix = this.getTransformOriginMatrix();
    const transformOriginMatrixInverse = this.getTransformOriginMatrixInverse();
    const parentMatrix = this.parent.absoluteMatrix;
    const parentMatrixInverse = this.parent.absoluteMatrixInverse;
    const localMatrix = this.localMatrix;
    const localMatrixInverse = this.localMatrixInverse;
    const itemMatrix = this.itemMatrix;
    const itemMatrixInverse = this.itemMatrixInverse;
    const absoluteMatrix = this.absoluteMatrix;
    const absoluteMatrixInverse = this.absoluteMatrixInverse;
    const relativeMatrix = this.relativeMatrix;
    const relativeMatrixInverse = this.relativeMatrixInverse;
    const directionMatrix = {
      "to top left": this.getDirectionTopLeftMatrix(width2, height2),
      "to top": this.getDirectionTopMatrix(width2, height2),
      "to top right": this.getDirectionTopRightMatrix(width2, height2),
      "to right": this.getDirectionRightMatrix(width2, height2),
      "to bottom left": this.getDirectionBottomLeftMatrix(width2, height2),
      "to bottom": this.getDirectionBottomMatrix(width2, height2),
      "to bottom right": this.getDirectionBottomRightMatrix(width2, height2),
      "to left": this.getDirectionLeftMatrix(width2, height2)
    };
    const verties = this.verties;
    const xList = verties.map((it) => it[0]);
    const yList = verties.map((it) => it[1]);
    return {
      id,
      x,
      y,
      width: width2,
      height: height2,
      transform: originalTransform,
      originalTransformOrigin,
      verties,
      originVerties: this.originVerties,
      xList,
      yList,
      directionMatrix,
      parentMatrix,
      parentMatrixInverse,
      localMatrix,
      localMatrixInverse,
      itemMatrix,
      itemMatrixInverse,
      absoluteMatrix,
      absoluteMatrixInverse,
      relativeMatrix,
      relativeMatrixInverse,
      transformOriginMatrix,
      transformOriginMatrixInverse
    };
  }
  absolutePath(pathString2 = "") {
    const d = pathString2 || this.d;
    const pathParser = new PathParser(d);
    pathParser.transformMat4(this.absoluteMatrix);
    return pathParser;
  }
  invertPath(pathString2 = "") {
    const path = new PathParser(pathString2);
    path.transformMat4(this.absoluteMatrixInverse);
    return path;
  }
  invertPoint(point2) {
    return transformMat4([], point2, this.absoluteMatrixInverse);
  }
  invertPathString(pathString2 = "") {
    return this.invertPath(pathString2).d;
  }
  updatePath(d) {
    const matrix = this.matrix;
    const newPath = new PathParser(d);
    let bbox = newPath.getBBox();
    const newWidth = distance$1(bbox[1], bbox[0]);
    const newHeight = distance$1(bbox[3], bbox[0]);
    let oldBBox = vertiesMap(rectToVerties(bbox[0][0], bbox[0][1], newWidth, newHeight), matrix.absoluteMatrix);
    let newBBox = vertiesMap(oldBBox, calculateMatrixInverse(fromTranslation([], oldBBox[4]), Transform.createTransformMatrix(Transform.parseStyle(matrix.transform), newWidth, newHeight), fromTranslation([], negate([], oldBBox[4]))));
    const worldMatrix = calculateMatrix(fromTranslation([], newBBox[0]), this.getLocalTransformMatrix(newWidth, newHeight));
    const realXY = getTranslation([], calculateMatrix(matrix.parentMatrixInverse, worldMatrix, invert([], this.getLocalTransformMatrix(newWidth, newHeight))));
    return {
      d: newPath.translate(-bbox[0][0], -bbox[0][1]).d,
      x: realXY[0],
      y: realXY[1],
      width: newWidth,
      height: newHeight
    };
  }
  checkInAreaForAll(areaVerties) {
    const items = [...this.checkInAreaForLayers(areaVerties)];
    if (this.is("artboard"))
      return items;
    if (this.is("project"))
      return items;
    if (this.checkInArea(areaVerties)) {
      items.push(this);
    }
    return items;
  }
  checkInAreaForLayers(areaVerties) {
    var items = [];
    this.layers.forEach((layer) => {
      items.push.apply(items, layer.checkInAreaForLayers(areaVerties));
      if (layer.checkInArea(areaVerties)) {
        items.push(layer);
      }
    });
    return items;
  }
  getTransformOriginMatrix() {
    return fromTranslation([], TransformOrigin.scale(this.transformOrigin || "50% 50% 0px", this.screenWidth, this.screenHeight));
  }
  getTransformOriginMatrixInverse() {
    return invert([], this.getTransformOriginMatrix());
  }
  recoverMatrix(newChildMatrix) {
    const matrix = calculateMatrix(this.absoluteMatrixInverse, newChildMatrix.absoluteMatrix);
    const q = getRotation([], matrix);
    const axis = [];
    const rad = getAxisAngle(axis, q);
    const angle = axis[2] ? radianToDegree(rad * axis[2]) : 0;
    const newTransformMatrix = create$4();
    fromRotation(newTransformMatrix, rad, axis);
    const [x, y] = getTranslation([], calculateMatrix(matrix, calculateMatrixInverse(newChildMatrix.transformOriginMatrix, newTransformMatrix, newChildMatrix.transformOriginMatrixInverse)));
    return { x, y, angle };
  }
  resetMatrix(childItem) {
    const matrix = calculateMatrix(this.absoluteMatrixInverse, childItem.absoluteMatrix);
    const q = getRotation([], matrix);
    const axis = [];
    const rad = getAxisAngle(axis, q);
    const angle = axis[2] ? radianToDegree(rad * axis[2]) : 0;
    const newTransformMatrix = create$4();
    fromRotation(newTransformMatrix, rad, axis);
    const [x, y] = getTranslation([], calculateMatrix(matrix, calculateMatrixInverse(childItem.getTransformOriginMatrix(), newTransformMatrix, childItem.getTransformOriginMatrixInverse())));
    childItem.reset({ x, y, angle });
    this.modelManager.setChanged("resetMatrix", this.id, {
      end: true,
      childItemId: childItem == null ? void 0 : childItem.id
    });
  }
  setOrder(targetIndex) {
    var parent = this.parent;
    var startIndex = this.index;
    if (startIndex > -1) {
      parent.children[startIndex] = parent.children[targetIndex];
      parent.children[targetIndex] = this.id;
      this.modelManager.setChanged("setOrder", this.id, {
        targetIndex,
        startIndex,
        parentId: parent.id
      });
    }
  }
  orderNext() {
    if (this.isLast) {
      if (this.parent.next) {
        let next = this.parent.next;
        if (next.enableHasChildren()) {
          next.appendChild(this);
        } else {
          next.insertAfter(this);
        }
      }
      return;
    }
    var startIndex = this.index;
    if (startIndex > -1) {
      this.setOrder(startIndex + 1);
    }
  }
  orderPrev() {
    if (this.isFirst) {
      const prev = this.parent.prev;
      if (prev) {
        prev.insertBefore(this);
      }
      return;
    }
    var startIndex = this.index;
    if (startIndex > 0) {
      this.setOrder(startIndex - 1);
    }
  }
  orderFirst() {
    this.setOrder(0);
  }
  orderLast() {
    this.setOrder(this.parent.childrenLength - 1);
  }
  orderTop() {
  }
  orderBottom() {
  }
}
const LayoutEngine = {
  [Layout.DEFAULT]: DefaultLayoutEngine,
  [Layout.GRID]: GridLayoutEngine
};
class GroupModel extends MovableModel {
  getDefaultObject(obj2 = {}) {
    return super.getDefaultObject(__spreadValues({
      layout: Layout.DEFAULT,
      constraintsHorizontal: Constraints.NONE,
      constraintsVertical: Constraints.NONE,
      flexDirection: FlexDirection.ROW,
      flexWrap: FlexWrap.NOWRAP,
      justifyContent: JustifyContent.FLEX_START,
      alignItems: AlignItems.FLEX_START,
      alignContent: AlignContent.FLEX_START,
      order: 0,
      flexGrow: 0,
      flexShrink: 0,
      flexBasis: "auto",
      gap: 0,
      resizingHorizontal: ResizingMode.FIXED,
      resizingVertical: ResizingMode.FIXED,
      gridTemplateRows: "auto",
      gridColumnGap: "0px",
      gridTemplateColumns: "auto",
      gridRowGap: "0px",
      gridTemplateAreas: "",
      gridAutoRows: "auto",
      gridAutoColumns: "auto",
      gridAutoFlow: "row"
    }, obj2));
  }
  get layout() {
    return this.get("layout");
  }
  get constraintsHorizontal() {
    return this.get("constraintsHorizontal");
  }
  set constraintsHorizontal(value) {
    this.reset({
      constraintsHorizontal: value
    });
  }
  get constraintsVertical() {
    return this.get("constraintsVertical");
  }
  set constraintsVertical(value) {
    this.reset({
      constraintsVertical: value
    });
  }
  get flexDirection() {
    return this.get("flexDirection");
  }
  set flexDirection(value) {
    this.reset({
      flexDirection: value
    });
  }
  get flexWrap() {
    return this.get("flexWrap");
  }
  set flexWrap(value) {
    this.reset({
      flexWrap: value
    });
  }
  get justifyContent() {
    return this.get("justifyContent");
  }
  set justifyContent(value) {
    this.reset({
      justifyContent: value
    });
  }
  get alignItems() {
    return this.get("alignItems");
  }
  set alignItems(value) {
    this.reset({
      alignItems: value
    });
  }
  get alignContent() {
    return this.get("alignContent");
  }
  set alignContent(value) {
    this.reset({
      alignContent: value
    });
  }
  get order() {
    return this.get("order");
  }
  set order(value) {
    this.reset({
      order: value
    });
  }
  get flexGrow() {
    return this.get("flexGrow");
  }
  set flexGrow(value) {
    this.reset({
      flexGrow: value
    });
  }
  get flexShrink() {
    return this.get("flexShrink");
  }
  set flexShrink(value) {
    this.reset({
      flexShrink: value
    });
  }
  get flexBasis() {
    return this.get("flexBasis");
  }
  set flexBasis(value) {
    this.reset({
      flexBasis: value
    });
  }
  get gap() {
    return this.get("gap");
  }
  set gap(value) {
    this.reset({
      gap: value
    });
  }
  get resizingHorizontal() {
    return this.get("resizingHorizontal");
  }
  set resizingHorizontal(value) {
    this.reset({
      resizingHorizontal: value
    });
  }
  get resizingVertical() {
    return this.get("resizingVertical");
  }
  set resizingVertical(value) {
    this.reset({
      resizingVertical: value
    });
  }
  get gridTemplateRows() {
    return this.get("gridTemplateRows");
  }
  set gridTemplateRows(value) {
    this.reset({
      gridTemplateRows: value
    });
  }
  get gridColumnGap() {
    return this.get("gridColumnGap");
  }
  set gridColumnGap(value) {
    this.reset({
      gridColumnGap: value
    });
  }
  get gridTemplateColumns() {
    return this.get("gridTemplateColumns");
  }
  set gridTemplateColumns(value) {
    this.reset({
      gridTemplateColumns: value
    });
  }
  get gridRowGap() {
    return this.get("gridRowGap");
  }
  set gridRowGap(value) {
    this.reset({
      gridRowGap: value
    });
  }
  get gridTemplateAreas() {
    return this.get("gridTemplateAreas");
  }
  set gridTemplateAreas(value) {
    this.reset({
      gridTemplateAreas: value
    });
  }
  get gridAutoRows() {
    return this.get("gridAutoRows");
  }
  set gridAutoRows(value) {
    this.reset({
      gridAutoRows: value
    });
  }
  get gridAutoColumns() {
    return this.get("gridAutoColumns");
  }
  set gridAutoColumns(value) {
    this.reset({
      gridAutoColumns: value
    });
  }
  get gridAutoFlow() {
    return this.get("gridAutoFlow");
  }
  set gridAutoFlow(value) {
    this.reset({
      gridAutoFlow: value
    });
  }
  isLayoutItem() {
    var _a;
    return !!((_a = this.parent) == null ? void 0 : _a.hasLayout());
  }
  hasConstraints() {
    return this.isLayout(Layout.DEFAULT);
  }
  hasLayout() {
    return !this.hasConstraints() || Boolean(this.layout) === false;
  }
  isLayout(layout2) {
    return this.layout === layout2;
  }
  isInDefault() {
    var _a;
    const parentLayout = ((_a = this.parent) == null ? void 0 : _a.layout) || "default";
    return Layout.DEFAULT === parentLayout;
  }
  isInGrid() {
    return this.isInLayout(Layout.GRID);
  }
  isInFlex() {
    return this.isInLayout(Layout.FLEX);
  }
  isInLayout(layout2) {
    var _a;
    return ((_a = this.parent) == null ? void 0 : _a.layout) === layout2;
  }
  changeConstraints(direction2, value, shiftKey = false) {
    const h = this.get(direction2);
    let newConstraints = value;
    if (h === Constraints.MAX) {
      if (value === Constraints.MAX) {
        newConstraints = Constraints.SCALE;
      }
      if (shiftKey && value === Constraints.MIN) {
        newConstraints = Constraints.STRETCH;
      }
    } else if (h === Constraints.MIN) {
      if (value === Constraints.MIN) {
        newConstraints = Constraints.SCALE;
      } else if (shiftKey && value === Constraints.MAX) {
        newConstraints = Constraints.STRETCH;
      }
    } else if (h === Constraints.STRETCH) {
      if (value === Constraints.MIN) {
        newConstraints = Constraints.MAX;
      } else if (value === Constraints.MAX) {
        newConstraints = Constraints.MIN;
      }
    }
    this.reset({
      [direction2]: newConstraints
    });
  }
  startToCacheChildren() {
    var _a;
    (_a = LayoutEngine[this.layout]) == null ? void 0 : _a.startCache(this);
  }
  recoverChildren() {
    var _a;
    (_a = LayoutEngine[this.layout]) == null ? void 0 : _a.recover(this);
  }
}
const editableList = [
  "appearance",
  "position",
  "right",
  "bottom",
  "rootVariable",
  "variable",
  "transform",
  "filter",
  "backdropFilter",
  "backgroundColor",
  "backgroundImage",
  "borderRadius",
  "border",
  "boxShadow",
  "clipPath",
  "color",
  "perspectiveOrigin",
  "transformOrigin",
  "transformStyle",
  "perspective",
  "mixBlendMode",
  "overflow",
  "opacity",
  "box-model",
  "layout",
  "flex-layout",
  "grid-layout",
  "animation",
  "transition",
  "pattern",
  "boolean-operation"
];
const editableKeys = {};
editableList.forEach(function(key) {
  editableKeys[key] = true;
});
class DomModel extends GroupModel {
  getDefaultObject(obj2 = {}) {
    return super.getDefaultObject(__spreadValues({
      rootVariable: "",
      variable: "",
      color: "black",
      overflow: "visible",
      opacity: 1,
      pattern: "",
      selectors: [],
      svg: [],
      gridColumnStart: "",
      gridColumnEnd: "",
      gridRowStart: "",
      gridRowEnd: "",
      gridColumnGap: "",
      gridRowGap: ""
    }, obj2));
  }
  get gridColumnStart() {
    return this.get("gridColumnStart");
  }
  set gridColumnStart(value) {
    this.set("gridColumnStart", value);
  }
  get gridColumnEnd() {
    return this.get("gridColumnEnd");
  }
  set gridColumnEnd(value) {
    this.set("gridColumnEnd", value);
  }
  get gridRowStart() {
    return this.get("gridRowStart");
  }
  set gridRowStart(value) {
    this.set("gridRowStart", value);
  }
  get gridRowEnd() {
    return this.get("gridRowEnd");
  }
  set gridRowEnd(value) {
    this.set("gridRowEnd", value);
  }
  get gridColumnGap() {
    return this.get("gridColumnGap");
  }
  set gridColumnGap(value) {
    this.set("gridColumnGap", value);
  }
  get gridRowGap() {
    return this.get("gridRowGap");
  }
  set gridRowGap(value) {
    this.set("gridRowGap", value);
  }
  get pattern() {
    return this.get("pattern");
  }
  set pattern(value) {
    this.reset({
      pattern: value
    });
  }
  get selectors() {
    return this.get("selectors");
  }
  set selectors(value) {
    this.reset({
      selectors: value
    });
  }
  get svg() {
    return this.get("svg");
  }
  set svg(value) {
    this.reset({ svg: value });
  }
  get rootVariable() {
    return this.get("rootVariable");
  }
  set rootVariable(value) {
    this.reset({
      rootVariable: value
    });
  }
  get variable() {
    return this.get("variable");
  }
  set variable(value) {
    this.reset({
      variable: value
    });
  }
  get filter() {
    return this.get("filter");
  }
  set filter(value) {
    this.reset({
      filter: value
    });
  }
  get backdropFilter() {
    return this.get("backdropFilter");
  }
  set backdropFilter(value) {
    this.reset({
      backdropFilter: value
    });
  }
  get backgroundColor() {
    return this.get("backgroundColor");
  }
  set backgroundColor(value) {
    this.reset({
      backgroundColor: value
    });
  }
  get backgroundImage() {
    return this.get("backgroundImage");
  }
  set backgroundImage(value) {
    this.reset({
      backgroundImage: value
    });
  }
  get textClip() {
    return this.get("textClip");
  }
  set textClip(value) {
    this.reset({
      textClip: value
    });
  }
  get borderRadius() {
    return this.get("borderRadius");
  }
  set borderRadius(value) {
    this.reset({
      borderRadius: value
    });
  }
  get border() {
    return this.get("border");
  }
  set border(value) {
    this.reset({
      border: value
    });
  }
  get boxShadow() {
    return this.get("boxShadow");
  }
  set boxShadow(value) {
    this.reset({
      boxShadow: value
    });
  }
  get textShadow() {
    return this.get("textShadow");
  }
  set textShadow(value) {
    this.reset({
      textShadow: value
    });
  }
  get clipPath() {
    return this.get("clipPath");
  }
  set clipPath(value) {
    this.reset({
      clipPath: value
    });
  }
  get color() {
    return this.get("color");
  }
  set color(value) {
    this.reset({
      color: value
    });
  }
  get opacity() {
    return this.get("opacity");
  }
  set opacity(value) {
    this.reset({
      opacity: value
    });
  }
  get transformStyle() {
    return this.get("transformStyle");
  }
  set transformStyle(value) {
    this.reset({
      transformStyle: value
    });
  }
  get fontSize() {
    return this.get("fontSize");
  }
  set fontSize(value) {
    this.reset({
      fontSize: value
    });
  }
  get fontFamily() {
    return this.get("fontFamily");
  }
  set fontFamily(value) {
    this.reset({
      fontFamily: value
    });
  }
  get fontWeight() {
    return this.get("fontWeight");
  }
  set fontWeight(value) {
    this.reset({
      fontWeight: value
    });
  }
  get fontStyle() {
    return this.get("fontStyle");
  }
  set fontStyle(value) {
    this.reset({
      fontStyle: value
    });
  }
  get fontVariant() {
    return this.get("fontVariant");
  }
  set fontVariant(value) {
    this.reset({
      fontVariant: value
    });
  }
  get fontStretch() {
    return this.get("fontStretch");
  }
  set fontStretch(value) {
    this.reset({
      fontStretch: value
    });
  }
  get lineHeight() {
    return this.get("lineHeight");
  }
  set lineHeight(value) {
    this.reset({
      lineHeight: value
    });
  }
  get letterSpacing() {
    return this.get("letterSpacing");
  }
  set letterSpacing(value) {
    this.reset({
      letterSpacing: value
    });
  }
  get wordSpacing() {
    return this.get("wordSpacing");
  }
  set wordSpacing(value) {
    this.reset({
      wordSpacing: value
    });
  }
  get textDecoration() {
    return this.get("textDecoration");
  }
  set textDecoration(value) {
    this.reset({
      textDecoration: value
    });
  }
  get textAlign() {
    return this.get("textAlign");
  }
  set textAlign(value) {
    this.reset({
      textAlign: value
    });
  }
  get textTransform() {
    return this.get("textTransform");
  }
  set textTransform(value) {
    this.reset({
      textTransform: value
    });
  }
  get textOverflow() {
    return this.get("text-overflow");
  }
  set textOverflow(value) {
    this.reset({
      "text-overflow": value
    });
  }
  get textIndent() {
    return this.get("textIndent");
  }
  set textIndent(value) {
    this.reset({
      textIndent: value
    });
  }
  get mixBlendMode() {
    return this.get("mixBlendMode");
  }
  set mixBlendMode(value) {
    this.reset({
      mixBlendMode: value
    });
  }
  get visibility() {
    return this.get("visibility");
  }
  set visibility(value) {
    this.reset({
      visibility: value
    });
  }
  get zIndex() {
    return this.get("z-index");
  }
  set zIndex(value) {
    this.reset({
      "z-index": value
    });
  }
  get overflow() {
    return this.get("overflow");
  }
  set overflow(value) {
    this.reset({
      overflow: value
    });
  }
  get animation() {
    return this.get("animation");
  }
  set animation(value) {
    this.reset({
      animation: value
    });
  }
  get transition() {
    return this.get("transition");
  }
  set transition(value) {
    this.reset({
      transition: value
    });
  }
  get marginTop() {
    return this.get("marginTop");
  }
  set marginTop(value) {
    this.reset({
      marginTop: value
    });
  }
  get marginRight() {
    return this.get("marginRight");
  }
  set marginRight(value) {
    this.reset({
      marginRight: value
    });
  }
  get marginBottom() {
    return this.get("marginBottom");
  }
  set marginBottom(value) {
    this.reset({
      marginBottom: value
    });
  }
  get marginLeft() {
    return this.get("marginLeft");
  }
  set marginLeft(value) {
    this.reset({
      marginLeft: value
    });
  }
  get paddingTop() {
    return this.get("paddingTop");
  }
  set paddingTop(value) {
    this.reset({
      paddingTop: value
    });
  }
  get paddingRight() {
    return this.get("paddingRight");
  }
  set paddingRight(value) {
    this.reset({
      paddingRight: value
    });
  }
  get paddingBottom() {
    return this.get("paddingBottom");
  }
  set paddingBottom(value) {
    this.reset({
      paddingBottom: value
    });
  }
  get paddingLeft() {
    return this.get("paddingLeft");
  }
  set paddingLeft(value) {
    this.reset({
      paddingLeft: value
    });
  }
  editable(editablePropertyName) {
    switch (editablePropertyName) {
      case "svg-item":
      case "transformOrigin":
      case "perspective":
      case "perspectiveOrigin":
        return false;
    }
    return Boolean(editableKeys[editablePropertyName]);
  }
  get changedBoxModel() {
    return this.hasChangedField("marginTop", "marginLeft", "marginBottom", "marginRight", "paddingTop", "paddingLeft", "paddingRight", "paddingBottom");
  }
  get changedFlexLayout() {
    return this.hasChangedField("flex-direction", "flex-wrap", "justify-content", "align-items", "align-content", "order", "flex-basis", "flex-grow", "flex-shrink", "flex-flow");
  }
  get changedGridLayout() {
    return this.hasChangedField("grid-template-rows", "grid-template-columns", "grid-template-areas", "grid-auto-rows", "grid-auto-columns", "grid-auto-flow", "grid-row-gap", "grid-column-gap", "grid-row-start", "grid-row-end", "grid-column-start", "grid-column-end", "grid-area");
  }
  get changedLayoutItem() {
    return this.hasChangedField("resizingHorizontal", "resizingVertical");
  }
  get changedLayout() {
    return this.hasChangedField("layout") || this.changedBoxModel || this.changedFlexLayout || this.changedGridLayout || this.changedLayoutItem;
  }
  addSelector(selector2) {
    this.selectors.push(selector2);
    return selector2;
  }
  createSelector(data = {}) {
    return this.addSelector(new Selector(__spreadValues({
      checked: true
    }, data)));
  }
  removePropertyList(arr, removeIndex) {
    arr.splice(removeIndex, 1);
  }
  removeSelector(removeIndex) {
    this.removePropertyList(this.selectors, removeIndex);
  }
  enableHasChildren() {
    return true;
  }
  sortItem(arr, startIndex, targetIndex) {
    arr.splice(targetIndex + (startIndex < targetIndex ? -1 : 0), 0, ...arr.splice(startIndex, 1));
  }
  updateSelector(index2, data = {}) {
    this.selectors[+index2].reset(data);
  }
  traverse(item, results, hasLayoutItem) {
    if (item.isAttribute())
      return;
    if (!hasLayoutItem && item.isLayoutItem() && !item.isRootItem())
      return;
    results.push(item);
    item.children.forEach((child) => {
      this.traverse(child, results);
    });
  }
  tree(hasLayoutItem) {
    var results = [];
    this.children.forEach((item) => {
      this.traverse(item, results, hasLayoutItem);
    });
    return results;
  }
  convert(json) {
    json = super.convert(json);
    if (json.padding) {
      json["paddingTop"] = Length.parse(json.padding);
      json["paddingRight"] = Length.parse(json.padding);
      json["paddingBottom"] = Length.parse(json.padding);
      json["paddingLeft"] = Length.parse(json.padding);
      delete json.padding;
    }
    return json;
  }
  reset(obj2, context = { origin: "*" }) {
    const isChanged = super.reset(obj2, context);
    if (this.hasChangedField("clipPath")) {
      this.setClipPathCache();
    }
    if (this.hasChangedField("width", "height")) {
      if (this.cacheClipPath) {
        const d = this.cacheClipPath.clone().scale(this.width / this.cacheClipPathWidth, this.height / this.cacheClipPathHeight).d;
        this.clipPath = `path(${d})`;
        this.modelManager.setChanged("reset", this.id, {
          clipPath: this.clipPath
        });
      }
    }
    if (this.hasChangedField("backgroundImage", "pattern")) {
      this.setBackgroundImageCache();
    }
    return isChanged;
  }
  setBackgroundImageCache() {
    let list2 = [];
    if (this.pattern) {
      const patternList = this.computed("pattern", (pattern) => {
        return Pattern.parseStyle(pattern).map((it) => {
          return BackgroundImage.parseStyle(STRING_TO_CSS(it.toCSS()));
        });
      });
      for (var i = 0, len2 = patternList.length; i < len2; i++) {
        list2.push.apply(list2, patternList[i]);
      }
    }
    if (this.backgroundImage) {
      const backgroundList = this.computed("backgroundImage", (backgroundImage2) => {
        return BackgroundImage.parseStyle(STRING_TO_CSS(backgroundImage2));
      });
      list2.push.apply(list2, backgroundList.filter((it) => it.visibility !== VisibilityType.HIDDEN));
    }
    if (list2.length) {
      const project2 = this.top;
      this.cacheBackgroundImage = BackgroundImage.joinCSS(list2);
      const cacheList = list2.filter((it) => it.type === GradientType.URL).map((it) => it.image.url);
      let cacheImage = this.cacheBackgroundImage["background-image"];
      cacheList.forEach((url) => {
        const imageUrl = project2.getImageValueById(url);
        cacheImage = cacheImage.replace(url, `"${imageUrl}"`);
      });
      this.cacheBackgroundImage["background-image"] = cacheImage;
    } else {
      this.cacheBackgroundImage = {};
      this.cacheBackgroundImageOriginal = [];
    }
  }
  setClipPathCache() {
    var obj2 = ClipPath.parseStyle(this.clipPath);
    this.cacheClipPathObject = obj2;
    if (obj2.type === "path") {
      this.cacheClipPath = new PathParser(obj2.value.trim());
      this.cacheClipPathWidth = this.width;
      this.cacheClipPathHeight = this.height;
    }
  }
  setCache() {
    super.setCache();
    this.setClipPathCache();
  }
  get clipPathString() {
    if (!this.cacheClipPath) {
      this.setClipPathCache();
    }
    if (this.cacheClipPath) {
      return this.cacheClipPath.clone().scale(this.width / this.cacheClipPathWidth, this.height / this.cacheClipPathHeight).d;
    }
  }
  getBackgroundImage(index2) {
    const backgroundImages = BackgroundImage.parseStyle(STRING_TO_CSS(this.backgroundImage));
    return backgroundImages[index2 || 0];
  }
  get borderWidth() {
    const border2 = Border.parseStyle(this.border);
    const borderObject = Border.parseValue(border2.border);
    if (borderObject == null ? void 0 : borderObject.width) {
      return {
        borderLeftWidth: borderObject == null ? void 0 : borderObject.width,
        borderRightWidth: borderObject == null ? void 0 : borderObject.width,
        borderTopWidth: borderObject == null ? void 0 : borderObject.width,
        borderBottomWidth: borderObject == null ? void 0 : borderObject.width
      };
    }
    return {
      borderLeftWidth: 0,
      borderRightWidth: 0,
      borderTopWidth: 0,
      borderBottomWidth: 0
    };
  }
  get contentBox() {
    const x = 0;
    const y = 0;
    const width2 = this.screenWidth;
    const height2 = this.screenHeight;
    {
      const borderWidth = this.borderWidth;
      return {
        x: x + borderWidth.borderLeftWidth,
        y: y + borderWidth.borderTopWidth,
        width: width2 - borderWidth.borderLeftWidth - borderWidth.borderRightWidth,
        height: height2 - borderWidth.borderTopWidth - borderWidth.borderBottomWidth
      };
    }
  }
  getGradientLineLength(width2, height2, angle) {
    return Math.abs(width2 * Math.sin(degreeToRadian(angle))) + Math.abs(height2 * Math.cos(degreeToRadian(angle)));
  }
  createBackgroundImageMatrix(index2) {
    const contentBox = this.contentBox;
    const backgroundImage2 = this.getBackgroundImage(index2);
    const { image: image2 } = backgroundImage2;
    const backRect = backgroundImage2.getOffset(contentBox);
    const backVerties = vertiesMap(rectToVerties(backRect.x, backRect.y, backRect.width, backRect.height), this.absoluteMatrix);
    const result = {
      backRect,
      backVerties,
      absoluteMatrix: this.absoluteMatrix,
      backgroundImage: backgroundImage2
    };
    switch (image2.type) {
      case GradientType.RADIAL:
      case GradientType.REPEATING_RADIAL:
      case GradientType.CONIC:
      case GradientType.REPEATING_CONIC:
        let [rx, ry] = image2.radialPosition;
        if (rx == "center")
          rx = Length.percent(50);
        if (ry == "center")
          ry = Length.percent(50);
        const newRx = rx.toPx(backRect.width);
        const newRy = ry.toPx(backRect.height);
        const centerVerties = vertiesMap([
          [newRx.value + backRect.x, newRy.value + backRect.y, 0],
          [newRx.value + backRect.x, newRy.value + backRect.y - 1, 0]
        ], this.absoluteMatrix);
        result.radialCenterPosition = centerVerties[0];
        result.radialCenterStick = centerVerties[1];
        result.radialCenterPoint = [newRx.value, newRy.value, 0];
        if (image2.type === GradientType.RADIAL || image2.type === GradientType.REPEATING_RADIAL) {
          const { startPoint: startPoint2, endPoint: endPoint2, shapePoint } = image2.getStartEndPoint(result);
          const [newStartPoint2, newEndPoint2, newShapePoint] = vertiesMap([startPoint2, endPoint2, shapePoint], this.absoluteMatrix);
          result.radialCenterPosition = newStartPoint2;
          result.startPoint = newStartPoint2;
          result.endPoint = newEndPoint2;
          result.shapePoint = newShapePoint;
          result.colorsteps = image2.colorsteps.map((it) => {
            const offset = it.toLength();
            return {
              id: it.id,
              cut: it.cut,
              color: it.color,
              timing: it.timing,
              timingCount: it.timingCount,
              pos: lerp$1([], result.startPoint, result.endPoint, offset.value / 100)
            };
          });
        } else if (image2.type === GradientType.CONIC || image2.type === GradientType.REPEATING_CONIC) {
          const { startPoint: startPoint2, endPoint: endPoint2, shapePoint } = image2.getStartEndPoint(result);
          const [newStartPoint2, newEndPoint2, newShapePoint] = vertiesMap([startPoint2, endPoint2, shapePoint], this.absoluteMatrix);
          result.radialCenterPosition = newStartPoint2;
          result.startPoint = newStartPoint2;
          result.endPoint = newEndPoint2;
          result.shapePoint = newShapePoint;
          [result.startPoint, result.endPoint, result.shapePoint] = vertiesMap([result.startPoint, result.endPoint, result.shapePoint], calculateRotationOriginMat4(image2.angle, result.radialCenterPosition));
          const targetPoint = result.shapePoint;
          result.colorsteps = image2.colorsteps.map((it) => {
            const angle = it.percent * 3.6;
            const [newPos] = vertiesMap([targetPoint], calculateRotationOriginMat4(angle, result.radialCenterPosition));
            return {
              id: it.id,
              cut: it.cut,
              color: it.color,
              timing: it.timing,
              timingCount: it.timingCount,
              pos: newPos
            };
          });
        }
        break;
      case GradientType.LINEAR:
      case GradientType.REPEATING_LINEAR:
        result.gradientLineLength = this.getGradientLineLength(backRect.width, backRect.height, image2.angle);
        result.centerPosition = lerp$1([], backVerties[0], backVerties[2], 0.5);
        const startPoint = add$1([], result.centerPosition, [
          0,
          result.gradientLineLength / 2,
          0
        ]);
        const endPoint = subtract([], result.centerPosition, [
          0,
          result.gradientLineLength / 2,
          0
        ]);
        const areaStartPoint = clone(startPoint);
        const areaEndPoint = clone(endPoint);
        const [newStartPoint, newEndPoint, newAreaStartPoint, newAreaEndPoint] = vertiesMap([startPoint, endPoint, areaStartPoint, areaEndPoint], calculateRotationOriginMat4(image2.angle, result.centerPosition));
        result.endPoint = newEndPoint;
        result.startPoint = newStartPoint;
        result.areaStartPoint = newAreaStartPoint;
        result.areaEndPoint = newAreaEndPoint;
        result.colorsteps = image2.colorsteps.map((it) => {
          const offset = it.toLength();
          return {
            id: it.id,
            cut: it.cut,
            color: it.color,
            timing: it.timing,
            timingCount: it.timingCount,
            pos: lerp$1([], result.startPoint, result.endPoint, offset.value / 100)
          };
        });
        break;
    }
    return result;
  }
}
class LayerModel extends DomModel {
  getDefaultObject(obj2 = {}) {
    return super.getDefaultObject(__spreadValues({
      itemType: "layer",
      name: "New Layer",
      tagName: "div"
    }, obj2));
  }
  getDefaultTitle() {
    return "Layer";
  }
}
class ArtBoard extends LayerModel {
  getDefaultObject(obj2 = {}) {
    return super.getDefaultObject(__spreadValues({
      itemType: "artboard",
      name: "New ArtBoard",
      width: 1e3,
      height: 1e3,
      backgroundColor: "white",
      transformStyle: "flat"
    }, obj2));
  }
  getDefaultTitle() {
    return "ArtBoard";
  }
  getIcon() {
    return obj$3.artboard;
  }
  editable(editablePropertyName) {
    switch (editablePropertyName) {
      case "border":
      case "borderRadius":
        return false;
      case "artboardSize":
      case "layout":
        return true;
    }
    return super.editable(editablePropertyName);
  }
}
const IMAGE_LIST = ["jpg", "jpeg", "png", "gif", "svg"];
class SVGImageResource extends ImageResource {
  getDefaultObject(obj2 = {}) {
    return super.getDefaultObject(__spreadValues({
      type: "url",
      url: "",
      datauri: "",
      patternUnits: "userSpaceOnUse",
      patternWidth: "100%",
      patternHeight: "100%",
      imageX: "0%",
      imageY: "0%",
      imageWidth: "100%",
      imageHeight: "100%"
    }, obj2));
  }
  toCloneObject() {
    return __spreadValues(__spreadValues({}, super.toCloneObject()), this.attrs("url", "datauri", "patternUnits", "patternWidth", "patternHeight", "imageX", "imageY", "imageWidth", "imageHeight"));
  }
  static parse(str) {
    var content2 = str.split("(")[1].split(")")[0];
    var [url, props] = content2.trim().split("#");
    if (!props) {
      return new SVGImageResource({ url });
    }
    var [
      patternUnits,
      patternWidth,
      patternHeight,
      imageX,
      imageY,
      imageWidth,
      imageHeight
    ] = props.split(",");
    return new SVGImageResource({
      patternUnits,
      patternWidth,
      patternHeight,
      imageX,
      imageY,
      imageWidth,
      imageHeight,
      url
    });
  }
  isUrl() {
    return true;
  }
  static isImageFile(fileExt) {
    return IMAGE_LIST.includes(fileExt);
  }
  toString() {
    var json = this.json;
    var {
      patternUnits,
      patternWidth,
      patternHeight,
      imageX,
      imageY,
      imageWidth,
      imageHeight,
      url
    } = json;
    var string = [
      patternUnits,
      patternWidth,
      patternHeight,
      imageX,
      imageY,
      imageWidth,
      imageHeight
    ].join(",").trim();
    return `url(${url}#${string})`;
  }
  toSVGString(id, item = {}) {
    var {
      patternUnits,
      patternWidth,
      patternHeight,
      imageX,
      imageY,
      imageWidth,
      imageHeight
    } = this.json;
    const localPatternWidth = Length.parse(patternWidth);
    const localPatternHeight = Length.parse(patternHeight);
    const localImageX = Length.parse(imageX);
    const localImageY = Length.parse(imageY);
    const localImageWidth = Length.parse(imageWidth);
    const localImageHeight = Length.parse(imageHeight);
    const width2 = item.width ? localPatternWidth.toPx(item.width).value : localPatternWidth;
    const height2 = item.height ? localPatternHeight.toPx(item.height).value : localPatternHeight;
    return `
  <pattern ${OBJECT_TO_PROPERTY({ id, patternUnits, width: width2, height: height2 })} >
    <image xlink:href="${this.json.datauri || this.json.url}" ${OBJECT_TO_PROPERTY({
      x: localImageX.toPx(item.width).value,
      y: localImageY.toPx(item.height).value,
      width: localImageWidth.toPx(item.width).value,
      height: localImageHeight.toPx(item.height).value,
      preserveAspectRatio: "none"
    })} />
  </pattern>
      `;
  }
  toFillValue(id) {
    return `url(#${id})`;
  }
}
class SVGGradient extends Gradient {
  toString() {
    return "";
  }
  toSVGString() {
    return "";
  }
  toFillValue() {
    return "";
  }
}
const SpreadMethodList$1 = [
  SpreadMethodType.PAD,
  SpreadMethodType.REFLECT,
  SpreadMethodType.REPEAT
];
class SVGLinearGradient extends SVGGradient {
  convert(json) {
    json.spreadMethod = SpreadMethodList$1.includes(json.spreadMethod) ? json.spreadMethod : SpreadMethodType.PAD;
    return json;
  }
  getDefaultObject(obj2) {
    return super.getDefaultObject(__spreadValues({
      type: GradientType.LINEAR,
      x1: Length.parse("0%"),
      y1: Length.parse("50%"),
      x2: Length.parse("100%"),
      y2: Length.parse("50%"),
      spreadMethod: SpreadMethodType.PAD
    }, obj2));
  }
  toCloneObject() {
    return __spreadValues(__spreadValues({}, super.toCloneObject()), this.attrs("x1", "y1", "x2", "y2", "spreadMethod"));
  }
  toString() {
    if (this.colorsteps.length === 0)
      return "";
    var colorString = this.getColorString();
    var { x1, y1, x2, y2, spreadMethod } = this.json;
    var opt = [x1, y1, x2, y2, spreadMethod].join(" ");
    var result = `${this.json.type}(${opt}, ${colorString})`;
    return result;
  }
  toSVGString(id) {
    var { x1, y1, x2, y2, spreadMethod } = this.json;
    return `
      <linearGradient 
        id="${id}"
        x1="${x1}"
        x2="${x2}"
        y1="${y1}"
        y2="${y2}"
        spreadMethod="${spreadMethod}"
      >
        ${SVGLinearGradient.makeColorStepList(this.colorsteps).map((it) => `
        <stop offset="${it.percent}%" stop-color="${it.color}"/>
      `).join("")}
      </linearGradient>
    `;
  }
  toFillValue(id) {
    return `url(#${id})`;
  }
  static parse(str) {
    const result = parseOneValue(str);
    var opt = {};
    const [options2, ...colors2] = result.parameters;
    const list2 = [];
    options2.forEach((it) => {
      if (it.func === FuncType.KEYWORD) {
        if (SpreadMethodList$1.includes(it.matchedString)) {
          opt.spreadMethod = it.matchedString;
        }
      } else {
        list2.push(it);
      }
    });
    var [
      x1 = Length.percent(0),
      y1 = Length.percent(50),
      x2 = Length.percent(100),
      y2 = Length.percent(50)
    ] = list2.map((it) => it.parsed);
    opt = __spreadProps(__spreadValues({}, opt), {
      x1,
      y1,
      x2,
      y2
    });
    const colorsteps = SVGLinearGradient.parseColorSteps(colors2);
    return new SVGLinearGradient(__spreadProps(__spreadValues({}, opt), { colorsteps }));
  }
}
const RadialTypeList = [RadialGradientType.CIRCLE, RadialGradientType.ELLIPSE];
const SpreadMethodList = [
  SpreadMethodType.PAD,
  SpreadMethodType.REFLECT,
  SpreadMethodType.REPEAT
];
class SVGRadialGradient extends SVGGradient {
  convert(json) {
    json.spreadMethod = SpreadMethodList.includes(json.spreadMethod) ? json.spreadMethod : SpreadMethodType.PAD;
    return json;
  }
  getDefaultObject(obj2 = {}) {
    return super.getDefaultObject(__spreadValues({
      type: GradientType.RADIAL,
      radialType: RadialGradientType.CIRCLE,
      x1: Length.parse("50%"),
      y1: Length.parse("50%"),
      x2: Length.parse("100%"),
      y2: Length.parse("50%"),
      x3: Length.parse("50%"),
      y3: Length.parse("100%"),
      spreadMethod: SpreadMethodType.PAD
    }, obj2));
  }
  toCloneObject() {
    return __spreadValues(__spreadValues({}, super.toCloneObject()), this.attrs("radialType", "x1", "y1", "x2", "y2", "x3", "y3", "spreadMethod"));
  }
  toString() {
    if (this.colorsteps.length === 0)
      return "";
    var colorString = this.getColorString();
    var { radialType, x1, y1, x2, y2, x3, y3, spreadMethod } = this.json;
    var opt = [radialType, x1, y1, x2, y2, x3, y3, spreadMethod].join(" ").trim();
    var result = `${this.json.type}(${opt}, ${colorString})`;
    return result;
  }
  getGradientAngle(contentBox = {}) {
    var { x1, y1, x2, y2 } = this.json;
    const newX1 = x1.toPx(contentBox.width);
    const newY1 = y1.toPx(contentBox.height);
    const newX2 = x2.toPx(contentBox.width);
    const newY2 = y2.toPx(contentBox.height);
    const angle = calculateAngle360(newX2.value - newX1.value, newY2.value - newY1.value) + 180;
    return angle % 360;
  }
  toSVGString(id, contentBox = {}) {
    var {
      x1: cx,
      y1: cy,
      x2,
      y2,
      x3,
      y3,
      spreadMethod,
      radialType
    } = this.json;
    const newX1 = cx.toPx(contentBox.width);
    const newY1 = cy.toPx(contentBox.height);
    const newX2 = x2.toPx(contentBox.width);
    const newY2 = y2.toPx(contentBox.height);
    var dist$1 = dist([newX1.value, newY1.value, 0], [newX2.value, newY2.value, 0]);
    var angle = this.getGradientAngle(contentBox);
    const view = create$5();
    multiply$2(view, view, fromTranslation$1([], [newX1.value, newY1.value]));
    multiply$2(view, view, fromRotation$1([], degreeToRadian(angle)));
    if (radialType === RadialGradientType.ELLIPSE) {
      const newX3 = x3.toPx(contentBox.width);
      const newY3 = y3.toPx(contentBox.height);
      var dist2 = dist([newX1.value, newY1.value, 0], [newX3.value, newY3.value, 0]);
      multiply$2(view, view, fromScaling$1([], [1, dist2 / dist$1]));
    }
    const gradientTransform = `matrix(${view[0]}, ${view[1]}, ${view[3]}, ${view[4]}, ${view[6]}, ${view[7]})`;
    return `
<radialGradient ${OBJECT_TO_PROPERTY({
      id,
      cx: 0,
      cy: 0,
      r: dist$1,
      spreadMethod,
      gradientUnits: "userSpaceOnUse",
      gradientTransform
    })} >
    ${SVGRadialGradient.makeColorStepList(this.colorsteps).map((it) => `
      <stop offset="${it.percent}%" stop-color="${it.color}"/>
    `).join("")}
</radialGradient>
`;
  }
  toFillValue(id) {
    return `url(#${id})`;
  }
  static parse(str) {
    const result = parseOneValue(str);
    var opt = {};
    const [options2, ...colors2] = result.parameters;
    const list2 = [];
    options2.forEach((it) => {
      if (it.func === FuncType.KEYWORD) {
        if (RadialTypeList.includes(it.matchedString)) {
          opt.radialType = it.matchedString;
        } else if (SpreadMethodList.includes(it.matchedString)) {
          opt.spreadMethod = it.matchedString;
        }
      } else {
        list2.push(it);
      }
    });
    var [
      x1 = Length.percent(50),
      y1 = Length.percent(50),
      x2 = Length.percent(100),
      y2 = Length.percent(50),
      x3 = Length.percent(50),
      y3 = Length.percent(100)
    ] = list2.map((it) => it.parsed);
    opt = __spreadProps(__spreadValues({}, opt), {
      x1,
      y1,
      x2,
      y2,
      x3,
      y3
    });
    const colorsteps = SVGRadialGradient.parseColorSteps(colors2);
    return new SVGRadialGradient(__spreadProps(__spreadValues({}, opt), { colorsteps }));
  }
}
class SVGStaticGradient extends SVGGradient {
  getDefaultObject() {
    return super.getDefaultObject({
      type: "static-gradient",
      colorsteps: [
        new ColorStep({ color: "red", percent: 0, index: 0 }),
        new ColorStep({ color: "red", percent: 100, index: 1 })
      ]
    });
  }
  toCloneObject() {
    return __spreadProps(__spreadValues({}, super.toCloneObject()), {
      static: true
    });
  }
  static create(color2 = "transparent") {
    return new SVGStaticGradient({
      colorsteps: [
        new ColorStep({ color: color2, percent: 0, index: 0 }),
        new ColorStep({ color: color2, percent: 100, index: 0 })
      ]
    });
  }
  setColor(color2) {
    this.colorsteps.forEach((it) => {
      it.color = color2;
    });
  }
  toString() {
    var color2 = this.json.colorsteps[0].color;
    return color2;
  }
  toSVGString() {
    return "";
  }
  toFillValue() {
    return this.toString();
  }
}
class SVGFill extends PropertyItem {
  addImageResource(imageResource) {
    this.clear("image-resource");
    return this.addItem("image-resource", imageResource);
  }
  addGradient(gradient2) {
    return this.addImageResource(gradient2);
  }
  setImageUrl(data) {
    if (!data.images)
      return;
    if (!data.images.length)
      return;
    this.reset({
      type: "image",
      image: SVGFill.createImage(data.images[0])
    });
  }
  static createImage(url) {
    return new SVGLImageResource({ url });
  }
  setGradient(data) {
    this.reset({
      type: data.type,
      image: SVGFill.createGradient(data, this.json.image)
    });
  }
  static createGradient(data, gradient2) {
    const colorsteps = data.colorsteps || gradient2.colorsteps;
    let json = gradient2.toJSON();
    delete json.itemType;
    delete json.type;
    switch (data.type) {
      case GradientType.LINEAR:
        return new SVGLinearGradient(__spreadProps(__spreadValues({}, json), { colorsteps }));
      case GradientType.RADIAL:
        return new SVGRadialGradient(__spreadProps(__spreadValues({}, json), { colorsteps }));
      default:
        return new SVGStaticGradient(__spreadProps(__spreadValues({}, json), { colorsteps }));
    }
  }
  get image() {
    return this.json.image;
  }
  set image(image2) {
    this.json.image = image2;
  }
  static parse(obj2) {
    return new SVGFill(obj2);
  }
  static parseImage(str = "") {
    const result = parseOneValue(str);
    let image2 = null;
    if (!result) {
      return SVGStaticGradient.create(str || "transparent");
    }
    switch (result.func) {
      case GradientType.LINEAR:
        image2 = SVGLinearGradient.parse(result.matchedString);
        break;
      case GradientType.RADIAL:
        image2 = SVGRadialGradient.parse(result.matchedString);
        break;
      case GradientType.URL:
        image2 = SVGImageResource.parse(result.matchedString);
        break;
      default:
        image2 = SVGStaticGradient.create(result.matchedString);
        break;
    }
    return image2;
  }
  static changeImageType(options2) {
    switch (options2.type) {
      case GradientType.LINEAR:
        return new SVGLinearGradient(options2);
      case GradientType.RADIAL:
        return new SVGRadialGradient(options2);
      case "image-resource":
      case GradientType.URL:
        return new SVGImageResource(options2);
      default:
        return new SVGStaticGradient(options2);
    }
  }
}
const expectedProperties = [
  "appearance",
  "border",
  "borderRadius",
  "backgroundImage",
  "backdropFilter",
  "clipPath",
  "pattern",
  "boxShadow",
  "layout",
  "transform",
  "transformOrigin",
  "perspective",
  "perspectiveOrigin",
  "backdropFilter",
  "boxModel"
];
const expectedPropertiesKeys = {};
expectedProperties.forEach((key) => {
  expectedPropertiesKeys[key] = true;
});
class SVGModel extends LayerModel {
  getDefaultObject(obj2 = {}) {
    return super.getDefaultObject(__spreadValues({
      itemType: "svg",
      name: "New SVG",
      elementType: "svg",
      overflow: "visible",
      stroke: "black",
      strokeWidth: 1,
      fill: "transparent",
      fillOpacity: 1,
      fillRule: "nonzero",
      textAnchor: "start",
      strokeLinecap: "",
      strokeLinejoin: "",
      strokeDasharray: [],
      strokeDashoffset: 0
    }, obj2));
  }
  get stroke() {
    return this.get("stroke");
  }
  set stroke(value) {
    this.set("stroke", value);
  }
  get strokeWidth() {
    return this.get("strokeWidth");
  }
  set strokeWidth(value) {
    this.set("strokeWidth", value);
  }
  get fill() {
    return this.get("fill");
  }
  set fill(value) {
    this.set("fill", value);
  }
  get fillOpacity() {
    return this.get("fillOpacity");
  }
  set fillOpacity(value) {
    this.set("fillOpacity", value);
  }
  get fillRule() {
    return this.get("fillRule");
  }
  set fillRule(value) {
    this.set("fillRule", value);
  }
  get textAnchor() {
    return this.get("textAnchor");
  }
  set textAnchor(value) {
    this.set("textAnchor", value);
  }
  get strokeDasharray() {
    return this.get("strokeDasharray");
  }
  set strokeDasharray(value) {
    this.set("strokeDasharray", value);
  }
  get strokeDashoffset() {
    return this.get("strokeDashoffset");
  }
  set strokeDashoffset(value) {
    this.set("strokeDashoffset", value);
  }
  get strokeLinejoin() {
    return this.get("strokeLinejoin");
  }
  set strokeLinejoin(value) {
    this.set("strokeLinejoin", value);
  }
  get strokeLinecap() {
    return this.get("strokeLinecap");
  }
  set strokeLinecap(value) {
    this.set("strokeLinecap", value);
  }
  get isDragSelectable() {
    return this.isBooleanItem === false;
  }
  get isBooleanItem() {
    return Boolean(this.parent.is("boolean-path"));
  }
  editable(editablePropertyName) {
    if (expectedPropertiesKeys[editablePropertyName]) {
      return false;
    }
    switch (editablePropertyName) {
      case "svgItem":
        return true;
    }
    return super.editable(editablePropertyName);
  }
  getDefaultTitle() {
    return "SVG";
  }
  isSVG() {
    return true;
  }
  hasPoint(x, y) {
    const fill = this.fill;
    const fillOpacity = this.fillOpacity;
    const strokeWidth = this.strokeWidth;
    const isTransparent = fill === "transparent" || fillOpacity === 0 || parse(fill).a === 0;
    const isZeroStroke = strokeWidth === 0;
    if (isTransparent) {
      return this.isPointInStroke(x, y);
    } else if (!isTransparent && !isZeroStroke) {
      return this.isPointInStroke(x, y) || this.isPointInFill(x, y);
    } else if (!isTransparent && isZeroStroke) {
      return this.isPointInFill(x, y);
    }
    return false;
  }
  isPointInFill(x, y) {
    const svgEl = this.getCache("svgElement");
    const pathEl = this.getCache("pathElement");
    if (pathEl) {
      const [localX, localY] = this.invertPoint([x, y, 0]);
      const point2 = svgEl.createSVGPoint();
      Object.assign(point2, { x: localX, y: localY });
      return pathEl.isPointInFill(point2);
    }
    return false;
  }
  isPointInStroke(x, y) {
    const svgEl = this.getCache("svgElement");
    const pathEl = this.getCache("pathElement");
    if (pathEl) {
      const [localX, localY] = this.invertPoint([x, y, 0]);
      const point2 = svgEl.createSVGPoint();
      Object.assign(point2, { x: localX, y: localY });
      return pathEl.isPointInStroke(point2);
    }
    return false;
  }
  convertStrokeToPath(distX = 10, distY = 10) {
    const attrs = this.attrs("name", "width", "parentId", "height", "x", "y", "transform", "stroke");
    attrs.fill = attrs.stroke;
    delete attrs.stroke;
    return __spreadProps(__spreadValues({
      itemType: "svg-path",
      "fill-rule": "evenodd"
    }, attrs), {
      x: Length.parse(attrs.x).add(distX),
      y: Length.parse(attrs.y).add(distY)
    });
  }
  toSVGPath() {
    const attrs = this.toCloneObject();
    delete attrs.id;
    delete attrs.itemType;
    return __spreadProps(__spreadValues({}, attrs), {
      d: this.d
    });
  }
  createFragmentMatrix(field) {
    const value = this.get(field);
    const image2 = SVGFill.parseImage(value);
    const backRect = {
      x: 0,
      y: 0,
      width: this.screenWidth,
      height: this.screenHeight
    };
    const backVerties = vertiesMap(rectToVerties(backRect.x, backRect.y, backRect.width, backRect.height), this.absoluteMatrix);
    const result = {
      backRect,
      backVerties,
      absoluteMatrix: this.absoluteMatrix,
      image: image2
    };
    let newX1, newY1, newX2, newY2, newX3, newY3;
    switch (image2.type) {
      case GradientType.RADIAL:
        newX1 = image2.x1.toPx(backRect.width);
        newY1 = image2.y1.toPx(backRect.height);
        newX2 = image2.x2.toPx(backRect.width);
        newY2 = image2.y2.toPx(backRect.height);
        newX3 = image2.x3.toPx(backRect.width);
        newY3 = image2.y3.toPx(backRect.height);
        const tempStartPoint = [newX1.value, newY1.value, 0];
        const tempEndPoint = [newX2.value, newY2.value, 0];
        const tempShapePoint = [newX3.value, newY3.value, 0];
        var [newStartPoint, newEndPoint, newShapePoint] = vertiesMap([tempStartPoint, tempEndPoint, tempShapePoint], this.absoluteMatrix);
        result.endPoint = newEndPoint;
        result.startPoint = newStartPoint;
        result.shapePoint = newShapePoint;
        result.colorsteps = image2.colorsteps.map((it) => {
          const offset = it.toLength();
          return {
            id: it.id,
            cut: it.cut,
            color: it.color,
            timing: it.timing,
            timingCount: it.timingCount,
            pos: lerp$1([], result.startPoint, result.endPoint, offset.value / 100)
          };
        });
        break;
      case GradientType.LINEAR:
        newX1 = image2.x1.toPx(backRect.width);
        newY1 = image2.y1.toPx(backRect.height);
        newX2 = image2.x2.toPx(backRect.width);
        newY2 = image2.y2.toPx(backRect.height);
        var [newStartPoint, newEndPoint] = vertiesMap([
          [newX1.value, newY1.value, 0],
          [newX2.value, newY2.value, 0]
        ], this.absoluteMatrix);
        result.endPoint = newEndPoint;
        result.startPoint = newStartPoint;
        result.areaStartPoint = clone(newStartPoint);
        result.areaEndPoint = clone(newEndPoint);
        result.colorsteps = image2.colorsteps.map((it) => {
          const offset = it.toLength();
          return {
            id: it.id,
            cut: it.cut,
            color: it.color,
            timing: it.timing,
            timingCount: it.timingCount,
            pos: lerp$1([], result.startPoint, result.endPoint, offset.value / 100)
          };
        });
        break;
    }
    return result;
  }
}
class PathModel extends SVGModel {
  getIcon() {
    return obj$3.edit;
  }
  getDefaultObject(obj2 = {}) {
    return super.getDefaultObject(__spreadValues({
      itemType: "svg-path",
      name: "New Path",
      strokeWidth: 1,
      d: "",
      totalLength: 0
    }, obj2));
  }
  enableHasChildren() {
    return false;
  }
  reset(json, context = { origin: "*" }) {
    const isChanged = super.reset(json, context);
    if (this.hasChangedField("d")) {
      this.cachePath = new PathParser(this.d);
      this.cacheWidth = this.width;
      this.cacheHeight = this.height;
    }
    return isChanged;
  }
  refreshMatrixCache() {
    super.refreshMatrixCache();
    if (this.hasChangedField("d")) {
      this.cachePath = new PathParser(this.d);
      this.cacheWidth = this.width;
      this.cacheHeight = this.height;
    } else if (this.hasChangedField("width", "height")) {
      this.d = this.cachePath.clone().scale(this.width / this.cacheWidth, this.height / this.cacheHeight).d;
      this.modelManager.setChanged("reset", this.id, { d: this.d });
    }
  }
  setCache() {
    super.setCache();
    this.cachePath = new PathParser(this.get("d"));
    this.cacheWidth = this.width;
    this.cacheHeight = this.height;
  }
  get d() {
    if (!this.get("d")) {
      return null;
    }
    if (!this.cachePath) {
      this.cachePath = new PathParser(this.get("d"));
      this.cacheWidth = this.width;
      this.cacheHeight = this.height;
    }
    return this.cachePath.clone().scale(this.width / this.cacheWidth, this.height / this.cacheHeight).d;
  }
  set d(value) {
    this.set("d", value);
  }
  getDefaultTitle() {
    return "Path";
  }
}
class BooleanPathModel extends PathModel {
  getIcon() {
    return obj$3.edit;
  }
  getDefaultObject(obj2 = {}) {
    return super.getDefaultObject(__spreadValues({
      itemType: "boolean-path",
      name: "New Boolean Path",
      strokeWidth: 1,
      d: "",
      booleanOperation: "none"
    }, obj2));
  }
  get booleanOperation() {
    return this.get("booleanOperation");
  }
  set booleanOperation(value) {
    this.set("booleanOperation", value);
  }
  enableHasChildren() {
    return true;
  }
  reset(json, context = { origin: "*" }) {
    var _a;
    const isChanged = super.reset(json, context);
    if (!this.cachePath) {
      this.setCache();
    }
    if (this.hasChangedField("changedChildren", "booleanOperation")) {
      if (this.children.length === 1) {
        const newPath = this.layers[0].absolutePath().d;
        this.d = this.invertPath(newPath).d;
        this.setCache();
        this.modelManager.setChanged("reset", this.id, { d: newPath });
      } else if (this.booleanOperation !== "none") {
        if (((_a = this.children) == null ? void 0 : _a.length) >= 2) {
          if (this.modelManager.editor.pathKitManager.has()) {
            const paths = this.layers.filter((it) => it.d);
            if (paths.length >= 2) {
              const newPath = this.doBooleanOperation();
              this.d = newPath;
              this.setCache();
              this.modelManager.setChanged("reset", this.id, { d: newPath });
            } else {
              this.d = void 0;
              this.removeCache();
              this.modelManager.setChanged("reset", this.id, { d: void 0 });
            }
          }
        }
      }
    }
    return isChanged;
  }
  get resizableWitChildren() {
    return true;
  }
  startToCacheChildren() {
    this.cachedSize = {
      width: this.width,
      height: this.height
    };
    this.cachedLayerMatrix = this.layers.map((item) => {
      item.startToCacheChildren();
      return {
        item,
        matrix: item.matrix
      };
    });
  }
  recoverChildren() {
    const obj2 = {
      width: this.width,
      height: this.height
    };
    const scaleX = obj2.width / this.cachedSize.width;
    const scaleY = obj2.height / this.cachedSize.height;
    this.cachedLayerMatrix.forEach(({ item, matrix }) => {
      item.reset({
        x: item.x.changeUnitValue(matrix.x * scaleX, obj2.width),
        y: item.y.changeUnitValue(matrix.y * scaleY, obj2.height),
        width: item.width.changeUnitValue(matrix.width * scaleX, obj2.width),
        height: item.height.changeUnitValue(matrix.height * scaleY, obj2.height)
      });
      item.recoverChildren();
    });
  }
  getFieldValueByBooleanOperation(field) {
    const layers2 = this.layers;
    if (layers2.length === 0) {
      return;
    } else if (layers2.length === 1) {
      return layers2[0][field];
    }
    const op = this.booleanOperation;
    switch (op) {
      case BooleanOperation.DIFFERENCE:
        return layers2[1][field];
    }
    return layers2[0][field];
  }
  get fill() {
    return this.getFieldValueByBooleanOperation("fill");
  }
  get stroke() {
    return this.getFieldValueByBooleanOperation("stroke");
  }
  setCache() {
    super.setCache();
    this.cachePath = new PathParser(this.d);
    this.cacheWidth = this.width;
    this.cacheHeight = this.height;
  }
  removeCache() {
    super.removeCache();
    this.cachePath = void 0;
    this.cacheWidth = void 0;
    this.cacheHeight = void 0;
  }
  getDefaultTitle() {
    return "Path";
  }
  doBooleanOperation() {
    const op = this.booleanOperation;
    switch (op) {
      case BooleanOperation.INTERSECTION:
        return this.intersection();
      case BooleanOperation.UNION:
        return this.union();
      case BooleanOperation.DIFFERENCE:
        return this.difference();
      case BooleanOperation.REVERSE_DIFFERENCE:
        return this.reverseDifference();
      case BooleanOperation.XOR:
        return this.xor();
    }
    return "";
  }
  getPathList() {
    return this.layers.map((it) => it.absolutePath().d);
  }
  intersection() {
    const [first, ...rest] = this.getPathList();
    const newPath = rest.reduce((path1, path2) => {
      return this.modelManager.editor.pathKitManager.intersection(path1, path2);
    }, first);
    return this.invertPath(newPath).d;
  }
  union() {
    const [first, ...rest] = this.getPathList();
    const newPath = rest.reduce((path1, path2) => {
      return this.modelManager.editor.pathKitManager.union(path1, path2);
    }, first);
    return this.invertPath(newPath).d;
  }
  difference() {
    const [first, ...rest] = this.getPathList();
    const newPath = rest.reduce((path1, path2) => {
      return this.modelManager.editor.pathKitManager.difference(path1, path2);
    }, first);
    return this.invertPath(newPath).d;
  }
  reverseDifference() {
    const [first, ...rest] = this.getPathList();
    const newPath = rest.reduce((path1, path2) => {
      return this.modelManager.editor.pathKitManager.reverseDifference(path1, path2);
    }, first);
    return this.invertPath(newPath).d;
  }
  xor() {
    const [first, ...rest] = this.getPathList();
    const newPath = rest.reduce((path1, path2) => {
      return this.modelManager.editor.pathKitManager.xor(path1, path2);
    }, first);
    return this.invertPath(newPath).d;
  }
}
class CircleLayer extends LayerModel {
  getIcon() {
    return obj$3.lens;
  }
  getDefaultObject(obj2 = {}) {
    return super.getDefaultObject(__spreadValues({
      itemType: "circle",
      name: "New Circle",
      borderRadius: "100%"
    }, obj2));
  }
  getDefaultTitle() {
    return "Circle";
  }
}
class ImageLayer extends LayerModel {
  getIcon() {
    return obj$3.image;
  }
  getDefaultObject(obj2 = {}) {
    return super.getDefaultObject(__spreadValues({
      itemType: "image",
      name: "New Image",
      elementType: "image",
      src: ""
    }, obj2));
  }
  get src() {
    return this.get("src");
  }
  set src(value) {
    this.set("src", value);
  }
  get naturalWidth() {
    return this.get("naturalWidth");
  }
  set naturalWidth(value) {
    this.set("naturalWidth", value);
  }
  get naturalHeight() {
    return this.get("naturalHeight");
  }
  set naturalHeight(value) {
    this.set("naturalHeight", value);
  }
  enableHasChildren() {
    return false;
  }
  getDefaultTitle() {
    return "Image";
  }
  resize() {
    this.reset({
      width: this.naturalWidth.clone(),
      height: this.naturalHeight.clone()
    });
  }
}
class PolygonModel extends SVGModel {
  getIcon() {
    return obj$3.edit;
  }
  getDefaultObject(obj2 = {}) {
    return super.getDefaultObject(__spreadValues({
      itemType: "polygon",
      name: "New Polygon",
      strokeWidth: 1,
      count: 3
    }, obj2));
  }
  get count() {
    return this.get("count");
  }
  set count(value) {
    this.set("count", value);
  }
  convert(json) {
    json = super.convert(json);
    if (json.count)
      json.count = +json.count;
    return json;
  }
  enableHasChildren() {
    return false;
  }
  get editablePath() {
    return false;
  }
  get d() {
    const { width: width2, height: height2, count } = this;
    return PathParser.makePolygon(width2, height2, count).d;
  }
  getDefaultTitle() {
    return "Polygon";
  }
  isPointInPath(point2) {
    const localPoint = transformMat4([], point2, this.absoluteMatrixInverse);
    return this.cachePath.isPointInPath({ x: localPoint[0], y: localPoint[1] }, this.strokeWidth || 0);
  }
}
function makeInterpolateIdentity(layer, property, value) {
  return () => {
    return value;
  };
}
function makeInterpolateNumber(layer, property, startNumber, endNumber, unit = void 0) {
  return (rate, t) => {
    var result = 0;
    if (t === 0) {
      result = startNumber;
    } else if (t === 1) {
      result = endNumber;
    } else {
      result = startNumber + (endNumber - startNumber) * rate;
    }
    if (unit) {
      return result + unit;
    }
    return result;
  };
}
function getRealAttributeValue(layer, property, value, refType = "width", refElement = "parent") {
  var refObject = null;
  if (refElement === "parent") {
    refObject = layer[refElement][refType];
  } else if (refElement === "self") {
    refObject = layer[refType];
  }
  if (refObject) {
    return value.toPx(refObject.value);
  }
  return value;
}
function rollbackRealAttributeValue(layer, property, value, unit, refType = "width", refElement = "parent") {
  var refObject = null;
  if (refElement === "parent") {
    refObject = layer[refElement][refType];
  } else if (refElement === "self") {
    refObject = layer[refType];
  }
  if (refObject) {
    return value.to(unit, refObject.value);
  }
  return value;
}
function makeInterpolateLength(layer, property, startNumber, endNumber, refType = "width", refElement = "parent") {
  var s = Length.parse(startNumber);
  var e = Length.parse(endNumber);
  if (s.unit === e.unit) {
    return makeInterpolateNumber(layer, property, s.value, e.value, s.unit);
  } else if (s.equals(e)) {
    return makeInterpolateIdentity(layer, property, s);
  }
  return (rate, t) => {
    var realStartValue = getRealAttributeValue(layer, property, s, refType, refElement);
    var realEndValue = getRealAttributeValue(layer, property, e, refType, refElement);
    if (t === 0) {
      return realStartValue;
    } else if (t === 1) {
      return realEndValue;
    }
    return rollbackRealAttributeValue(layer, property, realStartValue.value + (realEndValue.value - realStartValue.value) * rate, s.unit, refType, refElement);
  };
}
function makeInterpolateBoolean(layer, property, s, e) {
  return (ratio, t) => {
    if (t === 1) {
      return e;
    }
    return s;
  };
}
function makeInterpolateColor(layer, property, startColor, endColor) {
  var s = parse(startColor || "rgba(0, 0, 0, 1)");
  var e = parse(endColor || "rgba(0, 0, 0, 1)");
  return (rate, t) => {
    if (t === 0) {
      return startColor;
    } else if (t === 1) {
      return endColor;
    }
    return interpolateRGB(s, e, rate, "rgb");
  };
}
function makeInterpolateString(layer, property, startString, endString) {
  return makeInterpolateBoolean(layer, property, startString, endString);
}
function makeInterpolateColorStep(layer, property, startColorStep, endColorStep) {
  var obj2 = {
    cut: makeInterpolateBoolean(layer, property, startColorStep.cut, endColorStep.cut),
    percent: makeInterpolateNumber(layer, property, startColorStep.percent, endColorStep.percent),
    px: makeInterpolateNumber(layer, property, startColorStep.px, endColorStep.px),
    em: makeInterpolateNumber(layer, property, startColorStep.em, endColorStep.em),
    unit: makeInterpolateString(layer, property, startColorStep.unit, endColorStep.unit),
    color: makeInterpolateColor(layer, property, startColorStep.color, endColorStep.color)
  };
  return (rate, t) => {
    return new ColorStep({
      cut: obj2.cut(rate, t),
      percent: obj2.percent(rate, t),
      px: obj2.px(rate, t),
      em: obj2.em(rate, t),
      unit: obj2.unit(rate, t),
      color: obj2.color(rate, t)
    });
  };
}
function makeInterpolateColorStepList(layer, property, startColorsteps = [], endColorsteps = []) {
  var max = Math.max(startColorsteps.length, endColorsteps.length);
  var list2 = [];
  for (var i = 0; i < max; i++) {
    var s = startColorsteps[i];
    var e = endColorsteps[i];
    if (s && e) {
      list2[i] = makeInterpolateColorStep(layer, property, s, e);
    } else {
      list2[i] = makeInterpolateBoolean(layer, property, s, e);
    }
  }
  return (rate, t) => {
    return list2.map((it) => it(rate, t));
  };
}
function makeInterpolateConicGradient(layer, property, s, e) {
  var obj2 = {
    angle: makeInterpolateNumber(layer, property, s.angle, e.angle),
    radialPositionX: makeInterpolateLength(layer, property, s.radialPosition[0], e.radialPosition[0], "width", "self"),
    radialPositionY: makeInterpolateLength(layer, property, s.radialPosition[1], e.radialPosition[1], "height", "self"),
    colorsteps: makeInterpolateColorStepList(layer, property, s.colorsteps, e.colorsteps)
  };
  return (rate, t) => {
    return new ConicGradient({
      angle: obj2.angle(rate, t),
      radialPosition: [
        obj2.radialPositionX(rate, t),
        obj2.radialPositionY(rate, t)
      ],
      colorsteps: obj2.colorsteps(rate, t)
    });
  };
}
function makeInterpolateLinearGradient(layer, property, s, e) {
  var obj2 = {
    angle: makeInterpolateNumber(layer, property, s.angle, e.angle),
    colorsteps: makeInterpolateColorStepList(layer, property, s.colorsteps, e.colorsteps)
  };
  return (rate, t) => {
    var colorsteps = obj2.colorsteps(rate, t);
    return new LinearGradient({
      angle: obj2.angle(rate, t),
      colorsteps
    });
  };
}
function convertPercent(value, type) {
  switch (type) {
    case "width":
      if (value === "center") {
        return "50%";
      } else if (value === "left") {
        return "0%";
      } else if (value === "right") {
        return "100%";
      }
      break;
    case "height":
      if (value === "center") {
        return "50%";
      } else if (value === "top") {
        return "0%";
      } else if (value === "bottom") {
        return "100%";
      }
      break;
  }
  return value;
}
function makeInterpolateRadialGradient(layer, property, s, e) {
  s.radialPosition[0] = convertPercent(s.radialPosition[0], "width");
  s.radialPosition[1] = convertPercent(s.radialPosition[1], "height");
  e.radialPosition[0] = convertPercent(e.radialPosition[0], "width");
  e.radialPosition[1] = convertPercent(e.radialPosition[1], "height");
  var obj2 = {
    radialType: makeInterpolateString(layer, property, s.radialType, e.radialType),
    radialPositionX: makeInterpolateLength(layer, property, s.radialPosition[0], e.radialPosition[0], "width", "self"),
    radialPositionY: makeInterpolateLength(layer, property, s.radialPosition[1], e.radialPosition[1], "height", "self"),
    colorsteps: makeInterpolateColorStepList(layer, property, s.colorsteps, e.colorsteps)
  };
  return (rate, t) => {
    var results = new RadialGradient({
      radialType: obj2.radialType(rate, t),
      radialPosition: [
        obj2.radialPositionX(rate, t),
        obj2.radialPositionY(rate, t)
      ],
      colorsteps: obj2.colorsteps(rate, t)
    });
    return results;
  };
}
function makeInterpolateRepeatingConicGradient(layer, property, s, e) {
  var func = makeInterpolateConicGradient(layer, property, s, e);
  return (rate, t) => {
    var obj2 = func(rate, t);
    return new RepeatingConicGradient({
      angle: obj2.angle,
      radialPosition: obj2.radialPosition,
      colorsteps: obj2.colorsteps
    });
  };
}
function makeInterpolateRepeatingLinearGradient(layer, property, s, e) {
  var func = makeInterpolateLinearGradient(layer, property, s, e);
  return (rate, t) => {
    var obj2 = func(rate, t);
    var results = new RepeatingLinearGradient({
      angle: obj2.angle,
      colorsteps: obj2.colorsteps
    });
    return results;
  };
}
function makeInterpolateRepeatingRadialGradient(layer, property, s, e) {
  var func = makeInterpolateRadialGradient(layer, property, s, e);
  return (rate, t) => {
    var obj2 = func(rate, t);
    return new RepeatingRadialGradient({
      radialType: obj2.radialType,
      radialPosition: obj2.radialPosition,
      colorsteps: obj2.colorsteps
    });
  };
}
function makeInterpolateImageResource(layer, property, s, e) {
  var obj2 = {
    image: (rate, t) => {
      return t;
    }
  };
  if (s.type === "url" || e.type === "url") {
    obj2.image = makeInterpolateBoolean(layer, property, s, e);
  } else {
    if (s.type != e.type) {
      obj2.image = makeInterpolateBoolean(layer, property, s, e);
    } else {
      switch (s.type) {
        case "linear-gradient":
          obj2.image = makeInterpolateLinearGradient(layer, property, s, e);
          break;
        case "repeating-linear-gradient":
          obj2.image = makeInterpolateRepeatingLinearGradient(layer, property, s, e);
          break;
        case "radial-gradient":
          obj2.image = makeInterpolateRadialGradient(layer, property, s, e);
          break;
        case "repeating-radial-gradient":
          obj2.image = makeInterpolateRepeatingRadialGradient(layer, property, s, e);
          break;
        case "conic-gradient":
          obj2.image = makeInterpolateConicGradient(layer, property, s, e);
          break;
        case "repeating-conic-gradient":
          obj2.image = makeInterpolateRepeatingConicGradient(layer, property, s, e);
          break;
      }
    }
  }
  return (rate, t) => {
    return obj2.image(rate, t);
  };
}
function makeInterpolateBackgroundImage(layer, property, startValue, endValue) {
  var s = BackgroundImage.parseStyle(STRING_TO_CSS(startValue));
  var e = BackgroundImage.parseStyle(STRING_TO_CSS(endValue));
  var totalLength = Math.max(s.length, e.length);
  var list2 = [];
  for (var i = 0, len2 = totalLength; i < len2; i++) {
    var startObject = s[i] || null;
    var endObject = e[i] || null;
    if (startObject && !endObject) {
      list2.push({
        image: makeInterpolateIdentity(layer, property, startObject.image),
        size: makeInterpolateIdentity(layer, property, startObject.size),
        width: makeInterpolateIdentity(layer, property, startObject.width),
        height: makeInterpolateIdentity(layer, property, startObject.height),
        x: makeInterpolateIdentity(layer, property, startObject.x),
        y: makeInterpolateIdentity(layer, property, startObject.y),
        blendMode: makeInterpolateIdentity(layer, property, startObject.blendMode),
        repeat: makeInterpolateIdentity(layer, property, startObject.repeat)
      });
    } else if (!startObject && endObject) {
      list2.push({
        image: makeInterpolateIdentity(layer, property, endObject.image),
        size: makeInterpolateIdentity(layer, property, endObject.size),
        width: makeInterpolateIdentity(layer, property, endObject.width),
        height: makeInterpolateIdentity(layer, property, endObject.height),
        x: makeInterpolateIdentity(layer, property, endObject.x),
        y: makeInterpolateIdentity(layer, property, endObject.y),
        blendMode: makeInterpolateIdentity(layer, property, endObject.blendMode),
        repeat: makeInterpolateIdentity(layer, property, endObject.repeat)
      });
    } else if (startObject && endObject) {
      list2.push({
        image: makeInterpolateImageResource(layer, property, startObject.image, endObject.image),
        size: makeInterpolateString(layer, property, startObject.size, endObject.size),
        width: makeInterpolateLength(layer, property, startObject.width, endObject.width, "width", "self"),
        height: makeInterpolateLength(layer, property, startObject.height, endObject.height, "height", "self"),
        x: makeInterpolateLength(layer, property, startObject.x, endObject.x, "width", "self"),
        y: makeInterpolateLength(layer, property, startObject.y, endObject.y, "height", "self"),
        blendMode: makeInterpolateString(layer, property, startObject.blendMode, endObject.blendMode),
        repeat: makeInterpolateString(layer, property, startObject.repeat, endObject.repeat)
      });
    }
  }
  return (rate, t) => {
    return BackgroundImage.join(list2.map((it) => {
      var data = {
        image: it.image(rate, t),
        size: it.size(rate, t),
        x: it.x(rate, t),
        y: it.y(rate, t),
        width: it.width(rate, t),
        height: it.height(rate, t),
        blendMode: it.blendMode(rate, t),
        repeat: it.repeat(rate, t)
      };
      return data;
    }));
  };
}
const getBorderRadiusList = (radiusValue) => {
  var startObject = [];
  if (radiusValue.isAll) {
    startObject = [
      radiusValue["border-radius"] || "0px",
      radiusValue["border-radius"] || "0px",
      radiusValue["border-radius"] || "0px",
      radiusValue["border-radius"] || "0px"
    ];
  } else {
    startObject = [
      radiusValue["border-top-left-radius"] || "0px",
      radiusValue["border-top-right-radius"] || "0px",
      radiusValue["border-bottom-right-radius"] || "0px",
      radiusValue["border-bottom-left-radius"] || "0px"
    ];
  }
  return startObject;
};
function makeInterpolateBorderRadius(layer, property, startValue, endValue) {
  var s = getBorderRadiusList(BorderRadius.parseStyle(startValue));
  var e = getBorderRadiusList(BorderRadius.parseStyle(endValue));
  var max = Math.max(s.length, e.length);
  var list2 = [];
  for (var i = 0; i < max; i++) {
    list2[i] = makeInterpolateLength(layer, property, s[i], e[i]);
  }
  return (rate, t) => {
    return list2.map((it) => it(rate, t)).join(" ");
  };
}
function makeInterpolateBoxShadow(layer, property, startValue, endValue) {
  var s = BoxShadow.parseStyle(startValue);
  var e = BoxShadow.parseStyle(endValue);
  var totalLength = Math.max(s.length, e.length);
  var list2 = [];
  for (var i = 0, len2 = totalLength; i < len2; i++) {
    var startObject = s[i] || BoxShadow.parseStyle("0px 0px 0px 0px rgba(0, 0, 0, 0)")[0];
    var endObject = e[i] || BoxShadow.parseStyle("0px 0px 0px 0px rgba(0, 0, 0, 0)")[0];
    list2.push({
      inset: makeInterpolateBoolean(layer, property, startObject.inset, endObject.inset),
      offsetX: makeInterpolateLength(layer, property, startObject.offsetX, endObject.offsetX),
      offsetY: makeInterpolateLength(layer, property, startObject.offsetY, endObject.offsetY),
      blurRadius: makeInterpolateLength(layer, property, startObject.blurRadius, endObject.blurRadius),
      spreadRadius: makeInterpolateLength(layer, property, startObject.spreadRadius, endObject.spreadRadius),
      color: makeInterpolateColor(layer, property, startObject.color, endObject.color)
    });
  }
  return (rate, t) => {
    return BoxShadow.join(list2.map((it) => {
      return {
        inset: it.inset(rate, t),
        offsetX: it.offsetX(rate, t),
        offsetY: it.offsetY(rate, t),
        blurRadius: it.blurRadius(rate, t),
        spreadRadius: it.spreadRadius(rate, t),
        color: it.color(rate, t)
      };
    }));
  };
}
function makeInterpolateClipPathCircle(layer, property, s, e) {
  var obj2 = {};
  if (s.radius === "closest-side" || s.radius === "farthest-side" || e.radius === "closest-side" || e.radius === "farthest-side") {
    obj2.radius = makeInterpolateBoolean(layer, property, s.radius, e.radius);
  } else {
    if (s.radius.unit === e.radius.unit) {
      obj2.radius = makeInterpolateNumber(layer, property, s.radius.value, e.radius.value, s.radius.unit);
    } else {
      obj2.radius = makeInterpolateLength(layer, property, s.radius, e.radius, "width", "self");
    }
  }
  obj2.x = makeInterpolateLength(layer, property, s.x, e.x, "width", "self");
  obj2.y = makeInterpolateLength(layer, property, s.y, e.y, "height", "self");
  return (rate, t) => {
    var radius = obj2.radius(rate, t);
    var x = obj2.x(rate, t);
    var y = obj2.y(rate, t);
    var results = `${x} ${y}`;
    var radiusString = radius + "";
    if (radiusString.includes("closest-side")) {
      radiusString = "closest-side";
    } else if (radiusString.includes("farthest-side")) {
      radiusString = "farthest-side";
    }
    return radius ? `${radiusString} at ${results}` : `${results}`;
  };
}
function makeInterpolateClipPathEllipse(layer, property, s, e) {
  var obj2 = {
    radiusX: makeInterpolateLength(layer, property, s.radiusX, e.radiusX, "width", "self"),
    radiusY: makeInterpolateLength(layer, property, s.radiusY, e.radiusY, "height", "self"),
    x: makeInterpolateLength(layer, property, s.x, e.x, "width", "self"),
    y: makeInterpolateLength(layer, property, s.y, e.y, "height", "self")
  };
  return (rate, t) => {
    var radiusX = obj2.radiusX(rate, t);
    var radiusY = obj2.radiusY(rate, t);
    var x = obj2.x(rate, t);
    var y = obj2.y(rate, t);
    return `${radiusX} ${radiusY} at ${x} ${y}`;
  };
}
function makeInterpolateClipPathInset(layer, property, s, e) {
  var obj2 = {
    top: makeInterpolateNumber(layer, property, s.top.value, e.top.value, s.top.unit),
    left: makeInterpolateNumber(layer, property, s.left.value, e.left.value, s.left.unit),
    right: makeInterpolateNumber(layer, property, s.right.value, e.right.value, s.right.unit),
    bottom: makeInterpolateNumber(layer, property, s.bottom.value, e.bottom.value, s.bottom.unit),
    round: makeInterpolateBoolean(layer, property, s.round, e.round),
    topRadius: makeInterpolateNumber(layer, property, s.topRadius.value, e.topRadius.value, s.topRadius.unit),
    leftRadius: makeInterpolateNumber(layer, property, s.leftRadius.value, e.leftRadius.value, s.leftRadius.unit),
    rightRadius: makeInterpolateNumber(layer, property, s.rightRadius.value, e.rightRadius.value, s.rightRadius.unit),
    bottomRadius: makeInterpolateNumber(layer, property, s.bottomRadius.value, e.bottomRadius.value, s.bottomRadius.unit)
  };
  return (rate, t) => {
    var top2 = obj2.top(rate, t);
    var right2 = obj2.right(rate, t);
    var bottom2 = obj2.bottom(rate, t);
    var left2 = obj2.left(rate, t);
    var round2 = obj2.round(rate, t);
    var topRadius = obj2.topRadius(rate, t);
    var leftRadius = obj2.leftRadius(rate, t);
    var bottomRadius = obj2.bottomRadius(rate, t);
    var rightRadius = obj2.rightRadius(rate, t);
    var position2 = [top2, right2, bottom2, left2].join(" ");
    var radius = [topRadius, rightRadius, bottomRadius, leftRadius].join(" ");
    var results = `${position2} ${round2 && radius.trim() ? `round ${radius}` : ""}`;
    return results;
  };
}
function makeInterpolateClipPathPolygon(layer, property, s, e) {
  var max = Math.max(s.length, e.length);
  var list2 = [];
  for (var i = 0; i < max; i++) {
    var startPos = s[i];
    var endPos = e[i];
    if (startPos && !endPos) {
      list2.push({
        x: makeInterpolateIdentity(layer, property, startPos.x),
        y: makeInterpolateIdentity(layer, property, startPos.y)
      });
    } else if (!startPos && endPos) {
      list2.push({
        x: makeInterpolateIdentity(layer, property, endPos.x),
        y: makeInterpolateIdentity(layer, property, endPos.y)
      });
    } else {
      list2.push({
        x: makeInterpolateLength(layer, property, startPos.x, endPos.x, "width", "self"),
        y: makeInterpolateLength(layer, property, startPos.y, endPos.y, "height", "self")
      });
    }
  }
  return (rate, t) => {
    return list2.map((it) => {
      return `${it.x(rate, t)} ${it.y(rate, t)}`;
    }).join(",");
  };
}
function makeInterpolateClipPath(layer, property, startValue, endValue) {
  var startObject = ClipPath.parseStyle(startValue);
  var endObject = ClipPath.parseStyle(endValue);
  var obj2 = {
    type: makeInterpolateBoolean(layer, property, startObject.type, startObject.type),
    value: makeInterpolateBoolean(layer, property, startValue, endValue)
  };
  if (startObject.type == endObject.type && startObject != "none") {
    switch (startObject.type) {
      case "circle":
        startObject.value = ClipPath.parseStyleForCircle(startObject.value);
        endObject.value = ClipPath.parseStyleForCircle(endObject.value);
        obj2.value = makeInterpolateClipPathCircle(layer, property, startObject.value, endObject.value);
        break;
      case "ellipse":
        startObject.value = ClipPath.parseStyleForEllipse(startObject.value);
        endObject.value = ClipPath.parseStyleForEllipse(endObject.value);
        obj2.value = makeInterpolateClipPathEllipse(layer, property, startObject.value, endObject.value);
        break;
      case "inset":
        startObject.value = ClipPath.parseStyleForInset(startObject.value);
        endObject.value = ClipPath.parseStyleForInset(endObject.value);
        obj2.value = makeInterpolateClipPathInset(layer, property, startObject.value, endObject.value);
        break;
      case "polygon":
        startObject.value = ClipPath.parseStyleForPolygon(startObject.value);
        endObject.value = ClipPath.parseStyleForPolygon(endObject.value);
        obj2.value = makeInterpolateClipPathPolygon(layer, property, startObject.value, endObject.value);
        break;
      case "path":
        startObject.value = ClipPath.parseStyleForPath(startObject.value);
        endObject.value = ClipPath.parseStyleForPath(endObject.value);
        break;
    }
  }
  return (rate, t) => {
    var type = obj2.type(rate, t);
    var value = obj2.value(rate, t);
    if (type === "none") {
      return type;
    }
    return `${type}(${value})`;
  };
}
function makeInterpolateFilterItem(layer, property, startValue, endValue) {
  var obj2 = {
    type: makeInterpolateString(layer, property, startValue.type, endValue.type),
    value: makeInterpolateBoolean(layer, property, startValue.value, endValue.value)
  };
  switch (startValue.type) {
    case "blur":
      obj2.value = makeInterpolateLength(layer, property, startValue.value, endValue.value);
      break;
    case "grayscale":
    case "invert":
    case "brightness":
    case "contrast":
    case "opacity":
    case "saturate":
    case "sepia":
    case "hue-rotate":
      obj2.value = makeInterpolateNumber(layer, property, startValue.value.value, endValue.value.value, startValue.value.unit);
      break;
    case "drop-shadow":
      obj2.offsetX = makeInterpolateLength(layer, property, startValue.offsetX, endValue.offsetX, "width", "self");
      obj2.offsetY = makeInterpolateLength(layer, property, startValue.offsetY, endValue.offsetY, "height", "self");
      obj2.blurRadius = makeInterpolateLength(layer, property, startValue.blurRadius, endValue.blurRadius, "width", "self");
      obj2.spreadRadius = makeInterpolateLength(layer, property, startValue.spreadRadius, endValue.spreadRadius, "width", "self");
      obj2.color = makeInterpolateColor(layer, property, startValue.color, endValue.color);
      break;
  }
  return (rate, t) => {
    var type = obj2.type(rate, t);
    if (type === "drop-shadow") {
      return {
        type: obj2.type(rate, t),
        offsetX: obj2.offsetX(rate, t),
        offsetY: obj2.offsetY(rate, t),
        blurRadius: obj2.blurRadius(rate, t),
        spreadRadius: obj2.spreadRadius(rate, t),
        color: obj2.color(rate, t)
      };
    } else {
      return {
        type: obj2.type(rate, t),
        value: obj2.value(rate, t)
      };
    }
  };
}
function makeInterpolateFilter(layer, property, startValue, endValue) {
  var s = Filter.parseStyle(startValue);
  var e = Filter.parseStyle(endValue);
  var totalLength = Math.max(s.length, e.length);
  var list2 = [];
  for (var i = 0, len2 = totalLength; i < len2; i++) {
    var startObject = s[i];
    var endObject = e[i];
    if (startObject && !endObject) {
      list2.push(makeInterpolateIdentity(layer, property, startObject));
    } else if (!startObject && endObject) {
      list2.push(makeInterpolateIdentity(layer, property, endObject));
    } else {
      if (startObject.type != endObject.type || startObject.type === "svg" || endObject.type === "svg") {
        list2.push(makeInterpolateBoolean(layer, property, startObject, endObject));
      } else {
        list2.push(makeInterpolateFilterItem(layer, property, startObject, endObject));
      }
    }
  }
  return (rate, t) => {
    return Filter.join(list2.map((it) => it(rate, t)));
  };
}
function makeInterpolateCubic(sx, sy, cx1, cy1, cx2, cy2, ex, ey) {
  var points = [
    { x: sx, y: sy },
    { x: cx1, y: cy1 },
    { x: cx2, y: cy2 },
    { x: ex, y: ey }
  ];
  return (rate, t) => {
    return getBezierPointOne(points, t);
  };
}
function makeInterpolateLine(x1, y1, x2, y2) {
  var obj2 = {
    x: makeInterpolateNumber("", "", x1, x2),
    y: makeInterpolateNumber("", "", y1, y2)
  };
  return (rate, t) => {
    var results = {
      x: obj2.x(rate, t),
      y: obj2.y(rate, t)
    };
    return results;
  };
}
function makeInterpolateQuard(sx, sy, cx1, cy1, ex, ey) {
  var points = [
    { x: sx, y: sy },
    { x: cx1, y: cy1 },
    { x: ex, y: ey }
  ];
  return (rate, t) => {
    return getBezierPointOneQuard(points, t);
  };
}
function makeInterpolateOffset(segments) {
  var interpolateList = [];
  var startPoint = [];
  segments.forEach((segment) => {
    switch (segment.command) {
      case "M":
        var [ex, ey] = segment.values;
        startPoint = [ex, ey];
        break;
      case "m":
        var [sx, sy] = startPoint;
        var [ex, ey] = segment.values;
        ex += sx;
        ey += sy;
        startPoint = [ex, ey];
        break;
      case "L":
        var [sx, sy] = startPoint;
        var [ex, ey] = segment.values;
        interpolateList.push({
          command: segment.command,
          values: [sx, sy, ex, ey],
          length: getDist(sx, sy, ex, ey),
          interpolate: makeInterpolateLine(sx, sy, ex, ey)
        });
        startPoint = [ex, ey];
        break;
      case "l":
        var [sx, sy] = startPoint;
        var [ex, ey] = segment.values;
        ex += sx;
        ey += sy;
        interpolateList.push({
          command: segment.command,
          values: [sx, sy, ex, ey],
          length: getDist(sx, sy, ex, ey),
          interpolate: makeInterpolateLine(sx, sy, ex, ey)
        });
        startPoint = [ex, ey];
        break;
      case "C":
        var [sx, sy] = startPoint;
        var [cx1, cy1, cx2, cy2, ex, ey] = segment.values;
        interpolateList.push({
          command: segment.command,
          values: [sx, sy, cx1, cy1, cx2, cy2, ex, ey],
          length: getCurveDist(sx, sy, cx1, cy1, cx2, cy2, ex, ey),
          interpolate: makeInterpolateCubic(sx, sy, cx1, cy1, cx2, cy2, ex, ey)
        });
        startPoint = [ex, ey];
        break;
      case "c":
        var [sx, sy] = startPoint;
        var [cx1, cy1, cx2, cy2, ex, ey] = segment.values;
        cx1 += sx;
        cx2 += sx;
        ex += sx;
        cy1 += sy;
        cy2 += sy;
        ey += sy;
        interpolateList.push({
          command: segment.command,
          values: [sx, sy, cx1, cy1, cx2, cy2, ex, ey],
          length: getCurveDist(sx, sy, cx1, cy1, cx2, cy2, ex, ey),
          interpolate: makeInterpolateCubic(sx, sy, cx1, cy1, cx2, cy2, ex, ey)
        });
        startPoint = [ex, ey];
        break;
      case "Q":
        var [sx, sy] = startPoint;
        var [cx1, cy1, ex, ey] = segment.values;
        interpolateList.push({
          command: segment.command,
          values: [sx, sy, cx1, cy1, ex, ey],
          length: getQuardDist(sx, sy, cx1, cy1, ex, ey),
          interpolate: makeInterpolateQuard(sx, sy, cx1, cy1, ex, ey)
        });
        startPoint = [ex, ey];
        break;
      case "q":
        var [sx, sy] = startPoint;
        var [cx1, cy1, ex, ey] = segment.values;
        cx1 += sx;
        ex += sx;
        cy1 += sy;
        ey += sy;
        interpolateList.push({
          command: segment.command,
          values: [sx, sy, cx1, cy1, ex, ey],
          length: getQuardDist(sx, sy, cx1, cy1, ex, ey),
          interpolate: makeInterpolateQuard(sx, sy, cx1, cy1, ex, ey)
        });
        startPoint = [ex, ey];
        break;
      case "S":
        var [sx, sy] = startPoint;
        var [cx2, cy2, ex, ey] = segment.values;
        var prevSegment = interpolateList[interpolateList.length - 1];
        if (["C", "c", "S", "s"].includes(prevSegment.command)) {
          var [, , , , preC1x, preC1y, preEx, preEy] = prevSegment.values;
          var { x: cx1, y: cy1 } = Point.getReversePoint({ x: preEx, y: preEy }, { x: preC1x, preC1y });
          interpolateList.push({
            command: segment.command,
            values: [sx, sy, cx1, cy1, cx2, cy2, ex, ey],
            length: getCubicDist(sx, sy, cx1, cy1, cx2, cy2, ex, ey),
            interpolate: makeInterpolateCubic(sx, sy, cx1, cy1, cx2, cy2, ex, ey)
          });
          startPoint = [ex, ey];
          break;
        }
      case "s":
        var [sx, sy] = startPoint;
        var [cx2, cy2, ex, ey] = segment.values;
        cx2 += sx;
        ex += sx;
        cy2 += sy;
        ey += sy;
        var prevSegment = interpolateList[interpolateList.length - 1];
        if (["C", "c", "S", "s"].includes(prevSegment.command)) {
          var [, , , , preC1x, preC1y, preEx, preEy] = prevSegment.values;
          var { x: cx1, y: cy1 } = Point.getReversePoint({ x: preEx, y: preEy }, { x: preC1x, preC1y });
          interpolateList.push({
            command: segment.command,
            values: [sx, sy, cx1, cy1, cx2, cy2, ex, ey],
            length: getCubicDist(sx, sy, cx1, cy1, cx2, cy2, ex, ey),
            interpolate: makeInterpolateCubic(sx, sy, cx1, cy1, cx2, cy2, ex, ey)
          });
          startPoint = [ex, ey];
          break;
        }
      case "T":
        var [sx, sy] = startPoint;
        var [ex, ey] = segment.values;
        var prevSegment = interpolateList[interpolateList.length - 1];
        if (["Q", "q", "T", "t"].includes(prevSegment.command)) {
          var [, , preC1x, preC1y, preEx, preEy] = prevSegment.values;
          var { x: cx1, y: cy1 } = Point.getReversePoint({ x: preEx, y: preEy }, { x: preC1x, preC1y });
          interpolateList.push({
            command: segment.command,
            values: [sx, sy, cx1, cy1, ex, ey],
            length: getQuardDist(sx, sy, cx1, cy1, ex, ey),
            interpolate: makeInterpolateQuard(sx, sy, cx1, cy1, ex, ey)
          });
          startPoint = [ex, ey];
        }
        break;
      case "t":
        var [sx, sy] = startPoint;
        var [ex, ey] = segment.values;
        ex += sx;
        ey += sy;
        var prevSegment = interpolateList[interpolateList.length - 1];
        if (["Q", "q", "T", "t"].includes(prevSegment.command)) {
          var [, , preC1x, preC1y, preEx, preEy] = prevSegment.values;
          var { x: cx1, y: cy1 } = Point.getReversePoint({ x: preEx, y: preEy }, { x: preC1x, preC1y });
          interpolateList.push({
            command: segment.command,
            values: [sx, sy, cx1, cy1, ex, ey],
            length: getQuardDist(sx, sy, cx1, cy1, ex, ey),
            interpolate: makeInterpolateQuard(sx, sy, cx1, cy1, ex, ey)
          });
          startPoint = [ex, ey];
        }
        break;
    }
  });
  var totalLength = 0;
  interpolateList.forEach((it) => {
    totalLength += it.length;
  });
  var start2 = 0;
  interpolateList.forEach((it) => {
    it.startT = start2 / totalLength;
    it.endT = (start2 + it.length) / totalLength;
    it.totalLength = totalLength;
    start2 += it.length;
  });
  return { totalLength, interpolateList };
}
function makeInterpolateOffsetPath(layer, property, startValue, endValue, artboard2) {
  var [id, distance2, rotateStatus, rotate2] = startValue.split(",").map((it) => it.trim());
  var startObject = {
    id,
    distance: Length.parse(distance2 || "0%"),
    rotateStatus: rotateStatus || "auto",
    rotate: Length.parse(rotate2 || "0deg")
  };
  var innerInterpolate = () => {
    return {};
  };
  var innerInterpolateAngle = (rotateStatus2, currentAngle) => {
    var resultAngle = 0;
    switch (rotateStatus2) {
      case "angle":
        resultAngle = startObject.rotate.value;
        break;
      case "auto angle":
        resultAngle = currentAngle + startObject.rotate.value;
        break;
      case "reverse":
        resultAngle = currentAngle + 180;
        break;
      case "auto":
        resultAngle = currentAngle;
        break;
    }
    return resultAngle;
  };
  var screenX = 0, screenY = 0;
  if (artboard2) {
    var pathLayer = artboard2.searchById(startObject.id);
    if (pathLayer) {
      screenX = pathLayer.screenX.value;
      screenY = pathLayer.screenY.value;
    }
    innerInterpolate = (rate, t, timing) => {
      var parser = new PathParser(pathLayer.d || "");
      var { totalLength, interpolateList } = makeInterpolateOffset(parser.segments);
      var distance3 = startObject.distance.toPx(totalLength);
      var dt = distance3 / totalLength;
      t = t + dt;
      if (t > 1) {
        t -= 1;
      }
      var obj2 = interpolateList[0];
      if (t === 0) {
        obj2 = interpolateList[0];
      } else if (t === 1) {
        obj2 = interpolateList[interpolateList.length - 1];
      }
      var arr = interpolateList.find((it) => {
        return it.startT <= t && t < it.endT;
      });
      if (arr) {
        obj2 = arr;
      }
      var newT = (t - obj2.startT) / (obj2.endT - obj2.startT);
      var newRate = timing(newT);
      return __spreadProps(__spreadValues({}, obj2.interpolate(newRate, newT, timing)), {
        totalLength: obj2.totalLength
      });
    };
  }
  return (rate, t, timing) => {
    var arr = (layer.transformOrigin || "50% 50% 0px").split(" ").map((it) => Length.parse(it));
    var tx = arr[0].toPx(layer.width);
    var ty = arr[1].toPx(layer.height);
    var obj2 = innerInterpolate(rate, t, timing);
    var results = {
      x: obj2.x + screenX - tx.value,
      y: obj2.y + screenY - ty.value
    };
    layer.setScreenX(results.x);
    layer.setScreenY(results.y);
    if (startObject.rotateStatus === "element")
      ;
    else {
      var current = obj2;
      var distValue = 0;
      if (t < 1) {
        distValue = 1 / obj2.totalLength;
      }
      var next = innerInterpolate(rate + distValue, t + distValue, timing);
      var angle = calculateAngle(next.x - current.x, next.y - current.y);
      var newAngle = Length.deg(innerInterpolateAngle(startObject.rotateStatus, angle));
      layer.reset({
        transform: Transform.rotate(layer.transform, newAngle)
      });
    }
    return results;
  };
}
function makeInterpolatePerspectiveOrigin(layer, property, startValue, endValue) {
  var s = startValue.split(" ").map((it) => Length.parse(it));
  var e = endValue.split(" ").map((it) => Length.parse(it));
  var max = Math.max(s.length, e.length);
  var list2 = [];
  for (var i = 0; i < max; i++) {
    var startPos = s[i];
    var endPos = e[i];
    list2.push(makeInterpolateLength(layer, property, startPos, endPos, "perspective-origin"));
  }
  return (rate, t) => {
    var results = list2.map((it) => it(rate, t)).join(" ");
    return results;
  };
}
function makeInterpolatePlayTime(layer, property, startValue, endValue, artboard2, layerElement) {
  const mediaElement = layerElement.$("video").el;
  let [sTime, , durationTime] = startValue.split(":");
  const duration = +(durationTime || 1);
  const startTime = +(sTime || 0) * duration;
  return (rate, t) => {
    if (t === 0) {
      mediaElement.currentTime = startTime;
      if (mediaElement.paused) {
        mediaElement.play();
      }
    } else if (t === 1) {
      layer.reset({
        currentTime: mediaElement.currentTime
      });
      mediaElement.pause();
    } else {
      if (mediaElement.paused) {
        mediaElement.play();
      }
    }
  };
}
function makeInterpolateRotate(layer, property, startNumber, endNumber) {
  var startValue = Length.parse(startNumber);
  var endValue = Length.parse(endNumber);
  return (rate, t) => {
    var realStartValue = startValue.value;
    var realEndValue = endValue.value;
    if (t === 0) {
      return Length.deg(realStartValue);
    } else if (t === 1) {
      return Length.deg(realEndValue);
    }
    return Length.deg(realStartValue + (realEndValue - realStartValue) * rate).to(startValue.unit);
  };
}
function makeInterpolateStrokeDashArrray(layer, property, startValue, endValue) {
  var s = startValue.split(" ").map((it) => +it);
  var e = endValue.split(" ").map((it) => +it);
  var max = Math.max(s.length, e.length);
  var list2 = [];
  for (var i = 0; i < max; i++) {
    var startPos = s[i];
    var endPos = e[i];
    list2.push(makeInterpolateNumber(layer, property, startPos, endPos));
  }
  return (rate, t) => {
    var results = list2.map((it) => it(rate, t)).join(" ");
    return results;
  };
}
function makeInterpolateText(layer, property, startText, endText) {
  var max = endText.length - 1;
  var min = 0;
  return (rate, t) => {
    var result = 0;
    if (t === 0) {
      result = "";
    } else if (t === 1) {
      result = endText;
    } else {
      result = endText.substring(min, Math.floor((max - min) * t));
    }
    return result;
  };
}
function makeInterpolateTextShadow(layer, property, startValue, endValue) {
  var s = TextShadow.parseStyle(startValue);
  var e = TextShadow.parseStyle(endValue);
  var totalLength = Math.max(s.length, e.length);
  var list2 = [];
  for (var i = 0, len2 = totalLength; i < len2; i++) {
    var startObject = s[i] || TextShadow.parseStyle("0px 0px 0px rgba(0, 0, 0, 0)")[0];
    var endObject = e[i] || TextShadow.parseStyle("0px 0px 0px rgba(0, 0, 0, 0)")[0];
    list2.push({
      offsetX: makeInterpolateLength(layer, property, startObject.offsetX, endObject.offsetX, "width", "self"),
      offsetY: makeInterpolateLength(layer, property, startObject.offsetY, endObject.offsetY, "height", "self"),
      blurRadius: makeInterpolateLength(layer, property, startObject.blurRadius, endObject.blurRadius, "radius"),
      color: makeInterpolateColor(layer, property, startObject.color, endObject.color)
    });
  }
  return (rate, t) => {
    return TextShadow.join(list2.map((it) => {
      return {
        offsetX: it.offsetX(rate, t),
        offsetY: it.offsetY(rate, t),
        blurRadius: it.blurRadius(rate, t),
        color: it.color(rate, t)
      };
    }));
  };
}
function makeInterpolateTransformLength(layer, property, startValue, endValue) {
  var obj2 = {
    type: makeInterpolateBoolean(layer, property, startValue.type, endValue.type)
  };
  var value = [];
  var max = Math.max(startValue.value.length, endValue.value.length);
  for (var i = 0; i < max; i++) {
    var s = startValue.value[i];
    var e = endValue.value[i];
    if (s && e) {
      value.push(makeInterpolateLength(layer, property, s, e, startValue.type));
    } else {
      value.push(makeInterpolateLength(layer, property, startValue.value[i] || startValue.value[i - 1] || startValue.value[i - 2], endValue.value[i] || endValue.value[i - 1] || endValue.value[i - 2], startValue.type));
    }
  }
  obj2.value = value;
  return (rate, t) => {
    return {
      type: obj2.type(rate, t),
      value: obj2.value.map((it) => it(rate, t))
    };
  };
}
function makeInterpolateTransformNumber(layer, property, startValue, endValue) {
  var obj2 = {
    type: makeInterpolateBoolean(layer, property, startValue.type, endValue.type)
  };
  var value = [];
  var max = Math.max(startValue.value.length, endValue.value.length);
  for (var i = 0; i < max; i++) {
    var s = startValue.value[i];
    var e = endValue.value[i];
    if (s && e) {
      value.push(makeInterpolateNumber(layer, property, s.value, e.value));
    } else {
      var ss = startValue.value[i].value || startValue.value[i - 1].value || startValue.value[i - 2].value;
      var ee = endValue.value[i].value || endValue.value[i - 1].value || startValue.value[i - 2].value;
      value.push(makeInterpolateNumber(layer, property, ss, ee));
    }
  }
  obj2.value = value;
  return (rate, t) => {
    var value2 = obj2.value.map((it) => it(rate, t));
    var type = obj2.type(rate, t);
    if (type.includes("matrix") || type.includes("scale")) {
      value2 = value2.map((it) => {
        return Length.number(it);
      });
    }
    return { type, value: value2 };
  };
}
function makeInterpolateTransformRotate(layer, property, startValue, endValue) {
  var obj2 = {
    type: makeInterpolateBoolean(layer, property, startValue.type, endValue.type)
  };
  var value = [];
  var max = Math.max(startValue.value.length, endValue.value.length);
  for (var i = 0; i < max; i++) {
    var tempStartValue = startValue.value[i];
    var tempEndValue = endValue.value[i];
    if (tempStartValue && tempEndValue) {
      value.push(makeInterpolateRotate(layer, property, tempStartValue, tempEndValue));
    } else {
      value.push(makeInterpolateRotate(layer, property, startValue.value[i] || startValue.value[i - 1] || startValue.value[i - 2], endValue.value[i] || endValue.value[i - 1] || startValue.value[i - 2]));
    }
  }
  obj2.value = value;
  return (rate, t) => {
    var results = {
      type: obj2.type(rate, t),
      value: obj2.value.map((it) => it(rate, t))
    };
    return results;
  };
}
function makeInterpolateTransform(layer, property, startValue, endValue) {
  var startObject = Transform.parseStyle(startValue.trim());
  var endObject = Transform.parseStyle(endValue.trim());
  var max = Math.max(startObject.length, endObject.length);
  var list2 = [];
  for (var i = 0; i < max; i++) {
    var s = startObject[i];
    var e = endObject[i];
    if (s && !e) {
      list2.push(makeInterpolateIdentity(layer, property, s));
    } else if (!s && e) {
      list2.push(makeInterpolateIdentity(layer, property, e));
    } else if (s.type != e.type) {
      list2.push(makeInterpolateBoolean(layer, property, s, e));
    } else {
      switch (s.type) {
        case "translate":
        case "translateX":
        case "translateY":
        case "translateZ":
        case "translate3d":
        case "perspective":
          list2.push(makeInterpolateTransformLength(layer, property, s, e));
          break;
        case "rotate":
        case "rotateX":
        case "rotateY":
        case "rotateZ":
        case "rotate3d":
          list2.push(makeInterpolateTransformRotate(layer, property, s, e));
          break;
        case "scale":
        case "scaleX":
        case "scaleY":
        case "scaleZ":
        case "scale3d":
        case "matrix":
        case "matrix3d":
          list2.push(makeInterpolateTransformNumber(layer, property, s, e));
          break;
      }
    }
  }
  return (rate, t) => {
    var results = Transform.join(list2.map((it) => {
      return it(rate, t);
    }));
    return results;
  };
}
function makeInterpolateTransformOrigin(layer, property, startValue, endValue) {
  var s = startValue.split(" ").map((it) => Length.parse(it));
  var e = endValue.split(" ").map((it) => Length.parse(it));
  var max = Math.max(s.length, e.length);
  var list2 = [];
  for (var i = 0; i < max; i++) {
    var startPos = s[i];
    var endPos = e[i];
    list2.push(makeInterpolateLength(layer, property, startPos, endPos, "transform-origin"));
  }
  return (rate, t) => {
    var results = list2.map((it) => it(rate, t)).join(" ");
    return results;
  };
}
function makeInterpolatePathValues(layer, property, s, e) {
  var max = Math.max(s.length, e.length);
  var list2 = [];
  var startLastPos = s[s.length - 1];
  var endLastPos = e[e.length - 1];
  for (var i = 0; i < max; i++) {
    var startPos = s[i];
    var endPos = e[i];
    if (startPos && !endPos) {
      list2.push(makeInterpolateNumber(layer, property, startPos, endLastPos));
    } else if (!startPos && endPos) {
      list2.push(makeInterpolateNumber(layer, property, startLastPos, endPos));
    } else {
      list2.push(makeInterpolateNumber(layer, property, startPos, endPos));
    }
  }
  return (rate, t) => {
    return list2.map((it) => it(rate, t));
  };
}
function makeInterpolatePath(layer, property, startValue, endValue) {
  var returnParser = new PathParser();
  var s = new PathParser(startValue);
  var e = new PathParser(endValue);
  var max = Math.max(s.segments.length, e.segments.length);
  var list2 = [];
  for (var i = 0; i < max; i++) {
    var sc = s.segments[i];
    var ec = e.segments[i];
    if (sc.command === ec.command) {
      if (sc.values.length === ec.values.length) {
        list2.push({
          command: makeInterpolateIdentity(layer, property, sc.command),
          values: makeInterpolatePathValues(layer, property, sc.values, ec.values)
        });
      } else {
        list2.push({
          command: makeInterpolateIdentity(layer, property, sc.command),
          values: makeInterpolateIdentity(layer, property, sc.values)
        });
      }
    } else {
      list2.push({
        command: makeInterpolateBoolean(layer, property, sc.command, ec.command),
        values: makeInterpolateBoolean(layer, property, sc.values, ec.values)
      });
    }
  }
  return (rate, t) => {
    var segments = list2.map((it) => {
      return {
        command: it.command(rate, t),
        values: it.values(rate, t)
      };
    });
    var results = returnParser.joinPath(segments);
    return results;
  };
}
function makeInterpolatePolygon(layer, property, startValue, endValue) {
  var returnParser = new PolygonParser();
  var s = new PolygonParser(startValue);
  var e = new PolygonParser(endValue);
  var max = Math.max(s.segments.length, e.segments.length);
  var list2 = [];
  var startLastX = s.segments[s.segments.length - 1].x;
  var startLastY = s.segments[s.segments.length - 1].y;
  var endLastX = e.segments[e.segments.length - 1].x;
  var endLastY = e.segments[e.segments.length - 1].y;
  for (var i = 0; i < max; i++) {
    var startPos = s.segments[i];
    var endPos = e.segments[i];
    if (startPos && !endPos) {
      list2.push({
        x: makeInterpolateNumber(layer, property, startPos.x, endLastX),
        y: makeInterpolateNumber(layer, property, startPos.y, endLastY)
      });
    } else if (!startPos && endPos) {
      list2.push({
        x: makeInterpolateNumber(layer, property, startLastX, endPos.x),
        y: makeInterpolateNumber(layer, property, startLastY, endPos.y)
      });
    } else {
      list2.push({
        x: makeInterpolateNumber(layer, property, startPos.x, endPos.x),
        y: makeInterpolateNumber(layer, property, startPos.y, endPos.y)
      });
    }
  }
  return (rate, t) => {
    var points = returnParser.joinPoints(list2.map((it) => {
      return {
        x: it.x(rate, t),
        y: it.y(rate, t)
      };
    }));
    return points;
  };
}
const DEFAULT_FUCTION = () => () => {
};
function makeInterpolateCustom(property) {
  switch (property) {
    case "border-radius":
      return makeInterpolateBorderRadius;
    case "box-shadow":
      return makeInterpolateBoxShadow;
    case "text-shadow":
      return makeInterpolateTextShadow;
    case "background-image":
    case "BackgroundImageEditor":
      return makeInterpolateBackgroundImage;
    case "filter":
    case "backdrop-filter":
      return makeInterpolateFilter;
    case "clip-path":
      return makeInterpolateClipPath;
    case "transform":
      return makeInterpolateTransform;
    case "transform-origin":
      return makeInterpolateTransformOrigin;
    case "perspective-origin":
      return makeInterpolatePerspectiveOrigin;
    case "stroke-dasharray":
      return makeInterpolateStrokeDashArrray;
    case "d":
      return makeInterpolatePath;
    case "points":
      return makeInterpolatePolygon;
    case "offset-path":
      return makeInterpolateOffsetPath;
    case "text":
      return makeInterpolateText;
    case "playTime":
      return makeInterpolatePlayTime;
  }
}
function makeInterpolate(layer, property, startValue, endValue, editorString, artboard2, layerElement) {
  var checkField = editorString || property;
  switch (checkField) {
    case "width":
    case "x":
      return makeInterpolateLength(layer, property, startValue, endValue, "width");
    case "height":
    case "y":
      return makeInterpolateLength(layer, property, startValue, endValue, "height");
    case "perspective":
    case "font-size":
    case "font-weight":
    case "text-stroke-width":
    case "RangeEditor":
    case "textLength":
    case "startOffset":
      return makeInterpolateLength(layer, property, startValue, endValue, property);
    case "fill-opacity":
    case "opacity":
    case "stroke-dashoffset":
    case "currentTime":
    case "NumberRangeEditor":
      return makeInterpolateNumber(layer, property, +startValue, +endValue);
    case "background-color":
    case "color":
    case "text-fill-color":
    case "text-stroke-color":
    case "fill":
    case "stroke":
    case "ColorViewEditor":
      return makeInterpolateColor(layer, property, startValue, endValue);
    case "mix-blend-mode":
    case "fill-rule":
    case "stroke-linecap":
    case "stroke-linejoin":
    case "SelectEditor":
    case "lengthAdjust":
      return makeInterpolateString(layer, property, startValue, endValue);
    case "rotate":
      return makeInterpolateRotate(layer, property, startValue, endValue);
  }
  var func = makeInterpolateCustom(checkField);
  if (func) {
    return func(layer, property, startValue, endValue, artboard2, layerElement);
  }
  return DEFAULT_FUCTION;
}
function createInterpolateFunction(layer, property, startValue, endValue, editorString, artboard2, layerElement) {
  return makeInterpolate(layer, property, startValue, endValue, editorString, artboard2, layerElement);
}
class AssetModel extends BaseModel {
  getDefaultObject(obj2 = {}) {
    return super.getDefaultObject(__spreadValues({
      comments: [],
      colors: [],
      gradients: [],
      svgfilters: [],
      svgimages: [],
      keyframes: [],
      images: [],
      imageKeys: [],
      videos: [],
      videoKeys: [],
      audios: []
    }, obj2));
  }
  get comments() {
    return this.get("comments");
  }
  get colors() {
    return this.get("colors");
  }
  get gradients() {
    return this.get("gradients");
  }
  get svgfilters() {
    return this.get("svgfilters");
  }
  get svgimages() {
    return this.get("svgimages");
  }
  get keyframes() {
    return this.get("keyframes");
  }
  get videos() {
    return this.get("videos");
  }
  get images() {
    return this.get("images");
  }
  set images(value) {
    this.set("images", value);
  }
  get imageKeys() {
    return this.get("imageKeys");
  }
  get videoKeys() {
    return this.get("videoKeys");
  }
  addKeyframe(keyframe2) {
    this.keyframes.push(keyframe2);
    return keyframe2;
  }
  createKeyframe(data = {}) {
    return this.addKeyframe(new Keyframe(__spreadValues({
      checked: true
    }, data)));
  }
  removeKeyframe(removeIndex) {
    this.removePropertyList(this.keyframes, removeIndex);
  }
  sortItem(arr, startIndex, targetIndex) {
    arr.splice(targetIndex + (startIndex < targetIndex ? -1 : 0), 0, ...arr.splice(startIndex, 1));
  }
  sortKeyframe(startIndex, targetIndex) {
    this.sortItem(this.keyframes, startIndex, targetIndex);
  }
  updateKeyframe(index2, data = {}) {
    this.keyframes[+index2].reset(data);
  }
  toKeyframeString(isAnimate = false) {
    return this.keyframes.map((keyframe2) => keyframe2.toString(isAnimate)).join("\n\n");
  }
  copyPropertyList(arr, index2) {
    var copyObject = __spreadValues({}, arr[index2]);
    arr.splice(index2, 0, copyObject);
  }
  removePropertyList(arr, removeIndex) {
    arr.splice(removeIndex, 1);
  }
  removeColor(removeIndex) {
    this.removePropertyList(this.colors, removeIndex);
  }
  copyColor(index2) {
    this.copyPropertyList(this.colors, index2);
  }
  sortColor(startIndex, targetIndex) {
    this.sortItem(this.colors, startIndex, targetIndex);
  }
  setColorValue(index2, value = {}) {
    this.colors[index2] = __spreadValues(__spreadValues({}, this.colors[index2]), value);
  }
  getColorIndex(index2) {
    return this.colors[index2];
  }
  getColor(name) {
    return this.colors.filter((item) => item.name === name)[0];
  }
  addColor(obj2) {
    this.colors.push(obj2);
    return obj2;
  }
  createColor(data = {}) {
    return this.addColor(data);
  }
  removeImage(removeIndex) {
    this.removePropertyList(this.images, removeIndex);
    this.refreshImageKeys();
  }
  copyImage(index2) {
    this.copyPropertyList(this.images, index2);
    this.refreshImageKeys();
  }
  sortImage(startIndex, targetIndex) {
    this.sortItem(this.images, startIndex, targetIndex);
  }
  setImageValue(index2, value = {}) {
    this.images[index2] = __spreadValues(__spreadValues({}, this.images[index2]), value);
    this.refreshImageKeys();
  }
  getImageValueById(id, defaultValue2 = "") {
    const image2 = this.imageKeys[id];
    if (!image2)
      return id || defaultValue2;
    return image2.local;
  }
  getImageDataURIById(id) {
    const image2 = this.imageKeys[id];
    if (!image2)
      return void 0;
    return image2.original;
  }
  refreshImageKeys() {
    let imageKeys = {};
    this.images.forEach((it) => {
      imageKeys[it.id] = it;
    });
    this.reset({
      imageKeys
    });
  }
  addImage(obj2) {
    this.images.push(obj2);
    this.refreshImageKeys();
    return obj2;
  }
  createImage(data = {}) {
    return this.addImage(data);
  }
  removeVideo(removeIndex) {
    this.removePropertyList(this.videos, removeIndex);
    this.refreshVideoKeys();
  }
  copyVideo(index2) {
    this.copyPropertyList(this.videos, index2);
    this.refreshVideoKeys();
  }
  sortVideo(startIndex, targetIndex) {
    this.sortItem(this.videos, startIndex, targetIndex);
  }
  setVideoValue(index2, value = {}) {
    this.videos[index2] = __spreadValues(__spreadValues({}, this.videos[index2]), value);
  }
  getVideoValueById(id) {
    const video2 = this.videoKeys[id];
    if (!video2)
      return void 0;
    return video2.local;
  }
  refreshVideoKeys() {
    let videoKeys = {};
    this.videos.forEach((it) => {
      videoKeys[it.id] = it;
    });
    this.reset({
      videoKeys
    });
  }
  addVideo(obj2) {
    this.videos.push(obj2);
    this.refreshVideoKeys();
    return obj2;
  }
  createVideo(data = {}) {
    return this.addVideo(data);
  }
  removeGradient(removeIndex) {
    this.removePropertyList(this.gradients, removeIndex);
  }
  copyGradient(index2) {
    this.copyPropertyList(this.gradients, index2);
  }
  sortGradient(startIndex, targetIndex) {
    this.sortItem(this.gradients, startIndex, targetIndex);
  }
  setGradientValue(index2, value) {
    this.gradients[index2] = __spreadValues(__spreadValues({}, this.gradients[index2]), value);
  }
  getGradientIndex(index2) {
    return this.gradients[index2];
  }
  getGradient(name) {
    return this.gradients.filter((item) => item.name === name)[0];
  }
  addGradient(obj2 = {}) {
    this.gradients.push(obj2);
    return obj2;
  }
  createGradient(data = {}) {
    return this.addGradient(data);
  }
  getSVGFilterIndex(id) {
    var _a;
    var filter2 = this.svgfilters.map((it, index2) => {
      return { id: it.id, index: index2 };
    }).filter((it) => {
      return it.id === id;
    });
    return filter2.length ? (_a = filter2 == null ? void 0 : filter2[0]) == null ? void 0 : _a.index : -1;
  }
  removeSVGFilter(removeIndex) {
    this.removePropertyList(this.svgfilters, removeIndex);
  }
  copySVGFilter(index2) {
    this.copyPropertyList(this.svgfilters, index2);
  }
  sortSVGFilter(startIndex, targetIndex) {
    this.sortItem(this.svgfilters, startIndex, targetIndex);
  }
  setSVGFilterValue(index2, value) {
    this.svgfilters[index2] = __spreadValues(__spreadValues({}, this.svgfilters[index2]), value);
  }
  addSVGFilter(obj2 = {}) {
    this.svgfilters.push(obj2);
    var index2 = this.svgfilters.length - 1;
    return index2;
  }
  createSVGFilter(data = {}) {
    return this.addSVGFilter(data);
  }
  getSVGImageIndex(id) {
    var filter2 = this.svgimages.map((it, index2) => {
      return { id: it.id, index: index2 };
    }).filter((it) => {
      return it.id === id;
    })[0];
    return filter2 ? filter2.index : -1;
  }
  removeSVGImage(removeIndex) {
    this.removePropertyList(this.svgimages, removeIndex);
  }
  copySVGImage(index2) {
    this.copyPropertyList(this.svgimages, index2);
  }
  sortSVGImage(startIndex, targetIndex) {
    this.sortItem(this.svgimages, startIndex, targetIndex);
  }
  setSVGImageValue(index2, value) {
    this.svgimages[index2] = __spreadValues(__spreadValues({}, this.svgimages[index2]), value);
  }
  addSVGImage(obj2 = {}) {
    this.svgimages.push(obj2);
    var index2 = this.svgimages.length - 1;
    return index2;
  }
  createSVGImage(data = {}) {
    return this.addSVGImage(data);
  }
}
class TimelineModel extends AssetModel {
  constructor() {
    super(...arguments);
    __privateAdd(this, _compiledTimeline, []);
  }
  getDefaultObject(obj2 = {}) {
    return super.getDefaultObject(__spreadValues({
      timeline: [],
      compiledTimeline: {}
    }, obj2));
  }
  get timeline() {
    return this.get("timeline");
  }
  set timeline(value) {
    this.set("timeline", value);
  }
  expectJSON(key) {
    if (key === "compiledTimeline")
      return false;
    return super.expectJSON(key);
  }
  setTimelineInfo(obj2) {
    var timeline = this.getSelectedTimeline();
    if (!timeline)
      return;
    ["speed", "iterationCount", "direction"].forEach((key) => {
      if (isNotUndefined(obj2[key])) {
        timeline[key] = obj2[key];
      }
    });
  }
  compileAll() {
    var timeline = this.getSelectedTimeline();
    __privateSet(this, _compiledTimeline, {});
    if (timeline) {
      timeline.animations.forEach((animation2) => {
        animation2.properties.forEach((property) => {
          this.compiledTimingFunction(animation2.id, property.property);
        });
      });
    }
  }
  searchTimelineOffset(time) {
    var timeline = this.getSelectedTimeline();
    var filteredTimeline = [];
    if (timeline) {
      timeline.animations.forEach((animation2) => {
        animation2.properties.forEach((p) => {
          var list2 = this.getCompiledTimingFunction(animation2.id, p.property);
          filteredTimeline.push(list2.find((keyframe2) => {
            if (keyframe2.isOnlyTime && keyframe2.startTime <= time)
              return true;
            return keyframe2.startTime <= time && time < keyframe2.endTime;
          }));
        });
      });
    }
    return filteredTimeline.filter((it) => it);
  }
  getCompiledTimingFunction(layerId, property) {
    return __privateGet(this, _compiledTimeline)[`${layerId}.${property}`];
  }
  compiledTimingFunction(layerId, property) {
    var artboard2 = this;
    var p = this.getTimelineProperty(layerId, property);
    var layer = this.modelManager.get(layerId);
    var key = `${layerId}.${property}`;
    if (p.keyframes.length === 1) {
      __privateGet(this, _compiledTimeline)[key] = [];
      return;
    }
    let layerElement = Dom.body().$(`[data-id="${layerId}"]`);
    let editorString = p.keyframes.map((it) => it.editor)[0];
    __privateGet(this, _compiledTimeline)[key] = p.keyframes.map((offset, index2) => {
      var currentOffset = offset;
      var nextOffset = p.keyframes[index2 + 1];
      offset.editor = editorString;
      if (!nextOffset) {
        nextOffset = { time: offset.time, value: offset.value };
      }
      var it = {
        layer,
        layerElement,
        property: p.property,
        isOnlyTime: currentOffset.time === nextOffset.time,
        startTime: offset.time,
        endTime: nextOffset.time,
        startValue: offset.value,
        endValue: nextOffset.value,
        timing: offset.timing,
        interpolateFunction: createInterpolateFunction(layer, p.property, offset.value, nextOffset.value, offset.editor, artboard2, layerElement),
        timingFunction: createTimingFunction(offset.timing)
      };
      it.func = this.makeTimingFunction(it);
      return it;
    }).filter((it) => it);
  }
  makeTimingFunction(it) {
    return (time) => {
      var totalT = it.endTime - it.startTime;
      var t = 1;
      if (totalT !== 0) {
        t = (time - it.startTime) / totalT;
      }
      return it.interpolateFunction(it.timingFunction(t), t, totalT, it.timingFunction);
    };
  }
  stop() {
    var timeline = this.getSelectedTimeline();
    if (timeline) {
      var time = timeline.currentTime;
      this.searchTimelineOffset(time).forEach((it) => {
        if (it.property === "playTime") {
          const $video = it.layerElement.$("video");
          if ($video) {
            $video.el.pause();
          }
        }
      });
    }
  }
  seek(frameOrCode, filterFunction = (it) => it) {
    var timeline = this.getSelectedTimeline();
    if (timeline) {
      if (isNotUndefined(frameOrCode)) {
        this.setTimelineCurrentTime(frameOrCode);
      }
      var time = timeline.currentTime;
      this.searchTimelineOffset(time).filter(filterFunction).forEach((it) => {
        if (it.property === "offset-path" || it.property === "playTime") {
          it.func(time);
        } else if (it.layer) {
          it.layer.reset({
            [it.property]: it.func(time)
          });
        }
      });
    }
  }
  getSelectedTimeline() {
    var timeline = this.timeline;
    var a = timeline.filter((it) => it.selected);
    var selectedTimeline = a.length ? a[0] : timeline[0];
    return selectedTimeline || null;
  }
  getKeyframeListReturnArray() {
    var timeline = this.getSelectedTimeline();
    var keyframes = [];
    if (timeline) {
      timeline.animations.forEach((a) => {
        a.properties.forEach((p) => {
          keyframes.push.apply(keyframes, p.keyframes);
        });
      });
    }
    return keyframes;
  }
  getKeyframeList(callback) {
    var timeline = this.getSelectedTimeline();
    if (timeline) {
      timeline.animations.forEach((a) => {
        a.properties.forEach((p) => {
          p.keyframes.forEach((k) => {
            callback && callback(timeline, k);
          });
        });
      });
    }
  }
  getSelectedTimelineLastTime() {
    var time = 0;
    this.getKeyframeList((timeline, keyframe2) => {
      time = Math.max(keyframe2.time, time);
    });
    return time;
  }
  getSelectedTimelineFirstTime() {
    var time = Number.MAX_SAFE_INTEGER;
    this.getKeyframeList((timeline, keyframe2) => {
      time = Math.min(keyframe2.time, time);
    });
    return time;
  }
  getSelectedTimelinePrevTime() {
    var time = this.getSelectedTimelineFirstTime();
    this.getKeyframeList((timeline, keyframe2) => {
      if (timecode(timeline.fps, keyframe2.time) < timeline.currentTimecode) {
        time = Math.max(keyframe2.time, time);
      }
    });
    return time;
  }
  getSelectedTimelineNextTime() {
    var time = this.getSelectedTimelineLastTime();
    this.getKeyframeList((timeline, keyframe2) => {
      if (timecode(timeline.fps, keyframe2.time) > timeline.currentTimecode) {
        time = Math.min(keyframe2.time, time);
      }
    });
    return time;
  }
  setTimelineTitle(id, text2) {
    var timeline = this.timeline.find((it) => {
      return it.id === id;
    });
    if (timeline) {
      timeline.title = text2;
    }
  }
  selectTimeline(id) {
    if (id) {
      this.timeline.forEach((it) => {
        it.selected = it.id === id;
      });
    } else {
      var selectedTimeline = this.timeline.filter((it) => it.selected);
      if (selectedTimeline.length)
        ;
      else {
        if (this.timeline.length) {
          this.timeline.selected = true;
        }
      }
    }
    this.compileAll();
  }
  removeAnimation(id) {
    this.timeline = this.timeline.filter((it) => {
      return it.id !== id;
    });
    if (this.timeline.length) {
      this.timeline[0].selected = true;
    }
    this.compileAll();
  }
  addTimeline(fps = 60, endTimecode = "00:00:10:00") {
    var id = uuidShort();
    var selectedTimeline = __spreadProps(__spreadValues({
      id,
      title: "sample"
    }, this.getTimelineLayerInfo(fps, endTimecode)), {
      animations: []
    });
    this.timeline.push(selectedTimeline);
    this.selectTimeline(id);
    return selectedTimeline;
  }
  addTimelineLayer(layerId, fps = 60, endTimecode = "00:00:10:00") {
    var selectedTimeline = this.getSelectedTimeline();
    if (!selectedTimeline) {
      selectedTimeline = this.addTimeline(fps, endTimecode);
    }
    selectedTimeline.selected = true;
    if (layerId) {
      var layer = selectedTimeline.animations.filter((it) => it.id === layerId);
      if (!layer[0]) {
        selectedTimeline.animations.push({
          id: layerId,
          properties: []
        });
      }
    }
  }
  getTimelineLayerInfo(fps = 60, endTimecode = "00:00:10:00") {
    var endTime = second(fps, endTimecode);
    return {
      fps,
      speed: 1,
      direction: "normal",
      iterationCount: 1,
      currentTimecode: timecode(fps, 0),
      totalTimecode: timecode(fps, endTime),
      currentTime: 0,
      totalTime: endTime,
      displayStartTime: 0,
      displayEndTime: endTime
    };
  }
  setTimelineCurrentTime(frameOrCode) {
    var timeline = this.getSelectedTimeline();
    var { fps, totalTimecode } = timeline;
    if (timeline) {
      var frame = frameOrCode;
      var code2 = frameOrCode;
      if (+frame + "" === frame) {
        frame = +frame;
        code2 = framesToTimecode(fps, frame);
      }
      if (code2 > totalTimecode) {
        code2 = totalTimecode;
      }
      var currentTime = second(fps, code2);
      timeline.currentTime = currentTime;
      timeline.currentTimecode = timecode(fps, currentTime);
    }
  }
  setDisplayTimeDxRate(dxRate, initStartTime, initEndTime) {
    var timeline = this.getSelectedTimeline();
    if (timeline) {
      var dxTime = dxRate * timeline.totalTime;
      var startTime = initStartTime + dxTime;
      var endTime = initEndTime + dxTime;
      startTime = Math.max(startTime, 0);
      startTime = Math.min(startTime, endTime);
      if (startTime === 0) {
        endTime = initEndTime - initStartTime;
      }
      endTime = Math.max(endTime, startTime);
      endTime = Math.min(endTime, timeline.totalTime);
      if (endTime === timeline.totalTime) {
        startTime = timeline.totalTime - (initEndTime - initStartTime);
      }
      timeline.displayStartTime = startTime;
      timeline.displayEndTime = endTime;
    }
  }
  setDisplayStartTimeRate(rate) {
    var timeline = this.getSelectedTimeline();
    if (timeline) {
      timeline.displayStartTime = rate * timeline.totalTime;
    }
  }
  setDisplayEndTimeRate(rate) {
    var timeline = this.getSelectedTimeline();
    if (timeline) {
      timeline.displayEndTime = rate * timeline.totalTime;
    }
  }
  setTimelineCurrentTimeRate(rate) {
    var timeline = this.getSelectedTimeline();
    if (timeline) {
      var { displayStartTime, displayEndTime, fps } = timeline;
      var currentTime = displayStartTime + (displayEndTime - displayStartTime) * rate;
      this.setTimelineCurrentTime(timecode(fps, currentTime));
    }
  }
  setTimelineTotalTime(frameOrCode) {
    var timeline = this.getSelectedTimeline();
    if (timeline) {
      var frame = frameOrCode;
      var code2 = frameOrCode;
      if (+frame + "" === frame) {
        frame = +frame;
        code2 = framesToTimecode(timeline.fps, frame);
      }
      if (second(timeline.fps, code2) < timeline.displayEndTime) {
        timeline.displayEndTime = second(timeline.fps, code2);
        timeline.displayStartTime = 0;
      }
      timeline.totalTimecode = code2;
      timeline.totalTime = second(timeline.fps, code2);
    }
  }
  getTimelineObject(layerId) {
    var selectedTimeline = this.getSelectedTimeline();
    if (selectedTimeline) {
      return selectedTimeline.animations.find((it) => it.id === layerId);
    }
  }
  addTimelineProperty(layerId, property) {
    this.addTimelineLayer(layerId);
    var animation2 = this.getTimelineObject(layerId);
    if (animation2) {
      var p = animation2.properties.filter((it) => it.property === property);
      if (!p.length) {
        animation2.properties.push({
          property,
          keyframes: []
        });
        this.compiledTimingFunction(layerId, property);
      }
    }
  }
  getTimelineProperty(layerId, property) {
    var timeline = this.getSelectedTimeline();
    if (timeline) {
      layerId = layerId || timeline.selectedLayerId;
      property = property || timeline.selectedProperty;
      var timelineObject = this.getTimelineObject(layerId);
      if (timelineObject) {
        return timelineObject.properties.find((it) => it.property === property);
      }
    }
  }
  setSelectedOffset(layerId, property, time) {
    var timeline = this.getSelectedTimeline();
    if (timeline) {
      timeline.selectedLayerId = layerId;
      timeline.selectedProperty = property;
      timeline.selectedOffsetTime = time;
      var p = this.getTimelineProperty();
      p.keyframes.forEach((it) => {
        it.selected = it.time === time;
      });
    }
  }
  deleteTimelineKeyframe(layerId, property, offsetId) {
    var p = this.getTimelineProperty(layerId, property);
    if (p) {
      p.keyframes = p.keyframes.filter((it) => it.id != offsetId);
    }
  }
  removeTimelineProperty(layerId, property) {
    var layer = this.getTimelineObject(layerId);
    if (layer) {
      layer.properties = layer.properties.filter((p) => p.property != property);
    }
  }
  removeTimeline(layerId) {
    var timeline = this.getSelectedTimeline();
    if (timeline) {
      timeline.animations = timeline.animations.filter((ani) => ani.id != layerId);
    }
  }
  setTimelineKeyframeOffsetTime(layerId, property, offsetId, changedTime) {
    var keyframe2 = this.getTimelineKeyframeById(layerId, property, offsetId);
    if (keyframe2) {
      keyframe2.time = changedTime;
      this.compiledTimingFunction(layerId, property);
    }
  }
  setTimelineKeyframeOffsetValue(layerId, property, offsetId, value = void 0, timing = void 0, time = void 0) {
    var keyframe2 = this.getTimelineKeyframeById(layerId, property, offsetId);
    if (keyframe2) {
      if (isNotUndefined(time)) {
        keyframe2.time = time;
      }
      if (isNotUndefined(value)) {
        keyframe2.value = value;
      }
      if (isNotUndefined(timing)) {
        keyframe2.timing = timing;
      }
      this.compiledTimingFunction(layerId, property);
    }
  }
  addTimelineKeyframe({
    layerId,
    property,
    value,
    timing,
    time: newTime,
    editor
  }) {
    this.addTimelineProperty(layerId, property);
    var timeline = this.getSelectedTimeline();
    var p = this.getTimelineProperty(layerId, property);
    if (p) {
      var time = newTime || timeline.currentTime;
      var times = p.keyframes.filter((it) => it.time === time);
      if (!times.length) {
        value = isUndefined(value) || value === "" ? this.getDefaultPropertyValue(property) : value;
        var obj2 = {
          id: uuidShort(),
          layerId,
          property,
          time,
          value,
          timing: timing || "linear",
          editor
        };
        p.keyframes.push(obj2);
        p.keyframes.sort((a, b) => {
          return a.time > b.time ? 1 : -1;
        });
        this.compiledTimingFunction(layerId, property);
        return obj2;
      }
    }
  }
  getDefaultPropertyValue(property) {
    switch (property) {
      case "mix-blend-mode":
        return "normal";
      case "rotate":
        return "0deg";
      case "box-shadow":
        return "0px 0px 0px 0px rgba(0, 0, 0, 1)";
      case "text-shadow":
        return "0px 0px 0px rgba(0, 0, 0, 1)";
      case "opacity":
        return 1;
      default:
        return "";
    }
  }
  copyTimelineKeyframe(layerId, property, newTime = null) {
    var p = this.getTimelineProperty(layerId, property);
    if (p) {
      var timeline = this.getSelectedTimeline();
      var time = newTime || timeline.currentTime;
      var times = p.keyframes.filter((it) => it.time < time);
      var value = this.getDefaultPropertyValue(property);
      var timing = "linear";
      var editor = "";
      if (times.length) {
        times.sort((a, b) => {
          return a.time > b.time ? -1 : 1;
        });
        value = times[0].value + "";
        timing = times[0].timing + "";
        editor = times[0].editor;
      }
      this.addTimelineKeyframe({ layerId, property, value, timing, editor });
    }
  }
  getTimelineKeyframe(layerId, property, time) {
    var p = this.getTimelineProperty(layerId, property);
    if (p) {
      return p.keyframes.find((it) => it.time === time);
    }
  }
  getTimelineKeyframeById(layerId, property, id) {
    var p = this.getTimelineProperty(layerId, property);
    if (p) {
      return p.keyframes.find((it) => it.id === id);
    }
  }
  sortTimelineKeyframe(layerId, property) {
    var p = this.getTimelineProperty(layerId, property);
    if (p) {
      p.keyframes.sort((a, b) => {
        return a.time > b.time ? 1 : -1;
      });
      this.compiledTimingFunction(layerId, property);
    }
  }
  setFps(fps) {
    var timeline = this.getSelectedTimeline();
    if (timeline) {
      timeline.fps = fps;
      timeline.currentTimecode = timecode(fps, timeline.currentTime);
      timeline.totalTimecode = timecode(fps, timeline.totalTime);
    }
  }
}
_compiledTimeline = new WeakMap();
const identity = create$4();
class Project extends TimelineModel {
  getDefaultTitle() {
    return "New Project";
  }
  get isAbsolute() {
    return false;
  }
  get parent() {
    return null;
  }
  get nestedAngle() {
    return 0;
  }
  toRootVariableCSS() {
    var obj2 = {};
    this.rootVariable.split(";").filter((it) => it.trim()).forEach((it) => {
      var [key, value] = it.split(":");
      obj2[`--${key}`] = value;
    });
    return obj2;
  }
  getDefaultObject(obj2 = {}) {
    return super.getDefaultObject(__spreadValues({
      itemType: "project",
      name: "new Project",
      description: "",
      rootVariable: ""
    }, obj2));
  }
  get description() {
    return this.get("description");
  }
  set description(value) {
    this.set("description", value);
  }
  get rootVariable() {
    return this.get("rootVariable");
  }
  set rootVariable(value) {
    this.set("rootVariable", value);
  }
  get artboards() {
    return (this.layers || []).filter((it) => it.is("artboard"));
  }
  get offsetX() {
    return 0;
  }
  get offsetY() {
    return 0;
  }
  get screenWidth() {
    return 0;
  }
  get screenHeight() {
    return 0;
  }
  isLayoutItem() {
    return false;
  }
  hasLayout() {
    return false;
  }
  getAbsoluteMatrix() {
    return create$4();
  }
  getTransformMatrix() {
    return create$4();
  }
  resetMatrix(childItem) {
    const [x, y] = getTranslation([], calculateMatrix(childItem.absoluteMatrix, childItem.localMatrixInverse));
    childItem.reset({
      x,
      y
    });
  }
  get rectVerties() {
    var _a;
    return ((_a = this.layers) == null ? void 0 : _a.length) ? itemsToRectVerties(this.layers) : null;
  }
  get absoluteMatrix() {
    return identity;
  }
  get absoluteMatrixInverse() {
    return identity;
  }
  get contentBox() {
    return {
      left: 0,
      top: 0,
      width: 0,
      height: 0
    };
  }
}
class RectLayer extends LayerModel {
  getIcon() {
    return obj$3.rect;
  }
  getDefaultObject(obj2 = {}) {
    return super.getDefaultObject(__spreadValues({
      itemType: "rect",
      name: "New Rect"
    }, obj2));
  }
  getDefaultTitle() {
    return "Rect";
  }
}
var isNdarray$2 = function(arr) {
  if (!arr)
    return false;
  if (!arr.dtype)
    return false;
  var re = new RegExp("function View[0-9]+d(:?" + arr.dtype + ")+");
  return re.test(String(arr.constructor));
};
var isNdarrayLike$3 = function(arr) {
  if (!arr)
    return false;
  return arr.data !== void 0 && Array.isArray(arr.shape) && arr.offset !== void 0 && arr.stride !== void 0;
};
var isArrayLike$5 = function isArrayLike(data) {
  return Array.isArray(data) || ArrayBuffer.isView(data);
};
var isNdarray$1 = isNdarray$2;
var isNdarrayLike$2 = isNdarrayLike$3;
var isArrayLike$4 = isArrayLike$5;
function inferType$5(x) {
  if (!x) {
    return void 0;
  }
  if (isNdarray$1(x) || isNdarrayLike$2(x)) {
    if (x.dtype === "generic") {
      return inferType$5.GENERIC_NDARRAY;
    }
    return inferType$5.NDARRAY;
  } else {
    if (isArrayLike$4(x)) {
      return inferType$5.ARRAY_OF_ARRAYS;
    }
    throw new Error("Unhandled data type. Got type: " + typeof x);
  }
}
inferType$5.ARRAY_OF_ARRAYS = "Arr";
inferType$5.NDARRAY = "Nd";
inferType$5.GENERIC_NDARRAY = "GenNd";
inferType$5.PACKED = "PackArr";
var inferType_1 = inferType$5;
var isArrayLike$3 = isArrayLike$5;
function capitalize(str) {
  return str[0].toUpperCase() + str.slice(1);
}
var cacheKey = function(nurbs2, debug, checkBounds, pointType, weightType, knotType) {
  var d;
  var degreeParts = [];
  var hasAnyKnots = false;
  for (d = 0; d < nurbs2.splineDimension; d++) {
    var hasKnots = isArrayLike$3(nurbs2.knots) && isArrayLike$3(nurbs2.knots[d]);
    if (hasKnots)
      hasAnyKnots = true;
    degreeParts.push("Deg" + nurbs2.degree[d] + (hasKnots ? "" : "Uniform") + capitalize(nurbs2.boundary[d]));
  }
  var parts = [
    [
      hasAnyKnots ? "NU" : "",
      nurbs2.weights ? "RBS" : "BS"
    ].join("") + nurbs2.dimension + "D",
    degreeParts.join("_")
  ];
  if (pointType) {
    parts.push(pointType + "Pts");
  }
  if (weightType) {
    parts.push(weightType + "Wts");
  }
  if (knotType) {
    parts.push(knotType + "Kts");
  }
  if (debug) {
    parts.push("debug");
  }
  if (checkBounds) {
    parts.push("chk");
  }
  return parts.join("_");
};
var createVariable$1 = function createVariable(name, nurbs2) {
  return function(i, period) {
    if (i !== void 0 && !Array.isArray(i))
      i = [i];
    var dimAccessors = [];
    for (var j = 0; j < i.length; j++) {
      dimAccessors.push(createVariable.sum(i[j]));
    }
    if (period) {
      for (i = 0; i < dimAccessors.length; i++) {
        if (period[i] === void 0)
          continue;
        dimAccessors[i] = "(" + dimAccessors[i] + " + " + period[i] + ") % " + period[i];
      }
    }
    return name + dimAccessors.join("_");
  };
};
createVariable$1.sum = function(parts) {
  parts = Array.isArray(parts) ? parts : [parts];
  parts = parts.filter(function(part) {
    return part !== void 0 && part !== 0;
  });
  if (parts.length === 0)
    parts.push(0);
  return parts.join(" + ");
};
var variable$3 = createVariable$1;
var inferType$4 = inferType_1;
var createVariable2 = variable$3;
function wrapAccessor(callback) {
  return function(i, period) {
    if (i !== void 0 && !Array.isArray(i))
      i = [i];
    var dimAccessors = [];
    for (var j = 0; j < i.length; j++) {
      dimAccessors.push(createVariable2.sum(i[j]));
    }
    if (period) {
      for (i = 0; i < dimAccessors.length; i++) {
        if (period[i] === void 0)
          continue;
        dimAccessors[i] = "(" + dimAccessors[i] + " + " + period[i] + ") % " + period[i];
      }
    }
    return callback(dimAccessors);
  };
}
function createAccessor(name, data) {
  var i;
  if (!data)
    return void 0;
  switch (inferType$4(data)) {
    case inferType$4.ARRAY_OF_ARRAYS:
      return wrapAccessor(function(accessors) {
        return name + "[" + accessors.join("][") + "]";
      });
    case inferType$4.GENERIC_NDARRAY:
      return wrapAccessor(function(accessors) {
        return name + ".get(" + accessors.join(",") + ")";
      });
    case inferType$4.NDARRAY:
      return wrapAccessor(function(accessors) {
        var code2 = [name + "Offset"];
        for (i = 0; i < accessors.length; i++) {
          code2.push(name + "Stride" + i + " * (" + accessors[i] + ")");
        }
        return name + "[" + code2.join(" + ") + "]";
      });
    case inferType$4.PACKED:
    default:
      return void 0;
  }
}
var createAccessors$1 = function(nurbs2) {
  var accessors = {};
  var accessor;
  accessor = createAccessor("x", nurbs2.points);
  if (accessor)
    accessors.point = accessor;
  accessor = createAccessor("w", nurbs2.weights);
  if (accessor)
    accessors.weight = accessor;
  accessor = createAccessor("k", nurbs2.knots);
  if (accessor)
    accessors.knot = accessor;
  return accessors;
};
var args = [];
var tmp$1 = [];
var numericalDerivative$1 = function numericalDerivative(out, order, dimension) {
  if (order !== 1) {
    throw new Error("Numerical derivative not implemented for order n = " + order + ".");
  }
  var i;
  var h = arguments[this.splineDimension + 3] === void 0 ? 1e-4 : arguments[this.splineDimension + 3];
  args.length = this.splineDimension;
  for (i = 0; i < this.splineDimension; i++) {
    args[i + 1] = arguments[i + 3];
  }
  var domain = this.domain;
  var k0 = domain[dimension][0];
  var k1 = domain[dimension][1];
  var tm, tp, T;
  var t0 = args[dimension + 1];
  var dt = (k1 - k0) * h;
  if (this.boundary[dimension] === "closed") {
    T = k1 - k0;
    tm = k0 + (t0 - k0 - dt + T) % T;
    tp = k0 + (t0 - k0 + dt + T) % T;
    dt *= 2;
  } else {
    tm = Math.min(k1, Math.max(k0, t0 - dt));
    tp = Math.min(k1, Math.max(k0, t0 + dt));
    dt = tp - tm;
  }
  args[dimension + 1] = tm;
  args[0] = tmp$1;
  this.evaluate.apply(null, args);
  args[dimension + 1] = tp;
  args[0] = out;
  this.evaluate.apply(null, args);
  for (i = 0; i < this.dimension; i++) {
    out[i] = (out[i] - tmp$1[i]) / dt;
  }
  return out;
};
var ndloop$2 = function ndloop(n, callback) {
  for (var m = 1, k = 0, i = []; k < n.length; k++) {
    m *= Array.isArray(n[k]) ? n[k][1] - n[k][0] : n[k];
    i[k] = Array.isArray(n[k]) ? n[k][0] : 0;
  }
  for (var ptr = 0; ptr < m; ptr++) {
    callback(i.slice());
    for (k = n.length - 1; k >= 0; k--) {
      if (i[k] === (Array.isArray(n[k]) ? n[k][1] : n[k]) - 1) {
        i[k] = Array.isArray(n[k]) ? n[k][0] : 0;
      } else {
        i[k]++;
        break;
      }
    }
  }
};
var inferType$3 = inferType_1;
var accessorPreamble$3 = function(nurbs2, variableName, propertyName, data) {
  var i;
  var code2 = [];
  switch (inferType$3(data)) {
    case inferType$3.NDARRAY:
      code2.push("  var " + variableName + " = " + propertyName + ".data;");
      code2.push("  var " + variableName + "Offset = " + propertyName + ".offset;");
      for (i = 0; i < data.dimension; i++) {
        code2.push("  var " + variableName + "Stride" + i + " = " + propertyName + ".stride[" + i + "];");
      }
      break;
    case inferType$3.ARRAY_OF_ARRAYS:
      code2.push("  var " + variableName + " = " + propertyName + ";");
  }
  return code2.join("\n");
};
var isNdarrayLike$1 = isNdarrayLike$3;
var sizeGetter$3 = function(data, dataVariableName, dimension) {
  if (!data) {
    return "this.size[" + dimension + "]";
  } else if (isNdarrayLike$1(data)) {
    return dataVariableName + ".shape[" + dimension + "]";
  } else {
    var str = dataVariableName;
    for (var i = 0; i < dimension; i++) {
      str += "[0]";
    }
    return str + ".length";
  }
};
var ndloop$1 = ndloop$2;
var variable$2 = variable$3;
var accessorPreamble$2 = accessorPreamble$3;
var inferType$2 = inferType_1;
var isArrayLike$2 = isArrayLike$5;
var sizeGetter$2 = sizeGetter$3;
var evaluatorCache = {};
var codeCache = {};
var evaluate = function(cacheKey2, nurbs2, accessors, debug, checkBounds, isBasis, derivative) {
  var splineDimension = nurbs2.splineDimension;
  var i, j, n, m, d, kvar;
  var points = nurbs2.points;
  var degree = nurbs2.degree;
  var weights = nurbs2.weights;
  var hasWeights = weights !== void 0;
  var knots = nurbs2.knots;
  var spaceDimension = nurbs2.dimension;
  var boundary = nurbs2.boundary;
  if (derivative !== void 0 && derivative !== null) {
    if (!Array.isArray(derivative)) {
      derivative = [derivative];
    }
    var totalDerivativeOrder = 0;
    for (i = 0; i < splineDimension; i++) {
      if (derivative[i] === void 0)
        derivative[i] = 0;
      totalDerivativeOrder += derivative[i];
    }
    if (hasWeights && totalDerivativeOrder > 1) {
      throw new Error("Analytical derivative not implemented for rational b-splines with order n = " + totalDerivativeOrder + ".");
    }
  }
  if (isBasis)
    cacheKey2 = "Basis" + cacheKey2;
  if (derivative)
    cacheKey2 = "Der" + derivative.join("_") + "_" + cacheKey2;
  var cachedEvaluator = evaluatorCache[cacheKey2];
  if (debug) {
    var logger = typeof debug === "function" ? debug : console.log;
  }
  if (cachedEvaluator) {
    if (debug) {
      logger(codeCache[cacheKey2]);
    }
    return cachedEvaluator.bind(nurbs2);
  }
  var code2 = [];
  var functionName = "evaluate" + cacheKey2;
  var pointAccessor = accessors.point;
  if (isBasis) {
    pointAccessor = function(src, period) {
      var terms = [];
      for (var i2 = 0; i2 < src.length; i2++) {
        var accessor = src[i2];
        var terms2 = [];
        for (var j2 = 0; j2 < accessor.length; j2++) {
          if (accessor[j2] !== 0)
            terms2.push(accessor[j2]);
        }
        accessor = terms2.join(" + ");
        if (period[i2]) {
          accessor = "(" + accessor + " + " + period[i2] + ") % " + period[i2];
        }
        terms.push(accessor + " === " + indexVar(i2));
      }
      return "((" + terms.join(" && ") + ") ? 1 : 0)";
    };
  }
  var weightAccessor = accessors.weight;
  var knotAccessor = accessors.knot;
  var knotVar = variable$2("k");
  var pointVar = variable$2("x");
  var weightVar = variable$2("w");
  var indexVar = variable$2("i");
  var tVar = variable$2("t");
  var domainVar = debug ? "domain" : "d";
  var sizeVar = variable$2(debug ? "size" : "s");
  var knotIndex = variable$2(debug ? "knotIndex" : "j");
  var allDimensionUniform = true;
  for (d = 0; d < splineDimension; d++) {
    if (isArrayLike$2(knots) && isArrayLike$2(knots[d])) {
      allDimensionUniform = false;
    }
  }
  function line2(str) {
    code2.push("  " + (str || ""));
  }
  function debugLine(str) {
    if (debug)
      line2(str);
  }
  if (isBasis) {
    var indexArgs = [];
  }
  var parameterArgs = [];
  for (i = 0; i < splineDimension; i++) {
    if (isBasis) {
      indexArgs.push(indexVar([i]));
    }
    parameterArgs.push(tVar([i]));
  }
  code2.push("function " + functionName + " (" + (isBasis ? "" : "out, ") + parameterArgs.join(", ") + (isBasis ? ", " + indexArgs.join(", ") : "") + ") {");
  line2("var h, m, a, b;");
  if (checkBounds) {
    line2("var " + domainVar + " = this.domain;");
    line2("for (var i = 0; i < this.splineDimension; i++) {");
    line2("  a = arguments[i + 1];");
    line2("  if (a < " + domainVar + "[i][0] || a > " + domainVar + "[i][1] || a === undefined || isNaN(a)) {");
    line2("    throw new Error('Invalid Spline parameter in dimension '+i+'. Valid domain is ['+" + domainVar + "[i][0]+', '+" + domainVar + "[i][1]+']. but got t'+i+' = '+arguments[i + 1]+'.');");
    line2("  }");
    line2("}");
  }
  for (d = 0; d < splineDimension; d++) {
    line2("var " + sizeVar(d) + " = " + sizeGetter$2(points, "this.points", d) + ";");
  }
  code2.push(accessorPreamble$2(nurbs2, "x", "this.points", points));
  if (hasWeights) {
    code2.push(accessorPreamble$2(nurbs2, "w", "this.weights", weights));
  }
  if (!allDimensionUniform) {
    code2.push(accessorPreamble$2(nurbs2, "k", "this.knots", knots));
  }
  function ternary(cond, a, b) {
    return "(" + cond + ") ? (" + a + ") : (" + b + ")";
  }
  var hasKnots = [];
  for (d = 0; d < splineDimension; d++) {
    switch (inferType$2(knots)) {
      case inferType$2.NDARRAY:
        hasKnots[d] = true;
        break;
      case inferType$2.ARRAY_OF_ARRAYS:
        hasKnots[d] = isArrayLike$2(knots[d]);
        break;
    }
  }
  for (d = 0; d < splineDimension; d++) {
    if (hasKnots[d]) {
      debugLine("\n  // Bisect to locate the knot interval in dimension " + d + "\n");
      line2("var " + knotIndex(d) + " = 0;");
      line2("h = " + sizeVar(d) + ";");
      line2("while(h > " + knotIndex(d) + " + 1) {");
      line2("  m = 0.5 * (h + " + knotIndex(d) + ") | 0;");
      line2("  if (" + knotAccessor([d, "m"]) + " > " + tVar(d) + ") h = m;");
      line2("  else " + knotIndex(d) + " = m;");
      line2("}");
      debugLine("\n  // Fetch knots for dimension " + d + "\n");
      for (i = -degree[d] + 1; i <= degree[d]; i++) {
        if (boundary[d] === "closed") {
          if (i < 0) {
            line2("var " + knotVar([d, i + degree[d] - 1]) + " = " + ternary(knotIndex(d) + " < " + -i, knotAccessor([d, 0]) + " + " + knotAccessor([d, [sizeVar(d), knotIndex(d), i]]) + " - " + knotAccessor([d, [sizeVar(d)]]), knotAccessor([d, [knotIndex(d), i]])) + ";");
          } else if (i > 0) {
            line2("var " + knotVar([d, i + degree[d] - 1]) + " = " + ternary(knotIndex(d) + " + " + i + " > " + sizeVar(d), knotAccessor([d, sizeVar(d)]) + " + " + knotAccessor([d, i + " + " + knotIndex(d) + " - " + sizeVar(d)]) + " - " + knotAccessor([d, 0]), knotAccessor([d, [knotIndex(d), i]])) + ";");
          } else {
            line2("var " + knotVar([d, i + degree[d] - 1]) + " = " + knotAccessor([d, [knotIndex(d), i]]) + ";");
          }
        } else {
          line2("var " + knotVar([d, i + degree[d] - 1]) + " = " + knotAccessor([d, [knotIndex(d), i]]) + ";");
        }
      }
    } else {
      debugLine("\n  // Directly compute knot interval for dimension " + d + "\n");
      if (boundary[d] === "closed") {
        line2(knotIndex(d) + " = (" + tVar(d) + " | 0) % " + sizeVar(d) + ";");
      } else {
        line2(knotIndex(d) + " = (" + tVar(d) + " | 0);");
        line2("if (" + knotIndex(d) + " < " + degree[d] + ") " + knotIndex(d) + " = " + degree[d] + ";");
        line2("if (" + knotIndex(d) + " > " + sizeVar(d) + " - 1) " + knotIndex(d) + " = " + sizeVar(d) + " - 1;");
      }
      debugLine("\n  // Compute and clamp knots for dimension " + d + "\n");
      for (i = -degree[d] + 1; i <= degree[d]; i++) {
        kvar = knotVar([d, i + degree[d] - 1]);
        line2("var " + kvar + " = " + knotIndex(d) + " + " + i + ";");
      }
      if (boundary[d] === "clamped") {
        for (i = -degree[d] + 1; i <= degree[d]; i++) {
          kvar = knotVar([d, i + degree[d] - 1]);
          if (i < 0) {
            line2("if (" + kvar + " < " + degree[d] + ") " + kvar + " = " + degree[d] + ";");
          }
          if (i > 0) {
            line2("if (" + kvar + " > " + sizeVar(d) + ") " + kvar + " = " + sizeVar(d) + ";");
          }
        }
      }
      if (boundary[d] === "closed") {
        debugLine("\n  // Wrap the B-Spline parameter for closed boundary");
        line2(tVar(d) + " %= " + sizeVar(d) + ";");
      }
    }
  }
  for (d = 0, n = []; d < splineDimension; d++) {
    n[d] = degree[d] + 1;
  }
  if (hasWeights) {
    debugLine("\n  // Fetch weights\n");
    ndloop$1(n, function(dst) {
      var readIdx = [];
      var period = [];
      for (var d2 = 0; d2 < splineDimension; d2++) {
        readIdx[d2] = [knotIndex(d2), dst[d2] - degree[d2]];
        if (boundary[d2] === "closed" && dst[d2] - degree[d2] < 0)
          period[d2] = sizeVar(d2);
      }
      line2("var " + weightVar(dst) + " = " + weightAccessor(readIdx, period) + ";");
    });
  }
  if (debug) {
    if (hasWeights) {
      line2("\n  // Fetch points and project into homogeneous (weighted) coordinates\n");
    } else {
      line2("\n  // Fetch points\n");
    }
  }
  ndloop$1(n, function(dst) {
    var readIdx = [];
    var period = [];
    for (var d2 = 0; d2 < splineDimension; d2++) {
      readIdx[d2] = [knotIndex(d2), dst[d2] - degree[d2]];
      if (boundary[d2] === "closed" && dst[d2] - degree[d2] < 0)
        period[d2] = sizeVar(d2);
    }
    if (isBasis) {
      if (hasWeights) {
        line2("var " + pointVar(dst) + " = " + pointAccessor(readIdx, period) + " * " + weightVar(dst) + ";");
      } else {
        line2("var " + pointVar(dst) + " = " + pointAccessor(readIdx, period) + ";");
      }
    } else {
      for (d2 = 0; d2 < spaceDimension; d2++) {
        var dstWithDim = dst.concat(d2);
        readIdx[splineDimension] = d2;
        if (hasWeights) {
          line2("var " + pointVar(dstWithDim) + " = " + pointAccessor(readIdx, period) + " * " + weightVar(dst) + ";");
        } else {
          line2("var " + pointVar(dstWithDim) + " = " + pointAccessor(readIdx, period) + ";");
        }
      }
    }
  });
  debugLine("\n");
  debugLine("// Perform De Boor's algorithm");
  for (d = n.length - 1; d >= 0; d--) {
    n[d] = [degree[d], degree[d] + 1];
    for (i = 0; i < degree[d]; i++) {
      debugLine("\n  // Degree " + degree[d] + " evaluation in dimension " + d + ", step " + (i + 1) + "\n");
      for (j = degree[d]; j > i; j--) {
        var isDerivative = derivative && degree[d] - i - derivative[d] <= 0;
        if (isDerivative) {
          line2("m = 1 / (" + knotVar([d, j - i + degree[d] - 1]) + " - " + knotVar([d, j - 1]) + ");");
          if (hasWeights) {
            line2("a = (" + tVar(d) + " - " + knotVar([d, j - 1]) + ") * m;");
            line2("b = 1 - a;");
          }
        } else {
          line2("a = (" + tVar(d) + " - " + knotVar([d, j - 1]) + ") / (" + knotVar([d, j - i + degree[d] - 1]) + " - " + knotVar([d, j - 1]) + ");");
          line2("b = 1 - a;");
        }
        if (hasWeights) {
          ndloop$1(n, function(ii) {
            var ij = ii.slice();
            var ij1 = ii.slice();
            ij[d] = j;
            ij1[d] = j - 1;
            if (isDerivative && hasWeights)
              line2("h = " + weightVar(ij) + ";");
            line2(weightVar(ij) + " = b * " + weightVar(ij1) + " + a * " + weightVar(ij) + ";");
          });
        }
        ndloop$1(n, function(ii) {
          var weightFactor, pt1, pt2;
          var ij = ii.slice();
          var ij1 = ii.slice();
          ij[d] = j;
          ij1[d] = j - 1;
          if (isDerivative) {
            var derivCoeff = i + 1;
            if (isBasis) {
              weightFactor = hasWeights ? "h * " + weightVar(ij1) + " / " + weightVar(ij) + " * " : "";
              pt1 = pointVar(ij) + (hasWeights ? " / h" : "");
              pt2 = pointVar(ij1) + (hasWeights ? " / " + weightVar(ij1) : "");
              line2(pointVar(ij) + " = " + derivCoeff + " * " + weightFactor + "(" + pt1 + " - " + pt2 + ") * m;");
            } else {
              var ijWithDimension = ij.slice();
              var ij1WithDimension = ij1.slice();
              for (m = 0; m < spaceDimension; m++) {
                ijWithDimension[splineDimension] = ij1WithDimension[splineDimension] = m;
                weightFactor = hasWeights ? "h * " + weightVar(ij1) + " / " + weightVar(ij) + " * " : "";
                pt1 = pointVar(ijWithDimension) + (hasWeights ? " / h" : "");
                pt2 = pointVar(ij1WithDimension) + (hasWeights ? " / " + weightVar(ij1) : "");
                line2(pointVar(ijWithDimension) + " = " + derivCoeff + " * " + weightFactor + "(" + pt1 + " - " + pt2 + ") * m;");
              }
            }
          } else {
            if (isBasis) {
              line2(pointVar(ij) + " = b * " + pointVar(ij1) + " + a * " + pointVar(ij) + ";");
            } else {
              for (m = 0; m < spaceDimension; m++) {
                ij[splineDimension] = ij1[splineDimension] = m;
                line2(pointVar(ij) + " = b * " + pointVar(ij1) + " + a * " + pointVar(ij) + ";");
              }
            }
          }
        });
        debugLine("\n");
      }
    }
  }
  if (debug) {
    if (hasWeights) {
      line2("\n  // Project back from homogeneous coordinates and return final output\n");
    } else {
      line2("\n  // Return final output\n");
    }
  }
  if (isBasis) {
    if (hasWeights) {
      line2("return " + pointVar(degree) + " / " + weightVar(degree) + ";");
    } else {
      line2("return " + pointVar(degree) + ";");
    }
  } else {
    for (d = 0; d < spaceDimension; d++) {
      if (hasWeights) {
        line2("out[" + d + "] = " + pointVar(degree.concat([d])) + " / " + weightVar(degree) + ";");
      } else {
        line2("out[" + d + "] = " + pointVar(degree.concat([d])) + ";");
      }
    }
  }
  if (!isBasis) {
    line2("return out;");
  }
  code2.push("}");
  if (debug) {
    var codeStr = code2.join("\n");
    logger(codeStr);
    codeCache[cacheKey2] = codeStr;
  }
  var evaluator = new Function([code2.join("\n"), "; return ", functionName].join(""))();
  evaluatorCache[cacheKey2] = evaluator;
  return evaluator.bind(nurbs2);
};
var transformerCache = {};
var accessorPreamble$1 = accessorPreamble$3;
var sizeGetter$1 = sizeGetter$3;
var variable$1 = variable$3;
var transform = function createTransform(cacheKey2, nurbs2, accessors, debug) {
  var i, j, iterator, iterators, terms, n, rvalue, lvalue;
  var cachedTransformer = transformerCache[cacheKey2];
  if (cachedTransformer) {
    return cachedTransformer.bind(nurbs2);
  }
  var code2 = [];
  var functionName = "transform" + cacheKey2;
  code2.push("function " + functionName + "(m) {");
  code2.push("var i, w;");
  code2.push(accessorPreamble$1(nurbs2, "x", "this.points", nurbs2.points));
  var sizeVar = variable$1(debug ? "size" : "s");
  for (i = 0; i < nurbs2.splineDimension; i++) {
    code2.push("var " + sizeVar(i) + " = " + sizeGetter$1(nurbs2.points, "this.points", i) + ";");
  }
  iterators = [];
  for (i = 0; i < nurbs2.splineDimension; i++) {
    iterator = "i" + i;
    iterators.push(iterator);
    code2.push("for (" + iterator + " = " + sizeVar(i) + "- 1; " + iterator + " >= 0; " + iterator + "--) {");
  }
  for (i = 0; i < nurbs2.dimension; i++) {
    code2.push("x" + i + " = " + accessors.point(iterators.concat([i])));
  }
  terms = [];
  for (i = 0; i < nurbs2.dimension; i++) {
    terms.push("m[" + ((nurbs2.dimension + 1) * (i + 1) - 1) + "] * x" + i);
  }
  terms.push("m[" + ((nurbs2.dimension + 1) * (nurbs2.dimension + 1) - 1) + "]");
  code2.push("var w = (" + terms.join(" + ") + ") || 1.0;");
  for (i = 0; i < nurbs2.dimension; i++) {
    terms = [];
    n = nurbs2.dimension;
    for (j = 0; j < n; j++) {
      terms.push("m[" + (j * (n + 1) + i) + "] * x" + j);
    }
    terms.push("m[" + (j * (n + 1) + i) + "]");
    lvalue = accessors.point(iterators.concat([i]));
    rvalue = "(" + terms.join(" + ") + ") / w";
    code2.push(lvalue + " = " + rvalue + ";");
  }
  for (i = nurbs2.splineDimension - 1; i >= 0; i--) {
    code2.push("}");
  }
  code2.push("return this;");
  code2.push("}");
  var transform2 = new Function([code2.join("\n"), "; return ", functionName].join(""))();
  if (debug)
    console.log(code2.join("\n"));
  transformerCache[cacheKey2] = transform2;
  return transform2.bind(nurbs2);
};
var ndloop2 = ndloop$2;
var variable = variable$3;
var accessorPreamble = accessorPreamble$3;
var inferType$1 = inferType_1;
var isArrayLike$1 = isArrayLike$5;
var sizeGetter = sizeGetter$3;
var supportCache = {};
var support = function(cacheKey2, nurbs2, accessors, debug, checkBounds) {
  var cachedSupport = supportCache[cacheKey2];
  if (cachedSupport) {
    return cachedSupport.bind(nurbs2);
  }
  var degree = nurbs2.degree;
  var knots = nurbs2.knots;
  var splineDimension = nurbs2.splineDimension;
  var boundary = nurbs2.boundary;
  var i, n, d;
  var code2 = [];
  var functionName = "support" + cacheKey2;
  var knotAccessor = accessors.knot;
  var tVar = variable("t");
  var domainVar = debug ? "domain" : "d";
  var sizeVar = variable(debug ? "size" : "s");
  var knotIndex = variable(debug ? "knotIndex" : "i");
  var allDimensionUniform = true;
  for (d = 0; d < splineDimension; d++) {
    if (isArrayLike$1(knots) && isArrayLike$1(knots[d])) {
      allDimensionUniform = false;
    }
  }
  function line2(str) {
    code2.push("  " + (str || ""));
  }
  var parameterArgs = [];
  for (i = 0; i < splineDimension; i++) {
    parameterArgs.push(tVar([i]));
  }
  code2.push("function " + functionName + " (out, " + parameterArgs.join(", ") + ") {");
  var c2 = 0;
  function pushSupport(args2, period) {
    if (period === void 0) {
      line2("out[" + c2++ + "] = " + args2.join(" + ") + ";");
    } else {
      line2("out[" + c2++ + "] = (" + args2.join(" + ") + " + " + period + ") % " + period + ";");
    }
  }
  line2("var h, m;");
  line2("var c = 0;");
  if (checkBounds) {
    line2("var " + domainVar + " = this.domain;");
    line2("for (var i = 0; i < this.splineDimension; i++) {");
    line2("  a = arguments[i + 1];");
    line2("  if (a < " + domainVar + "[i][0] || a > " + domainVar + "[i][1] || a === undefined || isNaN(a)) {");
    line2("    throw new Error('Invalid Spline parameter in dimension '+i+'. Valid domain is ['+" + domainVar + "[i][0]+', '+" + domainVar + "[i][1]+']. but got t'+i+' = '+arguments[i + 1]+'.');");
    line2("  }");
    line2("}");
  }
  for (d = 0; d < splineDimension; d++) {
    line2("var " + sizeVar(d) + " = " + sizeGetter(nurbs2.points, "this.points", d) + ";");
  }
  if (!allDimensionUniform) {
    code2.push(accessorPreamble(nurbs2, "k", "this.knots", knots));
  }
  var hasKnots = [];
  for (d = 0; d < splineDimension; d++) {
    switch (inferType$1(knots)) {
      case inferType$1.NDARRAY:
        hasKnots[d] = true;
        break;
      case inferType$1.ARRAY_OF_ARRAYS:
        hasKnots[d] = isArrayLike$1(knots[d]);
        break;
    }
  }
  for (d = 0; d < splineDimension; d++) {
    if (hasKnots[d]) {
      line2("var " + knotIndex(d) + " = 0;");
      line2("h = " + sizeVar(d) + ";");
      line2("while(h > " + knotIndex(d) + " + 1) {");
      line2("  m = 0.5 * (h + " + knotIndex(d) + ") | 0;");
      line2("  if (" + knotAccessor([d, "m"]) + " > " + tVar(d) + ") h = m;");
      line2("  else " + knotIndex(d) + " = m;");
      line2("}");
    } else {
      if (boundary[d] === "closed") {
        line2(knotIndex(d) + " = (" + tVar(d) + " | 0) % " + sizeVar(d) + ";");
      } else {
        line2(knotIndex(d) + " = (" + tVar(d) + " | 0);");
        line2("if (" + knotIndex(d) + " < " + degree[d] + ") " + knotIndex(d) + " = " + degree[d] + ";");
        line2("if (" + knotIndex(d) + " > " + sizeVar(d) + " - 1) " + knotIndex(d) + " = " + sizeVar(d) + " - 1;");
      }
    }
  }
  for (d = 0, n = []; d < splineDimension; d++) {
    n[d] = degree[d] + 1;
  }
  ndloop2(n, function(dst) {
    var readIdx = [];
    var period = [];
    for (var d2 = 0; d2 < splineDimension; d2++) {
      readIdx[d2] = [knotIndex(d2), dst[d2] - degree[d2]];
      if (boundary[d2] === "closed" && dst[d2] - degree[d2] < 0)
        period[d2] = sizeVar(d2);
    }
    for (d2 = 0; d2 < splineDimension; d2++) {
      pushSupport(readIdx[d2], period[d2]);
    }
  });
  line2("out.length = " + c2 + ";");
  line2("return out;");
  code2.push("}");
  if (debug)
    console.log(code2.join("\n"));
  var evaluator = new Function([code2.join("\n"), "; return ", functionName].join(""))();
  supportCache[cacheKey2] = evaluator;
  return evaluator.bind(nurbs2);
};
var inferType = inferType_1;
var computeCacheKey = cacheKey;
var isNdarray = isNdarray$2;
var isNdarrayLike = isNdarrayLike$3;
var createAccessors = createAccessors$1;
var numericalDerivative2 = numericalDerivative$1;
var isArrayLike2 = isArrayLike$5;
var createEvaluator = evaluate;
var createTransform2 = transform;
var createSupport = support;
var BOUNDARY_TYPES = {
  open: "open",
  closed: "closed",
  clamped: "clamped"
};
function isBlank(x) {
  return x === void 0 || x === null;
}
function parseNURBS(points, degree, knots, weights, boundary, opts) {
  var i, dflt;
  if (points && !isArrayLike2(points) && !isNdarray(points)) {
    opts = points;
    this.debug = points.debug;
    this.checkBounds = !!points.checkBounds;
    this.weights = points.weights;
    this.knots = points.knots;
    this.degree = points.degree;
    this.boundary = points.boundary;
    this.points = points.points;
    Object.defineProperty(this, "size", { value: opts.size, writable: true, configurable: true });
  } else {
    opts = opts || {};
    this.weights = weights;
    this.knots = knots;
    this.degree = degree;
    this.points = points;
    this.boundary = boundary;
    this.debug = opts.debug;
    this.checkBounds = !!opts.checkBounds;
    Object.defineProperty(this, "size", { value: opts.size, writable: true, configurable: true });
  }
  var pointType = inferType(this.points);
  var weightType = inferType(this.weights);
  var knotType = inferType(this.knots);
  if (this.points) {
    switch (pointType) {
      case inferType.GENERIC_NDARRAY:
      case inferType.NDARRAY:
        Object.defineProperties(this, {
          splineDimension: {
            value: this.points.shape.length - 1,
            writable: false,
            configurable: true
          },
          dimension: {
            value: this.points.shape[this.points.shape.length - 1],
            writable: false,
            configurable: true
          },
          size: {
            get: function() {
              return this.points.shape.slice(0, this.points.shape.length - 1);
            },
            set: function() {
              throw new Error("Cannot assign to read only property 'size'");
            },
            configurable: true
          }
        });
        break;
      case inferType.ARRAY_OF_ARRAYS:
        var splineDimension = 0;
        var size2 = this.size || [];
        size2.length = 0;
        for (var ptr = this.points; isArrayLike2(ptr[0]); ptr = ptr[0]) {
          splineDimension++;
          size2.push(ptr.length);
        }
        if (splineDimension === 0) {
          throw new Error("Expected an array of points");
        }
        Object.defineProperties(this, {
          splineDimension: {
            value: splineDimension,
            writable: false,
            configurable: true
          },
          dimension: {
            value: ptr.length,
            writable: false,
            configurable: true
          },
          size: {
            get: function() {
              var size3 = [];
              size3.length = 0;
              for (var i2 = 0, ptr2 = this.points; i2 < this.splineDimension; i2++, ptr2 = ptr2[0]) {
                size3[i2] = ptr2.length;
              }
              return size3;
            },
            set: function() {
              throw new Error("Cannot assign to read only property 'size'");
            },
            configurable: true
          }
        });
        break;
      case inferType.PACKED:
      default:
        throw new Error("Expected either a packed array, array of arrays, or ndarray of points");
    }
  } else {
    if (this.size === void 0 || this.size === null) {
      throw new Error("Either points or a control hull size must be provided.");
    }
    if (!isArrayLike2(this.size)) {
      Object.defineProperty(this, "size", {
        value: [this.size],
        writable: true,
        configurable: true
      });
    }
    if (this.size.length === 0) {
      throw new Error("`size` must be a number or an array of length at least one.");
    }
    Object.defineProperties(this, {
      splineDimension: {
        value: this.size.length,
        writable: false,
        configurable: true
      },
      dimension: {
        value: 0,
        writable: false,
        configurable: true
      }
    });
  }
  if (isArrayLike2(this.degree)) {
    for (i = 0; i < this.splineDimension; i++) {
      if (isBlank(this.degree[i])) {
        throw new Error("Missing degree in dimension " + (i + 1));
      }
    }
  } else {
    var hasBaseDegree = !isBlank(this.degree);
    var baseDegree = isBlank(this.degree) ? 2 : this.degree;
    this.degree = [];
    for (i = 0; i < this.splineDimension; i++) {
      if (this.size[i] <= baseDegree) {
        if (hasBaseDegree) {
          throw new Error("Expected at least " + (baseDegree + 1) + " points for degree " + baseDegree + " spline in dimension " + (i + 1) + " but got only " + this.size[i]);
        } else {
          this.degree[i] = this.size[i] - 1;
        }
      } else {
        this.degree[i] = baseDegree;
      }
    }
  }
  dflt = typeof this.boundary !== "string" ? "open" : this.boundary;
  if (!BOUNDARY_TYPES[dflt]) {
    throw new Error("Boundary type must be one of " + Object.keys(BOUNDARY_TYPES) + ". Got " + dflt);
  }
  this.boundary = isArrayLike2(this.boundary) ? this.boundary : [];
  this.boundary.length = this.splineDimension;
  for (i = 0; i < this.splineDimension; i++) {
    this.boundary[i] = isBlank(this.boundary[i]) ? dflt : this.boundary[i];
    if (!BOUNDARY_TYPES[dflt]) {
      throw new Error("Boundary type must be one of " + Object.keys(BOUNDARY_TYPES) + ". Got " + dflt + " for dimension " + (i + 1));
    }
  }
  switch (knotType) {
    case inferType.ARRAY_OF_ARRAYS:
      if (isArrayLike2(this.knots) && this.knots.length > 0 && !isArrayLike2(this.knots[0])) {
        this.knots = [this.knots];
      }
      for (i = 0; i < this.splineDimension; i++) {
        if (this.size[i] <= this.degree[i]) {
          throw new Error("Expected at least " + (this.degree[i] + 1) + " points in dimension " + (i + 1) + " but got " + this.size[i] + ".");
        }
        if (isArrayLike2(this.knots[i])) {
          if (this.boundary[i] !== "closed" && this.knots[i].length !== this.degree[i] + this.size[i] + 1) {
            throw new Error("Expected " + (this.degree[i] + this.size[i] + 1) + " knots in dimension " + (i + 1) + " but got " + this.knots[i].length + ".");
          } else if (this.boundary[i] === "closed" && this.knots[i].length !== this.size[i] + 1) {
            var canBeFudged = this.knots[i].length === this.size[i] + this.degree[i] + 1;
            if (!canBeFudged) {
              throw new Error("Expected " + (this.size[i] + 1) + " knots for closed spline in dimension " + (i + 1) + " but got " + this.knots[i].length + ".");
            }
          }
        }
      }
      break;
  }
  var newCacheKey = computeCacheKey(this, this.debug, this.checkBounds, pointType, weightType, knotType);
  if (newCacheKey !== this.__cacheKey) {
    this.__cacheKey = newCacheKey;
    var accessors = createAccessors(this);
    this.evaluate = createEvaluator(this.__cacheKey, this, accessors, this.debug, this.checkBounds, false);
    this.transform = createTransform2(this.__cacheKey, this, accessors, this.debug);
    this.support = createSupport(this.__cacheKey, this, accessors, this.debug, this.checkBounds);
    this.evaluator = function(derivativeOrder, isBasis) {
      return createEvaluator(this.__cacheKey, this, accessors, this.debug, this.checkBounds, isBasis, derivativeOrder);
    };
  }
  this.numericalDerivative = numericalDerivative2.bind(this);
  return this;
}
function domainGetter() {
  var sizeArray;
  var ret = [];
  var ptr = this.points;
  if (!ptr) {
    sizeArray = this.size;
  } else if (isNdarrayLike(ptr)) {
    sizeArray = ptr.shape;
  }
  for (var d = 0; d < this.splineDimension; d++) {
    var size2 = sizeArray ? sizeArray[d] : ptr.length;
    var p = this.degree[d];
    var isClosed = this.boundary[d] === "closed";
    if (this.knots && this.knots[d]) {
      var k = this.knots[d];
      ret[d] = [k[isClosed ? 0 : p], k[size2]];
    } else {
      ret[d] = [isClosed ? 0 : p, size2];
    }
    if (ptr)
      ptr = ptr[0];
  }
  return ret;
}
function nurbs(points, degree, knots, weights, boundary, opts) {
  var ctor = function(points2, degree2, knots2, weights2, boundary2, opts2) {
    parseFcn(points2, degree2, knots2, weights2, boundary2, opts2);
    return ctor;
  };
  var parseFcn = parseNURBS.bind(ctor);
  Object.defineProperty(ctor, "domain", {
    get: domainGetter
  });
  parseFcn(points, degree, knots, weights, boundary, opts);
  return ctor;
}
var nurbs_1 = nurbs;
class SplineModel extends SVGModel {
  getIcon() {
    return obj$3.star;
  }
  getDefaultObject(obj2 = {}) {
    return super.getDefaultObject(__spreadValues({
      itemType: "spline",
      name: "New Spline",
      strokeWidth: 1,
      points: [],
      traceCount: 100,
      degree: 2,
      boundary: "clamped"
    }, obj2));
  }
  get points() {
    return this.get("points");
  }
  set points(value) {
    this.set("points", value);
  }
  get degree() {
    return this.get("degree");
  }
  set degree(value) {
    this.set("degree", value);
  }
  get traceCount() {
    return this.get("traceCount");
  }
  set traceCount(value) {
    this.set("traceCount", value);
  }
  get boundary() {
    return this.get("boundary");
  }
  set boundary(value) {
    this.set("boundary", value);
  }
  enableHasChildren() {
    return false;
  }
  refreshMatrixCache() {
    super.refreshMatrixCache();
    if (this.hasChangedField("points", "boundary")) {
      this.setCache();
    } else if (this.hasChangedField("width", "height")) {
      if (!this.cachePath) {
        this.setCache();
      }
      this.points = this.cachePath.clone().scale(this.width / this.cacheWidth, this.height / this.cacheHeight).verties;
      this.modelManager.setChanged("reset", this.id, {
        points: this.points
      });
    }
  }
  setCache() {
    super.setCache();
    this.cachePath = PathParser.makePathByVerties(this.points);
    this.cacheWidth = this.width;
    this.cacheHeight = this.height;
  }
  get editablePath() {
    let { width: width2, height: height2, points } = this;
    if (!points || points.length == 0) {
      points = [
        [0, height2],
        [0, 0],
        [width2, 0],
        [width2, height2]
      ];
    }
    return this.absolutePath(PathParser.makePathByVerties(points).d).d;
  }
  recoverEditablePath(d) {
    const points = this.invertPath(d).verties;
    const pathData = this.updatePath(this.getPath(points));
    delete pathData.d;
    return __spreadValues({
      points
    }, pathData);
  }
  get d() {
    return this.getPath(this.points, this.boundary);
  }
  getPath(points, boundary) {
    let { width: width2, height: height2 } = this;
    if (!points) {
      points = this.points;
    }
    if (!boundary) {
      boundary = this.boundary;
    }
    if (!points || points.length == 0) {
      points = [
        [0, height2],
        [0, 0],
        [width2, 0],
        [width2, height2]
      ];
    }
    const curve = nurbs_1({
      points,
      degree: points.length - 2,
      boundary
    });
    const pt = [];
    const verties = [];
    const traceCount = (points.length - 1) * 100;
    const unit = 1 / traceCount;
    const d0 = curve.domain[0][0];
    const d1 = curve.domain[0][1];
    for (var t = 0; t <= 1; t += unit) {
      curve.evaluate(pt, d0 + (d1 - d0) * t);
      verties.push(clone(pt));
    }
    return PathParser.makePathByVerties(verties, false).round(1e3).d;
  }
  getDefaultTitle() {
    return "BSpline";
  }
}
class StarModel extends SVGModel {
  getIcon() {
    return obj$3.star;
  }
  getDefaultObject(obj2 = {}) {
    return super.getDefaultObject(__spreadValues({
      itemType: "star",
      name: "New Star",
      strokeWidth: 1,
      isCurve: false,
      count: 5,
      radius: 0.5,
      tension: 0.5
    }, obj2));
  }
  get count() {
    return this.get("count");
  }
  set count(value) {
    this.set("count", value);
  }
  get radius() {
    return this.get("radius");
  }
  set radius(value) {
    this.set("radius", value);
  }
  get tension() {
    return this.get("tension");
  }
  set tension(value) {
    this.set("tension", value);
  }
  get isCurve() {
    return this.get("isCurve");
  }
  convert(json) {
    json = super.convert(json);
    if (json.count)
      json.count = +json.count;
    if (json.radius)
      json.radius = +json.radius;
    if (json.tension)
      json.tension = +json.tension;
    return json;
  }
  enableHasChildren() {
    return false;
  }
  get d() {
    const { width: width2, height: height2, count, radius, tension, isCurve } = this;
    let newPath = "";
    if (isCurve) {
      newPath = PathParser.makeCurvedStar(width2, height2, count, radius, tension).d;
    } else {
      newPath = PathParser.makeStar(width2, height2, count, radius).d;
    }
    return newPath;
  }
  getDefaultTitle() {
    return "Star";
  }
}
class SVGTextItem extends SVGModel {
  getIcon() {
    return obj$3.title;
  }
  getDefaultObject(obj2 = {}) {
    return super.getDefaultObject(__spreadValues({
      itemType: "svg-text",
      name: "New Text",
      totalLength: 0,
      fill: "rgba(0, 0, 0, 1)",
      text: "Insert a text",
      fontWeight: Length.number(100),
      textLength: Length.em(0),
      lengthAdjust: "spacingAndGlyphs"
    }, obj2));
  }
  get text() {
    return this.get("text");
  }
  set text(value) {
    this.set("text", value);
  }
  get textLength() {
    return this.get("textLength");
  }
  set textLength(value) {
    this.set("textLength", value);
  }
  get lengthAdjust() {
    return this.get("lengthAdjust");
  }
  set lengthAdjust(value) {
    this.set("lengthAdjust", value);
  }
  enableHasChildren() {
    return false;
  }
  convert(json) {
    json = super.convert(json);
    json.textLength = Length.parse(json.textLength);
    return json;
  }
  getDefaultTitle() {
    return "Text";
  }
}
class SVGTextPathItem extends SVGModel {
  getIcon() {
    return obj$3.text_rotate;
  }
  getDefaultObject(obj2 = {}) {
    return super.getDefaultObject(__spreadValues({
      itemType: "svg-textpath",
      name: "New TextPath",
      d: "",
      totalLength: 0,
      fill: "rgba(0, 0, 0, 1)",
      text: "Insert a text",
      textLength: Length.em(0),
      lengthAdjust: "spacingAndGlyphs",
      startOffset: Length.em(0)
    }, obj2));
  }
  get d() {
    if (!this.get("d")) {
      return null;
    }
    if (!this.cachePath) {
      this.cachePath = new PathParser(this.get("d"));
      this.cacheWidth = this.width;
      this.cacheHeight = this.height;
    }
    return this.cachePath.clone().scale(this.width / this.cacheWidth, this.height / this.cacheHeight).d;
  }
  set d(value) {
    this.set("d", value);
  }
  get text() {
    return this.get("text");
  }
  set text(value) {
    this.set("text", value);
  }
  get textLength() {
    return this.get("textLength");
  }
  set textLength(value) {
    this.set("textLength", value);
  }
  get lengthAdjust() {
    return this.get("lengthAdjust");
  }
  set lengthAdjust(value) {
    this.set("lengthAdjust", value);
  }
  get startOffset() {
    return this.get("startOffset");
  }
  set startOffset(value) {
    this.set("startOffset", value);
  }
  enableHasChildren() {
    return false;
  }
  refreshMatrixCache() {
    super.refreshMatrixCache();
    if (this.hasChangedField("d")) {
      this.cachePath = new PathParser(this.get("d"));
      this.cacheWidth = this.width;
      this.cacheHeight = this.height;
    } else if (this.hasChangedField("width", "height")) {
      this.d = this.cachePath.clone().scale(this.width / this.cacheWidth, this.height / this.cacheHeight).d;
      this.modelManager.setChanged("reset", this.id, { d: this.d });
    }
  }
  convert(json) {
    json = super.convert(json);
    json.textLength = Length.parse(json.textLength);
    json.startOffset = Length.parse(json.startOffset);
    return json;
  }
  getDefaultTitle() {
    return "TextPath";
  }
}
class Component extends LayerModel {
  is(...itemType) {
    if (itemType.includes("component")) {
      return true;
    }
    return super.is(...itemType);
  }
  getProps() {
    return [];
  }
  static createComponent({
    iconString,
    title: title2 = "Unknown Title",
    attrs = {},
    enableHasChildren = false
  }) {
    return class extends Component {
      getIcon() {
        return iconString || iconUse("add");
      }
      getDefaultObject() {
        return super.getDefaultObject(__spreadValues({
          itemType: "NewComponent",
          name: "New Component"
        }, attrs));
      }
      enableHasChildren() {
        return enableHasChildren || false;
      }
      getDefaultTitle() {
        return title2;
      }
    };
  }
}
const DEFAULT_TEMPLATE = `
  <svg>
    <rect width="100%" height="100%" fill="black" />
  </svg>
`;
class TemplateModel extends Component {
  getIcon() {
    return obj$3.auto_awesome;
  }
  getDefaultObject(obj2 = {}) {
    return super.getDefaultObject(__spreadValues({
      itemType: "template",
      name: "New Template",
      engine: "dom",
      template: DEFAULT_TEMPLATE,
      params: []
    }, obj2));
  }
  get template() {
    return this.get("template");
  }
  set template(value) {
    this.set("template", value);
  }
  get params() {
    return this.get("params");
  }
  set params(value) {
    this.set("params", value);
  }
  get engine() {
    return this.get("engine");
  }
  set engine(value) {
    this.set("engine", value);
  }
  enableHasChildren() {
    return false;
  }
  getDefaultTitle() {
    return "Template";
  }
  editable(editablePropertyName) {
    switch (editablePropertyName) {
      case "font":
        return true;
    }
    return super.editable(editablePropertyName);
  }
}
class TextModel extends LayerModel {
  getIcon() {
    return obj$3.title;
  }
  getDefaultObject(obj2 = {}) {
    return super.getDefaultObject(__spreadValues({
      itemType: "text",
      name: "New Text",
      elementType: "p",
      content: ""
    }, obj2));
  }
  get content() {
    return this.get("content");
  }
  set content(value) {
    this.set("content", value);
  }
  enableHasChildren() {
    return false;
  }
  getDefaultTitle() {
    return "Text";
  }
  editable(editablePropertyName) {
    switch (editablePropertyName) {
      case "svg-item":
      case "transform":
      case "transformOrigin":
      case "perspective":
      case "perspectiveOrigin":
      case "layout":
        return false;
      case "font":
      case "fontSpacing":
      case "textStyle":
      case "textShadow":
      case "textFill":
      case "textClip":
      case "backgroundImage":
      case "box-model":
      case "border":
      case "borderRadius":
      case "backdropFilter":
      case "pattern":
        return true;
    }
    return super.editable(editablePropertyName);
  }
}
function defaultItems(editor) {
  editor.registerItem("project", Project);
  editor.registerItem("artboard", ArtBoard);
  editor.registerItem("rect", RectLayer);
  editor.registerItem("circle", CircleLayer);
  editor.registerItem("image", ImageLayer);
  editor.registerItem("text", TextModel);
  editor.registerItem("boolean-path", BooleanPathModel);
  editor.registerItem("svg-path", PathModel);
  editor.registerItem("svg-text", SVGTextItem);
  editor.registerItem("svg-textpath", SVGTextPathItem);
  editor.registerItem("template", TemplateModel);
  editor.registerItem("polygon", PolygonModel);
  editor.registerItem("star", StarModel);
  editor.registerItem("spline", SplineModel);
}
var texture = `
<svg xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 0 24 24" width="24px" fill="#000000">
    <path d="M19.51 3.08L3.08 19.51c.09.34.27.65.51.9.25.24.56.42.9.51L20.93 4.49c-.19-.69-.73-1.23-1.42-1.41zM11.88 3L3 11.88v2.83L14.71 3h-2.83zM5 3c-1.1 0-2 .9-2 2v2l4-4H5zm14 18c.55 0 1.05-.22 1.41-.59.37-.36.59-.86.59-1.41v-2l-4 4h2zm-9.71 0h2.83L21 12.12V9.29L9.29 21z"/>
</svg>
`;
var TextureView$1 = "";
const cssPatterns = [
  {
    itemType: "circle",
    name: "base",
    attrs: {
      backgroundColor: "#ececec"
    }
  },
  {
    itemType: "circle",
    name: "base",
    attrs: {
      backgroundColor: "black"
    }
  },
  {
    itemType: "circle",
    name: "base",
    attrs: {
      backgroundColor: "red"
    }
  },
  {
    itemType: "circle",
    name: "base",
    attrs: {
      "background-image": `
      background-image: linear-gradient(to right, #ececec, black 100%);
    `
    }
  },
  {
    itemType: "circle",
    name: "base",
    attrs: {
      "background-image": `
      background-image: linear-gradient(to right, #ececec, black 100%);
    `,
      border: `
      border:10px solid black;
    `
    }
  }
];
class CSSTextureView extends EditorElement {
  template() {
    return `
      <div class="pattern-list css-pattern-list" ref="$css-list"></div>
    `;
  }
  [LOAD("$css-list")]() {
    return cssPatterns.map((it, index2) => {
      const svg = this.$editor.svg.render(this.$model.createModel(__spreadValues({
        itemType: it.itemType,
        width: 70,
        height: 70
      }, it.attrs), false));
      return `
        <div class="pattern-item" data-index="${index2}">
          <div class="preview">${svg}</div>
        </div>
      `;
    });
  }
  [CLICK("$css-list .pattern-item")](e) {
    const index2 = +e.$dt.data("index");
    const pattern = cssPatterns[index2];
    e.$dt.onlyOneClass("selected");
    this.$commands.emit("addLayerView", pattern.itemType, pattern.attrs);
  }
}
const svgPatterns = [
  {
    itemType: "svg-path",
    name: "path",
    attrs: {
      backgroundColor: "transparent",
      stroke: "black",
      "stroke-width": 2,
      d: PathParser.makeRect(0, 0, 80, 80).d
    }
  },
  {
    itemType: "svg-path",
    name: "line",
    attrs: {
      backgroundColor: "transparent",
      stroke: "black",
      "stroke-width": 2,
      d: PathParser.makeLine(0, 0, 80, 80).d
    }
  },
  {
    itemType: "svg-path",
    name: "line 2",
    attrs: {
      backgroundColor: "transparent",
      stroke: "black",
      "stroke-width": 2,
      fill: "#ececec",
      d: PathParser.makeLine(0, 80, 80, 0).d
    }
  },
  {
    itemType: "svg-path",
    name: "circle",
    attrs: {
      backgroundColor: "transparent",
      stroke: "black",
      "stroke-width": 2,
      fill: "#ececec",
      originWidth: 80,
      originHeight: 80,
      d: PathParser.makeCircle(0, 0, 80, 80).d
    }
  },
  {
    itemType: "polygon",
    name: "polygon - 3",
    attrs: {
      backgroundColor: "transparent",
      stroke: "black",
      "stroke-width": 2,
      fill: "#ececec",
      count: 3,
      originWidth: 80,
      originHeight: 80,
      d: PathParser.makePolygon(80, 80, 3).d
    }
  },
  {
    itemType: "polygon",
    name: "polygon - 4",
    attrs: {
      backgroundColor: "transparent",
      stroke: "black",
      "stroke-width": 2,
      fill: "#ececec",
      count: 4,
      originWidth: 80,
      originHeight: 80,
      d: PathParser.makePolygon(80, 80, 4).d
    }
  },
  {
    itemType: "polygon",
    name: "polygon - 4",
    attrs: {
      backgroundColor: "transparent",
      stroke: "black",
      "stroke-width": 2,
      fill: "#ececec",
      count: 5,
      originWidth: 80,
      originHeight: 80,
      d: PathParser.makePolygon(80, 80, 5).d
    }
  },
  {
    itemType: "polygon",
    name: "polygon - 4",
    attrs: {
      backgroundColor: "transparent",
      stroke: "black",
      "stroke-width": 2,
      fill: "#ececec",
      count: 6,
      originWidth: 80,
      originHeight: 80,
      d: PathParser.makePolygon(80, 80, 6).d
    }
  },
  {
    itemType: "polygon",
    name: "polygon - 4",
    attrs: {
      backgroundColor: "transparent",
      stroke: "black",
      "stroke-width": 2,
      fill: "#ececec",
      count: 7,
      originWidth: 80,
      originHeight: 80,
      d: PathParser.makePolygon(80, 80, 7).d
    }
  },
  {
    itemType: "polygon",
    name: "polygon - 4",
    attrs: {
      backgroundColor: "transparent",
      stroke: "black",
      "stroke-width": 2,
      fill: "#ececec",
      count: 12,
      originWidth: 80,
      originHeight: 80,
      d: PathParser.makePolygon(80, 80, 12).d
    }
  },
  {
    itemType: "star",
    name: "star - 5",
    attrs: {
      backgroundColor: "transparent",
      stroke: "black",
      "stroke-width": 2,
      fill: "#ececec",
      originWidth: 80,
      originHeight: 80,
      count: 5,
      radius: 0.5,
      d: PathParser.makeStar(80, 80, 5, 0.5).d
    }
  },
  {
    itemType: "star",
    name: "curved star - 5",
    attrs: {
      backgroundColor: "transparent",
      stroke: "black",
      "stroke-width": 2,
      fill: "#ececec",
      originWidth: 80,
      originHeight: 80,
      count: 5,
      radius: 0.5,
      d: PathParser.makeCurvedStar(80, 80, 5, 0.5).d
    }
  }
];
class SVGTextureView extends EditorElement {
  template() {
    return `
      <div class="pattern-list svg-pattern-list" ref="$svg-list"></div>
    `;
  }
  [LOAD("$svg-list")]() {
    return svgPatterns.map((it, index2) => {
      let d = it.attrs.d;
      if (d) {
        const path = PathParser.fromSVGString(d);
        if (it.attrs.originWidth) {
          path.scale(60 / it.attrs.originWidth, 60 / it.attrs.originHeight);
        } else {
          const rect2 = path.rect();
          path.scale(70 / rect2.width, 70 / rect2.height);
        }
        d = path.d;
      }
      const svg = this.$editor.svg.render(this.$model.createModel(__spreadProps(__spreadValues({
        itemType: it.itemType,
        width: 80,
        height: 80
      }, it.attrs), {
        d
      }), false));
      return `
        <div class="pattern-item" data-index="${index2}">
          <div class="preview">${svg}</div>
        </div>
      `;
    });
  }
  [CLICK("$svg-list .pattern-item")](e) {
    const index2 = +e.$dt.data("index");
    const pattern = svgPatterns[index2];
    e.$dt.onlyOneClass("selected");
    this.$commands.emit("addLayerView", pattern.itemType, pattern.attrs);
  }
}
class TextureView extends EditorElement {
  template() {
    const isItemMode = this.$config.get("editor.design.mode") === "item";
    return /* @__PURE__ */ createElementJsx("div", {
      class: "elf--texture"
    }, /* @__PURE__ */ createElementJsx(Tabs, {
      ref: "$tab",
      selectedValue: isItemMode ? "svg" : "css",
      onchange: (value) => {
        this.$config.set("inspector.selectedValue", value);
      }
    }, isItemMode ? "" : /* @__PURE__ */ createElementJsx(TabPanel, {
      value: "css",
      title: "CSS"
    }, /* @__PURE__ */ createElementJsx("object", {
      refClass: "CSSTextureView",
      ref: "$css"
    })), /* @__PURE__ */ createElementJsx(TabPanel, {
      value: "svg",
      title: "SVG"
    }, /* @__PURE__ */ createElementJsx("object", {
      refClass: "SVGTextureView",
      ref: "$svg"
    }))));
  }
}
function defaultPatterns(editor) {
  editor.registerElement({
    TextureView,
    CSSTextureView,
    SVGTextureView
  });
  editor.registerUI("leftbar.tab", {
    TextureView: {
      value: "texture",
      title: "Texture",
      icon: texture,
      designMode: ["design", "item"]
    }
  });
  editor.registerUI("leftbar.tab.texture", {
    TextureView
  });
}
var ExportProperty$1 = "";
class ExportProperty extends BaseProperty {
  getTitle() {
    return this.$i18n("export.property.title");
  }
  isFirstShow() {
    return true;
  }
  getClassName() {
    return "elf--export-property";
  }
  getBody() {
    return `
        <div class='export-item svg'>
          <label>SVG</label>
          <button ref='$svg'>${iconUse("archive")} ${this.$i18n("export.property.download")}</button>
        </div>
        <div class='export-item png'>
          <label>PNG</label>
          <button ref='$png'>${iconUse("archive")} ${this.$i18n("export.property.download")}</button>
        </div> 
      `;
  }
  [CLICK("$svg")]() {
    this.$commands.emit("downloadSVG");
  }
  [CLICK("$png")]() {
    this.$commands.emit("downloadPNG");
  }
}
function exportResource(editor) {
  editor.registerUI("inspector.tab.style", {
    ExportProperty
  });
}
var FillEditorView$1 = "";
const spreadMethodList = [
  SpreadMethodType.PAD,
  SpreadMethodType.REFLECT,
  SpreadMethodType.REPEAT
];
const TOOL_SIZE$1 = 20;
class FillBaseEditor extends EditorElement {
  initializeData() {
    const current = this.$context.selection.current;
    this.state.currentMatrix = current.matrix;
    this.state.imageResult = current.createFragmentMatrix(this.state.key);
    this.state.originalResult = current.createFragmentMatrix(this.state.key);
  }
}
class FillTimingStepEditor extends FillBaseEditor {
  [POINTERSTART("$el .step-point") + MOVE("moveStepPoint") + END("moveEndStepPoint")](e) {
    this.$el.toggleClass("dragging", true);
    this.initializeData();
    const colorStepIndex = +e.$dt.data("colorstep-index");
    this.localColorStep = this.state.imageResult.image.colorsteps[colorStepIndex];
    this.localColorStepTimingCount = this.localColorStep.timing.count;
    this.localColorCubicBezierTimingCount = this.localColorStep.timingCount;
  }
  moveStepPoint(dx, dy) {
    const dist$1 = (dx < 0 ? -1 : 1) * Math.ceil(dist([0, 0, 0], [dx, dy, 0]) / 10);
    switch (this.localColorStep.timing.name) {
      case TimingFunction.LINEAR:
        break;
      case TimingFunction.STEPS:
        this.localColorStep.timing.count = Math.max(this.localColorStepTimingCount + dist$1, 1);
        break;
      default:
        this.localColorStep.timingCount = Math.max(this.localColorCubicBezierTimingCount + dist$1, 1);
        break;
    }
    this.$commands.executeCommand("setAttribute", `change ${this.state.key} fragment`, this.$context.selection.packByValue({
      [this.state.key]: `${this.state.imageResult.image}`
    }));
  }
  makeTimingString(timing) {
    switch (timing.name) {
      case TimingFunction.LINEAR:
        return ``;
      case TimingFunction.EASE:
      case TimingFunction.EASE_IN:
      case TimingFunction.EASE_OUT:
      case TimingFunction.EASE_IN_OUT:
        return `${timing.name}`;
      default:
        return `cubic-bezier(${timing.x1}, ${timing.y1}, ${timing.x2}, ${timing.y2})`;
    }
  }
  moveEndStepPoint(dx, dy) {
    if (dx === 0 && dy === 0) {
      const { timing } = this.localColorStep;
      switch (timing.name) {
        case TimingFunction.STEPS:
          this.localColorStep.timing.direction = this.localColorStep.timing.direction === "start" ? "end" : "start";
          this.$commands.executeCommand("setAttribute", `change ${this.state.key} fragment`, this.$context.selection.packByValue({
            [this.state.key]: `${this.state.imageResult.image}`
          }));
          break;
        case TimingFunction.LINEAR:
          break;
        case TimingFunction.PATH:
          this.emit("showComponentPopup", {
            title: "Path Editor",
            width: 400,
            inspector: [
              {
                key: "path",
                editor: "path",
                editorOptions: {
                  height: 160
                },
                defaultValue: timing.d
              }
            ],
            changeEvent: (key, value) => {
              this.localColorStep.timing = parseOneValue(`path(${value})`).parsed;
              this.$commands.executeCommand("setAttribute", `change ${this.state.key} fragment`, this.$context.selection.packByValue({
                [this.state.key]: `${this.state.imageResult.image}`
              }));
            }
          });
          break;
        default:
          this.emit("showComponentPopup", {
            title: "Cubic Bezier",
            width: 220,
            inspector: [
              {
                key: "timing",
                editor: "cubic-bezier",
                editorOptions: {
                  isAnimating: false
                },
                defaultValue: this.makeTimingString(timing)
              }
            ],
            changeEvent: (key, value) => {
              this.localColorStep.timing = parseOneValue(value).parsed;
              this.$commands.executeCommand("setAttribute", `change ${this.state.key} fragment`, this.$context.selection.packByValue({
                [this.state.key]: `${this.state.imageResult.image}`
              }));
            }
          });
          this.$el.toggleClass("dragging", false);
          return;
      }
    }
    this.$commands.executeCommand("setAttribute", `change ${this.state.key} fragment`, this.$context.selection.packByValue({
      [this.state.key]: `${this.state.imageResult.image}`
    }));
    this.$el.toggleClass("dragging", false);
  }
}
class FillColorstepEditor extends FillTimingStepEditor {
  [KEYUP("$el .colorstep")](e) {
    const index2 = +e.$dt.data("index");
    switch (e.code) {
      case "Delete":
      case "Backspace":
        this.removeStep(index2);
        break;
      case "BracketRight":
        this.sortToRight(index2);
        break;
      case "BracketLeft":
        this.sortToLeft(index2);
        break;
      case "Equal":
        this.appendColorStep(index2);
        break;
      case "Minus":
        this.prependColorStep(index2);
        break;
    }
  }
  removeStep(currentIndex) {
    const image2 = this.state.imageResult.image;
    image2.removeColorStepByIndex(currentIndex);
    this.updateColorStepStatus(image2, -1);
  }
  sortToRight() {
    const image2 = this.state.imageResult.image;
    image2.sortToRight();
    this.updateColorStepStatus(image2, -1);
  }
  sortToLeft() {
    const image2 = this.state.imageResult.image;
    image2.sortToLeft();
    this.updateColorStepStatus(image2, -1);
  }
  appendColorStep(currentIndex) {
    const nextIndex = currentIndex + 1;
    const image2 = this.state.imageResult.image;
    const currentColorStep = image2.colorsteps[currentIndex];
    const nextColorStep = image2.colorsteps[nextIndex];
    let newIndex = -1;
    if (!nextColorStep) {
      if (currentColorStep.percent !== 100) {
        newIndex = image2.insertColorStep(currentColorStep.percent + (100 - currentColorStep.percent) / 2);
      }
    } else {
      newIndex = image2.insertColorStep(currentColorStep.percent + (nextColorStep.percent - currentColorStep.percent) / 2);
    }
    this.updateColorStepStatus(image2, newIndex);
  }
  prependColorStep(currentIndex) {
    const prevIndex = currentIndex - 1;
    const image2 = this.state.imageResult.image;
    const currentColorStep = image2.colorsteps[currentIndex];
    const prevColorStep = image2.colorsteps[prevIndex];
    let newIndex = -1;
    if (!prevColorStep) {
      if (currentColorStep.percent !== 0) {
        newIndex = image2.insertColorStep(currentColorStep.percent);
      }
    } else {
      newIndex = image2.insertColorStep(prevColorStep.percent + (currentColorStep.percent - prevColorStep.percent) / 2);
    }
    this.updateColorStepStatus(image2, newIndex);
  }
  [POINTERSTART("$el .point") + MOVE("movePoint") + END("moveEndPoint")](e) {
    this.$el.toggleClass("dragging", true);
    this.initializeData();
    const result = this.state.imageResult;
    this.pointTarget = e.$dt.data("type");
    this.startPoint = this.$viewport.applyVertex(result.startPoint);
    this.endPoint = this.$viewport.applyVertex(result.endPoint);
    this.dist = dist(this.startPoint, this.endPoint);
    if (result.shapePoint) {
      this.shapePoint = this.$viewport.applyVertex(result.shapePoint);
      this.shapeDist = dist(this.startPoint, this.shapePoint);
    }
  }
  calculateNextPoint(nextPoint) {
    if (this.$config.get("bodyEvent").shiftKey) {
      let tempStartPoint, tempEndPoint;
      if (this.pointTarget === "start") {
        tempStartPoint = this.endPoint;
        tempEndPoint = nextPoint;
      } else {
        tempStartPoint = this.startPoint;
        tempEndPoint = nextPoint;
      }
      const newDist = subtract([], tempEndPoint, tempStartPoint);
      let newAngle = calculateAngle360(newDist[0], newDist[1]) - 90;
      newAngle = (newAngle + 360) % 360;
      newAngle -= newAngle % this.$config.get("fixed.gradient.angle");
      nextPoint = vertiesMap([add$1([], tempStartPoint, [0, -this.dist, 0])], calculateRotationOriginMat4(newAngle, tempStartPoint))[0];
    }
    return nextPoint;
  }
  moveShapePoint(dx, dy) {
    const targetPoint = this.shapePoint;
    const nextPoint = this.calculateNextPoint(add$1([], targetPoint, [dx, dy, 0]));
    const width2 = this.state.currentMatrix.width;
    const height2 = this.state.currentMatrix.height;
    const image2 = this.state.imageResult.image;
    let newX, newY;
    switch (image2.type) {
      case GradientType.RADIAL:
        const dist$1 = dist(this.startPoint, nextPoint);
        const lastPoint = lerp$1([], this.startPoint, this.shapePoint, dist$1 / this.shapeDist);
        const [worldPosition] = vertiesMap([this.$viewport.applyVertexInverse(lastPoint)], this.state.currentMatrix.absoluteMatrixInverse);
        newX = Length.makePercent(worldPosition[0], width2);
        newY = Length.makePercent(worldPosition[1], height2);
        image2.reset({
          x3: newX,
          y3: newY
        });
        break;
    }
    this.$commands.executeCommand("setAttribute", `change ${this.state.key} fragment`, this.$context.selection.packByValue({
      [this.state.key]: `${this.state.imageResult.image}`
    }));
  }
  movePoint(dx, dy) {
    if (this.pointTarget === "shape") {
      return this.moveShapePoint(dx, dy);
    }
    const targetPoint = this.pointTarget === "start" ? this.startPoint : this.endPoint;
    let nextPoint = this.calculateNextPoint(add$1([], targetPoint, [dx, dy, 0]));
    var [worldPosition] = vertiesMap([this.$viewport.applyVertexInverse(nextPoint)], this.state.currentMatrix.absoluteMatrixInverse);
    const width2 = this.state.currentMatrix.width;
    const height2 = this.state.currentMatrix.height;
    const image2 = this.state.imageResult.image;
    switch (image2.type) {
      case GradientType.RADIAL:
        var newX, newY, newX2, newY2, newX3, newY3;
        if (this.pointTarget === "start") {
          newX = image2.x1.isPercent() ? Length.makePercent(worldPosition[0], width2) : Length.px(worldPosition[0]);
          newY = image2.y1.isPercent() ? Length.makePercent(worldPosition[1], height2) : Length.px(worldPosition[1]);
          const nextEndPoint = this.calculateNextPoint(add$1([], this.endPoint, [dx, dy, 0]));
          const [newEndPosition] = vertiesMap([this.$viewport.applyVertexInverse(nextEndPoint)], this.state.currentMatrix.absoluteMatrixInverse);
          newX2 = image2.x2.isPercent() ? Length.makePercent(newEndPosition[0], width2) : Length.px(newEndPosition[0]);
          newY2 = image2.y2.isPercent() ? Length.makePercent(newEndPosition[1], height2) : Length.px(newEndPosition[1]);
          const nextShapePoint = this.calculateNextPoint(add$1([], this.shapePoint, [dx, dy, 0]));
          const [newShapePosition] = vertiesMap([this.$viewport.applyVertexInverse(nextShapePoint)], this.state.currentMatrix.absoluteMatrixInverse);
          newX3 = image2.x3.isPercent() ? Length.makePercent(newShapePosition[0], width2) : Length.px(newShapePosition[0]);
          newY3 = image2.y3.isPercent() ? Length.makePercent(newShapePosition[1], height2) : Length.px(newShapePosition[1]);
          image2.reset({
            x1: newX,
            y1: newY,
            x2: newX2,
            y2: newY2,
            x3: newX3,
            y3: newY3
          });
        } else if (this.pointTarget === "end") {
          if (this.$config.get("bodyEvent").altKey) {
            const dist$1 = dist(this.startPoint, nextPoint);
            nextPoint = lerp$1([], this.startPoint, this.endPoint, dist$1 / this.dist);
            var [worldPosition] = vertiesMap([this.$viewport.applyVertexInverse(nextPoint)], this.state.currentMatrix.absoluteMatrixInverse);
          }
          newX = Length.makePercent(worldPosition[0], width2);
          newY = Length.makePercent(worldPosition[1], height2);
          image2.reset({
            x2: newX,
            y2: newY
          });
          const lastDist = dist(this.startPoint, nextPoint);
          const unitVector = lerp$1([], this.startPoint, nextPoint, 1 / lastDist);
          const nextShapePoint = lerp$1([], this.startPoint, vertiesMap([unitVector], calculateRotationOriginMat4(90, this.startPoint))[0], image2.radialType === RadialGradientType.CIRCLE ? lastDist : this.shapeDist);
          const [newShapePosition] = vertiesMap([this.$viewport.applyVertexInverse(nextShapePoint)], this.state.currentMatrix.absoluteMatrixInverse);
          newX3 = Length.makePercent(newShapePosition[0], width2);
          newY3 = Length.makePercent(newShapePosition[1], height2);
          image2.reset({
            x3: newX3,
            y3: newY3
          });
        }
        break;
      case GradientType.LINEAR:
        var newX, newY;
        if (this.pointTarget === "start") {
          newX = image2.x1.isPercent() ? Length.makePercent(worldPosition[0], width2) : Length.px(worldPosition[0]);
          newY = image2.y1.isPercent() ? Length.makePercent(worldPosition[1], height2) : Length.px(worldPosition[1]);
          image2.reset({
            x1: newX,
            y1: newY
          });
        } else if (this.pointTarget === "end") {
          newX = image2.x2.isPercent() ? Length.makePercent(worldPosition[0], width2) : Length.px(worldPosition[0]);
          newY = image2.y2.isPercent() ? Length.makePercent(worldPosition[1], height2) : Length.px(worldPosition[1]);
          image2.reset({
            x2: newX,
            y2: newY
          });
        }
        break;
    }
    this.$commands.executeCommand("setAttribute", `change ${this.state.key} fragment`, this.$context.selection.packByValue({
      [this.state.key]: `${this.state.imageResult.image}`
    }));
  }
  moveEndPoint(dx, dy) {
    const image2 = this.state.imageResult.image;
    const width2 = this.state.currentMatrix.width;
    const height2 = this.state.currentMatrix.height;
    if (dx === 0 && dy === 0) {
      switch (image2.type) {
        case GradientType.RADIAL:
          if (this.pointTarget === "start") {
            switch (image2.radialType) {
              case RadialGradientType.CIRCLE:
                image2.reset({
                  radialType: RadialGradientType.ELLIPSE
                });
                break;
              case RadialGradientType.ELLIPSE:
                const lastDist = dist(this.startPoint, this.endPoint);
                const unitVector = lerp$1([], this.startPoint, this.endPoint, 1 / lastDist);
                const nextShapePoint = lerp$1([], this.startPoint, vertiesMap([unitVector], calculateRotationOriginMat4(90, this.startPoint))[0], lastDist);
                const [newShapePosition] = vertiesMap([this.$viewport.applyVertexInverse(nextShapePoint)], this.state.currentMatrix.absoluteMatrixInverse);
                const x3 = Length.makePercent(newShapePosition[0], width2);
                const y3 = Length.makePercent(newShapePosition[1], height2);
                image2.reset({
                  radialType: RadialGradientType.CIRCLE,
                  x3,
                  y3
                });
                break;
            }
            break;
          }
        default:
          const index2 = spreadMethodList.findIndex((it) => image2.spreadMethod === it);
          const nextIndex = (index2 + 1) % spreadMethodList.length;
          image2.reset({
            spreadMethod: spreadMethodList[nextIndex]
          });
          break;
      }
    }
    this.emit("updateFillEditor", image2);
    this.$commands.executeCommand("setAttribute", `change ${this.state.key} fragment`, this.$context.selection.packByValue({
      [this.state.key]: `${image2}`
    }));
  }
  [POINTERSTART("$el .colorstep") + MOVE("moveColorStep") + END("moveEndColorStep")](e) {
    this.$el.toggleClass("dragging", true);
    this.state.hoverColorStep = null;
    this.initializeData();
    const $colorstep = e.$dt;
    this.$targetIndex = +$colorstep.data("index");
    if (e.altKey) {
      this.removeStep(this.$targetIndex);
      this.state.altKey = true;
      return;
    }
    const result = this.state.imageResult;
    switch (result.image.type) {
      case GradientType.RADIAL:
      case GradientType.LINEAR:
        this.startPoint = this.$viewport.applyVertex(result.startPoint);
        this.endPoint = this.$viewport.applyVertex(result.endPoint);
        const x = +$colorstep.data("x");
        const y = +$colorstep.data("y");
        this.screenXY = [x, y, 0];
        const dist2 = subtract([], this.endPoint, this.startPoint);
        const angle = calculateAngle360(dist2[0], dist2[1]) - 180;
        this.rotateInverse = calculateRotationOriginMat4(-angle, this.startPoint);
        break;
    }
  }
  moveColorStep(dx, dy) {
    if (this.state.altKey)
      return;
    const nextPoint = add$1([], this.screenXY, [dx, dy, 0]);
    const [baseStartPoint, baseEndPoint, baseNextPoint] = vertiesMap([this.startPoint, this.endPoint, nextPoint], this.rotateInverse);
    const result = this.state.imageResult;
    let newDist = 0;
    let baseDist = 0;
    switch (result.image.type) {
      case GradientType.RADIAL:
      case GradientType.LINEAR:
        var [s, e, n] = [baseStartPoint[0], baseEndPoint[0], baseNextPoint[0]];
        var baseDefaultDist = Math.abs(s - e);
        if (n < s) {
          newDist = -1 * Math.abs(n - s) / baseDefaultDist * 100;
        } else if (n > e) {
          newDist = Math.abs(n - s) / baseDefaultDist * 100;
        } else {
          newDist = (n - s) / baseDefaultDist * 100;
        }
        newDist = Math.max(0, Math.min(100, newDist));
        baseDist = baseDefaultDist;
        break;
    }
    const image2 = this.state.imageResult.image;
    image2.colorsteps[this.$targetIndex].setValue(newDist, baseDist);
    const targetColorStep = {
      color: image2.colorsteps[this.$targetIndex].color,
      percent: image2.colorsteps[this.$targetIndex].percent
    };
    const nextImage = this.state.originalResult.image;
    nextImage.colorsteps = image2.colorsteps.map((it) => {
      return it;
    });
    nextImage.sortColorStep();
    this.emit("updateFillEditor", nextImage, targetColorStep);
    this.$commands.executeCommand("setAttribute", `change ${this.state.key} fragment`, this.$context.selection.packByValue({
      [this.state.key]: `${nextImage}`
    }));
  }
  moveEndColorStep(dx, dy) {
    if (this.state.altKey) {
      this.state.altKey = false;
      return;
    }
    if (dx === 0 && dy === 0) {
      const image2 = this.state.imageResult.image;
      image2.colorsteps[this.$targetIndex].toggleTiming();
      const targetColorStep = {
        color: image2.colorsteps[this.$targetIndex].color,
        percent: image2.colorsteps[this.$targetIndex].percent
      };
      this.emit("updateFillEditor", image2, targetColorStep);
      this.$commands.executeCommand("setAttribute", "change background image", this.$context.selection.packByValue({
        [this.state.key]: `${image2}`
      }));
    }
    this.$el.toggleClass("dragging", false);
  }
  updateColorStepStatus(image2, index2) {
    this.initializeData();
    const { color: color2, percent } = image2.colorsteps[index2] || {};
    this.emit("updateFillEditor", image2, { color: color2, percent });
    this.$commands.executeCommand("setAttribute", "change background image", this.$context.selection.packByValue({
      [this.state.key]: `${image2}`
    }));
    this.state.hoverColorStep = null;
  }
  [POINTERSTART("$el .area-line")]() {
    const image2 = this.state.originalResult.image;
    const index2 = image2.insertColorStep(this.state.hoverColorStep.percent);
    this.updateColorStepStatus(image2, index2);
  }
  [POINTEROUT("$el .area-line")]() {
    if (this.state.hoverColorStep) {
      this.state.hoverColorStep = null;
      this.refresh();
    }
  }
  [POINTERMOVE("$el .area-line")](evt) {
    const nextPoint = this.$viewport.applyVertex(this.$viewport.getWorldPosition(evt));
    const image2 = this.state.originalResult.image;
    let baseStartPoint, baseEndPoint, baseNextPoint;
    switch (image2.type) {
      case GradientType.LINEAR:
      case GradientType.RADIAL:
        [baseStartPoint, baseEndPoint, baseNextPoint] = vertiesMap([this.state.startPoint, this.state.endPoint, nextPoint], this.state.rotateInverse);
        var [s, e, n] = [baseStartPoint[0], baseEndPoint[0], baseNextPoint[0]];
        var baseDefaultDist = Math.abs(s - e);
        var newDist;
        if (n < s) {
          newDist = -1 * Math.abs(n - s) / baseDefaultDist * 100;
        } else if (n > e) {
          newDist = Math.abs(n - s) / baseDefaultDist * 100;
        } else {
          newDist = (n - s) / baseDefaultDist * 100;
        }
        this.state.hoverColorStep = image2.pickColorStep(newDist);
        break;
    }
    this.refresh();
  }
}
class FillEditorView extends FillColorstepEditor {
  initState() {
    return {
      key: "",
      value: "",
      isShow: false
    };
  }
  template() {
    return /* @__PURE__ */ createElementJsx("div", {
      class: "elf--fill-editor-view"
    });
  }
  updateData() {
    this.trigger(this.state.onchange, this.state.key, this.state.value);
  }
  refresh() {
    if (this.state.isShow) {
      this.load();
    }
  }
  [SUBSCRIBE(UPDATE_VIEWPORT)]() {
    this.refresh();
  }
  [SUBSCRIBE(UPDATE_CANVAS) + DEBOUNCE(100)]() {
    if (this.$context.selection.current) {
      if (this.$context.selection.hasChangedField("x", "y", "width", "height", "angle", "fill", "stroke")) {
        this.refresh();
      }
    }
  }
  [SUBSCRIBE("showFillEditorView")](params = {}) {
    this.setState({
      key: params.key,
      isShow: true,
      onchange: params.onchange
    });
    this.$el.show();
    this.$context.commands.emit("push.mode.view", "FillEditorView");
  }
  [SUBSCRIBE("hideFillEditorView")]() {
    this.setState({
      key: "",
      isShow: false,
      onchange: null
    });
    this.$el.hide();
    this.$commands.emit("pop.mode.view", "FillEditorView");
  }
  makeTimingLine(timing, width2 = 10, startX = 0, startY = 0) {
    switch (timing.name) {
      case TimingFunction.LINEAR:
        return ``;
      case TimingFunction.STEPS:
        return /* @__PURE__ */ createElementJsx("path", {
          class: "timing",
          d: `
          M${startX + 0} ${startY + width2} 
          L${startX + width2 * 1 / 3} ${startY + width2} 
          L${startX + width2 * 1 / 3} ${startY + width2 * 2 / 3} 
          L${startX + width2 * 2 / 3} ${startY + width2 * 2 / 3} 
          L${startX + width2 * 2 / 3} ${startY + width2 * 1 / 3} 
          L${startX + width2} ${startY + width2 * 1 / 3} 
          L${startX + width2} ${startY + 0}           
        `
        });
      case TimingFunction.PATH:
        return /* @__PURE__ */ createElementJsx("path", {
          class: "timing",
          d: PathParser.fromSVGString(timing.d).scale(width2, width2).flipX().translate(0, width2).translate(startX, startY).d
        });
      default:
        return /* @__PURE__ */ createElementJsx("path", {
          class: "timing",
          d: `
          M${startX + 0} ${startY + width2} 
          C 
            ${startX + timing.x1 * width2} ${startY + width2 - timing.y1 * width2} 
            ${startX + timing.x2 * width2} ${startY + width2 - timing.y2 * width2}  
            ${startX + width2} ${startY + 0}
        `
        });
    }
  }
  makeTimingCircle(colorstepIndex, current, prev) {
    const prevStickScreenXY = prev.stickScreenXYInEnd;
    const stickScreenXY = current.stickScreenXYInStart;
    const { timing, timingCount } = current;
    let pos;
    switch (timing.name) {
      case TimingFunction.LINEAR:
        return ``;
      case TimingFunction.STEPS:
        pos = lerp$1([], prevStickScreenXY, stickScreenXY, 0.5);
        return /* @__PURE__ */ createElementJsx(FragmentInstance, null, /* @__PURE__ */ createElementJsx("circle", {
          class: "step-point",
          "data-colorstep-index": colorstepIndex,
          cx: pos[0],
          cy: pos[1],
          r: 7
        }), /* @__PURE__ */ createElementJsx("text", {
          x: pos[0],
          y: pos[1],
          dy: 4,
          "text-anchor": "middle"
        }, timing.count));
      default:
        pos = lerp$1([], prevStickScreenXY, stickScreenXY, 0.5);
        return /* @__PURE__ */ createElementJsx(FragmentInstance, null, /* @__PURE__ */ createElementJsx("circle", {
          class: "step-point",
          "data-colorstep-index": colorstepIndex,
          cx: pos[0],
          cy: pos[1],
          r: 7
        }), /* @__PURE__ */ createElementJsx("text", {
          x: pos[0],
          y: pos[1],
          dy: 4,
          "text-anchor": "middle"
        }, timingCount));
    }
  }
  makeTimingArea(colorstepIndex, current, prev, size2) {
    const prevStickScreenXY = prev.stickScreenXYInEnd;
    const stickScreenXY = current.stickScreenXYInStart;
    return /* @__PURE__ */ createElementJsx("g", {
      class: "timing-area"
    }, current.timing.name === TimingFunction.LINEAR ? `` : /* @__PURE__ */ createElementJsx("path", {
      class: "timing-path",
      d: `
              M ${prevStickScreenXY[0]} ${prevStickScreenXY[1]}
              L ${stickScreenXY[0]} ${stickScreenXY[1]}
            `
    }), this.makeTimingCircle(colorstepIndex, current, prev, size2));
  }
  makeGradientPoint(colorsteps, startPoint, endPoint, shapePoint, newHoverColorStepPoint) {
    const size2 = TOOL_SIZE$1;
    const dist2 = subtract([], endPoint, startPoint);
    const angle = calculateAngle360(dist2[0], dist2[1]) - 180;
    return /* @__PURE__ */ createElementJsx(FragmentInstance, null, colorsteps.map((it, index2) => {
      if (index2 === 0)
        return "";
      return this.makeTimingArea(index2, it, colorsteps[index2 - 1], TOOL_SIZE$1);
    }), colorsteps.map((it, index2) => {
      return /* @__PURE__ */ createElementJsx("g", {
        transform: `rotate(${angle} ${it.stickScreenXY[0]} ${it.stickScreenXY[1]})`
      }, /* @__PURE__ */ createElementJsx("rect", {
        id: it.id,
        "data-index": index2,
        class: "colorstep",
        x: it.stickScreenXY[0],
        y: it.stickScreenXY[1],
        width: size2,
        height: size2,
        fill: it.color,
        tabIndex: -1,
        "data-x": it.screenXY[0],
        "data-y": it.screenXY[1]
      }), this.makeTimingLine(it.timing, size2, it.stickScreenXY[0], it.stickScreenXY[1]));
    }), /* @__PURE__ */ createElementJsx("circle", {
      class: "point",
      "data-type": "start",
      cx: startPoint[0],
      cy: startPoint[1]
    }), /* @__PURE__ */ createElementJsx("circle", {
      class: "point",
      "data-type": "end",
      cx: endPoint[0],
      cy: endPoint[1]
    }), shapePoint && /* @__PURE__ */ createElementJsx("circle", {
      class: "point",
      "data-type": "shape",
      cx: shapePoint[0],
      cy: shapePoint[1]
    }), newHoverColorStepPoint && /* @__PURE__ */ createElementJsx("circle", {
      class: "hover-colorstep",
      r: "5",
      cx: newHoverColorStepPoint[0],
      cy: newHoverColorStepPoint[1],
      fill: this.state.hoverColorStep.color
    }));
  }
  makeStickPoint(colorsteps, startPoint, endPoint) {
    const size2 = TOOL_SIZE$1;
    const dist2 = subtract([], endPoint, startPoint);
    const angle = calculateAngle360(dist2[0], dist2[1]) - 180;
    const rotateInverse = calculateRotationOriginMat4(-angle, startPoint);
    const rotateInverseInverse = invert([], rotateInverse);
    return colorsteps.map((it) => {
      it.screenXY = this.$viewport.applyVertex(it.pos);
      const [newScreenXY] = vertiesMap([it.screenXY], rotateInverse);
      [it.stickScreenXY, it.stickScreenXYInStart, it.stickScreenXYInEnd] = vertiesMap([
        [newScreenXY[0] - size2 / 2, newScreenXY[1] - size2 * 1.5, 0],
        [
          newScreenXY[0] - size2 / 2,
          newScreenXY[1] - size2 * 1.5 + size2 / 2,
          0
        ],
        [
          newScreenXY[0] + size2 / 2,
          newScreenXY[1] - size2 * 1.5 + size2 / 2,
          0
        ]
      ], rotateInverseInverse);
      return it;
    });
  }
  makeRadialCenterPoint(result) {
    let startPoint, endPoint, shapePoint, colorsteps;
    startPoint = this.$viewport.applyVertex(result.startPoint);
    endPoint = this.$viewport.applyVertex(result.endPoint);
    shapePoint = this.$viewport.applyVertex(result.shapePoint);
    colorsteps = this.makeStickPoint(result.colorsteps, startPoint, endPoint);
    let newHoverColorStepPoint = null;
    if (this.state.hoverColorStep) {
      newHoverColorStepPoint = lerp$1([], startPoint, endPoint, this.state.hoverColorStep.percent / 100);
    }
    return /* @__PURE__ */ createElementJsx("svg", {
      class: "gradient-editor-area"
    }, /* @__PURE__ */ createElementJsx("path", {
      d: `
              M ${startPoint[0]} ${startPoint[1]}
              L ${endPoint[0]} ${endPoint[1]}
          `,
      class: "area-line"
    }), /* @__PURE__ */ createElementJsx("path", {
      d: `
              M ${startPoint[0]} ${startPoint[1]}
              L ${endPoint[0]} ${endPoint[1]}
          `,
      class: "start-end-line"
    }), /* @__PURE__ */ createElementJsx("path", {
      d: `
              M ${startPoint[0]} ${startPoint[1]}
              L ${shapePoint[0]} ${shapePoint[1]}
          `,
      class: "normal-line"
    }), this.makeGradientPoint(colorsteps, startPoint, endPoint, shapePoint, newHoverColorStepPoint));
  }
  makeLinearCenterPoint(result) {
    let startPoint, endPoint, colorsteps;
    startPoint = this.$viewport.applyVertex(result.startPoint);
    endPoint = this.$viewport.applyVertex(result.endPoint);
    colorsteps = this.makeStickPoint(result.colorsteps, startPoint, endPoint);
    let newHoverColorStepPoint = null;
    if (this.state.hoverColorStep) {
      newHoverColorStepPoint = lerp$1([], startPoint, endPoint, this.state.hoverColorStep.percent / 100);
    }
    return /* @__PURE__ */ createElementJsx("svg", {
      class: "gradient-editor-area"
    }, /* @__PURE__ */ createElementJsx("path", {
      d: `
            M ${startPoint[0]} ${startPoint[1]}
            L ${endPoint[0]} ${endPoint[1]}
          `,
      class: "area-line"
    }), /* @__PURE__ */ createElementJsx("path", {
      d: `
              M ${startPoint[0]} ${startPoint[1]}
              L ${endPoint[0]} ${endPoint[1]}
          `,
      class: "start-end-line"
    }), this.makeGradientPoint(colorsteps, startPoint, endPoint, null, newHoverColorStepPoint));
  }
  makeCenterPoint(result) {
    const { image: image2 } = result;
    switch (image2.type) {
      case GradientType.LINEAR:
        return this.makeLinearCenterPoint(result);
      case GradientType.RADIAL:
        return this.makeRadialCenterPoint(result);
    }
    return "";
  }
  [LOAD("$el") + DOMDIFF]() {
    if (!this.state.isShow)
      return "";
    const current = this.$context.selection.current;
    if (!current)
      return "";
    const result = current.createFragmentMatrix(this.state.key);
    this.state.result = result;
    this.state.originalResult = current.createFragmentMatrix(this.state.key);
    const image2 = result.image;
    let angle, dist2;
    switch (image2.type) {
      case GradientType.LINEAR:
        this.state.startPoint = this.$viewport.applyVertex(result.startPoint);
        this.state.endPoint = this.$viewport.applyVertex(result.endPoint);
        dist2 = subtract([], this.state.endPoint, this.state.startPoint);
        angle = calculateAngle360(dist2[0], dist2[1]) - 180;
        this.state.rotateInverse = calculateRotationOriginMat4(-angle, this.state.startPoint);
        break;
      case GradientType.RADIAL:
        this.state.startPoint = this.$viewport.applyVertex(result.startPoint);
        this.state.endPoint = this.$viewport.applyVertex(result.endPoint);
        this.state.shapePoint = this.$viewport.applyVertex(result.shapePoint);
        dist2 = subtract([], this.state.endPoint, this.state.startPoint);
        angle = calculateAngle360(dist2[0], dist2[1]) - 180;
        this.state.rotateInverse = calculateRotationOriginMat4(-angle, this.state.startPoint);
        break;
    }
    return /* @__PURE__ */ createElementJsx("div", null, this.makeCenterPoint(result));
  }
}
function fillEditorView(editor) {
  editor.registerUI("canvas.view", {
    FillEditorView
  });
}
var FilterProperty$1 = "";
const filter_list = [
  "blur",
  "grayscale",
  "hue-rotate",
  "invert",
  "brightness",
  "contrast",
  "drop-shadow",
  "opacity",
  "saturate",
  "sepia",
  "svg"
];
class FilterProperty extends BaseProperty {
  getTitle() {
    return this.$i18n("filter.property.title");
  }
  hasKeyframe() {
    return true;
  }
  isFirstShow() {
    return true;
  }
  afterRender() {
    this.show();
  }
  getKeyframeProperty() {
    return "filter";
  }
  getTitleClassName() {
    return "filter";
  }
  getBodyClassName() {
    return "no-padding";
  }
  getBody() {
    return `<div class='full filter-property' ref='$body'></div>`;
  }
  getTools() {
    return `
      <select class='filter-select' ref="$filterSelect">      
      </select>
      <button type="button" ref="$add" title="add Filter">${iconUse("add")}</button>
    `;
  }
  [CLICK("$add")]() {
    var filterType = this.refs.$filterSelect.value;
    this.children.$filterEditor.trigger("add", filterType);
  }
  [LOAD("$filterSelect")]() {
    var list2 = filter_list.map((it) => {
      return { title: this.$i18n(`filter.property.${it}`), value: it };
    });
    var svgFilterList = this.getSVGFilterList();
    var totalList = [];
    if (svgFilterList.length) {
      totalList = [...list2, { title: "-------", value: "" }, ...svgFilterList];
    } else {
      totalList = [...list2];
    }
    return totalList.map((it) => {
      var { title: title2, value } = it;
      return `<option value='${value}'>${title2}</option>`;
    });
  }
  getSVGFilterList() {
    var current = this.$context.selection.currentProject;
    var arr = [];
    if (current) {
      arr = current.svgfilters.map((it) => {
        var id = it.id;
        return {
          title: `svg - #${id}`,
          value: id
        };
      });
    }
    return arr;
  }
  [LOAD("$body") + DOMDIFF]() {
    var current = this.$context.selection.current || {};
    var value = current.filter;
    return createComponent("FilterEditor", {
      ref: "$filterEditor",
      key: "filter",
      value,
      onchange: "changeFilterEditor"
    });
  }
  [SUBSCRIBE_SELF("changeFilterEditor")](key, filter2) {
    this.$commands.executeCommand("setAttribute", "change filter", this.$context.selection.packByValue({
      [key]: filter2
    }));
  }
  get editableProperty() {
    return "filter";
  }
  [SUBSCRIBE(REFRESH_SELECTION) + IF("checkShow") + DEBOUNCE(100)]() {
    this.refresh();
  }
  [SUBSCRIBE("refreshSVGArea") + DEBOUNCE(100)]() {
    this.load("$filterSelect");
  }
}
function filter(editor) {
  editor.registerUI("inspector.tab.style", {
    FilterProperty
  });
}
function font(editor) {
  editor.registerUI("inspector.tab.style", {
    FontProperty: ObjectProperty.create({
      title: editor.$i18n("font.property.title"),
      editableProperty: "font",
      preventUpdate: true
    })
  });
  editor.registerInspector("font", (current) => {
    return [
      {
        key: "font-family",
        editor: "SelectEditor",
        editorOptions: {
          compact: true,
          label: "font_download",
          options: [
            "",
            "Arial",
            "Arial Black",
            "Times New Roman",
            "Times",
            "Courier New",
            "Courier",
            "Verdana",
            "Georgia",
            "Palatino",
            "Garamond",
            "Bookman",
            "Tahoma",
            "Trebuchet MS",
            "Impact",
            "Comic Sans MS",
            "serif",
            "sans-serif",
            "monospace",
            "cursive",
            "fantasy",
            "system-ui"
          ]
        },
        defaultValue: current.fontFamily || ""
      },
      {
        type: "column",
        size: [1, 1],
        gap: 10,
        columns: [
          {
            key: "font-size",
            editor: "NumberInputEditor",
            editorOptions: {
              label: "format_size",
              compact: true,
              min: 8,
              max: 1e3,
              step: 1
            },
            defaultValue: Length.parse(current.fontSize).value,
            convert: (key, value) => Length.px(value)
          },
          {
            key: "padding",
            editor: "NumberInputEditor",
            editorOptions: {
              label: "padding",
              compact: true,
              min: 8,
              max: 1e3,
              step: 1
            },
            defaultValue: Length.parse(current.paddingTop).value,
            convert: (key, value) => Length.px(value)
          }
        ]
      },
      {
        type: "column",
        size: [1, 1],
        columns: [
          {
            key: "color",
            editor: "ColorViewEditor",
            editorOptions: {
              compact: true
            },
            defaultValue: current.color || "#000"
          },
          {
            key: "font-weight",
            editor: "NumberInputEditor",
            editorOptions: {
              label: "format_bold",
              compact: true,
              min: 100,
              max: 900,
              step: 100
            },
            defaultValue: current.fontWeight || 400
          }
        ]
      },
      {
        type: "column",
        size: [1, 1, 1],
        gap: 10,
        columns: [
          {
            key: "text-indent",
            editor: "NumberInputEditor",
            editorOptions: {
              label: "format_indent",
              min: -100,
              max: 100,
              step: 1,
              compact: true
            },
            defaultValue: Length.parse(current.textIndent).value,
            convert: (key, value) => Length.px(value)
          },
          {
            key: "line-height",
            editor: "NumberInputEditor",
            editorOptions: {
              label: "format_line_spacing",
              min: 0,
              max: 10,
              step: 0.01,
              compact: true
            },
            defaultValue: current.lineHeight || 1.2
          },
          {
            key: "letter-spacing",
            editor: "NumberInputEditor",
            editorOptions: {
              label: "space",
              min: -100,
              max: 100,
              step: 1,
              compact: true
            },
            defaultValue: Length.parse(current.letterSpacing).value,
            convert: (key, value) => Length.px(value)
          }
        ]
      }
    ];
  });
}
var FillEditor$1 = "";
class FillEditor extends EditorElement {
  initState() {
    var _a;
    const image2 = SVGFill.parseImage(this.props.value || "transparent") || SVGStaticGradient.create();
    const id = (_a = image2.colorsteps[this.props.index]) == null ? void 0 : _a.id;
    this.$context.selection.selectColorStep(id);
    if (id) {
      this.currentStep = image2.colorsteps.find((it) => this.$context.selection.isSelectedColorStep(it.id));
    }
    return {
      cachedRect: null,
      index: +(this.props.index || 0),
      value: this.props.value,
      image: image2
    };
  }
  setValue(value) {
    this.setState({
      cachedRect: null,
      image: SVGFill.parseImage(value)
    }, false);
    this.refresh();
  }
  template() {
    return `
        <div class='elf--fill-editor'>
            <div class='gradient-steps' data-editor='gradient'>
                <div class="hue-container" ref="$back"></div>            
                <div class="hue" ref="$steps">
                    <div class='step-list' ref="$stepList" ></div>
                </div>
            </div>               
            <div class='sub-editor' ref='$subEditor'> 
                <div data-editor='patternUnits'>
                  ${createComponent("SelectEditor", {
      label: "Pattern",
      ref: "$patternUnits",
      options: ["userSpaceOnUse"],
      key: "patternUnits",
      onchange: "changeKeyValue"
    })}
                </div>                  
                                                                                                                                
            </div>            
        </div>
      `;
  }
  getImageFieldValue(image2, field) {
    var value = image2[field];
    if (isUndefined(value)) {
      switch (field) {
        case "cx":
        case "cy":
        case "r":
        case "fx":
        case "fy":
          return "50%";
        case "x1":
        case "y1":
        case "y2":
        case "fr":
        case "imageX":
        case "imageY":
          return "0%";
        case "x2":
        case "patternWidth":
        case "patternHeight":
        case "imageWidth":
        case "imageHeight":
          return "100%";
      }
    }
    return value;
  }
  [CHANGE("$file")](e) {
    var project2 = this.$context.selection.currentProject;
    if (project2) {
      [...e.target.files].forEach((item) => {
        this.$commands.emit("updateImageAssetItem", item, (local) => {
          this.trigger("setImageUrl", local);
        });
      });
    }
  }
  refreshFieldValue() {
    this.children.$cx.setValue(this.state.image.cx);
    this.children.$cy.setValue(this.state.image.cy);
    this.children.$r.setValue(this.state.image.r);
    this.children.$fx.setValue(this.state.image.fx);
    this.children.$fy.setValue(this.state.image.fy);
    this.children.$fr.setValue(this.state.image.fr);
    this.children.$patternUnits.setValue(this.state.image.patternUnits);
    this.children.$patternWidth.setValue(this.state.image.patternWidth);
    this.children.$patternHeight.setValue(this.state.image.patternHeight);
    this.children.$imageX.setValue(this.state.image.imageX);
    this.children.$imageY.setValue(this.state.image.imageY);
    this.children.$imageWidth.setValue(this.state.image.imageWidth);
    this.children.$imagenHeight.setValue(this.state.image.imageHeight);
  }
  getFieldValue(field) {
    return Length.parse(this.getImageFieldValue(this.state.image, field));
  }
  getRectRate(rect2, x, y) {
    var { width: width2, height: height2, x: rx, y: ry } = rect2;
    if (rx > x) {
      x = rx;
    } else if (rx + width2 < x) {
      x = rx + width2;
    }
    if (ry > y) {
      y = ry;
    } else if (ry + height2 < y) {
      y = ry + height2;
    }
    var left2 = Length.makePercent(x - rx, width2);
    var top2 = Length.makePercent(y - ry, height2);
    return { left: left2, top: top2 };
  }
  [SUBSCRIBE_SELF("changeTabType")](type) {
    var _a, _b;
    const oldType = (_a = this.state.image) == null ? void 0 : _a.type;
    const colorsteps = ((_b = this.state.image) == null ? void 0 : _b.colorsteps) || [];
    if (colorsteps.length === 1) {
      colorsteps.push(colorsteps[0]);
    }
    if (oldType === GradientType.STATIC) {
      if (colorsteps.length === 0) {
        colorsteps.push(colorsteps[0], colorsteps[0]);
      } else if (colorsteps.length === 1) {
        colorsteps.push(colorsteps[0]);
      }
    }
    var url = type === "image-resource" ? this.state.image.url : this.state.url;
    this.state.image = SVGFill.changeImageType({
      type,
      url,
      colorsteps,
      spreadMethod: this.state.image.spreadMethod
    });
    this.refresh();
    this.updateData();
  }
  [SUBSCRIBE_SELF("changeKeyValue")](key, value) {
    this.state.image.reset({
      [key]: value
    });
    this.updateData();
  }
  [SUBSCRIBE("changeColorStepOffset")](key, value) {
    if (this.currentStep) {
      this.currentStep.percent = value.value;
      this.state.image.sortColorStep();
      this.refresh();
      this.updateData();
    }
  }
  [CLICK("$back")](e) {
    var rect2 = this.refs.$stepList.rect();
    var minX = rect2.x;
    var maxX = rect2.right;
    var x = e.xy.x;
    if (x < minX)
      x = minX;
    else if (x > maxX)
      x = maxX;
    var percent = (x - minX) / rect2.width * 100;
    this.state.image.insertColorStep(percent);
    this.state.image.sortColorStep();
    this.refresh();
    this.updateData();
  }
  [BIND("$el")]() {
    var type = this.state.image.type;
    if (type === "url") {
      type = "image-resource";
    }
    return {
      "data-selected-editor": type
    };
  }
  [BIND("$stepList")]() {
    return {
      style: {
        "background-image": this.getLinearGradient()
      }
    };
  }
  [LOAD("$stepList")]() {
    var colorsteps = this.state.image.colorsteps || [];
    return colorsteps.map((it) => {
      var selected = this.$context.selection.isSelectedColorStep(it.id) ? "selected" : "";
      return `
      <div class='step ${selected}' data-id='${it.id}' data-cut='${it.cut}' tabindex="-1" style='left: ${it.toLength()};'>
        <div class='color-view' style="background-color: ${it.color}">
          <span>${Math.floor(it.percent * 10) / 10}</span>
        </div>
        <div class='arrow'></div>
      </div>`;
    });
  }
  removeStep(id) {
    this.state.image.removeColorStep(id);
    this.refresh();
    this.updateData();
  }
  selectStep(id) {
    this.state.id = id;
    this.$context.selection.selectColorStep(id);
    if (this.state.image.colorsteps) {
      this.currentStep = this.state.image.colorsteps.find((it) => this.$context.selection.isSelectedColorStep(it.id));
      this.parent.trigger("selectColorStep", this.currentStep.color);
    }
    this.refresh();
  }
  [KEYUP("$el .step")](e) {
    const id = e.$dt.data("id");
    switch (e.code) {
      case "Delete":
      case "Backspace":
        this.removeStep(id);
        break;
      case "BracketRight":
        this.sortToRight(id);
        break;
      case "BracketLeft":
        this.sortToLeft(id);
        break;
      case "Equal":
        this.appendColorStep(id);
        break;
      case "Minus":
        this.prependColorStep(id);
        break;
    }
  }
  sortToRight(id) {
    this.state.image.sortToRight();
    this.refresh();
    this.updateData();
    this.doFocus(id);
  }
  sortToLeft(id) {
    this.state.image.sortToLeft();
    this.refresh();
    this.updateData();
    this.doFocus(id);
  }
  appendColorStep(id) {
    const currentIndex = this.state.image.colorsteps.findIndex((it) => it.id === id);
    const nextIndex = currentIndex + 1;
    const currentColorStep = this.state.image.colorsteps[currentIndex];
    const nextColorStep = this.state.image.colorsteps[nextIndex];
    if (!nextColorStep) {
      if (currentColorStep.percent !== 100) {
        this.state.image.insertColorStep(currentColorStep.percent + (100 - currentColorStep.percent) / 2);
      }
    } else {
      this.state.image.insertColorStep(currentColorStep.percent + (nextColorStep.percent - currentColorStep.percent) / 2);
    }
    this.refresh();
    this.updateData();
    this.doFocus(id);
  }
  doFocus(id) {
    this.nextTick(() => {
      this.refs.$stepList.$(".step[data-id='" + id + "']").focus();
    }, 100);
  }
  prependColorStep(id) {
    const currentIndex = this.state.image.colorsteps.findIndex((it) => it.id === id);
    const prevIndex = currentIndex - 1;
    const currentColorStep = this.state.image.colorsteps[currentIndex];
    const prevColorStep = this.state.image.colorsteps[prevIndex];
    if (!prevColorStep) {
      if (currentColorStep.percent !== 0) {
        this.state.image.insertColorStep(currentColorStep.percent);
      }
    } else {
      this.state.image.insertColorStep(prevColorStep.percent + (currentColorStep.percent - prevColorStep.percent) / 2);
    }
    this.refresh();
    this.updateData();
    this.doFocus(id);
  }
  [POINTERSTART("$stepList .step") + MOVE() + END()](e) {
    var id = e.$dt.attr("data-id");
    if (e.altKey) {
      this.removeStep(id);
      return false;
    } else {
      e.$dt.focus();
      this.isSelectedColorStep = this.$context.selection.isSelectedColorStep(id);
      this.selectStep(id);
      this.startXY = e.xy;
      this.cachedStepListRect = this.refs.$stepList.rect();
    }
  }
  getStepListRect() {
    return this.cachedStepListRect;
  }
  move(dx) {
    var rect2 = this.getStepListRect();
    var minX = rect2.x;
    var maxX = rect2.right;
    var x = this.startXY.x + dx;
    if (x < minX)
      x = minX;
    else if (x > maxX)
      x = maxX;
    var percent = (x - minX) / rect2.width * 100;
    if (this.$config.get("bodyEvent").shiftKey) {
      percent = Math.floor(percent);
    }
    this.currentStep.percent = percent;
    this.state.image.sortColorStep();
    this.refresh();
    this.updateData();
  }
  end(dx, dy) {
    if (dx === 0 && dy === 0) {
      if (this.isSelectedColorStep) {
        if (this.currentStep) {
          this.currentStep.cut = !this.currentStep.cut;
          this.refresh();
          this.updateData();
        }
      }
    }
    this.doFocus(this.state.id);
  }
  getLinearGradient() {
    var { image: image2 } = this.state;
    return `linear-gradient(to right, ${Gradient.toCSSColorString(image2.colorsteps)})`;
  }
  [SUBSCRIBE_SELF("setColorStepColor")](color2) {
    if (this.state.image.type === "static-gradient") {
      this.state.image.setColor(color2);
      this.refresh();
      this.updateData();
    } else {
      if (this.currentStep) {
        this.currentStep.color = color2;
        this.refresh();
        this.updateData();
      }
    }
  }
  [SUBSCRIBE("setImageUrl")](url, datauri) {
    if (this.state.image) {
      this.state.url = url;
      this.state.image.reset({ url, datauri });
      this.refresh();
      this.updateData();
    }
  }
  updateData(data = {}) {
    this.setState(data, false);
    this.parent.trigger(this.props.onchange, this.state.image.toString());
  }
}
var GradientPickerPopup$1 = "";
class GradientPickerPopup extends BasePopup {
  getTitle() {
    var _a;
    return createComponent("SelectEditor", {
      ref: "$select",
      value: ((_a = this.state.image) == null ? void 0 : _a.type) || GradientType.STATIC,
      onchange: "changeTabType",
      options: [
        {
          value: GradientType.STATIC,
          text: "Static"
        },
        {
          value: GradientType.LINEAR,
          text: "Linear Gradient"
        },
        {
          value: GradientType.RADIAL,
          text: "Radial Gradient"
        },
        {
          value: GradientType.CONIC,
          text: "Conic Gradient"
        },
        {
          value: GradientType.REPEATING_LINEAR,
          text: "Repeating Linear Gradient"
        },
        {
          value: GradientType.REPEATING_RADIAL,
          text: "Repeating Radial Gradient"
        },
        {
          value: GradientType.REPEATING_CONIC,
          text: "Repeating Conic Gradient"
        },
        {
          value: GradientType.URL,
          text: "Image"
        }
      ]
    });
  }
  initialize() {
    super.initialize();
    this.selectedTab = "static-gradient";
  }
  getClassName() {
    return "fill-picker-popup";
  }
  getBody() {
    var _a, _b;
    return `
      <div class="elf--gradient-picker-popup" ref='$body' data-selected-editor='${(_a = this.state.image) == null ? void 0 : _a.type}'>
        <div class='box'>
          <div ref='$gradientEditor'></div>
        </div>
        <div class='box'>
          <div class='colorpicker'>
            ${createComponent("EmbedColorPicker", {
      ref: "$color",
      onchange: "changeColor"
    })}
          </div>
          <div class='assetpicker'>
            ${createComponent("ImageSelectEditor", {
      ref: "$image",
      key: "image",
      value: (_b = this.state.image) == null ? void 0 : _b.url,
      onchange: "changeImageUrl"
    })}
            ${createComponent("ImageAssetPicker", {
      ref: "$asset",
      onchange: "changeImageUrl"
    })}
          </div>
        </div>
      </div>
     
    `;
  }
  getColorString() {
    var value = "";
    if (this.state.image instanceof Gradient) {
      value = this.state.image.getColorString();
    }
    return value;
  }
  getCurrentColor() {
    return this.state.image.colorsteps[this.state.selectColorStepIndex || 0].color;
  }
  [BIND("$body")]() {
    var _a;
    return {
      "data-selected-editor": (_a = this.state.image) == null ? void 0 : _a.type
    };
  }
  [LOAD("$gradientEditor") + DOMDIFF]() {
    var _a;
    if (((_a = this.state.image) == null ? void 0 : _a.type) === GradientType.URL) {
      return "";
    }
    return createComponent("GradientEditor", {
      ref: "$g",
      value: `${this.state.image ? this.state.image.toString() : ""}`,
      index: this.state.selectColorStepIndex,
      onchange: "changeGradientEditor"
    });
  }
  [SUBSCRIBE("updateGradientEditor")](data, targetColorStep) {
    this.state.image = isString(data) ? BackgroundImage.parseImage(data) : data;
    this.state.selectColorStepIndex = this.state.image.colorsteps.findIndex((it) => it.color === targetColorStep.color && it.percent === targetColorStep.percent);
    this.children.$color.setValue(targetColorStep.color);
    this.refresh();
  }
  [SUBSCRIBE_SELF("changeGradientEditor")](data) {
    this.state.image = isString(data) ? BackgroundImage.parseImage(data) : data;
    this.updateTitle();
    this.updateData();
  }
  [SUBSCRIBE_SELF("changeTabType")](key, type) {
    this.children.$g.trigger("changeTabType", type);
    this.refs.$body.attr("data-selected-editor", type);
  }
  [SUBSCRIBE_SELF("changeColor")](color2) {
    this.children.$g.trigger("setColorStepColor", color2);
  }
  [SUBSCRIBE_SELF("changeImageUrl")](key, url) {
    if (this.state.image) {
      this.state.image.reset({
        url
      });
      this.trigger("changeGradientEditor", this.state.image);
    }
  }
  updateTitle() {
    this.children.$select.setValue(this.state.image.type);
  }
  [SUBSCRIBE("showGradientPickerPopup")](data, params, rect2) {
    data.changeEvent = data.changeEvent || "changeFillPopup";
    data.image = data.gradient;
    data.params = params;
    this.showByRect(this.makeRect(248, 560, rect2));
    this.setState(data);
    this.updateTitle();
    this.emit("showGradientEditorView", {
      index: data.index
    });
  }
  [SUBSCRIBE("hideGradientickerPopup")]() {
    this.hide();
    this.emit("hideGradientEditorView");
  }
  onClose() {
    this.emit("hideGradientEditorView");
  }
  [SUBSCRIBE("selectColorStep")](color2) {
    this.children.$color.setValue(color2);
  }
  [SUBSCRIBE("changeColorStep")](data = {}) {
    this.state.image.reset(__spreadValues({}, data));
    this.updateData();
  }
  load(...args2) {
    if (this.$el.isShow()) {
      super.load(...args2);
    }
  }
  getValue() {
    return `${this.state.image}`;
  }
  updateData() {
    this.state.instance.trigger(this.state.changeEvent, this.getValue(), this.state.params);
  }
}
class FillPickerPopup extends BasePopup {
  getTitle() {
    var _a;
    return createComponent("SelectEditor", {
      ref: "$select",
      value: ((_a = this.state.image) == null ? void 0 : _a.type) || GradientType.STATIC,
      onchange: "changeTabType",
      options: [
        {
          value: GradientType.STATIC,
          text: "Static"
        },
        {
          value: GradientType.LINEAR,
          text: "Linear Gradient"
        },
        {
          value: GradientType.RADIAL,
          text: "Radial Gradient"
        },
        {
          value: GradientType.URL,
          text: "Image"
        }
      ]
    });
  }
  initState() {
    return {
      image: SVGStaticGradient.create()
    };
  }
  initialize() {
    super.initialize();
    this.selectedTab = "static-gradient";
  }
  getClassName() {
    return "fill-picker-popup";
  }
  getBody() {
    var _a, _b;
    return `
      <div class="elf--gradient-picker-popup" ref='$body' data-selected-editor='${(_a = this.state.image) == null ? void 0 : _a.type}'>
        <div class='box'>
          <div ref='$gradientEditor'></div>
        </div>
        <div class='box'>
          <div class='colorpicker'>
            ${createComponent("EmbedColorPicker", {
      ref: "$color",
      onchange: "changeColor"
    })}    
          </div>
          <div class='assetpicker'>
            ${createComponent("ImageSelectEditor", {
      ref: "$image",
      key: "image",
      value: (_b = this.state.image) == null ? void 0 : _b.url,
      onchange: "changeImageUrl"
    })}
            ${createComponent("ImageAssetPicker", {
      ref: "$asset",
      onchange: "changeImageUrl"
    })}
          </div>
        </div>
      </div>
     
    `;
  }
  [BIND("$body")]() {
    var _a;
    return {
      "data-selected-editor": (_a = this.state.image) == null ? void 0 : _a.type
    };
  }
  getColorString() {
    var value = "";
    if (this.state.image instanceof Gradient) {
      value = this.state.image.getColorString();
    }
    return value;
  }
  getCurrentColor() {
    return this.state.image.colorsteps[this.state.selectColorStepIndex || 0].color;
  }
  [LOAD("$gradientEditor")]() {
    var _a;
    if (((_a = this.state.image) == null ? void 0 : _a.type) === GradientType.URL) {
      return "";
    }
    return createComponent("FillEditor", {
      ref: "$g",
      value: `${this.state.image}`,
      index: this.state.selectColorStepIndex,
      onchange: "changeFillEditor"
    });
  }
  [SUBSCRIBE("updateFillEditor")](data, targetColorStep = void 0) {
    this.state.image = isString(data) ? SVGFill.parseImage(data) : data;
    if (targetColorStep) {
      this.state.selectColorStepIndex = this.state.image.colorsteps.findIndex((it) => it.color === targetColorStep.color && it.percent === targetColorStep.percent);
      this.children.$color.setValue(targetColorStep.color);
    }
    this.refresh();
  }
  [SUBSCRIBE_SELF("changeFillEditor")](data) {
    this.state.image = isString(data) ? SVGFill.parseImage(data) : data;
    this.updateTitle();
    this.updateData();
  }
  [SUBSCRIBE_SELF("changeTabType")](key, type) {
    this.children.$g.trigger("changeTabType", type);
    this.refs.$body.attr("data-selected-editor", type);
  }
  [SUBSCRIBE_SELF("changeColor")](color2) {
    this.children.$g.trigger("setColorStepColor", color2);
  }
  [SUBSCRIBE_SELF("changeImageUrl")](url) {
    if (this.state.image) {
      this.state.image.reset({
        url
      });
      this.trigger("changeFillEditor", this.state.image);
    }
  }
  updateTitle() {
    this.children.$select.setValue(this.state.image.type);
  }
  [SUBSCRIBE("showFillPickerPopup")](data, params, rect2) {
    data.changeEvent = data.changeEvent || "changeFillPopup";
    data.params = params;
    this.showByRect(this.makeRect(248, 560, rect2));
    this.setState(data);
    this.updateTitle();
    if (data.image.isGradient()) {
      this.trigger("selectColorStep", data.image.colorsteps[0].color);
    }
    this.emit("showFillEditorView", {
      key: data.key
    });
  }
  [SUBSCRIBE("hideFillPickerPopup")]() {
    this.hide();
    this.emit("hideFillEditorView");
  }
  onClose() {
    this.emit("hideFillEditorView");
  }
  [SUBSCRIBE("selectColorStep")](color2) {
    this.children.$color.setValue(color2);
  }
  [SUBSCRIBE("changeColorStep")](data = {}) {
    this.state.image.reset(__spreadValues({}, data));
    this.updateData();
  }
  load(...args2) {
    if (this.$el.isShow()) {
      super.load(...args2);
    }
  }
  getValue() {
    return `${this.state.image}`;
  }
  updateData() {
    this.state.instance.trigger(this.state.changeEvent, this.getValue(), this.state.params);
  }
}
var FillSingleEditor$1 = "";
class FillSingleEditor extends EditorElement {
  initState() {
    return {
      index: this.props.index,
      label: this.props.label,
      simple: this.props.simple === "true" ? true : false,
      image: SVGFill.parseImage(this.props.value || this.props.image || "transparent")
    };
  }
  get fillId() {
    return this.id + "fill";
  }
  updateData(opt = {}) {
    this.setState(opt, false);
    this.modifyValue(opt);
  }
  modifyValue() {
    this.parent.trigger(this.props.onchange, this.props.key, this.getValue(), this.state.index);
  }
  getValue() {
    return this.state.image.toString();
  }
  setValue(value) {
    this.setState({
      image: SVGFill.parseImage(value)
    });
  }
  [BIND("$fillView")]() {
    var image2 = this.state.image;
    if (!image2)
      return { innerHTML: "" };
    return {
      innerHTML: image2.toSVGString(this.fillId, {
        width: 20,
        height: 20,
        sizeType: "percent"
      })
    };
  }
  [BIND("$fillColor")]() {
    var image2 = this.state.image;
    if (!image2)
      return { fill: "transparent" };
    return {
      fill: image2.toFillValue(this.fillId)
    };
  }
  [BIND("$colors")]() {
    var image2 = this.state.image;
    if (!image2)
      return { fill: "transparent" };
    var colors2 = image2.type != "url" ? `${image2.colorsteps[0].color}` : "transparent";
    if ([GradientType.LINEAR, GradientType.RADIAL].includes(image2.type)) {
      colors2 = image2.colorsteps.map((it) => {
        return `<span class='color' style='background-color: ${it.color}' title='${it.color}'></span>`;
      }).join("");
    }
    return {
      innerHTML: `<div> ${colors2} </div>`
    };
  }
  template() {
    var { label, simple } = this.state;
    var hasLabel = label ? "has-label" : "";
    return `
            <div class='elf--fill-single-editor ${hasLabel}'>
                ${label ? `<label>${label}</label>` : ""}            
                <div class="area">
                    <div class='preview' ref='$preview'>
                        <div class='mini-view'>

                            <svg class='color-view' ref='$miniView'>
                                <defs ref='$fillView'></defs>
                                <rect x="0" y="0" width="100%" height="100%" ref='$fillColor' fill='url(#${this.fillId})' />
                            </svg>
                        </div>
                    </div>
                    <div class='colors ${simple ? "simple" : ""}' ref='$colors'></div>
                </div>
            </div>
        `;
  }
  [CLICK()]() {
    this.viewGradientPopup();
  }
  viewGradientPopup() {
    this.emit("showFillPickerPopup", {
      instance: this,
      key: this.props.key,
      changeEvent: "changeFillSingle",
      image: this.state.image
    }, null, this.$el.rect());
  }
  [SUBSCRIBE("changeFillSingle")](image2) {
    this.updateData({ image: SVGFill.parseImage(image2) });
    this.refresh();
  }
}
var GradientSingleEditor$1 = "";
class GradientSingleEditor extends EditorElement {
  initState() {
    return {
      index: this.props.index,
      image: this.props.image,
      color: "rgba(0, 0, 0, 1)"
    };
  }
  updateData(opt = {}) {
    this.setState(opt, false);
    this.modifyValue(opt);
  }
  modifyValue(value) {
    this.parent.trigger(this.props.onchange, this.props.key, value, this.state.index);
  }
  setValue(obj2) {
    this.setState(__spreadValues({}, obj2));
  }
  [BIND("$miniView")]() {
    const project2 = this.$context.selection.currentProject;
    let image2;
    if (this.state.image.type === GradientType.URL) {
      const imageUrl = project2.getImageValueById(this.state.image.url);
      image2 = this.state.image.toString(imageUrl);
    } else {
      image2 = this.state.image.toCSSString();
    }
    return {
      style: {
        "background-image": image2
      }
    };
  }
  template() {
    return `
            <div class='elf--gradient-single-editor'>
                <div class='preview' ref='$preview'>
                    <div class='mini-view'>
                        <div class='color-view' ref='$miniView'></div>
                    </div>
                </div>
            </div>
        `;
  }
  [CLICK("$preview")]() {
    this.viewGradientPopup();
  }
  viewGradientPopup() {
    this.emit("showGradientPickerPopup", {
      instance: this,
      changeEvent: "changeGradientSingle",
      index: this.state.index,
      gradient: this.state.image
    }, null, this.$el.rect());
  }
  [SUBSCRIBE("changeGradientSingle")](image2) {
    var _a;
    image2 = BackgroundImage.parseImage(image2);
    const currentImage = (_a = this.$context.selection.current.getBackgroundImage(this.state.index)) == null ? void 0 : _a.image;
    switch (currentImage.type) {
      case GradientType.RADIAL:
      case GradientType.REPEATING_RADIAL:
        image2.reset({
          radialPosition: currentImage.radialPosition || ["50%", "50%"],
          radialType: currentImage.radialType || RadialGradientType.CIRCLE
        });
        break;
      case GradientType.CONIC:
      case GradientType.REPEATING_CONIC:
        image2.reset({
          angle: currentImage.angle || 0,
          radialPosition: currentImage.radialPosition || ["50%", "50%"]
        });
        break;
      case GradientType.LINEAR:
      case GradientType.REPEATING_LINEAR:
      case GradientType.STATIC:
        image2.reset({
          angle: currentImage.angle || 0
        });
        break;
    }
    this.updateData({ image: image2 });
    this.refresh();
  }
}
function gradient(editor) {
  editor.registerElement({
    FillSingleEditor,
    FillEditor,
    GradientSingleEditor
  });
  editor.registerAlias({
    "fill-single": "FillSingleEditor",
    fill: "FillEditor",
    "gradient-single": "GradientSingleEditor"
  });
  editor.registerUI("popup", {
    FillPickerPopup,
    GradientPickerPopup
  });
}
var conic = {
  title: "Conic",
  key: "conic",
  execute: function(count = 42) {
    return repeat(count).map(() => {
      var x = randomNumber(45, 55);
      var y = randomNumber(45, 55);
      var angle = randomNumber(0, 360);
      return {
        gradient: `conic-gradient(from ${angle}deg at ${x}% ${y}%, ${ColorStep.createColorStep(2, 360, "deg")})`
      };
    });
  }
};
const angle_list$2 = ["0deg", "45deg", "90deg"];
var linear = {
  title: "Linear",
  key: "linear",
  execute: function(count = 42) {
    return repeat(count).map(() => {
      return {
        gradient: `linear-gradient(${randomItem(...angle_list$2)}, ${ColorStep.createColorStep(2)})`
      };
    });
  }
};
var radial = {
  title: "Radial",
  key: "radial",
  execute: function(count = 42) {
    return repeat(count).map(() => {
      var shape2 = "circle";
      return {
        gradient: `radial-gradient(${shape2}, ${ColorStep.createColorStep(2)})`
      };
    });
  }
};
var randomConic = {
  title: "Random Conic",
  key: "random-conic",
  execute: function(count = 42) {
    return repeat(count).map(() => {
      return {
        gradient: `conic-gradient(from 0deg at 50% 50%, ${ColorStep.createColorStep(10, 360, "deg")})`
      };
    });
  }
};
const angle_list$1 = ["0deg", "45deg", "90deg"];
var randomLinear = {
  title: "Random Linear",
  key: "random-linear",
  execute: function(count = 42) {
    return repeat(count).map(() => {
      return {
        gradient: `linear-gradient(${randomItem(...angle_list$1)}, ${ColorStep.createColorStep(10)})`
      };
    });
  }
};
var randomRadial = {
  title: "Random Radial",
  key: "random-radial",
  execute: function(count = 42) {
    return repeat(count).map(() => {
      return {
        gradient: `radial-gradient(circle, ${ColorStep.createColorStep(10)})`
      };
    });
  }
};
var repeatConic = {
  title: "Repeat Conic",
  key: "repeat-conic",
  execute: function(count = 42) {
    return repeat(count).map(() => {
      return {
        gradient: `repeating-conic-gradient(from 0deg at 0% 50%, ${ColorStep.createRepeatColorStep(10, "10deg")})`
      };
    });
  }
};
const angle_list = ["0deg", "45deg", "90deg"];
var repeatLinear = {
  title: "Repeat Linear",
  key: "repeat-linear",
  execute: function(count = 42) {
    return repeat(count).map(() => {
      return {
        gradient: `repeating-linear-gradient(${randomItem(...angle_list)}, ${ColorStep.createRepeatColorStep(2, "10px")})`
      };
    });
  }
};
var repeatRadial = {
  title: "Repeat Radial",
  key: "repeat-radial",
  execute: function(count = 42) {
    return repeat(count).map(() => {
      var shape2 = "circle";
      return {
        gradient: `repeating-radial-gradient(${shape2}, ${ColorStep.createRepeatColorStep(3, "6px")})`
      };
    });
  }
};
var gradients = [
  linear,
  randomLinear,
  repeatLinear,
  radial,
  randomRadial,
  repeatRadial,
  conic,
  randomConic,
  repeatConic
];
var GradientAssetsProperty$1 = "";
const options = gradients.map((it) => {
  return { value: it.key, text: it.title };
});
class GradientAssetsProperty extends BaseProperty {
  getTitle() {
    return this.$i18n("gradient.asset.property.title");
  }
  initState() {
    return {
      mode: "grid",
      preset: "linear"
    };
  }
  getTools() {
    return `<div ref="$tools"></div>`;
  }
  [LOAD("$tools")]() {
    return createComponent("SelectEditor", {
      ref: "$preset",
      key: "preset",
      value: this.state.preset,
      options,
      onchange: "changePreset"
    });
  }
  [SUBSCRIBE_SELF("changePreset")](key, value) {
    this.setState({
      [key]: value
    });
  }
  getClassName() {
    return "elf--gradient-assets-property";
  }
  [SUBSCRIBE(REFRESH_SELECTION) + DEBOUNCE(100)]() {
    this.show();
  }
  getBody() {
    return `
      <div class='property-item gradient-assets'>
        <div class='gradient-list' ref='$gradientList' data-view-mode='${this.state.mode}'></div>
      </div>
    `;
  }
  [DRAGSTART("$gradientList .gradient-item")](e) {
    const gradient2 = e.$dt.attr("data-gradient");
    e.dataTransfer.effectAllowed = "copy";
    e.dataTransfer.setData("text/gradient", gradient2);
  }
  [LOAD("$gradientList")]() {
    var preset = gradients.find((it) => it.key === this.state.preset);
    if (!preset) {
      return "";
    }
    var results = preset.execute().map((item, index2) => {
      return `
        <div class='gradient-item' data-index="${index2}" data-gradient='${item.gradient}' data-custom="${item.custom}">
          <div class='preview' title="${item.gradient}" draggable="true">
            <div class='gradient-view' style='background-image: ${item.gradient};'></div>
          </div>
        </div>
      `;
    });
    if (preset.edit) {
      results.push(`<div class='add-gradient-item'><butto type="button">${iconUse("add")}</button></div>`);
    }
    return results;
  }
  executeGradient(callback, isRefresh = true, isEmit = true) {
    var project2 = this.$context.selection.currentProject;
    if (project2) {
      callback && callback(project2);
      if (isRefresh)
        this.refresh();
      if (isEmit)
        this.emit("refreshGradientAssets");
    } else {
      window.alert("Please select a project.");
    }
  }
  [CLICK("$gradientList .add-gradient-item")]() {
    this.executeGradient((project2) => {
      project2.createGradient({
        gradient: Gradient.random(),
        name: "",
        variable: ""
      });
    });
  }
  [CLICK("$gradientList .preview")](e) {
    var $item = e.$dt.closest("gradient-item");
    var gradient2 = $item.attr("data-gradient");
    this.$commands.emit("drop.asset", { gradient: gradient2 });
  }
}
function gradientAsset(editor) {
  editor.registerElement({
    GradientAssetsProperty
  });
}
var GradientEditorView$1 = "";
var radialTypeList = [
  "circle",
  "circle farthest-corner",
  "circle closest-side",
  "circle closest-corner",
  "circle farthest-side",
  "ellipse",
  "ellipse farthest-corner",
  "ellipse closest-side",
  "ellipse closest-corner",
  "ellipse farthest-side"
];
var repeatTypeList = [
  "no-repeat",
  "repeat",
  "repeat-x",
  "repeat-y",
  "space",
  "round"
];
const TOOL_SIZE = 20;
class GradientBaseEditor extends EditorElement {
  initializeData() {
    const value = this.$context.selection.current.backgroundImage;
    const cssValue = STRING_TO_CSS(value);
    this.state.backgroundImages = BackgroundImage.parseStyle(cssValue);
    this.state.backImages = BackgroundImage.parseStyle(cssValue);
    const current = this.$context.selection.current;
    this.state.gradient = this.state.backImages[this.state.index];
    this.state.contentBox = current.contentBox;
    this.state.backgroundImageMatrix = current.createBackgroundImageMatrix(this.state.index);
  }
  updateData() {
    var value = CSS_TO_STRING(BackgroundImage.toProperty(this.state.backgroundImages));
    this.$commands.executeCommand("setAttribute", "change background image", this.$context.selection.packByValue({
      backgroundImage: value
    }));
  }
}
class GradientTimingStepEditor extends GradientBaseEditor {
  [POINTERSTART("$el .step-point") + MOVE("moveStepPoint") + END("moveEndStepPoint")](e) {
    this.$el.toggleClass("dragging", true);
    this.initializeData();
    const colorStepIndex = +e.$dt.data("colorstep-index");
    this.localColorStep = this.state.backgroundImages[this.state.index].image.colorsteps[colorStepIndex];
    this.localColorStepTimingCount = this.localColorStep.timing.count;
    this.localColorCubicBezierTimingCount = this.localColorStep.timingCount;
  }
  moveStepPoint(dx, dy) {
    const dist$1 = (dx < 0 ? -1 : 1) * Math.ceil(dist([0, 0, 0], [dx, dy, 0]) / 10);
    switch (this.localColorStep.timing.name) {
      case TimingFunction.LINEAR:
        break;
      case TimingFunction.STEPS:
        this.localColorStep.timing.count = Math.max(this.localColorStepTimingCount + dist$1, 1);
        break;
      default:
        this.localColorStep.timingCount = Math.max(this.localColorCubicBezierTimingCount + dist$1, 1);
        break;
    }
    this.updateData();
  }
  makeTimingString(timing) {
    switch (timing.name) {
      case TimingFunction.LINEAR:
        return ``;
      case TimingFunction.EASE:
      case TimingFunction.EASE_IN:
      case TimingFunction.EASE_OUT:
      case TimingFunction.EASE_IN_OUT:
        return `${timing.name}`;
      default:
        return `cubic-bezier(${timing.x1}, ${timing.y1}, ${timing.x2}, ${timing.y2})`;
    }
  }
  moveEndStepPoint(dx, dy) {
    if (dx === 0 && dy === 0) {
      const { timing } = this.localColorStep;
      switch (timing.name) {
        case TimingFunction.STEPS:
          this.localColorStep.timing.direction = this.localColorStep.timing.direction === "start" ? "end" : "start";
          break;
        case TimingFunction.LINEAR:
          break;
        case TimingFunction.PATH:
          this.emit("showComponentPopup", {
            title: "Path Editor",
            width: 400,
            inspector: [
              {
                key: "path",
                editor: "path",
                editorOptions: {
                  height: 160
                },
                defaultValue: timing.d
              }
            ],
            changeEvent: (key, value) => {
              this.localColorStep.timing = parseOneValue(`path(${value})`).parsed;
              this.updateData();
            }
          });
          break;
        default:
          this.emit("showComponentPopup", {
            title: "Cubic Bezier",
            width: 220,
            inspector: [
              {
                key: "timing",
                editor: "cubic-bezier",
                editorOptions: {
                  isAnimating: false
                },
                defaultValue: this.makeTimingString(timing)
              }
            ],
            changeEvent: (key, value) => {
              this.localColorStep.timing = parseOneValue(value).parsed;
              this.updateData();
            }
          });
          this.$el.toggleClass("dragging", false);
          return;
      }
    }
    this.updateData();
    this.$el.toggleClass("dragging", false);
  }
}
class GradientResizer extends GradientTimingStepEditor {
  [POINTERSTART("$el .resizer") + LEFT_BUTTON + MOVE("calculateMovedResizer") + END("calculateMovedEndResizer") + PREVENT](e) {
    this.state.$target = e.$dt;
    this.$el.toggleClass("dragging", true);
    this.initializeData();
    this.initMousePoint = this.$viewport.getWorldPosition(e);
    this.isShiftKey = e.shiftKey;
  }
  calculateMovedResizer() {
    const targetMousePoint = this.$viewport.getWorldPosition();
    const currentVertex = clone(this.initMousePoint);
    const nextVertex = targetMousePoint;
    const reverseMatrix = this.$context.selection.current.absoluteMatrixInverse;
    const [currentResult, nextResult] = vertiesMap([currentVertex, nextVertex], reverseMatrix);
    const realDist = subtract([], nextResult, currentResult);
    const { backRect: rect2 } = this.state.backgroundImageMatrix;
    const backgroundImage2 = this.state.gradient;
    const backRect = backgroundImage2.recoverOffset(rect2.x, rect2.y, this.state.contentBox, realDist[0], realDist[1], {
      shiftKey: this.$config.get("bodyEvent").shiftKey
    });
    this.state.backgroundImages[this.state.index].reset({
      x: backRect.x,
      y: backRect.y,
      width: backRect.width,
      height: backRect.height
    });
    this.updateData();
  }
  calculateMovedEndResizer() {
    this.updateData();
    this.$el.toggleClass("dragging", false);
  }
  [POINTERSTART("$el .back-rect") + LEFT_BUTTON + MOVE("calculateMovedRect") + END("calculateMovedEndRect") + PREVENT](e) {
    this.state.$target = e.$dt;
    this.initializeData();
    this.initMousePoint = this.$viewport.getWorldPosition(e);
  }
  calculateMovedRect() {
    const targetMousePoint = this.$viewport.getWorldPosition();
    const currentVertex = clone(this.initMousePoint);
    const nextVertex = targetMousePoint;
    const reverseMatrix = this.$context.selection.current.absoluteMatrixInverse;
    const [currentResult, nextResult] = vertiesMap([currentVertex, nextVertex], reverseMatrix);
    const realDist = subtract([], nextResult, currentResult);
    const { backRect: rect2 } = this.state.backgroundImageMatrix;
    const backgroundImage2 = this.state.gradient;
    const backRect = backgroundImage2.recoverOffset(rect2.x + realDist[0], rect2.y + realDist[1], this.state.contentBox);
    this.state.backgroundImages[this.state.index].reset({
      x: backRect.x,
      y: backRect.y
    });
    this.updateData();
  }
  calculateMovedEndRect(dx, dy) {
    if (dx == 0 && dy === 0) {
      const index2 = repeatTypeList.indexOf(this.state.gradient.repeat);
      this.state.backgroundImages[this.state.index].repeat = repeatTypeList[(index2 + 1) % repeatTypeList.length];
    }
    this.updateData();
  }
}
class GradientRotateEditor extends GradientResizer {
  [POINTERSTART("$el .gradient-angle .rotate") + LEFT_BUTTON + MOVE("calculateMovedAngle") + END("calculatedMovedEndAngle") + PREVENT](e) {
    this.state.$target = e.$dt;
    this.initializeData();
    this.$el.toggleClass("dragging", true);
    this.state.centerX = +this.state.$target.data("center-x");
    this.state.centerY = +this.state.$target.data("center-y");
    this.state.startX = +this.state.$target.attr("cx");
    this.state.startY = +this.state.$target.attr("cy");
    this.state.$target.toggleClass("moved");
  }
  calculateMovedAngle(dx, dy) {
    const center2 = [this.state.centerX, this.state.centerY, 0];
    const point2 = [this.state.startX, this.state.startY, 0];
    const dist2 = [dx, dy, 0];
    const distAngle = calculateAngleForVec3(point2, center2, dist2);
    let newAngle = Math.floor(this.state.gradient.image.angle + distAngle);
    if (this.$config.get("bodyEvent").shiftKey) {
      newAngle -= newAngle % this.$config.get("fixed.gradient.angle");
    }
    this.state.backgroundImages[this.state.index].image.angle = newAngle;
    this.updateData();
  }
  calculatedMovedEndAngle() {
    this.state.$target.toggleClass("moved");
    this.$el.toggleClass("dragging", false);
    this.updateData();
  }
}
class GradientColorstepEditor extends GradientRotateEditor {
  [KEYUP("$el .colorstep")](e) {
    const index2 = +e.$dt.data("index");
    switch (e.code) {
      case "Delete":
      case "Backspace":
        this.removeStep(index2);
        break;
      case "BracketRight":
        this.sortToRight(index2);
        break;
      case "BracketLeft":
        this.sortToLeft(index2);
        break;
      case "Equal":
        this.appendColorStep(index2);
        break;
      case "Minus":
        this.prependColorStep(index2);
        break;
    }
  }
  removeStep(currentIndex) {
    const image2 = this.state.lastBackgroundMatrix.backgroundImage.image;
    image2.removeColorStepByIndex(currentIndex);
    this.updateColorStepStatus(image2, -1);
  }
  sortToRight() {
    const image2 = this.state.lastBackgroundMatrix.backgroundImage.image;
    image2.sortToRight();
    this.updateColorStepStatus(image2, -1);
  }
  sortToLeft() {
    const image2 = this.state.lastBackgroundMatrix.backgroundImage.image;
    image2.sortToLeft();
    this.updateColorStepStatus(image2, -1);
  }
  appendColorStep(currentIndex) {
    const nextIndex = currentIndex + 1;
    const image2 = this.state.lastBackgroundMatrix.backgroundImage.image;
    const currentColorStep = image2.colorsteps[currentIndex];
    const nextColorStep = image2.colorsteps[nextIndex];
    let newIndex = -1;
    if (!nextColorStep) {
      if (currentColorStep.percent !== 100) {
        newIndex = image2.insertColorStep(currentColorStep.percent + (100 - currentColorStep.percent) / 2);
      }
    } else {
      newIndex = image2.insertColorStep(currentColorStep.percent + (nextColorStep.percent - currentColorStep.percent) / 2);
    }
    this.updateColorStepStatus(image2, newIndex);
  }
  prependColorStep(currentIndex) {
    const prevIndex = currentIndex - 1;
    const image2 = this.state.lastBackgroundMatrix.backgroundImage.image;
    const currentColorStep = image2.colorsteps[currentIndex];
    const prevColorStep = image2.colorsteps[prevIndex];
    let newIndex = -1;
    if (!prevColorStep) {
      if (currentColorStep.percent !== 0) {
        newIndex = image2.insertColorStep(currentColorStep.percent);
      }
    } else {
      newIndex = image2.insertColorStep(prevColorStep.percent + (currentColorStep.percent - prevColorStep.percent) / 2);
    }
    this.updateColorStepStatus(image2, newIndex);
  }
  [POINTERSTART("$el .colorstep") + MOVE("moveColorStep") + END("moveEndColorStep")](e) {
    this.$el.toggleClass("dragging", true);
    this.state.hoverColorStep = null;
    this.initializeData();
    const $colorstep = e.$dt;
    this.$targetIndex = +$colorstep.data("index");
    if (e.altKey) {
      this.removeStep(this.$targetIndex);
      this.state.altKey = true;
      return;
    }
    const result = this.state.backgroundImageMatrix;
    switch (result.backgroundImage.image.type) {
      case GradientType.LINEAR:
      case GradientType.REPEATING_LINEAR:
        this.centerPosition = this.$viewport.applyVertex(result.centerPosition);
        this.startPoint = this.$viewport.applyVertex(result.startPoint);
        this.endPoint = this.$viewport.applyVertex(result.endPoint);
        this.screenXY = this.$viewport.applyVertex(result.colorsteps[this.$targetIndex].pos);
        this.rotateInverse = calculateRotationOriginMat4(-this.state.gradient.image.angle, this.centerPosition);
        break;
      case GradientType.RADIAL:
      case GradientType.REPEATING_RADIAL:
        this.centerPosition = this.$viewport.applyVertex(result.radialCenterPosition);
        this.startPoint = this.$viewport.applyVertex(result.startPoint);
        this.endPoint = this.$viewport.applyVertex(result.endPoint);
        this.screenXY = this.$viewport.applyVertex(result.colorsteps[this.$targetIndex].pos);
        const dist2 = subtract([], this.endPoint, this.startPoint);
        const angle = calculateAngle360(dist2[0], dist2[1]) - 180;
        this.rotateInverse = calculateRotationOriginMat4(-angle, this.centerPosition);
        break;
      case GradientType.CONIC:
      case GradientType.REPEATING_CONIC:
        this.centerPosition = this.$viewport.applyVertex(result.radialCenterPosition);
        this.startPoint = this.$viewport.applyVertex(result.shapePoint);
        this.newStartPoint = subtract([], this.startPoint, this.centerPosition);
        this.newStartAngle = calculateAngle360(this.newStartPoint[0], this.newStartPoint[1]);
        const x = +$colorstep.data("x");
        const y = +$colorstep.data("y");
        this.screenXY = [x, y, 0];
        this.endPoint = this.$viewport.applyVertex(result.endPoint);
        this.rotateInverse = create$4();
        break;
    }
  }
  moveColorStep(dx, dy) {
    if (this.state.altKey)
      return;
    const nextPoint = add$1([], this.screenXY, [dx, dy, 0]);
    const [baseStartPoint, baseEndPoint, baseNextPoint] = vertiesMap([this.startPoint, this.endPoint, nextPoint], this.rotateInverse);
    const result = this.state.backgroundImageMatrix;
    let newDist = 0;
    let baseDist = 0;
    switch (result.backgroundImage.image.type) {
      case GradientType.LINEAR:
      case GradientType.REPEATING_LINEAR:
        var [s, e, n] = [baseStartPoint[1], baseEndPoint[1], baseNextPoint[1]];
        var baseDefaultDist = Math.abs(s - e);
        if (s < n) {
          newDist = -1 * Math.abs(n - s) / baseDefaultDist * 100;
        } else if (e > n) {
          newDist = Math.abs(n - s) / baseDefaultDist * 100;
        } else {
          var distStart = Math.abs(s - n);
          var distEnd = Math.abs(e - n);
          newDist = distStart / (distEnd + distStart) * 100;
        }
        newDist = Math.max(0, Math.min(100, newDist));
        baseDist = dist(this.startPoint, this.endPoint);
        break;
      case GradientType.RADIAL:
      case GradientType.REPEATING_RADIAL:
        var [s, e, n] = [baseStartPoint[0], baseEndPoint[0], baseNextPoint[0]];
        var baseDefaultDist = Math.abs(s - e);
        if (n < s) {
          newDist = -1 * Math.abs(n - s) / baseDefaultDist * 100;
        } else if (n > e) {
          newDist = Math.abs(n - s) / baseDefaultDist * 100;
        } else {
          newDist = (n - s) / baseDefaultDist * 100;
        }
        newDist = Math.max(0, Math.min(100, newDist));
        baseDist = dist(this.startPoint, this.endPoint);
        break;
      case GradientType.CONIC:
      case GradientType.REPEATING_CONIC:
        const newNextPoint = subtract([], nextPoint, this.centerPosition);
        let nextAngle = calculateAngle360(newNextPoint[0], newNextPoint[1]);
        if (this.$config.get("bodyEvent").shiftKey) {
          nextAngle -= nextAngle % this.$config.get("fixed.gradient.angle");
        }
        let newAngle = nextAngle - this.newStartAngle;
        newDist = newAngle / 360 * 100;
        newDist = (newDist + 100) % 100;
        baseDist = 100;
        break;
    }
    const image2 = this.state.gradient.image;
    image2.colorsteps[this.$targetIndex].setValue(newDist, baseDist);
    const targetColorStep = {
      color: image2.colorsteps[this.$targetIndex].color,
      percent: image2.colorsteps[this.$targetIndex].percent
    };
    const nextImage = this.state.backgroundImages[this.state.index].image;
    nextImage.colorsteps = image2.colorsteps.map((it) => {
      return it;
    });
    nextImage.sortColorStep();
    this.emit("updateGradientEditor", nextImage, targetColorStep);
    var value = CSS_TO_STRING(BackgroundImage.toProperty(this.state.backgroundImages));
    this.$commands.executeCommand("setAttribute", "change background image", this.$context.selection.packByValue({
      backgroundImage: value
    }));
  }
  moveEndColorStep(dx, dy) {
    if (this.state.altKey) {
      this.state.altKey = false;
      return;
    }
    if (dx === 0 && dy === 0) {
      const image2 = this.state.backgroundImages[this.state.index].image;
      image2.colorsteps[this.$targetIndex].toggleTiming();
      const targetColorStep = {
        color: image2.colorsteps[this.$targetIndex].color,
        percent: image2.colorsteps[this.$targetIndex].percent
      };
      this.emit("updateGradientEditor", image2, targetColorStep);
      var value = CSS_TO_STRING(BackgroundImage.toProperty(this.state.backgroundImages));
      this.$commands.executeCommand("setAttribute", "change background image", this.$context.selection.packByValue({
        backgroundImage: value
      }));
    }
    this.$el.toggleClass("dragging", false);
  }
  updateColorStepStatus(image2, index2) {
    this.initializeData();
    const { color: color2, percent } = image2.colorsteps[index2] || {};
    this.emit("updateGradientEditor", image2, { color: color2, percent });
    this.state.backgroundImages[this.state.index].image = image2;
    var value = CSS_TO_STRING(BackgroundImage.toProperty(this.state.backgroundImages));
    this.$commands.executeCommand("setAttribute", "change background image", this.$context.selection.packByValue({
      backgroundImage: value
    }));
    this.state.hoverColorStep = null;
  }
  [POINTERSTART("$el .area-line")]() {
    const image2 = this.state.lastBackgroundMatrix.backgroundImage.image;
    const index2 = image2.insertColorStep(this.state.hoverColorStep.percent);
    this.updateColorStepStatus(image2, index2);
  }
  [POINTEROUT("$el .area-line")]() {
    if (this.state.hoverColorStep) {
      this.state.hoverColorStep = null;
      this.refresh();
    }
  }
  [POINTERMOVE("$el .area-line")](evt) {
    const nextPoint = this.$viewport.applyVertex(this.$viewport.getWorldPosition(evt));
    const image2 = this.state.lastBackgroundMatrix.backgroundImage.image;
    let baseStartPoint, baseEndPoint, baseNextPoint;
    switch (image2.type) {
      case GradientType.LINEAR:
      case GradientType.REPEATING_LINEAR:
        [baseStartPoint, baseEndPoint, baseNextPoint] = vertiesMap([this.state.startPoint, this.state.endPoint, nextPoint], this.state.rotateInverse);
        var newDist = 0;
        var [s, e, n] = [baseStartPoint[1], baseEndPoint[1], baseNextPoint[1]];
        var baseDefaultDist = Math.abs(s - e);
        if (s < n) {
          newDist = -1 * Math.abs(n - s) / baseDefaultDist * 100;
        } else if (e > n) {
          newDist = Math.abs(n - s) / baseDefaultDist * 100;
        } else {
          const distStart = Math.abs(s - n);
          const distEnd = Math.abs(e - n);
          newDist = distStart / (distEnd + distStart) * 100;
        }
        this.state.hoverColorStep = this.state.lastBackgroundMatrix.backgroundImage.image.pickColorStep(newDist);
        break;
      case GradientType.RADIAL:
      case GradientType.REPEATING_RADIAL:
        [baseStartPoint, baseEndPoint, baseNextPoint] = [
          this.state.startPoint,
          this.state.endPoint,
          nextPoint
        ];
        var newDist = 0;
        var [s, e, n] = [baseStartPoint[0], baseEndPoint[0], baseNextPoint[0]];
        var baseDefaultDist = Math.abs(s - e);
        if (n < s) {
          newDist = -1 * Math.abs(n - s) / baseDefaultDist * 100;
        } else {
          newDist = Math.abs(n - s) / baseDefaultDist * 100;
        }
        this.state.hoverColorStep = this.state.lastBackgroundMatrix.backgroundImage.image.pickColorStep(newDist);
        break;
      case GradientType.CONIC:
      case GradientType.REPEATING_CONIC:
        const newStartPoint = subtract([], this.state.startPoint, this.state.centerPosition);
        const newNextPoint = subtract([], nextPoint, this.state.centerPosition);
        const startAngle = calculateAngle360(newStartPoint[0], newStartPoint[1]);
        const nextAngle = calculateAngle360(newNextPoint[0], newNextPoint[1]);
        var newDist = (nextAngle - startAngle) / 360 * 100;
        this.state.hoverColorStep = this.state.lastBackgroundMatrix.backgroundImage.image.pickColorStep(newDist);
        break;
    }
    this.refresh();
  }
}
class GradientEditorView extends GradientColorstepEditor {
  template() {
    return /* @__PURE__ */ createElementJsx("div", {
      class: "elf--gradient-editor-view"
    });
  }
  [POINTERSTART("$el .point") + LEFT_BUTTON + MOVE("calculateMovedElement") + END("calculateMovedEndElement") + PREVENT](e) {
    this.$el.toggleClass("dragging", true);
    this.initializeData();
    const result = this.state.backgroundImageMatrix;
    this.pointTarget = e.$dt.data("type");
    this.startPoint = this.$viewport.applyVertex(result.startPoint);
    this.endPoint = this.$viewport.applyVertex(result.endPoint);
    if (result.shapePoint) {
      this.shapePoint = this.$viewport.applyVertex(result.shapePoint);
    }
  }
  calculateMovedElement(dx, dy) {
    const targetPoint = this.pointTarget === "start" ? this.startPoint : this.endPoint;
    let nextPoint = add$1([], targetPoint, [dx, dy, 0]);
    var [localPosition] = vertiesMap([this.$viewport.applyVertexInverse(nextPoint)], this.$context.selection.current.absoluteMatrixInverse);
    const backgroundImage2 = this.state.gradient;
    const backRect = backgroundImage2.getOffset(this.state.contentBox);
    const image2 = this.state.gradient.image;
    switch (image2.type) {
      case GradientType.RADIAL:
      case GradientType.REPEATING_RADIAL:
        if (this.pointTarget === "start") {
          const newX = localPosition[0] - backRect.x;
          const newY = localPosition[1] - backRect.y;
          this.state.backgroundImages[this.state.index].image.radialPosition = [
            Length.makePercent(newX, backRect.width),
            Length.makePercent(newY, backRect.height)
          ];
          this.updateData();
        } else if (this.pointTarget === "end") {
          var [localStartPosition] = vertiesMap([this.$viewport.applyVertexInverse(this.startPoint)], this.$context.selection.current.absoluteMatrixInverse);
          var [localEndPosition] = vertiesMap([
            this.$viewport.applyVertexInverse(add$1([], this.endPoint, [dx, 0, 0]))
          ], this.$context.selection.current.absoluteMatrixInverse);
          var [localShapePosition] = vertiesMap([this.$viewport.applyVertexInverse(this.shapePoint)], this.$context.selection.current.absoluteMatrixInverse);
          const newEndX = localEndPosition[0] - backRect.x - localStartPosition[0];
          const newShapeY = localShapePosition[1] - backRect.y - localStartPosition[1];
          if (this.state.gradient.image.radialType === RadialGradientType.CIRCLE) {
            this.state.backgroundImages[this.state.index].image.radialSize = [
              Length.px(Math.abs(newEndX))
            ];
          } else if (this.state.gradient.image.radialType === RadialGradientType.ELLIPSE) {
            this.state.backgroundImages[this.state.index].image.radialSize = [
              Length.makePercent(Math.abs(newEndX), backRect.width),
              Length.makePercent(Math.abs(newShapeY), backRect.height)
            ];
          }
          this.updateData();
        } else if (this.pointTarget === "shape") {
          var [localStartPosition] = vertiesMap([this.$viewport.applyVertexInverse(this.startPoint)], this.$context.selection.current.absoluteMatrixInverse);
          var [localShapePosition] = vertiesMap([
            this.$viewport.applyVertexInverse(add$1([], this.shapePoint, [0, dy, 0]))
          ], this.$context.selection.current.absoluteMatrixInverse);
          var [localEndPosition] = vertiesMap([this.$viewport.applyVertexInverse(this.endPoint)], this.$context.selection.current.absoluteMatrixInverse);
          const newEndX = localEndPosition[0] - backRect.x - localStartPosition[0];
          const newShapeY = localShapePosition[1] - backRect.y - localStartPosition[1];
          if (this.state.gradient.image.radialType === RadialGradientType.CIRCLE) {
            this.state.backgroundImages[this.state.index].image.radialSize = [
              Length.px(Math.abs(newShapeY))
            ];
          } else if (this.state.gradient.image.radialType === RadialGradientType.ELLIPSE) {
            this.state.backgroundImages[this.state.index].image.radialSize = [
              Length.makePercent(Math.abs(newEndX), backRect.width),
              Length.makePercent(Math.abs(newShapeY), backRect.height)
            ];
          }
          this.updateData();
        }
        break;
      case GradientType.CONIC:
      case GradientType.REPEATING_CONIC:
        if (this.pointTarget === "start") {
          const newX = localPosition[0] - backRect.x;
          const newY = localPosition[1] - backRect.y;
          this.state.backgroundImages[this.state.index].image.radialPosition = [
            Length.makePercent(newX, backRect.width),
            Length.makePercent(newY, backRect.height)
          ];
          this.updateData();
        }
        break;
    }
  }
  calculateMovedEndElement(dx, dy) {
    if (dx == 0 && dy === 0) {
      if (this.pointTarget === "start") {
        switch (this.state.gradient.type) {
          case GradientType.RADIAL:
          case GradientType.REPEATING_RADIAL:
            const findKey = `${this.state.gradient.image.radialType} ${this.state.gradient.image.radialSize}`.trim();
            const index2 = radialTypeList.indexOf(findKey);
            const [radialType, radialSize] = radialTypeList[(index2 + 1) % radialTypeList.length].split(" ");
            const image2 = this.state.backgroundImages[this.state.index].image;
            image2.radialType = radialType;
            image2.radialSize = radialSize;
            break;
        }
      }
    }
    this.updateData();
    this.$el.toggleClass("dragging", false);
  }
  refresh() {
    if (this.state.isShow) {
      this.load();
    }
  }
  [SUBSCRIBE(UPDATE_VIEWPORT)]() {
    this.refresh();
  }
  [SUBSCRIBE(UPDATE_CANVAS) + DEBOUNCE(10)]() {
    if (this.$context.selection.current) {
      if (this.$context.selection.hasChangedField("x", "y", "width", "height", "angle", "backgroundImage", "border", "padding", "paddingTop", "paddingLeft", "paddingRight", "paddingBottom")) {
        this.refresh();
      }
    }
  }
  [SUBSCRIBE("showGradientEditorView")]({ index: index2 }) {
    this.state.index = index2;
    this.$el.show();
    this.state.isShow = true;
    this.refresh();
    this.$commands.emit("recoverCursor");
    this.$context.commands.emit("push.mode.view", "GradientEditorView");
  }
  [SUBSCRIBE("hideGradientEditorView")]() {
    this.$el.hide();
    this.state.isShow = false;
    this.$commands.emit("pop.mode.view", "GradientEditorView");
  }
  makeTimingLine(timing, width2 = 10, startX = 0, startY = 0) {
    switch (timing.name) {
      case TimingFunction.LINEAR:
        return ``;
      case TimingFunction.STEPS:
        return /* @__PURE__ */ createElementJsx("path", {
          class: "timing",
          d: `
          M${startX + 0} ${startY + width2} 
          L${startX + width2 * 1 / 3} ${startY + width2} 
          L${startX + width2 * 1 / 3} ${startY + width2 * 2 / 3} 
          L${startX + width2 * 2 / 3} ${startY + width2 * 2 / 3} 
          L${startX + width2 * 2 / 3} ${startY + width2 * 1 / 3} 
          L${startX + width2} ${startY + width2 * 1 / 3} 
          L${startX + width2} ${startY + 0}           
        `
        });
      case TimingFunction.PATH:
        return /* @__PURE__ */ createElementJsx("path", {
          class: "timing",
          d: PathParser.fromSVGString(timing.d).scale(width2, width2).flipX().translate(0, width2).d
        });
      default:
        return /* @__PURE__ */ createElementJsx("path", {
          class: "timing",
          d: `
          M${startX + 0} ${startY + width2} 
          C 
            ${startX + timing.x1 * width2} ${startY + width2 - timing.y1 * width2} 
            ${startX + timing.x2 * width2} ${startY + width2 - timing.y2 * width2}  
            ${startX + width2} ${startY + 0}
        `
        });
    }
  }
  makeConicTimingLine(timing, width2 = 10, startX = 0, startY = 0) {
    const half = width2 / 2;
    switch (timing.name) {
      case TimingFunction.LINEAR:
        return ``;
      case TimingFunction.STEPS:
        return /* @__PURE__ */ createElementJsx("path", {
          class: "timing",
          d: `
          M${startX + 0 - half} ${startY + width2 - half} 
          L${startX + width2 * 1 / 3 - half} ${startY + width2 - half} 
          L${startX + width2 * 1 / 3 - half} ${startY + width2 * 2 / 3 - half} 
          L${startX + width2 * 2 / 3 - half} ${startY + width2 * 2 / 3 - half} 
          L${startX + width2 * 2 / 3 - half} ${startY + width2 * 1 / 3 - half} 
          L${startX + width2 - half} ${startY + width2 * 1 / 3 - half} 
          L${startX + width2 - half} ${startY + 0 - half}           
        `
        });
      case TimingFunction.PATH:
        return /* @__PURE__ */ createElementJsx("path", {
          class: "timing",
          d: PathParser.fromSVGString(timing.d).scale(width2, width2).flipX().translate(-half, width2).d
        });
      default:
        return /* @__PURE__ */ createElementJsx("path", {
          class: "timing",
          d: `
          M${startX + 0 - half} ${startY + width2 - half} 
          C 
            ${startX + timing.x1 * width2 - half} ${startY + width2 - timing.y1 * width2 - half} 
            ${startX + timing.x2 * width2 - half} ${startY + width2 - timing.y2 * width2 - half}  
            ${startX + width2 - half} ${startY + 0 - half}
        `
        });
    }
  }
  makeTimingCircle(colorstepIndex, current, prev) {
    const prevStickScreenXY = prev.stickScreenXYInEnd;
    const stickScreenXY = current.stickScreenXYInStart;
    const { timing, timingCount } = current;
    let pos;
    switch (timing.name) {
      case TimingFunction.LINEAR:
        return ``;
      case TimingFunction.STEPS:
        pos = lerp$1([], prevStickScreenXY, stickScreenXY, 0.5);
        return /* @__PURE__ */ createElementJsx(FragmentInstance, null, /* @__PURE__ */ createElementJsx("circle", {
          class: "step-point",
          "data-colorstep-index": colorstepIndex,
          cx: pos[0],
          cy: pos[1],
          r: 7
        }), /* @__PURE__ */ createElementJsx("text", {
          x: pos[0],
          y: pos[1],
          dy: 4,
          "text-anchor": "middle"
        }, timing.count));
      default:
        pos = lerp$1([], prevStickScreenXY, stickScreenXY, 0.5);
        return /* @__PURE__ */ createElementJsx(FragmentInstance, null, /* @__PURE__ */ createElementJsx("circle", {
          class: "step-point",
          "data-colorstep-index": colorstepIndex,
          cx: pos[0],
          cy: pos[1],
          r: 7
        }), /* @__PURE__ */ createElementJsx("text", {
          x: pos[0],
          y: pos[1],
          dy: 4,
          "text-anchor": "middle"
        }, timingCount));
    }
  }
  makeConicTimingCircle(startPoint, colorstepIndex, current, prev) {
    const prevStickScreenXY = prev.stickScreenXY;
    const stickScreenXY = current.stickScreenXY;
    const { timing, timingCount } = current;
    const dist$1 = dist(prevStickScreenXY, startPoint);
    const prevAngle = calculateAngle360(...subtract([], prevStickScreenXY, startPoint));
    const angle = calculateAngle360(...subtract([], stickScreenXY, startPoint));
    let nextAngle = this.getRealAngle(prevAngle + (angle - prevAngle) / 2);
    const bigArc = Math.abs(angle - prevAngle) % 360 >= 180 ? 1 : 0;
    if (bigArc) {
      nextAngle -= 180;
    }
    var [pos] = vertiesMap([lerp$1([], startPoint, add$1([], startPoint, [-1, 0, 0]), dist$1)], calculateRotationOriginMat4(nextAngle, startPoint));
    switch (timing.name) {
      case TimingFunction.LINEAR:
        return ``;
      case TimingFunction.STEPS:
        return /* @__PURE__ */ createElementJsx(FragmentInstance, null, /* @__PURE__ */ createElementJsx("circle", {
          class: "step-point",
          "data-colorstep-index": colorstepIndex,
          cx: pos[0],
          cy: pos[1],
          r: 7
        }), /* @__PURE__ */ createElementJsx("text", {
          x: pos[0],
          y: pos[1],
          dy: 4,
          "text-anchor": "middle"
        }, timing.count));
      default:
        return /* @__PURE__ */ createElementJsx(FragmentInstance, null, /* @__PURE__ */ createElementJsx("circle", {
          class: "step-point",
          "data-colorstep-index": colorstepIndex,
          cx: pos[0],
          cy: pos[1],
          r: 7
        }), /* @__PURE__ */ createElementJsx("text", {
          x: pos[0],
          y: pos[1],
          dy: 4,
          "text-anchor": "middle"
        }, timingCount));
    }
  }
  makeTimingArea(colorstepIndex, current, prev, size2) {
    const prevStickScreenXY = prev.stickScreenXYInEnd;
    const stickScreenXY = current.stickScreenXYInStart;
    return /* @__PURE__ */ createElementJsx("g", {
      class: "timing-area"
    }, current.timing.name === TimingFunction.LINEAR ? `` : /* @__PURE__ */ createElementJsx("path", {
      class: "timing-path",
      d: `
              M ${prevStickScreenXY[0]} ${prevStickScreenXY[1]}
              L ${stickScreenXY[0]} ${stickScreenXY[1]}
            `
    }), this.makeTimingCircle(colorstepIndex, current, prev, size2));
  }
  getRealAngle(angle) {
    return angle < 0 ? 360 + angle : angle;
  }
  makeConicTimingArea(startPoint, colorstepIndex, current, prev, size2, dist2, startAngle) {
    const prevStickScreenXY = prev.stickScreenXY;
    const stickScreenXY = current.stickScreenXY;
    const prevAngle = calculateAngle360(...subtract([], prevStickScreenXY, startPoint)) + startAngle;
    const angle = calculateAngle360(...subtract([], stickScreenXY, startPoint)) + startAngle;
    const nextAngle = 360 - prevAngle;
    const nextAngle2 = angle;
    const bigArc = Math.abs(nextAngle + nextAngle2) % 360 >= 180 ? 1 : 0;
    return /* @__PURE__ */ createElementJsx("g", {
      class: "timing-area"
    }, current.timing.name === TimingFunction.LINEAR ? `` : /* @__PURE__ */ createElementJsx(FragmentInstance, null, /* @__PURE__ */ createElementJsx("path", {
      class: "timing-path",
      d: `
              M ${prevStickScreenXY[0]} ${prevStickScreenXY[1]}
              A ${dist2} ${dist2} 0 ${bigArc} 1 ${stickScreenXY[0]} ${stickScreenXY[1]}
            `
    })), this.makeConicTimingCircle(startPoint, colorstepIndex, current, prev, dist2));
  }
  makeGradientPoint(colorsteps, startPoint, endPoint, shapePoint, newHoverColorStepPoint) {
    const size2 = TOOL_SIZE;
    const dist2 = subtract([], endPoint, startPoint);
    const angle = calculateAngle360(dist2[0], dist2[1]) - 180;
    return /* @__PURE__ */ createElementJsx(FragmentInstance, null, colorsteps.map((it, index2) => {
      if (index2 === 0)
        return "";
      return this.makeTimingArea(index2, it, colorsteps[index2 - 1], TOOL_SIZE);
    }), colorsteps.map((it, index2) => {
      return /* @__PURE__ */ createElementJsx("g", {
        transform: `rotate(${angle} ${it.stickScreenXY[0]} ${it.stickScreenXY[1]})`
      }, /* @__PURE__ */ createElementJsx("rect", {
        id: it.id,
        "data-index": index2,
        class: "colorstep",
        x: it.stickScreenXY[0],
        y: it.stickScreenXY[1],
        width: size2,
        height: size2,
        fill: it.color,
        tabIndex: -1,
        "data-x": it.screenXY[0],
        "data-y": it.screenXY[1]
      }), this.makeTimingLine(it.timing, size2, it.stickScreenXY[0], it.stickScreenXY[1]));
    }), /* @__PURE__ */ createElementJsx("circle", {
      class: "point",
      "data-type": "start",
      cx: startPoint[0],
      cy: startPoint[1]
    }), /* @__PURE__ */ createElementJsx("circle", {
      class: "point",
      "data-type": "end",
      cx: endPoint[0],
      cy: endPoint[1]
    }), shapePoint && /* @__PURE__ */ createElementJsx("circle", {
      class: "point",
      "data-type": "shape",
      cx: shapePoint[0],
      cy: shapePoint[1]
    }), newHoverColorStepPoint && /* @__PURE__ */ createElementJsx("circle", {
      class: "hover-colorstep",
      r: "5",
      cx: newHoverColorStepPoint[0],
      cy: newHoverColorStepPoint[1],
      fill: this.state.hoverColorStep.color
    }));
  }
  makeConicGradientPoint(colorsteps, startPoint, endPoint, shapePoint, newHoverColorStepPoint, dist2, startAngle) {
    const size2 = TOOL_SIZE;
    return /* @__PURE__ */ createElementJsx(FragmentInstance, null, colorsteps.map((it, index2) => {
      if (index2 === 0)
        return "";
      return this.makeConicTimingArea(startPoint, index2, it, colorsteps[index2 - 1], TOOL_SIZE, dist2, startAngle);
    }), colorsteps.map((it, index2) => {
      const angle = calculateAngle360(...subtract([], it.screenXY, startPoint)) - 180;
      return /* @__PURE__ */ createElementJsx("g", {
        transform: `rotate(${angle} ${it.screenXY[0]} ${it.screenXY[1]})`
      }, /* @__PURE__ */ createElementJsx("rect", {
        id: it.id,
        "data-index": index2,
        class: "colorstep",
        x: it.screenXY[0] - size2 / 2,
        y: it.screenXY[1] - size2 / 2,
        width: size2,
        height: size2,
        fill: it.color,
        tabIndex: -1,
        "data-x": it.screenXY[0],
        "data-y": it.screenXY[1]
      }), this.makeConicTimingLine(it.timing, size2, it.screenXY[0], it.screenXY[1], startAngle));
    }), /* @__PURE__ */ createElementJsx("circle", {
      class: "point",
      "data-type": "start",
      cx: startPoint[0],
      cy: startPoint[1]
    }), /* @__PURE__ */ createElementJsx("circle", {
      class: "point",
      "data-type": "end",
      cx: endPoint[0],
      cy: endPoint[1]
    }), shapePoint && /* @__PURE__ */ createElementJsx("circle", {
      class: "point",
      "data-type": "shape",
      cx: shapePoint[0],
      cy: shapePoint[1]
    }), newHoverColorStepPoint && /* @__PURE__ */ createElementJsx("circle", {
      class: "hover-colorstep",
      r: "5",
      cx: newHoverColorStepPoint[0],
      cy: newHoverColorStepPoint[1],
      fill: this.state.hoverColorStep.color
    }));
  }
  makeGradientRect(result) {
    const boxPosition = this.$viewport.applyVerties(result.backVerties);
    return /* @__PURE__ */ createElementJsx(FragmentInstance, null, /* @__PURE__ */ createElementJsx("div", {
      class: "gradient-rect"
    }, /* @__PURE__ */ createElementJsx("svg", null, /* @__PURE__ */ createElementJsx("path", {
      class: "back-rect",
      d: `
                    M ${boxPosition[0][0]} ${boxPosition[0][1]}
                    L ${boxPosition[1][0]} ${boxPosition[1][1]}
                    L ${boxPosition[2][0]} ${boxPosition[2][1]}
                    L ${boxPosition[3][0]} ${boxPosition[3][1]}
                    Z
                `
    }))), /* @__PURE__ */ createElementJsx("div", {
      class: "resizer",
      "data-direction": "bottom-right",
      style: {
        left: Length.px(boxPosition[2][0]),
        top: Length.px(boxPosition[2][1])
      }
    }));
  }
  makeCenterPoint(result) {
    const { image: image2 } = result.backgroundImage;
    switch (image2.type) {
      case GradientType.LINEAR:
      case GradientType.REPEATING_LINEAR:
        return this.makeLinearCenterPoint(result);
      case GradientType.RADIAL:
      case GradientType.REPEATING_RADIAL:
        return this.makeRadialCenterPoint(result);
      case GradientType.CONIC:
      case GradientType.REPEATING_CONIC:
        return this.makeConicCenterPoint(result);
    }
    return "";
  }
  makeConicCenterPoint(result) {
    const { image: image2 } = result.backgroundImage;
    let centerPosition, centerStick;
    let startPoint, endPoint, shapePoint, colorsteps;
    centerPosition = this.$viewport.applyVertex(result.radialCenterPosition);
    startPoint = this.$viewport.applyVertex(result.startPoint);
    endPoint = this.$viewport.applyVertex(result.endPoint);
    shapePoint = this.$viewport.applyVertex(result.shapePoint);
    let lastDist = dist(startPoint, endPoint) / 2;
    if (lastDist < 50) {
      lastDist = 50;
    }
    colorsteps = result.colorsteps.map((it) => {
      it.screenXY = this.$viewport.applyVertex(it.pos);
      const pointDist = dist(it.screenXY, startPoint);
      if (pointDist < lastDist) {
        it.screenXY = lerp$1([], startPoint, lerp$1([], startPoint, it.screenXY, 1 / pointDist), lastDist + 20);
      } else if (pointDist > lastDist) {
        it.screenXY = lerp$1([], startPoint, it.screenXY, (lastDist + 20) / pointDist);
      }
      it.stickScreenXY = clone(it.screenXY);
      const dist$1 = subtract([], it.screenXY, startPoint);
      it.angle = calculateAngle360(dist$1[0], dist$1[1]);
      return it;
    });
    centerPosition = this.$viewport.applyVertex(result.radialCenterPosition);
    const stickPoint = this.$viewport.applyVertex(result.shapePoint);
    centerStick = lerp$1([], centerPosition, lerp$1([], centerPosition, stickPoint, 1 / dist(centerPosition, stickPoint)), lastDist + 50);
    const targetStick = lerp$1([], centerStick, centerPosition, 1);
    let newHoverColorStepPoint = null;
    if (this.state.hoverColorStep) {
      const hoverAngle = this.state.hoverColorStep.percent * 3.6;
      const originDist = dist(centerPosition, shapePoint);
      [newHoverColorStepPoint] = vertiesMap([
        lerp$1([], centerPosition, shapePoint, (lastDist + 20) / originDist)
      ], calculateRotationOriginMat4(hoverAngle, centerPosition));
    }
    return /* @__PURE__ */ createElementJsx(FragmentInstance, null, /* @__PURE__ */ createElementJsx("div", {
      class: "gradient-position center",
      "data-radial-type": image2.radialType,
      style: {
        left: Length.px(centerPosition[0]),
        top: Length.px(centerPosition[1])
      }
    }), /* @__PURE__ */ createElementJsx("svg", {
      class: "gradient-angle"
    }, /* @__PURE__ */ createElementJsx("circle", {
      class: "size",
      cx: startPoint[0],
      cy: startPoint[1],
      r: lastDist
    }), /* @__PURE__ */ createElementJsx("circle", {
      class: "area-line",
      cx: startPoint[0],
      cy: startPoint[1],
      r: lastDist
    }), /* @__PURE__ */ createElementJsx("path", {
      class: "stick",
      d: `
                M ${targetStick[0]} ${targetStick[1]}
                L ${centerStick[0]} ${centerStick[1]}
            `
    }), /* @__PURE__ */ createElementJsx("circle", {
      class: "rotate",
      cx: centerStick[0],
      cy: centerStick[1],
      r: "7",
      "data-center-x": centerPosition[0],
      "data-center-y": centerPosition[1]
    }), this.makeConicGradientPoint(colorsteps, startPoint, endPoint, shapePoint, newHoverColorStepPoint, lastDist + 20, image2.angle)));
  }
  makeRadialCenterPoint(result) {
    let colorsteps, startPoint, endPoint, shapePoint;
    startPoint = this.$viewport.applyVertex(result.startPoint);
    endPoint = this.$viewport.applyVertex(result.endPoint);
    shapePoint = this.$viewport.applyVertex(result.shapePoint);
    colorsteps = this.makeStickPoint(result.colorsteps, startPoint, endPoint);
    let newHoverColorStepPoint = null;
    if (this.state.hoverColorStep) {
      newHoverColorStepPoint = lerp$1([], startPoint, endPoint, this.state.hoverColorStep.percent / 100);
    }
    return /* @__PURE__ */ createElementJsx(FragmentInstance, null, /* @__PURE__ */ createElementJsx("svg", {
      class: "gradient-radial-line"
    }, /* @__PURE__ */ createElementJsx("path", {
      d: `
              M ${startPoint[0]} ${startPoint[1]}
              L ${endPoint[0]} ${endPoint[1]}
          `,
      class: "area-line"
    }), /* @__PURE__ */ createElementJsx("path", {
      d: `
              M ${startPoint[0]} ${startPoint[1]}
              L ${endPoint[0]} ${endPoint[1]}
          `,
      class: "start-end-line"
    }), /* @__PURE__ */ createElementJsx("path", {
      d: `
              M ${startPoint[0]} ${startPoint[1]}
              L ${shapePoint[0]} ${shapePoint[1]}
          `,
      class: "shape-line"
    }), this.makeGradientPoint(colorsteps, startPoint, endPoint, shapePoint, newHoverColorStepPoint)));
  }
  makeStickPoint(colorsteps, startPoint, endPoint) {
    const size2 = TOOL_SIZE;
    const dist2 = subtract([], endPoint, startPoint);
    const angle = calculateAngle360(dist2[0], dist2[1]) - 180;
    const rotateInverse = calculateRotationOriginMat4(-angle, startPoint);
    const rotateInverseInverse = invert([], rotateInverse);
    return colorsteps.map((it) => {
      it.screenXY = this.$viewport.applyVertex(it.pos);
      const [newScreenXY] = vertiesMap([it.screenXY], rotateInverse);
      [it.stickScreenXY, it.stickScreenXYInStart, it.stickScreenXYInEnd] = vertiesMap([
        [newScreenXY[0] - size2 / 2, newScreenXY[1] - size2 * 1.5, 0],
        [
          newScreenXY[0] - size2 / 2,
          newScreenXY[1] - size2 * 1.5 + size2 / 2,
          0
        ],
        [
          newScreenXY[0] + size2 / 2,
          newScreenXY[1] - size2 * 1.5 + size2 / 2,
          0
        ]
      ], rotateInverseInverse);
      return it;
    });
  }
  makeLinearCenterPoint(result) {
    let centerPosition, centerStick, startPoint, endPoint, areaStartPoint, areaEndPoint, colorsteps;
    startPoint = this.$viewport.applyVertex(result.startPoint);
    endPoint = this.$viewport.applyVertex(result.endPoint);
    areaStartPoint = this.$viewport.applyVertex(result.areaStartPoint);
    areaEndPoint = this.$viewport.applyVertex(result.areaEndPoint);
    centerPosition = this.$viewport.applyVertex(result.centerPosition);
    colorsteps = this.makeStickPoint(result.colorsteps, startPoint, endPoint);
    const lastDist = dist(centerPosition, endPoint);
    const [stickPoint] = vertiesMap([endPoint], calculateRotationOriginMat4(90, lerp$1([], startPoint, endPoint, 0.5)));
    centerStick = lerp$1([], centerPosition, lerp$1([], centerPosition, stickPoint, 1 / dist(centerPosition, stickPoint)), lastDist + 20);
    const targetStick = lerp$1([], centerStick, centerPosition, 20 / (lastDist + 20));
    let newHoverColorStepPoint = null;
    if (this.state.hoverColorStep) {
      newHoverColorStepPoint = lerp$1([], startPoint, endPoint, this.state.hoverColorStep.percent / 100);
    }
    return /* @__PURE__ */ createElementJsx("svg", {
      class: "gradient-angle"
    }, /* @__PURE__ */ createElementJsx("path", {
      class: "stick",
      d: `
              M ${targetStick[0]} ${targetStick[1]}
              L ${centerStick[0]} ${centerStick[1]}
          `
    }), /* @__PURE__ */ createElementJsx("circle", {
      class: "size",
      cx: centerPosition[0],
      cy: centerPosition[1],
      r: dist(centerPosition, startPoint)
    }), /* @__PURE__ */ createElementJsx("circle", {
      class: "rotate",
      cx: centerStick[0],
      cy: centerStick[1],
      r: "7",
      "data-center-x": centerPosition[0],
      "data-center-y": centerPosition[1]
    }), /* @__PURE__ */ createElementJsx("path", {
      d: `
              M ${areaStartPoint[0]} ${areaStartPoint[1]}
              L ${areaEndPoint[0]} ${areaEndPoint[1]}
          `,
      class: "area-line"
    }), /* @__PURE__ */ createElementJsx("path", {
      d: `
              M ${startPoint[0]} ${startPoint[1]}
              L ${endPoint[0]} ${endPoint[1]}
          `,
      class: "start-end-line"
    }), this.makeGradientPoint(colorsteps, startPoint, endPoint, null, newHoverColorStepPoint));
  }
  [LOAD("$el") + DOMDIFF]() {
    const current = this.$context.selection.current;
    if (!current)
      return "";
    const result = current.createBackgroundImageMatrix(this.state.index);
    this.state.lastBackgroundMatrix = result;
    const image2 = result.backgroundImage.image;
    switch (image2.type) {
      case GradientType.LINEAR:
      case GradientType.REPEATING_LINEAR:
        this.state.centerPosition = this.$viewport.applyVertex(result.centerPosition);
        this.state.startPoint = this.$viewport.applyVertex(result.startPoint);
        this.state.endPoint = this.$viewport.applyVertex(result.endPoint);
        this.state.rotateInverse = calculateRotationOriginMat4(-1 * result.backgroundImage.image.angle, this.state.centerPosition);
        break;
      case GradientType.RADIAL:
      case GradientType.REPEATING_RADIAL:
        this.state.centerPosition = this.$viewport.applyVertex(result.radialCenterPosition);
        this.state.startPoint = this.$viewport.applyVertex(result.startPoint);
        this.state.endPoint = this.$viewport.applyVertex(result.endPoint);
        break;
      case GradientType.CONIC:
      case GradientType.REPEATING_CONIC:
        this.state.centerPosition = this.$viewport.applyVertex(result.radialCenterPosition);
        this.state.startPoint = this.$viewport.applyVertex(result.shapePoint);
        break;
    }
    return /* @__PURE__ */ createElementJsx("div", null, this.makeGradientRect(result), image2.type === GradientType.STATIC || image2.type === GradientType.IMAGE ? null : this.makeCenterPoint(result));
  }
}
function gradientEditorView(editor) {
  editor.registerUI("canvas.view", {
    GradientEditorView
  });
}
var GuideLineView$1 = "";
const line = (source2, target, className = "base-line") => {
  return `<line x1="${source2[0]}" y1="${source2[1]}" x2="${target[0]}" y2="${target[1]}" class='${className}' />`;
};
const hLineByPoint = (target, source2) => {
  return line(target, source2);
};
const vLineByPoint = (target, source2) => {
  return line(target, source2);
};
const rect = (rectVerties) => {
  return `<path class="base-rect" fill="none" stroke-width="1" stroke="red" stroke-dasharray="2 2" d="${PathParser.makeRect(rectVerties[0][0], rectVerties[0][1], dist(rectVerties[0], rectVerties[1]), dist(rectVerties[0], rectVerties[3])).d}" />`;
};
const point = (target, dist2 = 3, direction2 = "left") => {
  if (direction2 === "left") {
    return `<path class="arrow" d="M ${target[0] + dist2} ${target[1] - dist2} L ${target[0]} ${target[1]} L ${target[0] + dist2} ${target[1] + dist2} "/>`;
  }
  if (direction2 === "right") {
    return `<path class="arrow" d=" M ${target[0] - dist2} ${target[1] - dist2} L ${target[0]} ${target[1]} L ${target[0] - dist2} ${target[1] + dist2}" />`;
  }
  if (direction2 === "up") {
    return `<path class="arrow" d=" M ${target[0] - dist2} ${target[1] + dist2} L ${target[0]} ${target[1]} L ${target[0] + dist2} ${target[1] + dist2}" />`;
  }
  if (direction2 === "down") {
    return `<path class="arrow" d=" M ${target[0] - dist2} ${target[1] - dist2} L ${target[0]} ${target[1]} L ${target[0] + dist2} ${target[1] - dist2}" />`;
  }
  return `<path stroke-width="1" d=" M ${target[0] - dist2} ${target[1] - dist2} L ${target[0] + dist2} ${target[1] + dist2} M ${target[0] - dist2} ${target[1] + dist2} L ${target[0] + dist2} ${target[1] - dist2}" />`;
};
class GuideLineView extends EditorElement {
  template() {
    return `<svg class='elf--guide-line-view' ref="$guide" width="100%" height="100%" ></svg>`;
  }
  initState() {
    return {
      list: []
    };
  }
  [BIND("$guide")]() {
    const line2 = this.createGuideLine(this.state.list);
    return {
      svgDiff: `<g>${line2}</g>`
    };
  }
  createLayerLine() {
    return "";
  }
  filterGuideLine(list2) {
    list2 = list2.filter(Boolean);
    return list2;
  }
  createGuideLine(list2) {
    var images = [];
    var texts = [];
    list2 = this.filterGuideLine(list2);
    for (var i = 0, len2 = list2.length; i < len2; i++) {
      const [
        source2,
        target,
        axis,
        dist$1,
        newTarget,
        sourceVerties,
        targetVerties
      ] = list2[i];
      const localDist = dist(source2, target);
      const localSourceVertex = this.$viewport.applyVertex(source2);
      const localTargetVertex = this.$viewport.applyVertex(target);
      let localNewTargetVertex;
      if (newTarget) {
        localNewTargetVertex = this.$viewport.applyVerties([newTarget])[0];
      }
      if (axis === "x") {
        if (localDist > 0) {
          images.push(line(localSourceVertex, localTargetVertex, "dash-line"));
        }
        if (localNewTargetVertex) {
          images.push(line(localTargetVertex, localNewTargetVertex, "dash-line"));
        }
      }
      if (axis === "y") {
        if (localDist > 0) {
          images.push(line(localSourceVertex, localTargetVertex, "dash-line"));
        }
        if (localNewTargetVertex) {
          images.push(line(localTargetVertex, localNewTargetVertex, "dash-line"));
        }
      }
      if (axis === "x") {
        images.push(hLineByPoint(localTargetVertex, localSourceVertex));
      }
      if (axis === "y") {
        images.push(vLineByPoint(localTargetVertex, localSourceVertex));
      }
      if (this.state.hasVerties) {
        images.push(point(localSourceVertex, 3, "vertex"));
        images.push(point(localTargetVertex, 3, "vertex"));
      }
      if (sourceVerties) {
        if (this.$context.selection.isOne && this.$editor.isPointerDown || this.$context.selection.isMany && !this.$editor.isPointerMove) {
          images.push(rect(this.$viewport.applyVerties(sourceVerties)));
        }
      }
      if (targetVerties) {
        images.push(rect(this.$viewport.applyVerties(targetVerties)));
      }
    }
    return [...images, ...texts].join("");
  }
  removeGuideLine() {
    this.setState({
      list: []
    });
  }
  setGuideLine(list2, hasVerties = false) {
    this.setState({
      list: list2,
      hasVerties
    });
  }
  [SUBSCRIBE("removeGuideLine", REFRESH_SELECTION)]() {
    this.removeGuideLine();
  }
  [SUBSCRIBE("refreshGuideLineByTarget")](targetVertiesList = []) {
    return this.refreshSmartGuides(targetVertiesList);
  }
  [SUBSCRIBE(UPDATE_VIEWPORT)]() {
    this.refreshSmartGuidesForVerties(1);
  }
  refreshSmartGuides(targetVertiesList) {
    if (this.$context.selection.isEmpty)
      return;
    const sourceVerties = toRectVerties(this.$context.selection.verties);
    let targetList;
    if (targetVertiesList) {
      targetList = targetVertiesList.map((it) => toRectVerties(it));
    } else {
      const targets = this.$context.snapManager.snapTargetLayers.map((target) => {
        const rectVerties = toRectVerties(target.verties);
        return {
          targetVerties: rectVerties,
          dist: dist(rectVerties[4], sourceVerties[4])
        };
      });
      targets.sort((a, b) => {
        return a.dist - b.dist;
      });
      targetList = targets.map((target) => target.targetVerties);
    }
    const xList = targetList.map((targetVerties) => makeGuidePoint(sourceVerties, targetVerties));
    xList.sort((a, b) => {
      return a[3] - b[3];
    });
    const list2 = [xList[0], xList[1]].filter(Boolean);
    this.setGuideLine(list2);
  }
  refreshSmartGuidesForVerties(dist2 = 0) {
    let verties = this.$context.selection.verties;
    if (verties.length) {
      verties = [
        ...verties,
        lerp$1([], verties[0], verties[1], 0.5),
        lerp$1([], verties[1], verties[2], 0.5),
        lerp$1([], verties[2], verties[3], 0.5),
        lerp$1([], verties[3], verties[0], 0.5)
      ];
    }
    const guides = this.$context.snapManager.findGuide(verties, dist2);
    this.setGuideLine(guides, true);
  }
  [SUBSCRIBE(UPDATE_CANVAS)]() {
    const expect = this.$context.selection.hasChangedField("d", "clip-path");
    if (!expect) {
      this.refreshSmartGuidesForVerties(1 / this.$viewport.scale);
    }
  }
}
function guideLineView(editor) {
  editor.registerUI("canvas.view", {
    GuideLineView
  });
}
var HistoryProperty$1 = "";
class HistoryProperty extends BaseProperty {
  afterRender() {
    this.show();
  }
  getTitle() {
    return "History";
  }
  getBody() {
    return `
      <div class="elf--history-list-view" ref='$body'></div>
    `;
  }
  [LOAD("$body") + DOMDIFF]() {
    return this.$editor.context.history.map((it, index2) => {
      if (it === "-") {
        return `<div class='divider'>-</div>`;
      }
      return `
        <div class='history-item'>
          <span>${index2 === this.$editor.context.history.currentIndex ? obj$3.arrowRight : ""}</span>
          <span>${it.message}</span>
        </div>
      `;
    });
  }
  [SUBSCRIBE("refreshHistoryList")]() {
    this.refresh();
  }
}
function history(editor) {
  editor.registerUI("inspector.tab.history", {
    HistoryProperty
  });
}
var HoverView$1 = "";
class HoverView extends EditorElement {
  template() {
    return /* @__PURE__ */ createElementJsx("div", {
      class: "elf--hover-view sepia(0.2)"
    }, /* @__PURE__ */ createElementJsx("div", {
      class: "elf--hover-rect",
      ref: "$hoverRect"
    }));
  }
  checkModeView() {
    const e = this.$config.get("bodyEvent");
    if (!this.$viewport.checkInViewport(this.$viewport.getWorldPosition(e))) {
      return false;
    }
    const canvas = Dom.create(e.target).closest("elf--page-container");
    if (!canvas)
      return false;
    return this.$modeView.isCurrentMode(ViewModeType.CanvasView) && this.$stateManager.isPointerUp;
  }
  [CONFIG("bodyEvent") + IF("checkModeView")]() {
    var _a, _b, _c;
    if (this.$config.true("set.move.control.point")) {
      this.$context.selection.setHoverId("");
      this.renderHoverLayer();
      return;
    }
    const filteredList = this.$context.selection.filteredLayers;
    const point2 = this.$viewport.getWorldPosition(this.$config.get("bodyEvent"));
    const items = filteredList.filter((it) => it.hasPoint(point2[0], point2[1])).filter((it) => it.isNot("artboard"));
    let hoverItems = items;
    let id = (_a = hoverItems[0]) == null ? void 0 : _a.id;
    if (this.$context.selection.isEmpty) {
      id = (_b = hoverItems[0]) == null ? void 0 : _b.id;
    } else if (this.$context.selection.isOne) {
      const pathIds = this.$context.selection.current.pathIds;
      hoverItems = hoverItems.filter((it) => pathIds.includes(it.id) === false || it.id === this.$context.selection.current.id);
      id = (_c = hoverItems[0]) == null ? void 0 : _c.id;
    }
    if (!id) {
      this.$context.selection.setHoverId("");
      this.renderHoverLayer();
    } else {
      if (this.$context.selection.setHoverId(id)) {
        this.renderHoverLayer();
      }
    }
  }
  [CONFIG("set.move.control.point")]() {
    this.renderHoverLayer();
  }
  [SUBSCRIBE("refreshHoverView")](id) {
    if (this.$context.selection.setHoverId(id)) {
      this.renderHoverLayer();
    }
  }
  [SUBSCRIBE(UPDATE_VIEWPORT, UPDATE_CANVAS)]() {
    this.$context.selection.setHoverId("");
    this.renderHoverLayer();
  }
  createVisiblePath(current) {
    if (!current.is("boolean-path")) {
      return "";
    }
    const newPath = current.absolutePath();
    newPath.transformMat4(this.$viewport.matrix);
    return `
        <svg overflow="visible">
            <path
                d="${newPath.d}"
                stroke="red"
                stroke-width="2"
                fill="none"
                />
        </svg>
        `;
  }
  renderHoverLayer() {
    const items = this.$context.selection.hoverItems;
    if (items.length === 0) {
      this.refs.$hoverRect.updateDiff("");
    } else {
      const verties = items[0].verties;
      const line2 = this.createPointerLine(this.$viewport.applyVerties(verties));
      const offsetLine = this.createOffsetLine();
      this.refs.$hoverRect.updateDiff(line2 + offsetLine);
    }
  }
  getOffsetVerties(current, parent) {
    const currentVerties = current.verties;
    const parentVerties = parent.verties;
    const result = {};
    const left2 = this.$viewport.applyVerties([
      [
        currentVerties[0][0],
        lerp$1([], currentVerties[0], currentVerties[3], 0.5)[1],
        0
      ],
      [
        parentVerties[0][0],
        lerp$1([], currentVerties[0], currentVerties[3], 0.5)[1],
        0
      ]
    ]);
    var dist$1 = dist(...left2);
    if (dist$1 > 0) {
      result.left = left2;
    }
    const top2 = this.$viewport.applyVerties([
      [
        lerp$1([], currentVerties[0], currentVerties[1], 0.5)[0],
        currentVerties[1][1],
        0
      ],
      [
        lerp$1([], currentVerties[0], currentVerties[1], 0.5)[0],
        parentVerties[1][1],
        0
      ]
    ]);
    var dist$1 = dist(...top2);
    if (dist$1 > 0) {
      result.top = top2;
    }
    return result;
  }
  createOffsetLine() {
    const item = this.$context.selection.hoverItems[0] || this.$context.selection.current;
    if (!item || !item.parent) {
      return "";
    }
    if (item.parent && item.parent.is("project")) {
      return "";
    }
    if (this.$context.selection.isEmpty) {
      const offsetVerties = this.getOffsetVerties(item, item.parent);
      return `
            <svg overflow="visible">
                <path
                    class="offset-line"
                    d="
                        ${vertiesToPath(offsetVerties.left)}
                        ${vertiesToPath(offsetVerties.right)}
                        ${vertiesToPath(offsetVerties.top)}
                        ${vertiesToPath(offsetVerties.bottom)}
                    "
                    />
            </svg>
            `;
    } else {
      const offsetVerties = this.getOffsetVerties(item, this.$context.selection.current);
      return `
            <svg overflow="visible">
                <path
                    d="
                        ${vertiesToPath(offsetVerties.left)}
                        ${vertiesToPath(offsetVerties.top)}
                    "
                    stroke="red"
                    stroke-width="1"
                    stroke-dasharray="5, 10"
                    fill="none"
                    />
            </svg>
            `;
    }
  }
  createPointerLine(pointers) {
    if (pointers.length === 0)
      return "";
    pointers = pointers.filter((_, index2) => index2 < 4);
    return `<svg overflow="visible"><path class='line' d="${vertiesToPath(pointers)}" /></svg>`;
  }
}
function hoverView(editor) {
  editor.registerUI("canvas.view", {
    HoverView
  });
}
const image_size = [
  "",
  "100x100",
  "200x200",
  "300x300",
  "400x300",
  "900x600",
  "1024x762"
];
class ImageProperty extends BaseProperty {
  getClassName() {
    return "item";
  }
  getTitle() {
    return this.$i18n("image.property.title");
  }
  getBody() {
    return `<div ref='$body' style='padding-top: 3px;'></div>`;
  }
  getFooter() {
    return `
      <div>
        <label> ${this.$i18n("image.property.origin")} </label> 
        <span ref='$sizeInfo'></span> 
        <button type="button" ref='$resize'>${iconUse("size")}</button>
      </div>
      <div>
        ${createComponent("SelectEditor", {
      ref: "$select",
      label: this.$i18n("image.property.size"),
      key: "size",
      value: "",
      options: image_size,
      onchange: "changeImageSize"
    })}

      </div>
    `;
  }
  [SUBSCRIBE_SELF("changeImageSize")](key, value) {
    var [width2, height2] = value.split("x").map((it) => it);
    this.$commands.executeCommand("setAttribute", "resize image", this.$context.selection.packByValue({
      width: width2,
      height: height2
    }));
  }
  [CLICK("$resize")]() {
    var current = this.$context.selection.current;
    if (current) {
      this.$commands.executeCommand("setAttribute", "resize image", this.$context.selection.packByValue({
        width: (item) => item.naturalWidth.clone(),
        height: (item) => item.naturalHeight.clone()
      }));
    }
  }
  [BIND("$sizeInfo")]() {
    var current = this.$context.selection.current || {};
    return {
      innerHTML: `${this.$i18n("image.property.width")}: ${current.naturalWidth}, ${this.$i18n("image.property.height")}: ${current.naturalHeight}`
    };
  }
  [LOAD("$body")]() {
    var current = this.$context.selection.current || {};
    var src = current.src || "";
    return createComponent("ImageSelectEditor", {
      ref: "$1",
      key: "src",
      value: src,
      onchange: "changeSelect"
    });
  }
  [SUBSCRIBE_SELF("changeSelect")](key, value, info) {
    var current = this.$context.selection.current;
    if (current) {
      current.reset(__spreadValues({
        src: value
      }, info));
      this.bindData("$sizeInfo");
      this.$commands.executeCommand("setAttribute", "change image", this.$context.selection.packByValue(__spreadValues({
        src: value
      }, info)));
    }
  }
  [SUBSCRIBE(REFRESH_SELECTION) + DEBOUNCE(100)]() {
    this.refreshShow(["image"]);
  }
}
var ImageSelectEditor$1 = "";
class ImageSelectEditor extends EditorElement {
  initState() {
    return {
      key: this.props.key,
      value: this.props.value
    };
  }
  template() {
    return /* @__PURE__ */ createElementJsx("div", {
      class: "elf--image-select-editor",
      ref: "$body"
    });
  }
  getValue() {
    return this.state.value;
  }
  setValue(value) {
    this.setState({ value });
  }
  [LOAD("$body")]() {
    const project2 = this.$context.selection.currentProject;
    if (!project2)
      return;
    const imageUrl = project2.getImageValueById(this.state.value);
    return /* @__PURE__ */ createElementJsx(FragmentInstance, null, /* @__PURE__ */ createElementJsx("div", {
      class: "preview-container"
    }, imageUrl ? /* @__PURE__ */ createElementJsx("img", {
      src: imageUrl
    }) : null, /* @__PURE__ */ createElementJsx("input", {
      type: "file",
      ref: "$file",
      accept: "image/*"
    })), /* @__PURE__ */ createElementJsx("div", {
      class: "select-container"
    }, /* @__PURE__ */ createElementJsx("button", {
      type: "button",
      ref: "$select"
    }, this.$i18n("image.select.editor.button"))));
  }
  [CHANGE("$file")](e) {
    var files = [...e.target.files];
    if (files.length) {
      this.$commands.emit("updateImageAssetItem", files[0], (imageId) => {
        this.trigger("changeImageSelectEditor", imageId);
      });
    }
  }
  [CLICK("$select")]() {
    this.emit("showImageSelectPopup", {
      context: this,
      changeEvent: "changeImageSelectEditor",
      value: this.state.value
    });
  }
  [SUBSCRIBE("changeImageSelectEditor")](value) {
    this.updateData({ value });
    this.refresh();
  }
  updateData(data) {
    this.setState(data, false);
    this.parent.trigger(this.props.onchange, this.props.key, this.state.value, this.props.params);
  }
}
var ImageSelectPopup$1 = "";
class ImageSelectPopup extends BasePopup {
  getTitle() {
    return "Select a image";
  }
  getClassName() {
    return "compact";
  }
  initState() {
    return {
      value: ""
    };
  }
  updateData(opt = {}) {
    this.setState(opt, false);
    this.state.context.trigger(this.state.changeEvent, this.state.value, {
      width: this.state.width,
      height: this.state.height,
      naturalWidth: this.state.naturalWidth,
      naturalHeight: this.state.naturalHeight
    });
  }
  getBody() {
    return `<div class="elf--image-select-popup"><div class='box' ref='$imageBox'></div></div>`;
  }
  [LOAD("$imageBox") + DOMDIFF]() {
    return "";
  }
  [CLICK("$imageBox .image-item")](e) {
    var $img = e.$dt.$("img");
    this.updateData({
      value: $img.attr("data-id"),
      naturalWidth: $img.naturalWidth,
      naturalHeight: $img.naturalHeight,
      width: $img.naturalWidth,
      height: $img.naturalHeight
    });
    this.trigger("hideImageSelectPopup");
  }
  [SUBSCRIBE("showImageSelectPopup")](data, params) {
    this.setState({
      context: data.context,
      changeEvent: data.changeEvent,
      value: data.value,
      params
    }, false);
    this.refresh();
    this.show(500);
  }
  [SUBSCRIBE("hideImageSelectPopup")]() {
    this.hide();
  }
}
function image(editor) {
  editor.registerElement({
    ImageSelectEditor
  });
  editor.registerUI("inspector.tab.style", {
    ImageProperty
  });
  editor.registerUI("popup", {
    ImageSelectPopup
  });
}
class ImageAssetPicker extends EditorElement {
  initState() {
    return {
      mode: "grid"
    };
  }
  template() {
    return `
      <div class='image-asset-picker'>
        <div class='image-list' ref='$imageList' data-view-mode='${this.state.mode}'></div>
      </div>
    `;
  }
  [LOAD("$imageList") + DOMDIFF]() {
    var current = this.$context.selection.currentProject || { images: [] };
    var images = current.images;
    var results = images.map((image2) => {
      return `
        <div class='image-item'>
          <div class='preview'>
            <img src="${image2.local}" />
          </div>
        </div>
      `;
    });
    return results;
  }
  [CLICK("$imageList .image-item")](e) {
    var $img = e.$dt.$("img");
    this.updateData($img.attr("src"));
  }
  updateData(localUrl) {
    this.parent.trigger(this.props.onchange, localUrl);
  }
  [SUBSCRIBE("addImageAsset")]() {
    this.refresh();
  }
}
var ImageAssetsProperty$1 = "";
function revokeObjectUrl(url) {
  window.URL.revokeObjectURL(url);
}
class ImageAssetsProperty extends BaseProperty {
  getTitle() {
    return this.$i18n("image.asset.property.title");
  }
  initState() {
    return {
      mode: "grid"
    };
  }
  getClassNamef() {
    return "elf--image-assets-property";
  }
  afterRender() {
    this.show();
  }
  getBody() {
    return `
      <div class='property-item image-assets'>
        <div class='image-list' ref='$imageList' data-view-mode='${this.state.mode}'></div>
      </div>
    `;
  }
  [LOAD("$imageList") + DOMDIFF]() {
    var current = this.$context.selection.currentProject || { images: [] };
    var images = current.images;
    var results = images.map((image2, index2) => {
      return `
        <div class='image-item' data-index="${index2}">
          <div class='preview' draggable="true">
            <img src="${image2.local}" />
          </div>
          <div class='tools'>
            <button type="button" class='copy'>${obj$3.copy}</button>          
            <button type="button" class='remove'>${obj$3.remove}</button>
          </div>
        </div>
      `;
    });
    return `
      <div class='loaded-list'>
        ${results.join("")}
        <div class='add-image-item'>
          <input type='file' accept='image/*' ref='$file' />
          <button type="button">${obj$3.add}</button>
        </div>        
      </div>

    `;
  }
  executeImage(callback, isRefresh = true, isEmit = true) {
    var project2 = this.$context.selection.currentProject;
    if (project2) {
      callback && callback(project2);
      if (isRefresh)
        this.refresh();
      if (isEmit)
        this.emit("refreshImageAssets");
    } else {
      window.alert("Please select a project.");
    }
  }
  [DRAGSTART("$imageList .preview img")](e) {
    var index2 = +e.$dt.closest("image-item").attr("data-index");
    var project2 = this.$context.selection.currentProject;
    if (project2) {
      var imageInfo = project2.images[index2];
      e.dataTransfer.setData("image/info", imageInfo.local);
    }
  }
  [CHANGE("$imageList .add-image-item input[type=file]")](e) {
    this.executeImage(() => {
      [...e.target.files].forEach((item) => {
        this.$commands.emit("updateImageAssetItem", item);
      });
    });
  }
  [CLICK("$imageList .remove")](e) {
    var $item = e.$dt.closest("image-item");
    var index2 = +$item.attr("data-index");
    this.executeImage((project2) => {
      project2.removeImage(index2);
      revokeObjectUrl($item.$(".preview img").attr("src"));
    });
  }
  [CLICK("$imageList .copy")](e) {
    var $item = e.$dt.closest("image-item");
    var index2 = +$item.attr("data-index");
    this.executeImage((project2) => {
      project2.copyImage(index2);
    });
  }
  [SUBSCRIBE("addImageAsset")]() {
    this.refresh();
  }
}
function imageAsset(editor) {
  editor.registerElement({
    ImageAssetPicker,
    ImageAssetsProperty
  });
}
var KeyframePopup$1 = "";
class KeyframePopup extends BasePopup {
  getTitle() {
    return this.$i18n("keyframe.popup.title");
  }
  initState() {
    return {
      name: "none",
      offsets: []
    };
  }
  updateData(opt) {
    this.setState(opt, false);
    this.emit("changeKeyframePopup", this.state);
  }
  getBody() {
    return `
    <div class='elf--keyframe-popup' ref='$popup'>
      <div class="box">
        ${this.templateForName()}
        ${this.templateForOffset()}
      </div>
    </div>`;
  }
  templateForOffset() {
    return `
      <div>
        ${createComponent("OffsetEditor", { ref: "$offsetEditor" })}
      </div>
    `;
  }
  templateForName() {
    return `
      <div class='name'>
        <label>Name</label>
        <div class='input grid-1'>
          <input type='text' value='${this.state.name}' ref='$name'/>
        </div>
      </div>
    `;
  }
  [INPUT("$name")](e) {
    if (this.refs.$name.value.match(/^[a-zA-Z0-9\b]+$/)) {
      this.updateData({ name: this.refs.$name.value });
    } else {
      e.preventDefault();
      e.stopPropagation();
      return false;
    }
  }
  getOffsetData() {
    var offsets = this.state.offsets.map((it) => it);
    return { offsets };
  }
  refresh() {
    this.refs.$name.val(this.state.name);
    this.emit("showOffsetEditor", this.getOffsetData());
  }
  [SUBSCRIBE("changeOffsetEditor")](data) {
    this.updateData(data);
  }
  [SUBSCRIBE("showKeyframePopup")](data) {
    this.setState(data);
    this.refresh();
    this.show(240);
  }
  [SUBSCRIBE("hideKeyframePopup")]() {
    this.$el.hide();
  }
}
var KeyframeProperty$1 = "";
class KeyframeProperty extends BaseProperty {
  getTitle() {
    return this.$i18n("keyframe.property.title");
  }
  getBody() {
    return `<div class='elf--keyframe-list' ref='$keyframeList'></div>`;
  }
  getTools() {
    return `
      <button type="button" ref="$add" title="add Filter">${obj$3.add}</button>
    `;
  }
  makeProperty(property) {
    var key = property.key;
    if (key === "x")
      key = "left";
    else if (key === "y")
      key = "top";
    return `
      <div class='offset-property-item'>
        <label>${key}:</label>
        <div class='value'>${property.value}</div>
      </div>
    `;
  }
  makeOffset(offset) {
    return `
      <div class='offset'>
        <label>${offset.offset}</label>
        <div class='properties'>
          ${offset.properties.map((p) => {
      return this.makeProperty(p);
    }).join("")}
        </div>        
      </div>
    `;
  }
  makeKeyframeTemplate(keyframe2, index2) {
    index2 = index2.toString();
    return `
      <div class='keyframe-item' data-selected-value='${keyframe2.selectedType}' ref='$keyframeIndex${index2}' data-index='${index2}'>
        <div class='title'>
          <div class='name'>${keyframe2.name}</div>
          <div class='tools'>
            <div class='group'>
              <button type="button" data-type='list'>${obj$3.list}</button>
              <button type="button" data-type='code'>${obj$3.code}</button>
            </div>
            <button type="button" class="del" data-index="${index2}">${obj$3.remove2}</button>
          </div>
        </div>
        <div class='offset-list'>
          <div class='container'>
            ${keyframe2.offsets.map((o) => {
      return `
              <div class='offset' style='left: ${o.offset}; background-color: ${o.color}'></div>
              `;
    }).join("")}
          </div>
        </div>
        <div class='keyframe-code' data-type='list'>
          ${keyframe2.offsets.map((offset) => {
      return this.makeOffset(offset);
    }).join("")}
        </div>
        <div class='keyframe-code' data-type='code'>
          <pre>${keyframe2.toString().trim()}</pre>
        </div>        
      </div>
    `;
  }
  [CLICK("$keyframeList .keyframe-item .title .group button[data-type]")](e) {
    var $keyframeItem = e.$dt.closest("keyframe-item");
    var index2 = +$keyframeItem.attr("data-index");
    var type = e.$dt.attr("data-type");
    var current = this.$context.selection.currentProject;
    if (!current)
      return;
    var currentKeyframe = current.keyframes[index2];
    if (currentKeyframe) {
      currentKeyframe.reset({
        selectedType: type
      });
    }
    $keyframeItem.attr("data-selected-value", type);
  }
  [CLICK("$keyframeList .keyframe-item .offset-list")](e) {
    var index2 = +e.$dt.closest("keyframe-item").attr("data-index");
    var current = this.$context.selection.currentProject;
    if (!current)
      return;
    this.viewKeyframePicker(index2);
  }
  [CLICK("$keyframeList .del") + PREVENT](e) {
    var removeIndex = e.$dt.attr("data-index");
    var current = this.$context.selection.currentProject;
    if (!current)
      return;
    current.removeKeyframe(removeIndex);
    this.$commands.emit("refreshProject", current);
    this.refresh();
  }
  [SUBSCRIBE(REFRESH_SELECTION) + DEBOUNCE(100)]() {
    const current = this.$context.selection.current;
    if (current && current.hasChangedField("keyframes")) {
      this.refresh();
    }
  }
  [LOAD("$keyframeList")]() {
    var current = this.$context.selection.currentProject;
    if (!current)
      return "";
    var keyframes = current.keyframes || [];
    return keyframes.map((keyframe2, index2) => {
      return this.makeKeyframeTemplate(keyframe2, index2);
    });
  }
  [CLICK("$add")]() {
    var current = this.$context.selection.currentProject;
    if (current) {
      current.createKeyframe();
      this.refresh();
      this.$commands.emit("refreshProject", current);
    } else {
      window.alert("Please select a project.");
    }
  }
  viewKeyframePicker(index2) {
    if (typeof this.selectedIndex === "number") {
      this.selectItem(this.selectedIndex, false);
    }
    this.selectedIndex = +index2;
    this.selectItem(this.selectedIndex, true);
    this.current = this.$context.selection.currentProject;
    if (!this.current)
      return;
    this.currentKeyframe = this.current.keyframes[this.selectedIndex];
    this.viewKeyframePropertyPopup();
  }
  selectItem(selectedIndex, isSelected = true) {
    if (isSelected) {
      this.getRef("$keyframeIndex", selectedIndex).addClass("selected");
    } else {
      this.getRef("$keyframeIndex", selectedIndex).removeClass("selected");
    }
    if (this.current) {
      this.current.keyframes.forEach((it, index2) => {
        it.selected = index2 === selectedIndex;
      });
    }
  }
  viewKeyframePropertyPopup(position2) {
    this.current = this.$context.selection.currentProject;
    if (!this.current)
      return;
    this.currentKeyframe = this.current.keyframes[this.selectedIndex];
    const back = this.currentKeyframe;
    const name = back.name;
    const offsets = back.offsets;
    this.emit("showKeyframePopup", {
      position: position2,
      name,
      offsets
    });
  }
  [SUBSCRIBE("changeKeyframePopup")](data) {
    var project2 = this.$context.selection.currentProject;
    if (!project2)
      return;
    this.currentKeyframe = project2.keyframes[this.selectedIndex];
    if (this.currentKeyframe) {
      this.currentKeyframe.reset(data);
    }
    this.refresh();
    this.$commands.emit("refreshProject", project2);
  }
}
class OffsetEditor extends EditorElement {
  initState() {
    return {
      offsets: []
    };
  }
  updateData(opt) {
    this.setState(opt, false);
    this.modifyOffset();
  }
  modifyOffset() {
    this.emit("changeOffsetEditor", this.state);
  }
  template() {
    return `
    <div class='editor offset-editor' ref='$editor'>
        ${this.templateForOffset()}
        ${this.templateForOffsetInput()}
        ${this.templateForProperty()}        
    </div>`;
  }
  templateForOffsetInput() {
    return `
      <div class='offset-input' >
        <div class='title'>
          <label>Offset</label>
          <div class='tools'>
            ${createComponent("InputRangeEditor", {
      key: "offset",
      min: 0,
      max: 100,
      step: 0.01,
      value: Length.percent(0),
      ref: "$offsetInput",
      units: "%",
      onchange: "changeRangeEditor"
    })}
          </div>
        </div>
      </div>
    `;
  }
  [SUBSCRIBE("changeRangeEditor")](key, value) {
    var offset = this.state.offsets[this.selectedIndex];
    if (offset) {
      offset.offset = value.clone();
      this.refresh();
      this.modifyOffset();
    }
  }
  templateForProperty() {
    return createComponent("CSSPropertyEditor", {
      ref: "$offsetPropertyEditor",
      "hide-refresh": true,
      onchange: "changeCSSPropertyEditor"
    });
  }
  templateForOffset() {
    return `<div class='offset' ref='$offset' data-selected-value="-1"></div>`;
  }
  makeOffset(offset, index2) {
    return `<div class='offset-item' style='left: ${offset.offset};' data-offset-index='${index2.toString()}'></div>`;
  }
  selectItem(selectedIndex) {
    if (isUndefined(selectedIndex)) {
      selectedIndex = -1;
      for (var i = 0, len2 = this.state.offsets.length; i < len2; i++) {
        if (this.state.offsets[i].selected) {
          selectedIndex = i;
          break;
        }
      }
      if (selectedIndex === -1) {
        selectedIndex = 0;
      }
    }
    this.getRef("$offset").attr("data-selected-value", selectedIndex);
    this.selectedIndex = selectedIndex;
    this.state.offsets.forEach((it, index2) => {
      it.selected = index2 === selectedIndex;
    });
    var selectedList = this.state.offsets.filter((it) => it.selected);
    this.selectedOffsetItem = selectedList.length ? selectedList[0] : {};
    this.refreshOffsetInput();
  }
  refreshOffsetInput() {
    var offset = this.state.offsets[this.selectedIndex];
    if (offset) {
      this.children.$offsetInput.setValue(offset.offset);
    }
  }
  [LOAD("$offset")]() {
    return this.state.offsets.map((it, index2) => {
      return this.makeOffset(it, index2);
    });
  }
  isNotOffsetItem(e) {
    return !Dom.create(e.target).hasClass("offset-item") && !this.currentOffset;
  }
  [CLICK("$offset") + IF("isNotOffsetItem") + PREVENT](e) {
    this.baseOffsetWidth = this.refs.$offset.width();
    this.baseOffsetArea = this.refs.$offset.offset();
    var currentX = e.xy.x;
    var newOffset = Length.percent((currentX - this.baseOffsetArea.left) / this.baseOffsetWidth * 100).round(100);
    this.state.offsets.push(new Offset({
      offset: newOffset
    }));
    this.selectItem(this.state.offsets.length - 1, true);
    this.refresh();
    this.modifyOffset();
  }
  refreshOffsetProperty() {
    this.emit("showCSSPropertyEditor", this.selectedOffsetItem.properties);
  }
  [POINTERSTART("$offset .offset-item") + MOVE("moveOffset") + END("endOffset")](e) {
    this.baseOffsetWidth = this.refs.$offset.width();
    this.baseOffsetArea = this.refs.$offset.offset();
    this.currentOffsetleft = Length.parse(e.$dt.css("left"));
    this.currentOffset = e.$dt;
    this.currentOffsetIndex = +e.$dt.attr("data-offset-index");
    this.currentOffsetXY = e.xy;
    this.baseOffsetMin = this.baseOffsetArea.left;
    this.baseOffsetMax = this.baseOffsetArea.left + this.baseOffsetWidth;
    this.isRemoveOffset = false;
    if (e.altKey) {
      this.isRemoveOffset = true;
    } else {
      this.selectItem(this.currentOffsetIndex, true);
      this.refreshOffsetInput();
    }
  }
  moveOffset(dx) {
    if (this.isRemoveOffset)
      return;
    var currentX = this.currentOffsetXY.x + dx;
    if (currentX < this.baseOffsetMin) {
      currentX = this.baseOffsetMin;
    }
    if (currentX > this.baseOffsetMax) {
      currentX = this.baseOffsetMax;
    }
    var newOffset = Length.percent((currentX - this.baseOffsetMin) / this.baseOffsetWidth * 100).round(100);
    this.state.offsets[this.currentOffsetIndex].offset.set(newOffset.value);
    this.currentOffset.css("left", newOffset);
    this.refreshOffsetInput();
    this.modifyOffset();
  }
  removeOffset(index2) {
    this.state.offsets.splice(index2, 1);
    this.selectItem(0);
    this.refresh();
    this.modifyOffset();
  }
  endOffset() {
    if (this.isRemoveOffset) {
      window.setTimeout(() => {
        this.currentOffset = null;
        this.removeOffset(this.currentOffsetIndex);
      }, 10);
    } else {
      window.setTimeout(() => {
        this.currentOffset = null;
        this.refreshOffsetInput();
        this.refreshOffsetProperty();
        this.modifyOffset();
      }, 10);
    }
  }
  refresh() {
    this.load();
    this.refreshOffsetProperty();
  }
  [SUBSCRIBE("showOffsetEditor")](data) {
    this.setState(data);
    this.selectItem();
    this.refresh();
  }
  [SUBSCRIBE("changeCSSPropertyEditor")](properties = []) {
    var offset = this.state.offsets[this.selectedIndex];
    if (offset) {
      offset.properties = [...properties];
    }
    this.modifyOffset();
  }
}
function keyframe(editor) {
  editor.registerElement({
    OffsetEditor
  });
  editor.registerUI("inspector.tab.transition", {
    KeyframeProperty
  });
  editor.registerUI("popup", {
    KeyframePopup
  });
}
var LayerAppendView$1 = "";
class LayerAppendView extends EditorElement {
  template() {
    return `
        <div class='elf--layer-append-view'>
            <div class='area' ref='$area'></div>
            <div class='area-rect' ref='$areaRect'></div>
            <div class='area-pointer' ref='$mousePointer'></div>
            <div class='area-pointer-view' ref='$mousePointerView'></div>            
            <input type='file' accept='image/*' multiple="true" ref='$file' class='embed-file-input'/>
            <input type='file' accept='video/*' multiple="true" ref='$video' class='embed-video-input'/>            
        </div>
        `;
  }
  initState() {
    return {
      dragStart: false,
      width: 0,
      height: 0,
      color: "black",
      fontSize: 30,
      showRectInfo: false,
      areaVerties: rectToVerties(0, 0, 0, 0),
      content: "Insert a text",
      pathManager: new PathStringManager(),
      rect: {},
      options: {},
      containerItem: void 0,
      patternInfo: {}
    };
  }
  get scale() {
    return this.$viewport.scale;
  }
  checkNotDragStart() {
    return Boolean(this.state.dragStart) === false;
  }
  [POINTERMOVE("$el") + IF("checkNotDragStart")](e) {
    const vertex2 = this.$viewport.getWorldPosition(e);
    const newVertex = this.$context.snapManager.checkPoint(vertex2);
    if (equals$2(newVertex, vertex2) === false) {
      this.state.target = newVertex;
      this.state.targetVertex = this.$viewport.applyVertex(this.state.target);
      this.state.targetPositionVertex = clone(this.state.target);
      this.state.targetGuides = this.$context.snapManager.findGuideOne([
        this.state.target
      ]);
    } else {
      this.state.target = floor([], vertex2);
      this.state.targetVertex = floor([], this.$viewport.applyVertex(this.state.target));
      this.state.targetGuides = [];
      this.state.targetPositionVertex = null;
    }
    this.bindData("$mousePointer");
    this.bindData("$mousePointerView");
  }
  [POINTERSTART("$el") + MOVE() + END() + PREVENT + STOP](e) {
    this.initMousePoint = this.state.targetPositionVertex ? this.state.targetPositionVertex : this.$viewport.getWorldPosition(e);
    this.state.dragStart = true;
    this.state.color = "#C4C4C4";
    this.state.text = "";
    const minX = this.initMousePoint[0];
    const minY = this.initMousePoint[1];
    const verties = rectToVerties(minX, minY, 0, 0);
    this.state.areaVerties = this.$viewport.applyVerties(verties);
    this.bindData("$area");
    this.bindData("$areaRect");
  }
  createLayerTemplate(width2, height2) {
    const { type, text: text2, color: color2, inlineStyle } = this.state;
    switch (type) {
      case "artboard":
        return `<div class='draw-item' style='background-color: white; ${inlineStyle}'></div>`;
      case "rect":
        return `<div class='draw-item' style='background-color: ${color2}; ${inlineStyle}'></div>`;
      case "circle":
        return `<div class='draw-item' style='background-color: ${color2}; border-radius: 100%; ${inlineStyle}'></div>`;
      case "text":
      case "svg-text":
        return `
                <div 
                    class='draw-item' 
                    
                    style='font-size: 30px;outline: 1px solid blue;white-space:nowrap'
                >
                    <p contenteditable="true" style="margin:0px;display: inline-block;outline:none;" ></p>
                </div>`;
      case "svg-rect":
        return `
            <div class='draw-item'>
                <svg width="${width2}" height="${height2}" style="width:100%; height:100%;" overflow="visible">
                    <path d="${PathParser.makeRect(0, 0, width2, height2).d}" stroke-width="1" stroke="black" fill="transparent" />
                </svg>
            </div>
            `;
      case "svg-circle":
        return `
            <div class='draw-item'>
                <svg width="${width2}" height="${height2}" style="width:100%; height:100%;" overflow="visible">
                    <path d="${PathParser.makeCircle(0, 0, width2, height2).d}" stroke-width="1" stroke="black" fill="transparent" />
                </svg>
            </div>
            `;
      case "svg-path":
        const newD = this.state.d.clone().scale(width2 / this.state.bboxRect.width, height2 / this.state.bboxRect.height).d;
        const options2 = this.state.options;
        return `
            <div class='draw-item'>
                <svg width="${width2}" height="${height2}" style="width:100%; height:100%;" overflow="visible">
                    <path   d="${newD}" 
                            stroke-width="${options2["stroke-width"] || 1}" 
                            stroke="${options2["stroke"] || "black"}" 
                            fill="${options2["fill"] || "transparent"}" 
                    />
                </svg>
            </div>
            `;
      case "polygon":
        const options22 = this.state.options;
        return `
                <div class='draw-item'>
                    <svg width="${width2}" height="${height2}" style="width:100%; height:100%;" overflow="visible">
                        <path   d="${PathParser.makePolygon(width2, height2, options22.count).d}" 
                                stroke-width="${options22["stroke-width"] || 1}" 
                                stroke="${options22["stroke"] || "black"}" 
                                fill="${options22["fill"] || "transparent"}" 
                        />
                    </svg>
                </div>
                `;
      case "star":
        const options3 = this.state.options;
        return `
                    <div class='draw-item'>
                        <svg width="${width2}" height="${height2}" style="width:100%; height:100%;" overflow="visible">
                            <path   d="${PathParser.makeStar(width2, height2, options3.count, options3.radius, options3.tension).d}" 
                                    stroke-width="${options3["stroke-width"] || 1}" 
                                    stroke="${options3["stroke"] || "black"}" 
                                    fill="${options3["fill"] || "transparent"}" 
                            />
                        </svg>
                    </div>
                    `;
      case "svg-textpath":
        return `
            <div class='draw-item' style='outline: 1px solid blue;'>
                <svg width="${width2}" height="${height2}" style="width:100%; height:100%;font-size: ${height2}px;" overflow="visible">
                    <defs>
                        <path id='layer-add-path' d="${PathStringManager.makeLine(0, height2, width2, height2)}" />
                    </defs>
                    <text>
                        <textPath 
                          xlink:href="#layer-add-path"
                          textLength="100%"
                          lengthAdjust="spacingAndGlyphs"
                          startOffset="0em"
                        >${text2}</textPath>
                    </text>
                </svg>
            </div>
            `;
      default:
        return `<div class='draw-item' style='outline: 1px solid blue; ${inlineStyle}'></div>`;
    }
  }
  [BIND("$area")]() {
    const { areaVerties } = this.state;
    const { left: left2, top: top2, width: width2, height: height2 } = vertiesToRectangle(areaVerties);
    return {
      style: {
        left: left2,
        top: top2,
        width: width2,
        height: height2
      },
      innerHTML: this.createLayerTemplate(width2, height2)
    };
  }
  [BIND("$areaRect")]() {
    const { areaVerties, showRectInfo } = this.state;
    const newVerties = this.$viewport.applyVertiesInverse(areaVerties);
    const { width: width2, height: height2 } = vertiesToRectangle(newVerties);
    return {
      style: {
        display: showRectInfo ? "inline-block" : "none",
        left: areaVerties[2][0],
        top: areaVerties[2][1]
      },
      innerHTML: `x: ${Math.round(newVerties[0][0])}, y: ${Math.round(newVerties[0][1])}, ${Math.round(width2)} x ${Math.round(height2)}`
    };
  }
  [BIND("$mousePointerView")]() {
    const { showRectInfo } = this.state;
    const { target = create$3(), targetVertex = create$3() } = this.state;
    return {
      style: {
        display: !showRectInfo ? "inline-block" : "none",
        left: targetVertex[0] || -1e4,
        top: targetVertex[1] || -1e4
      },
      innerHTML: `x: ${Math.round(target[0])}, y: ${Math.round(target[1])}`
    };
  }
  makeMousePointer() {
    if (this.state.dragStart)
      return "";
    const { target } = this.state;
    if (!target)
      return "";
    const guides = (this.state.targetGuides || []).filter(Boolean);
    return `
        <svg width="100%" height="100%">
            ${guides.map((guide) => {
      this.state.pathManager.reset();
      guide = this.$viewport.applyVerties([guide[0], guide[1]]);
      return this.state.pathManager.M({ x: guide[0][0], y: guide[0][1] }).L({ x: guide[1][0], y: guide[1][1] }).X({ x: guide[0][0], y: guide[0][1] }).X({ x: guide[1][0], y: guide[1][1] }).toString("layer-add-snap-pointer");
    }).join("\n")}
        </svg>
    `;
  }
  [BIND("$mousePointer")]() {
    const html = this.makeMousePointer();
    return {
      innerHTML: html
    };
  }
  move() {
    const e = this.$config.get("bodyEvent");
    const targetMousePoint = this.$viewport.getWorldPosition();
    const newMousePoint = this.$context.snapManager.checkPoint(targetMousePoint);
    if (equals$2(newMousePoint, targetMousePoint) === false) {
      this.state.target = newMousePoint;
      this.state.targetVertex = this.$viewport.applyVertex(newMousePoint);
      this.state.targetGuides = this.$context.snapManager.findGuideOne([newMousePoint]).filter(Boolean);
    } else {
      this.state.target = void 0;
      this.state.targetGuides = [];
    }
    const isShiftKey = e.shiftKey;
    const minX = Math.min(newMousePoint[0], this.initMousePoint[0]);
    const minY = Math.min(newMousePoint[1], this.initMousePoint[1]);
    const maxX = Math.max(newMousePoint[0], this.initMousePoint[0]);
    const maxY = Math.max(newMousePoint[1], this.initMousePoint[1]);
    let dx = maxX - minX;
    let dy = maxY - minY;
    if (isShiftKey) {
      dy = dx;
    }
    const verties = rectToVerties(minX, minY, dx, dy);
    this.state.areaVerties = this.$viewport.applyVerties(verties);
    this.state.showRectInfo = true;
    this.bindData("$area");
    this.bindData("$areaRect");
    this.bindData("$mousePointer");
    this.bindData("$mousePointerView");
  }
  end() {
    const isAltKey = this.$config.get("bodyEvent").altKey;
    let { color: color2, content: content2, fontSize, areaVerties, patternInfo } = this.state;
    const rectVerties = this.$viewport.applyVertiesInverse(areaVerties);
    const parentArtBoard = this.$context.selection.getArtboardByPoint(rectVerties[0]);
    let { x, y, width: width2, height: height2 } = vertiesToRectangle(rectVerties);
    let hasArea = true;
    if (width2 === 0 && height2 === 0) {
      switch (this.state.type) {
        case "text":
          content2 = "";
          height2.set(this.state.fontSize);
          hasArea = false;
          break;
        default:
          width2 = 100;
          height2 = 100;
          break;
      }
    }
    var rect2 = __spreadValues(__spreadValues({
      x: Math.floor(x),
      y: Math.floor(y),
      width: Math.floor(width2),
      height: Math.floor(height2),
      backgroundColor: color2,
      content: content2,
      fontSize
    }, patternInfo.attrs), this.state.options);
    switch (this.state.type) {
      case "text":
      case "svg-text":
      case "svg-textpath":
        delete rect2.backgroundColor;
        break;
      case "svg-path":
        rect2["d"] = this.state.d.clone().scale(width2 / this.state.bboxRect.width, height2 / this.state.bboxRect.height).d;
        break;
      default:
        delete rect2["content"];
        break;
    }
    switch (this.state.type) {
      case "image":
        this.trigger("openImage", rect2, parentArtBoard);
        break;
      case "video":
        this.trigger("openVideo", rect2, parentArtBoard);
        break;
      case "audio":
        this.trigger("openAudio", rect2, parentArtBoard);
        break;
      case "text":
        if (hasArea) {
          rect2.fontSize = Length.px(this.state.fontSize).floor();
        } else {
          const scaledFontSize = this.state.fontSize / this.$viewport.scale;
          const $drawItem = this.refs.$area.$(".draw-item > p");
          $drawItem.parent().css("height", `${scaledFontSize}px`);
          $drawItem.parent().css("font-size", `${scaledFontSize}px`);
          $drawItem.select();
          $drawItem.focus();
          return;
        }
        break;
      default:
        this.$commands.emit("newComponent", this.state.type, rect2, true, parentArtBoard || this.$context.selection.currentProject);
        this.$config.set("editing.mode.itemType", "select");
        break;
    }
    if (!isAltKey) {
      this.trigger("hideLayerAppendView");
    }
    this.state.dragStart = false;
    this.state.showRectInfo = false;
    this.state.target = void 0;
    this.bindData("$areaRect");
  }
  [SUBSCRIBE("showLayerAppendView")](type, options2 = {}) {
    this.state.type = type;
    this.state.options = options2;
    this.state.isShow = true;
    this.refs.$area.empty();
    this.$el.show();
    this.$el.focus();
    this.$context.snapManager.clear();
    const model = this.$model.createModel(__spreadValues({
      itemType: type
    }, options2), false);
    this.state.inlineStyle = CSS_TO_STRING(this.$editor.html.toCSS(model, {
      top: true,
      left: true,
      width: true,
      height: true,
      transform: true,
      transformOrigin: true
    }));
    if (options2.d) {
      this.state.d = new PathParser(options2.d);
      this.state.bboxRect = this.state.d.rect();
    }
    this.$context.commands.emit("push.mode.view", "LayerAppendView");
  }
  [SUBSCRIBE("hideLayerAppendView")]() {
    if (this.$el.isShow()) {
      this.state.isShow = false;
      this.$el.hide();
      this.$commands.emit("pop.mode.view", "LayerAppendView");
      this.$config.set("editing.mode", EditingMode.SELECT);
    }
  }
  [SUBSCRIBE("hideAddViewLayer")]() {
    this.state.isShow = false;
    this.$el.hide();
  }
  isShow() {
    return this.state.isShow;
  }
  [KEYDOWN("document") + IF("isShow") + ESCAPE + ENTER]() {
  }
  [KEYUP("document") + IF("isShow") + ESCAPE + ENTER](e) {
    switch (this.state.type) {
      case "text":
        const $t = Dom.create(e.target);
        let { fontSize, areaVerties } = this.state;
        const rectVerties = this.$viewport.applyVertiesInverse(areaVerties);
        const { x, y } = vertiesToRectangle(rectVerties);
        const { width: width2, height: height2 } = $t.rect();
        const text2 = $t.text();
        if (text2.length === 0) {
          break;
        }
        const [[newWidth, newHeight, newFontSize]] = this.$viewport.applyScaleVertiesInverse([[width2, height2, fontSize]]);
        const rect2 = {
          x,
          y,
          width: newWidth,
          height: newHeight,
          content: text2.trim(),
          "font-size": newFontSize
        };
        const parentArtBoard = this.$context.selection.getArtboardByPoint(rectVerties[0]);
        this.$commands.emit("newComponent", this.state.type, rect2, true, parentArtBoard || this.$context.selection.currentProject);
        break;
    }
    this.state.dragStart = false;
    this.state.showRectInfo = false;
    this.state.target = null;
    this.bindData("$areaRect");
    this.trigger("hideLayerAppendView");
  }
  [CHANGE("$file")]() {
    this.refs.$file.files.forEach((item) => {
      this.$commands.emit("updateImage", item, this.state.rect, this.state.containerItem);
    });
  }
  [CHANGE("$video")]() {
    this.refs.$video.files.forEach((item) => {
      this.$commands.emit("updateVideo", item, this.state.rect, this.state.containerItem);
    });
  }
  [SUBSCRIBE("openImage")](rect2, containerItem) {
    this.state.rect = rect2;
    this.state.containerItem = containerItem;
    this.refs.$file.click();
  }
  [SUBSCRIBE("openVideo")](rect2, containerItem) {
    this.state.rect = rect2;
    this.state.containerItem = containerItem;
    this.refs.$video.click();
  }
  [SUBSCRIBE("setPatternInfo")](patternInfo) {
    this.state.patternInfo = patternInfo;
  }
  [SUBSCRIBE(UPDATE_VIEWPORT)]() {
    this.$context.snapManager.clear();
    this.bindData("$mousePointer");
    this.bindData("$mousePointerView");
  }
}
function layerAppendView(editor) {
  editor.registerUI("canvas.view", {
    LayerAppendView
  });
}
var LayerTreeProperty$1 = "";
const DRAG_START_CLASS = "drag-start";
class LayerTreeProperty extends BaseProperty {
  getTitle() {
    return this.$i18n("layer.tree.property.title");
  }
  getClassName() {
    return "full";
  }
  initState() {
    return {
      hideDragPointer: true,
      lastDragOverPosition: 0,
      lastDragOverOffset: 0,
      rootRect: { top: 0 },
      itemRect: { height: 0 }
    };
  }
  getBody() {
    return `
      <div class="elf--layer-list scrollbar" ref="$layerList"></div>
      <div class='drag-point' ref='$dragPointer'></div>
    `;
  }
  [BIND("$dragPointer")]() {
    var offset = this.state.lastDragOverOffset;
    var dist2 = this.state.itemRect.height / 3;
    var bound = {};
    if (this.state.lastDragOverOffset < dist2) {
      offset = 0;
      var top2 = this.state.lastDragOverPosition + offset - this.state.rootRect.top;
      bound = {
        top: top2,
        height: "1px",
        width: "100%",
        left: "0px"
      };
      this.state.lastDragOverItemDirection = "before";
    } else if (this.state.lastDragOverOffset > this.state.itemRect.height - dist2) {
      offset = this.state.itemRect.height;
      var top2 = this.state.lastDragOverPosition + offset - this.state.rootRect.top;
      bound = {
        top: top2,
        height: "1px",
        width: "100%",
        left: "0px"
      };
      this.state.lastDragOverItemDirection = "after";
    } else {
      const targetItem = this.$model.get(this.state.lastDragOverItemId);
      if (targetItem == null ? void 0 : targetItem.enableHasChildren()) {
        offset = 0;
        var top2 = this.state.lastDragOverPosition + offset - this.state.rootRect.top;
        bound = {
          top: top2,
          height: this.state.itemRect.height,
          width: "100%",
          left: "0px"
        };
        this.state.lastDragOverItemDirection = "self";
      }
    }
    bound.display = this.state.hideDragPointer ? "none" : "block";
    return {
      style: bound
    };
  }
  getIcon(item) {
    if (item.d) {
      return iconUseForPath(item.d, {
        width: item.screenWidth,
        height: item.screenHeight,
        fill: "currentColor",
        stroke: "currentColor"
      });
    }
    if (item.hasLayout() || item.hasChildren() || item.is("artboard")) {
      if (item.isLayout("flex")) {
        return iconUse("layout_flex");
      } else if (item.isLayout("grid")) {
        return iconUse("layout_grid");
      }
      return iconUse("layout_default");
    }
    return this.$icon.get(item.itemType, item);
  }
  makeLayerList(parentObject, depth = 0) {
    if (!parentObject.layers)
      return "";
    const layers2 = parentObject.layers;
    const data = [];
    for (var last = layers2.length - 1; last > -1; last--) {
      var layer = layers2[last];
      var selectedPathClass = this.$context.selection.hasPathOf(layer) ? "selected-path" : "";
      var selectedClass = this.$context.selection.check(layer) ? "selected" : "";
      var hovered = this.$context.selection.checkHover(layer) ? "hovered" : "";
      var name = layer.is("boolean-path") ? layer["boolean-operation"] : layer.name;
      if (layer.is("text")) {
        name = layer.text || layer.name;
      }
      var title2 = "";
      if (layer.hasLayout()) {
        title2 = this.$i18n("layer.tree.property.layout.title." + layer.layout);
      }
      const isHide = layer.isTreeItemHide();
      const depthPadding = depth * 20;
      const hasChildren = layer.hasChildren();
      const lock2 = this.$lockManager.get(layer.id);
      const visible2 = this.$visibleManager.get(layer.id);
      data[data.length] = `<div class='layer-item ${selectedClass} ${selectedPathClass} ${hovered}' data-is-group="${hasChildren}" data-depth="${depth}" data-layout='${layer.layout}' data-layer-id='${layer.id}' data-is-hide="${isHide}"  draggable="true"><div class='detail'><label data-layout-title='${title2}' style='padding-left: ${Length.px(depthPadding)}' ><div class='folder ${layer.collapsed ? "collapsed" : ""}'>${hasChildren ? iconUse("arrow_right") : ""}</div><span class='icon' data-item-type="${layer.itemType}">${this.getIcon(layer)}</span><span class='name'>${name}</span></label><div class="tools"><button type="button" class="lock" data-lock="${lock2}" title='Lock'>${lock2 ? iconUse("lock") : iconUse("lock_open")}</button><button type="button" class="visible" data-visible="${visible2}" title='Visible'>${iconUse("visible")}</button><button type="button" class="remove" title='Remove'>${iconUse("remove2")}</button></div></div></div>${this.makeLayerList(layer, depth + 1)}`;
    }
    return data.join("");
  }
  [SUBSCRIBE("refreshContent")]() {
    this.refresh();
  }
  [LOAD("$layerList") + DOMDIFF]() {
    var project2 = this.$context.selection.currentProject;
    if (!project2)
      return "";
    return [
      this.makeLayerList(project2, 0),
      `
        <div class='layer-item ' data-depth="0" data-is-last="true">
        </div>
      `
    ];
  }
  [DRAGSTART("$layerList .layer-item")](e) {
    var layerId = e.$dt.attr("data-layer-id");
    e.$dt.addClass(DRAG_START_CLASS);
    e.dataTransfer.setData("layer/id", layerId);
    this.state.rootRect = this.refs.$layerList.rect();
    this.state.itemRect = e.$dt.rect();
    this.setState({
      hideDragPointer: false
    }, false);
    this.bindData("$dragPointer");
  }
  [DRAGEND("$layerList .layer-item")]() {
    this.setState({
      hideDragPointer: true
    }, false);
    this.bindData("$dragPointer");
    this.refs.$layerList.$$(`.${DRAG_START_CLASS}`).forEach((it) => {
      it.removeClass(DRAG_START_CLASS);
    });
  }
  [DRAGOVER(`$layerList .layer-item:not(.${DRAG_START_CLASS})`) + PREVENT](e) {
    var targetLayerId = e.$dt.attr("data-layer-id");
    this.state.lastDragOverItemId = targetLayerId;
    this.state.lastDragOverPosition = e.$dt.rect().top;
    this.state.lastDragOverOffset = e.offsetY;
    this.bindData("$dragPointer");
  }
  [DROP(`$layerList .layer-item:not(.${DRAG_START_CLASS})`)](e) {
    var targetLayerId = e.$dt.attr("data-layer-id");
    var sourceLayerId = e.dataTransfer.getData("layer/id");
    if (targetLayerId === sourceLayerId)
      return;
    var targetItem = this.$model.get(targetLayerId);
    var sourceItem = this.$model.get(sourceLayerId);
    if ((targetItem == null ? void 0 : targetItem.enableHasChildren()) === false)
      return;
    if (targetItem && targetItem.hasParent(sourceItem.id))
      return;
    switch (this.state.lastDragOverItemDirection) {
      case "self":
        this.$commands.emit("history.moveLayerToTarget", "change target with move", sourceItem, targetItem, void 0, TargetActionType.APPEND_CHILD);
        break;
      case "before":
        this.$commands.emit("history.moveLayerToTarget", "change target with move", sourceItem, targetItem, void 0, TargetActionType.INSERT_BEFORE);
        break;
      case "after":
        this.$commands.emit("history.moveLayerToTarget", "change target with move", sourceItem, targetItem, void 0, TargetActionType.INSERT_AFTER);
        break;
    }
    this.nextTick(() => {
      this.$commands.emit("recoverBooleanPath");
      this.$context.selection.select(sourceItem);
      this.setState({
        hideDragPointer: true
      });
    }, 10);
  }
  [DOUBLECLICK("$layerList .layer-item")](e) {
    this.startInputEditing(e.$dt.$(".name"));
  }
  modifyDoneInputEditing(input2, event) {
    if (KEY_CODE.enter === event.keyCode) {
      this.endInputEditing(input2, () => {
        var id2 = input2.closest("layer-item").attr("data-layer-id");
        var text3 = input2.text();
        this.$commands.executeCommand("setAttribute", "change name", {
          [id2]: {
            name: text3
          }
        });
      });
    } else {
      var id = input2.closest("layer-item").attr("data-layer-id");
      var text2 = input2.text();
      this.$commands.executeCommand("setAttribute", "change name", {
        [id]: {
          name: text2
        }
      });
    }
  }
  [KEYDOWN("$layerList .layer-item .name") + STOP](e) {
    this.modifyDoneInputEditing(e.$dt, e);
  }
  [FOCUSOUT("$layerList .layer-item .name") + PREVENT + STOP](e) {
    this.modifyDoneInputEditing(e.$dt, { keyCode: KEY_CODE.enter });
  }
  selectLayer(layer) {
    if (layer) {
      this.$context.selection.select(layer);
    }
    this.refresh();
    this.emit(REFRESH_SELECTION);
  }
  addLayer(layer) {
    if (layer) {
      this.$context.selection.select(layer);
      this.$commands.emit("refreshArtboard");
    }
  }
  [CLICK("$add")]() {
    this.$commands.emit("newComponent", "rect", {
      backgroundColor: "#ececec",
      width: 200,
      height: 100
    });
  }
  [CLICK("$layerList .layer-item label .name")](e) {
    var $item = e.$dt.closest("layer-item");
    $item.onlyOneClass("selected");
    var id = $item.attr("data-layer-id");
    this.$context.selection.select(id);
    this.$commands.executeCommand(REFRESH_SELECTION);
  }
  [CLICK("$layerList .layer-item label .folder")](e) {
    var $item = e.$dt.closest("layer-item");
    var id = $item.attr("data-layer-id");
    var item = this.$model.get(id);
    item.reset({
      collapsed: !item.collapsed
    });
    this.refresh();
  }
  [CLICK("$layerList .layer-item .visible")](e) {
    var $item = e.$dt.closest("layer-item");
    var id = $item.attr("data-layer-id");
    this.$visibleManager.toggle(id);
    var visible2 = this.$visibleManager.get(id);
    e.$dt.attr("data-visible", visible2);
    this.emit("refreshVisibleView");
  }
  [CLICK("$layerList .layer-item .remove")](e) {
    var $item = e.$dt.closest("layer-item");
    var id = $item.attr("data-layer-id");
    this.$commands.executeCommand("removeLayer", "remove a layer", [id]);
    this.nextTick(() => {
      this.refresh();
    }, 1e3);
  }
  [CLICK("$layerList .layer-item .lock")](e) {
    var $item = e.$dt.closest("layer-item");
    var id = $item.attr("data-layer-id");
    this.$lockManager.toggle(id);
    var lastLock = this.$lockManager.get(id);
    e.$dt.attr("data-lock", lastLock);
    if (lastLock) {
      this.$context.selection.removeById(id);
      this.emit(REFRESH_SELECTION);
    }
  }
  [SUBSCRIBE("changeHoverItem")]() {
    this.refs.$layerList.$$(".hovered").forEach((it) => {
      it.removeClass("hovered");
    });
    if (this.$context.selection.hoverItems.length) {
      var selector2 = this.$context.selection.hoverItems.map((it) => {
        return `[data-layer-id="${it.id}"]`;
      }).join(",");
      this.refs.$layerList.$$(selector2).forEach((it) => {
        it.addClass("hovered");
      });
    }
  }
  [SUBSCRIBE_SELF("changeSelection")](isSelection = false) {
    if (isSelection && this.refs.$layerList) {
      this.refs.$layerList.$$(".selected").forEach((it) => {
        it.removeClass("selected");
      });
      this.refs.$layerList.$$(".selected-path").forEach((it) => {
        it.removeClass("selected-path");
      });
      var selector2 = this.$context.selection.items.map((it) => {
        return `[data-layer-id="${it.id}"]`;
      }).join(",");
      if (selector2) {
        this.refs.$layerList.$$(selector2).forEach((it) => {
          it.addClass("selected");
          var item = this.$context.selection.itemKeys[it.attr("data-layer-id")];
          if (item.is("svg-path", "svg-polygon")) {
            it.$(".icon").html(this.getIcon(item));
          }
        });
      }
    }
  }
  [SUBSCRIBE(REFRESH_SELECTION, "refreshAllCanvas")]() {
    if (this.$config.false("set.move.control.point")) {
      this.refresh();
    }
  }
  [SUBSCRIBE("refreshLayerTreeView") + THROTTLE(100)]() {
    this.refresh();
  }
  [SUBSCRIBE("changeItemLayout")]() {
    this.refresh();
  }
  [CONFIG("bodyEvent")]() {
    const $target = Dom.create(this.$config.get("bodyEvent").target);
    const $layerItem = $target.closest("layer-item");
    if ($layerItem) {
      this.emit("refreshHoverView", $layerItem.data("layer-id"));
    }
  }
}
function layerTree(editor) {
  editor.registerElement({
    LayerTreeProperty
  });
}
var DefaultLayoutItemProperty$1 = "";
class DefaultLayoutItemProperty extends BaseProperty {
  getTitle() {
    return this.$i18n("default.layout.item.property.title.constraints");
  }
  getClassName() {
    return "elf--default-layout-item-property";
  }
  getBody() {
    return `
        <div class='property-item' ref='$body'>
          <div class="constraints">
            <div ref="$constraintsInfo"></div>
            <div ref="$constraintsInfoInput"></div>
          </div>
        </div>
      `;
  }
  [LOAD("$constraintsInfo") + DOMDIFF]() {
    var current = this.$context.selection.current;
    const h = (current == null ? void 0 : current["constraints-horizontal"]) || Constraints.MIN;
    const v = (current == null ? void 0 : current["constraints-vertical"]) || Constraints.MIN;
    return `
      <div class="constraints-box">

        <!-- Horizontal -->
        <div class='item' data-value='min' data-selected="${h === Constraints.MIN || h === Constraints.STRETCH}" data-key='${ConstraintsDirection.HORIZONTAL}'></div>
        <div class='item' data-value='max' data-selected="${h === Constraints.MAX || h === Constraints.STRETCH}" data-key='${ConstraintsDirection.HORIZONTAL}'></div>
        <div class='item' data-value='center' data-selected="${h === Constraints.CENTER}" data-key='${ConstraintsDirection.HORIZONTAL}'></div>

        <!-- Vertical -->
        <div class='item' data-value='min' data-selected="${v === Constraints.MIN || v === Constraints.STRETCH}" data-key='${ConstraintsDirection.VERTICAL}'></div>
        <div class='item' data-value='max' data-selected="${v === Constraints.MAX || v === Constraints.STRETCH}" data-key='${ConstraintsDirection.VERTICAL}'></div>
        <div class='item' data-value='center' data-selected="${v === Constraints.CENTER}" data-key='${ConstraintsDirection.VERTICAL}'></div>            
        <div class="rect"></div>
      </div>
    `;
  }
  [LOAD("$constraintsInfoInput")]() {
    var current = this.$context.selection.current;
    const hasLayout = current == null ? void 0 : current.hasLayout();
    return `
      <div>
        ${createComponent("SelectEditor", {
      ref: "$constraintsHorizontal",
      key: "constraints-horizontal",
      value: (current == null ? void 0 : current["constraints-horizontal"]) || "min",
      label: iconUse("width"),
      compact: true,
      options: [
        { value: "min", text: "Left" },
        { value: "max", text: "Right" },
        { value: "stretch", text: "Left and Right", disabled: hasLayout },
        { value: "center", text: "Center" },
        { value: "scale", text: "Scale", disabled: hasLayout }
      ],
      onchange: "changeConstraints"
    })}
      </div>

      <div>
        ${createComponent("SelectEditor", {
      ref: "$constraintsVertical",
      key: "constraints-vertical",
      value: (current == null ? void 0 : current["constraints-vertical"]) || "min",
      label: iconUse("height"),
      compact: true,
      options: [
        { value: "min", text: "Top" },
        { value: "max", text: "Bottom" },
        { value: "stretch", text: "Top and Bottom", disabled: hasLayout },
        { value: "center", text: "Center" },
        { value: "scale", text: "Scale", disabled: hasLayout }
      ],
      onchange: "changeConstraints"
    })}
      </div>
    `;
  }
  [CLICK("$constraintsInfo .item")](e) {
    const [value, key] = e.$dt.attrs("data-value", "data-key");
    const current = this.$context.selection.current;
    if (!current)
      return;
    current.changeConstraints(key, value, e.shiftKey);
    this.trigger("changeConstraints", key, current[key]);
  }
  [SUBSCRIBE_SELF("changeConstraints")](key, value) {
    this.$commands.executeCommand("setAttribute", "apply constraints", this.$context.selection.packByValue({
      [key]: value
    }));
    this.nextTick(() => {
      this.refresh();
    }, 100);
  }
  [SUBSCRIBE(REFRESH_SELECTION) + DEBOUNCE(100)]() {
    this.refreshShow(() => {
      var current = this.$context.selection.current;
      return current && current.isInDefault() && current.parent.isNot("project");
    });
  }
}
var FlexGrowToolView$1 = "";
class FlexGrowToolView extends EditorElement {
  template() {
    return /* @__PURE__ */ createElementJsx("div", {
      class: "elf--flex-grow-tool-view"
    });
  }
  [LOAD("$el") + DOMDIFF]() {
    return this.$context.selection.map((item) => {
      const parentItem = item.parent;
      if (!parentItem)
        return;
      if (parentItem.is("project"))
        return;
      if (parentItem.isLayout(Layout.FLEX) === false)
        return;
      return parentItem.layers.map((child) => {
        const verties = this.$viewport.applyVerties(child.verties);
        const center2 = verties[4];
        let flexGrow = 0;
        let size2 = child.screenWidth || 0;
        const parentLayoutDirection = parentItem == null ? void 0 : parentItem["flex-direction"];
        if (parentLayoutDirection === FlexDirection.ROW) {
          if (child.resizingHorizontal === ResizingMode.FILL_CONTAINER) {
            flexGrow = child["flex-grow"] || 1;
          }
          size2 = child.screenWidth;
        } else if (parentLayoutDirection === FlexDirection.COLUMN) {
          if (child.resizingVertical === ResizingMode.FILL_CONTAINER) {
            flexGrow = child["flex-grow"] || 1;
          }
          size2 = child.screenHeight;
        }
        return /* @__PURE__ */ createElementJsx("div", {
          class: "flex-grow-item",
          style: {
            left: Length.px(center2[0]),
            top: Length.px(center2[1])
          },
          "data-flex-item-id": child.id,
          "data-parent-direction": parentLayoutDirection,
          "data-flex-grow": flexGrow
        }, /* @__PURE__ */ createElementJsx("span", {
          class: "size"
        }, Math.floor(size2)), " ", /* @__PURE__ */ createElementJsx("span", {
          class: "grow"
        }, flexGrow || "x"));
      }).join("");
    });
  }
  [POINTERSTART("$el .flex-grow-item") + MOVE() + END()](e) {
    const [id, grow] = e.$dt.attrs("data-flex-item-id", "data-flex-grow");
    this.state = {
      id,
      grow: +grow
    };
  }
  getFlexGrow(parentLayoutDirection, item, grow, dx, dy) {
    let flexGrow = grow;
    if (parentLayoutDirection === FlexDirection.ROW && item.resizingHorizontal === ResizingMode.FILL_CONTAINER) {
      flexGrow = grow + Math.floor(dx / 10);
    } else if (parentLayoutDirection === FlexDirection.COLUMN && item.resizingVertical === ResizingMode.FILL_CONTAINER) {
      flexGrow = grow + Math.floor(dy / 10);
    }
    flexGrow = Math.max(1, flexGrow);
    return flexGrow;
  }
  move(dx, dy) {
    const { id, grow } = this.state;
    const item = this.$editor.get(id);
    if (!item)
      return;
    const parentItem = item.parent;
    if (!parentItem)
      return;
    const parentLayoutDirection = parentItem["flex-direction"];
    let flexGrow = this.getFlexGrow(parentLayoutDirection, item, grow, dx, dy);
    this.$commands.emit("setAttribute", {
      [id]: {
        "flex-grow": flexGrow
      }
    });
  }
  end(dx, dy) {
    const { id, grow } = this.state;
    const item = this.$editor.get(id);
    if (!item)
      return;
    const parentItem = item.parent;
    if (!parentItem)
      return;
    const parentLayoutDirection = parentItem["flex-direction"];
    let flexGrow = this.getFlexGrow(parentLayoutDirection, item, grow, dx, dy);
    if (dx === 0 && dy === 0) {
      if (parentLayoutDirection === FlexDirection.ROW && item.resizingHorizontal !== ResizingMode.FILL_CONTAINER) {
        this.commands.executeCommand("setAttribute", "change self resizing", {
          [id]: {
            "flex-grow": 1,
            resizingHorizontal: ResizingMode.FILL_CONTAINER
          }
        });
      } else if (parentLayoutDirection === FlexDirection.COLUMN && item.resizingVertical !== ResizingMode.FILL_CONTAINER) {
        this.commands.executeCommand("setAttribute", "change self resizing", {
          [id]: {
            "flex-grow": 1,
            resizingVertical: ResizingMode.FILL_CONTAINER
          }
        });
      }
    } else {
      this.commands.executeCommand("setAttribute", "change self resizing", {
        [id]: {
          "flex-grow": flexGrow
        }
      });
    }
    this.nextTick(() => {
      this.refresh();
    }, 10);
  }
  [SUBSCRIBE(UPDATE_VIEWPORT)]() {
    this.refresh();
  }
  [SUBSCRIBE(REFRESH_SELECTION) + THROTTLE(100)]() {
    this.refresh();
  }
  [SUBSCRIBE(UPDATE_CANVAS) + THROTTLE(1)]() {
    this.refresh();
  }
  [CONFIG("set.move.control.point")]() {
    this.refresh();
  }
}
var FlexLayoutEditor$1 = "";
class FlexLayoutEditor extends EditorElement {
  initialize() {
    super.initialize();
    this.directionOptions = this.getDirectionOptions();
    this.wrapOptions = this.getWrapOptions();
    this.justifyContentOptions = this.getJustifyContentOptions();
    this.alignItemsOptions = this.getAlignItemsOptions();
  }
  getDirectionOptions() {
    return this.makeOptionsFunction("row,column");
  }
  getWrapOptions() {
    return this.makeOptionsFunction("nowrap,wrap");
  }
  getJustifyContentOptions() {
    return this.makeOptionsFunction("flex-start,flex-end,center,space-between,space-around");
  }
  getAlignItemsOptions() {
    return this.makeOptionsFunction("flex-start,flex-end,center,baseline,stretch");
  }
  getAlignContentOptions() {
    return this.makeOptionsFunction("flex-start,flex-end,center,space-between,space-around,stretch");
  }
  makeOptionsFunction(options2) {
    return options2.split(",").map((it) => {
      return { value: it, text: this.$i18n("flex.layout.editor." + it) };
    });
  }
  initState() {
    return __spreadValues({}, this.props.value);
  }
  setValue(value) {
    this.setState(__spreadValues({}, value));
  }
  getValue() {
    return this.state;
  }
  modifyData(key, value) {
    this.parent.trigger(this.props.onchange, key, value);
  }
  [LOAD("$body") + DOMDIFF]() {
    const current = this.$context.selection.current;
    if (!current)
      return "";
    const realPaddingTop = Math.min(current.paddingTop || 0, 50);
    const realPaddingLeft = Math.min(current.paddingLeft || 0, 50);
    const realPaddingRight = Math.min(current.paddingRight || 0, 50);
    const realPaddingBottom = Math.min(current.paddingBottom || 0, 50);
    const padding2 = `padding-top:${realPaddingTop}px;padding-left: ${realPaddingLeft}px;padding-right:${realPaddingRight}px;padding-bottom: ${realPaddingBottom}px;`;
    return `<div class='flex-layout-item'><div class="grid-2"><div>${createComponent("SelectIconEditor", {
      key: "flex-direction",
      ref: "$flexDirection",
      value: this.state["flex-direction"] || FlexDirection.ROW,
      options: this.directionOptions,
      icons: ["east", "south"],
      onchange: "changeKeyValue"
    })}</div><div>${createComponent("NumberInputEditor", {
      compact: true,
      ref: "$flex-gap",
      label: iconUse("space"),
      key: "gap",
      value: this.state.gap,
      min: 0,
      max: 100,
      step: 1,
      onchange: "changeKeyValue"
    })}</div><div>${createComponent("NumberInputEditor", {
      compact: true,
      label: iconUse("padding"),
      key: "padding",
      ref: "$padding",
      value: current.paddingTop,
      min: 0,
      max: 100,
      step: 1,
      onchange: "changePadding"
    })}</div><div>${createComponent("ToggleButton", {
      compact: true,
      key: "flex-wrap",
      ref: "$wrap",
      checkedValue: "wrap",
      value: this.state["flex-wrap"] || FlexWrap.NOWRAP,
      toggleLabels: [iconUse("wrap"), iconUse("wrap")],
      toggleValues: [FlexWrap.NOWRAP, FlexWrap.WRAP],
      onchange: "changeKeyValue"
    })}</div></div></div>
  <div class="select-flex-direction">
      <div>
          <div class="flex-group-padding">            
              <div class="padding-top" style="height: ${current.paddingTop}px"></div>
              <div class="padding-left" style="width: ${current.paddingLeft}px"></div>
              <div class="padding-right" style="width: ${current.paddingRight}px"></div>
              <div class="padding-bottom" style="height: ${current.paddingBottom}px"></div>
          </div>
          <div class="flex-group" style="
                  --flex-group-gap: ${Math.floor(this.state["gap"] / 10)}px;
                  --flex-group-padding: ${realPaddingTop}px;
                  ${padding2};
                  flex-direction: ${this.state["flex-direction"]};
                  flex-wrap: ${this.state["flex-wrap"]};
                  justify-content:${this.state["justify-content"]};
                  align-items: ${this.state["align-items"]};
                  align-content:${this.state["align-content"]};
          ">
              ${[1, 2, 3].map(() => {
      return `
                      <div class="flex-direction" data-value="${this.state["flex-direction"]}" style="flex-direction: ${this.state["flex-direction"]};align-items: ${this.state["align-items"]};">
                          <div class="flex-direction-item" data-index="1"></div>
                          <div class="flex-direction-item" data-index="2"></div>
                          <div class="flex-direction-item" data-index="3"></div>
                      </div>
                  `;
    }).join("\n")}
          </div>
          <div class="flex-group-tool"  style="${padding2};">
              <div class="tool-area"  
                  data-direction="${this.state["flex-direction"]}"  
                  data-justify-content="${this.state["justify-content"]}"
                  data-align-items="${this.state["align-items"]}"
                  data-align-content="${this.state["align-content"]}"                            
                  style="
                      --flex-group-gap: ${Math.floor(this.state["gap"] / 10)}px;
                      --flex-group-padding: ${realPaddingTop}px;
                  "
              >
                  <div class="tool-area-item" data-index="1" data-justify-content="flex-start" data-align-items="flex-start"></div>
                  <div class="tool-area-item" data-index="2"  data-justify-content="center" data-align-items="flex-start"></div>
                  <div class="tool-area-item" data-index="3"  data-justify-content="flex-end" data-align-items="flex-start"></div>
                  <div class="tool-area-item" data-index="4"  data-justify-content="flex-start" data-align-items="center"></div>
                  <div class="tool-area-item" data-index="5"  data-justify-content="center" data-align-items="center"></div>
                  <div class="tool-area-item" data-index="6"  data-justify-content="flex-end" data-align-items="center"></div>
                  <div class="tool-area-item" data-index="7"  data-justify-content="flex-start" data-align-items="flex-end"></div>
                  <div class="tool-area-item" data-index="8"  data-justify-content="center" data-align-items="flex-end"></div>
                  <div class="tool-area-item" data-index="9"  data-justify-content="flex-end" data-align-items="flex-end"></div>                            
              </div>
          </div>
      </div>
  </div>

  <div class='flex-layout-item'>
      <div class="title">${this.$i18n("flex.layout.editor.justify-content")}</div>
      ${createComponent("SelectIconEditor", {
      key: "justify-content",
      ref: "$justify",
      value: this.state["justify-content"] || JustifyContent.FLEX_START,
      options: this.justifyContentOptions,
      icons: [
        "start",
        "end",
        "horizontal_align_center",
        "horizontal_distribute",
        "justify_content_space_around"
      ],
      onchange: "changeKeyValue"
    })}
  </div>
  <div class='flex-layout-item'>
      <div class="title">${this.$i18n("flex.layout.editor.align-items")}</div>            
      ${createComponent("SelectIconEditor", {
      key: "align-items",
      ref: "$alignItems",
      value: this.state["align-items"] || AlignItems.FLEX_START,
      options: this.alignItemsOptions,
      icons: [
        "vertical_align_top",
        "vertical_align_bottom",
        "vertical_align_center",
        "vertical_align_baseline",
        "vertical_align_stretch"
      ],
      onchange: "changeKeyValue"
    })}
  </div>
        `;
  }
  template() {
    return `
            <div class='flex-layout-editor' ref='$body' ></div>
        `;
  }
  [SUBSCRIBE_SELF("changeKeyValue")](key, value) {
    this.setState({
      [key]: value
    }, false);
    this.modifyData(key, value);
    this.refresh();
  }
  [SUBSCRIBE_SELF("changePadding")](key, value) {
    this.setState({
      [key]: value
    }, false);
    this.modifyData(key, {
      paddingTop: value,
      paddingLeft: value,
      paddingRight: value,
      paddingBottom: value
    });
    this.refresh();
  }
  [CLICK("$body .tool-area-item")](e) {
    const $target = e.$dt;
    const [justifyContent, alignItems] = $target.attrs("data-justify-content", "data-align-items", "data-align-content");
    if (this.state["justify-content"] === JustifyContent.SPACE_BETWEEN) {
      this.setState({
        "align-items": alignItems
      }, false);
      this.modifyData("align-item", alignItems);
    } else if (this.state["justify-content"] === JustifyContent.SPACE_AROUND) {
      this.setState({
        "align-items": alignItems
      }, false);
      this.modifyData("align-item", alignItems);
    } else {
      this.setState({
        "justify-content": justifyContent,
        "align-items": alignItems
      }, false);
      this.modifyData("justify-content", justifyContent);
      this.modifyData("align-items", alignItems);
    }
    this.refresh();
  }
}
var GridBoxEditor$1 = "";
const REG_CSS_UNIT = /(auto)|(repeat\([^)]*\))|(([\d.]+)(px|pt|fr|r?em|deg|vh|vw|%))/gi;
class GridBoxEditor extends EditorElement {
  getLayoutItemOptions() {
    return "none,auto,repeat,length".split(",").map((it) => {
      return { value: it, text: this.$i18n(`grid.box.editor.${it}`) };
    });
  }
  initState() {
    return {
      label: this.props.label,
      list: this.parseValue(this.props.value)
    };
  }
  setValue(value) {
    this.setState({
      list: this.parseValue(value)
    });
  }
  parseValue(value) {
    let arr = null;
    var target = [];
    while ((arr = REG_CSS_UNIT.exec(value)) !== null) {
      var text2 = arr[0];
      if (text2 === "auto") {
        target.push({ type: "auto", count: 0, value: "0px" });
      } else if (text2.includes("repeat")) {
        var tempArray = text2.split("repeat(")[1].split(")");
        tempArray.pop();
        let [count, ...size2] = tempArray.join("").split(",");
        target.push({ type: "repeat", count, value: size2.join(", ") });
      } else {
        target.push({ type: "length", count: 1, value: text2 });
      }
    }
    return target;
  }
  getValue() {
    return this.state.list.map((it) => {
      if (it.type === "repeat") {
        return `repeat(${it.count}, ${it.value})`;
      } else if (it.type === "auto" || it.type === "none") {
        return it.type;
      } else {
        return it.value;
      }
    }).join(" ");
  }
  modifyData() {
    this.parent.trigger(this.props.onchange, this.props.key, this.getValue());
  }
  makeItem(it, index2) {
    return `
            <div class='item' data-repeat-type='${it.type}' data-index='${index2}' >
                <div class='repeat'>
                    ${createComponent("SelectEditor", {
      ref: `$${index2}-type`,
      compact: true,
      options: this.getLayoutItemOptions(),
      key: "type",
      value: it.type || "auto",
      params: index2,
      onchange: "changeKeyValue"
    })}
                </div>
                <div class='count'>
                    ${createComponent("NumberInputEditor", {
      compact: true,
      ref: `$${index2}-count`,
      key: "count",
      value: it.count,
      params: index2,
      max: 1e3,
      onchange: "changeKeyValue"
    })}
                </div>                
                <div class='value'>
                    ${createComponent("InputRangeEditor", {
      ref: `$${index2}-value`,
      compact: true,
      key: "value",
      value: it.value,
      params: index2,
      units: ["auto", "fr", "px", "em", "%"],
      onchange: "changeKeyValue"
    })}
                </div>
                <div class='tools'>
                    <button type="button" class='copy'>${iconUse("copy")}</button>                
                    <button type="button" class='remove'>${iconUse("remove2")}</button>
                </div>
            </div>
        `;
  }
  [LOAD("$list")]() {
    return this.state.list.map((it, index2) => {
      return this.makeItem(it, index2);
    });
  }
  template() {
    return `
            <div class='elf--grid-box-editor' ref='$body' >
                <div class='grid-box-editor-item'>
                    <div class='item header'>
                        <div class='repeat'>
                            <label>${this.state.label} </label>
                            <button type='button' ref='$add'>${obj$3.add}</button>
                        </div>
                        <div class='count'>${this.$i18n("grid.box.editor.count")}</div>
                        <div class='value'>${this.$i18n("grid.box.editor.value")}</div>
                        <div class='tools'></div>
                    </div>
                    <div ref='$list'></div>
                </div>
            </div>
        `;
  }
  [CLICK("$list .remove")](e) {
    var index2 = +e.$dt.closest("item").attr("data-index");
    this.state.list.splice(index2, 1);
    this.refresh();
    this.modifyData();
  }
  [CLICK("$list .copy")](e) {
    var index2 = +e.$dt.closest("item").attr("data-index");
    var newObj = clone$1(this.state.list[index2]);
    this.state.list.splice(index2, 0, newObj);
    this.refresh();
    this.modifyData();
  }
  [CLICK("$add")]() {
    this.trigger("add");
  }
  [SUBSCRIBE("add")]() {
    this.state.list.push({ type: "auto", count: 0, value: "0px" });
    this.refresh();
    this.modifyData();
  }
  [SUBSCRIBE_SELF("changeKeyValue")](key, value, params) {
    var index2 = +params;
    var item = this.state.list[index2];
    if (item) {
      if (key === "type") {
        this.refs.$list.$(`[data-index="${index2}"]`).attr("data-repeat-type", value);
      }
      item[key] = value;
    }
    this.modifyData();
  }
}
class GridGapEditor extends EditorElement {
  initState() {
    return {
      label: this.props.label,
      value: this.parseValue(this.props.value)
    };
  }
  setValue(value) {
    this.setState({
      list: this.parseValue(value)
    });
  }
  parseValue(value) {
    return Length.parse(value);
  }
  getValue() {
    return this.state.value;
  }
  modifyData() {
    this.parent.trigger(this.props.onchange, this.props.key, this.getValue());
  }
  makeItem() {
    return `
            <div class='item'>
                <div class='value'>
                    ${createComponent("InputRangeEditor", {
      label: this.state.label,
      wide: true,
      ref: "$value",
      key: "value",
      value: this.state.value,
      max: 500,
      units: ["px", "em", "%"],
      onchange: "changeKeyValue"
    })}
                </div>
            </div>
        `;
  }
  [LOAD("$list")]() {
    return this.makeItem();
  }
  template() {
    return `
            <div class='grid-gap-editor' ref='$body' >
                <div class='grid-gap-editor-item'>
                    <div ref='$list'></div>
                </div>
            </div>
        `;
  }
  [SUBSCRIBE_SELF("changeKeyValue")](key, value) {
    this.state.value = value;
    this.modifyData();
  }
}
var GridGrowToolView$1 = "";
class Grid {
  static parseStyle(value) {
    const units = [];
    parseValue(value).forEach((it) => {
      switch (it.func) {
        case FuncType.REPEAT:
          for (var i = 0, len2 = it.parsed.count; i < len2; i++) {
            units.push(it.parsed.length);
          }
          break;
        case FuncType.LENGTH:
          units.push(it.parsed);
          break;
        case FuncType.KEYWORD:
          units.push(it.matchedString);
          break;
      }
    });
    return units;
  }
  static join(values = []) {
    return values.join(" ");
  }
}
class GridGrowBaseView extends EditorElement {
  updateRows(current, newRows) {
    const data = {};
    current.layers.forEach((it) => {
      data[it.id] = {
        "grid-row-start": Math.max(1, Math.min(newRows.length, it["grid-row-start"])),
        "grid-row-end": Math.min(newRows.length + 1, it["grid-row-end"])
      };
    });
    this.$commands.executeCommand("setAttribute", "change grid rows", __spreadProps(__spreadValues({}, data), {
      [current.id]: {
        "grid-template-rows": Grid.join(newRows)
      }
    }));
  }
  updateColumns(current, newColumns) {
    const data = {};
    current.layers.forEach((it) => {
      data[it.id] = {
        "grid-column-start": Math.max(1, Math.min(newColumns.length, it["grid-column-start"])),
        "grid-column-end": Math.min(newColumns.length + 1, it["grid-column-end"])
      };
    });
    this.$commands.executeCommand("setAttribute", "change grid columns", __spreadProps(__spreadValues({}, data), {
      [current.id]: {
        "grid-template-columns": Grid.join(newColumns)
      }
    }));
  }
  updateColumnGap(current, columnGap) {
    this.$commands.executeCommand("setAttribute", "change grid column gap", {
      [current.id]: {
        "grid-column-gap": `${columnGap}`
      }
    });
  }
  updateRowGap(current, rowGap) {
    this.$commands.executeCommand("setAttribute", "change grid row gap", {
      [current.id]: {
        "grid-row-gap": `${rowGap}`
      }
    });
  }
  createNewGridItems(arr) {
    let newArr = [];
    if (arr.length === 0) {
      newArr = [Length.fr(1)];
    } else {
      newArr = [...arr, arr[arr.length - 1]];
    }
    return newArr;
  }
  copyNewGridItems(arr, index2) {
    return [...arr.slice(0, index2 + 1), ...arr.slice(index2)];
  }
  getScaleDist(num) {
    return num / this.$viewport.scale;
  }
}
class GridGrowClickEventView extends GridGrowBaseView {
  checkTargetLayer() {
    const current = this.getGridTargetLayer();
    if (!current)
      return false;
    if (current.isLayout(Layout.GRID) === false)
      return false;
    return true;
  }
  [CLICK("$grid .column-plus") + IF("checkTargetLayer")]() {
    const info = this.getGridLayoutInformation();
    this.updateColumns(info.current, this.createNewGridItems(info.columns));
  }
  [CLICK("$grid .row-plus") + IF("checkTargetLayer")]() {
    const info = this.getGridLayoutInformation();
    this.updateRows(info.current, this.createNewGridItems(info.rows));
  }
  [CLICK("$grid .column-delete") + IF("checkTargetLayer")](e) {
    const info = this.getGridLayoutInformation();
    if (info.columns.length < 2) {
      this.alert("Alert", "Columns can not be less than one.", 2e3);
      return;
    }
    const index2 = +e.$dt.data("index");
    const newColumns = [
      ...info.columns.slice(0, index2),
      ...info.columns.slice(index2 + 1)
    ];
    this.updateColumns(info.current, newColumns);
  }
  [CLICK("$grid .column-add") + IF("checkTargetLayer")](e) {
    const info = this.getGridLayoutInformation();
    const index2 = +e.$dt.data("index");
    this.updateColumns(info.current, this.copyNewGridItems(info.columns, index2), index2 + 1);
  }
  [CLICK("$grid .row-add") + IF("checkTargetLayer")](e) {
    const info = this.getGridLayoutInformation();
    const index2 = +e.$dt.data("index");
    this.updateRows(info.current, this.copyNewGridItems(info.rows, index2));
  }
  [CLICK("$grid .row-delete") + IF("checkTargetLayer")](e) {
    const info = this.getGridLayoutInformation();
    if (info.rows.length < 2) {
      this.alert("Alert", "Rows can not be less than one.", 2e3);
      return;
    }
    const index2 = +e.$dt.data("index");
    const newRows = [
      ...info.rows.slice(0, index2),
      ...info.rows.slice(index2 + 1)
    ];
    this.updateRows(info.current, newRows);
  }
}
class GridGrowDragEventView extends GridGrowClickEventView {
  [POINTERSTART("$gridGap .gap-tool.column-gap") + IF("checkTargetLayer") + FIRSTMOVE("moveFirstColumnGap") + MOVE("moveColumnGap") + END("moveEndColumnGap")](e) {
    const info = this.getGridLayoutInformation();
    this.current = info.current;
    this.columnGap = info.columnGap;
    this.lastColumnGap = info.columnGap;
    this.initMousePosition = this.$viewport.getWorldPosition(e);
  }
  updateGapPointer(gap) {
    const screenPosition = this.$viewport.applyVertex(this.$viewport.getWorldPosition());
    this.refs.$pointer.text(`${gap}`);
    this.refs.$pointer.css({
      left: Length.px(screenPosition[0]),
      top: Length.px(screenPosition[1] + 20)
    });
  }
  moveFirstColumnGap() {
    this.refs.$pointer.show();
    this.updateGapPointer(this.columnGap);
  }
  moveColumnGap() {
    const targetPosition = this.$viewport.getWorldPosition();
    const newDist = subtract([], targetPosition, this.initMousePosition);
    const stepRate = newDist[0] / this.getScaleDist(100);
    const columnGap = this.columnGap;
    let newColumnGap = columnGap;
    if (columnGap instanceof Length) {
      if (columnGap.isPercent()) {
        newColumnGap = Length.percent(Math.max(columnGap.value + stepRate * this.getScaleDist(5), 0)).round(1e3);
      } else if (columnGap.isPx()) {
        newColumnGap = Length.px(Math.max(columnGap.value + stepRate * this.getScaleDist(100), 0)).floor();
      }
    }
    this.lastColumnGap = newColumnGap;
    this.updateColumnGap(this.current, newColumnGap);
    this.updateGapPointer(this.lastColumnGap);
  }
  moveEndColumnGap() {
    const targetPosition = this.$viewport.getWorldPosition();
    const realDistance = dist(targetPosition, this.initMousePosition);
    if (realDistance < 1) {
      if (this.lastColumnGap.isPx()) {
        this.lastColumnGap = Length.makePercent(this.lastColumnGap.value, this.current.screenWidth);
      } else {
        this.lastColumnGap = this.lastColumnGap.toPx(this.current.screenWidth);
      }
    }
    this.updateColumnGap(this.current, this.lastColumnGap);
    this.refs.$pointer.hide();
  }
  [POINTERSTART("$gridGap .gap-tool.row-gap") + IF("checkTargetLayer") + FIRSTMOVE("moveFirstColumnGap") + MOVE("moveRowGap") + END("moveEndRowGap")](e) {
    const info = this.getGridLayoutInformation();
    this.current = info.current;
    this.rowGap = info.rowGap;
    this.lastColumnGap = info.rowGap;
    this.initMousePosition = this.$viewport.getWorldPosition(e);
  }
  moveRowGap() {
    const targetPosition = this.$viewport.getWorldPosition();
    const newDist = subtract([], targetPosition, this.initMousePosition);
    const stepRate = newDist[1] / this.getScaleDist(100);
    const rowGap = this.rowGap;
    let newRowGap = rowGap;
    if (rowGap instanceof Length) {
      if (rowGap.isPercent()) {
        newRowGap = Length.percent(Math.max(rowGap.value + stepRate * this.getScaleDist(5), 0)).round(1e3);
      } else if (rowGap.isPx()) {
        newRowGap = Length.px(Math.max(rowGap.value + stepRate * this.getScaleDist(100), 0)).floor();
      }
    }
    this.lastRowGap = newRowGap;
    this.updateRowGap(this.current, newRowGap);
    this.updateGapPointer(this.lastRowGap);
  }
  moveEndRowGap() {
    const targetPosition = this.$viewport.getWorldPosition();
    const realDistance = dist(targetPosition, this.initMousePosition);
    if (realDistance < 1) {
      if (!this.lastRowGap) {
        this.lastRowGap = Length.px(0);
      }
      if (this.lastRowGap.isPx()) {
        this.lastRowGap = Length.makePercent(this.lastRowGap.value, this.current.screenHeight);
      } else {
        this.lastRowGap = this.lastRowGap.toPx(this.current.screenHeight);
      }
    }
    this.updateRowGap(this.current, this.lastRowGap);
    this.refs.$pointer.hide();
  }
  [POINTERSTART("$grid .grid-item-tool.column .item") + MOVE("moveColumn") + END("moveEndColumn")](e) {
    const index2 = +e.$dt.data("index");
    const info = this.getGridLayoutInformation();
    this.current = info.current;
    this.columns = info.columns;
    this.selectedColumnIndex = index2;
    this.selectedColumnWidth = info.columns[index2];
    this.initMousePosition = this.$viewport.getWorldPosition(e);
  }
  moveColumn() {
    const targetPosition = this.$viewport.getWorldPosition();
    const newDist = subtract([], targetPosition, this.initMousePosition);
    const stepRate = newDist[0] / this.getScaleDist(100);
    const columnWidth = this.selectedColumnWidth;
    if (columnWidth instanceof Length) {
      if (columnWidth.isPercent()) {
        var newWidth = Math.max(columnWidth.value + stepRate * this.getScaleDist(5), 1);
        this.columns[this.selectedColumnIndex] = Length.percent(newWidth).round(1e3);
      } else if (columnWidth.isPx()) {
        var newWidth = Math.max(10, columnWidth.value + stepRate * this.getScaleDist(100));
        this.columns[this.selectedColumnIndex] = Length.px(newWidth).floor();
      } else if (columnWidth.isFr()) {
        var newWidth = Math.max(columnWidth.value + Math.floor(newDist[0] / this.getScaleDist(20)) * 0.25, 0.25);
        this.columns[this.selectedColumnIndex] = Length.fr(newWidth);
      } else {
        var newWidth = Math.max(columnWidth.value + stepRate * 1, 10);
        this.columns[this.selectedColumnIndex] = new Length(newWidth, columnWidth.unit);
      }
      this.updateColumns(this.current, this.columns);
    }
  }
  changedColumnSize() {
    const info = this.getGridLayoutInformation();
    const index2 = this.selectedColumnIndex;
    const width2 = this.selectedColumnWidth;
    if (width2 instanceof Length) {
      if (width2.isPercent()) {
        this.columns[index2] = Length.fr(1);
      } else if (width2.isPx()) {
        this.columns[index2] = Length.makePercent(width2.value, info.current.screenWidth).round(1e3);
      } else if (width2.isFr()) {
        this.columns[index2] = "auto";
      }
    } else if (width2 === "auto") {
      const { items } = this.state.lastGridInfo;
      const column = items.find((it) => it.column === index2 + 1);
      this.columns[index2] = Length.px(column.rect.width).floor();
    }
  }
  moveEndColumn() {
    const targetPosition = this.$viewport.getWorldPosition();
    const realDistance = dist(targetPosition, this.initMousePosition);
    if (realDistance < 1) {
      this.changedColumnSize();
    }
    this.updateColumns(this.current, this.columns);
  }
  [POINTERSTART("$grid .grid-item-tool.row .item") + MOVE("moveRow") + END("moveEndRow")](e) {
    const index2 = +e.$dt.data("index");
    const info = this.getGridLayoutInformation();
    this.current = info.current;
    this.rows = info.rows;
    this.selectedRowIndex = index2;
    this.selectedRowHeight = info.rows[index2];
    this.initMousePosition = this.$viewport.getWorldPosition(e);
  }
  moveRow() {
    const targetPosition = this.$viewport.getWorldPosition();
    const newDist = subtract([], targetPosition, this.initMousePosition);
    const stepRate = newDist[1] / this.getScaleDist(30);
    const rowHeight = this.selectedRowHeight;
    if (rowHeight instanceof Length) {
      if (rowHeight.isPercent()) {
        var newHeight = Math.max(rowHeight.value - stepRate * this.getScaleDist(5), 1);
        this.rows[this.selectedRowIndex] = Length.percent(newHeight).round(1e3);
      } else if (rowHeight.isPx()) {
        var newHeight = Math.max(10, rowHeight.value - stepRate * this.getScaleDist(100));
        this.rows[this.selectedRowIndex] = Length.px(newHeight).floor();
      } else if (rowHeight.isFr()) {
        var newHeight = Math.max(rowHeight.value + Math.floor(newDist[1] / this.getScaleDist(20)) * 0.25, 0.25);
        this.rows[this.selectedRowIndex] = Length.fr(newHeight);
      } else {
        var newHeight = Math.max(rowHeight.value - stepRate * 1, 10);
        this.rows[this.selectedRowIndex] = new Length(newHeight, rowHeight.unit);
      }
      this.updateRows(this.current, this.rows);
    }
  }
  changedRowSize() {
    const info = this.getGridLayoutInformation();
    const index2 = this.selectedRowIndex;
    const height2 = this.selectedRowHeight;
    if (height2 instanceof Length) {
      if (height2.isPercent()) {
        this.rows[index2] = Length.fr(1);
      } else if (height2.isPx()) {
        this.rows[index2] = Length.makePercent(height2.value, info.current.screenHeight).round(1e3);
      } else if (height2.isFr()) {
        this.rows[index2] = "auto";
      }
    } else if (height2 === "auto") {
      const { items } = this.state.lastGridInfo;
      const row = items.find((it) => it.row === index2 + 1);
      this.rows[index2] = Length.px(row.rect.height).floor();
    }
  }
  moveEndRow() {
    const targetPosition = this.$viewport.getWorldPosition();
    const realDistance = dist(targetPosition, this.initMousePosition);
    if (realDistance < 1) {
      this.changedRowSize();
    }
    this.updateRows(this.current, this.rows);
  }
}
class GridGrowToolView extends GridGrowDragEventView {
  template() {
    return /* @__PURE__ */ createElementJsx("div", {
      class: "elf--grid-grow-tool-view"
    }, /* @__PURE__ */ createElementJsx("div", {
      class: "layout-rect",
      ref: "$grid"
    }), /* @__PURE__ */ createElementJsx("div", {
      class: "layout-rect blank-tool",
      ref: "$gridGap"
    }), /* @__PURE__ */ createElementJsx("div", {
      class: "layout-pointer",
      ref: "$pointer"
    }));
  }
  [BIND("$el")]() {
    var _a;
    const current = this.getGridTargetLayer();
    return {
      "data-drag-target-item": Boolean(this.$context.selection.dragTargetItem),
      "data-grid-layout-own": ((_a = this.$context.selection.current) == null ? void 0 : _a.id) === (current == null ? void 0 : current.id),
      style: {
        display: current ? "block" : "none"
      }
    };
  }
  [BIND("$grid")]() {
    const current = this.getGridTargetLayer();
    if (!current)
      return "";
    if (current.isLayout(Layout.GRID) === false)
      return "";
    const rect2 = vertiesToRectangle(this.$viewport.applyVerties(current.verties));
    const info = this.getGridLayoutInformation();
    const [paddingTop, paddingRight, paddingBottom, paddingLeft] = this.getScaledInformation([
      Length.px(info.current.paddingTop),
      Length.px(info.current.paddingRight),
      Length.px(info.current.paddingBottom),
      Length.px(info.current.paddingLeft)
    ]);
    const columns = this.getScaledInformation(info.columns);
    const rows = this.getScaledInformation(info.rows);
    const columnGap = this.getScaledLength(info.columnGap);
    const rowGap = this.getScaledLength(info.rowGap);
    const origin = subtract([], current.verties[1], current.verties[0]);
    const angle = calculateAngle360(origin[0], origin[1]) - 180;
    return {
      style: {
        display: "grid",
        "grid-template-columns": Grid.join(columns),
        "grid-template-rows": Grid.join(rows),
        "grid-column-gap": columnGap,
        "grid-row-gap": rowGap,
        left: Length.px(rect2.left),
        top: Length.px(rect2.top),
        width: Length.px(rect2.width),
        height: Length.px(rect2.height),
        "padding-top": paddingTop,
        "padding-right": paddingRight,
        "padding-bottom": paddingBottom,
        "padding-left": paddingLeft,
        "transform-origin": "left top",
        transform: `rotate(${angle}deg)`
      }
    };
  }
  [BIND("$gridGap")]() {
    const current = this.getGridTargetLayer();
    if (!current)
      return "";
    if (current.isLayout(Layout.GRID) === false)
      return "";
    const rect2 = vertiesToRectangle(this.$viewport.applyVerties(current.verties));
    const origin = subtract([], current.verties[1], current.verties[0]);
    const angle = calculateAngle360(origin[0], origin[1]) - 180;
    return {
      style: {
        left: Length.px(rect2.left),
        top: Length.px(rect2.top),
        width: Length.px(rect2.width),
        height: Length.px(rect2.height),
        "transform-origin": "left top",
        transform: `rotate(${angle}deg)`
      }
    };
  }
  getScaledInformation(arr) {
    return arr.map((it) => this.getScaledLength(it));
  }
  getScaledLength(it) {
    if (isString(it)) {
      return it;
    } else if (it instanceof Length) {
      if (it.isPx()) {
        return it.clone().mul(this.$viewport.scale);
      }
    }
    return it;
  }
  getGridTargetLayer() {
    if (this.$context.selection.dragTargetItem) {
      return this.$context.selection.dragTargetItem;
    }
    const current = this.$context.selection.current;
    if (!current)
      return null;
    if (current.isLayout(Layout.GRID))
      return current;
    const parent = current.parent;
    if (parent && parent.is("project"))
      return null;
    if (parent && parent.isLayout(Layout.GRID))
      return parent;
    return null;
  }
  getParsedValue(it) {
    if (it === "auto") {
      return it;
    }
    return Length.parse(it);
  }
  getGridLayoutInformation() {
    const current = this.getGridTargetLayer();
    const columns = Grid.parseStyle(current.gridTemplateColumns);
    const rows = Grid.parseStyle(current.gridTemplateRows);
    return {
      current,
      columns,
      columnGap: this.getParsedValue(current.gridColumnGap),
      rows,
      rowGap: this.getParsedValue(current.gridRowGap)
    };
  }
  afterLoadRendering(targetRef, refName) {
    this.trigger("refreshGridInformation", targetRef, refName);
  }
  [SUBSCRIBE_SELF("refreshGridInformation") + DEBOUNCE(10)](targetRef, refName) {
    const current = this.getGridTargetLayer();
    if (!current)
      return;
    if (current.isLayout(Layout.GRID) === false)
      return;
    if (refName !== "$grid")
      return;
    const info = this.getGridLayoutInformation();
    const scale2 = this.$viewport.scale;
    const items = targetRef.$$(".grid-item").map((it) => {
      const [row, column] = it.attrs("data-row", "data-column").map((it2) => +it2);
      const { x, y, width: width2, height: height2 } = it.offsetRect();
      const rect2 = {
        x: x / scale2,
        y: y / scale2,
        width: width2 / scale2,
        height: height2 / scale2
      };
      const verties = vertiesMap(rectToVerties(rect2.x, rect2.y, rect2.width, rect2.height), info.current.absoluteMatrix);
      const originVerties = verties.filter((_, index2) => index2 < 4);
      return {
        row,
        column,
        rect: rect2,
        info,
        verties,
        originVerties,
        originRect: vertiesToRectangle(originVerties)
      };
    });
    this.state.lastGridInfo = { info, items };
    this.load("$gridGap");
    this.$context.selection.updateGridInformation({
      info,
      items
    });
  }
  [LOAD("$gridGap") + DOMDIFF]() {
    const current = this.getGridTargetLayer();
    if (!current)
      return "";
    if (this.$config.true("set.move.control.point"))
      return "";
    if (!this.$context.selection.current)
      return "";
    const last = this.state.lastGridInfo;
    const scale2 = this.$viewport.scale;
    if (!last)
      return "";
    const { info, items } = last;
    const { columns, rows } = info;
    const result = [];
    const rowItems = items.filter((it) => it.column === 1);
    const columnItems = items.filter((it) => it.row === 1);
    const minY = Math.min(...rowItems.map((it) => it.verties[0][1]));
    const maxY = Math.max(...rowItems.map((it) => it.verties[2][1]));
    const h = maxY - minY;
    for (var columnIndex = 1, len2 = columns.length; columnIndex < len2 && columnItems.length; columnIndex++) {
      const prevCell = columnItems[columnIndex - 1];
      const cell = columnItems[columnIndex];
      const x = prevCell.rect.x + prevCell.rect.width;
      const w2 = cell.rect.x - x;
      const y = prevCell.rect.y;
      result.push({
        type: "column-gap",
        index: columnIndex,
        x,
        y,
        width: w2,
        height: h
      });
    }
    const minX = Math.min(...columnItems.map((it) => it.verties[0][0]));
    const maxX = Math.max(...columnItems.map((it) => it.verties[2][0]));
    const w = maxX - minX;
    for (var rowIndex = 1, len2 = rows.length; rowIndex < len2; rowIndex++) {
      const prevCell = rowItems[rowIndex - 1];
      const cell = rowItems[rowIndex];
      const y = prevCell.rect.y + prevCell.rect.height;
      const h2 = cell.rect.y - y;
      const x = prevCell.rect.x;
      result.push({
        type: "row-gap",
        index: rowIndex,
        x,
        y,
        width: w,
        height: h2
      });
    }
    return result.map((it) => {
      if (it.type === "column-gap") {
        return /* @__PURE__ */ createElementJsx("div", {
          class: "gap-tool column-gap",
          style: {
            left: Length.px(it.x * scale2),
            top: Length.px(it.y * scale2),
            width: Length.px(Math.max(it.width * scale2, 5)),
            height: Length.px(it.height * scale2)
          }
        });
      } else if (it.type === "row-gap") {
        return /* @__PURE__ */ createElementJsx("div", {
          class: "gap-tool row-gap",
          style: {
            left: Length.px(it.x * scale2),
            top: Length.px(it.y * scale2),
            height: Length.px(Math.max(it.height * scale2, 5)),
            width: Length.px(it.width * scale2)
          }
        });
      }
      return "";
    });
  }
  isSelectedColumn(index2) {
    const current = this.$context.selection.current;
    return current.gridColumnStart <= index2 && index2 < current.gridColumnEnd;
  }
  isSelectedRow(index2) {
    const current = this.$context.selection.current;
    return current.gridRowStart <= index2 && index2 < current.gridRowEnd;
  }
  [LOAD("$grid") + DOMDIFF]() {
    var _a;
    const current = this.getGridTargetLayer();
    if (!current)
      return "";
    if (current.isLayout(Layout.GRID) === false)
      return "";
    const info = this.getGridLayoutInformation();
    const totalCount = info.columns.length * info.rows.length;
    const isChild = ((_a = this.$context.selection.current) == null ? void 0 : _a.id) !== info.current.id;
    return /* @__PURE__ */ createElementJsx(FragmentInstance, null, Array.from(Array(info.columns.length).keys()).map((index2) => {
      const selected = isChild && this.isSelectedColumn(index2 + 1) ? "selected" : "";
      return /* @__PURE__ */ createElementJsx("div", {
        class: `grid-item-tool column ${selected}`,
        "data-index": index2,
        style: {
          "grid-column": `${index2 + 1} / span 1`,
          "grid-row": `1 / span 1`
        }
      }, /* @__PURE__ */ createElementJsx("div", {
        class: "grid-item-tool-inner"
      }, /* @__PURE__ */ createElementJsx("div", {
        class: "item",
        "data-index": index2
      }, /* @__PURE__ */ createElementJsx("span", null, info.columns[index2])), /* @__PURE__ */ createElementJsx("div", {
        class: "drag-handle right"
      }, /* @__PURE__ */ createElementJsx("div", {
        class: "column-delete",
        "data-index": index2,
        title: `Delete ${info.columns[index2]}`
      }, iconUse("close")), /* @__PURE__ */ createElementJsx("div", {
        class: "column-add",
        "data-index": index2,
        title: `Add ${info.columns[index2]}`
      }, iconUse("add")))));
    }), /* @__PURE__ */ createElementJsx("div", {
      class: "grid-item-tool append column-plus",
      style: {
        "grid-column": `${info.columns.length} / span 1`,
        "grid-row": `1 / span 1`
      }
    }, iconUse("add")), Array.from(Array(info.rows.length).keys()).map((index2) => {
      const selected = isChild && this.isSelectedRow(index2 + 1) ? "selected" : "";
      return /* @__PURE__ */ createElementJsx(FragmentInstance, null, /* @__PURE__ */ createElementJsx("div", {
        class: `grid-item-tool row ${selected}`,
        style: {
          "grid-row": `${index2 + 1} / span 1`,
          "grid-column": `1 / span 1`
        }
      }, /* @__PURE__ */ createElementJsx("div", {
        class: "grid-item-tool-inner"
      }, /* @__PURE__ */ createElementJsx("div", {
        class: "item",
        "data-index": index2
      }, /* @__PURE__ */ createElementJsx("span", null, info.rows[index2])), /* @__PURE__ */ createElementJsx("div", {
        class: "drag-handle bottom"
      }, /* @__PURE__ */ createElementJsx("div", {
        class: "row-delete",
        "data-index": index2,
        title: `Delete ${info.rows[index2]}`
      }, iconUse("close")), /* @__PURE__ */ createElementJsx("div", {
        class: "row-add",
        "data-index": index2,
        title: `Add ${info.rows[index2]}`
      }, iconUse("add"))))));
    }), /* @__PURE__ */ createElementJsx("div", {
      class: "grid-item-tool append row-plus",
      style: {
        "grid-row": `${info.rows.length} / span 1`,
        "grid-column": `1 / span 1`
      }
    }, iconUse("add")), Array.from(Array(totalCount).keys()).map((i) => {
      const column = i % info.columns.length;
      const row = Math.floor(i / info.columns.length);
      return /* @__PURE__ */ createElementJsx(FragmentInstance, null, /* @__PURE__ */ createElementJsx("div", {
        class: "grid-item",
        "data-row": row + 1,
        "data-column": column + 1,
        style: {
          "grid-column": `${column + 1} / span 1`,
          "grid-row": `${row + 1} / span 1`
        }
      }));
    }));
  }
  [SUBSCRIBE("refreshGridToolInfo")]() {
    this.refresh();
  }
  [SUBSCRIBE(UPDATE_VIEWPORT)]() {
    this.refresh();
  }
  [SUBSCRIBE(REFRESH_SELECTION) + DEBOUNCE(100)]() {
    this.refresh();
  }
  [SUBSCRIBE(UPDATE_CANVAS)]() {
    this.refresh();
  }
}
var GridLayoutEditor$1 = "";
class GridLayoutEditor extends EditorElement {
  modifyData(key, value) {
    this.parent.trigger(this.props.onchange, key, value);
  }
  template() {
    return `
            <div class='elf--grid-layout-editor' ref='$body' ></div>
        `;
  }
  [LOAD("$body") + DOMDIFF]() {
    const current = this.$context.selection.current;
    if (!current)
      return "";
    if (current.isLayout(Layout.GRID) === false)
      return "";
    return `
            <div class="grid-layout-item">
            ${createComponent("NumberInputEditor", {
      wide: true,
      label: "grid padding",
      key: "padding",
      ref: "$padding",
      value: current.paddingTop,
      min: 0,
      max: 300,
      step: 1,
      onchange: "changePadding"
    })}
            </div>
            <div class='grid-layout-item'>
                ${createComponent("GridGapEditor", {
      label: this.$i18n("grid.layout.editor.column.gap"),
      ref: "$columnGap",
      key: "gridColumnGap",
      value: current.gridColumnGap || "",
      onchange: "changeKeyValue"
    })}
            </div>              
            <div class='grid-layout-item'>
                ${createComponent("GridGapEditor", {
      label: this.$i18n("grid.layout.editor.row.gap"),
      ref: "$rowGap",
      key: "gridRowGap",
      value: current.gridRowGap || "",
      onchange: "changeKeyValue"
    })}
            </div>
        `;
  }
  [SUBSCRIBE_SELF("changePadding")](key, value) {
    this.modifyData(key, {
      paddingTop: value,
      paddingLeft: value,
      paddingRight: value,
      paddingBottom: value
    });
  }
  [SUBSCRIBE_SELF("changeKeyValue")](key, value, params) {
    this.modifyData(key, value, params);
  }
}
var LayoutProperty$1 = "";
class LayoutProperty extends BaseProperty {
  getTitle() {
    return this.$i18n("layout.property.title");
  }
  getClassName() {
    return "elf--layout-property";
  }
  getBody() {
    return `
        <div ref='$layoutProperty'></div>
      `;
  }
  getTools() {
    return `
      <div ref='$layoutType'></div>
    `;
  }
  [LOAD("$layoutType")]() {
    const current = this.$context.selection.current;
    if (!current)
      return "";
    return createComponent("SelectIconEditor", {
      ref: "$layout",
      key: "layout",
      height: 24,
      value: current.layout,
      options: [Layout.DEFAULT, Layout.FLEX, Layout.GRID],
      icons: ["layout_default", "layout_flex", "layout_grid"],
      onchange: "changeLayoutType"
    });
  }
  [LOAD("$layoutProperty") + DOMDIFF]() {
    var current = this.$context.selection.current || { layout: "default" };
    return `
      <div class='layout-list' ref='$layoutList'>
        <div data-value='default' class='${current.layout === "default" ? "selected" : ""}'></div>
        <div data-value='flex' class='${current.layout === "flex" ? "selected" : ""}'>
          ${createComponent("FlexLayoutEditor", {
      ref: "$flex",
      key: "flex-layout",
      value: {
        "flex-direction": current.flexDirection,
        "flex-wrap": current.flexWrap,
        "justify-content": current.justifyContent,
        "align-items": current.alignItems,
        "align-content": current.alignContent,
        gap: current.gap
      },
      onchange: "changeLayoutInfo"
    })}
        </div>
        <div data-value='grid' class='${current.layout === "grid" ? "selected" : ""}'>
          ${createComponent("GridLayoutEditor", {
      ref: "$grid",
      key: "grid-layout",
      value: current["grid-layout"] || "",
      onchange: "changeLayoutInfo"
    })}
        </div>
      </div>
    `;
  }
  [SUBSCRIBE_SELF("changeLayoutInfo")](key, value) {
    if (key === "padding") {
      this.$commands.executeCommand("setAttribute", "change padding", this.$context.selection.packByValue(value));
    } else {
      this.$commands.executeCommand("setAttribute", "change layout info", this.$context.selection.packByValue({
        [key]: value
      }));
    }
    this.nextTick(() => {
      this.emit("refreshAllElementBoundSize");
    });
  }
  [SUBSCRIBE_SELF("changeLayoutType")](key, value) {
    this.$context.selection.reset(this.$context.selection.packByValue({
      [key]: value
    }));
    this.updateTitle();
    this.$commands.executeCommand("setAttribute", "change layout type", this.$context.selection.packByValue({
      [key]: value
    }));
    this.nextTick(() => {
      this.refresh();
    });
  }
  get editableProperty() {
    return "layout";
  }
  enableHasChildren() {
    return this.$context.selection.current.enableHasChildren();
  }
  updateTitle() {
    this.setTitle(this.$context.selection.current.layout + " Layout");
  }
  [SUBSCRIBE(REFRESH_SELECTION) + IF("checkShow") + IF("enableHasChildren")]() {
    this.updateTitle();
    this.refresh();
  }
}
var ResizingItemProperty$1 = "";
class ResizingItemProperty extends BaseProperty {
  getTitle() {
    return this.$i18n("layout.property.resizing.self.title");
  }
  getClassName() {
    return "elf--resizing-item-property";
  }
  getBody() {
    return `
        <div ref='$body'>
          <div class="resizing-mode">
            <div class="resizing-box" ref="$resizingModeInfo"></div>
            <div ref="$resizingModeInfoInput"></div>
          </div>
        </div>
      `;
  }
  [LOAD("$resizingModeInfo") + DOMDIFF]() {
    var current = this.$context.selection.current || {};
    const h = current.resizingHorizontal || ResizingMode.FIXED;
    const v = current.resizingVertical || ResizingMode.FIXED;
    return `
      <div class="resizing-mode-box" data-horizontal="${h}" data-vertical="${v}">
        <div class="rect">
          <div class="tool">
            <div class="vertical">
              <div class="vertical-top" data-key="resizingVertical">${iconUse("keyboard_arrow_up")}</div>
              <div class="vertical-bottom" data-key="resizingVertical">${iconUse("keyboard_arrow_down")}</div>
            </div>
            <div class="horizontal">
              <div class="horizontal-left" data-key="resizingHorizontal">${iconUse("keyboard_arrow_left")}</div>
              <div class="horizontal-right" data-key="resizingHorizontal">${iconUse("keyboard_arrow_right")}</div>
            </div>
          </div>         
          <div class="inner-rect"></div>
        </div>

      </div>
    `;
  }
  makeOptionsForHorizontal() {
    const options2 = [
      { value: ResizingMode.FIXED, text: "Fixed Width" },
      { value: ResizingMode.FILL_CONTAINER, text: "Fill Container" }
    ];
    return options2;
  }
  makeOptionsForVertical() {
    const options2 = [
      { value: ResizingMode.FIXED, text: "Fixed Height" },
      { value: ResizingMode.FILL_CONTAINER, text: "Fill Container" }
    ];
    return options2;
  }
  [LOAD("$resizingModeInfoInput") + DOMDIFF]() {
    var current = this.$context.selection.current || {};
    this.setState({
      resizingHorizontal: (current == null ? void 0 : current.resizingHorizontal) || ResizingMode.FIXED,
      resizingVertical: (current == null ? void 0 : current.resizingVertical) || ResizingMode.FIXED
    }, false);
    return `
      <div class="has-label-grid">
        <label data-direction="horizontal"></label>
        ${createComponent("SelectEditor", {
      ref: "$resizingHorizontal",
      key: "resizingHorizontal",
      value: this.state.resizingHorizontal,
      options: this.makeOptionsForHorizontal(),
      onchange: "changeResizingMode"
    })}
      </div>

      <div class="has-label-grid">
      <label data-direction="vertical"></label>
        ${createComponent("SelectEditor", {
      ref: "$resizingVertical",
      key: "resizingVertical",
      value: this.state.resizingVertical,
      options: this.makeOptionsForVertical(),
      onchange: "changeResizingMode"
    })}
      </div>
    `;
  }
  [CLICK("$resizingModeInfo [data-key]")](e) {
    const key = e.$dt.data("key");
    const current = this.$context.selection.current;
    if (current[key] === ResizingMode.FIXED) {
      this.trigger("changeResizingMode", key, ResizingMode.FILL_CONTAINER);
    } else {
      this.trigger("changeResizingMode", key, ResizingMode.FIXED);
    }
  }
  [SUBSCRIBE_SELF("changeResizingMode")](key, value) {
    this.$commands.executeCommand("setAttribute", "apply self resizing", this.$context.selection.packByValue({
      [key]: value,
      "flex-grow": 1
    }));
    this.nextTick(() => {
      this.refresh();
    }, 100);
  }
  [SUBSCRIBE(REFRESH_SELECTION) + DEBOUNCE(100)]() {
    this.refreshShow(() => {
      var _a, _b;
      var current = this.$context.selection.current;
      return ((_a = current == null ? void 0 : current.parent) == null ? void 0 : _a.hasLayout()) && ((_b = current == null ? void 0 : current.parent) == null ? void 0 : _b.isLayout(Layout.GRID)) === false;
    });
  }
  [SUBSCRIBE(UPDATE_CANVAS)]() {
    const current = this.$context.selection.current;
    if (current && current.changedLayoutItem) {
      if (current.resizingHorizontal !== this.state.resizingHorizontal || current.resizingVertical !== this.state.resizingVertical) {
        this.refresh();
      }
    }
  }
}
var ResizingProperty$1 = "";
class ResizingProperty extends BaseProperty {
  getTitle() {
    return this.$i18n("layout.property.resizing.title");
  }
  getClassName() {
    return "elf--resizing-property";
  }
  getBody() {
    return `
        <div ref='$body'>
          <div class="resizing-mode">
            <div class="resizing-box" ref="$resizingModeInfo"></div>
            <div ref="$resizingModeInfoInput"></div>
          </div>
        </div>
      `;
  }
  [LOAD("$resizingModeInfo") + DOMDIFF]() {
    var current = this.$context.selection.current || {};
    const h = current.resizingHorizontal || ResizingMode.FIXED;
    const v = current.resizingVertical || ResizingMode.FIXED;
    return `
      <div class="resizing-mode-box" data-horizontal="${h}" data-vertical="${v}">
        <div class="rect">
          <div class="vertical" data-key="resizingVertical">
            <div class="vertical-top">${iconUse("keyboard_arrow_down")}</div>
            <div class="vertical-bottom">${iconUse("keyboard_arrow_up")}</div>
          </div>
          <div class="horizontal" data-key="resizingHorizontal">
            <div class="horizontal-left">${iconUse("keyboard_arrow_right")}</div>
            <div class="horizontal-right">${iconUse("keyboard_arrow_left")}</div>
          </div>
          <div class="inner-rect"></div>
          <div class="inner-horizontal-rect"></div>
          <div class="inner-vertical-rect"></div>
        </div>
      </div>
    `;
  }
  makeOptionsForHorizontal() {
    const options2 = [
      { value: ResizingMode.FIXED, text: "Fixed Width" },
      { value: ResizingMode.HUG_CONTENT, text: "Hug Content" }
    ];
    return options2;
  }
  makeOptionsForVertical() {
    const options2 = [
      { value: ResizingMode.FIXED, text: "Fixed Height" },
      { value: ResizingMode.HUG_CONTENT, text: "Hug Content" }
    ];
    return options2;
  }
  [LOAD("$resizingModeInfoInput")]() {
    var current = this.$context.selection.current || {};
    return `
      <div class="has-label-grid">
        <label data-direction="horizontal"></label>
        ${createComponent("SelectEditor", {
      ref: "$resizingHorizontal",
      key: "resizingHorizontal",
      value: (current == null ? void 0 : current.resizingHorizontal) || ResizingMode.FIXED,
      options: this.makeOptionsForHorizontal(),
      onchange: "changeResizingMode"
    })}
      </div>

      <div class="has-label-grid">
      <label data-direction="vertical"></label>
        ${createComponent("SelectEditor", {
      ref: "$resizingVertical",
      key: "resizingVertical",
      value: (current == null ? void 0 : current.resizingVertical) || ResizingMode.FIXED,
      options: this.makeOptionsForVertical(),
      onchange: "changeResizingMode"
    })}
      </div>
    `;
  }
  [CLICK("$resizingModeInfo [data-key]")](e) {
    const key = e.$dt.data("key");
    const current = this.$context.selection.current;
    if (current[key] === ResizingMode.FIXED) {
      this.trigger("changeResizingMode", key, ResizingMode.HUG_CONTENT);
    } else {
      this.trigger("changeResizingMode", key, ResizingMode.FIXED);
    }
  }
  [SUBSCRIBE_SELF("changeResizingMode")](key, value) {
    this.$commands.executeCommand("setAttribute", "apply constraints", this.$context.selection.packByValue({
      [key]: value
    }));
    this.nextTick(() => {
      this.refresh();
    }, 100);
  }
  [SUBSCRIBE(REFRESH_SELECTION) + DEBOUNCE(100)]() {
    this.refreshShow(() => {
      var current = this.$context.selection.current;
      return current && current.hasLayout();
    });
  }
}
function layout$2(editor) {
  editor.registerElement({
    FlexLayoutEditor,
    GridLayoutEditor,
    GridBoxEditor,
    GridGapEditor
  });
  editor.registerUI("inspector.tab.style", {
    LayoutProperty,
    ResizingProperty,
    ResizingItemProperty,
    DefaultLayoutItemProperty
  });
  editor.registerUI("canvas.view", {
    FlexGrowToolView,
    GridGrowToolView
  }, CanvasViewToolLevel.LAYOUT_TOOL);
}
var LineView$1 = "";
class LineView extends EditorElement {
  template() {
    return /* @__PURE__ */ createElementJsx("div", {
      class: "elf--line-view sepia(0.2)"
    });
  }
  [CONFIG("vertical.line")]() {
    this.refresh();
  }
  [CONFIG("horizontal.line")]() {
    this.refresh();
  }
  [SUBSCRIBE(UPDATE_VIEWPORT, UPDATE_CANVAS)]() {
    this.refresh();
  }
  [LOAD("$el") + DOMDIFF]() {
    return [
      ...this.$config.get("vertical.line").map((it, index2) => {
        const screen2 = this.$viewport.applyVertex([0, it, 0]);
        return /* @__PURE__ */ createElementJsx("div", {
          class: "vertical-line",
          "data-index": index2,
          style: `transform: translate3d(0px, ${screen2[1]}px, 0px);`
        });
      }),
      ...this.$config.get("horizontal.line").map((it, index2) => {
        const screen2 = this.$viewport.applyVertex([it, 0, 0]);
        return /* @__PURE__ */ createElementJsx("div", {
          class: "horizontal-line",
          "data-index": index2,
          style: `transform: translate3d(${screen2[0]}px, 0px, 0px);`
        });
      })
    ];
  }
  [POINTERSTART("$el .horizontal-line") + MOVE("moveHorizontalLine") + END("moveEndHorizontalLine")](e) {
    this.startIndex = +e.$dt.data("index");
    this.$context.snapManager.clear();
  }
  moveHorizontalLine() {
    const newPos = this.$context.snapManager.getWorldPosition();
    this.$config.setIndexValue("horizontal.line", this.startIndex, newPos[0]);
  }
  moveEndHorizontalLine() {
    this.$commands.emit("recoverCursor");
  }
  [POINTERSTART("$el .vertical-line") + MOVE("moveVerticalLine") + END("moveEndVerticalLine")](e) {
    this.startIndex = +e.$dt.data("index");
    this.$context.snapManager.clear();
  }
  moveVerticalLine() {
    const newPos = this.$context.snapManager.getWorldPosition();
    this.$config.setIndexValue("vertical.line", this.startIndex, newPos[1]);
  }
  moveEndVerticalLine() {
    this.$commands.emit("recoverCursor");
  }
}
function lineView(editor) {
  editor.registerUI("canvas.view", {
    LineView
  });
}
var DrawManager$1 = "";
class DrawManager extends EditorElement {
  initState() {
    return {
      tolerance: 1,
      stroke: "black",
      "stroke-width": 2,
      "stroke-linecap": "round",
      "stroke-linejoin": "round",
      msg: this.$i18n("path.manager.msg")
    };
  }
  [SUBSCRIBE(REFRESH_SELECTION)]() {
    var _a, _b;
    var current = this.$context.selection.current;
    if (current) {
      (_a = this.children.$stroke) == null ? void 0 : _a.setValue(current.stroke || "rgba(0, 0, 0, 1)");
      (_b = this.children.$strokeWidth) == null ? void 0 : _b.setValue(current.strokeWidth || Length.number(1));
    }
  }
  [SUBSCRIBE("setColorAsset")]({ color: color2 }) {
    if (this.$el.isShow()) {
      this.setState({
        stroke: color2
      }, false);
      this.children.$stroke.setValue(color2);
      this.updateData({
        stroke: color2
      });
    }
  }
  template() {
    return `
      <div class='elf--draw-manager'>
        <div class="tools left" ref="$left">
            <button type="button" class="primary" data-value='DrawEditorDone' title='${this.$i18n("draw.manager.mode.modify")}' >Done</button>
        </div>      
        <div class='tools'>   
          <div >        
            <label data-tooltip="${this.$i18n("draw.manager.tolerance")}">Tolerance</label>       
            ${createComponent("NumberInputEditor", {
      ref: "$tolerance",
      key: "tolerance",
      value: 1,
      min: 0,
      max: 100,
      step: 0.01,
      unit: "number",
      onchange: "changeValue"
    })}
          </div>              
          <div >
            <label>${this.$i18n("svg.item.property.stroke")}</label>          
            ${createComponent("FillSingleEditor", {
      ref: "$stroke",
      simple: true,
      value: this.state.stroke,
      key: "stroke",
      onchange: "changeValue"
    })}
          </div>

          <div >
            <label>${this.$i18n("svg.item.property.strokeWidth")}</label>          
            ${createComponent("NumberInputEditor", {
      ref: "$strokeWidth",
      key: "strokeWidth",
      value: this.state["strokeWidth"],
      onchange: "changeValue"
    })}
          </div>      
          

          <div>
            <label data-tooltip="${this.$i18n("svg.item.property.lineCap")}">Cap</label>          
            ${createComponent("SelectEditor", {
      ref: "$strokeLineCap",
      key: "strokeLinecap",
      value: this.state["strokeLinecap"],
      options: ["butt", "round", "square"],
      onchange: "changeValue"
    })}
          </div> 
          <div>
            <label data-tooltip="${this.$i18n("svg.item.property.lineJoin")}">Join</label>          
            ${createComponent("SelectEditor", {
      ref: "$strokeLineJoin",
      key: "strokeLinejoin",
      value: this.state["strokeLinejoin"],
      options: ["miter", "bevel", "round"],
      onchange: "changeValue"
    })}
          </div>
        </div>
      </div>    
    `;
  }
  [SUBSCRIBE_SELF("changeValue")](key, value) {
    this.updateData({
      [key]: value
    });
  }
  updateData(obj2 = {}) {
    this.setState(obj2, false);
    this.state.instance.trigger(this.state.changeEvent, obj2);
  }
  [SUBSCRIBE("changePathManager")](mode) {
    this.setState({ mode });
  }
  [SUBSCRIBE("showDrawManager")](obj2 = {}) {
    obj2.changeEvent = obj2.changeEvent || "changeDrawManager";
    this.setState(obj2);
    this.$el.show();
    this.emit("hidePathManager");
  }
  [SUBSCRIBE("hideDrawManager")]() {
    this.$el.hide();
  }
  [CLICK("$left button")](e) {
    var message = e.$dt.attr("data-value");
    this.emit(message);
  }
}
var PathDrawView$1 = "";
const FIELDS$1 = [
  "fill",
  "fill-opacity",
  "stroke",
  "stroke-width",
  "stroke-linecap",
  "stroke-linejoin"
];
class PathDrawView extends EditorElement {
  initialize() {
    super.initialize();
    this.pathParser = new PathParser();
  }
  initState() {
    return {
      points: [],
      $target: null,
      fill: "transparent",
      stroke: "black",
      "fill-opacity": null,
      "stroke-width": 2,
      "stroke-linecap": "round",
      "stroke-linejoin": "round",
      tolerance: 1
    };
  }
  [SUBSCRIBE("changeDrawManager")](obj2) {
    this.setState(__spreadValues({}, obj2), false);
  }
  get scale() {
    return this.$viewport.scale;
  }
  template() {
    return `
        <div class='elf--path-draw-view' tabIndex="-1">
            <div class='path-draw-container' ref='$view'></div>
        </div>`;
  }
  initRect(isForce = false) {
    if (!this.state.rect || isForce) {
      this.state.rect = this.$el.rect();
    }
  }
  [KEYUP("document") + IF("isShow") + ESCAPE + ENTER]() {
    this.trigger("hidePathDrawEditor");
  }
  [SUBSCRIBE("DrawEditorDone")]() {
    this.trigger("hidePathDrawEditor");
  }
  get totalPathLength() {
    if (!this.refs.$view)
      return 0;
    var $obj = this.refs.$view.$("path.object");
    if (!$obj)
      return 0;
    return $obj.totalLength;
  }
  makePathLayer() {
    var layer;
    const newPath = PathParser.makePathByPoints(this.state.points).simplify(this.state.tolerance).smooth(30);
    newPath.transformMat4(this.$viewport.matrixInverse);
    const bbox = newPath.getBBox();
    const newWidth = distance$1(bbox[1], bbox[0]);
    const newHeight = distance$1(bbox[3], bbox[0]);
    newPath.translate(-bbox[0][0], -bbox[0][1]);
    const pathItem = {
      itemType: "svg-path",
      x: bbox[0][0],
      y: bbox[0][1],
      width: newWidth,
      height: newHeight,
      d: newPath.d,
      totalLength: this.totalPathLength
    };
    FIELDS$1.forEach((key) => {
      if (this.state[key])
        Object.assign(pathItem, { [key]: this.state[key] });
    });
    const containerItem = this.$context.selection.currentProject;
    layer = containerItem.appendChild(this.$editor.createModel(pathItem));
    return layer;
  }
  addPathLayer() {
    var pathRect = this.getPathRect();
    if (pathRect.width !== 0 && pathRect.height !== 0) {
      var layer = this.makePathLayer(pathRect);
      if (layer) {
        this.emit("refreshAll");
      }
    }
  }
  changeMode(obj2) {
    this.setState(__spreadValues(__spreadValues({}, this.initState()), obj2), false);
  }
  getCurrentObject() {
    var current = this.state.current;
    if (!current) {
      return null;
    }
    return {
      current,
      d: current.d
    };
  }
  [SUBSCRIBE("showPathDrawEditor")](obj2 = {}) {
    this.changeMode(obj2);
    this.$el.show();
    this.$el.focus();
    this.emit("showDrawManager", {
      instance: this,
      fill: this.state.fill,
      stroke: this.state.stroke,
      "fill-opacity": this.state["fill-opacity"],
      "stroke-width": this.state["stroke-width"],
      "stroke-linecap": this.state["stroke-linecap"],
      "stroke-linejoin": this.state["stroke-linejoin"]
    });
    this.emit("hidePathEditor");
    this.$context.commands.emit("push.mode.view", "PathDrawView");
  }
  [SUBSCRIBE("initPathDrawEditor")]() {
    this.pathParser.reset("");
    this.refs.$view.empty();
  }
  [SUBSCRIBE("hidePathDrawEditor")]() {
    if (this.$el.isShow()) {
      this.trigger("initPathDrawEditor");
      this.$el.hide();
      this.emit("hideDrawManager");
      this.$commands.emit("pop.mode.view", "PathDrawView");
    }
  }
  [SUBSCRIBE("hideAddViewLayer")]() {
    this.$el.hide();
    this.emit("hideDrawManager");
  }
  getInnerId(postfix = "") {
    return "draw-manager-" + postfix;
  }
  get toFillSVG() {
    return SVGFill.parseImage(this.state.fill || "transparent").toSVGString(this.fillId);
  }
  get toStrokeSVG() {
    return SVGFill.parseImage(this.state.stroke || "black").toSVGString(this.strokeId);
  }
  get toDefInnerString() {
    return `
            ${this.toFillSVG}
            ${this.toStrokeSVG}
        `;
  }
  get toDefString() {
    var str = this.toDefInnerString.trim();
    return `
            <defs>
            ${str}
            </defs>
        `;
  }
  get fillId() {
    return this.getInnerId("fill");
  }
  get strokeId() {
    return this.getInnerId("stroke");
  }
  get toFillValue() {
    return SVGFill.parseImage(this.state.fill || "transparent").toFillValue(this.fillId);
  }
  get toStrokeValue() {
    return SVGFill.parseImage(this.state.stroke || "black").toFillValue(this.strokeId);
  }
  [BIND("$view")]() {
    const newPath = PathParser.makePathByPoints(this.state.points).simplify(this.state.tolerance);
    return {
      innerHTML: `
            <svg width="100%" height="100%" class='svg-editor-canvas'>
                ${this.toDefString}
                <path 
                    class='object' 
                    fill="${this.toFillValue}"
                    stroke="${this.toStrokeValue}"
                    fill-opacity="${this.state["fill-opacity"]}"
                    stroke-width="${this.state["stroke-width"]}"
                    stroke-linecap="${this.state["stroke-linecap"]}"
                    stroke-linejoin="${this.state["stroke-linejoin"]}"
                    d="${newPath.d}" 
                />
            </svg>
            `
    };
  }
  renderPath() {
    this.bindData("$view");
  }
  [SUBSCRIBE("resizeEditor")]() {
    this.initRect(true);
  }
  getPathRect() {
    this.initRect(true);
    var $obj = this.refs.$view.$("path.object");
    var pathRect = { x: 0, y: 0, width: 0, height: 0 };
    if ($obj) {
      pathRect = $obj.rect();
      pathRect.x -= this.state.rect.x;
      pathRect.y -= this.state.rect.y;
    }
    return pathRect;
  }
  [POINTERSTART("$view") + MOVE() + END()](e) {
    this.initRect();
    this.state.altKey = false;
    this.state.startXY = {
      x: e.xy.x - this.state.rect.x,
      y: e.xy.y - this.state.rect.y
    };
    this.state.points = [this.state.startXY];
  }
  move(dx, dy, eventType, pressure) {
    this.state.points.push({
      x: this.state.startXY.x + dx,
      y: this.state.startXY.y + dy,
      pressure
    });
    this.renderPath();
  }
  end() {
    this.addPathLayer();
    this.trigger("initPathDrawEditor");
  }
}
function pathDrawView(editor) {
  editor.registerUI("canvas.view", {
    PathDrawView
  });
  editor.registerUI("page.subeditor.view", {
    DrawManager
  });
}
var PathEditorView$1 = "";
const SEGMENT_DIRECTION = ["startPoint", "endPoint", "reversePoint"];
function calculateSnapPoint(points, sourceKey, target, distanceValue, dist2) {
  var checkedPointList = points.filter((p) => {
    if (!p)
      return false;
    return Math.abs(p[sourceKey] - target) <= dist2;
  }).map((p) => {
    return { dist: Math.abs(p[sourceKey] - target), point: p };
  });
  checkedPointList.sort((a, b) => {
    return a.dist < b.dist ? -1 : 1;
  });
  var point2 = null;
  if (checkedPointList.length) {
    point2 = checkedPointList[0].point;
    distanceValue += point2[sourceKey] - target;
  }
  return { point: point2, distanceValue };
}
function calculateMovePointSnap(points, moveXY, dist2 = 1) {
  var snapPointX = calculatePointDist(points, "x", moveXY.x, dist2);
  var snapPointY = calculatePointDist(points, "y", moveXY.y, dist2);
  var snapEndPoint = __spreadValues({}, moveXY);
  if (snapPointX) {
    snapEndPoint.x = snapPointX.x;
  }
  if (snapPointY) {
    snapEndPoint.y = snapPointY.y;
  }
  var snapPointList = [];
  if (snapPointX) {
    snapPointList.push({ startPoint: snapPointX, endPoint: snapEndPoint });
  }
  if (snapPointY) {
    snapPointList.push({ startPoint: snapPointY, endPoint: snapEndPoint });
  }
  return { snapPointList, moveXY: snapEndPoint };
}
function calculatePointDist(points, sourceKey, target, dist2) {
  var checkedPointList = [];
  var arr = SEGMENT_DIRECTION;
  points.filter((p) => p).forEach((p) => {
    arr.filter((key) => p[key]).forEach((key) => {
      var point2 = p[key];
      var tempDist = Math.abs(point2[sourceKey] - target);
      if (tempDist <= dist2) {
        checkedPointList.push({ dist: tempDist, point: point2 });
      }
    });
  });
  checkedPointList.sort((a, b) => {
    return a.dist > b.dist ? 1 : -1;
  });
  return checkedPointList.length ? checkedPointList[0].point : null;
}
function toPath(points, minX, minY, scale2 = 1) {
  var d = [];
  for (var index2 = 0, len2 = points.length; index2 < len2; index2++) {
    var currentIndex = index2;
    var current = points[currentIndex];
    if (!current)
      continue;
    if (current.command === "M") {
      d.push({ command: "M", values: [current.startPoint] });
    } else {
      var prevPoint = Point.getPrevPoint(points, index2);
      if (current.curve === false) {
        if (prevPoint.curve === false) {
          d.push({ command: "L", values: [current.startPoint] });
        } else {
          d.push({
            command: "Q",
            values: [prevPoint.endPoint, current.startPoint]
          });
        }
      } else {
        if (prevPoint.curve === false) {
          if (Point.isEqual(current.reversePoint, current.startPoint)) {
            d.push({ command: "L", values: [current.startPoint] });
          } else {
            d.push({
              command: "Q",
              values: [current.reversePoint, current.startPoint]
            });
          }
        } else {
          d.push({
            command: "C",
            values: [
              prevPoint.endPoint,
              current.reversePoint,
              current.startPoint
            ]
          });
        }
      }
    }
    if (current.close) {
      d.push({ command: "Z" });
    }
  }
  var dString = d.map((segment) => {
    return calculateRelativePosition(minX, minY, segment, scale2);
  }).join(" ");
  return {
    d: dString
  };
}
function calculateRelativePosition(minX, minY, segment, scale2 = 1) {
  var { command, values } = segment;
  switch (command) {
    case "Z":
      return "Z";
    default:
      var str = values.map((v) => {
        var tx = v.x - minX === 0 ? 0 : (v.x - minX) / scale2;
        var ty = v.y - minY === 0 ? 0 : (v.y - minY) / scale2;
        return `${tx} ${ty}`;
      }).join(" ");
      return `${command} ${str}`;
  }
}
function checkInArea(area2, point2) {
  if (area2.x2.value < point2.x) {
    return false;
  }
  if (area2.y2.value < point2.y) {
    return false;
  }
  if (area2.x.value > point2.x) {
    return false;
  }
  if (area2.y.value > point2.y) {
    return false;
  }
  return true;
}
class PathGenerator {
  static generatorPathString(points, minX = 0, minY = 0, scale2 = 1) {
    return toPath(points, minX, minY, scale2).d;
  }
  constructor(pathEditor) {
    this.pathEditor = pathEditor;
    this.pathStringManager = new PathStringManager();
    this.guideLineManager = new PathStringManager();
    this.segmentManager = new SegmentManager(this.pathEditor.$viewport);
    this.points = [];
    this.cachedSegmentKeys = {};
    this.initialize();
    this.initializeSelect();
  }
  initialize() {
    this.splitLines = [];
    this.guideLineManager.reset();
    this.segmentManager.reset();
    this.pathStringManager.reset();
  }
  initializeSelect(initPointList = []) {
    this.selectedPointKeys = {};
    this.selectedPointList = [];
    if (initPointList.length) {
      this.select(...initPointList.map((p) => {
        const checkedPoint = this.points[p.index][p.key];
        if (!checkedPoint)
          return void 0;
        return {
          x: checkedPoint.x,
          y: checkedPoint.y,
          key: p.key,
          index: checkedPoint.index
        };
      }).filter(Boolean));
    }
  }
  get state() {
    return this.pathEditor.state;
  }
  get clonePoints() {
    return [...this.points];
  }
  get length() {
    return this.points.length;
  }
  setPoints(points = []) {
    this.points = points;
    this.snapPointList = [];
    if (this.points.length === 0) {
      this.select();
      this.selectGroup(-1);
    }
  }
  selectInBox(box, isToggle = false) {
    var list2 = [];
    this.points.forEach((point2, index2) => {
      SEGMENT_DIRECTION.forEach((key) => {
        const p = point2[key];
        if (checkInArea(box, p)) {
          list2.push({ x: p.x, y: p.y, key, index: index2 });
        }
      });
    });
    if (isToggle) {
      list2 = list2.map((it) => {
        const selectedKey = this.makeSegmentKey(it);
        return __spreadProps(__spreadValues({}, it), {
          included: Boolean(this.selectedPointKeys[selectedKey])
        });
      });
      const includedList = list2.filter((it) => it.included);
      const notIncludedList = list2.filter((it) => !it.included);
      let uniqueList = [...this.selectedPointList];
      if (includedList.length) {
        uniqueList = this.selectedPointList.filter((it) => {
          const oldKey = this.makeSegmentKey(it);
          return Boolean(includedList.find((includeNode) => {
            return oldKey === this.makeSegmentKey(includeNode);
          })) === false;
        });
      }
      this.select(...uniqueList, ...notIncludedList);
    } else {
      this.select(...list2);
    }
  }
  makeSegmentKey(p) {
    return `${p.key}_${p.index}`;
  }
  select(...list2) {
    this.selectedPointKeys = {};
    this.selectedPointList = list2.map(({ x, y, key, index: index2 }) => ({
      x,
      y,
      key,
      index: +index2
    }));
    list2.forEach((it) => {
      var key = this.makeSegmentKey(it);
      this.selectedPointKeys[key] = true;
    });
  }
  convertPointsToSelectionList(points) {
    var list2 = [];
    points.forEach((point2) => {
      SEGMENT_DIRECTION.forEach((key) => {
        const { x, y } = point2[key];
        list2.push({ x, y, key, index: point2.index });
      });
    });
    return list2;
  }
  selectGroup(groupIndex) {
    const group2 = this.splitedGroupList[groupIndex];
    if (group2) {
      this.select(...this.convertPointsToSelectionList(group2.points));
    } else {
      this.select();
    }
  }
  getCacheSegmentKey(segmentKey, index2) {
    if (!this.cachedSegmentKeys[segmentKey]) {
      this.cachedSegmentKeys[segmentKey] = {};
    }
    if (!this.cachedSegmentKeys[segmentKey][index2]) {
      this.cachedSegmentKeys[segmentKey][index2] = this.makeSegmentKey({
        key: segmentKey,
        index: index2
      });
    }
    return this.cachedSegmentKeys[segmentKey][index2];
  }
  toggleSelect(key, index2) {
    if (this.points[index2]) {
      var point2 = this.points[index2][key];
      if (point2 && !this.isSelectedSegment(key, index2)) {
        this.select(...this.selectedPointList, {
          x: point2.x,
          y: point2.y,
          key,
          index: index2
        });
      } else {
        this.select(...this.selectedPointList.filter((it) => {
          return it.key !== key || it.index !== index2;
        }));
      }
    }
  }
  selectKeyIndex(key, index2) {
    if (this.points[index2]) {
      var point2 = this.points[index2][key];
      if (point2 && !this.isSelectedSegment(key, index2)) {
        this.select({ x: point2.x, y: point2.y, key, index: index2 });
      }
    }
  }
  reselect() {
    this.selectedPointList.filter(Boolean).forEach((it) => {
      var _a;
      var point2 = (_a = this.points[it.index]) == null ? void 0 : _a[it.key];
      if (point2) {
        it.x = point2.x;
        it.y = point2.y;
      }
    });
  }
  isSelectedSegment(segment, index2) {
    var key = this.getCacheSegmentKey(segment, index2);
    return this.selectedPointKeys[key];
  }
  commitTransformMatrix(point2, transformMatrix) {
    var result = transformMat4([], [point2.x, point2.y, 0], transformMatrix);
    return { x: result[0], y: result[1] };
  }
  transformMat4(transformMatrix) {
    this.transformPoints.forEach((p, index2) => {
      var realPoint = this.points[index2];
      Object.assign(realPoint.startPoint, this.commitTransformMatrix(p.startPoint, transformMatrix));
      Object.assign(realPoint.endPoint, this.commitTransformMatrix(p.endPoint, transformMatrix));
      Object.assign(realPoint.reversePoint, this.commitTransformMatrix(p.reversePoint, transformMatrix));
    });
  }
  transform(type) {
    var { x, y, width: width2, height: height2 } = this.transformRect;
    var view = create$4();
    translate(view, view, [x, y, 0]);
    switch (type) {
      case "flipX":
        scale$1(view, view, [-1, 1, 1]);
        translate(view, view, [-width2, 0, 0]);
        break;
      case "flipY":
        scale$1(view, view, [1, -1, 1]);
        translate(view, view, [0, -height2, 0]);
        break;
      case "flip":
        scale$1(view, view, [-1, -1, 1]);
        translate(view, view, [-width2, -height2, 0]);
        break;
    }
    translate(view, view, [-x, -y, 0]);
    this.transformMat4(view);
  }
  initTransform(rect2) {
    this.transformRect = clone$1(rect2);
    this.transformPoints = this.clonePoints.map((p) => {
      return {
        startPoint: clone$1(p.startPoint),
        endPoint: clone$1(p.endPoint),
        reversePoint: clone$1(p.reversePoint)
      };
    });
  }
  setConnectedPoint(dx, dy) {
    var state = this.state;
    var x = state.dragXY.x + dx;
    var y = state.dragXY.y + dy;
    var endPoint = { x, y };
    var reversePoint = { x, y };
    if (state.dragPoints) {
      state.reversePoint = Point.getReversePoint(state.startPoint, endPoint);
    }
    var point2 = {
      startPoint: state.startPoint,
      endPoint,
      curve: !!state.dragPoints,
      reversePoint,
      connected: true,
      close: true
    };
    this.points.push(point2);
  }
  setLastPoint(startPoint) {
    var endPoint = clone$1(startPoint);
    var reversePoint = clone$1(startPoint);
    var point2 = {
      startPoint,
      endPoint,
      curve: false,
      reversePoint,
      connected: false,
      close: false
    };
    this.points.push(point2);
  }
  getPrevPoint(index2) {
    return Point.getPrevPoint(this.points, index2);
  }
  getIndexPoint(index2) {
    return Point.getIndexPoint(this.points, index2);
  }
  getNextPoint(index2) {
    return Point.getNextPoint(this.points, index2);
  }
  getConnectedPointList(index2) {
    return Point.getConnectedPointList(this.points, index2);
  }
  isFirst(segment) {
    return Point.isFirst(segment);
  }
  getLastPoint(index2) {
    return Point.getLastPoint(this.points, index2);
  }
  setCachePoint(index2, segmentKey) {
    var state = this.state;
    this.snapPointList = [];
    this.selectedIndex = index2;
    state.connectedPoint = this.getPrevPoint(index2);
    state.connectedPointList = clone$1(Point.getConnectedPointList(this.points, this.selectedIndex));
    if (state.connectedPoint && !state.connectedPoint.connected) {
      state.connectedPoint = null;
    }
    state.segment = this.getIndexPoint(index2);
    if (state.segment.connected) {
      state.connectedPoint = this.getNextPoint(index2);
    }
    var isFirstSegment = this.isFirst(state.segment);
    if (isFirstSegment) {
      var lastPoint = this.getLastPoint(index2);
      if (lastPoint.connected) {
        state.connectedPoint = lastPoint;
      }
    }
    state.segmentKey = segmentKey;
    state.isCurveSegment = state.segment.curve && state.segmentKey != "startPoint";
    state.originalSegment = clone$1(state.segment);
    if (state.connectedPoint) {
      state.originalConnectedPoint = clone$1(state.connectedPoint);
    }
    state.cachedPoints = [];
    this.points.filter((p) => p && p != state.segment).forEach((p) => {
      state.cachedPoints.push(p.startPoint, p.reversePoint, p.endPoint);
    });
  }
  moveSegment(segmentKey, dx, dy, originSegment = void 0) {
    if (originSegment) {
      const segment = this.points[originSegment.index][segmentKey];
      segment.x = originSegment[segmentKey].x + dx;
      segment.y = originSegment[segmentKey].y + dy;
    } else {
      var state = this.state;
      var originPoint = state.originalSegment[segmentKey];
      var targetPoint = state.segment[segmentKey];
      if (originPoint) {
        targetPoint.x = originPoint.x + dx;
        targetPoint.y = originPoint.y + dy;
      }
    }
  }
  calculateToCurve(point2, nextPoint, prevPoint) {
    var centerX = (nextPoint.startPoint.x + prevPoint.startPoint.x) / 2;
    var centerY = (nextPoint.startPoint.y + prevPoint.startPoint.y) / 2;
    var dx = (nextPoint.startPoint.x - centerX) / 2;
    var dy = (nextPoint.startPoint.y - centerY) / 2;
    point2.endPoint = {
      x: point2.startPoint.x + dx,
      y: point2.startPoint.y + dy
    };
    point2.reversePoint = {
      x: point2.startPoint.x - dx,
      y: point2.startPoint.y - dy
    };
    return { dx, dy };
  }
  convertToCurve(index2) {
    var point2 = this.points[index2];
    if (point2.curve) {
      point2.curve = false;
      point2.reversePoint = clone$1(point2.startPoint);
      point2.endPoint = clone$1(point2.startPoint);
      if (point2.command === "M") {
        var lastPoint = Point.getPrevPoint(this.points, point2.index);
        if (lastPoint.connected) {
          lastPoint.curve = false;
          lastPoint.reversePoint = clone$1(lastPoint.startPoint);
          lastPoint.endPoint = clone$1(lastPoint.startPoint);
        }
      } else {
        var nextPoint = this.getNextPoint(index2);
        if (nextPoint && nextPoint.command === "M") {
          var firstPoint = nextPoint;
          firstPoint.curve = false;
          firstPoint.reversePoint = clone$1(firstPoint.startPoint);
          firstPoint.endPoint = clone$1(firstPoint.startPoint);
        }
      }
    } else {
      point2.curve = true;
      var prevPoint = this.getPrevPoint(index2);
      var nextPoint = this.getNextPoint(index2);
      if (nextPoint && nextPoint.index < index2 && nextPoint.command === "M") {
        var firstPoint = nextPoint;
        nextPoint = this.getNextPoint(firstPoint.index);
        this.calculateToCurve(point2, nextPoint, prevPoint);
        firstPoint.curve = true;
        firstPoint.endPoint = clone$1(point2.endPoint);
        firstPoint.reversePoint = clone$1(point2.reversePoint);
      } else if (nextPoint && nextPoint.index > index2 && nextPoint.command !== "M") {
        this.calculateToCurve(point2, nextPoint, prevPoint);
      } else if (!nextPoint && prevPoint) {
        var centerX = (point2.startPoint.x - prevPoint.startPoint.x) / 3;
        var centerY = (point2.startPoint.y - prevPoint.startPoint.y) / 3;
        point2.endPoint = {
          x: point2.startPoint.x + centerX,
          y: point2.startPoint.y + centerY
        };
        point2.reversePoint = Point.getReversePoint(point2.startPoint, point2.endPoint);
      } else if (!prevPoint && nextPoint) {
        var centerX = (point2.startPoint.x - nextPoint.startPoint.x) / 3;
        var centerY = (point2.startPoint.y - nextPoint.startPoint.y) / 3;
        point2.endPoint = {
          x: point2.startPoint.x + centerX,
          y: point2.startPoint.y + centerY
        };
        point2.reverse = Point.getReversePoint(point2.startPoint, point2.endPoint);
      }
    }
  }
  moveCurveSegment(segmentKey, dx, dy) {
    var state = this.state;
    this.moveSegment(segmentKey, dx, dy);
    var targetSegmentKey = segmentKey === "endPoint" ? "reversePoint" : "endPoint";
    state.segment[targetSegmentKey] = Point.getReversePoint(state.segment.startPoint, state.segment[segmentKey]);
  }
  rotateSegmentTarget(segmentKey, target) {
    var state = this.state;
    if (state.originalSegment && state.segment) {
      var { x: cx, y: cy } = state.originalSegment.startPoint;
      var { x: rx, y: ry } = state.segment[segmentKey];
      var { x: tx, y: ty } = state.originalSegment[target];
      var { x, y } = getXYInCircle(calculateAngle360(rx - cx, ry - cy), getDist(tx, ty, cx, cy), cx, cy);
      state.segment[target] = { x, y };
    }
  }
  rotateSegment(segmentKey) {
    this.rotateSegmentTarget(segmentKey, segmentKey === "endPoint" ? "reversePoint" : "endPoint");
  }
  calculateSnap(segmentKey, dx, dy, dist2 = 1) {
    var state = this.state;
    var cachedPoints = state.cachedPoints;
    var original = state.originalSegment[segmentKey];
    if (!segmentKey) {
      return { dx, dy, snapPointList: [] };
    }
    var realX = original.x + dx;
    var realY = original.y + dy;
    var { point: snapPointX, distanceValue: dx } = calculateSnapPoint(cachedPoints, "x", realX, dx, dist2);
    var { point: snapPointY, distanceValue: dy } = calculateSnapPoint(cachedPoints, "y", realY, dy, dist2);
    var snapEndPoint = {
      x: original.x + dx,
      y: original.y + dy
    };
    var snapPointList = [];
    if (snapPointX) {
      snapPointList.push({ startPoint: snapPointX, endPoint: snapEndPoint });
    }
    if (snapPointY) {
      snapPointList.push({ startPoint: snapPointY, endPoint: snapEndPoint });
    }
    return { dx, dy, snapPointList };
  }
  copySegment(from, to) {
    to.startPoint = clone$1(from.startPoint);
    to.endPoint = clone$1(from.endPoint);
    to.reversePoint = clone$1(from.reversePoint);
  }
  get selectedLength() {
    return this.selectedPointList.length;
  }
  moveSelectedSegment(dx, dy) {
    if (this.selectedPointList.length > 0) {
      this.selectedPointList.forEach((it) => {
        var target = this.points[it.index][it.key];
        target.x = it.x + dx;
        target.y = it.y + dy;
      });
    } else if (this.selectedGroup) {
      this.moveSelectedGroup(dx, dy);
    }
  }
  moveSelectedGroup(dx, dy) {
    this.selectedGroup.points.forEach((it) => {
      const target = this.points[it.index];
      target.startPoint.x = it.startPoint.x + dx;
      target.startPoint.y = it.startPoint.y + dy;
      target.endPoint.x = it.endPoint.x + dx;
      target.endPoint.y = it.endPoint.y + dy;
      target.reversePoint.x = it.reversePoint.x + dx;
      target.reversePoint.y = it.reversePoint.y + dy;
    });
  }
  get selectedGroup() {
    return this.splitedGroupList[this.state.selectedGroupIndex];
  }
  get splitedGroupList() {
    return Point.getSplitedGroupList(this.points);
  }
  get groupList() {
    return Point.getGroupList(this.points);
  }
  getGroup(groupList, pointIndex) {
    return Point.getGroup(groupList, pointIndex);
  }
  get selectedGroupIndexList() {
    const groupIndexList = /* @__PURE__ */ new Set();
    const groupList = this.groupList;
    if (this.selectedPointList.length === 0 && this.state.selectedGroupIndex < 0) {
      return groupList.map((group2) => group2.groupIndex);
    }
    const points = this.selectedPointList;
    points.forEach((it) => {
      const group2 = this.getGroup(groupList, it.index);
      if (group2) {
        groupIndexList.add(group2.groupIndex);
      }
    });
    return [.../* @__PURE__ */ new Set([...groupIndexList, this.state.selectedGroupIndex])];
  }
  removeSelectedSegment() {
    this.selectedPointList.forEach((it) => {
      var target = this.points[it.index][it.key];
      target.removed = true;
    });
    const pointGroup = Point.splitPoints(this.points);
    const newPoints = Point.recoverPoints(pointGroup.map((points) => {
      return points.filter((p) => !p.startPoint.removed).map((p) => {
        if (p.endPoint.removed) {
          p.endPoint = clone$1(p.startPoint);
        }
        if (p.reversePoint.removed) {
          p.reversePoint = clone$1(p.startPoint);
        }
        if (Point.isEqual(p.endPoint, p.startPoint, p.reversePoint)) {
          p.command = "L";
          p.curve = false;
        }
        return p;
      });
    }));
    this.points = newPoints;
    this.select();
  }
  move(dx, dy, e) {
    var state = this.state;
    var { isCurveSegment, segmentKey, connectedPoint } = state;
    if (this.selectedPointList.length > 1) {
      this.moveSelectedSegment(dx, dy);
    } else if (this.selectedPointList.length === 1) {
      var { dx, dy, snapPointList } = this.calculateSnap(segmentKey, dx, dy, 3);
      this.snapPointList = snapPointList || [];
      if (isCurveSegment) {
        if (e.shiftKey) {
          this.moveSegment(segmentKey, dx, dy);
          var targetSegmentKey = segmentKey === "endPoint" ? "reversePoint" : "endPoint";
          state.segment[targetSegmentKey] = Point.getReversePoint(state.segment.startPoint, state.segment[segmentKey]);
        } else if (e.altKey) {
          this.moveSegment(segmentKey, dx, dy);
          this.rotateSegment(segmentKey);
        } else {
          this.moveSegment(segmentKey, dx, dy);
        }
      } else {
        this.moveSegment("startPoint", dx, dy);
        this.moveSegment("endPoint", dx, dy);
        this.moveSegment("reversePoint", dx, dy);
        if (!e.altKey) {
          state.connectedPointList.forEach((it) => {
            this.moveSegment("startPoint", dx, dy, it);
            this.moveSegment("endPoint", dx, dy, it);
            this.moveSegment("reversePoint", dx, dy, it);
          });
        }
      }
      connectedPoint && this.copySegment(state.segment, state.connectedPoint);
    } else if (this.state.selectedGroupIndex > -1) {
      this.moveSelectedGroup(dx, dy);
    }
  }
  moveEnd(dx, dy) {
    var state = this.state;
    var points = this.points;
    var x = state.dragXY.x + dx;
    var y = state.dragXY.y + dy;
    var endPoint = { x, y };
    var reversePoint = { x, y };
    if (state.dragPoints) {
      reversePoint = Point.getReversePoint(state.startPoint, endPoint);
    }
    points.push({
      command: state.clickCount === 0 ? "M" : "",
      startPoint: state.startPoint,
      endPoint,
      curve: !!state.dragPoints,
      reversePoint
    });
    state.startPoint = null;
    state.dragPoints = false;
    state.moveXY = null;
  }
  setPoint(obj2) {
    var p0 = obj2.first[0];
    var p1 = obj2.second[obj2.second.length - 1];
    var allPoints = this.clonePoints;
    var firstItem = Point.getPoint(allPoints, p0);
    var secondItem = Point.getPoint(allPoints, p1);
    var newPoints = [
      __spreadProps(__spreadValues({}, firstItem), { endPoint: obj2.first[1] }),
      {
        startPoint: obj2.first[3],
        reversePoint: obj2.first[2],
        curve: true,
        endPoint: obj2.second[1]
      },
      __spreadProps(__spreadValues({}, secondItem), { reversePoint: obj2.second[2] })
    ];
    var firstIndex = Point.getIndex(allPoints, p0);
    allPoints.splice(firstIndex, 2, ...newPoints);
    this.points = allPoints;
    return firstIndex + 1;
  }
  setPointQuard(obj2) {
    var p0 = obj2.first[0];
    var p1 = obj2.second[obj2.second.length - 1];
    var allPoints = this.clonePoints;
    var firstItem = Point.getPoint(allPoints, p0);
    var secondItem = Point.getPoint(allPoints, p1);
    if (firstItem.curve && secondItem.curve === false) {
      var newPoints = [
        __spreadProps(__spreadValues({}, firstItem), { endPoint: firstItem.startPoint }),
        {
          startPoint: obj2.first[2],
          reversePoint: obj2.first[1],
          curve: true,
          endPoint: obj2.second[1]
        }
      ];
      var firstIndex = Point.getIndex(allPoints, p0);
      allPoints.splice(firstIndex, 1, ...newPoints);
    } else {
      var newPoints = [
        __spreadValues({}, firstItem),
        {
          startPoint: obj2.first[2],
          reversePoint: obj2.first[1],
          curve: true,
          endPoint: obj2.second[1]
        },
        __spreadProps(__spreadValues({}, secondItem), { reversePoint: obj2.second[1], curve: true })
      ];
      var firstIndex = Point.getIndex(allPoints, p0);
      allPoints.splice(firstIndex, 2, ...newPoints);
    }
    this.points = allPoints;
    return firstIndex + 1;
  }
  setPointLine(obj2) {
    var p0 = obj2.first[0];
    var allPoints = this.clonePoints;
    var newPoints = [
      {
        command: "L",
        startPoint: obj2.first[1],
        curve: false,
        endPoint: obj2.first[1],
        reversePoint: obj2.first[1]
      }
    ];
    var firstIndex = Point.getIndex(allPoints, p0);
    allPoints.splice(firstIndex + 1, 0, ...newPoints);
    this.points = allPoints;
    return firstIndex + 1;
  }
  toPath(minX = 0, minY = 0, scale2 = 1) {
    return toPath(this.clonePoints, minX, minY, scale2);
  }
  makeSVGPath() {
    this.initialize();
    this.makePointGuide(this.points);
    this.makeMovePositionGuide();
    return this.toSVGString();
  }
  makeTriangleDistancePointGuide(first, second2) {
    var minX = Math.min(first.startPoint.x, second2.startPoint.x);
    var maxX = Math.max(first.startPoint.x, second2.startPoint.x);
    var minY = Math.min(first.startPoint.y, second2.startPoint.y);
    var maxY = Math.max(first.startPoint.y, second2.startPoint.y);
    if (first.startPoint.x < second2.startPoint.x && first.startPoint.y < second2.startPoint.y) {
      this.segmentManager.addDistanceLine({ x: minX, y: minY }, { x: maxX, y: minY }).addDistanceLine({ x: maxX, y: minY }, { x: maxX, y: maxY });
      var centerX = minX;
      var centerY = minY;
      var angle = calculateAngle360(maxX - minX, maxY - minY) - 180;
      var dist2 = 20;
      var { x, y } = getXYInCircle(0, dist2, centerX, centerY);
      var last = getXYInCircle(angle, dist2, centerX, centerY);
      this.segmentManager.addDistanceAngle(last, dist2, dist2, angle, { x, y }, { x: x - dist2, y });
    } else if (first.startPoint.x < second2.startPoint.x && first.startPoint.y > second2.startPoint.y) {
      this.segmentManager.addDistanceLine({ x: minX, y: maxY }, { x: maxX, y: maxY }).addDistanceLine({ x: maxX, y: minY }, { x: maxX, y: maxY });
    } else if (first.startPoint.x > second2.startPoint.x && first.startPoint.y > second2.startPoint.y) {
      this.segmentManager.addDistanceLine({ x: minX, y: minY }, { x: minX, y: maxY }).addDistanceLine({ x: minX, y: maxY }, { x: maxX, y: maxY });
    } else if (first.startPoint.x > second2.startPoint.x && first.startPoint.y < second2.startPoint.y) {
      this.segmentManager.addDistanceLine({ x: minX, y: maxY }, { x: maxX, y: maxY }).addDistanceLine({ x: maxX, y: minY }, { x: maxX, y: maxY });
    }
  }
  makeDistancePointGuide(prevPoint, current, nextPoint) {
    if (current.selected) {
      if (prevPoint) {
        this.makeTriangleDistancePointGuide(prevPoint, current);
      }
      if (nextPoint) {
        this.makeTriangleDistancePointGuide(current, nextPoint);
      }
    }
  }
  makeStartPointGuide(prevPoint, current, nextPoint, index2) {
    current.startPoint.isFirst = true;
    if (current.curve === false) {
      this.segmentManager.addPoint({}, current.startPoint, index2, "startPoint", this.isSelectedSegment("startPoint", index2));
    } else {
      this.segmentManager.addPoint({}, current.startPoint, index2, "startPoint", this.isSelectedSegment("startPoint", index2)).addGuideLine(current.startPoint, current.endPoint);
      if (Point.isEqual(current.startPoint, current.endPoint) === false) {
        this.segmentManager.addCurvePoint(current.endPoint, index2, "endPoint", this.isSelectedSegment("endPoint", index2));
      }
    }
  }
  makeMiddlePointGuideSegment(prevPoint, current, nextPoint, index2, isSiblingSelected) {
    var mng = this.segmentManager;
    if (current.curve === false) {
      if (prevPoint.curve === false) {
        mng.addPoint({}, current.startPoint, index2, "startPoint", this.isSelectedSegment("startPoint", index2));
      } else {
        if (isSiblingSelected === false) {
          mng.addCurvePoint(current.startPoint, index2, "startPoint", this.isSelectedSegment("startPoint", index2));
        } else {
          mng.addGuideLine(prevPoint.startPoint, prevPoint.endPoint).addCurvePoint(current.startPoint, index2, "startPoint", this.isSelectedSegment("startPoint", index2));
          if (Point.isEqual(prevPoint.startPoint, prevPoint.endPoint) === false) {
            mng.addCurvePoint(prevPoint.endPoint, prevPoint.index, "endPoint", this.isSelectedSegment("endPoint", prevPoint.index));
          }
        }
      }
    } else {
      if (prevPoint.curve === false) {
        if (isSiblingSelected === false) {
          if (Point.isEqual(current.reversePoint, current.startPoint)) {
            mng.addPoint({}, current.startPoint, index2, "startPoint", this.isSelectedSegment("startPoint", index2));
          } else {
            mng.addCurvePoint(current.startPoint, index2, "startPoint", this.isSelectedSegment("startPoint", index2));
          }
        } else {
          if (Point.isEqual(current.reversePoint, current.startPoint)) {
            mng.addPoint({}, current.startPoint, index2, "startPoint", this.isSelectedSegment("startPoint", index2));
          } else {
            mng.addGuideLine(current.startPoint, current.reversePoint).addCurvePoint(current.startPoint, index2, "startPoint", this.isSelectedSegment("startPoint", index2));
            if (Point.isEqual(current.startPoint, current.reversePoint) === false) {
              mng.addCurvePoint(current.reversePoint, index2, "reversePoint", this.isSelectedSegment("reversePoint", index2));
            }
          }
        }
      } else {
        if (current.connected) {
          if (isSiblingSelected === false)
            ;
          else {
            mng.addGuideLine(prevPoint.startPoint, prevPoint.endPoint).addGuideLine(current.startPoint, current.reversePoint);
            if (Point.isEqual(prevPoint.startPoint, prevPoint.endPoint) === false) {
              mng.addCurvePoint(prevPoint.endPoint, prevPoint.index, "endPoint", this.isSelectedSegment("endPoint", prevPoint.index));
            }
            if (Point.isEqual(current.startPoint, current.reversePoint) === false) {
              mng.addCurvePoint(current.reversePoint, index2, "reversePoint", this.isSelectedSegment("reversePoint", index2));
            }
          }
        } else {
          if (isSiblingSelected === false) {
            mng.addCurvePoint(current.startPoint, index2, "startPoint", this.isSelectedSegment("startPoint", index2));
          } else {
            mng.addGuideLine(prevPoint.startPoint, prevPoint.endPoint).addGuideLine(current.startPoint, current.reversePoint).addCurvePoint(current.startPoint, index2, "startPoint", this.isSelectedSegment("startPoint", index2));
            if (Point.isEqual(prevPoint.startPoint, prevPoint.endPoint) === false) {
              mng.addCurvePoint(prevPoint.endPoint, prevPoint.index, "endPoint", this.isSelectedSegment("endPoint", prevPoint.index));
            }
            if (Point.isEqual(current.startPoint, current.reversePoint) === false) {
              mng.addCurvePoint(current.reversePoint, index2, "reversePoint", this.isSelectedSegment("reversePoint", index2));
            }
          }
        }
      }
    }
  }
  checkInViewport(point2) {
    const vertext = this.pathEditor.$viewport.applyVertexInverse([
      point2.x,
      point2.y,
      0
    ]);
    return this.pathEditor.$viewport.checkInViewport(vertext);
  }
  makeMiddlePointGuideSplitLine(prevPoint, current, nextPoint, index2, isSiblingSelected) {
    const selected = isSiblingSelected ? "selected" : "";
    if (current.curve === false) {
      if (prevPoint.curve === false) {
        if ((this.checkInViewport(prevPoint.startPoint) || this.checkInViewport(current.startPoint)) === false) {
          return;
        }
        this.splitLines.push(new PathStringManager().M(prevPoint.startPoint).L(current.startPoint).toString(`split-path ${selected}`));
      } else {
        if ((this.checkInViewport(prevPoint.startPoint) || this.checkInViewport(prevPoint.endPoint) || this.checkInViewport(current.startPoint)) === false) {
          return;
        }
        this.splitLines.push(new PathStringManager().M(prevPoint.startPoint).Q(prevPoint.endPoint, current.startPoint).toString(`split-path ${selected}`));
      }
    } else {
      if (prevPoint.curve === false) {
        if (Point.isEqual(current.reversePoint, current.startPoint)) {
          if ((this.checkInViewport(prevPoint.startPoint) || this.checkInViewport(current.startPoint)) === false) {
            return;
          }
          this.splitLines.push(new PathStringManager().M(prevPoint.startPoint).L(current.startPoint).toString(`split-path ${selected}`));
        } else {
          if ((this.checkInViewport(prevPoint.startPoint) || this.checkInViewport(current.reversePoint) || this.checkInViewport(current.startPoint)) === false) {
            return;
          }
          this.splitLines.push(new PathStringManager().M(prevPoint.startPoint).Q(current.reversePoint, current.startPoint).toString(`split-path ${selected}`));
        }
      } else {
        if ((this.checkInViewport(prevPoint.startPoint) || this.checkInViewport(prevPoint.endPoint) || this.checkInViewport(current.reversePoint) || this.checkInViewport(current.startPoint)) === false) {
          return;
        }
        this.splitLines.push(new PathStringManager().M(prevPoint.startPoint).C(prevPoint.endPoint, current.reversePoint, current.startPoint).toString(`split-path ${selected}`));
      }
    }
  }
  makePointGuide(points) {
    for (var index2 = 0, len2 = points.length; index2 < len2; index2++) {
      var currentIndex = index2;
      var current = points[currentIndex];
      if (!current)
        continue;
      var nextPoint = Point.getNextPoint(points, index2);
      var prevPoint = Point.getPrevPoint(points, index2);
      if (prevPoint && prevPoint.command === "M") {
        if (current.startPoint) {
          current.startPoint.isSecond = true;
        }
      }
      if (current.startPoint) {
        if (nextPoint) {
          current.startPoint.isLast = nextPoint.command === "M";
        } else {
          current.startPoint.isLast = index2 === len2 - 1;
        }
      }
      current.selected = this.selectedIndex === index2;
      if (current.command === "M") {
        this.makeStartPointGuide(prevPoint, current, nextPoint, index2);
      } else {
        var isSiblingSelected = Boolean(this.isSelectedSegment("endPoint", prevPoint == null ? void 0 : prevPoint.index) || this.isSelectedSegment("startPoint", prevPoint == null ? void 0 : prevPoint.index) || this.isSelectedSegment("reversePoint", prevPoint == null ? void 0 : prevPoint.index) || this.isSelectedSegment("endPoint", nextPoint == null ? void 0 : nextPoint.index) || this.isSelectedSegment("startPoint", nextPoint == null ? void 0 : nextPoint.index) || this.isSelectedSegment("reversePoint", nextPoint == null ? void 0 : nextPoint.index) || this.isSelectedSegment("endPoint", current == null ? void 0 : current.index) || this.isSelectedSegment("startPoint", current == null ? void 0 : current.index) || this.isSelectedSegment("reversePoint", current == null ? void 0 : current.index));
        this.makeMiddlePointGuideSplitLine(prevPoint, current, nextPoint, index2, isSiblingSelected);
        this.makeMiddlePointGuideSegment(prevPoint, current, nextPoint, index2, isSiblingSelected);
      }
      if (current.close) {
        this.pathStringManager.Z();
      }
    }
  }
  makeMovePositionGuide() {
    var state = this.state;
    var {
      startPoint,
      moveXY,
      dragPoints,
      snapPointList,
      isGroupSegment
    } = state;
    var points = this.points;
    if (moveXY) {
      snapPointList = snapPointList || [];
      var { snapPointList: movePointSnapPointList, moveXY: newMoveXY } = calculateMovePointSnap(points, moveXY, 3);
      snapPointList.push.apply(snapPointList, movePointSnapPointList);
      state.moveXY = newMoveXY;
      moveXY = newMoveXY;
      this.snapPointList = snapPointList;
      var prev = points[points.length - 1];
      if (dragPoints && !isGroupSegment) {
        if (!prev) {
          var { x, y } = Point.getReversePoint(startPoint, moveXY);
          this.guideLineManager.M(moveXY).L(startPoint).L({ x, y });
          this.segmentManager.addCurvePoint(startPoint).addCurvePoint(moveXY).addCurvePoint({ x, y });
        } else if (prev.curve) {
          var { x, y } = Point.getReversePoint(startPoint, moveXY);
          this.guideLineManager.M(prev.startPoint).C(prev.endPoint, { x, y }, startPoint);
          this.segmentManager.addGuideLine(prev.startPoint, prev.endPoint).addGuideLine(startPoint, { x, y }).addGuideLine(startPoint, moveXY).addCurvePoint(prev.endPoint).addCurvePoint({ x, y }).addCurvePoint(moveXY).addPoint(false, startPoint);
        } else if (prev.curve === false) {
          var { x, y } = Point.getReversePoint(startPoint, moveXY);
          this.guideLineManager.M(prev.startPoint).Q({ x, y }, startPoint);
          this.segmentManager.addGuideLine(moveXY, { x, y }).addPoint(false, startPoint).addCurvePoint({ x, y }).addCurvePoint(moveXY);
        }
      } else {
        if (!prev)
          ;
        else if (prev.curve) {
          this.guideLineManager.M(prev.startPoint).Q(prev.endPoint, moveXY);
          this.segmentManager.addGuideLine(prev.endPoint, prev.startPoint).addCurvePoint(prev.endPoint);
        } else {
          if (!prev.close) {
            this.guideLineManager.M(prev.startPoint).L(moveXY);
            this.segmentManager.addPoint(false, prev.startPoint);
          }
        }
      }
    }
  }
  makeSnapLines() {
    var snapLines = [];
    if (this.snapPointList) {
      var snapPath = new PathStringManager();
      snapLines = this.snapPointList.map((snapPoint) => {
        snapPath.reset();
        return snapPath.M(snapPoint.startPoint).L(snapPoint.endPoint).X(snapPoint.startPoint).toString("snap-path");
      });
    }
    return snapLines.join("");
  }
  makePathArea() {
    const pathList = this.splitedGroupList.map(({ startPointIndex, points }, groupIndex) => {
      const d = PathGenerator.generatorPathString(points);
      const verties = toRectVerties(PathParser.fromSVGString(d).getBBox());
      return {
        points,
        startPointIndex,
        groupIndex,
        center: verties[4],
        d
      };
    });
    const pathCount = pathList.length;
    return `
            <g>
               ${pathList.map((it) => {
      const { center: center2 } = it;
      const [x, y] = center2;
      const selected = this.state.selectedGroupIndex === it.groupIndex;
      return `
                        <path class="path-area ${selected ? "selected" : ""}" 
                            d="${it.d}" 
                            data-point-index="${it.startPointIndex}" 
                            data-group-index="${it.groupIndex}" 
                        />

                        ${pathCount > 1 && `
                            <text class="path-area-text" x="${x}" y="${y}" >${it.groupIndex + 1}</text>
                        `}
                    `;
    }).join("")}
            </g>
        `;
  }
  toSVGString() {
    return `
        <svg width="100%" height="100%" class='svg-editor-canvas'>
            ${this.guideLineManager.toString("guide")}
            ${this.splitLines.join("")}
            ${this.makeSnapLines()}
            ${this.makePathArea()}
            ${this.segmentManager.toString()}
        </svg>
        `;
  }
}
function xy([x, y]) {
  return { x, y };
}
const SegmentConvertor = class extends EditorElement {
  convertToCurve(index2) {
    this.pathGenerator.convertToCurve(index2);
    this.renderPath();
    this.refreshPathLayer();
  }
  isEditableSegment() {
    return this.state.disableCurve === false;
  }
  [DOUBLECLICK("$view [data-segment]") + IF("isEditableSegment") + PREVENT](e) {
    var index2 = +e.$dt.attr("data-index");
    this.convertToCurve(index2);
  }
  [DOUBLETAB("$view [data-segment]") + PREVENT + DELAY(300)](e) {
    var index2 = +e.$dt.attr("data-index");
    this.convertToCurve(index2);
  }
};
const PathCutter = class extends SegmentConvertor {
  calculatePointOnLine(d, clickPosition) {
    var parser = new PathParser(d);
    return parser.getClosedPoint(clickPosition);
  }
  [POINTERSTART("$view .split-path") + MOVE() + END()](e) {
    this.initRect();
    var parser = new PathParser(e.$dt.attr("d"));
    var clickPosition = {
      x: e.xy.x - this.state.rect.x,
      y: e.xy.y - this.state.rect.y
    };
    var selectedSegmentIndex = -1;
    if (this.isMode("path")) {
      this.state.dragXY = clickPosition;
      this.state.startPoint = this.state.dragXY;
      this.pathGenerator.setLastPoint(this.state.startPoint);
      this.state.isSplitPath = true;
      this.renderPath();
      if (this.state.current) {
        this.refreshPathLayer();
      } else {
        this.addPathLayer();
        this.trigger("initPathEditorView");
      }
      return;
    } else {
      if (parser.segments[1].command === "C") {
        var points = [
          xy(parser.segments[0].values),
          xy(parser.segments[1].values.slice(0, 2)),
          xy(parser.segments[1].values.slice(2, 4)),
          xy(parser.segments[1].values.slice(4, 6))
        ];
        var curve = recoverBezier(...points, 20);
        var t = curve(clickPosition.x, clickPosition.y);
        selectedSegmentIndex = this.pathGenerator.setPoint(getBezierPoints(points, t));
      } else if (parser.segments[1].command === "Q") {
        var points = [
          xy(parser.segments[0].values),
          xy(parser.segments[1].values.slice(0, 2)),
          xy(parser.segments[1].values.slice(2, 4))
        ];
        var curve = recoverBezierQuard(...points, 20);
        var t = curve(clickPosition.x, clickPosition.y);
        selectedSegmentIndex = this.pathGenerator.setPointQuard(getBezierPointsQuard(points, t));
      } else if (parser.segments[1].command === "L") {
        var points = [
          xy(parser.segments[0].values),
          xy(parser.segments[1].values.slice(0, 2))
        ];
        var curve = recoverBezierLine(...points, 20);
        var t = curve(clickPosition.x, clickPosition.y);
        selectedSegmentIndex = this.pathGenerator.setPointLine(getBezierPointsLine(points, t));
        if (e.altKey) {
          this.pathGenerator.convertToCurve(selectedSegmentIndex);
        }
      }
      this.renderPath();
      this.refreshPathLayer();
      this.changeMode("segment-move");
      this.pathGenerator.setCachePoint(selectedSegmentIndex, "startPoint");
      this.pathGenerator.selectKeyIndex("startPoint", selectedSegmentIndex);
    }
  }
};
const PathTransformEditor = class extends PathCutter {
  [SUBSCRIBE("changePathTransform")](transformMoveType) {
    this.resetTransformZone();
    var { width: width2, height: height2 } = this.state.transformZoneRect;
    this.pathGenerator.initTransform(this.state.transformZoneRect);
    switch (transformMoveType) {
      case "flipX":
        this.pathGenerator.transform("flipX", width2, 0);
        break;
      case "flipY":
        this.pathGenerator.transform("flipY", 0, height2);
        break;
      case "flip":
        this.pathGenerator.transform("flip", width2, height2);
    }
    this.renderPath();
    this.refreshPathLayer();
  }
  [SUBSCRIBE("changePathUtil")](utilType) {
    if (utilType === "reverse") {
      const { d } = this.pathGenerator.toPath();
      const pathParser = new PathParser(d);
      pathParser.reverse(...this.pathGenerator.selectedGroupIndexList);
      pathParser.transformMat4(this.state.cachedMatrixInverse);
      this.refreshEditorView({ d: pathParser.d });
      this.updatePathLayer();
    }
  }
  [SUBSCRIBE("divideSegmentsByCount")](count) {
    const { d } = this.pathGenerator.toPath();
    const pathParser = new PathParser(d);
    const newPath = pathParser.divideSegmentByCount(count);
    newPath.transformMat4(this.state.cachedMatrixInverse);
    this.refreshEditorView({ d: newPath.d });
  }
};
const FIELDS = ["fill", "fill-opacity", "stroke", "stroke-width"];
class PathEditorView extends PathTransformEditor {
  initialize() {
    super.initialize();
    this.pathParser = new PathParser();
    this.pathGenerator = new PathGenerator(this);
  }
  initState() {
    return {
      changeEvent: "updatePathItem",
      isShow: false,
      isControl: false,
      disableCurve: false,
      points: [],
      mode: "path",
      clickCount: 0,
      isSegment: false,
      isFirstSegment: false,
      current: null
    };
  }
  get scale() {
    return this.$viewport.scale;
  }
  template() {
    return `
        <div class='elf--path-editor-view' tabIndex="-1">
            <style type="text/css" ref="$styleView"></style>
            <svg id='patternId' width='100%' height='100%' xmlns='http://www.w3.org/2000/svg'>
                <defs>
                    <pattern id='stripe' patternUnits='userSpaceOnUse' width='20' height='33' patternTransform='scale(1) rotate(135)'>
                        <path d='M0 8h20z'   stroke-width='1' stroke='#07A3FB' fill='none'/>
                        <path d='M0 16h20z'   stroke-width='1' stroke='#07A3FB' fill='none'/>
                        <path d='M0 24h20z'   stroke-width='1' stroke='#07A3FB' fill='none'/>
                        <path d='M0 32h20z'   stroke-width='1' stroke='#07A3FB' fill='none'/>
                    </pattern>
                </defs>    
            </svg>
            <div class='path-container' ref='$view'></div>
            <div class='path-container split-panel'>
                <svg width="100%" height="100%">
                    <circle ref='$splitCircle' class='split-circle' />
                </svg>
            </div>
            <div class='segment-box' ref='$segmentBox'></div>
        </div>`;
  }
  isShow() {
    return this.state.isShow;
  }
  initRect(isForce = false) {
    if (!this.state.rect || isForce) {
      this.state.rect = this.$el.rect();
    }
  }
  [SUBSCRIBE("PathEditorDone")]() {
    if (this.state.current) {
      this.refreshPathLayer();
      this.trigger("hidePathEditor");
    } else {
      this.addPathLayer();
    }
    if (!this.state.current && this.pathGenerator.length) {
      this.trigger("initPathEditorView");
    } else {
      this.trigger("hidePathEditor");
    }
  }
  [KEYUP("document") + IF("isShow") + ENTER]() {
    this.trigger("PathEditorDone");
  }
  [KEYUP("document") + IF("isShow") + ESCAPE]() {
    if (this.state.current) {
      this.refreshPathLayer();
    } else {
      this.addPathLayer();
    }
    this.trigger("hidePathEditor");
  }
  makePathLayer() {
    var layer;
    const newPath = new PathParser(this.pathGenerator.toPath().d);
    newPath.transformMat4(this.$viewport.matrixInverse);
    const bbox = newPath.getBBox();
    const newWidth = distance$1(bbox[1], bbox[0]);
    const newHeight = distance$1(bbox[3], bbox[0]);
    newPath.translate(-bbox[0][0], -bbox[0][1]);
    const pathItem = {
      itemType: "svg-path",
      x: bbox[0][0],
      y: bbox[0][1],
      width: newWidth,
      height: newHeight,
      d: newPath.d,
      fill: newPath.closed ? `#C4C4C4` : "transparent"
    };
    FIELDS.forEach((key) => {
      if (this.state[key]) {
        pathItem[key] = this.state[key];
      }
    });
    const containerItem = this.$context.selection.currentProject;
    layer = containerItem.appendChild(this.$editor.createModel(pathItem));
    this.$commands.executeCommand("moveLayerToTarget", "add path", layer, this.$context.selection.currentProject);
    return layer;
  }
  updatePathLayer() {
    var { d } = this.pathGenerator.toPath();
    var parser = new PathParser(d);
    parser.transformMat4(this.$viewport.matrixInverse);
    this.emit(this.state.changeEvent, {
      d: parser.d,
      matrix: this.state.matrix,
      box: this.state.box
    });
  }
  addPathLayer() {
    this.changeMode("modify");
    var layer = this.makePathLayer();
    if (layer) {
      this.$config.set("editing.mode.itemType", "select");
      this.$context.selection.select(layer);
      this.trigger("hidePathEditor");
      this.emit("refreshAll");
    }
  }
  changeMode(mode, obj2) {
    this.setState(__spreadValues({
      mode,
      clickCount: 0,
      moveXY: null
    }, obj2), false);
    if (obj2 == null ? void 0 : obj2.points) {
      this.pathGenerator.setPoints(obj2.points || []);
    }
    this.emit("changePathManager", this.state.mode);
  }
  [SUBSCRIBE("changePathManager")](obj2) {
    this.setState(__spreadProps(__spreadValues({}, obj2), { clickCount: 0 }), false);
    this.renderPath();
  }
  isMode(mode) {
    return this.state.mode === mode;
  }
  afterRender() {
    this.$el.hide();
  }
  [SUBSCRIBE(UPDATE_VIEWPORT)]() {
    if (this.$el.isShow()) {
      const { d } = this.pathGenerator.toPath();
      const pathParser = new PathParser(d);
      pathParser.transformMat4(this.state.cachedMatrixInverse);
      this.refreshEditorView({ d: pathParser.d });
    }
  }
  refreshEditorView(obj2) {
    if (obj2 && obj2.d) {
      this.pathParser.reset(obj2.d);
      this.pathParser.transformMat4(this.$viewport.matrix);
      this.state.cachedMatrixInverse = this.$viewport.matrixInverse;
      this.pathGenerator.setPoints(this.pathParser.convertGenerator());
    }
    this.renderPath();
  }
  [SUBSCRIBE("showPathEditor")](mode = "path", obj2 = {}) {
    this.state.isShow = true;
    this.transformMode = mode;
    if (mode === "move") {
      obj2.current = null;
      obj2.points = [];
    }
    obj2.box = obj2.box || "canvas";
    this.changeMode(mode, obj2);
    this.refreshEditorView(obj2, true);
    this.$el.show();
    this.$el.focus();
    this.emit("showPathManager", { mode: this.state.mode });
    this.emit("hidePathDrawEditor");
    this.$context.commands.emit("push.mode.view", "PathEditorView");
  }
  [SUBSCRIBE("hidePathEditor")]() {
    if (this.$el.isShow()) {
      this.pathParser.reset("");
      this.pathGenerator.setPoints([]);
      this.setState(this.initState(), false);
      this.refs.$view.empty();
      this.$el.hide();
      this.emit("hidePathManager");
      this.$context.commands.emit("pop.mode.view", "PathEditorView");
      this.emit(REFRESH_SELECTION);
    }
  }
  [SUBSCRIBE("hideAddViewLayer")]() {
    this.state.isShow = false;
    this.state.isControl = false;
    this.pathParser.reset("");
    this.setState(this.initState(), false);
    this.refs.$view.empty();
    this.$el.hide();
    this.emit("hidePathManager");
  }
  [BIND("$view")]() {
    var _a;
    const path = this.state.isShow ? this.pathGenerator.makeSVGPath() : "";
    const strokeWidth = Length.parse((_a = this.state.current) == null ? void 0 : _a["stroke-width"]).value || 0;
    return {
      class: {
        path: this.state.mode === "path",
        modify: this.state.mode === "modify",
        transform: this.state.mode === "transform",
        box: this.state.box === "box",
        canvas: this.state.box === "canvas",
        "segment-move": this.state.mode === "segment-move",
        "is-control": this.state.isControl,
        "has-one-stroke-width": strokeWidth === 1
      },
      htmlDiff: path
    };
  }
  [BIND("$splitCircle")]() {
    if (this.state.splitXY) {
      return {
        cx: this.state.splitXY.x,
        cy: this.state.splitXY.y,
        r: 5
      };
    } else {
      return {
        r: 0
      };
    }
  }
  refreshPathLayer() {
    this.updatePathLayer();
  }
  renderPath() {
    this.bindData("$view");
  }
  getPathRect() {
    this.initRect(true);
    const { d } = this.pathGenerator.toPath();
    return vertiesToRectangle(PathParser.fromSVGString(d).getBBox());
  }
  resetTransformZone() {
    var rect2 = this.getPathRect();
    this.state.transformZoneRect = rect2;
  }
  [POINTERMOVE("$view") + PREVENT](e) {
    this.initRect();
    if (this.isMode("path") && this.state.rect) {
      this.state.moveXY = {
        x: e.xy.x - this.state.rect.x,
        y: e.xy.y - this.state.rect.y
      };
      this.state.altKey = e.altKey;
      this.renderPath();
    } else {
      var $target = Dom.create(e.target);
      var isSplitPath = $target.hasClass("split-path");
      if (isSplitPath) {
        this.state.splitXY = this.calculatePointOnLine($target.attr("d"), {
          x: e.xy.x - this.state.rect.x,
          y: e.xy.y - this.state.rect.y
        });
      } else {
        this.state.splitXY = null;
      }
      this.bindData("$splitCircle");
      this.state.altKey = false;
    }
  }
  [POINTERSTART("$view :not(.split-path)") + PREVENT + STOP + MOVE() + END()](e) {
    this.initRect();
    this.state.altKey = false;
    var isPathMode = this.isMode("path");
    this.$config.set("set.move.control.point", true);
    this.state.dragXY = {
      x: e.xy.x - this.state.rect.x,
      y: e.xy.y - this.state.rect.y
    };
    this.$config.set("set.drag.path.area", false);
    var $target = Dom.create(e.target);
    if ($target.hasClass("svg-editor-canvas") && !isPathMode) {
      this.$config.set("set.drag.path.area", true);
      this.state.isGroupSegment = false;
      this.state.selectedGroupIndex = -1;
      this.state.selectedPointIndex = -1;
    } else {
      this.pathGenerator.reselect();
      this.state.isSegment = $target.attr("data-segment") === "true";
      this.state.isFirstSegment = this.state.isSegment && $target.attr("data-is-first") === "true";
      this.state.isGroupSegment = $target.hasClass("path-area");
      if (this.state.isGroupSegment) {
        this.state.selectedGroupIndex = +$target.data("group-index");
        this.state.selectedPointIndex = +$target.data("point-index");
      } else {
        this.state.selectedGroupIndex = -1;
        this.state.selectedPointIndex = -1;
      }
    }
    if (isPathMode) {
      if (this.state.isFirstSegment) {
        var index2 = +$target.attr("data-index");
        this.state.startPoint = this.pathGenerator.points[index2].startPoint;
      } else {
        this.state.startPoint = this.state.dragXY;
      }
      this.state.dragPoints = false;
      this.state.endPoint = null;
    } else {
      if (this.state.isSegment) {
        this.changeMode("segment-move");
        var [index2, segmentKey] = $target.attrs("data-index", "data-segment-point");
        const localIndex = +index2;
        if (e.shiftKey) {
          this.pathGenerator.toggleSelect(segmentKey, localIndex);
        } else {
          this.pathGenerator.setCachePoint(localIndex, segmentKey);
          this.pathGenerator.selectKeyIndex(segmentKey, localIndex);
        }
        this.renderPath();
      } else if (this.state.isGroupSegment) {
        this.changeMode("segment-move");
        this.pathGenerator.selectGroup(this.state.selectedGroupIndex);
        this.renderPath();
      }
    }
  }
  move(dx, dy) {
    var e = this.$config.get("bodyEvent");
    if (this.$config.true("set.drag.path.area")) {
      this.renderSelectBox(this.state.dragXY, dx, dy);
    } else if (this.isMode("segment-move")) {
      this.pathGenerator.move(dx, dy, e);
      this.renderPath();
      this.updatePathLayer();
    } else if (this.isMode("path")) {
      const dist2 = getDist(dx, dy, 0, 0);
      if (dist2 >= 2) {
        this.state.dragPoints = e.altKey ? false : true;
      }
    }
  }
  renderSegment(callback) {
    if (this.pathGenerator.selectedLength) {
      this.pathGenerator.reselect();
      if (isFunction(callback))
        callback();
      this.renderPath();
      this.updatePathLayer();
    }
  }
  end(dx, dy) {
    var e = this.$config.get("bodyEvent");
    this.$config.set("set.move.control.point", false);
    if (this.state.isGroupSegment) {
      this.pathGenerator.select();
    }
    if (this.$config.true("set.drag.path.area")) {
      if (dx === 0 && dy === 0) {
        this.changeMode("modify");
        this.trigger("hidePathEditor");
      } else {
        this.changeMode("segment-move");
        this.pathGenerator.selectInBox(this.getSelectBox(), e.shiftKey);
        this.renderPath();
        this.hideSelectBox();
      }
    } else if (this.isMode("modify")) {
      this.pathGenerator.reselect();
    } else if (this.isMode("segment-move")) {
      this.changeMode("modify");
      this.pathGenerator.reselect();
      this.renderPath();
      this.updatePathLayer();
    } else if (this.isMode("path")) {
      if (this.state.isFirstSegment) {
        this.changeMode("modify");
        this.pathGenerator.setConnectedPoint(dx, dy);
        this.renderPath();
        if (this.state.current) {
          this.refreshPathLayer();
        } else {
          this.addPathLayer();
          this.trigger("initPathEditorView");
        }
      } else {
        if (this.state.isSplitPath)
          ;
        else {
          this.pathGenerator.moveEnd(dx, dy);
          this.state.clickCount++;
          this.renderPath();
          this.pathGenerator.reselect();
        }
      }
      this.state.isSplitPath = false;
    }
  }
  hideSelectBox() {
    this.refs.$segmentBox.css({
      left: -1e5
    });
  }
  renderSelectBox(startXY = null, dx = 0, dy = 0) {
    var obj2 = {
      left: startXY.x + (dx < 0 ? dx : 0),
      top: startXY.y + (dy < 0 ? dy : 0),
      width: Math.abs(dx),
      height: Math.abs(dy)
    };
    this.refs.$segmentBox.css(obj2);
  }
  getSelectBox() {
    var [x, y, width2, height2] = this.refs.$segmentBox.styles("left", "top", "width", "height").map((it) => Length.parse(it));
    var rect2 = {
      x,
      y,
      width: width2,
      height: height2
    };
    rect2.x2 = rect2.x.value + rect2.width;
    rect2.y2 = rect2.y.value + rect2.height;
    return rect2;
  }
  [SUBSCRIBE("deleteSegment")]() {
    this.pathGenerator.reselect();
    this.pathGenerator.removeSelectedSegment();
    this.renderPath();
    this.updatePathLayer();
  }
  [SUBSCRIBE("moveSegment")](dx, dy) {
    this.pathGenerator.reselect();
    this.pathGenerator.moveSelectedSegment(dx, dy);
    this.renderPath();
    this.updatePathLayer();
  }
  [SUBSCRIBE("initPathEditorView")]() {
    this.pathParser.reset("");
    this.setState(this.initState(), false);
    this.state.isShow = true;
    this.refs.$view.empty();
    this.$el.focus();
  }
}
var PathManager$1 = "";
const MODES = {
  "segment-move": "modify",
  modify: "modify",
  path: "path",
  transform: "transform",
  warp: "warp"
};
class PathManager extends EditorElement {
  initState() {
    return {
      mode: "move",
      fill: null,
      stroke: null,
      "fill-opacity": null,
      "stroke-width": null,
      msg: this.$i18n("path.manager.msg")
    };
  }
  template() {
    return `
      <div class='elf--path-manager'>
        <div class="tools left" ref="$left">
            <button type="button" class="primary" data-value='PathEditorDone' title='${this.$i18n("path.manager.mode.modify")}' >Done</button>
        </div>
        <div class='tools' ref='$mode' data-selected-value='${this.state.mode}'>
            <button type="button" data-value='modify' data-tooltip='${this.$i18n("path.manager.mode.modify")}' > ${iconUse("device_hub")}</button>
            <button type="button" data-value='path' data-tooltip='${this.$i18n("path.manager.mode.path")}' > ${iconUse("control_point")}</button>
            <button type="button" data-value='transform' data-tooltip='${this.$i18n("path.manager.mode.transform")}' > ${iconUse("transform")}</button>             
        </div>
        <div class="split"></div>        
        <div class='tools' ref='$util'>
            <button type="button" data-value='reverse' data-tooltip='${this.$i18n("path.manager.mode.reverse")}' >${iconUse("sync")}</button>
        </div>                        
        <div class='tools' ref='$flip'>
            <button type="button" data-value='flipX' data-tooltip='${this.$i18n("path.manager.mode.flipX")}'>${iconUse("flip")}</button>
            <button type="button" data-value='flipY' data-tooltip='${this.$i18n("path.manager.mode.flipY")}'>${iconUse("flip", "rotate(90 12 12)")}</button>
            <button type="button" data-value='flip' data-tooltip='${this.$i18n("path.manager.mode.flipOrigin")}'>${iconUse("flip", "rotate(45 12 12)")}</button>
            <div class="split"></div>            
            <button type="button" data-value='2x' data-tooltip="divide segment by 2 times">2x</button>
            <button type="button" data-value='3x' data-tooltip="divide segment by 3 times">3x</button>            
        </div>
        <div class="subpath" style="display:none">
          <button type="button" data-value="path" data-pathtype="rect">${iconUse("rect", "", { width: 24, height: 24 })}</button>
        </div>
      </div>    
    `;
  }
  [BIND("$mode")]() {
    return {
      "data-selected-value": MODES[this.state.mode]
    };
  }
  refresh() {
    this.bindData("$mode");
  }
  [CLICK("$flip button")](e) {
    var transformType = e.$dt.attr("data-value");
    if (transformType === "2x") {
      this.emit("divideSegmentsByCount", 2);
    } else if (transformType === "3x") {
      this.emit("divideSegmentsByCount", 3);
    } else {
      this.emit("changePathTransform", transformType);
    }
  }
  [CLICK("$util button")](e) {
    var utilType = e.$dt.attr("data-value");
    this.emit("changePathUtil", utilType);
  }
  [CLICK("$mode button")](e) {
    var mode = e.$dt.attr("data-value");
    this.updateData({
      mode
    });
    this.refresh();
  }
  [CLICK("$left button")](e) {
    var message = e.$dt.attr("data-value");
    this.emit(message);
  }
  updateData(obj2 = {}) {
    this.setState(obj2, false);
    this.emit(this.state.changeEvent, obj2);
  }
  [SUBSCRIBE("changePathManager")](mode) {
    this.setState({ mode });
  }
  [SUBSCRIBE("showPathManager")](obj2 = {}) {
    obj2.changeEvent = obj2.changeEvent || "changePathManager";
    this.setState(obj2);
    this.$el.show();
  }
  [SUBSCRIBE("hidePathManager")]() {
    this.$el.hide();
  }
}
function pathEditorView(editor) {
  editor.registerUI("canvas.view", {
    PathEditorView
  });
  editor.registerUI("page.subeditor.view", {
    PathManager
  });
}
var PathToolProperty$1 = "";
class PathToolProperty extends BaseProperty {
  components() {
    return {
      LeftAlign,
      CenterAlign,
      RightAlign,
      TopAlign,
      MiddleAlign,
      BottomAlign,
      SameWidth,
      SameHeight
    };
  }
  getTitle() {
    return this.$i18n("alignment.property.title");
  }
  isHideHeader() {
    return true;
  }
  getBody() {
    return `
      <div class="elf--boolean-item" ref="$buttons">
        <div>
          <button type="button" data-command="convert.path.operation" data-args="union">${iconUse("boolean_union", "", { width: 30, height: 30 })} Union</button>        
          <button type="button" data-command="convert.path.operation" data-args="intersection">${iconUse("boolean_intersection", "", { width: 30, height: 30 })} Intersection</button>        
        </div>
        <div>
          <button type="button" data-command="convert.path.operation" data-args="difference">${iconUse("boolean_difference", "", { width: 30, height: 30 })} Subtract</button>        
          <button type="button" data-command="convert.path.operation" data-args="xor">${iconUse("boolean_xor", "", { width: 30, height: 30 })} Exclude</button>        
        </div>
        <div class="divider"></div>
        <!--div>
          <button type="button" data-command="convert.no.transform.path">${iconUse("grid3x3", "", { width: 24, height: 24 })} No Transform</button>        
        </div-->
        <div>
          <button type="button" data-command="convert.simplify.path">${iconUse("grid3x3", "", { width: 24, height: 24 })} Self Intersection</button>        
          <button type="button" data-command="convert.flatten.path">${iconUse("flatten", "", { width: 24, height: 24 })} Flatten</button>                  
        </div>        
        <div>
          <!--<button type="button" data-command="convert.smooth.path">${iconUse("smooth", "", { width: 24, height: 24 })} Smooth Path</button>-->                
          <button type="button" data-command="switch.path">${iconUse("sync", "", { width: 30, height: 30 })} Switch path</button>                  
          <button type="button" data-command="convert.stroke.to.path">${iconUse("outline_shape", "", { width: 24, height: 24 })} Outline Path</button> 
        </div>        
        <!--div>
          <button type="button" data-command="convert.polygonal.path">${iconUse("highlight_at", "", { width: 24, height: 24 })} Polygonal</button>                
          <button type="button" data-command="convert.normalize.path">${iconUse("stroke_to_path", "", { width: 24, height: 24 })} Normalize</button> 
        </div-->                
      </div>
    `;
  }
  [CLICK("$buttons button")](e) {
    const command = e.$dt.data("command");
    const args2 = e.$dt.data("args");
    if (command === "convert.smooth.path") {
      this.$commands.emit(command);
    } else {
      this.$commands.emit(command, args2);
    }
  }
  [SUBSCRIBE(REFRESH_SELECTION)]() {
    this.refreshShow(() => {
      if (this.$context.selection.length === 1 && this.$context.selection.is("boolean-path"))
        return true;
      return this.$context.selection.is("svg-path", "polygon", "star");
    });
  }
}
function pathTool(editor) {
  editor.registerUI("inspector.tab.style", {
    PathToolProperty
  });
}
var check = {
  key: "check",
  title: "Check",
  execute: function() {
    return [
      { pattern: `check(20px 20px, 10px 10px, black, transparent)` },
      { pattern: `check(40px 40px, 20px 20px, black, transparent)` },
      { pattern: `check(60px 60px, 30px 30px, #DDB104, rgba(254,240,188,0))` },
      { pattern: `check(80px 80px, 40px 40px, #DDB104, rgba(254,240,188,0))` },
      { pattern: `check(100px 100px, 50px 50px, #DCF3DC, transparent)` },
      { pattern: `check(200px 200px, 100px 100px, #102C45, transparent)` }
    ];
  }
};
var crossdot = {
  key: "cross-dot",
  title: "Cross Dot",
  execute: function() {
    return [
      {
        pattern: `cross-dot(20px 20px, 10px 10px, #B7C4CD, white, normal, 1px)`
      },
      {
        pattern: `cross-dot(40px 40px, 20px 20px, #DDB104, #FEF0BC, normal, 4px)`
      },
      {
        pattern: `cross-dot(60px 60px, 30px 30px, #35DB92, #DCF9EC, normal, 6px)`
      }
    ];
  }
};
var diagonalLine = {
  key: "diagonal-line",
  title: "Diagonal Line",
  execute: function() {
    return [
      {
        pattern: `diagonal-line(10px 10px, 45deg, #B7C4CD, white, normal, 1px)`
      },
      {
        pattern: `diagonal-line(25px 25px, 90deg, #DDB104, #FEF0BC, normal, 2px)`
      },
      {
        pattern: `diagonal-line(50px 50px, 135deg, #35DB92, #DCF9EC, normal, 3px)`
      }
    ];
  }
};
var dot = {
  key: "dot",
  title: "Dot",
  execute: function() {
    return [
      { pattern: `dot(20px 20px, 10px 10px, #B7C4CD, white, normal, 1px)` },
      { pattern: `dot(40px 40px, 20px 20px, #E7393F, #FEF0BC, normal, 2px)` },
      { pattern: `dot(60px 60px, 30px 30px, #E7393F, black, normal, 3px)` },
      { pattern: `dot(80px 80px, 40px 40px, #B7C4CD, white, normal, 4px)` }
    ];
  }
};
var grid = {
  key: "grid",
  title: "Grid",
  execute: function() {
    return [
      { pattern: `grid(20px 20px, 10px 10px, black, transparent)` },
      { pattern: `grid(40px 40px, 20px 20px, black, transparent)` },
      { pattern: `grid(60px 60px, 30px 30px, #DDB104, rgba(254,240,188,0))` },
      { pattern: `grid(80px 80px, 40px 40px, #DDB104, rgba(254,240,188,0))` },
      { pattern: `grid(100px 100px, 50px 50px, #DCF3DC, transparent)` },
      { pattern: `grid(200px 200px, 100px 100px, #102C45, transparent)` }
    ];
  }
};
var horizontalLine = {
  key: "horizontal-line",
  title: "Horizontal Line",
  execute: function() {
    return [
      { pattern: `horizontal-line(10px 10px, 0, #B7C4CD, white, normal, 1px)` },
      {
        pattern: `horizontal-line(25px 25px, 0, #DDB104, #FEF0BC, normal, 2px)`
      },
      {
        pattern: `horizontal-line(50px 50px, 0, #35DB92, #DCF9EC, normal, 3px)`
      }
    ];
  }
};
var verticalLine = {
  key: "vertical-line",
  title: "Vertical Line",
  execute: function() {
    return [
      { pattern: `vertical-line(10px 10px, 0px, #B7C4CD, white, normal, 1px)` },
      {
        pattern: `vertical-line(25px 25px, 0px, #DDB104, #FEF0BC, normal, 2px)`
      },
      {
        pattern: `vertical-line(50px 50px, 0px, black, rgba(231,57,63,0.9), normal, 1px)`
      }
    ];
  }
};
var patterns = [
  check,
  grid,
  dot,
  crossdot,
  diagonalLine,
  verticalLine,
  horizontalLine
];
var PatternAssetsProperty$1 = "";
class PatternAssetsProperty extends BaseProperty {
  getTitle() {
    return this.$i18n("pattern.asset.property.title");
  }
  initState() {
    return {
      mode: "grid",
      preset: "check"
    };
  }
  getTools() {
    const options2 = variable$4(patterns.map((it) => {
      return { value: it.key, text: it.title };
    }));
    return createComponent("SelectEditor", {
      ref: "$assets",
      key: "preset",
      value: this.state.preset,
      options: options2,
      onchange: "changePreset"
    });
  }
  [SUBSCRIBE_SELF("changePreset")](key, value) {
    this.setState({
      [key]: value
    });
  }
  getClassName() {
    return "elf--pattern-assets-property";
  }
  get editableProperty() {
    return "pattern";
  }
  [SUBSCRIBE(REFRESH_SELECTION) + DEBOUNCE(100) + IF("checkShow")]() {
  }
  getBody() {
    return `
      <div class='property-item pattern-assets'>
        <div class='pattern-list' ref='$patternList' data-view-mode='${this.state.mode}'></div>
      </div>
    `;
  }
  [DRAGSTART("$patternList .pattern-item")](e) {
    const pattern = e.$dt.attr("data-pattern");
    e.dataTransfer.effectAllowed = "copy";
    e.dataTransfer.setData("text/pattern", pattern);
  }
  [LOAD("$patternList")]() {
    var preset = patterns.find((it) => it.key === this.state.preset);
    if (!preset) {
      return "";
    }
    var results = preset.execute().map((item, index2) => {
      const cssText = CSS_TO_STRING(Pattern.toCSS(item.pattern));
      return `
        <div class='pattern-item' data-index="${index2}" data-pattern="${item.pattern}">
          <div class='preview' title="${item.title}" draggable="true">
            <div class='pattern-view' style='${cssText}'></div>
          </div>
        </div>
      `;
    });
    return results;
  }
  [CLICK("$patternList .pattern-item")](e) {
    const pattern = e.$dt.attr("data-pattern");
    if (this.$modeView.isCurrentMode(ViewModeType.CanvasView)) {
      this.$commands.emit("addBackgroundImagePattern", pattern);
    } else {
      this.emit("setPatternAsset", pattern);
    }
  }
}
var PatternEditor$1 = "";
class PatternEditor extends EditorElement {
  initState() {
    return {
      hideLabel: this.props.hideLabel,
      value: this.props.value,
      patterns: this.parsePattern(this.props.value)
    };
  }
  parsePattern(str) {
    if (str === "undefined")
      return [];
    return Pattern.parseStyle(str);
  }
  setValue(value) {
    this.setState({
      value,
      patterns: this.parsePattern(value)
    });
  }
  template() {
    return `
            <div class='elf--pattern-editor' >
                <div class='pattern-list' ref='$patternList'></div>
            </div>
        `;
  }
  [LOAD("$patternList")]() {
    return this.state.patterns.map((it, index2) => {
      const selectedClass = it.selected ? "selected" : "";
      if (it.selected) {
        this.selectedIndex = index2;
      }
      return `
            <div class='pattern-item ${selectedClass}' data-index='${index2}' ref="fillIndex${index2}"  draggable='true'>
                ${createComponent("PatternSizeEditor", {
        key: "pattern-size",
        ref: `$bp${index2}`,
        type: it.type,
        x: it.x,
        y: it.y,
        width: it.width,
        height: it.height,
        index: index2,
        foreColor: it.foreColor,
        backColor: it.backColor,
        blendMode: it.blendMode,
        lineWidth: it.lineWidth,
        lineHeight: it.lineHeight,
        onchange: "changePatternSizeInfo"
      })}
                <div class='tools'>
                    <button type="button" class='remove' title='Remove a pattern' data-index='${index2}'>${iconUse("remove")}</button>
                </div>
            </div>
            `;
    });
  }
  modifyPattern() {
    var value = Pattern.join(this.state.patterns);
    this.parent.trigger(this.props.onchange, this.props.key, value);
  }
  [SUBSCRIBE("add")](type = "check") {
    var pattern = patterns.find((it) => it.key === type);
    if (pattern) {
      const data = Pattern.parseStyle(pattern.execute()[0].pattern);
      this.state.patterns.push.apply(this.state.patterns, data);
      this.refresh();
      this.modifyPattern();
    }
  }
  [CLICK("$add")]() {
    this.trigger("add");
  }
  [DRAGSTART("$patternList .pattern-item")](e) {
    this.startIndex = +e.$dt.attr("data-index");
  }
  [DRAGOVER("$patternList .pattern-item") + PREVENT]() {
  }
  sortItem(arr, startIndex, targetIndex) {
    arr.splice(targetIndex + (startIndex < targetIndex ? -1 : 0), 0, ...arr.splice(startIndex, 1));
  }
  sortPattern(startIndex, targetIndex) {
    this.sortItem(this.state.patterns, startIndex, targetIndex);
  }
  [DROP("$patternList .pattern-item") + PREVENT](e) {
    var targetIndex = +e.$dt.attr("data-index");
    this.selectItem(this.startIndex, true);
    this.sortPattern(this.startIndex, targetIndex);
    this.modifyPattern();
    this.refresh();
  }
  getCurrentPattern() {
    return this.state.patterns[this.selectedIndex];
  }
  [CLICK("$patternList .tools .remove")](e) {
    var removeIndex = +e.$dt.attr("data-index");
    this.state.patterns.splice(removeIndex, 1);
    this.modifyPattern();
    this.refresh();
  }
  selectItem(selectedIndex, isSelected = true) {
    if (isSelected) {
      this.refs[`fillIndex${selectedIndex}`].addClass("selected");
    } else {
      this.refs[`fillIndex${selectedIndex}`].removeClass("selected");
    }
    this.state.patterns.forEach((it, index2) => {
      it.selected = index2 === selectedIndex;
    });
  }
  [SUBSCRIBE("changePatternSizeInfo") + DEBOUNCE(10)](key, value, index2) {
    var pattern = this.state.patterns[index2];
    pattern.reset(value);
    this.modifyPattern();
    this.refresh();
  }
}
var PatternInfoPopup$1 = "";
class PatternInfoPopup extends BasePopup {
  getClassName() {
    return "pattern-info-popup";
  }
  getTitle() {
    return this.$i18n("pattern.info.popup.title");
  }
  initState() {
    return {
      type: this.props.type || "grid",
      x: this.props.x || 0,
      y: this.props.y || 0,
      width: this.props.width || 0,
      height: this.props.height || 0,
      lineWidth: this.props.lineWidth || 1,
      lineHeight: this.props.lineHeight || 1,
      foreColor: this.props.foreColor || "black",
      backColor: this.props.backColor || "transparent",
      blendMode: this.props.blendMode || "normal"
    };
  }
  updateData(opt = {}) {
    this.setState(opt, false);
    const {
      x,
      y,
      width: width2,
      height: height2,
      foreColor,
      backColor,
      blendMode,
      lineWidth,
      lineHeight
    } = this.state;
    this.state.instance.trigger(this.state.changeEvent, {
      x,
      y,
      width: width2,
      height: height2,
      foreColor,
      backColor,
      blendMode,
      lineWidth,
      lineHeight
    });
  }
  [SUBSCRIBE_SELF("changeRangeEditor")](key, value) {
    this.updateData({ [key]: value });
  }
  templateForX() {
    if (this.hasNotX())
      return "";
    let label = "X";
    let units = "";
    if (this.state.type === "diagonal-line") {
      label = this.$i18n("pattern.info.popup.rotate");
      units = ["deg"];
    }
    return createComponent("InputRangeEditor", {
      label,
      ref: "$x",
      key: "x",
      value: this.state.x,
      min: 0,
      max: 1e3,
      step: 1,
      units,
      onchange: "changeRangeEditor"
    });
  }
  templateForY() {
    if (this.hasNotY())
      return "<div></div>";
    return createComponent("InputRangeEditor", {
      label: "Y",
      ref: "$y",
      key: "y",
      value: this.state.y,
      min: 0,
      max: 1e3,
      step: 1,
      onchange: "changeRangeEditor"
    });
  }
  templateForLabel() {
    return `<label>${this.state.type}</label>`;
  }
  templateForWidth() {
    return createComponent("InputRangeEditor", {
      label: this.$i18n("pattern.info.popup.width"),
      ref: "$width",
      key: "width",
      value: this.state.width,
      min: 0,
      max: 500,
      step: 1,
      onchange: "changeRangeEditor"
    });
  }
  templateForHeight() {
    return createComponent("InputRangeEditor", {
      label: this.$i18n("pattern.info.popup.height"),
      ref: "$height",
      key: "height",
      value: this.state.height,
      min: 0,
      max: 500,
      step: 1,
      onchange: "changeRangeEditor"
    });
  }
  hasNotLineWidth() {
    return ["check"].includes(this.state.type);
  }
  hasNotLineHeight() {
    return [
      "cross-dot",
      "dot",
      "check",
      "diagonal-line",
      "horizontal-line"
    ].includes(this.state.type);
  }
  hasNotX() {
    return ["grid", "dot", "horizontal-line"].includes(this.state.type);
  }
  hasNotY() {
    return ["grid", "dot", "diagonal-line", "vertical-line"].includes(this.state.type);
  }
  templateForLineWidth() {
    if (this.hasNotLineWidth())
      return "<div></div>";
    return createComponent("InputRangeEditor", {
      label: this.$i18n("pattern.info.popup.lineWidth"),
      ref: "$lineWidth",
      key: "lineWidth",
      value: this.state.lineWidth,
      min: 0,
      max: 500,
      step: 1,
      onchange: "changeRangeEditor"
    });
  }
  templateForLineHeight() {
    if (this.hasNotLineHeight())
      return "<div></div>";
    return createComponent("InputRangeEditor", {
      label: this.$i18n("pattern.info.popup.lineHeight"),
      ref: "$lineHeight",
      key: "lineHeight",
      value: this.state.lineHeight,
      min: 0,
      max: 500,
      step: 1,
      onchange: "changeRangeEditor"
    });
  }
  templateForForeColor() {
    return createComponent("ColorViewEditor", {
      ref: "$foreColor",
      label: this.$i18n("pattern.info.popup.foreColor"),
      key: "foreColor",
      value: this.state.foreColor,
      onchange: "changeRangeEditor"
    });
  }
  templateForBackColor() {
    return createComponent("ColorViewEditor", {
      ref: "$backColor",
      label: this.$i18n("pattern.info.popup.backColor"),
      key: "backColor",
      value: this.state.backColor,
      onchange: "changeRangeEditor"
    });
  }
  templateForBlendMode() {
    return `
    <div class=''>
      ${createComponent("BlendSelectEditor", {
      ref: "$blend",
      key: "blendMode",
      label: this.$i18n("pattern.info.popup.blend"),
      value: this.state.blendMode,
      onchange: "changeRangeEditor"
    })}
    </div>
    `;
  }
  getBody() {
    return `
      <div class="background-image-position-picker" ref='$picker'></div>
    `;
  }
  [LOAD("$picker")]() {
    return `
      
      <div class='box'>
          <div>
            ${this.templateForLabel()}
          </div>
          <div>
            ${this.templateForWidth()}
            ${this.templateForHeight()}        
          </div>
          <div>
            ${this.templateForLineWidth()}
            ${this.templateForLineHeight()}                  
          </div>
          <div>
            ${this.templateForX()}
            ${this.templateForY()}
          </div>
          <div>
            ${this.templateForForeColor()}
            ${this.templateForBackColor()}
          </div>
          <div>
            ${this.templateForBlendMode()}
          </div>
      </div>
    `;
  }
  [SUBSCRIBE("showPatternInfoPopup")](data, rect2) {
    this.state.changeEvent = data.changeEvent || "changePatternInfoPopup";
    this.state.instance = data.instance;
    this.setState(data.data);
    this.showByRect(rect2);
  }
}
var PatternProperty$1 = "";
class PatternProperty extends BaseProperty {
  getTitle() {
    return this.$i18n("pattern.property.title");
  }
  getClassName() {
    return "el--pattern-property";
  }
  getTitleClassName() {
    return "pattern";
  }
  getBody() {
    return `<div class='pattern-property' ref='$body'></div>`;
  }
  getTools() {
    return `
      <div ref='$tools' class='add-tools'>
        <button type="button" data-pattern='check' data-tooltip="Check">${iconUse("pattern_check")}</button>
        <button type="button" data-pattern='grid' data-tooltip="Grid">${iconUse("pattern_grid")}</button>
        <button type="button" data-pattern='dot' data-tooltip="Dot">${iconUse("pattern_dot")}</button>
        <button type="button" data-pattern='cross-dot' data-tooltip="Cross Dot">${iconUse("pattern_cross_dot", "rotate(45 12 12)")}</button>
        <button type="button" data-pattern='diagonal-line' data-tooltip="Diagonal Line">${iconUse("texture")}</button>
        <button type="button" data-pattern='vertical-line' data-tooltip="Vertical Line" data-direction="bottom right">${iconUse("pattern_horizontal_line", "rotate(90 12 12)")}</button>
        <button type="button" data-pattern='horizontal-line' data-tooltip="Horizontal Line" data-direction="bottom right">${iconUse("pattern_horizontal_line")}</button>
      </div>
    `;
  }
  [CLICK("$tools button")](e) {
    var patternType = e.$dt.data("pattern");
    this.children.$patternEditor.trigger("add", patternType);
  }
  [LOAD("$body")]() {
    var current = this.$context.selection.current || {};
    var value = current.pattern;
    return createComponent("PatternEditor", {
      ref: "$patternEditor",
      value,
      "hide-label": true,
      onchange: "changePatternEditor"
    });
  }
  [SUBSCRIBE_SELF("changePatternEditor")](key, pattern) {
    this.$commands.executeCommand("setAttribute", "change pattern", this.$context.selection.packByValue({
      pattern
    }));
  }
  get editableProperty() {
    return "pattern";
  }
  [SUBSCRIBE(REFRESH_SELECTION) + IF("checkShow")]() {
    this.refresh();
  }
  [SUBSCRIBE("refreshSVGArea") + DEBOUNCE(1e3)]() {
    this.load("$patternSelect");
  }
}
var PatternSizeEditor$1 = "";
class PatternSizeEditor extends EditorElement {
  initState() {
    return {
      index: this.props.index,
      x: Length.parse(this.props.x),
      y: Length.parse(this.props.y),
      width: Length.parse(this.props.width),
      height: Length.parse(this.props.height),
      lineWidth: Length.parse(this.props.lineWidth),
      lineHeight: Length.parse(this.props.lineHeight),
      backColor: this.props.backColor,
      foreColor: this.props.foreColor,
      blendMode: this.props.blendMode,
      type: this.props.type
    };
  }
  updateData(opt = {}) {
    this.setState(opt, false);
    this.modifyValue(opt);
  }
  modifyValue(value) {
    this.parent.trigger(this.props.onchange, this.props.key, value, this.state.index);
  }
  setValue(obj2) {
    this.setState(__spreadValues({}, obj2));
  }
  [BIND("$miniView")]() {
    const {
      type,
      x,
      y,
      width: width2,
      height: height2,
      lineWidth,
      lineHeight,
      backColor,
      foreColor,
      blendMode
    } = this.state;
    let obj2 = {
      type,
      x,
      y,
      width: width2,
      height: height2,
      lineWidth,
      lineHeight,
      backColor,
      foreColor,
      blendMode
    };
    if (this.state.width > 80) {
      obj2.width = 80;
      obj2.x = obj2.x.value / this.state.width / 80;
    }
    if (this.state.height > 80) {
      obj2.height = 80;
      obj2.y = this.state.y.value / this.state.height / 80;
    }
    const pattern = Pattern.parse(obj2);
    return {
      cssText: pattern.toCSS()
    };
  }
  template() {
    return `
            <div class='elf--pattern-size-editor'>
                <div class='preview' ref='$preview'>
                    <div class='mini-view'>
                        <div class='color-view' style="background-color: ${this.state.color}" ref='$miniView'></div>
                    </div>
                </div>
            </div>
        `;
  }
  [CLICK("$preview")]() {
    this.viewBackgroundPositionPopup();
  }
  viewBackgroundPositionPopup() {
    const layoutElement = this.$config.get("editor.layout.elements");
    const bodyRect = layoutElement.$bodyPanel.rect();
    const rect2 = this.$el.rect();
    const newRect = {
      left: bodyRect.left + bodyRect.width - 240,
      top: rect2.top,
      width: 240,
      height: 300
    };
    this.emit("showPatternInfoPopup", {
      changeEvent: (pattern) => {
        this.updateData(__spreadValues({}, pattern));
      },
      data: this.state,
      instance: this
    }, newRect);
  }
}
function patternAsset(editor) {
  editor.registerElement({
    PatternEditor,
    PatternSizeEditor,
    PatternAssetsProperty
  });
  editor.registerUI("inspector.tab.style", {
    PatternProperty
  });
  editor.registerUI("popup", {
    PatternInfoPopup
  });
}
var PositionProperty$1 = "";
const DEFAULT_SIZE = 0;
class PositionProperty extends BaseProperty {
  getTitle() {
    return this.$i18n("position.property.title");
  }
  afterRender() {
    this.show();
  }
  [SUBSCRIBE(REFRESH_SELECTION)]() {
    this.refreshShowIsNot(["project"]);
  }
  checkChangedValue() {
    var current = this.$context.selection.current;
    if (!current)
      return false;
    return current.hasChangedField("x", "y", "right", "bottom", "width", "height", "angle", "transform", "opacity", "resizingVertical", "resizingHorizontal", "constraints-horizontal", "constriants-vertical");
  }
  [SUBSCRIBE(UPDATE_CANVAS) + IF("checkChangedValue") + THROTTLE(10)]() {
    var current = this.$context.selection.current;
    if (!current)
      return "";
    this.children.$x.setValue(round(current.offsetX || DEFAULT_SIZE, 100));
    this.children.$y.setValue(round(current.offsetY || DEFAULT_SIZE, 100));
    this.children.$width.setValue(round(current.width || DEFAULT_SIZE, 100));
    this.children.$height.setValue(round(current.height || DEFAULT_SIZE, 100));
    this.children.$opacity.setValue(current.opacity || "1");
    this.children.$rotate.setValue(Length.deg(current.angle).round(100));
  }
  isHideHeader() {
    return true;
  }
  getBodyClassName() {
    return "no-padding";
  }
  getBody() {
    return `
      <div class="position-item" ref="$positionItem" style='padding: 5px 10px;'>
        <div class="grid-layout">
          ${createComponent("NumberInputEditor", {
      ref: "$x",
      compact: true,
      label: "X",
      key: "x",
      min: -1e5,
      max: 1e5,
      trigger: "enter",
      onchange: "changRangeEditor"
    })}
          ${createComponent("NumberInputEditor", {
      ref: "$y",
      compact: true,
      trigger: "enter",
      label: "Y",
      key: "y",
      min: -1e4,
      max: 1e4,
      onchange: "changRangeEditor"
    })}
        </div>
        <div class="grid-layout">          
          ${createComponent("NumberInputEditor", {
      ref: "$width",
      compact: true,
      trigger: "enter",
      label: "W",
      key: "width",
      min: 0,
      max: 3e3,
      onchange: "changRangeEditor"
    })}
          ${createComponent("NumberInputEditor", {
      ref: "$height",
      compact: true,
      trigger: "enter",
      label: "H",
      key: "height",
      min: 0,
      max: 3e3,
      onchange: "changRangeEditor"
    })}
        </div> 
        <div class="grid-layout">
          ${createComponent("InputRangeEditor", {
      ref: "$rotate",
      key: "rotateZ",
      compact: true,
      label: "rotate_left",
      min: -360,
      max: 360,
      step: 1,
      units: ["deg"],
      onchange: "changeRotate"
    })}
          ${createComponent("NumberInputEditor", {
      ref: "$opacity",
      key: "opacity",
      compact: true,
      label: "opacity",
      min: 0,
      max: 1,
      step: 0.01,
      onchange: "changeSelect"
    })}
        </div>                
      </div>
    `;
  }
  refresh() {
    const current = this.$context.selection.current;
    if (current) {
      this.children.$x.setValue(round(current.offsetX || DEFAULT_SIZE, 100));
      this.children.$y.setValue(round(current.offsetY || DEFAULT_SIZE, 100));
      this.children.$width.setValue(round(current.width || DEFAULT_SIZE, 100));
      this.children.$height.setValue(round(current.height || DEFAULT_SIZE, 100));
      this.children.$opacity.setValue(current.opacity || "1");
      this.children.$rotate.setValue(Length.deg(current.angle));
    }
  }
  [CLICK("$positionItem button[data-command]")](e) {
    const command = e.$dt.data("command");
    console.log(command);
  }
  [SUBSCRIBE_SELF("changRangeEditor")](key, value) {
    this.$commands.executeCommand("setAttribute", "change position or size", this.$context.selection.packByValue({
      [key]: value
    }));
  }
  [SUBSCRIBE_SELF("changeRotate")](key, rotate2) {
    this.$commands.executeCommand("setAttribute", "change rotate", this.$context.selection.packByValue({
      angle: rotate2.value
    }));
  }
  [SUBSCRIBE_SELF("changeSelect")](key, value) {
    this.$commands.executeCommand("setAttribute", `change ${key}`, this.$context.selection.packByValue({
      [key]: value
    }));
  }
}
function position(editor) {
  editor.registerUI("inspector.tab.style", {
    PositionProperty
  });
}
var ProjectProperty$1 = "";
class ProjectProperty extends BaseProperty {
  getTitle() {
    return this.$i18n("project.property.title");
  }
  getClassName() {
    return "full";
  }
  getTools() {
    return `
      <button type='button' ref='$add' data-tooltip="Add a project" data-direction="bottom right">${obj$3.add}</button>
    `;
  }
  [CLICK("$add")]() {
    this.$commands.emit("addProject");
  }
  getBody() {
    return `
      <div class="elf--project-list scrollbar" ref="$projectList"></div>
    `;
  }
  [LOAD("$projectList") + DOMDIFF]() {
    var _a;
    var projects = ((_a = this.$model) == null ? void 0 : _a.projects) || [];
    return projects.map((projectId) => {
      var selected = projectId === this.$context.selection.currentProject.id ? "selected" : "";
      const project2 = this.$model.get(projectId);
      return `
        <div class='project-item ${selected}'>
          <div class='detail'>
            <label data-id='${projectId}'>${project2.name || "New Project"}</label>
            <div class="tools">
              <button type="button" class="remove" data-id="${projectId}" title='Remove'>${obj$3.remove2}</button>
            </div>
          </div>
        </div>
      `;
    });
  }
  [DOUBLECLICK("$projectList .project-item")](e) {
    this.startInputEditing(e.$dt.$("label"));
  }
  modifyDoneInputEditing(input2) {
    this.endInputEditing(input2, (index2, text2) => {
      var project2 = this.$editor.projects[index2];
      if (project2) {
        project2.reset({
          name: text2
        });
      }
    });
  }
  [KEYDOWN("$projectList .project-item label") + ENTER + PREVENT + STOP](e) {
    this.modifyDoneInputEditing(e.$dt);
    return false;
  }
  [FOCUSOUT("$projectList .project-item label") + PREVENT + STOP](e) {
    this.modifyDoneInputEditing(e.$dt);
  }
  [CLICK("$projectList .project-item label")](e) {
    var id = e.$dt.attr("data-id");
    this.commands.executeCommand("refreshSelectionPorject", "change project", id);
    this.nextTick(() => {
      this.refresh();
    });
  }
  [CLICK("$projectList .project-item .remove")](e) {
    var id = e.$dt.attr("data-id");
    this.commands.executeCommand("removeProject", "remove project", id);
    this.nextTick(() => {
      this.refresh();
    });
  }
  [SUBSCRIBE("refreshProjectList", "refreshAll")]() {
    this.refresh();
  }
}
function project(editor) {
  editor.registerElement({
    ProjectProperty
  });
}
const char_list = [/\(/gi, /\)/gi];
const function_list = "grayscale,matrix,rotateZ,blur,sepia,linear-gradient,radial-gradient,conic-gradient,circle,inset,polygon,rgb".split(",").map((it) => {
  return new RegExp(it, "gi");
});
const keyword_list = "butt,miter,start,at,black,repeat,lighten,multiply,solid,border-box,visible,absolute,relative,auto".split(",").map((it) => {
  return new RegExp(it, "gi");
});
function replaceKeyword(str) {
  keyword_list.forEach((ke) => {
    str = str.replace(ke, (str2) => {
      return `<span class="keyword">${str2}</span>`;
    });
  });
  function_list.forEach((ke) => {
    str = str.replace(ke, (str2) => {
      return `<span class="function">${str2}</span>`;
    });
  });
  char_list.forEach((ke) => {
    str = str.replace(ke, (str2) => {
      return `<span class="char">${str2}</span>`;
    });
  });
  return str;
}
function filterKeyName(str) {
  return str.split(";").filter((it) => it.trim()).map((it) => {
    it = it.trim();
    var [key, value] = it.split(":").map((it2) => it2.trim());
    if (value === "") {
      return "";
    }
    return `<div class="block"><strong>${key}</strong><span>:&nbsp;</span><span class="value">${replaceKeyword(value)}</span><span>;</span></div>`;
  }).join("").trim();
}
function modifyNewLine(str) {
  return str.replace(/;/gi, ";\n").trim();
}
class HTMLRenderer {
  constructor(editor) {
    this.editor = editor;
  }
  get id() {
    return this.editor.EDITOR_ID;
  }
  getDefaultRendererInstance() {
    return this.editor.getRendererInstance("html", "rect");
  }
  getRendererInstance(item) {
    return this.editor.getRendererInstance("html", item.itemType) || this.getDefaultRendererInstance() || item;
  }
  render(item, renderer) {
    if (!item)
      return;
    const currentRenderer = this.getRendererInstance(item);
    if (currentRenderer) {
      return currentRenderer.render(item, renderer || this);
    }
  }
  renderSVG(item, renderer) {
    const currentRenderer = this.getRendererInstance(item);
    if (isFunction(currentRenderer.renderSVG)) {
      return currentRenderer.renderSVG(item, renderer || this);
    }
    return this.getDefaultRendererInstance().renderSVG(item, renderer || this);
  }
  to(type, item) {
    const currentRenderer = this.getRendererInstance(item);
    if (isFunction(currentRenderer[type])) {
      return currentRenderer[type].call(currentRenderer, item);
    }
    const defaultInstance = this.getDefaultRendererInstance();
    if (isFunction(defaultInstance[type])) {
      return defaultInstance[type].call(defaultInstance, item);
    }
  }
  toCSS(item, omit = {}) {
    const css = this.to("toCSS", item);
    Object.keys(omit).forEach((key) => {
      delete css[key];
    });
    return css;
  }
  toNestedCSS(item) {
    return this.to("toNestedCSS", item);
  }
  toTransformCSS(item) {
    return this.to("toTransformCSS", item);
  }
  toGridLayoutCSS(item) {
    return this.to("toGridLayoutCSS", item);
  }
  toLayoutItemCSS(item) {
    return this.to("toLayoutItemCSS", item);
  }
  toLayoutBaseModelCSS(item) {
    return this.to("toLayoutBaseModelCSS", item);
  }
  toStyle(item, renderer) {
    const currentRenderer = this.getRendererInstance(item);
    if (isFunction(currentRenderer.toStyle)) {
      return currentRenderer.toStyle(item, renderer || this);
    }
    return this.getDefaultRendererInstance().toStyle(item, renderer || this);
  }
  toStyleData(item, renderer) {
    const currentRenderer = this.getRendererInstance(item);
    if (isFunction(currentRenderer.toStyleData)) {
      return currentRenderer.toStyleData(item, renderer || this);
    }
    return this.getDefaultRendererInstance().toStyleData(item, renderer || this);
  }
  toExportStyle(item, renderer) {
    const currentRenderer = this.getRendererInstance(item);
    if (isFunction(currentRenderer.toExportStyle)) {
      return currentRenderer.toExportStyle(item, renderer || this);
    }
    return this.getDefaultRendererInstance().toExportStyle(item, renderer || this);
  }
  update(item, currentElement, editor) {
    const currentRenderer = this.getRendererInstance(item);
    if (isFunction(currentRenderer.update)) {
      return currentRenderer.update(item, currentElement, editor, this);
    }
    return this.getDefaultRendererInstance().update(item, currentElement, editor);
  }
  codeview(item) {
    if (!item) {
      return "";
    }
    const currentProject = item.top;
    let keyframeCode = modifyNewLine(filterKeyName(currentProject ? currentProject.toKeyframeString() : ""));
    let rootVariable = currentProject ? CSS_TO_STRING(currentProject.toRootVariableCSS()) : "";
    const current = item;
    const cssCode = filterKeyName(current ? TAG_TO_STRING(CSS_TO_STRING(this.toCSS(current))) : "");
    const nestedCssCode = current ? this.toNestedCSS(current).map((it) => {
      var cssText = it.cssText ? it.cssText : CSS_TO_STRING(it.css);
      return `${it.selector} { 
    ${filterKeyName(TAG_TO_STRING(cssText))}
    }`;
    }) : [];
    const selectorCode = current ? current.selectors : [];
    return `
<div >

${cssCode && `<div><pre title='CSS'>${cssCode}</pre></div>`}

${nestedCssCode.map((it) => {
      return `<div><pre title='CSS'>${it}</pre></div>`;
    }).join("")}

${(selectorCode || []).length ? `<div>
    ${selectorCode.map((selector2) => {
      return `<pre title='${selector2.selector}'>${selector2.toPropertyString()}</pre>`;
    }).join("")}
    
    </div>` : ""}

${keyframeCode && `<div><pre title='Keyframe'>${keyframeCode}</pre></div>`}

${rootVariable ? `<div>
    <label>:root</label>
    <pre>${rootVariable}</pre>
    </div>` : ""}

</div>
        `;
  }
}
class ItemRender$1 {
  getInnerId(item, postfix = "") {
    return item.id + postfix;
  }
}
const Primitive = "SourceGraphic,SourceAlpha,BackgroundImage,BackgroundAlpha,FillPaint,StrokePaint".split(",");
const DEFAULT_ATTRIBUTES = {
  xChannelSelector: true,
  yChannelSelector: true
};
class BaseSVGFilter extends PropertyItem {
  static parse(obj2) {
    var FilterClass = SVGFilterClassName[obj2.type];
    return new FilterClass(obj2);
  }
  hasLight() {
    return false;
  }
  isLight() {
    return false;
  }
  isSource() {
    return false;
  }
  getDefaultObject(obj2 = {}) {
    var id = uuidShort();
    return super.getDefaultObject(__spreadValues({
      itemType: "svgfilter",
      id,
      in: [],
      bound: { x: 100, y: 100, targetX: 0, targetY: 0 },
      connected: []
    }, obj2));
  }
  getInCount() {
    return 0;
  }
  setIn(index2, target) {
    this.json.in[index2] = { id: target.id, type: target.type };
  }
  setConnected(target) {
    var f = this.json.connected.filter((c2) => c2.id === target.id);
    if (f.length === 0) {
      this.json.connected.push({ id: target.id });
    }
  }
  convert(json) {
    if (typeof json.in === "string") {
      json.in = JSON.parse(json.in);
    }
    if (typeof json.bound === "string") {
      json.bound = JSON.parse(json.bound);
    }
    if (typeof json.connected === "string") {
      json.connected = JSON.parse(json.connected);
    }
    return json;
  }
  toCloneObject() {
    return __spreadValues(__spreadValues({}, super.toCloneObject()), this.attrs("id", "in", "bound", "connected"));
  }
  getDefaultAttribute() {
    var list2 = [];
    if (this.json.connected.length) {
      list2.push(`result="${this.json.id}result"`);
    }
    Object.keys(DEFAULT_ATTRIBUTES).filter((key) => {
      return !!this.json[key];
    }).forEach((key) => {
      list2.push(`${key}="${this.json[key]}"`);
    });
    return list2.join(" ") + " " + this.getSourceInAttribute();
  }
  hasInIndex() {
    return false;
  }
  getSourceInAttribute(inList) {
    return (inList || this.json.in).map((it, index2) => {
      if (!it)
        return "";
      var indexString = index2 === 0 ? "" : index2 + 1 + "";
      if (!this.hasInIndex()) {
        indexString = "";
      }
      if (Primitive.includes(it.type)) {
        return `in${indexString}="${it.type}"`;
      }
      return `in${indexString}="${it.id}result"`;
    }).join(" ");
  }
  toString() {
    var { type, value } = this.json;
    return `<fe${type} value="${value}" ${this.getDefaultAttribute()} />`;
  }
}
class SourceSVGFilter extends BaseSVGFilter {
  getDefaultObject(obj2 = {}) {
    return super.getDefaultObject(__spreadValues({
      type: "Source"
    }, obj2));
  }
  isSource() {
    return true;
  }
  toString() {
    return "";
  }
}
class BackgroundAlphaSVGFilter extends SourceSVGFilter {
  getDefaultObject() {
    return super.getDefaultObject({
      type: "BackgroundAlpha"
    });
  }
}
class BackgroundImageSVGFilter extends SourceSVGFilter {
  getDefaultObject() {
    return super.getDefaultObject({
      type: "BackgroundImage"
    });
  }
}
class BlendSVGFilter extends BaseSVGFilter {
  getDefaultObject() {
    return super.getDefaultObject({
      type: "Blend",
      mode: BlendSVGFilter.spec.mode.defaultValue
    });
  }
  getInCount() {
    return 2;
  }
  toString() {
    var { mode } = this.json;
    return `<feBlend ${OBJECT_TO_PROPERTY({
      mode
    })} ${this.getDefaultAttribute()} />`;
  }
  hasInIndex() {
    return true;
  }
}
BlendSVGFilter.spec = {
  mode: {
    title: "mode",
    inputType: "blend",
    defaultValue: "normal"
  }
};
class ColorMatrixSVGFilter extends BaseSVGFilter {
  getDefaultObject() {
    return super.getDefaultObject({
      type: "ColorMatrix",
      values: ColorMatrixSVGFilter.spec.values.defaultValue
    });
  }
  getInCount() {
    return 1;
  }
  toString() {
    var { values } = this.json;
    var valueString = values.join(" ");
    return `<feColorMatrix type="matrix" values="${valueString}"  ${this.getDefaultAttribute()} />`;
  }
}
ColorMatrixSVGFilter.spec = {
  values: {
    title: "values",
    inputType: "color-matrix",
    column: 5,
    defaultValue: [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0]
  }
};
class ComponentTransferSVGFilter extends BaseSVGFilter {
  getDefaultObject() {
    return super.getDefaultObject({
      type: "ComponentTransfer",
      r: ComponentTransferSVGFilter.spec.r.defaultValue,
      g: ComponentTransferSVGFilter.spec.g.defaultValue,
      b: ComponentTransferSVGFilter.spec.b.defaultValue,
      a: ComponentTransferSVGFilter.spec.a.defaultValue
    });
  }
  getInCount() {
    return 1;
  }
  parse(value) {
    var [type, ...values] = value.split(" ");
    if (type === "table" || type === "discrete") {
      return { type, tableValues: values.join(" ") };
    }
    if (type === "linear") {
      var [slop, intercept] = values;
      return { type, slop, intercept };
    } else if (type === "gamma") {
      var [amplitude, exponent, offset] = values;
      return { type, amplitude, exponent, offset };
    }
    return { type };
  }
  toString() {
    var { r, g, b, a } = this.json;
    r = this.parse(r);
    g = this.parse(g);
    b = this.parse(b);
    a = this.parse(a);
    return `<feComponentTransfer ${this.getDefaultAttribute()} >
      ${r && `<feFuncR ${OBJECT_TO_PROPERTY(r)} />`}
      ${g && `<feFuncG ${OBJECT_TO_PROPERTY(g)} />`}
      ${b && `<feFuncB ${OBJECT_TO_PROPERTY(b)} />`}
      ${a && `<feFuncA ${OBJECT_TO_PROPERTY(a)} />`}
    </feComponentTransfe>`;
  }
}
ComponentTransferSVGFilter.spec = {
  r: {
    title: "R",
    inputType: "FuncFilter",
    defaultValue: "identity"
  },
  g: {
    title: "G",
    inputType: "FuncFilter",
    defaultValue: "identity"
  },
  b: {
    title: "B",
    inputType: "FuncFilter",
    defaultValue: "identity"
  },
  a: {
    title: "A",
    inputType: "FuncFilter",
    defaultValue: "identity"
  }
};
class CompositeSVGFilter extends BaseSVGFilter {
  getDefaultObject() {
    return super.getDefaultObject({
      type: "Composite",
      operator: CompositeSVGFilter.spec.operator.defaultValue,
      k1: CompositeSVGFilter.spec.k1.defaultValue,
      k2: CompositeSVGFilter.spec.k2.defaultValue,
      k3: CompositeSVGFilter.spec.k3.defaultValue,
      k4: CompositeSVGFilter.spec.k4.defaultValue
    });
  }
  getInCount() {
    return 2;
  }
  toString() {
    var { operator, k1, k2, k3, k4 } = this.json;
    var kNumbers = "";
    if (operator === "arithmetic") {
      kNumbers = ` k1="${k1}" k2="${k2}" k3="${k3}" k4="${k4}" `;
    }
    return `<feComposite operator="${operator}" ${kNumbers}  ${this.getDefaultAttribute()} />`;
  }
  hasInIndex() {
    return true;
  }
}
CompositeSVGFilter.spec = {
  operator: {
    title: "operator",
    inputType: "select",
    options: "over,in,out,atop,xor,arithmetic",
    defaultValue: "over"
  },
  k1: {
    title: "k1",
    inputType: "number-range",
    min: 0,
    max: 1,
    step: 0.01,
    defaultValue: Length.number(0)
  },
  k2: {
    title: "k2",
    inputType: "number-range",
    min: 0,
    max: 1,
    step: 0.01,
    defaultValue: Length.number(0)
  },
  k3: {
    title: "k3",
    inputType: "number-range",
    min: 0,
    max: 1,
    step: 0.01,
    defaultValue: Length.number(0)
  },
  k4: {
    title: "k4",
    inputType: "number-range",
    min: 0,
    max: 1,
    step: 0.01,
    defaultValue: Length.number(0)
  }
};
class ConvolveMatrixSVGFilter extends BaseSVGFilter {
  getDefaultObject() {
    return super.getDefaultObject({
      type: "ConvolveMatrix",
      kernelMatrix: ConvolveMatrixSVGFilter.spec.kernelMatrix.defaultValue
    });
  }
  getInCount() {
    return 1;
  }
  toString() {
    var { kernelMatrix } = this.json;
    var valueString = kernelMatrix.join(" ");
    return `<feConvolveMatrix kernelMatrix="${valueString}"  ${this.getDefaultAttribute()} />`;
  }
}
ConvolveMatrixSVGFilter.spec = {
  kernelMatrix: {
    title: "kernelMatrix",
    inputType: "input-array",
    column: 3,
    defaultValue: [1, 0, 0, 0, 1, 0, 0, 0, 1]
  }
};
class DiffuseLightingSVGFilter extends BaseSVGFilter {
  getDefaultObject() {
    return super.getDefaultObject({
      type: "DiffuseLighting",
      surfaceScale: DiffuseLightingSVGFilter.spec.surfaceScale.defaultValue,
      lightingColor: DiffuseLightingSVGFilter.spec.lightingColor.defaultValue,
      diffuseConstant: DiffuseLightingSVGFilter.spec.diffuseConstant.defaultValue,
      lightInfo: ""
    });
  }
  toCloneObject() {
    return __spreadValues(__spreadValues({}, super.toCloneObject()), this.attrs("surfaceScale", "lightingColor", "diffuseConstant", "lightInfo"));
  }
  hasLight() {
    return true;
  }
  getInCount() {
    return 1;
  }
  toString() {
    var { surfaceScale, diffuseConstant, lightingColor } = this.json;
    return `<feDiffuseLighting ${OBJECT_TO_PROPERTY({
      surfaceScale,
      diffuseConstant,
      "lighting-color": lightingColor
    })}  ${this.getDefaultAttribute()} >
      ${this.json.lightInfo}
    </feDiffuseLighting>`;
  }
}
DiffuseLightingSVGFilter.spec = {
  surfaceScale: {
    title: "surfaceScale",
    inputType: "number-range",
    min: 0,
    max: 100,
    step: 1,
    defaultValue: Length.number(1)
  },
  diffuseConstant: {
    title: "diffuseConstant",
    inputType: "number-range",
    min: 0,
    max: 100,
    step: 1,
    defaultValue: Length.number(1)
  },
  lightingColor: {
    title: "Lighting Color",
    inputType: "color",
    defaultValue: "rgba(0, 0, 0, 1)"
  }
};
class DisplacementMapSVGFilter extends BaseSVGFilter {
  getDefaultObject() {
    return super.getDefaultObject({
      type: "DisplacementMap",
      scale: DisplacementMapSVGFilter.spec.scale.defaultValue
    });
  }
  getInCount() {
    return 2;
  }
  convert(obj2) {
    obj2.scale = Length.parse(obj2.scale);
    return obj2;
  }
  toString() {
    var { scale: scale2 } = this.json;
    var scaleOption = scale2.value ? `scale="${scale2}"` : "";
    return `<feDisplacementMap ${scaleOption}  ${this.getDefaultAttribute()} />`;
  }
  hasInIndex() {
    return true;
  }
}
DisplacementMapSVGFilter.spec = {
  scale: {
    title: "scale",
    inputType: "number-range",
    min: 0,
    max: 5e3,
    step: 1,
    defaultValue: Length.number(0)
  }
};
class DistantLightSVGFilter extends BaseSVGFilter {
  getDefaultObject() {
    return super.getDefaultObject({
      type: "DistantLight",
      azimuth: DistantLightSVGFilter.spec.azimuth.defaultValue,
      elevation: DistantLightSVGFilter.spec.elevation.defaultValue
    });
  }
  isLight() {
    return true;
  }
  toString() {
    return "";
  }
  toLightString() {
    var { azimuth, elevation } = this.json;
    return `<feDistantLight ${OBJECT_TO_PROPERTY({
      azimuth,
      elevation
    })} />`;
  }
}
DistantLightSVGFilter.spec = {
  azimuth: {
    title: "azimuth",
    inputType: "number-range",
    min: 0,
    max: 1e3,
    step: 1,
    defaultValue: Length.number(0)
  },
  elevation: {
    title: "elevation",
    inputType: "number-range",
    min: 0,
    max: 1e3,
    step: 1,
    defaultValue: Length.number(0)
  }
};
class DropShadowSVGFilter extends BaseSVGFilter {
  getDefaultObject() {
    return super.getDefaultObject({
      type: "DropShadow",
      dx: DropShadowSVGFilter.spec.dx.defaultValue,
      dy: DropShadowSVGFilter.spec.dy.defaultValue,
      stdDeviation: DropShadowSVGFilter.spec.stdDeviation.defaultValue,
      color: DropShadowSVGFilter.spec.color.defaultValue,
      opacity: DropShadowSVGFilter.spec.opacity.defaultValue
    });
  }
  getInCount() {
    return 1;
  }
  toString() {
    var { dx, dy, stdDeviation, color: color2, opacity: opacity2 } = this.json;
    return `<feDropShadow ${OBJECT_TO_PROPERTY({
      dx,
      dy,
      stdDeviation,
      "flood-color": color2,
      "flood-opacity": opacity2
    })}  ${this.getDefaultAttribute()} />`;
  }
}
DropShadowSVGFilter.spec = {
  dx: {
    title: "dx",
    inputType: "number-range",
    min: 0,
    max: 1e3,
    step: 1,
    defaultValue: Length.number(0)
  },
  dy: {
    title: "dy",
    inputType: "number-range",
    min: 0,
    max: 1e3,
    step: 1,
    defaultValue: Length.number(0)
  },
  stdDeviation: {
    title: "stdDeviation",
    inputType: "number-range",
    min: 0,
    max: 1e3,
    step: 0.1,
    defaultValue: Length.number(0)
  },
  opacity: {
    title: "opacity",
    inputType: "number-range",
    min: 0,
    max: 1,
    step: 0.01,
    defaultValue: Length.number(1)
  },
  color: {
    title: "color",
    inputType: "color",
    defaultValue: "rgba(0, 0, 0, 1)"
  }
};
class FillPaintSVGFilter extends SourceSVGFilter {
  getDefaultObject() {
    return super.getDefaultObject({
      type: "FillPaint"
    });
  }
}
class FloodSVGFilter extends BaseSVGFilter {
  getDefaultObject() {
    return super.getDefaultObject({
      type: "Flood",
      x: FloodSVGFilter.spec.x.defaultValue,
      y: FloodSVGFilter.spec.y.defaultValue,
      width: FloodSVGFilter.spec.width.defaultValue,
      height: FloodSVGFilter.spec.height.defaultValue,
      color: FloodSVGFilter.spec.color.defaultValue,
      opacity: FloodSVGFilter.spec.opacity.defaultValue
    });
  }
  convert(json) {
    json.x = Length.parse(json.x);
    json.y = Length.parse(json.y);
    json.width = Length.parse(json.width);
    json.height = Length.parse(json.height);
    return json;
  }
  toString() {
    const { opacity: opacity2, color: color2, x, y, width: width2, height: height2 } = this.json;
    return `<feFlood ${OBJECT_TO_PROPERTY({
      x,
      y,
      width: width2,
      height: height2
    })} flood-opacity="${opacity2}" flood-color="${color2}" ${this.getDefaultAttribute()} />`;
  }
}
FloodSVGFilter.spec = {
  x: {
    title: "X",
    inputType: "number-range",
    min: 0,
    max: 1e3,
    step: 1,
    defaultValue: Length.number(0)
  },
  y: {
    title: "Y",
    inputType: "number-range",
    min: 0,
    max: 1e3,
    step: 1,
    defaultValue: Length.number(0)
  },
  width: {
    title: "width",
    inputType: "number-range",
    min: 0,
    max: 1e3,
    step: 1,
    defaultValue: Length.number(0)
  },
  height: {
    title: "height",
    inputType: "number-range",
    min: 0,
    max: 1e3,
    step: 1,
    defaultValue: Length.number(0)
  },
  opacity: {
    title: "opacity",
    inputType: "number-range",
    min: 0,
    max: 1,
    step: 0.01,
    defaultValue: Length.number(0)
  },
  color: {
    title: "color",
    inputType: "color",
    defaultValue: "rgba(0, 0, 0, 1)"
  }
};
class GaussianBlurSVGFilter extends BaseSVGFilter {
  getDefaultObject() {
    return super.getDefaultObject({
      type: "GaussianBlur",
      stdDeviationX: GaussianBlurSVGFilter.spec.stdDeviationX.defaultValue,
      stdDeviationY: GaussianBlurSVGFilter.spec.stdDeviationY.defaultValue,
      edgeMode: GaussianBlurSVGFilter.spec.edgeMode.defaultValue
    });
  }
  getInCount() {
    return 1;
  }
  convert(obj2) {
    obj2.stdDeviationX = Length.parse(obj2.stdDeviationX);
    obj2.stdDeviationY = Length.parse(obj2.stdDeviationY);
    return obj2;
  }
  toString() {
    var { stdDeviationX, stdDeviationY, edgeMode } = this.json;
    var stdDeviation = `${stdDeviationX} ${stdDeviationY}`;
    if (stdDeviationX === stdDeviationY) {
      stdDeviation = stdDeviationX;
    }
    return `<feGaussianBlur  stdDeviation="${stdDeviation}" edgeMode="${edgeMode}"  ${this.getDefaultAttribute()} />`;
  }
}
GaussianBlurSVGFilter.spec = {
  stdDeviationX: {
    title: "X",
    inputType: "number-range",
    min: 0,
    max: 100,
    step: 1,
    defaultValue: Length.number(0)
  },
  stdDeviationY: {
    title: "Y",
    inputType: "number-range",
    min: 0,
    max: 100,
    step: 1,
    defaultValue: Length.number(0)
  },
  edgeMode: {
    title: "edge",
    inputType: "select",
    options: "none,duplicate,wrap",
    defaultValue: "none"
  }
};
class HueRotateSVGFilter extends BaseSVGFilter {
  getDefaultObject() {
    return super.getDefaultObject({
      type: "HueRotate",
      values: HueRotateSVGFilter.spec.values.defaultValue
    });
  }
  getInCount() {
    return 1;
  }
  toString() {
    var { values } = this.json;
    return `<feColorMatrix type="hueRotate" values="${values}"  ${this.getDefaultAttribute()} />`;
  }
}
HueRotateSVGFilter.spec = {
  values: {
    title: "values",
    inputType: "number-range",
    min: 0,
    max: 360,
    step: 0.1,
    defaultValue: Length.number(0)
  }
};
class ImageSVGFilter extends BaseSVGFilter {
  getDefaultObject() {
    return super.getDefaultObject({
      type: "Image",
      x: ImageSVGFilter.spec.x.defaultValue,
      y: ImageSVGFilter.spec.y.defaultValue,
      width: ImageSVGFilter.spec.width.defaultValue,
      height: ImageSVGFilter.spec.height.defaultValue,
      src: ImageSVGFilter.spec.src.defaultValue,
      alignment: ImageSVGFilter.spec.alignment.defaultValue,
      scaleing: ImageSVGFilter.spec.scaleing.defaultValue
    });
  }
  convert(json) {
    json.x = Length.parse(json.x);
    json.y = Length.parse(json.y);
    json.width = Length.parse(json.width);
    json.height = Length.parse(json.height);
    return json;
  }
  toString() {
    const { src, x, y, width: width2, height: height2, alignment: alignment2, scaleing } = this.json;
    return `<feImage ${OBJECT_TO_PROPERTY({
      x,
      y,
      width: width2,
      height: height2,
      "xlink:href": src,
      preserveAspectRatio: `${alignment2} ${scaleing}`
    })} ${this.getDefaultAttribute()} />`;
  }
}
ImageSVGFilter.spec = {
  x: {
    title: "X",
    inputType: "number-range",
    min: 0,
    max: 1e3,
    step: 1,
    defaultValue: Length.number(0)
  },
  y: {
    title: "Y",
    inputType: "number-range",
    min: 0,
    max: 1e3,
    step: 1,
    defaultValue: Length.number(0)
  },
  width: {
    title: "width",
    inputType: "number-range",
    min: 0,
    max: 1e3,
    step: 1,
    defaultValue: Length.number(0)
  },
  height: {
    title: "height",
    inputType: "number-range",
    min: 0,
    max: 1e3,
    step: 1,
    defaultValue: Length.number(0)
  },
  alignment: {
    title: "alignment",
    inputType: "select",
    options: "xMinYMin,xMidYMin,xMaxYMin,xMinYMid,xMidYMid,xMaxYMid,xMinYMax,xMidYMax,xMaxYMax",
    defaultValue: "xMidYMid"
  },
  scaleing: {
    title: "scaleing",
    inputType: "select",
    options: "meet,slice",
    defaultValue: "meet"
  },
  src: {
    title: "Image",
    inputType: "ImageSelectEditor",
    defaultValue: ""
  }
};
class LuminanceAlphaSVGFilter extends BaseSVGFilter {
  getDefaultObject() {
    return super.getDefaultObject({
      type: "LuminanceAlpha"
    });
  }
  getInCount() {
    return 1;
  }
  toString() {
    return `<feColorMatrix type="luminanceToAlpha" ${this.getDefaultAttribute()} />`;
  }
}
LuminanceAlphaSVGFilter.spec = {};
class MergeSVGFilter extends BaseSVGFilter {
  getDefaultObject() {
    return super.getDefaultObject({
      type: "Merge"
    });
  }
  getInCount() {
    return 3;
  }
  getDefaultAttribute() {
    var list2 = [];
    if (this.json.connected.length) {
      list2.push(`result="${this.json.id}result"`);
    }
    return list2.join(" ");
  }
  toString() {
    var { in: inList } = this.json;
    return `
    <feMerge  ${this.getDefaultAttribute()} >
      ${inList.map((it) => {
      return `<feMergeNode ${this.getSourceInAttribute([it])} />`;
    }).join("")}
    </feMerge>`;
  }
}
MergeSVGFilter.spec = {};
class MorphologySVGFilter extends BaseSVGFilter {
  getDefaultObject() {
    return super.getDefaultObject({
      type: "Morphology",
      operator: MorphologySVGFilter.spec.operator.defaultValue,
      radius: MorphologySVGFilter.spec.radius.defaultValue
    });
  }
  getInCount() {
    return 1;
  }
  toString() {
    var { operator, radius } = this.json;
    return `<feMorphology operator="${operator}" radius="${radius}"  ${this.getDefaultAttribute()} />`;
  }
}
MorphologySVGFilter.spec = {
  operator: {
    title: "Operator",
    inputType: "select",
    options: "erode,dilate",
    defaultValue: "erode"
  },
  radius: {
    title: "Radius",
    inputType: "number-range",
    min: 0,
    max: 100,
    step: 1,
    defaultValue: Length.number(0)
  }
};
class OffsetSVGFilter extends BaseSVGFilter {
  getDefaultObject() {
    return super.getDefaultObject({
      type: "Offset",
      dx: OffsetSVGFilter.spec.dx.defaultValue,
      dy: OffsetSVGFilter.spec.dy.defaultValue
    });
  }
  getInCount() {
    return 1;
  }
  toString() {
    var { dx, dy } = this.json;
    return `<feOffset 
      ${OBJECT_TO_PROPERTY({
      dx,
      dy
    })}  ${this.getDefaultAttribute()} />`;
  }
}
OffsetSVGFilter.spec = {
  dx: {
    title: "dx",
    inputType: "number-range",
    min: 0,
    max: 1e3,
    step: 1,
    defaultValue: Length.number(0)
  },
  dy: {
    title: "dy",
    inputType: "number-range",
    min: 0,
    max: 1e3,
    step: 1,
    defaultValue: Length.number(0)
  }
};
class PointLightSVGFilter extends BaseSVGFilter {
  getDefaultObject() {
    return super.getDefaultObject({
      type: "PointLight",
      x: PointLightSVGFilter.spec.x.defaultValue,
      y: PointLightSVGFilter.spec.y.defaultValue,
      z: PointLightSVGFilter.spec.z.defaultValue
    });
  }
  isLight() {
    return true;
  }
  toString() {
    return "";
  }
  toLightString() {
    var { x, y, z } = this.json;
    return `<fePointLight ${OBJECT_TO_PROPERTY({
      x,
      y,
      z
    })} />`;
  }
}
PointLightSVGFilter.spec = {
  x: {
    title: "x",
    inputType: "number-range",
    min: 0,
    max: 1e3,
    step: 1,
    defaultValue: Length.number(0)
  },
  y: {
    title: "y",
    inputType: "number-range",
    min: 0,
    max: 1e3,
    step: 1,
    defaultValue: Length.number(0)
  },
  z: {
    title: "z",
    inputType: "number-range",
    min: 0,
    max: 1e3,
    step: 1,
    defaultValue: Length.number(0)
  }
};
class RotaMatrixSVGFilter extends BaseSVGFilter {
  getDefaultObject() {
    return super.getDefaultObject({
      type: "RotaMatrix",
      hueRotate: RotaMatrixSVGFilter.spec.hueRotate.defaultValue
    });
  }
  convert(json) {
    json.hueRotate = Length.parse(json.hueRotate);
    return json;
  }
  toString() {
    var { id, hueRotate } = this.json;
    return `
      <feColorMatrix type="hueRotate" result="romatrix-${id}"  values="${hueRotate}"/>
      <feColorMatrix type="matrix" in="romatrix-${id}" in2="SourceGraphic"  ${this.getDefaultAttribute()} values="-1 2 -3 0 -.5 2 1 0 0 0 0 3 1 0 0 0 0 1 1 0"/>
    `;
  }
}
RotaMatrixSVGFilter.spec = {
  hueRotate: {
    title: "hue-rotate",
    inputType: "number-range",
    min: 0,
    max: 360,
    step: 1,
    defaultValue: Length.number(0)
  }
};
class SaturateSVGFilter extends BaseSVGFilter {
  getDefaultObject() {
    return super.getDefaultObject({
      type: "Saturate",
      values: SaturateSVGFilter.spec.values.defaultValue
    });
  }
  getInCount() {
    return 1;
  }
  toString() {
    var { values } = this.json;
    return `<feColorMatrix type="saturate" values="${values}"  ${this.getDefaultAttribute()} />`;
  }
}
SaturateSVGFilter.spec = {
  values: {
    title: "values",
    inputType: "number-range",
    min: -1,
    max: 1,
    step: 0.01,
    defaultValue: Length.number(0)
  }
};
class SourceAlphaSVGFilter extends SourceSVGFilter {
  getDefaultObject() {
    return super.getDefaultObject({
      type: "SourceAlpha"
    });
  }
}
class SourceGraphicSVGFilter extends SourceSVGFilter {
  getDefaultObject() {
    return super.getDefaultObject({
      type: "SourceGraphic"
    });
  }
}
class SpecularLightingSVGFilter extends BaseSVGFilter {
  getDefaultObject() {
    return super.getDefaultObject({
      type: "SpecularLighting",
      surfaceScale: SpecularLightingSVGFilter.spec.surfaceScale.defaultValue,
      lightingColor: SpecularLightingSVGFilter.spec.lightingColor.defaultValue,
      specularConstant: SpecularLightingSVGFilter.spec.specularConstant.defaultValue,
      specularExponent: SpecularLightingSVGFilter.spec.specularExponent.defaultValue,
      lightInfo: ""
    });
  }
  toCloneObject() {
    return __spreadValues(__spreadValues({}, super.toCloneObject()), this.attrs("surfaceScale", "lightingColor", "specularConstant", "specularExponent", "lightInfo"));
  }
  hasLight() {
    return true;
  }
  getInCount() {
    return 1;
  }
  toString() {
    var { surfaceScale, specularConstant, specularExponent, lightingColor } = this.json;
    return `<feSpecularLighting ${OBJECT_TO_PROPERTY({
      surfaceScale,
      specularConstant,
      specularExponent,
      "lighting-color": lightingColor
    })}  ${this.getDefaultAttribute()} >
      ${this.json.lightInfo}
    </feSpecularLighting>`;
  }
  getSourceInAttribute() {
    return "";
  }
}
SpecularLightingSVGFilter.spec = {
  surfaceScale: {
    title: "surfaceScale",
    inputType: "number-range",
    min: 0,
    max: 100,
    step: 1,
    defaultValue: Length.number(1)
  },
  specularConstant: {
    title: "Constant",
    inputType: "number-range",
    min: 0,
    max: 100,
    step: 1,
    defaultValue: Length.number(1)
  },
  specularExponent: {
    title: "Exponent",
    inputType: "number-range",
    min: 0,
    max: 100,
    step: 1,
    defaultValue: Length.number(1)
  },
  lightingColor: {
    title: "Lighting Color",
    inputType: "color",
    defaultValue: "rgba(0, 0, 0, 1)"
  }
};
class SpotLightSVGFilter extends BaseSVGFilter {
  getDefaultObject() {
    return super.getDefaultObject({
      type: "SpotLight",
      x: SpotLightSVGFilter.spec.x.defaultValue,
      y: SpotLightSVGFilter.spec.x.defaultValue,
      z: SpotLightSVGFilter.spec.x.defaultValue,
      pointsAtX: SpotLightSVGFilter.spec.pointsAtX.defaultValue,
      pointsAtY: SpotLightSVGFilter.spec.pointsAtY.defaultValue,
      pointsAtZ: SpotLightSVGFilter.spec.pointsAtZ.defaultValue,
      specularExponent: SpotLightSVGFilter.spec.specularExponent.defaultValue,
      limitingConeAngle: SpotLightSVGFilter.spec.limitingConeAngle.defaultValue
    });
  }
  isLight() {
    return true;
  }
  toString() {
  }
  toLightString() {
    var {
      x,
      y,
      z,
      pointsAtX,
      pointsAtY,
      pointsAtZ,
      specularExponent,
      limitingConeAngle
    } = this.json;
    return `<feSpotLight ${OBJECT_TO_PROPERTY({
      x,
      y,
      z,
      pointsAtX,
      pointsAtY,
      pointsAtZ,
      specularExponent,
      limitingConeAngle
    })} />`;
  }
}
SpotLightSVGFilter.spec = {
  x: {
    title: "x",
    inputType: "number-range",
    min: 0,
    max: 1e3,
    step: 1,
    defaultValue: Length.number(0)
  },
  y: {
    title: "y",
    inputType: "number-range",
    min: 0,
    max: 1e3,
    step: 1,
    defaultValue: Length.number(0)
  },
  z: {
    title: "z",
    inputType: "number-range",
    min: 0,
    max: 1e3,
    step: 1,
    defaultValue: Length.number(0)
  },
  pointsAtX: {
    title: "pointsAtX",
    inputType: "number-range",
    min: 0,
    max: 1e3,
    step: 1,
    defaultValue: Length.number(0)
  },
  pointsAtY: {
    title: "pointsAtY",
    inputType: "number-range",
    min: 0,
    max: 1e3,
    step: 1,
    defaultValue: Length.number(0)
  },
  pointsAtZ: {
    title: "pointsAtZ",
    inputType: "number-range",
    min: 0,
    max: 1e3,
    step: 1,
    defaultValue: Length.number(0)
  },
  specularExponent: {
    title: "specularExponent",
    inputType: "number-range",
    min: 0,
    max: 100,
    step: 1,
    defaultValue: Length.number(1)
  },
  limitingConeAngle: {
    title: "limitingConeAngle",
    inputType: "number-range",
    min: 0,
    max: 100,
    step: 1,
    defaultValue: Length.number(1)
  }
};
class StrokePaintSVGFilter extends SourceSVGFilter {
  getDefaultObject() {
    return super.getDefaultObject({
      type: "StrokePaint"
    });
  }
}
class TileSVGFilter extends BaseSVGFilter {
  getDefaultObject() {
    return super.getDefaultObject({
      type: "Tile",
      x: TileSVGFilter.spec.x.defaultValue,
      y: TileSVGFilter.spec.y.defaultValue,
      width: TileSVGFilter.spec.width.defaultValue,
      height: TileSVGFilter.spec.height.defaultValue
    });
  }
  getInCount() {
    return 1;
  }
  convert(json) {
    json.x = Length.parse(json.x);
    json.y = Length.parse(json.y);
    json.width = Length.parse(json.width);
    json.height = Length.parse(json.height);
    return json;
  }
  toString() {
    const { x, y, width: width2, height: height2 } = this.json;
    return `<feTile ${OBJECT_TO_PROPERTY({
      x,
      y,
      width: width2,
      height: height2
    })} ${this.getDefaultAttribute()} />`;
  }
}
TileSVGFilter.spec = {
  x: {
    title: "X",
    inputType: "number-range",
    min: 0,
    max: 1e3,
    step: 1,
    defaultValue: Length.number(0)
  },
  y: {
    title: "Y",
    inputType: "number-range",
    min: 0,
    max: 1e3,
    step: 1,
    defaultValue: Length.number(0)
  },
  width: {
    title: "width",
    inputType: "number-range",
    min: 0,
    max: 1e3,
    step: 1,
    defaultValue: Length.number(0)
  },
  height: {
    title: "height",
    inputType: "number-range",
    min: 0,
    max: 1e3,
    step: 1,
    defaultValue: Length.number(0)
  }
};
class TurbulenceSVGFilter extends BaseSVGFilter {
  getDefaultObject() {
    return super.getDefaultObject({
      type: "Turbulence",
      filterType: TurbulenceSVGFilter.spec.filterType.defaultValue,
      baseFrequency: TurbulenceSVGFilter.spec.baseFrequency.defaultValue,
      numOctaves: TurbulenceSVGFilter.spec.numOctaves.defaultValue,
      seed: TurbulenceSVGFilter.spec.seed.defaultValue
    });
  }
  convert(obj2) {
    obj2.baseFrequency = Length.parse(obj2.baseFrequency);
    obj2.numOctaves = Length.parse(obj2.numOctaves);
    obj2.seed = Length.parse(obj2.seed);
    return obj2;
  }
  toString() {
    var { filterType, baseFrequency, numOctaves, seed } = this.json;
    return `<feTurbulence ${OBJECT_TO_PROPERTY({
      type: filterType,
      baseFrequency,
      numOctaves,
      seed
    })}   ${this.getDefaultAttribute()} />`;
  }
}
TurbulenceSVGFilter.spec = {
  filterType: {
    title: "Type",
    inputType: "select",
    options: "fractalNoise,turbulence",
    defaultValue: "turbulence"
  },
  baseFrequency: {
    title: "Frequency",
    inputType: "number-range",
    min: 0,
    max: 1,
    step: 0.01,
    defaultValue: Length.number(0)
  },
  numOctaves: {
    title: "Octaves",
    inputType: "number-range",
    min: 1,
    max: 10,
    step: 1,
    defaultValue: Length.number(1)
  },
  seed: {
    title: "Seed",
    inputType: "number-range",
    min: 0,
    max: 1e4,
    step: 1,
    defaultValue: Length.number(0)
  }
};
const SVG_FILTER_COMMON_ATTRIBUTES = ["result"];
class SVGFilter extends PropertyItem {
  static parse(obj2) {
    var FilterClass = SVGFilterClassName[obj2.type];
    return new FilterClass(obj2);
  }
  getDefaultObject(obj2 = {}) {
    return super.getDefaultObject(__spreadValues({
      itemType: "svgfilter",
      result: ""
    }, obj2));
  }
  getDefaultAttribute() {
    return SVG_FILTER_COMMON_ATTRIBUTES.map((key) => {
      return `${key}="${this.json[key]}"`;
    }).join(" ");
  }
  toString() {
    var { type, value } = this.json;
    return `<fe${type} value="${value}" ${this.getDefaultAttribute()} />`;
  }
}
const SVGFilterClassName = {
  Image: ImageSVGFilter,
  Tile: TileSVGFilter,
  Saturate: SaturateSVGFilter,
  HueRotate: HueRotateSVGFilter,
  LuminanceAlpha: LuminanceAlphaSVGFilter,
  DropShadow: DropShadowSVGFilter,
  SourceGraphic: SourceGraphicSVGFilter,
  SourceAlpha: SourceAlphaSVGFilter,
  BackgroundImage: BackgroundImageSVGFilter,
  BackgroundAlpha: BackgroundAlphaSVGFilter,
  FillPaint: FillPaintSVGFilter,
  StrokePaint: StrokePaintSVGFilter,
  ComponentTransfer: ComponentTransferSVGFilter,
  DistantLight: DistantLightSVGFilter,
  PointLight: PointLightSVGFilter,
  SpotLight: SpotLightSVGFilter,
  DiffuseLighting: DiffuseLightingSVGFilter,
  SpecularLighting: SpecularLightingSVGFilter,
  Blend: BlendSVGFilter,
  Offset: OffsetSVGFilter,
  RotaMatrix: RotaMatrixSVGFilter,
  GaussianBlur: GaussianBlurSVGFilter,
  Flood: FloodSVGFilter,
  Merge: MergeSVGFilter,
  Composite: CompositeSVGFilter,
  Morphology: MorphologySVGFilter,
  Turbulence: TurbulenceSVGFilter,
  DisplacementMap: DisplacementMapSVGFilter,
  ColorMatrix: ColorMatrixSVGFilter,
  ConvolveMatrix: ConvolveMatrixSVGFilter
};
const SVGFilterSpecList = {
  Image: ImageSVGFilter.spec,
  Tile: TileSVGFilter.spec,
  DropShadow: DropShadowSVGFilter.spec,
  Saturate: SaturateSVGFilter.spec,
  HueRotate: HueRotateSVGFilter.spec,
  LuminanceAlpha: LuminanceAlphaSVGFilter.spec,
  Offset: OffsetSVGFilter.spec,
  ComponentTransfer: ComponentTransferSVGFilter.spec,
  SpecularLighting: SpecularLightingSVGFilter.spec,
  SpotLight: SpotLightSVGFilter.spec,
  PointLight: PointLightSVGFilter.spec,
  DistantLight: DistantLightSVGFilter.spec,
  DiffuseLighting: DiffuseLightingSVGFilter.spec,
  Blend: BlendSVGFilter.spec,
  RotaMatrix: RotaMatrixSVGFilter.spec,
  Merge: MergeSVGFilter.spec,
  GaussianBlur: GaussianBlurSVGFilter.spec,
  Flood: FloodSVGFilter.spec,
  Morphology: MorphologySVGFilter.spec,
  Composite: CompositeSVGFilter.spec,
  Turbulence: TurbulenceSVGFilter.spec,
  DisplacementMap: DisplacementMapSVGFilter.spec,
  ColorMatrix: ColorMatrixSVGFilter.spec,
  ConvolveMatrix: ConvolveMatrixSVGFilter.spec
};
const WEBKIT_ATTRIBUTE_FOR_CSS = [
  "text-fill-color",
  "text-stroke-color",
  "text-stroke-width",
  "background-clip"
];
function valueFilter(obj2) {
  const result = {};
  Object.keys(obj2).forEach((key) => {
    if (isNotUndefined(obj2[key])) {
      result[key] = obj2[key];
    }
  });
  return result;
}
class DomRender$1 extends ItemRender$1 {
  toStringPropertyCSS(item, field) {
    return STRING_TO_CSS(item.get(field));
  }
  toBackgroundImageCSS(item) {
    if (!item.cacheBackgroundImage) {
      item.setBackgroundImageCache();
    }
    return {
      "background-image": item.cacheBackgroundImage["background-image"],
      "background-position": item.cacheBackgroundImage["background-position"],
      "background-repeat": item.cacheBackgroundImage["background-repeat"],
      "background-size": item.cacheBackgroundImage["background-size"],
      "background-blend-mode": item.cacheBackgroundImage["background-blend-mode"]
    };
  }
  toLayoutCSS(item) {
    if (item.hasLayout()) {
      if (item.isLayout(Layout.FLEX)) {
        return this.toFlexLayoutCSS(item);
      } else if (item.isLayout(Layout.GRID)) {
        return this.toGridLayoutCSS(item);
      }
    }
    return {};
  }
  toLayoutItemCSS(item) {
    var _a, _b;
    var parentLayout = (_a = item.parent) == null ? void 0 : _a["layout"];
    var obj2 = {};
    if (parentLayout === Layout.FLEX) {
      obj2 = {
        position: "relative",
        left: "auto !important",
        top: "auto !important"
      };
    } else if (parentLayout === Layout.GRID) {
      obj2 = {
        position: "relative",
        left: "auto",
        top: "auto"
      };
    } else if (parentLayout === Layout.DEFAULT) {
      obj2 = this.toDefaultLayoutItemCSS(item);
    }
    if (parentLayout === Layout.FLEX) {
      obj2 = __spreadValues(__spreadValues({}, obj2), item.attrs("flexBasis", "flexShrink"));
      const parentLayoutDirection = (_b = item == null ? void 0 : item.parent) == null ? void 0 : _b.flexDirection;
      if (parentLayoutDirection === FlexDirection.ROW && item.resizingHorizontal === ResizingMode.FILL_CONTAINER) {
        obj2.width = "auto";
        obj2["flex-grow"] = item.flexGrow || 1;
      } else if (parentLayoutDirection === FlexDirection.COLUMN && item.resizingVertical === ResizingMode.FILL_CONTAINER) {
        obj2.height = "auto";
        obj2["flex-grow"] = item.flexGrow || 1;
      }
    } else if (parentLayout === Layout.GRID) {
      obj2 = __spreadValues(__spreadValues({}, obj2), item.attrs("gridColumnStart", "gridColumnEnd", "gridRowStart", "gridRowEnd"));
      const columns = Grid.parseStyle(item.parent.gridTemplateColumns);
      const rows = Grid.parseStyle(item.parent.gridTemplateRows);
      obj2["grid-column-start"] = Math.max(1, Math.min(columns.length, obj2["grid-column-start"] || 1));
      obj2["grid-column-end"] = Math.min(columns.length + 1, obj2["grid-column-end"] || 2);
      obj2["grid-row-start"] = Math.max(1, Math.min(rows.length, obj2["grid-row-start"] || 1));
      obj2["grid-row-end"] = Math.min(rows.length + 1, obj2["grid-row-end"] || 2);
    }
    return obj2;
  }
  toDefaultLayoutItemCSS(item) {
    var _a;
    const obj2 = {};
    if ((_a = item.parent) == null ? void 0 : _a.is("project")) {
      return obj2;
    }
    const parentWidth = item.parent.screenWidth;
    switch (item[ConstraintsDirection.HORIZONTAL]) {
      case Constraints.MIN:
        obj2.left = Length.px(item.x);
        obj2.right = "auto !important";
        break;
      case Constraints.MAX:
        obj2.right = Length.px(parentWidth - item.offsetX - item.screenWidth);
        obj2.left = "auto !important";
        break;
      case Constraints.STRETCH:
        obj2.left = Length.px(item.x);
        obj2.right = Length.px(parentWidth - item.offsetX - item.screenWidth);
        obj2.width = "auto !important";
        break;
      case Constraints.CENTER:
        obj2.left = Length.px(item.x);
        break;
      case Constraints.SCALE:
        obj2.left = Length.px(item.x).toPercent(parentWidth);
        obj2.right = Length.px(parentWidth - item.offsetX - item.screenWidth).toPercent(parentWidth);
        obj2.width = "auto !important";
        break;
    }
    const parentHeight = item.parent.screenHeight;
    switch (item[ConstraintsDirection.VERTICAL]) {
      case Constraints.MIN:
        obj2.top = Length.px(item.y);
        obj2.bottom = "auto !important";
        break;
      case Constraints.MAX:
        obj2.top = "auto !important";
        obj2.bottom = Length.px(parentHeight - item.offsetY - item.screenHeight);
        break;
      case Constraints.STRETCH:
        obj2.top = Length.px(item.y);
        obj2.bottom = Length.px(parentHeight - item.offsetY - item.screenHeight);
        obj2.height = "auto !important";
        break;
      case Constraints.CENTER:
        obj2.top = Length.px(item.y);
        break;
      case Constraints.SCALE:
        obj2.top = Length.px(item.y).toPercent(parentHeight);
        obj2.bottom = Length.px(parentHeight - item.offsetY - item.screenHeight).toPercent(parentHeight);
        obj2.height = "auto !important";
        break;
    }
    return obj2;
  }
  toFlexLayoutCSS(item) {
    if (item.parent.isNot("project"))
      ;
    return __spreadValues({
      display: "flex",
      gap: Length.px(item.gap)
    }, item.attrs("flex-direction", "flex-wrap", "justify-content", "align-items", "align-content"));
  }
  toGridLayoutCSS(item) {
    return __spreadValues({
      display: "grid"
    }, item.attrs("grid-template-columns", "grid-template-rows", "grid-auto-columns", "grid-auto-rows", "grid-auto-flow", "grid-column-gap", "grid-row-gap"));
  }
  toBorderCSS(item) {
    const borderCSS = item.computed("border", (border2) => {
      const obj2 = __spreadValues({}, STRING_TO_CSS(border2));
      return obj2;
    });
    return borderCSS;
  }
  toBoxModelCSS(item) {
    let obj2 = {};
    if (item.marginTop)
      obj2["margin-top"] = Length.px(item.marginTop);
    if (item.marginBottom)
      obj2["margin-bottom"] = Length.px(item.marginBottom);
    if (item.marginLeft)
      obj2["margin-left"] = Length.px(item.marginLeft);
    if (item.marginRight)
      obj2["margin-right"] = Length.px(item.marginRight);
    if (item.paddingTop)
      obj2["padding-top"] = Length.px(item.paddingTop);
    if (item.paddingBottom)
      obj2["padding-bottom"] = Length.px(item.paddingBottom);
    if (item.paddingLeft)
      obj2["padding-left"] = Length.px(item.paddingLeft);
    if (item.paddingRight)
      obj2["padding-right"] = Length.px(item.paddingRight);
    return obj2;
  }
  toKeyListCSS(item, args2 = []) {
    let obj2 = {};
    for (var i = 0; i < args2.length; i++) {
      const key = args2[i];
      const value = item.get(key);
      if (isNotUndefined(value)) {
        obj2[key] = value || item[key];
      }
    }
    return obj2;
  }
  toSizeCSS(item) {
    const obj2 = {};
    if (item.isLayout(Layout.FLEX)) {
      switch (item.resizingHorizontal) {
        case ResizingMode.FIXED:
          obj2.width = Length.px(item.screenWidth);
          break;
        case ResizingMode.HUG_CONTENT:
          obj2["min-width"] = Length.px(item.screenWidth);
          break;
      }
      switch (item.resizingVertical) {
        case ResizingMode.FIXED:
          obj2.height = Length.px(item.screenHeight);
          break;
        case ResizingMode.HUG_CONTENT:
          obj2["min-height"] = Length.px(item.screenHeight);
          break;
      }
    }
    if (item.isInDefault()) {
      obj2.width = Length.px(item.screenWidth);
      obj2.height = Length.px(item.screenHeight);
    }
    if (item.isInFlex()) {
      const direction2 = item.parent.flexDirection;
      if (direction2 === FlexDirection.ROW || direction2 === FlexDirection.ROW_REVERSE) {
        obj2.width = Length.px(item.screenWidth);
        obj2.height = Length.px(item.screenHeight);
        if (item.parent["align-items"] === AlignItems.STRETCH) {
          obj2.height = "auto";
        }
        if (item.resizingVertical === ResizingMode.FILL_CONTAINER) {
          obj2.height = "auto";
          obj2["align-self"] = AlignItems.STRETCH;
        }
      } else {
        obj2.width = Length.px(item.screenWidth);
        obj2.height = Length.px(item.screenHeight);
        if (item.parent["align-items"] === AlignItems.STRETCH) {
          obj2.width = "auto";
        }
        if (item.resizingHorizontal === ResizingMode.FILL_CONTAINER) {
          obj2.width = "auto";
          obj2["align-self"] = AlignItems.STRETCH;
        }
      }
    }
    if (item.isInGrid()) {
      obj2.width = "auto";
      obj2.height = "auto";
    }
    return obj2;
  }
  toDefaultCSS(item) {
    let obj2 = {};
    if (item.isAbsolute) {
      obj2.left = Length.px(item.x);
      obj2.top = Length.px(item.y);
    }
    let result = {
      "box-sizing": "border-box"
    };
    result = Object.assign(result, obj2);
    result = Object.assign(result, {
      "background-color": item.backgroundColor,
      color: item.color,
      "font-size": item.fontSize,
      "font-weight": item.fontWeight,
      "font-style": item.fontStyle,
      "font-family": item.fontFamily,
      "text-align": item.textAlign,
      "text-decoration": item.textDecoration,
      "text-transform": item.textTransform,
      "letter-spacing": item.letterSpacing,
      "word-spacing": item.wordSpacing,
      "line-height": item.lineHeight,
      "text-indent": item.textIndent,
      "text-shadow": item.textShadow,
      "text-overflow": item.textOverflow,
      "text-wrap": item.textWrap,
      position: item.position,
      overflow: item.overflow,
      "z-index": item.zIndex,
      opacity: item.opacity,
      "mix-blend-mode": item.mixBlendMode,
      "transform-origin": item.transformOrigin,
      "border-radius": item.borderRadius,
      filter: item.filter,
      "backdrop-filter": item.backdropFilter,
      "box-shadow": item.boxShadow,
      animation: item.animation,
      transition: item.transition
    });
    return result;
  }
  toVariableCSS(item) {
    const v = item.computed("variable", (v2) => {
      let obj2 = {};
      v2.split(";").filter((it) => it.trim()).forEach((it) => {
        const [key, value] = it.split(":");
        obj2[`--${key}`] = value;
      });
      return obj2;
    });
    return v;
  }
  toRootVariableCSS(item) {
    let obj2 = {};
    item.rootVariable.split(";").filter((it) => it.trim()).forEach((it) => {
      const [key, value] = it.split(":");
      obj2[`--${key}`] = value;
    });
    return obj2;
  }
  toRootVariableString(item) {
    return CSS_TO_STRING(this.toRootVariableCSS(item));
  }
  toWebkitCSS(item) {
    var results = {};
    WEBKIT_ATTRIBUTE_FOR_CSS.forEach((key) => {
      results[`-webkit-${key}`] = item.get(key);
    });
    return results;
  }
  toTextClipCSS(item) {
    let results = {};
    if (item.textClip === "text") {
      results["-webkit-background-clip"] = "text";
      results["-webkit-text-fill-color"] = "transparent";
      results["color"] = "transparent";
    }
    return results;
  }
  toTransformCSS(item) {
    const results = {
      transform: item.transform
    };
    if (results.transform === "rotateZ(0deg)") {
      delete results.transform;
    }
    return {
      transform: results.transform
    };
  }
  toDefInnerString(item) {
    return `
      ${this.toClipPath(item)}
      ${this.toSVGFilter(item)}
    `.trim();
  }
  toClipPath(item) {
    if (item.clipPath === "")
      return "";
    if (!item.cacheClipPathObject) {
      item.setClipPathCache();
    }
    var obj2 = item.cacheClipPathObject;
    var value = obj2.value;
    switch (obj2.type) {
      case "path":
        return `<clipPath id="${this.clipPathId(item)}"><path d="${item.clipPathString}" /></clipPath>`;
      case "svg":
        return `<clipPath id="${this.clipPathId(item)}">${value}</clipPath>`;
    }
    return ``;
  }
  toClipPathCSS(item) {
    let str = item.clipPath;
    if (Boolean(str) === false) {
      return null;
    }
    if (!item.cacheClipPathObject) {
      item.setClipPathCache();
    }
    var obj2 = item.cacheClipPathObject;
    switch (obj2.type) {
      case "path":
        if (obj2.value) {
          str = `url(#${this.clipPathId(item)})`;
        }
        break;
      case "svg":
        str = `url(#${this.clipPathId(item)})`;
        break;
    }
    return {
      "clip-path": str
    };
  }
  innerSVGId(item) {
    return item.id + "inner-svg";
  }
  booleanId(item) {
    return item.id + "boolean";
  }
  clipPathId(item) {
    return item.id + "clip-path";
  }
  toDefString(item) {
    var str = this.toDefInnerString(item).trim();
    return str ? `
    <svg class='inner-svg-element' style="display:block" data-id="${this.innerSVGId(item)}" width="0" height="0">
      <defs>
        ${str}
      </defs>
    </svg>
    ` : "";
  }
  toSelectorString(item, prefix = "") {
    var _a;
    return (_a = item.selectors) == null ? void 0 : _a.map((selector2) => selector2.toString(prefix)).join("\n\n");
  }
  generateView(item, prefix = "", appendCSS = "") {
    var cssString = `
  ${prefix} {  /* ${item.itemType} */
      ${CSS_TO_STRING(this.toCSS(item), "\n    ")}; 
      ${appendCSS}
  }
  ${this.toNestedCSS(item).map((it) => {
      return `${prefix} ${it.selector} { 
        ${it.cssText ? it.cssText : CSS_TO_STRING(it.css || {}, "\n		")}; 
    }`;
    }).join("\n")}
  ${this.toSelectorString(item, prefix)}
    `;
    return cssString;
  }
  toCSS(item) {
    return valueFilter(Object.assign({}, this.toVariableCSS(item), this.toDefaultCSS(item), this.toClipPathCSS(item), this.toWebkitCSS(item), this.toTextClipCSS(item), this.toBoxModelCSS(item), this.toBorderCSS(item), this.toBackgroundImageCSS(item), this.toLayoutCSS(item), this.toSizeCSS(item), this.toTransformCSS(item), this.toLayoutItemCSS(item)));
  }
  toStyleCode(item, renderer) {
    const cssString = this.generateView(item, `[data-renderer-id='${renderer.id}'] .element-item[data-id='${item.id}']`);
    return cssString;
  }
  toStyle(item, renderer) {
    const cssString = this.generateView(item, `[data-renderer-id='${renderer.id}'] .element-item[data-id='${item.id}']`);
    return `
<style type='text/css' data-renderer-type="html" data-id='${item.id}'>
${cssString}
</style>
    ` + item.layers.map((it) => {
      return renderer.toStyle(it, renderer);
    }).join("");
  }
  toStyleData(item, renderer) {
    const cssString = this.generateView(item, `[data-renderer-id='${renderer.id}'] .element-item[data-id='${item.id}']`);
    return {
      styleTag: `<style type='text/css' data-renderer-type="html" data-id='${item.id}'>${cssString}</style>`,
      cssString
    };
  }
  toExportStyle(item, renderer) {
    const cssString = this.generateView(item, `.element-item[data-id='${item.id}']`);
    return `
<style type='text/css' data-renderer-type="html" data-id='${item.id}' data-timestamp='${item.timestamp}'>
${cssString}
</style>
    ` + item.layers.map((it) => {
      return renderer.toExportStyle(it, renderer);
    }).join("");
  }
  render(item, renderer) {
    var { elementType, id, name, itemType, isBooleanItem } = item;
    const tagName = elementType || "div";
    return `<${tagName} class="element-item ${itemType}" data-is-boolean-item="${isBooleanItem}" data-id="${id}" data-title="${name}">${this.toDefString(item)}${item.layers.map((it) => {
      return renderer.render(it, renderer);
    }).join("")}</${tagName}>`;
  }
  toSVGFilter(item) {
    if (item.svgfilters.length === 0)
      return "";
    var filterString = item.computedValue("svgfilters");
    if (item.hasChangedField("svgfilters") || !filterString) {
      filterString = item.computed("svgfilters", (svgfilters) => {
        var filterString2 = svgfilters.map((svgfilter) => {
          return `
              <filter id='${svgfilter.id}'>
                ${svgfilter.filters.map((filter2) => SVGFilter.parse(filter2)).join("\n")}
              </filter>`;
        }).join("");
        return filterString2;
      }, true);
    }
    return filterString;
  }
  renderSVG() {
  }
  toNestedCSS() {
    const result = [];
    return result;
  }
  updateStyle(item) {
    if (item.hasCache("style")) {
      const styleText = this.toStyleData(item, item.manager.editor.html).cssString;
      if (item.hasCache("styleText")) {
        if (item.getCache("styleText") === styleText) {
          return;
        }
      }
      item.addCache("styleText", styleText);
      item.getCache("style").text(styleText);
    } else {
      const style = Dom.createByHTML(this.toStyleData(item, item.manager.editor.html).styleTag);
      item.addCache("style", style);
      document.head.appendChild(style.el);
    }
  }
  update(item, currentElement) {
    if (!currentElement)
      return;
    this.updateStyle(item);
    let $svg = currentElement.el.$svg;
    if (!$svg) {
      currentElement.el.$svg = currentElement.$(`[data-id="${this.innerSVGId(item)}"]`);
      $svg = currentElement.el.$svg;
      currentElement.el.$booleanSvg = currentElement.$(`[data-id="${this.booleanId(item)}"]`);
    }
    if (currentElement.data("is-boolean-item") !== `${item.isBooleanItem}`) {
      currentElement.attr("data-is-boolean-item", item.isBooleanItem);
    }
    if ($svg) {
      const defString = this.toDefInnerString(item);
      if (defString) {
        var $defs = $svg.$("defs");
        $defs.updateSVGDiff(`<defs>${defString}</defs>`);
      }
    } else {
      const defString = this.toDefString(item);
      if (defString) {
        var a = Dom.createByHTML(defString);
        if (a) {
          currentElement.prepend(a);
        }
      }
    }
  }
}
class ArtBoardRender$2 extends DomRender$1 {
  render(item, renderer) {
    var { id } = item;
    return `<div class="element-item artboard" data-id="${id}">${this.toDefString(item)}${item.layers.map((it) => {
      return renderer.render(it, renderer);
    }).join("\n	")}</div>`;
  }
  toBorderCSS() {
    return {};
  }
}
class LayerRender$1 extends DomRender$1 {
}
class SVGItemRender$2 extends LayerRender$1 {
  update(item, currentElement) {
    this.updateElementCache(item, currentElement);
    super.update(item, currentElement);
  }
  updateElementCache(item, currentElement) {
    if (item.getCache("element") !== currentElement) {
      item.addCache("element", currentElement);
      const $path = currentElement.$("path");
      item.addCache("svgElement", $path.parent().el);
      item.addCache("pathElement", $path.el);
    }
  }
  updateDefString(item, currentElement) {
    var $defs = currentElement.$("defs");
    if ($defs) {
      $defs.updateSVGDiff(`<defs>${this.toDefInnerString(item)}</defs>`);
    } else {
      var str = this.toDefString(item).trim();
      currentElement.prepend(Dom.createByHTML(str));
    }
  }
  toDefInnerString(item) {
    return `
            ${this.toFillSVG(item)}
            ${this.toStrokeSVG(item)}
        `;
  }
  fillId(item) {
    return this.getInnerId(item, "fill");
  }
  strokeId(item) {
    return this.getInnerId(item, "stroke");
  }
  cachedStroke(item) {
    return item.computed("stroke", (value) => {
      if (item.isBooleanItem) {
        return SVGFill.parseImage("transparent");
      } else {
        return SVGFill.parseImage(value || "black");
      }
    });
  }
  cachedFill(item) {
    return item.computed("fill", (value) => {
      if (item.isBooleanItem) {
        return SVGFill.parseImage("transparent");
      } else {
        return SVGFill.parseImage(value || "black");
      }
    });
  }
  toFillSVG(item) {
    var _a;
    const fillValue = this.cachedFill(item);
    return (_a = fillValue == null ? void 0 : fillValue.toSVGString) == null ? void 0 : _a.call(fillValue, this.fillId(item), item.contentBox);
  }
  toStrokeSVG(item) {
    var _a;
    const strokeValue = this.cachedStroke(item);
    return (_a = strokeValue == null ? void 0 : strokeValue.toSVGString) == null ? void 0 : _a.call(strokeValue, this.strokeId(item), item.contentBox);
  }
  toFillValue(item) {
    var _a;
    const fillValue = this.cachedFill(item);
    return (_a = fillValue == null ? void 0 : fillValue.toFillValue) == null ? void 0 : _a.call(fillValue, this.fillId(item));
  }
  toFillOpacityValue(item) {
    return parse(item.fill || "transparent").a;
  }
  toStrokeValue(item) {
    var _a;
    const strokeValue = this.cachedStroke(item);
    return (_a = strokeValue == null ? void 0 : strokeValue.toFillValue) == null ? void 0 : _a.call(strokeValue, this.strokeId(item));
  }
  toFilterValue(item) {
    if (!item.svgfilter) {
      return "";
    }
    return `url(#${item.svgfilter})`;
  }
  toLayoutCSS() {
    return {};
  }
  toDefaultCSS(item) {
    var _a;
    return Object.assign({}, super.toDefaultCSS(item), this.toKeyListCSS(item, [
      "stroke-width",
      "stroke-linecap",
      "stroke-linejoin",
      "stroke-dashoffset",
      "fill-opacity",
      "fill-rule",
      "text-anchor"
    ]), {
      "stroke-dasharray": (_a = item.strokeDasharray) == null ? void 0 : _a.join(" ")
    });
  }
  toSVGAttribute(item) {
    return this.toDefaultCSS(item);
  }
}
class BooleanPathRender$2 extends SVGItemRender$2 {
  toFillSVG(item) {
    const layers2 = item.layers;
    const op = item.booleanOperation;
    switch (op) {
      case BooleanOperation.DIFFERENCE:
        return SVGFill.parseImage(layers2[1].fill || "transparent").toSVGString(this.fillId(item));
    }
    return SVGFill.parseImage(layers2[0].fill || "transparent").toSVGString(this.fillId(item));
  }
  toStrokeSVG(item) {
    const layers2 = item.layers;
    const op = item.booleanOperation;
    switch (op) {
      case BooleanOperation.DIFFERENCE:
        return SVGFill.parseImage(layers2[1].stroke || "transparent").toSVGString(this.strokeId(item));
    }
    return SVGFill.parseImage(layers2[0].stroke || "black").toSVGString(this.strokeId(item));
  }
  toFillValue(item) {
    var _a, _b;
    const layers2 = item.layers;
    const op = item.booleanOperation;
    switch (op) {
      case BooleanOperation.DIFFERENCE:
        return SVGFill.parseImage(layers2[1].fill || "transparent").toSVGString(this.fillId(item));
    }
    return (_b = (_a = SVGFill.parseImage(layers2[0].fill || "transparent")).toFillValue) == null ? void 0 : _b.call(_a, this.fillId(item));
  }
  toFillOpacityValue(item) {
    return parse(item.fill || "transparent").a;
  }
  toStrokeValue(item) {
    var _a, _b, _c, _d;
    const layers2 = item.layers;
    const op = item.booleanOperation;
    switch (op) {
      case BooleanOperation.DIFFERENCE:
        return (_b = (_a = SVGFill.parseImage(layers2[1].stroke || "transparent")).toFillValue) == null ? void 0 : _b.call(_a, this.strokeId(item));
    }
    return (_d = (_c = SVGFill.parseImage(layers2[0].stroke || "black")).toFillValue) == null ? void 0 : _d.call(_c, this.strokeId(item));
  }
  update(item, currentElement) {
    if (!currentElement)
      return;
    const $path = currentElement.$(`[data-boolean-path-id="${item.id}"]`);
    if ($path) {
      if (item.hasChangedField("changedChildren", "d", "boolean-operation", "width", "height")) {
        $path.setAttrNS({
          d: item.d
        });
      }
      if (item.hasChangedField("fill")) {
        $path.setAttrNS({
          fill: this.toFillValue(item)
        });
      }
      if (item.hasChangedField("stroke")) {
        $path.setAttrNS({
          stroke: this.toStrokeValue(item)
        });
      }
      if (item.hasChangedField("filter")) {
        $path.setAttrNS({
          filter: this.toFilterValue(item)
        });
      }
      if (item.hasChangedField("fill-rule")) {
        $path.setAttrNS({
          "fill-rule": item.fillRule || "nonezero"
        });
      }
      if (item.hasChangedField("stroke-linejoin")) {
        $path.setAttrNS({
          "stroke-linejoin": item.strokeLinejoin
        });
      }
      if (item.hasChangedField("stroke-linecap")) {
        $path.setAttrNS({
          "stroke-linecap": item.strokeLinecap
        });
      }
    }
    super.update(item, currentElement);
  }
  updateElementCache(item, currentElement) {
    if (item.getCache("element") !== currentElement) {
      item.addCache("element", currentElement);
      const $path = currentElement.$(`[data-boolean-path-id="${item.id}"]`);
      item.addCache("svgElement", $path.parent().el);
      item.addCache("pathElement", $path.el);
    }
  }
  render(item, renderer) {
    var { id, name, itemType } = item;
    return `    
<div class="element-item ${itemType}" data-id="${id}" data-title="${name}">
  ${this.toDefString(item)}
  ${item.layers.map((it) => {
      return renderer.render(it, renderer);
    }).join("")}
  <svg xmlns="http://www.w3.org/2000/svg" class="boolean-path-item" width="100%" height="100%" overflow="visible">
    <path 
      class="svg-path-item"
      d="${item.d}"
      data-boolean-path-id="${id}" 
      fill-rule="${item.fillRule}"
      filter="${this.toFilterValue(item)}"
      fill="${this.toFillValue(item)}"
      stroke="${this.toStrokeValue(item)}"
      stroke-linejoin="${item.strokeLinejoin}"
      stroke-linecap="${item.strokeLinecap}"
    />
  </svg>
</div>
    `;
  }
}
class CircleRender$2 extends LayerRender$1 {
}
class ImageRender$2 extends LayerRender$1 {
  toNestedCSS() {
    return [
      {
        selector: "img",
        cssText: `
                width: 100%;
                height: 100%;
                pointer-events: none;
                `.trim()
      }
    ];
  }
  getUrl(item) {
    var { src } = item;
    var project2 = item.project;
    return project2.getImageValueById(src) || src;
  }
  render(item) {
    var { id } = item;
    return `
          <div class='element-item image' data-id="${id}">
            ${this.toDefString(item)}
            <img src='${this.getUrl(item)}' />
          </div>`;
  }
  update(item, currentElement) {
    const $image = currentElement.$("img");
    if ($image) {
      $image.attr("src", this.getUrl(item));
    }
    super.update(item, currentElement);
  }
}
class ProjectRender$2 extends DomRender$1 {
  toRootVariableCSS(item) {
    let obj2 = {};
    item.rootVariable.split(";").filter((it) => it.trim()).forEach((it) => {
      var [key, value] = it.split(":");
      obj2[`--${key}`] = value;
    });
    return obj2;
  }
  toCSS(item) {
    return Object.assign({}, this.toRootVariableCSS(item));
  }
  toStyle(item) {
    const keyframeString = item.toKeyframeString();
    const rootVariable = this.toRootVariableCSS(item);
    return `
<style type='text/css' data-renderer-type="html" data-id='${item.id}'>
    :root {
        ${CSS_TO_STRING(rootVariable)}
    }
    /* keyframe */
    ${keyframeString}
</style>
        `;
  }
  toExportStyle(item) {
    const keyframeString = item.toKeyframeString();
    const rootVariable = this.toRootVariableCSS(item);
    return `
<style type='text/css' data-renderer-type="html" data-id='${item.id}'>
    :root {
        ${CSS_TO_STRING(rootVariable)}
    }
    /* keyframe */
    ${keyframeString}
</style>
        `;
  }
  render(item, renderer) {
    return item.layers.map((it) => {
      return renderer.render(it);
    }).join("");
  }
  renderSVG() {
    return "";
  }
}
class RectRender$2 extends LayerRender$1 {
}
class SVGPathRender$2 extends SVGItemRender$2 {
  update(item, currentElement) {
    if (!currentElement)
      return;
    const $path = currentElement.$("path");
    if ($path) {
      if (item.hasChangedField("width", "height", "d")) {
        $path.setAttrNS({
          d: item.d
        });
      }
      if (item.hasChangedField("fill")) {
        $path.setAttrNS({
          fill: this.toFillValue(item)
        });
      }
      if (item.hasChangedField("stroke")) {
        $path.setAttrNS({
          stroke: this.toStrokeValue(item)
        });
      }
      if (item.hasChangedField("filter")) {
        $path.setAttrNS({
          filter: this.toFilterValue(item)
        });
      }
      if (item.hasChangedField("fill-rule")) {
        $path.setAttrNS({
          "fill-rule": item.fillRule || "nonezero"
        });
      }
      if (item.hasChangedField("stroke-linejoin")) {
        $path.setAttrNS({
          "stroke-linejoin": item.strokeLinejoin
        });
      }
      if (item.hasChangedField("stroke-linecap")) {
        $path.setAttrNS({
          "stroke-linecap": item.strokeLinecap
        });
      }
      if (item.hasChangedField("stroke-dasharray")) {
        $path.setAttrNS({
          "stroke-dasharray": item.strokeDasharray.join(" ")
        });
      }
    }
    super.update(item, currentElement);
  }
  render(item) {
    var { id, name, itemType } = item;
    return `    
<div class="element-item ${itemType}" data-id="${id}" data-title="${name}">
  ${this.toDefString(item)}
  <svg xmlns="http://www.w3.org/2000/svg" class="view-path-item" width="100%" height="100%" overflow="visible">
    <path 
      class="svg-path-item"
      d="${item.d}"
      fill-rule="${item.fillRule}"
      filter="${this.toFilterValue(item)}"
      fill="${this.toFillValue(item)}"
      stroke="${this.toStrokeValue(item)}"
      stroke-linejoin="${item.strokeLinejoin}"
      stroke-linecap="${item.strokeLinecap}"
      stroke-dasharray="${item.strokeDasharray.join(" ")}"
    />
  </svg>
</div>
    `;
  }
}
class SplineRender$2 extends SVGPathRender$2 {
  update(item, currentElement) {
    if (!currentElement)
      return;
    var $path = currentElement.$("path");
    if ($path) {
      if (item.hasChangedField("points", "boundary")) {
        $path.setAttrNS({
          d: item.d
        });
      }
    }
    super.update(item, currentElement);
  }
}
class SVGPolygonRender$2 extends SVGItemRender$2 {
  update(item, currentElement) {
    if (!currentElement)
      return;
    var $path = currentElement.$("path");
    if ($path) {
      if (item.hasChangedField("width", "height", "count")) {
        $path.setAttrNS({
          d: item.d
        });
      }
      if (item.hasChangedField("fill")) {
        $path.setAttrNS({
          fill: this.toFillValue(item)
        });
      }
      if (item.hasChangedField("stroke")) {
        $path.setAttrNS({
          stroke: this.toStrokeValue(item)
        });
      }
      if (item.hasChangedField("filter")) {
        $path.setAttrNS({
          filter: this.toFilterValue(item)
        });
      }
      if (item.hasChangedField("fill-rule")) {
        $path.setAttrNS({
          "fill-rule": item.fillRule || "nonezero"
        });
      }
      if (item.hasChangedField("stroke-linejoin")) {
        $path.setAttrNS({
          "stroke-linejoin": item.strokeLinejoin
        });
      }
      if (item.hasChangedField("stroke-linecap")) {
        $path.setAttrNS({
          "stroke-linecap": item.strokeLinecap
        });
      }
    }
    super.update(item, currentElement);
  }
  render(item) {
    var { id, name, itemType } = item;
    return `    
<div class="element-item ${itemType}" data-id="${id}" data-title="${name}">
  ${this.toDefString(item)}
  <svg xmlns="http://www.w3.org/2000/svg" class="view-path-item" width="100%" height="100%" overflow="visible">
    <path 
      class="svg-path-item"
      d="${item.d}"
      fill-rule="${item.fillRule}"
      filter="${this.toFilterValue(item)}"
      fill="${this.toFillValue(item)}"
      stroke="${this.toStrokeValue(item)}"
      stroke-linejoin="${item.strokeLinejoin}"
      stroke-linecap="${item.strokeLinecap}"
    />
  </svg>
</div>
    `;
  }
}
class SVGStarRender$2 extends SVGItemRender$2 {
  update(item, currentElement) {
    if (!currentElement)
      return;
    var $path = currentElement.$("path");
    if ($path) {
      if (item.hasChangedField("width", "height", "count", "radius", "isCurve", "tension")) {
        $path.setAttrNS({
          d: item.d
        });
      }
      if (item.hasChangedField("fill")) {
        $path.setAttrNS({
          fill: this.toFillValue(item)
        });
      }
      if (item.hasChangedField("stroke")) {
        $path.setAttrNS({
          stroke: this.toStrokeValue(item)
        });
      }
      if (item.hasChangedField("filter")) {
        $path.setAttrNS({
          filter: this.toFilterValue(item)
        });
      }
      if (item.hasChangedField("fill-rule")) {
        $path.setAttrNS({
          "fill-rule": item.fillRule || "nonezero"
        });
      }
      if (item.hasChangedField("stroke-linejoin")) {
        $path.setAttrNS({
          "stroke-linejoin": item.strokeLinejoin
        });
      }
      if (item.hasChangedField("stroke-linecap")) {
        $path.setAttrNS({
          "stroke-linecap": item.strokeLinecap
        });
      }
    }
    super.update(item, currentElement);
  }
  render(item) {
    var { id, name, itemType } = item;
    return `    
<div class="element-item ${itemType}" data-id="${id}" data-title="${name}">
  ${this.toDefString(item)}
  <svg xmlns="http://www.w3.org/2000/svg" class="view-path-item" width="100%" height="100%" overflow="visible">
    <path 
      class="svg-path-item"
      d="${item.d}"
      fill-rule="${item.fillRule}"
      filter="${this.toFilterValue(item)}"
      fill="${this.toFillValue(item)}"
      stroke="${this.toStrokeValue(item)}"
      stroke-linejoin="${item.strokeLinejoin}"
      stroke-linecap="${item.strokeLinecap}"
    />
  </svg>
</div>
    `;
  }
}
class SVGTextPathRender$2 extends SVGItemRender$2 {
  update(item, currentElement) {
    var $path = currentElement.$("path.svg-path-item");
    if ($path) {
      if (item.hasChangedField("width", "height", "d")) {
        $path.attr("d", item.d);
      }
    }
    var $guidePath = currentElement.$("path.guide");
    if ($guidePath) {
      if (item.hasChangedField("width", "height", "d")) {
        $guidePath.attr("d", item.d);
      }
    }
    var $textPath = currentElement.$("textPath");
    if ($textPath) {
      if (item.hasChangedField("text")) {
        $textPath.text(item.text);
      }
      if (item.hasChangedField("textLength", "lengthAdjust", "startOffset")) {
        $textPath.setAttrNS({
          textLength: item.textLength,
          lengthAdjust: item.lengthAdjust,
          startOffset: item.startOffset
        });
      }
      if (item.hasChangedField("fill")) {
        $textPath.setAttrNS({
          fill: this.toFillValue(item)
        });
      }
      if (item.hasChangedField("stroke")) {
        $textPath.setAttrNS({
          stroke: this.toStrokeValue(item)
        });
      }
      if (item.hasChangedField("filter")) {
        $textPath.setAttrNS({
          filter: this.toFilterValue(item)
        });
      }
    }
    super.update(item, currentElement);
    item.totalLength = $path.totalLength;
  }
  toDefInnerString(item) {
    return `
        ${this.toPathSVG(item)}
        ${this.toFillSVG(item)}
        ${this.toStrokeSVG(item)}
    `;
  }
  toPathId(item) {
    return this.getInnerId(item, "path");
  }
  toPathSVG(item) {
    return `
    <path class="svg-path-item" id="${this.toPathId(item)}" d="${item.d}" fill="none" />
    `;
  }
  render(item) {
    var { id, textLength, lengthAdjust, startOffset } = item;
    const pathId = `#${this.toPathId(item)}`;
    return `
      <svg class='element-item textpath' data-id="${id}">
        ${this.toDefString(item)}
        <text class="svg-textpath-item">
          <textPath 
            xlink:href="${pathId}"
            textLength="${textLength}"
            lengthAdjust="${lengthAdjust}"
            startOffset="${startOffset}"
          >${item.text}</textPath>
          <use href="${pathId}" stroke-width="1" stroke="black" />
        </text>
        <path class="guide" d="${item.d}" stroke="rgba(0, 0, 0, 0.5)" fill="none"/>
      </svg>
    `;
  }
}
class SVGTextRender$2 extends SVGItemRender$2 {
  update(item, currentElement) {
    var $text = currentElement.$("text");
    if ($text) {
      if (item.hasChangedField("text")) {
        $text.text(item.text);
      }
      if (item.hasChangedField("textLength", "lengthAdjust", "startOffset")) {
        $text.setAttrNS({
          textLength: item.textLength,
          lengthAdjust: item.lengthAdjust,
          startOffset: item.startOffset
        });
      }
      if (item.hasChangedField("fill")) {
        $text.setAttrNS({
          fill: this.toFillValue(item)
        });
      }
      if (item.hasChangedField("stroke")) {
        $text.setAttrNS({
          stroke: this.toStrokeValue(item)
        });
      }
      if (item.hasChangedField("filter")) {
        $text.setAttrNS({
          filter: this.toFilterValue(item)
        });
      }
    }
    super.update(item, currentElement);
  }
  shapeInsideId(item) {
    return this.getInnerId(item, "shape-inside");
  }
  render(item) {
    var { id, textLength, lengthAdjust } = item;
    return `
  <svg class='element-item textpath' data-id="${id}">
    ${this.toDefString(item)}
      <text class="svg-text-item" textLength="${textLength}" lengthAdjust="${lengthAdjust}">${item.text}</text>
  </svg>`;
  }
}
class DomTemplateEngine {
  static compile(template, params = []) {
    return template;
  }
}
const EngineList = {
  dom: DomTemplateEngine
};
class TemplateEngine {
  static compile(engine, template, params = []) {
    const currentEngine = EngineList[engine] || EngineList["dom"];
    return currentEngine.compile(template, params);
  }
}
class TemplateRender$2 extends LayerRender$1 {
  update(item, currentElement) {
    if (item.hasChangedField("x", "y", "width", "height") === false) {
      const compiledTemplate = this.compile(item);
      let $innerHTML = currentElement.$(".inner-html");
      if ($innerHTML) {
        $innerHTML.updateDiff(compiledTemplate);
      }
    }
    super.update(item, currentElement);
  }
  compile(item) {
    return TemplateEngine.compile("dom", item.template, item.params);
  }
  render(item) {
    var { id } = item;
    const compiledTemplate = this.compile(item);
    return `
      <div class='element-item template' data-id="${id}">
        ${this.toDefString(item)}
        <style id="style-${id}">
          [data-id="${id}"] .inner-html {
            width: 100%; 
            height: 100%;
            position:relative;
            display:block;
            pointer-events: none; 
          }

          [data-id="${id}"] .inner-html > * {
            width: 100%; 
            height: 100%;
          }          
        </style>
        <div class="inner-html" data-domdiff-pass="true">
          ${compiledTemplate}
        </div>
      </div>`;
  }
}
class TextRender$2 extends LayerRender$1 {
  toCSS(item) {
    let css = super.toCSS(item);
    css.margin = css.margin || "0px";
    if (item.overflow !== Overflow.SCROLL) {
      css.height = "auto";
    }
    return css;
  }
  update(item, currentElement) {
    const $textElement = currentElement.$(`.text-content`);
    if ($textElement) {
      var { content: content2 } = item;
      $textElement.updateDiff(content2);
    }
    super.update(item, currentElement);
  }
  render(item) {
    var { id, content: content2 } = item;
    return `
            <div class='element-item text' data-id="${id}">
                ${this.toDefString(item)}
                <div class="text-content" tabIndex="-1" data-id="${id}">${content2}</div>
            </div>
        `;
  }
}
class VideoRender$2 extends LayerRender$1 {
  toNestedCSS() {
    return [
      {
        selector: "video",
        cssText: `
                width: 100%;
                height: 100%;
                pointer-events: none;
                `.trim()
      }
    ];
  }
  getUrl(item) {
    var { src } = item;
    var project2 = item.project;
    return project2.getVideoValueById(src);
  }
  render(item) {
    var { id, controls, muted, poster, loop, crossorigin, autoplay } = item;
    return `
        <div class='element-item video' data-id="${id}">
            ${this.toDefString(item)}
            <video 
                controls="${controls}"
                src="${this.getUrl(item)}
                muted="${muted}"
                poster="${poster}"
                loop="${loop}"
                crossorigin="${crossorigin}"
                autoplay="${autoplay}"
            >
                Sorry, your browser doesn't support embedded videos.
            </video>
        </div>`;
  }
  update(item, currentElement) {
    const { currentTime, playbackRate, volume } = item;
    const $video = currentElement.$("video");
    if ($video) {
      $video.setProp({
        currentTime,
        playbackRate,
        volume
      });
    }
    super.update(item, currentElement);
  }
}
function rendererHtml(editor) {
  editor.registerRendererType("html", new HTMLRenderer(editor));
  editor.registerRenderer("html", "project", new ProjectRender$2());
  editor.registerRenderer("html", "artboard", new ArtBoardRender$2());
  editor.registerRenderer("html", "rect", new RectRender$2());
  editor.registerRenderer("html", "circle", new CircleRender$2());
  editor.registerRenderer("html", "image", new ImageRender$2());
  editor.registerRenderer("html", "text", new TextRender$2());
  editor.registerRenderer("html", "video", new VideoRender$2());
  editor.registerRenderer("html", "boolean-path", new BooleanPathRender$2());
  editor.registerRenderer("html", "svg-path", new SVGPathRender$2());
  editor.registerRenderer("html", "polygon", new SVGPolygonRender$2());
  editor.registerRenderer("html", "star", new SVGStarRender$2());
  editor.registerRenderer("html", "spline", new SplineRender$2());
  editor.registerRenderer("html", "svg-text", new SVGTextRender$2());
  editor.registerRenderer("html", "svg-textpath", new SVGTextPathRender$2());
  editor.registerRenderer("html", "template", new TemplateRender$2());
}
class JSONRenderer {
  constructor(editor) {
    this.editor = editor;
  }
  getDefaultRendererInstance() {
    return this.editor.getRendererInstance("json", "rect");
  }
  getRendererInstance(item) {
    return this.editor.getRendererInstance("json", item.itemType) || this.getDefaultRendererInstance() || item;
  }
  async render(item, renderer) {
    if (!item)
      return;
    const currentRenderer = this.getRendererInstance(item);
    if (currentRenderer) {
      return await currentRenderer.render(item, renderer || this);
    }
  }
  async renderAll(items, renderer) {
    return await Promise.all(items.map(async (it) => {
      return await this.render(it, renderer);
    }));
  }
  async getResourceDataURI() {
  }
}
class ItemRender {
  async render(item, renderer) {
    return await this.toCloneObject(item, renderer);
  }
  async toCloneObject(item, renderer) {
    var json = item.attrs("itemType", "name", "elementType", "type", "visible", "lock", "selected");
    if (item.parent && item.parent.isNot("project")) {
      json.parentId = item.parentId;
    }
    json.referenceId = item.id;
    json.newTargetId = uuid();
    let layers2 = [];
    for (var i = 0, len2 = item.layers.length; i < len2; i++) {
      layers2.push(await renderer.render(item.layers[i], renderer));
    }
    json.layers = layers2;
    return json;
  }
}
class BaseAssetRender extends ItemRender {
  async toCloneObject(item, renderer) {
    return __spreadValues(__spreadValues({}, await super.toCloneObject(item, renderer)), item.attrs("svgfilters", "keyframes"));
  }
}
class GroupRender extends BaseAssetRender {
  async toCloneObject(item, renderer) {
    return __spreadValues(__spreadValues({}, await super.toCloneObject(item, renderer)), item.attrs("layout", "constraintsHorizontal", "constraintsVertical", "resizingMode", "flexDirection", "flexWrap", "flexFlow", "justifyContent", "alignItems", "alignContent", "order", "flexBasis", "flexGrow", "flexShrink", "gap", "gridTemplateRows", "gridTemplateColumns", "gridTemplateAreas", "gridAutoRows", "gridAutoColumns", "gridAutoFlow", "gridColumnStart", "gridColumnEnd", "gridRowStart", "gridRowEnd", "gridColumnGap", "gridRowGap", "animation", "transition", "paddingTop", "paddingRight", "paddingLeft", "paddingBottom"));
  }
}
class MovableRender extends GroupRender {
  async toCloneObject(item, renderer) {
    return __spreadValues(__spreadValues({}, await super.toCloneObject(item, renderer)), item.attrs("x", "y", "right", "bottom", "width", "height", "angle", "transformOrigin"));
  }
}
class DomRender extends MovableRender {
  async toCloneObject(item, renderer) {
    return __spreadProps(__spreadValues(__spreadValues({}, await super.toCloneObject(item, renderer)), item.attrs("position", "rootVariable", "variable", "filter", "backdropFilter", "backgroundColor", "backgroundImage", "textClip", "borderRadius", "border", "boxShadow", "textShadow", "clipPath", "color", "fontSize", "lineHeight", "textAlign", "textTransform", "textDecoration", "letterSpacing", "wordSpacing", "textIndent", "perspectiveOrigin", "transformStyle", "perspective", "mixBlendMode", "overflow", "opacity", "animation", "transition")), {
      selectors: item.selectors.map((selector2) => selector2.clone()),
      svg: item.svg.map((svg) => svg.clone())
    });
  }
}
class ArtBoardRender$1 extends DomRender {
  async toCloneObject(item, renderer) {
    return __spreadValues(__spreadValues({}, await super.toCloneObject(item, renderer)), item.attrs("name"));
  }
}
class LayerRender extends DomRender {
  async toCloneObject(item, renderer) {
    return __spreadValues(__spreadValues({}, await super.toCloneObject(item, renderer)), item.attrs("tagName"));
  }
}
class SVGItemRender$1 extends LayerRender {
  async toCloneObject(item, renderer) {
    return __spreadValues(__spreadValues({}, await super.toCloneObject(item, renderer)), item.attrs("overflow", "stroke", "stroke-width", "svgfilter", "fill", "fill-rule", "fill-opacity", "stroke-linecap", "stroke-linejoin", "stroke-dashoffset", "stroke-dasharray", "text-anchor"));
  }
}
class BooleanPathRender$1 extends SVGItemRender$1 {
  async toCloneObject(item, renderer) {
    return __spreadValues(__spreadValues({}, await super.toCloneObject(item, renderer)), item.attrs("d", "booleanOperation"));
  }
}
class CircleRender$1 extends LayerRender {
}
class IFrameRender$1 extends LayerRender {
  async toCloneObject(item, renderer) {
    return __spreadValues(__spreadValues({}, await super.toCloneObject(item, renderer)), item.attrs("src"));
  }
}
class ImageRender$1 extends LayerRender {
  async toCloneObject(item, renderer) {
    const project2 = item.project;
    const image2 = project2.imageKeys[item.src];
    const src = image2.original;
    return __spreadProps(__spreadValues({}, await super.toCloneObject(item, renderer)), {
      src
    });
  }
}
class AssetRender extends ItemRender {
  async toCloneObject(item, renderer) {
    return __spreadValues(__spreadValues({}, await super.toCloneObject(item, renderer)), item.attrs("colors", "gradients", "svgfilters", "svgimages", "images", "keyframes"));
  }
}
class TimelineRender extends AssetRender {
  async toCloneObject(item, renderer) {
    return __spreadValues(__spreadValues({}, await super.toCloneObject(item, renderer)), item.attrs("timeline"));
  }
}
class ProjectRender$1 extends TimelineRender {
  async toCloneObject(item, renderer) {
    return __spreadValues(__spreadValues({}, await super.toCloneObject(item, renderer)), item.attrs("name", "description", "rootVariable"));
  }
}
class RectRender$1 extends LayerRender {
}
class SplineRender$1 extends SVGItemRender$1 {
  async toCloneObject(item, renderer) {
    return __spreadValues(__spreadValues({}, await super.toCloneObject(item, renderer)), item.attrs("points", "boundary"));
  }
}
class SVGPathRender$1 extends SVGItemRender$1 {
  async toCloneObject(item, renderer) {
    return __spreadValues(__spreadValues({}, await super.toCloneObject(item, renderer)), item.attrs("d"));
  }
}
class SVGPolygonRender$1 extends SVGItemRender$1 {
  async toCloneObject(item, renderer) {
    return __spreadValues(__spreadValues({}, await super.toCloneObject(item, renderer)), item.attrs("count"));
  }
}
class SVGStarRender$1 extends SVGItemRender$1 {
  async toCloneObject(item, renderer) {
    return __spreadValues(__spreadValues({}, await super.toCloneObject(item, renderer)), item.attrs("count", "radius"));
  }
}
class SVGTextPathRender$1 extends SVGItemRender$1 {
  async toCloneObject(item, renderer) {
    return __spreadValues(__spreadValues({}, await super.toCloneObject(item, renderer)), item.attrs("totalLength", "d", "text", "textLength", "lengthAdjust", "startOffset"));
  }
}
class SVGTextRender$1 extends SVGItemRender$1 {
  async toCloneObject(item, renderer) {
    return __spreadValues(__spreadValues({}, await super.toCloneObject(item, renderer)), item.attrs("totalLength", "text", "textLength", "lengthAdjust", "shape-inside"));
  }
}
class TemplateRender$1 extends LayerRender {
  async toCloneObject(item, renderer) {
    return __spreadValues(__spreadValues({}, await super.toCloneObject(item, renderer)), item.attrs("engine", "template", "params"));
  }
}
class TextRender$1 extends LayerRender {
  async toCloneObject(item, renderer) {
    return __spreadValues(__spreadValues({}, await super.toCloneObject(item, renderer)), item.attrs("content"));
  }
}
class VideoRender$1 extends LayerRender {
  async toCloneObject(item, renderer) {
    return __spreadValues(__spreadValues({}, await super.toCloneObject(item, renderer)), item.attrs("src"));
  }
}
function rendererJson(editor) {
  editor.registerRendererType("json", new JSONRenderer(editor));
  editor.registerRenderer("json", "project", new ProjectRender$1());
  editor.registerRenderer("json", "artboard", new ArtBoardRender$1());
  editor.registerRenderer("json", "rect", new RectRender$1());
  editor.registerRenderer("json", "circle", new CircleRender$1());
  editor.registerRenderer("json", "image", new ImageRender$1());
  editor.registerRenderer("json", "template", new TemplateRender$1());
  editor.registerRenderer("json", "iframe", new IFrameRender$1());
  editor.registerRenderer("json", "text", new TextRender$1());
  editor.registerRenderer("json", "video", new VideoRender$1());
  editor.registerRenderer("json", "svg-path", new SVGPathRender$1());
  editor.registerRenderer("json", "boolean-path", new BooleanPathRender$1());
  editor.registerRenderer("json", "polygon", new SVGPolygonRender$1());
  editor.registerRenderer("json", "star", new SVGStarRender$1());
  editor.registerRenderer("json", "spline", new SplineRender$1());
  editor.registerRenderer("json", "svg-text", new SVGTextRender$1());
  editor.registerRenderer("json", "svg-textpath", new SVGTextPathRender$1());
}
class SVGRenderer {
  constructor(editor) {
    this.editor = editor;
  }
  getDefaultRendererInstance() {
    return this.editor.getRendererInstance("svg", "rect");
  }
  getRendererInstance(item) {
    return this.editor.getRendererInstance("svg", item.itemType) || this.getDefaultRendererInstance() || item;
  }
  render(item, renderer) {
    if (!item)
      return "";
    const currentRenderer = this.getRendererInstance(item);
    if (currentRenderer) {
      return currentRenderer.render(item, renderer || this);
    }
  }
  toCSS(item) {
    const currentRenderer = this.getRendererInstance(item);
    if (currentRenderer) {
      return currentRenderer.toCSS(item);
    }
  }
  toTransformCSS(item) {
    const currentRenderer = this.getRendererInstance(item);
    if (currentRenderer) {
      return currentRenderer.toTransformCSS(item);
    }
  }
  toStyle(item, renderer) {
    const currentRenderer = this.getRendererInstance(item);
    if (currentRenderer) {
      return currentRenderer.toStyle(item, renderer || this);
    }
  }
  update(item, currentElement) {
    const currentRenderer = this.getRendererInstance(item);
    if (currentRenderer) {
      return currentRenderer.update(item, currentElement);
    }
  }
  codeview(item) {
    if (!item) {
      return "";
    }
    let svgCode = this.render(item);
    svgCode = svgCode.replace(/</g, "&lt;").replace(/>/g, "&gt;");
    return `
<div class='svg-code'>
${svgCode && `<div><pre title='SVG'>${svgCode}</pre></div>`}
</div>
        `;
  }
}
class SVGRender extends DomRender$1 {
  toDefaultCSS(item) {
    return {
      overflow: "visible",
      "font-size": item.fontSize,
      "font-weight": item.fontWeight,
      "font-style": item.fontStyle,
      "font-family": item.fontFamily,
      "text-align": item.textAlign,
      "text-decoration": item.textDecoration,
      "text-transform": item.textTransform,
      "letter-spacing": item.letterSpacing,
      "word-spacing": item.wordSpacing,
      "line-height": item.lineHeight,
      "text-indent": item.textIndent,
      "text-shadow": item.textShadow,
      "text-overflow": item.textOverflow,
      "text-wrap": item.textWrap,
      "z-index": item.zIndex,
      opacity: item.opacity,
      "mix-blend-mode": item.mixBlendMode,
      "transform-origin": item.transformOrigin,
      "border-radius": item.borderRadius,
      filter: item.filter,
      "backdrop-filter": item.backdropFilter,
      "box-shadow": item.boxShadow,
      animation: item.animation,
      transition: item.transition
    };
  }
  toCSS(item) {
    const css = Object.assign({}, this.toVariableCSS(item), this.toDefaultCSS(item), this.toClipPathCSS(item), this.toWebkitCSS(item), this.toTextClipCSS(item), this.toTransformCSS(item), this.toLayoutItemCSS(item), this.toBorderCSS(item), this.toBackgroundImageCSS(item), this.toLayoutCSS(item));
    delete css.left;
    delete css.top;
    delete css.width;
    delete css.height;
    delete css.position;
    return css;
  }
  toSVGAttribute(item) {
    var _a;
    return __spreadProps(__spreadValues({}, this.toDefaultCSS(item)), {
      strokeWidth: item.strokeWidth,
      "fill-opacity": item.fillOpacity,
      "fill-rule": item.fillRule,
      "stroke-linecap": item.strokeLinecap,
      "stroke-linejoin": item.strokeLinejoin,
      "text-anchor": item.textAnchor,
      "stroke-dasharray": (_a = item.strokeDasharray) == null ? void 0 : _a.join(" ")
    });
  }
  wrappedRender(item, callback) {
    const { id, x, y, width: width2, height: height2, itemType } = item;
    return `

<svg class='svg-element-item ${itemType}'
    xmlns="http://www.w3.org/2000/svg"
    data-id="${id}"
    x="${x}"
    y="${y}"
    width="${width2}"
    height="${height2}"
    viewBox="0 0 ${width2} ${height2}"
    overflow="visible"
>
    ${this.toDefString(item)}
    ${isFunction(callback) && callback()}
</svg>
        `;
  }
  render(item, renderer) {
    const { width: width2, height: height2, elementType } = item;
    const tagName = elementType || "div";
    let css = this.toCSS(item);
    return this.wrappedRender(item, () => {
      return `
<foreignObject 
    width="${width2}"
    height="${height2}"
    overflow="visible"
>
    <${tagName} xmlns="http://www.w3.org/1999/xhtml" style="${CSS_TO_STRING(css)};width:100%;height:100%;"></${tagName}>
</foreignObject>    
${item.layers.map((it) => {
        return renderer.render(it, renderer);
      }).join("")}
            `;
    });
  }
}
class ArtBoardRender extends SVGRender {
  toCSS(item) {
    const css = Object.assign({}, this.toDefaultCSS(item), this.toClipPathCSS(item), this.toWebkitCSS(item), this.toTextClipCSS(item), this.toBackgroundImageCSS(item));
    delete css.left;
    delete css.top;
    delete css.width;
    delete css.height;
    delete css.position;
    return css;
  }
  render(item, renderer, encoding = true) {
    const { width: width2, height: height2 } = item;
    let css = this.toCSS(item);
    return `
${encoding ? `<?xml version="1.0"?>` : ""}
<svg 
    xmlns="http://www.w3.org/2000/svg"
    width="${width2}"
    height="${height2}"
    viewBox="0 0 ${width2} ${height2}"
    style="${CSS_TO_STRING(css)}"
>
    ${this.toDefString(item)}
    ${item.layers.map((it) => {
      return renderer.render(it, renderer);
    }).join("")}
</svg>      
        `;
  }
}
class SVGLayerRender extends SVGRender {
}
class SVGItemRender extends SVGLayerRender {
  updateDefString(item, currentElement) {
    var $defs = currentElement.$("defs");
    if ($defs) {
      $defs.html(this.toDefInnerString(item));
    } else {
      var str = this.toDefString(item).trim();
      currentElement.prepend(Dom.createByHTML(str));
    }
  }
  toDefInnerString(item) {
    return `
            ${this.toFillSVG(item)}
            ${this.toStrokeSVG(item)}
        `;
  }
  toDefString(item) {
    const str = this.toDefInnerString(item).trim();
    return `
            <defs>
            ${str}
            </defs>
        `;
  }
  fillId(item) {
    return this.getInnerId(item, "fill");
  }
  strokeId(item) {
    return this.getInnerId(item, "stroke");
  }
  toFillSVG(item) {
    return SVGFill.parseImage(item.fill || "transparent").toSVGString(this.fillId(item));
  }
  toStrokeSVG(item) {
    return SVGFill.parseImage(item.stroke || "black").toSVGString(this.strokeId(item));
  }
  toFillValue(item) {
    return SVGFill.parseImage(item.fill || "transparent").toFillValue(this.fillId(item));
  }
  toFillOpacityValue(item) {
    return parse(item.fill || "transparent").a;
  }
  toStrokeValue(item) {
    return SVGFill.parseImage(item.stroke || "black").toFillValue(this.strokeId(item));
  }
  toFilterValue(item) {
    if (!item.svgfilter) {
      return "";
    }
    return `url(#${item.svgfilter})`;
  }
  toLayoutCSS() {
    return {};
  }
}
class BooleanPathRender extends SVGItemRender {
  update(item, currentElement) {
    if (!currentElement)
      return;
    const $path = currentElement.$(`[data-boolean-path-id="${item.id}"]`);
    if ($path) {
      $path.setAttr({
        d: item.d,
        filter: this.toFilterValue(item),
        fill: this.toFillValue(item),
        stroke: this.toStrokeValue(item)
      });
      item.totalLength = $path.totalLength;
    }
    this.updateDefString(item, currentElement);
  }
  render(item) {
    var { d } = item;
    return this.wrappedRender(item, () => {
      return `
<path ${OBJECT_TO_PROPERTY(__spreadProps(__spreadValues({
        class: "boolean-path-item",
        "data-boolean-path-id": item.id,
        d,
        filter: this.toFilterValue(item),
        fill: this.toFillValue(item),
        stroke: this.toStrokeValue(item)
      }, this.toSVGAttribute(item)), {
        style: CSS_TO_STRING(this.toCSS(item))
      }))} />
    `;
    });
  }
}
class CircleRender extends SVGLayerRender {
}
class IFrameRender extends SVGLayerRender {
  update(item, currentElement) {
    let $iframe = currentElement.$("iframe");
    if ($iframe) {
      $iframe.attr("src", item.url || "about:blank");
    }
    super.update(item, currentElement);
  }
  render(item) {
    const { width: width2, height: height2, url = "about:blank" } = item;
    let css = this.toCSS(item);
    return this.wrappedRender(item, () => {
      return `
  <foreignObject
      width="${width2}"
      height="${height2}"
  >
      <iframe 
          xmlns="http://www.w3.org/1999/xhtml"
          width="100%" 
          height="100%" 
          style="border:0px;width:100%;height:100%;pointer-events:none; ${CSS_TO_STRING(css)}" 
          src="${url}"
      ></iframe>
  </foreignObject>              
          `;
    });
  }
}
class ImageRender extends SVGLayerRender {
  getUrl(item) {
    var { src } = item;
    var project2 = item.project;
    return project2.getImageValueById(src);
  }
  render(item) {
    const { width: width2, height: height2 } = item;
    let css = this.toCSS(item);
    return this.wrappedRender(item, () => {
      return `
            <foreignObject
                width="${width2}"
                height="${height2}"
            >
                <div xmlns="http://www.w3.org/1999/xhtml">
                    <img src='${this.getUrl(item)}' style="width:100%;height:100%; ${CSS_TO_STRING(css)}"  />
                </div>
            </foreignObject>              
          `;
    });
  }
  update(item, currentElement) {
    const $image = currentElement.$("img");
    if ($image) {
      $image.attr("src", this.getUrl(item));
    }
    super.update(item, currentElement);
  }
}
class ProjectRender extends SVGRender {
  render(item, renderer) {
    return item.artboards.map((it) => {
      return renderer.render(it, renderer);
    });
  }
}
class RectRender extends SVGLayerRender {
}
class SplineRender extends SVGItemRender {
  update(item, currentElement) {
    if (!currentElement)
      return;
    var $path = currentElement.$("path");
    if ($path) {
      $path.setAttr({
        d: item.d,
        filter: this.toFilterValue(item),
        fill: this.toFillValue(item),
        stroke: this.toStrokeValue(item)
      });
    }
    this.updateDefString(item, currentElement);
  }
  render(item) {
    var { d } = item;
    return this.wrappedRender(item, () => {
      return `
<path ${OBJECT_TO_PROPERTY(__spreadProps(__spreadValues({
        class: "spline-item",
        d,
        filter: this.toFilterValue(item),
        fill: this.toFillValue(item),
        stroke: this.toStrokeValue(item)
      }, this.toSVGAttribute(item)), {
        style: CSS_TO_STRING(this.toCSS(item))
      }))} />
    `;
    });
  }
}
class SVGPathRender extends SVGItemRender {
  update(item, currentElement) {
    if (!currentElement)
      return;
    var $path = currentElement.$("path");
    if ($path) {
      $path.setAttr({
        d: item.d,
        filter: this.toFilterValue(item),
        fill: this.toFillValue(item),
        stroke: this.toStrokeValue(item)
      });
      item.totalLength = $path.totalLength;
    }
    this.updateDefString(item, currentElement);
  }
  render(item) {
    var { d } = item;
    return this.wrappedRender(item, () => {
      return `
<path ${OBJECT_TO_PROPERTY(__spreadProps(__spreadValues({
        class: "svg-path-item",
        d,
        filter: this.toFilterValue(item),
        fill: this.toFillValue(item),
        stroke: this.toStrokeValue(item)
      }, this.toSVGAttribute(item)), {
        style: CSS_TO_STRING(this.toCSS(item))
      }))} />
    `;
    });
  }
}
class SVGPolygonRender extends SVGItemRender {
  update(item, currentElement) {
    if (!currentElement)
      return;
    var $path = currentElement.$("path");
    if ($path) {
      $path.setAttr({
        d: item.d,
        filter: this.toFilterValue(item),
        fill: this.toFillValue(item),
        stroke: this.toStrokeValue(item)
      });
    }
    this.updateDefString(item, currentElement);
  }
  render(item) {
    var { d } = item;
    return this.wrappedRender(item, () => {
      return `
<path ${OBJECT_TO_PROPERTY(__spreadProps(__spreadValues({
        class: "polygon-item",
        d,
        filter: this.toFilterValue(item),
        fill: this.toFillValue(item),
        stroke: this.toStrokeValue(item)
      }, this.toSVGAttribute(item)), {
        style: CSS_TO_STRING(this.toCSS(item))
      }))} />
    `;
    });
  }
}
class SVGStarRender extends SVGItemRender {
  update(item, currentElement) {
    if (!currentElement)
      return;
    var $path = currentElement.$("path");
    if ($path) {
      $path.setAttr({
        d: item.d,
        filter: this.toFilterValue(item),
        fill: this.toFillValue(item),
        stroke: this.toStrokeValue(item)
      });
    }
    this.updateDefString(item, currentElement);
  }
  render(item) {
    var { d } = item;
    return this.wrappedRender(item, () => {
      return `
<path ${OBJECT_TO_PROPERTY(__spreadProps(__spreadValues({
        class: "star-item",
        d,
        filter: this.toFilterValue(item),
        fill: this.toFillValue(item),
        stroke: this.toStrokeValue(item)
      }, this.toSVGAttribute(item)), {
        style: CSS_TO_STRING(this.toCSS(item))
      }))} />
    `;
    });
  }
}
class SVGTextPathRender extends SVGItemRender {
  update(item, currentElement) {
    var $path = currentElement.$("path");
    if ($path) {
      $path.attr("d", item.d);
    }
    var $textPath = currentElement.$("textPath");
    if ($textPath) {
      $textPath.text(item.text);
      $textPath.setAttr({
        filter: this.toFilterValue(item),
        fill: this.toFillValue(item),
        stroke: this.toStrokeValue(item),
        textLength: item.textLength,
        lengthAdjust: item.lengthAdjust,
        startOffset: item.startOffset
      });
    }
    this.updateDefString(item, currentElement);
    item.totalLength = $path.totalLength;
  }
  toDefInnerString(item) {
    return `
      ${this.toPathSVG(item)}
      ${this.toFillSVG(item)}
      ${this.toStrokeSVG(item)}
    `;
  }
  toPathId(item) {
    return this.getInnerId(item, "path");
  }
  toPathSVG(item) {
    return `
      <path 
        class="svg-path-item"
        id="${this.toPathId(item)}"
        d="${item.d}"
        fill="none"
      />
    `;
  }
  render(item) {
    return this.wrappedRender(item, () => {
      const { textLength, lengthAdjust, startOffset } = item;
      return `
        <textPath ${OBJECT_TO_PROPERTY(__spreadProps(__spreadValues({
        "xlink:href": `#${this.toPathId(item)}`,
        textLength,
        lengthAdjust,
        startOffset,
        filter: this.toFilterValue(item),
        fill: this.toFillValue(item),
        stroke: this.toStrokeValue(item)
      }, this.toSVGAttribute(item)), {
        style: CSS_TO_STRING(this.toCSS(item))
      }))} >${item.text}</textPath>
      `;
    });
  }
}
class SVGTextRender extends SVGItemRender {
  update(item, currentElement) {
    var $text = currentElement.$("text");
    if ($text) {
      $text.text(item.text);
      $text.setAttr({
        filter: this.toFilterValue(item),
        fill: this.toFillValue(item),
        stroke: this.toStrokeValue(item),
        textLength: item.textLength,
        lengthAdjust: item.lengthAdjust
      });
    }
    this.updateDefString(item, currentElement);
  }
  shapeInsideId(item) {
    return this.getInnerId(item, "shape-inside");
  }
  render(item) {
    var { textLength, lengthAdjust } = item;
    return this.wrappedRender(item, () => {
      return `
        <text ${OBJECT_TO_PROPERTY(__spreadProps(__spreadValues({
        class: "svg-text-item",
        textLength,
        lengthAdjust,
        filter: this.toFilterValue(item),
        fill: this.toFillValue(item),
        stroke: this.toStrokeValue(item)
      }, this.toSVGAttribute(item)), {
        style: CSS_TO_STRING(this.toCSS(item))
      }))} >${item.text}</text>
      `;
    });
  }
}
class TemplateRender extends SVGLayerRender {
  update(item, currentElement) {
    const compiledTemplate = this.compile(item);
    let $innerHTML = currentElement.$(".inner-html");
    if ($innerHTML) {
      $innerHTML.updateDiff(compiledTemplate);
    }
    super.update(item, currentElement);
  }
  compile(item) {
    return TemplateEngine.compile("dom", item.template, item.params);
  }
  render(item) {
    const { id, width: width2, height: height2 } = item;
    const compiledTemplate = this.compile(item);
    return this.wrappedRender(item, () => {
      return `
            <foreignObject
                width="${width2}"
                height="${height2}"
            >
                <div  xmlns="http://www.w3.org/1999/xhtml" style="width: 100%;height:100%;">
                    <style id="style-${id}">
                    [data-id="${id}"] .inner-html {
                        width: 100%; 
                        height: 100%;
                        position:relative;
                        display:block;
                        pointer-events: none; 
                    }

                    [data-id="${id}"] .inner-html > * {
                        width: 100%; 
                        height: 100%;
                    }          
                    </style>
                    <div class="inner-html">
                    ${compiledTemplate}
                    </div>
                </div>
            </foreignObject>              
          `;
    });
  }
}
class TextRender extends SVGLayerRender {
  toCSS(item) {
    let css = super.toCSS(item);
    css.margin = css.margin || "0px";
    css.height = "auto";
    return css;
  }
  render(item) {
    const { content: content2, width: width2, height: height2 } = item;
    let css = this.toCSS(item);
    return this.wrappedRender(item, () => {
      return `
            <foreignObject width="${width2}" height="${height2}">
                <p xmlns="http://www.w3.org/1999/xhtml" style="${CSS_TO_STRING(css)}">${content2}</p>
            </foreignObject>              
          `;
    });
  }
  update(item, currentElement) {
    var { content: content2 } = item;
    currentElement.updateDiff(content2);
  }
}
class VideoRender extends SVGLayerRender {
  getUrl(item) {
    var { src } = item;
    var project2 = item.project;
    return project2.getVideoValueById(src);
  }
  render(item) {
    var {
      width: width2,
      height: height2,
      controls,
      muted,
      poster,
      loop,
      crossorigin,
      autoplay
    } = item;
    let css = this.toCSS(item);
    return this.wrappedRender(item, () => {
      return `
            <foreignObject 
                width="${width2}"
                height="${height2}"
                overflow="visible"
            >
                <video 
                    xmlns="http://www.w3.org/1999/xhtml"
                    controls="${controls}"
                    src="${this.getUrl(item)}"
                    muted="${muted}"
                    poster="${poster}"
                    loop="${loop}"
                    crossorigin="${crossorigin}"
                    autoplay="${autoplay}"
                    style="${CSS_TO_STRING(css)};width:100%;height:100%;"></video>
            </foreignObject>    
            `;
    });
  }
}
function rendererSvg(editor) {
  editor.registerRendererType("svg", new SVGRenderer(editor));
  editor.registerRenderer("svg", "project", new ProjectRender());
  editor.registerRenderer("svg", "artboard", new ArtBoardRender());
  editor.registerRenderer("svg", "rect", new RectRender());
  editor.registerRenderer("svg", "circle", new CircleRender());
  editor.registerRenderer("svg", "image", new ImageRender());
  editor.registerRenderer("svg", "template", new TemplateRender());
  editor.registerRenderer("svg", "iframe", new IFrameRender());
  editor.registerRenderer("svg", "video", new VideoRender());
  editor.registerRenderer("svg", "text", new TextRender());
  editor.registerRenderer("svg", "boolean-path", new BooleanPathRender());
  editor.registerRenderer("svg", "svg-path", new SVGPathRender());
  editor.registerRenderer("svg", "polygon", new SVGPolygonRender());
  editor.registerRenderer("svg", "star", new SVGStarRender());
  editor.registerRenderer("svg", "spline", new SplineRender());
  editor.registerRenderer("svg", "svg-text", new SVGTextRender());
  editor.registerRenderer("svg", "svg-textpath", new SVGTextPathRender());
}
class SampleLayer extends LayerModel {
  getDefaultObject(obj2 = {}) {
    return super.getDefaultObject(__spreadValues({
      itemType: "sample",
      name: "New Sample Layer",
      sampleText: "Sample Text 1",
      sampleNumber: 1
    }, obj2));
  }
  get sampleText() {
    return this.get("sampleText");
  }
  set sampleText(value) {
    this.set("sampleText", value);
  }
  get sampleNumber() {
    return this.get("sampleNumber");
  }
  set sampleNumber(value) {
    this.set("sampleNumber", value);
  }
  toCloneObject() {
    return __spreadValues(__spreadValues({}, super.toCloneObject()), this.attrs("sampleText", "sampleNumber"));
  }
  editable(editablePropertyName) {
    switch (editablePropertyName) {
      case "sample":
        return true;
    }
    return super.editable(editablePropertyName);
  }
  getDefaultTitle() {
    return "Sample Layer";
  }
}
class SampleRender extends LayerRender$1 {
  update(item, currentElement) {
    const $sampleText = currentElement.$(".sample-text");
    if ($sampleText) {
      $sampleText.text(item.sampleText);
    }
    const $sampleNumber = currentElement.$(".sample-number");
    if ($sampleNumber) {
      $sampleNumber.text(item.sampleNumber);
    }
    const $sampleItems = currentElement.$(".sample-items");
    if ($sampleItems) {
      const template = [...Array(item.sampleNumber)].map((_, i) => `
            <div class="sample-item" style="background-color: yellow">${i}</div>
          `).join("\n");
      $sampleItems.html(template);
    }
    super.update(item, currentElement);
  }
  render(item) {
    var { id, sampleText, sampleNumber } = item;
    return `
      <div class='element-item sample' data-id="${id}">
        ${this.toDefString(item)}
        <div>
          <div class="sample-text">${sampleText}</div>
          <div class="sample-number">${sampleNumber}</div>
          <div class="sample-items" style="display: grid; grid-template-columns: 1fr 1fr 1fr; column-gap: 10px;"></div>
        </div>
      </div>`;
  }
}
function sample(editor) {
  editor.registerComponent("sample", SampleLayer);
  editor.registerRenderer("html", "sample", new SampleRender());
  editor.registerInspector("sample", (current) => {
    return [
      "Sample Text \uD3B8\uC9D1",
      {
        key: "sampleText",
        editor: "TextEditor",
        defaultValue: current.sampleText
      },
      "Sample Number \uD3B8\uC9D1",
      {
        key: "sampleNumber",
        editor: "NumberInputEditor",
        editorOptions: {
          min: 0,
          max: 10,
          step: 1,
          label: "SN"
        },
        defaultValue: current.sampleNumber
      },
      "\uC2A4\uD0C0\uC77C \uCE74\uD53C",
      {
        type: "column",
        size: [1, 1],
        gap: 10,
        columns: [
          {
            key: "copyCssJSON",
            editor: "Button",
            editorOptions: {
              text: "Copy CSS JSON",
              onClick: () => {
                console.log(JSON.stringify(editor.html.toCSS(current), null, 4));
              }
            }
          },
          {
            key: "copyCssString",
            editor: "Button",
            editorOptions: {
              text: "Copy CSS String",
              onClick: () => {
                console.log(CSS_TO_STRING(editor.html.toCSS(current)));
              }
            }
          },
          {
            key: "changeColor",
            editor: "Button",
            editorOptions: {
              text: "Change Text Random Color",
              onClick: () => {
                const textColor = random$1();
                const backgroundColor = random$1();
                editor.context.commands.emit("setAttribute", {
                  [current.id]: {
                    color: textColor,
                    "background-color": backgroundColor
                  }
                });
              }
            }
          }
        ]
      }
    ];
  });
}
var SelectionInfoView$1 = "";
class SelectionInfoView extends EditorElement {
  template() {
    return /* @__PURE__ */ createElementJsx("div", {
      class: "elf--selection-info-view"
    });
  }
  [POINTERSTART("$el [data-artboard-title-id]") + LEFT_BUTTON + MOVE("calculateMovedElement") + END("calculateEndedElement")](e) {
    this.startXY = e.xy;
    this.initMousePoint = this.$viewport.getWorldPosition(e);
    const id = e.$dt.attr("data-artboard-title-id");
    this.$context.selection.select(id);
    if (e.altKey) {
      this.$context.selection.selectAfterCopy();
      this.emit("refreshAllCanvas");
      this.emit("refreshLayerTreeView");
    }
    this.initializeDragSelection();
    this.$commands.emit("history.refreshSelection");
    this.$config.set("set.move.control.point", true);
  }
  initializeDragSelection() {
    this.$context.selection.reselect();
    this.$context.snapManager.clear();
    this.emit(REFRESH_SELECTION);
  }
  moveTo(dist2) {
    const snap = this.$context.snapManager.check(this.$context.selection.cachedRectVerties.map((v) => {
      return add$1([], v, dist2);
    }), 3 / this.$viewport.scale);
    const localDist = add$1([], snap.dist, dist2);
    const result = {};
    this.$context.selection.cachedItemMatrices.forEach((it) => {
      const newVerties = it.verties.map((v) => {
        return add$1([], v, localDist);
      });
      const newDist = subtract([], transformMat4([], newVerties[0], it.parentMatrixInverse), transformMat4([], it.verties[0], it.parentMatrixInverse));
      result[it.id] = {
        x: Math.floor(it.x + newDist[0]),
        y: Math.floor(it.y + newDist[1])
      };
    });
    this.$context.selection.reset(result);
  }
  calculateMovedElement() {
    const targetMousePoint = this.$viewport.getWorldPosition();
    const newDist = floor([], subtract([], targetMousePoint, this.initMousePoint));
    this.moveTo(newDist);
    this.$commands.emit("setAttribute", this.$context.selection.pack("x", "y"));
    this.emit(UPDATE_CANVAS);
    this.refresh();
  }
  [SUBSCRIBE("refreshItemName")](id, title2) {
    var _a;
    this.$commands.emit("setAttribute", {
      [id]: { name: title2 }
    });
    (_a = this.$el.$(`[data-artboard-title-id='${id}']`)) == null ? void 0 : _a.text(title2);
  }
  calculateEndedElement() {
    this.$commands.executeCommand("setAttribute", "move item", this.$context.selection.pack("x", "y"));
    this.$config.set("set.move.control.point", false);
  }
  [SUBSCRIBE(UPDATE_VIEWPORT)]() {
    this.refresh();
  }
  [SUBSCRIBE(UPDATE_CANVAS)]() {
    if (this.$context.selection.current) {
      if (this.$context.selection.current.is("artboard")) {
        if (this.$context.selection.hasChangedField("x", "y", "width", "height", "angle", "transform", "transform-origin")) {
          this.refresh();
        }
      }
    }
  }
  [LOAD("$el") + DOMDIFF]() {
    var _a;
    return (_a = this.$context.selection.currentProject) == null ? void 0 : _a.artboards.map((it) => {
      return {
        item: it,
        title: it.name,
        id: it.id,
        layout: it.layout,
        pointers: this.$viewport.applyVerties(it.verties)
      };
    }).map((it) => this.makeArtboardTitleArea(it));
  }
  getIcon(item) {
    if (item.hasLayout() || item.hasChildren() || item.is("artboard")) {
      if (item.isLayout("flex")) {
        return iconUse("layout_flex", item["flex-direction"] === "column" ? "rotate(90 12 12)" : "");
      } else if (item.isLayout("grid")) {
        return iconUse("layout_grid");
      }
      return "";
    }
    return this.$icon.get(item.itemType, item);
  }
  createSize(pointers, artboardItem) {
    const newPointer = pointers[0];
    const diff = subtract([], pointers[0], pointers[3]);
    const angle = calculateAngle360(diff[0], diff[1]) - 90;
    return /* @__PURE__ */ createElementJsx("div", {
      class: "artboard-title is-not-drag-area",
      "data-artboard-title-id": artboardItem.id,
      "data-layout": artboardItem.layout,
      style: {
        "transform-origin": "0% 0%",
        transform: `translate3d( calc(${newPointer[0]}px), calc(${newPointer[1]}px), 0px) rotateZ(${angle}deg)`
      }
    }, /* @__PURE__ */ createElementJsx("div", {
      style: "transform: translateY(-100%);"
    }, this.getIcon(artboardItem.item), artboardItem.title));
  }
  makeArtboardTitleArea(it) {
    return this.createSize(it.pointers, it);
  }
  [SUBSCRIBE("refreshAll")]() {
    this.refresh();
  }
  [SUBSCRIBE("appendLayer")]() {
    this.refresh();
  }
}
function selectionInfoView(editor) {
  editor.registerUI("canvas.view", {
    SelectionInfoView
  });
}
var GhostToolView$1 = "";
const CHECK_RATE = 0.5;
class GhostToolView extends EditorElement {
  template() {
    return /* @__PURE__ */ createElementJsx("div", {
      class: "elf--ghost-tool-view"
    }, /* @__PURE__ */ createElementJsx("div", {
      ref: "$containerView"
    }), /* @__PURE__ */ createElementJsx("div", {
      ref: "$view"
    }));
  }
  [SUBSCRIBE("startGhostToolView")]() {
    const screenVerties = this.$context.selection.verties;
    this.isLayoutItem = this.$context.selection.isLayoutItem;
    this.verties = clone$1(screenVerties);
    this.ghostVerties = clone$1(screenVerties);
    this.ghostScreenVerties = this.$viewport.applyVerties(this.ghostVerties);
    this.initMousePoint = this.$viewport.getWorldPosition();
    this.filteredLayers = this.$context.selection.notSelectedLayers;
    this.containerList = this.filteredLayers.filter((it) => it.hasLayout() || it.is("artboard")).map((it) => it.originVerties);
    this.$config.set("set.move.control.point", true);
  }
  collectInformation() {
    var _a, _b;
    const targetMousePoint = this.$viewport.getWorldPosition();
    const newDist = this.getDist();
    this.ghostVerties = this.verties.map((v) => {
      return add$1([], v, newDist);
    });
    this.ghostScreenVerties = this.$viewport.applyVerties(this.ghostVerties);
    const filteredLayers = this.$context.selection.filteredLayers.filter((it) => this.$context.selection.check(it) === false);
    this.targetItem = filteredLayers[0];
    if (this.targetItem) {
      const currentParent = (_a = this.$context.selection.current) == null ? void 0 : _a.parent;
      if (currentParent.isNot("project") && (currentParent == null ? void 0 : currentParent.isLayout(Layout.GRID))) {
        this.targetItem = this.$context.selection.current.parent;
      } else {
        if (this.targetItem.hasLayout() && ((_b = this.targetItem) == null ? void 0 : _b.hasChildren())) {
          if (this.targetItem.isLayout(Layout.FLEX)) {
            this.targetItem = this.targetItem.layers[this.targetItem.layers.length - 1];
          } else if (this.targetItem.isLayout(Layout.GRID))
            ;
        }
      }
      this.$context.selection.updateDragTargetItem(this.targetItem);
      this.targetOriginPosition = this.$viewport.applyVerties(toRectVerties(this.targetItem.contentVerties));
      this.targetPoint = this.$viewport.applyVertex(targetMousePoint);
      this.targetRelativeMousePoint = {
        x: (this.targetPoint[0] - this.targetOriginPosition[0][0]) / (this.targetOriginPosition[1][0] - this.targetOriginPosition[0][0]),
        y: (this.targetPoint[1] - this.targetOriginPosition[0][1]) / (this.targetOriginPosition[3][1] - this.targetOriginPosition[0][1])
      };
      if (this.targetItem.isLayoutItem()) {
        this.targetParent = this.targetItem.parent;
        if (this.targetParent) {
          this.targetParentPosition = this.$viewport.applyVerties(this.targetParent.contentVerties);
        }
      } else {
        this.targetParent = null;
        this.targetParentPosition = null;
      }
    } else {
      this.targetPoint = null;
      this.targetRelativeMousePoint = null;
      this.targetParent = null;
      this.targetParentPosition = null;
    }
  }
  [SUBSCRIBE("moveFirstGhostToolView")]() {
    this.collectInformation();
    this.load("$containerView");
    this.load("$view");
  }
  [SUBSCRIBE("moveGhostToolView")]() {
    this.collectInformation();
    this.load("$view");
  }
  [LOAD("$containerView")]() {
    var _a;
    if (!this.ghostVerties) {
      return /* @__PURE__ */ createElementJsx("svg", null);
    }
    return /* @__PURE__ */ createElementJsx("svg", null, (_a = this.containerList) == null ? void 0 : _a.map((it) => {
      it = this.$viewport.applyVerties(it);
      return /* @__PURE__ */ createElementJsx("path", {
        class: "container",
        d: `
                    M ${it[0][0]} ${it[0][1]}
                    L ${it[1][0]} ${it[1][1]}
                    L ${it[2][0]} ${it[2][1]}
                    L ${it[3][0]} ${it[3][1]}
                    Z
                `
      });
    }));
  }
  renderPathForVerties(verties, className) {
    if (!verties) {
      return /* @__PURE__ */ createElementJsx("g", null);
    }
    const d = vertiesToPath(verties);
    return /* @__PURE__ */ createElementJsx("g", null, /* @__PURE__ */ createElementJsx("path", {
      class: className,
      d
    }));
  }
  renderPath(verties, className, data = className) {
    if (!verties)
      return "";
    verties = data === "ghost" ? verties : toRectVerties(verties);
    const textX = className === "flex-item" ? verties[0][0] : verties[0][0];
    const textY = className === "flex-item" ? verties[2][1] + 10 : verties[0][1] - 10;
    return /* @__PURE__ */ createElementJsx("g", null, /* @__PURE__ */ createElementJsx("text", {
      x: textX,
      y: textY,
      "font-size": 8
    }, data), this.renderPathForVerties(verties, className));
  }
  renderLayoutFlexRowArea() {
    if (this.targetRelativeMousePoint.x < CHECK_RATE) {
      return /* @__PURE__ */ createElementJsx(FragmentInstance, null, this.renderPathForVerties([this.targetOriginPosition[0], this.targetOriginPosition[3]], "flex-target"));
    } else {
      return /* @__PURE__ */ createElementJsx(FragmentInstance, null, this.renderPathForVerties([this.targetOriginPosition[1], this.targetOriginPosition[2]], "flex-target"));
    }
  }
  renderLayoutFlexForFirstItem(direction2) {
    const isColumn = direction2 === FlexDirection.COLUMN;
    const verticalField = isColumn ? "align-items" : "justify-content";
    const verticalConst = isColumn ? AlignItems : JustifyContent;
    const horizontalField = isColumn ? "justify-content" : "align-items";
    const horizontalConst = isColumn ? JustifyContent : AlignItems;
    const rect2 = vertiesToRectangle(this.targetOriginPosition);
    const center2 = this.ghostScreenVerties[4];
    const width2 = dist(this.ghostScreenVerties[0], this.ghostScreenVerties[1]);
    const height2 = dist(this.ghostScreenVerties[0], this.ghostScreenVerties[3]);
    let newCenterX = width2 / 2;
    let newCenterY = height2 / 2;
    switch (this.targetItem[verticalField]) {
      case verticalConst.FLEX_START:
        newCenterX = rect2.x + width2 / 2;
        break;
      case verticalConst.CENTER:
      case verticalConst.SPACE_BETWEEN:
      case verticalConst.SPACE_AROUND:
        newCenterX = rect2.x + rect2.width / 2;
        break;
      case verticalConst.FLEX_END:
        newCenterX = rect2.x + rect2.width - width2 / 2;
        break;
    }
    switch (this.targetItem[horizontalField]) {
      case horizontalConst.FLEX_START:
        newCenterY = rect2.y + height2 / 2;
        break;
      case horizontalConst.CENTER:
      case horizontalConst.SPACE_BETWEEN:
      case horizontalConst.SPACE_AROUND:
        newCenterY = rect2.y + rect2.height / 2;
        break;
      case horizontalConst.FLEX_END:
        newCenterY = rect2.y + rect2.height - height2 / 2;
        break;
    }
    const newDist = subtract([], [newCenterX, newCenterY, 0], center2);
    const renderVerties = this.ghostScreenVerties.map((it) => add$1([], it, newDist)).filter((it, index2) => index2 < 4);
    return this.renderPathForVerties(renderVerties, "flex-item", "ghost");
  }
  renderLayoutFlexColumnArea() {
    if (this.targetRelativeMousePoint.y < 0) {
      return "";
    }
    if (this.targetRelativeMousePoint.y < CHECK_RATE) {
      return this.renderPathForVerties([this.targetOriginPosition[0], this.targetOriginPosition[1]], "flex-target");
    } else {
      return this.renderPathForVerties([this.targetOriginPosition[2], this.targetOriginPosition[3]], "flex-target");
    }
  }
  renderLayoutItemInsertArea() {
    if (!this.targetParent) {
      return;
    }
    if (this.targetParent.hasLayout()) {
      if (this.targetParent.isLayout(Layout.FLEX)) {
        switch (this.targetParent["flex-direction"]) {
          case FlexDirection.ROW:
            return this.renderLayoutFlexRowArea();
          case FlexDirection.COLUMN:
            return this.renderLayoutFlexColumnArea();
        }
      } else if (this.targetParent.isLayout(Layout.GRID))
        ;
    }
    return /* @__PURE__ */ createElementJsx("path", {
      class: "insert-area",
      d: `

        `
    });
  }
  renderLayoutItemForFirst() {
    var _a;
    if (((_a = this.targetItem) == null ? void 0 : _a.hasChildren()) === false) {
      if (this.targetItem.isLayout(Layout.FLEX)) {
        return this.renderLayoutFlexForFirstItem(this.targetItem["flex-direction"]);
      } else if (this.targetItem.isLayout(Layout.GRID))
        ;
    }
    return /* @__PURE__ */ createElementJsx("path", {
      class: "insert-area",
      d: `

        `
    });
  }
  [LOAD("$view") + DOMDIFF]() {
    var _a;
    const current = this.$context.selection.current;
    if (!this.ghostVerties || !current) {
      return /* @__PURE__ */ createElementJsx("svg", null);
    }
    const hasTargetView = ((_a = this.targetItem) == null ? void 0 : _a.id) !== current.id;
    return /* @__PURE__ */ createElementJsx("svg", null, this.targetParent && this.renderPathForVerties(this.targetParentPosition, "target-parent"), hasTargetView && this.renderPathForVerties(this.targetOriginPosition, "target", ""), hasTargetView && this.renderPathForVerties(this.targetOriginPosition, "target-rect", ""), hasTargetView && this.renderLayoutItemInsertArea(), hasTargetView && this.renderLayoutItemForFirst(), this.isLayoutItem && this.renderPathForVerties(this.ghostScreenVerties.filter((_, index2) => index2 < 4), "ghost"));
  }
  initializeGhostView() {
    this.isLayoutItem = false;
    this.ghostVerties = void 0;
    this.ghostScreenVerties = void 0;
    this.targetOriginPosition = void 0;
    this.targetOriginPosition = void 0;
    this.targetRelativeMousePoint = void 0;
    this.targetItem = void 0;
    this.targetParent = void 0;
    this.targetParentPosition = void 0;
    this.$context.selection.updateDragTargetItem(this.targetItem);
  }
  getDist() {
    const targetMousePoint = this.$viewport.getWorldPosition();
    const newDist = floor([], subtract([], targetMousePoint, this.initMousePoint));
    return newDist;
  }
  insertToBackground() {
    const current = this.$context.selection.current;
    const newDist = this.getDist();
    if (current.isLayoutItem() === false)
      return;
    this.$commands.executeCommand("moveLayerToTarget", "change target with move", current, this.$context.selection.currentProject, newDist);
  }
  getTargetAction() {
    let targetAction = "";
    if (this.targetParent.hasLayout()) {
      if (this.targetParent.isLayout(Layout.FLEX)) {
        switch (this.targetParent["flex-direction"]) {
          case FlexDirection.ROW:
            if (this.targetRelativeMousePoint.x < CHECK_RATE) {
              targetAction = TargetActionType.INSERT_BEFORE;
            } else {
              targetAction = TargetActionType.INSERT_AFTER;
            }
            break;
          case FlexDirection.COLUMN:
            if (this.targetRelativeMousePoint.y < CHECK_RATE) {
              targetAction = TargetActionType.INSERT_BEFORE;
            } else {
              targetAction = TargetActionType.INSERT_AFTER;
            }
            break;
        }
      }
    }
    return targetAction;
  }
  insertToLayoutItem() {
    const current = this.$context.selection.current;
    const newDist = this.getDist();
    if (this.targetParent.hasLayout()) {
      let targetAction = this.getTargetAction();
      if (this.targetParent.isLayout(Layout.FLEX)) {
        if (targetAction) {
          this.$commands.executeCommand("moveLayerToTarget", "change target with move", current, this.targetItem, newDist, targetAction);
        }
      } else if (this.targetParent.isLayout(Layout.GRID)) {
        this.insertToGridItem();
      }
    }
  }
  insertToGridItem() {
    const current = this.$context.selection.current;
    const { info, items } = this.$context.selection.gridInformation || {
      items: []
    };
    const currentVerties = this.ghostVerties.filter((_, index2) => index2 < 4);
    const targetRect = vertiesToRectangle(currentVerties);
    const epsilon = IntersectEpsilonNumberType.RECT / this.$context.viewport.scale;
    const checkedItems = items == null ? void 0 : items.filter((it) => {
      return polyPoly(it.originVerties, currentVerties);
    }).filter((it) => {
      const intersect = intersectRectRect(it.originRect, targetRect);
      return Math.floor(intersect.width) > epsilon && Math.floor(intersect.height) > epsilon;
    });
    if (checkedItems == null ? void 0 : checkedItems.length) {
      const columnList = checkedItems.map((it) => it.column);
      const rowList = checkedItems.map((it) => it.row);
      const columnStart = Math.min(...columnList);
      const rowStart = Math.min(...rowList);
      const columnEnd = Math.max(...columnList) + 1;
      const rowEnd = Math.max(...rowList) + 1;
      this.$commands.executeCommand("setAttribute", "change grid item", this.$context.selection.packByValue({
        "grid-column-start": columnStart,
        "grid-column-end": columnEnd,
        "grid-row-start": rowStart,
        "grid-row-end": rowEnd
      }));
      if (info.current.hasChild(current.id) === false) {
        this.$commands.executeCommand("moveLayerToTarget", "change target with move", current, info.current, void 0);
      }
      return;
    } else {
      if (this.targetItem) {
        this.emit("refreshGridToolInfo", this.targetItem);
        this.$commands.executeCommand("moveLayerToTarget", "change target with move", current, this.targetItem, void 0);
      }
    }
  }
  updateLayer() {
    var _a;
    const current = this.$context.selection.current;
    if (!current)
      return;
    const newDist = this.getDist();
    if (newDist[0] === 0 && newDist[1] === 0) {
      return;
    }
    if (this.targetItem && this.targetItem.id === (current == null ? void 0 : current.id)) {
      return;
    }
    if (!this.targetItem) {
      this.insertToBackground();
      return;
    }
    if (this.targetItem.hasLayout()) {
      const isCtrl = this.$context.keyboardManager.isCtrl();
      if (((_a = this.targetItem) == null ? void 0 : _a.hasChildren()) === false && this.targetItem.isLayout(Layout.FLEX) && isCtrl === false) {
        this.$commands.executeCommand("moveLayerToTarget", "change target with move", current, this.targetItem, newDist);
        return;
      } else {
        if (isCtrl) {
          const { info } = this.$context.selection.gridInformation || {
            items: []
          };
          if (info == null ? void 0 : info.current) {
            this.insertToGridItem();
            return;
          }
        } else {
          if (this.targetItem.isLayout(Layout.GRID)) {
            this.insertToGridItem();
            return;
          }
        }
      }
    }
    if (this.targetParent) {
      this.insertToLayoutItem();
      return;
    }
    if (current.isLayoutItem() && current.parent.id !== this.targetItem.id) {
      this.$commands.executeCommand("moveLayerToTarget", "change target with move", current, this.targetItem, newDist);
    }
  }
  [SUBSCRIBE("endGhostToolView")](hasMoved = false) {
    if (hasMoved) {
      this.updateLayer();
    }
    this.initializeGhostView();
    this.load();
  }
}
var SelectionView = "";
var directionType$1 = {
  1: "to top left",
  2: "to top right",
  3: "to bottom right",
  4: "to bottom left",
  11: "to top",
  12: "to right",
  13: "to bottom",
  14: "to left"
};
const SelectionToolEvent$1 = class extends EditorElement {
  checkViewMode() {
    return this.$modeView.isCurrentMode(ViewModeType.CanvasView);
  }
  [SUBSCRIBE(REFRESH_SELECTION, REFRESH_SELECTION_TOOL) + IF("checkViewMode")]() {
    if (this.$context.selection.isMany) {
      this.initSelectionTool();
    } else {
      this.hide();
    }
  }
  [SUBSCRIBE(UPDATE_VIEWPORT) + IF("checkViewMode")]() {
    if (this.$context.selection.isMany) {
      this.initSelectionTool();
    }
  }
};
class GroupSelectionToolView extends SelectionToolEvent$1 {
  template() {
    return `
            <div class='elf--selection-view group-selection-view' ref='$selectionView'  style='display:none' >
                <div class='pointer-rect' ref='$pointerRect'></div>        
            </div>
        `;
  }
  toggleEditingPath(isEditingPath) {
    this.refs.$selectionView.toggleClass("editing-path", isEditingPath);
  }
  [POINTERSTART("$pointerRect .rotate-pointer") + MOVE("rotateVertex") + END("rotateEndVertex")](e) {
    this.state.moveType = "rotate";
    this.initMousePoint = this.$viewport.getWorldPosition(e);
    this.verties = this.groupItem.verties;
    this.rotateTargetNumber = +e.$dt.attr("data-number");
    this.refreshRotatePointerIcon();
    this.state.dragging = false;
    this.state.isRotate = true;
    this.$config.set("set.move.control.point", true);
  }
  rotateVertex() {
    const targetMousePoint = this.$viewport.getWorldPosition();
    const distVector = subtract([], targetMousePoint, this.initMousePoint);
    const targetRotatePointer = this.rotateTargetNumber === 4 ? getRotatePointer(this.verties, 34) : this.verties[this.rotateTargetNumber];
    var distAngle = Math.floor(calculateAngleForVec3(targetRotatePointer, this.verties[4], distVector));
    if (this.$config.get("bodyEvent").shiftKey) {
      distAngle = distAngle - distAngle % this.$config.get("fixed.angle");
    }
    this.localAngle = this.angle + distAngle;
    this.groupItem.reset({
      angle: this.localAngle
    });
    const selectionMatrix = calculateRotationOriginMat4(distAngle, this.verties[4]);
    let cachedItemMatrices = this.$context.selection.cachedItemMatrices;
    if (this.$context.selection.length === 1) {
      cachedItemMatrices = cachedItemMatrices.filter((it) => it.id === this.$context.selection.current.id);
    }
    cachedItemMatrices.forEach((item) => {
      const newVerties = vertiesMap(item.verties, multiply$1([], item.parentMatrixInverse, selectionMatrix));
      const rotatePointer = getRotatePointer(newVerties, 34);
      var lastAngle = calculateAngle(rotatePointer[0] - newVerties[4][0], rotatePointer[1] - newVerties[4][1]) - 270;
      const newTranslate = transformMat4([], newVerties[0], calculateRotationOriginMat4(-lastAngle, newVerties[4]));
      const instance = this.$model.get(item.id);
      if (instance) {
        instance.reset({
          x: newTranslate[0],
          y: newTranslate[1],
          angle: lastAngle
        });
      }
    });
    this.state.dragging = true;
    this.$commands.emit("setAttribute", this.$context.selection.pack("x", "y", "width", "height", "angle"));
    this.renderPointers();
  }
  rotateEndVertex() {
    this.state.dragging = false;
    this.state.isRotate = false;
    this.$commands.emit("recoverCursor");
    this.$config.set("set.move.control.point", false);
    this.$context.selection.reselect();
    this.initMatrix(true);
    this.nextTick(() => {
      this.$commands.executeCommand("setAttribute", "rotate selection pointer", this.$context.selection.pack("x", "y", "width", "height", "angle"));
    });
  }
  refreshRotatePointerIcon() {
    this.$commands.emit("refreshCursor", "rotate");
  }
  refreshPointerIcon(e) {
    const dataPointer = e.$dt.data("pointer");
    if (dataPointer) {
      const pointer = dataPointer.split(",").map((it) => Number(it));
      const diff = subtract([], pointer, this.state.renderPointerList[0][4]);
      const angle = calculateAngle360(diff[0], diff[1]);
      let iconAngle = Math.floor(angle);
      this.$commands.emit("refreshCursor", "direction", `rotate(${iconAngle} 8 8)`);
    } else {
      this.$commands.emit("recoverCursor");
    }
  }
  checkPointerIsNotMoved() {
    return Boolean(this.state.dragging) === false && this.$config.false("set.move.control.point");
  }
  [POINTEROVER("$pointerRect .rotate-pointer") + IF("checkPointerIsNotMoved") + PREVENT](e) {
    this.refreshRotatePointerIcon(e);
  }
  [POINTEROVER("$pointerRect .pointer") + IF("checkPointerIsNotMoved") + PREVENT](e) {
    this.refreshPointerIcon(e);
  }
  [POINTEROUT("$pointerRect .pointer,.rotate-pointer") + IF("checkPointerIsNotMoved") + PREVENT]() {
    this.$commands.emit("recoverCursor");
  }
  [POINTERSTART("$pointerRect .pointer") + PREVENT + MOVE("moveVertex") + END("moveEndVertex")](e) {
    this.refreshPointerIcon(e);
    this.state.dragging = true;
    const num = +e.$dt.attr("data-number");
    this.state.moveType = directionType$1[`${num}`];
    this.initMousePoint = this.$viewport.getWorldPosition(e);
    this.$context.selection.reselect();
    this.state.dragging = false;
    this.initMatrix(true);
    this.cachedGroupItem = this.groupItem.matrix;
    this.$config.set("set.move.control.point", true);
    this.$context.selection.startToCacheChildren();
  }
  calculateNewOffsetMatrixInverse(vertextOffset, width2, height2, origin, itemMatrix) {
    const center2 = add$1([], TransformOrigin.scale(origin, width2, height2), negate([], vertextOffset));
    return calculateMatrixInverse(fromTranslation([], vertextOffset), fromTranslation([], center2), itemMatrix, fromTranslation([], negate([], center2)));
  }
  calculateDistance(vertext, distVector, reverseMatrix) {
    const currentVertex = clone(vertext);
    const snap = this.$context.snapManager.check([add$1([], currentVertex, distVector)], 3 / this.$viewport.scale);
    const nextVertex = add$1([], currentVertex, add$1([], distVector, snap.dist));
    var currentResult = transformMat4([], currentVertex, reverseMatrix);
    var nextResult = transformMat4([], nextVertex, reverseMatrix);
    const realDist = round$2([], subtract([], nextResult, currentResult));
    return realDist;
  }
  calculateRealDist(item, vertextIndex, distVector) {
    return this.calculateDistance(item.verties[vertextIndex], distVector, item.absoluteMatrixInverse);
  }
  moveGroupItem(lastStartVertex, newWidth, newHeight) {
    this.groupItem.reset({
      x: lastStartVertex[0] + (newWidth < 0 ? newWidth : 0),
      y: lastStartVertex[1] + (newHeight < 0 ? newHeight : 0),
      width: Math.abs(newWidth),
      height: Math.abs(newHeight)
    });
  }
  moveItemForGroup(it, newVerties, realDx = 0, realDy = 0) {
    const transformViewInverse = calculateMatrixInverse(fromTranslation([], newVerties[4]), it.itemMatrix, fromTranslation([], negate([], newVerties[4])));
    const [newX, newY] = transformMat4([], newVerties[0], transformViewInverse);
    const newWidth = distance$1(newVerties[0], newVerties[1]);
    const newHeight = distance$1(newVerties[0], newVerties[3]);
    const instance = this.$model.get(it.id);
    if (instance) {
      instance.reset({
        x: newX + realDx,
        y: newY + realDy,
        width: Math.max(Math.abs(newWidth), 1),
        height: Math.max(Math.abs(newHeight), 1)
      });
    }
  }
  recoverItemForGroup(groupItem, scaleX, scaleY, realDx = 0, realDy = 0) {
    const absoluteMatrix = groupItem.absoluteMatrix;
    const absoluteMatrixInverse = groupItem.absoluteMatrixInverse;
    this.$context.selection.cachedItemMatrices.forEach((it) => {
      const localView = calculateMatrix(it.parentMatrixInverse, absoluteMatrix, fromTranslation([], [realDx, realDy, 0]), fromScaling([], [scaleX, scaleY, 1]), absoluteMatrixInverse);
      const newVerties = vertiesMap(it.verties, localView);
      this.moveItemForGroup(it, newVerties);
    });
  }
  moveBottomRightVertex(distVector) {
    const groupItem = this.cachedGroupItem;
    let [realDx, realDy] = this.calculateRealDist(groupItem, 2, distVector);
    if (this.$config.get("bodyEvent").shiftKey) {
      realDy = realDx * groupItem.height / groupItem.width;
    }
    const newWidth = groupItem.width + realDx;
    const newHeight = groupItem.height + realDy;
    this.moveDirectionVertex(groupItem, 0, 0, newWidth, newHeight, "to top left", [0, 0, 0]);
  }
  moveTopRightVertex(distVector) {
    const groupItem = this.cachedGroupItem;
    let [realDx, realDy] = this.calculateRealDist(groupItem, 1, distVector);
    if (this.$config.get("bodyEvent").shiftKey) {
      realDy = -(realDx * groupItem.height / groupItem.width);
    }
    const newWidth = groupItem.width + realDx;
    const newHeight = groupItem.height - realDy;
    this.moveDirectionVertex(groupItem, 0, realDy, newWidth, newHeight, "to bottom left", [0, newHeight, 0]);
  }
  moveDirectionVertex(groupItem, realDx, realDy, newWidth, newHeight, direction2, directionNewVector) {
    const scaleX = newWidth / groupItem.width;
    const scaleY = newHeight / groupItem.height;
    if (scaleX >= 0 && scaleY >= 0) {
      const view = calculateMatrix(groupItem.directionMatrix[direction2], this.calculateNewOffsetMatrixInverse(directionNewVector, newWidth, newHeight, groupItem.originalTransformOrigin, groupItem.itemMatrix));
      const lastStartVertex = getTranslation([], view);
      this.moveGroupItem(lastStartVertex, newWidth, newHeight);
      this.recoverItemForGroup(groupItem, scaleX, scaleY, realDx, realDy);
    }
  }
  moveTopVertex(distVector) {
    const groupItem = this.cachedGroupItem;
    const [, realDy] = this.calculateRealDist(groupItem, 0, distVector);
    const newWidth = groupItem.width;
    const newHeight = groupItem.height - realDy;
    this.moveDirectionVertex(groupItem, 0, realDy, newWidth, newHeight, "to bottom", [newWidth / 2, newHeight, 0]);
  }
  moveBottomVertex(distVector) {
    const groupItem = this.cachedGroupItem;
    const [, realDy] = this.calculateRealDist(groupItem, 2, distVector);
    const newWidth = groupItem.width;
    const newHeight = groupItem.height + realDy;
    this.moveDirectionVertex(groupItem, 0, 0, newWidth, newHeight, "to top", [
      newWidth / 2,
      0,
      0
    ]);
  }
  moveTopLeftVertex(distVector) {
    const groupItem = this.cachedGroupItem;
    let [realDx, realDy] = this.calculateRealDist(groupItem, 0, distVector);
    if (this.$config.get("bodyEvent").shiftKey) {
      realDy = realDx * groupItem.height / groupItem.width;
    }
    const newWidth = groupItem.width - realDx;
    const newHeight = groupItem.height - realDy;
    this.moveDirectionVertex(groupItem, realDx, realDy, newWidth, newHeight, "to bottom right", [newWidth, newHeight, 0]);
  }
  moveLeftVertex(distVector) {
    const groupItem = this.cachedGroupItem;
    const [realDx] = this.calculateRealDist(groupItem, 0, distVector);
    const newWidth = groupItem.width - realDx;
    const newHeight = groupItem.height;
    this.moveDirectionVertex(groupItem, realDx, 0, newWidth, newHeight, "to right", [newWidth, newHeight / 2, 0]);
  }
  moveRightVertex(distVector) {
    const groupItem = this.cachedGroupItem;
    const [realDx] = this.calculateRealDist(groupItem, 2, distVector);
    const newWidth = groupItem.width + realDx;
    const newHeight = groupItem.height;
    this.moveDirectionVertex(groupItem, 0, 0, newWidth, newHeight, "to left", [
      0,
      newHeight / 2,
      0
    ]);
  }
  moveBottomLeftVertex(distVector) {
    const groupItem = this.cachedGroupItem;
    let [realDx, realDy] = this.calculateRealDist(groupItem, 3, distVector);
    if (this.$config.get("bodyEvent").shiftKey) {
      realDy = -(realDx * groupItem.height / groupItem.width);
    }
    const newWidth = groupItem.width - realDx;
    const newHeight = groupItem.height + realDy;
    this.moveDirectionVertex(groupItem, realDx, 0, newWidth, newHeight, "to top right", [newWidth, 0, 0]);
  }
  moveVertex() {
    const targetMousePoint = this.$viewport.getWorldPosition();
    const distVector = floor([], subtract([], targetMousePoint, this.initMousePoint));
    if (this.state.moveType === "to bottom right") {
      this.moveBottomRightVertex(distVector);
    } else if (this.state.moveType === "to top right") {
      this.moveTopRightVertex(distVector);
    } else if (this.state.moveType === "to top left") {
      this.moveTopLeftVertex(distVector);
    } else if (this.state.moveType === "to bottom left") {
      this.moveBottomLeftVertex(distVector);
    } else if (this.state.moveType === "to top") {
      this.moveTopVertex(distVector);
    } else if (this.state.moveType === "to left") {
      this.moveLeftVertex(distVector);
    } else if (this.state.moveType === "to right") {
      this.moveRightVertex(distVector);
    } else if (this.state.moveType === "to bottom") {
      this.moveBottomVertex(distVector);
    }
    this.$commands.emit("setAttribute", this.$context.selection.pack("x", "y", "width", "height"));
    this.renderPointers();
    this.state.dragging = true;
  }
  moveEndVertex() {
    this.state.dragging = false;
    this.$commands.emit("recoverCursor");
    this.$config.set("set.move.control.point", false);
    this.$context.selection.reselect();
    this.initMatrix(true);
    this.nextTick(() => {
      this.$context.selection.recoverChildren();
      this.$commands.executeCommand("setAttribute", "move selection pointer", this.$context.selection.pack("x", "y", "width", "height"));
      this.$commands.emit("recoverBooleanPath");
    });
  }
  show() {
    this.$el.show();
    this.state.show = true;
  }
  hide() {
    if (this.state.show) {
      this.$el.hide();
      this.state.show = false;
    }
  }
  initSelectionTool() {
    if (this.$el.isHide() && this.$context.selection.isMany) {
      this.show();
    } else {
      if (this.$el.isShow() && this.$context.selection.isMany === false)
        this.hide();
    }
    this.initMatrix();
    this.makeSelectionTool();
  }
  get item() {
    const verties = this.verties || rectToVerties(0, 0, 0, 0);
    if (!this.state.groupSelectionView) {
      this.state.groupSelectionView = this.$editor.createModel({ itemType: "artboard" }, false);
    }
    this.state.groupSelectionView.reset({
      parentId: this.$context.selection.currentProject.id,
      x: verties[0][0],
      y: verties[0][1],
      width: dist(verties[0], verties[1]),
      height: dist(verties[0], verties[3])
    });
    return this.state.groupSelectionView;
  }
  initMatrix() {
    if (this.$context.selection.isMany && this.state.dragging === false) {
      this.verties = clone$1(this.$context.selection.verties);
      this.angle = 0;
      this.localAngle = this.angle;
      this.groupItem = this.item;
      this.cachedGroupItem = this.item.matrix;
    }
  }
  makeSelectionTool() {
    this.renderPointers();
  }
  renderPointers() {
    if (this.$context.selection.isEmpty) {
      this.refs.$pointerRect.empty();
      return;
    }
    this.state.renderPointerList = [
      this.$viewport.applyVerties(this.$context.selection.verties)
    ];
    const { line: line2, point: point2, size: size2, elementLine } = this.createRenderPointers(this.state.renderPointerList[0]);
    this.refs.$pointerRect.updateDiff(line2 + elementLine + point2 + size2);
  }
  createPointer(pointer, number, rotate2) {
    return `
        <div    
            class='pointer' 
            data-number="${number}" 
            data-pointer="${pointer}" 
            style="transform: translate3d( calc(${pointer[0]}px - 50%), calc(${pointer[1]}px - 50%), 0px) rotateZ(${rotate2 || "0deg"})" 
        ></div>
        `;
  }
  createPointerSide(pointer, number, rotate2, width2, height2) {
    return `
        <div class='pointer' data-number="${number}" data-pointer="${pointer}" style="width: ${width2}px; height: ${height2}px;transform: translate3d( calc(${pointer[0]}px - 50%), calc(${pointer[1]}px - 50%), 0px) rotateZ(${rotate2 || "0deg"})" ></div>
        `;
  }
  createRotatePointer(pointer, number) {
    if (pointer.length === 0)
      return "";
    if (number < 4) {
      return `
            <div class='rotate-pointer no-fill' data-number="${number}" style="transform: translate3d( calc(${pointer[0]}px - 50%), calc(${pointer[1]}px - 50%), 0px) scale(1.8);" ></div>
            `;
    }
    return `
        <div class='rotate-pointer' data-number="${number}" style="transform: translate3d( calc(${pointer[0]}px - 50%), calc(${pointer[1]}px - 50%), 0px)" ></div>
        `;
  }
  createPointerRect(pointers, rotatePointer) {
    if (pointers.length === 0)
      return "";
    const centerPointer = lerp$1([], pointers[0], pointers[1], 0.5);
    const line2 = `
            M ${centerPointer[0]},${centerPointer[1]} 
            L ${rotatePointer[0]}, ${rotatePointer[1]} 
        `;
    return `
        <svg class='line' overflow="visible">
            <path 
                d="
                    M ${pointers[0][0]}, ${pointers[0][1]} 
                    L ${pointers[1][0]}, ${pointers[1][1]} 
                    L ${pointers[2][0]}, ${pointers[2][1]} 
                    L ${pointers[3][0]}, ${pointers[3][1]} 
                    L ${pointers[0][0]}, ${pointers[0][1]}
                    ${line2}
                    Z
                " />
        </svg>`;
  }
  createLine(pointers) {
    return `
            M ${pointers[0][0]}, ${pointers[0][1]} 
            L ${pointers[1][0]}, ${pointers[1][1]} 
            L ${pointers[2][0]}, ${pointers[2][1]} 
            L ${pointers[3][0]}, ${pointers[3][1]} 
            L ${pointers[0][0]}, ${pointers[0][1]}
            Z
        `;
  }
  createSize(pointers) {
    const top2 = lerp$1([], pointers[0], pointers[1], 0.5);
    const right2 = lerp$1([], pointers[1], pointers[2], 0.5);
    const bottom2 = lerp$1([], pointers[2], pointers[3], 0.5);
    const left2 = lerp$1([], pointers[3], pointers[0], 0.5);
    const worldPosition = this.$viewport.applyVertiesInverse(pointers);
    const width2 = dist(worldPosition[0], worldPosition[1]);
    const height2 = dist(worldPosition[0], worldPosition[3]);
    const list2 = [
      { start: top2, end: bottom2 },
      { start: right2, end: left2 },
      { start: bottom2, end: top2 },
      { start: left2, end: right2 }
    ].map((it, index2) => {
      return { index: index2, data: it };
    });
    list2.sort((a, b) => {
      return a.data.start[1] > b.data.start[1] ? -1 : 1;
    });
    const item = list2[0];
    const newPointer = lerp$1([], item.data.end, item.data.start, 1 + 16 / dist(item.data.start, item.data.end));
    const diff = subtract([], item.data.start, item.data.end);
    const angle = calculateAngle360(diff[0], diff[1]) + 90;
    let text2 = `${round(width2, 100)} x ${round(height2, 100)}`;
    if (this.state.isRotate) {
      const rotateZ2 = this.groupItem.angle;
      if (rotateZ2) {
        text2 = `${rotateZ2}\xB0`;
      }
    }
    return `<div class='size-pointer' style="transform: translate3d( calc(${newPointer[0]}px - 50%), calc(${newPointer[1]}px - 50%), 0px) rotateZ(${angle}deg)" >${text2}</div>`;
  }
  createRenderPointers(pointers) {
    const diff = subtract([], lerp$1([], pointers[0], pointers[1], 0.5), lerp$1([], pointers[0], pointers[2], 0.5));
    const rotate2 = Length.deg(calculateAngle360(diff[0], diff[1]) - 90).round(1e3);
    const rotatePointer = getRotatePointer(pointers, 30);
    const dist$1 = dist(pointers[0], pointers[2]);
    const width2 = dist(pointers[0], pointers[1]);
    const height2 = dist(pointers[0], pointers[3]);
    return {
      line: this.createPointerRect(pointers, rotatePointer),
      elementLine: `
                <svg class='line' overflow="visible">
                    <path 
                        d="${this.$context.selection.items.map((it) => {
        return this.createLine(this.$viewport.applyVerties(it.originVerties));
      }).join("")}
                        " />
                </svg>
            `,
      size: this.createSize(pointers),
      point: [
        this.createRotatePointer(rotatePointer, 4, "center center"),
        dist$1 < 20 ? void 0 : this.createPointerSide(lerp$1([], pointers[0], pointers[1], 0.5), 11, rotate2, width2, 5),
        dist$1 < 20 ? void 0 : this.createPointerSide(lerp$1([], pointers[1], pointers[2], 0.5), 12, rotate2, 5, height2),
        dist$1 < 20 ? void 0 : this.createPointerSide(lerp$1([], pointers[2], pointers[3], 0.5), 13, rotate2, width2, 5),
        dist$1 < 20 ? void 0 : this.createPointerSide(lerp$1([], pointers[3], pointers[0], 0.5), 14, rotate2, 5, height2),
        this.createPointer(pointers[0], 1, rotate2),
        this.createPointer(pointers[1], 2, rotate2),
        this.createPointer(pointers[2], 3, rotate2),
        this.createPointer(pointers[3], 4, rotate2)
      ].join("")
    };
  }
  checkShow() {
    if (this.state.show && this.$context.selection.isMany) {
      return true;
    }
    return false;
  }
  [SUBSCRIBE("hideSelectionToolView")]() {
    this.hide();
  }
}
var directionType = {
  1: "to top left",
  2: "to top right",
  3: "to bottom right",
  4: "to bottom left",
  11: "to top",
  12: "to right",
  13: "to bottom",
  14: "to left"
};
const SelectionToolEvent = class extends EditorElement {
  checkViewMode() {
    return this.$modeView.isCurrentMode(ViewModeType.CanvasView);
  }
  [SUBSCRIBE(REFRESH_SELECTION, REFRESH_SELECTION_TOOL) + IF("checkViewMode")]() {
    this.initSelectionTool();
  }
  [SUBSCRIBE(UPDATE_VIEWPORT) + IF("checkViewMode")]() {
    if (this.$context.selection.isOne) {
      this.initSelectionTool();
    } else {
      this.hide();
    }
  }
  [SUBSCRIBE("updateModeView")]() {
    if (this.checkViewMode()) {
      this.initSelectionTool();
    } else {
      this.hide();
    }
  }
};
class SelectionToolView extends SelectionToolEvent {
  template() {
    return `
            <div class='elf--selection-view one-selection-view' ref='$selectionView' style='display:none' >
                <div class='pointer-rect' ref='$pointerRect'></div>
            </div>
        `;
  }
  toggleEditingPath(isEditingPath) {
    this.$el.toggleClass("editing-path", isEditingPath);
  }
  [POINTERSTART("$pointerRect .rotate-pointer") + MOVE("rotateVertex") + END("rotateEndVertex")](e) {
    this.state.moveType = "rotate";
    this.initMousePoint = this.$viewport.getWorldPosition(e);
    this.$context.selection.reselect();
    this.verties = clone$1(this.$context.selection.verties);
    this.$context.snapManager.clear();
    this.rotateTargetNumber = +e.$dt.attr("data-number");
    this.refreshRotatePointerIcon();
    this.state.dragging = true;
    this.state.isRotate = true;
    this.initAngle = this.$context.selection.current.angle;
  }
  rotateVertex() {
    const targetMousePoint = this.$viewport.getWorldPosition();
    const distVector = subtract([], targetMousePoint, this.initMousePoint);
    const targetRotatePointer = this.rotateTargetNumber === 4 ? getRotatePointer(this.verties, 34) : this.verties[this.rotateTargetNumber];
    var distAngle = Math.floor(calculateAngleForVec3(targetRotatePointer, this.verties[4], distVector));
    const instance = this.$context.selection.current;
    let newAngle = this.initAngle + distAngle;
    if (instance) {
      if (this.$config.get("bodyEvent").shiftKey) {
        newAngle -= newAngle % this.$config.get("fixed.angle");
      }
      instance.angle = round(newAngle % 360, 100);
    }
    this.state.dragging = true;
    this.$commands.emit("setAttribute", this.$context.selection.pack("angle"));
    this.makeSelectionTool();
  }
  rotateEndVertex() {
    this.state.dragging = false;
    this.state.isRotate = false;
    this.$commands.emit("recoverCursor");
    this.verties = null;
    this.$commands.executeCommand("setAttribute", "change rotate", this.$context.selection.pack("angle"));
  }
  refreshRotatePointerIcon() {
    this.$commands.emit("refreshCursor", "rotate");
  }
  refreshPointerIcon(e) {
    const dataPointer = e.$dt.data("pointer");
    if (dataPointer) {
      const pointer = dataPointer.split(",").map((it) => Number(it));
      const diff = subtract([], pointer, this.state.renderPointerList[0][4]);
      const angle = calculateAngle360(diff[0], diff[1]);
      let iconAngle = Math.floor(angle);
      this.$commands.emit("refreshCursor", "direction", `rotate(${iconAngle} 8 8)`);
    } else {
      this.$commands.emit("recoverCursor");
    }
  }
  checkPointerIsNotMoved() {
    return Boolean(this.state.dragging) === false && this.$config.false("set.move.control.point");
  }
  [POINTEROVER("$pointerRect .rotate-pointer") + IF("checkPointerIsNotMoved")](e) {
    this.refreshRotatePointerIcon(e);
  }
  [POINTEROVER("$pointerRect .pointer") + IF("checkPointerIsNotMoved")](e) {
    this.refreshPointerIcon(e);
  }
  [POINTEROUT("$pointerRect .pointer,.rotate-pointer") + IF("checkPointerIsNotMoved")]() {
    this.$commands.emit("recoverCursor");
  }
  [POINTERSTART("$pointerRect .pointer") + MOVE("moveVertex") + END("moveEndVertex")](e) {
    this.refreshPointerIcon(e);
    this.state.dragging = true;
    const num = +e.$dt.attr("data-number");
    const direction2 = directionType[`${num}`];
    this.initMousePoint = this.$viewport.getWorldPosition(e);
    this.state.moveType = direction2;
    this.state.moveTarget = num;
    this.$context.snapManager.clear();
    this.verties = this.$context.selection.verties;
    this.hasRotate = this.$context.selection.current.angle !== 0;
    this.cachedCurrentItemMatrix = this.$context.selection.current.matrix;
    this.$context.selection.startToCacheChildren();
  }
  calculateDistance(vertex2, distVector, reverseMatrix) {
    const currentVertex = clone(vertex2);
    const moveVertex = add$1([], currentVertex, distVector);
    const snap = this.$context.snapManager.check([moveVertex], 3 / this.$viewport.scale);
    const nextVertex = add$1([], moveVertex, snap.dist);
    const [currentResult, nextResult] = vertiesMap([currentVertex, nextVertex], reverseMatrix);
    const realDist = subtract([], nextResult, currentResult);
    return realDist;
  }
  calculateRealDist(item, vertexIndex, distVector) {
    return this.calculateDistance(item.verties[vertexIndex], distVector, item.absoluteMatrixInverse);
  }
  moveItem(instance, lastStartVertex, newWidth, newHeight, options2 = {}) {
    if (instance) {
      let data = {
        x: lastStartVertex[0] + (newWidth < 0 ? newWidth : 0),
        y: lastStartVertex[1] + (newHeight < 0 ? newHeight : 0),
        width: Math.max(Math.abs(newWidth), 1),
        height: Math.max(Math.abs(newHeight), 1)
      };
      if (instance.isInFlex()) {
        delete data.x;
        delete data.y;
      } else if (instance.isInGrid())
        ;
      if (this.hasRotate)
        ;
      else {
        data = objectFloor(data);
      }
      instance.reset(__spreadValues(__spreadValues({}, data), options2));
    }
  }
  moveDirectionVertex(item, newWidth, newHeight, direction2, directionNewVector, options2 = {}) {
    const center2 = subtract([], TransformOrigin.scale(item.originalTransformOrigin, newWidth, newHeight), directionNewVector);
    const newOffsetInverse = calculateMatrixInverse(fromTranslation([], directionNewVector), fromTranslation([], center2), item.itemMatrix, fromTranslation([], negate([], center2)));
    const view = calculateMatrix(item.directionMatrix[direction2], newOffsetInverse);
    const lastStartVertex = getTranslation([], view);
    this.moveItem(this.$model.get(item.id), lastStartVertex, newWidth, newHeight, options2);
  }
  moveBottomRightVertex(distVector) {
    const { shiftKey, altKey, metaKey } = this.$config.get("bodyEvent");
    const item = this.cachedCurrentItemMatrix;
    if (item) {
      let [realDx, realDy] = this.calculateRealDist(item, 2, distVector);
      let directionNewVector = fromValues(0, 0, 0);
      if (altKey) {
        realDx = realDx * 2;
        realDy = realDy * 2;
      }
      if (shiftKey) {
        realDy = realDx * item.height / item.width;
      }
      const newWidth = item.width + realDx;
      const newHeight = metaKey ? newWidth : item.height + realDy;
      if (altKey) {
        directionNewVector = fromValues(realDx / 2, realDy / 2, 0);
      }
      this.moveDirectionVertex(item, newWidth, newHeight, "to top left", directionNewVector, {
        resizingVertical: ResizingMode.FIXED,
        resizingHorizontal: ResizingMode.FIXED
      });
      this.updateGridArea(item);
    }
  }
  moveTopRightVertex(distVector) {
    const { shiftKey, altKey, metaKey } = this.$config.get("bodyEvent");
    const item = this.cachedCurrentItemMatrix;
    if (item) {
      let [realDx, realDy] = this.calculateRealDist(item, 1, distVector);
      if (altKey) {
        realDx = realDx * 2;
        realDy = realDy * 2;
      }
      if (shiftKey) {
        realDy = -(realDx * item.height / item.width);
      }
      const newWidth = item.width + realDx;
      const newHeight = metaKey ? newWidth : item.height - realDy;
      let directionNewVector = fromValues(0, newHeight, 0);
      if (altKey) {
        directionNewVector = fromValues(realDx / 2, newHeight + realDy / 2, 0);
      }
      this.moveDirectionVertex(item, newWidth, newHeight, "to bottom left", directionNewVector, {
        resizingVertical: ResizingMode.FIXED,
        resizingHorizontal: ResizingMode.FIXED
      });
      this.updateGridArea(item);
    }
  }
  moveTopLeftVertex(distVector) {
    const { shiftKey, altKey, metaKey } = this.$config.get("bodyEvent");
    const item = this.cachedCurrentItemMatrix;
    if (item) {
      let [realDx, realDy] = this.calculateRealDist(item, 0, distVector);
      if (altKey) {
        realDx = realDx * 2;
        realDy = realDy * 2;
      }
      if (shiftKey) {
        realDy = realDx * item.height / item.width;
      }
      const newWidth = item.width - realDx;
      const newHeight = metaKey ? newWidth : item.height - realDy;
      let directionNewVector = fromValues(newWidth, newHeight, 0);
      if (altKey) {
        directionNewVector = fromValues(newWidth + realDx / 2, newHeight + realDy / 2, 0);
      }
      this.moveDirectionVertex(item, newWidth, newHeight, "to bottom right", directionNewVector, {
        resizingHorizontal: ResizingMode.FIXED,
        resizingVertical: ResizingMode.FIXED
      });
      this.updateGridArea(item);
    }
  }
  moveTopVertex(distVector) {
    const { altKey } = this.$config.get("bodyEvent");
    const item = this.cachedCurrentItemMatrix;
    if (item) {
      let [, realDy] = this.calculateRealDist(item, 0, distVector);
      if (altKey) {
        realDy = realDy * 2;
      }
      const newWidth = item.width;
      const newHeight = item.height - realDy;
      let directionNewVector = fromValues(newWidth / 2, newHeight, 0);
      if (altKey) {
        directionNewVector = fromValues(newWidth / 2, newHeight + realDy / 2, 0);
      }
      this.moveDirectionVertex(item, newWidth, newHeight, "to bottom", directionNewVector, {
        resizingVertical: ResizingMode.FIXED
      });
      this.updateGridArea(item);
    }
  }
  moveBottomVertex(distVector) {
    const { altKey } = this.$config.get("bodyEvent");
    const item = this.cachedCurrentItemMatrix;
    if (item) {
      let [, realDy] = this.calculateRealDist(item, 3, distVector);
      if (altKey) {
        realDy = realDy * 2;
      }
      const newWidth = item.width;
      const newHeight = item.height + realDy;
      let directionNewVector = fromValues(newWidth / 2, 0, 0);
      if (altKey) {
        directionNewVector = fromValues(newWidth / 2, realDy / 2, 0);
      }
      this.moveDirectionVertex(item, newWidth, newHeight, "to top", directionNewVector, {
        resizingVertical: ResizingMode.FIXED
      });
      this.updateGridArea(item);
    }
  }
  moveRightVertex(distVector) {
    const { shiftKey, altKey, metaKey } = this.$config.get("bodyEvent");
    const item = this.cachedCurrentItemMatrix;
    if (item) {
      let [realDx] = this.calculateRealDist(item, 1, distVector);
      if (altKey) {
        realDx = realDx * 2;
      }
      const newWidth = item.width + realDx;
      let newHeight = item.height;
      if (metaKey) {
        newHeight = newWidth;
      } else if (shiftKey) {
        newHeight = item.height * (1 + realDx / item.width);
      }
      let directionNewVector = fromValues(0, newHeight / 2, 0);
      if (altKey) {
        directionNewVector = fromValues(realDx / 2, newHeight / 2, 0);
      }
      this.moveDirectionVertex(item, newWidth, newHeight, "to left", directionNewVector, {
        resizingHorizontal: ResizingMode.FIXED
      });
      this.updateGridArea(item);
    }
  }
  moveLeftVertex(distVector) {
    const { shiftKey, altKey, metaKey } = this.$config.get("bodyEvent");
    const item = this.cachedCurrentItemMatrix;
    if (item) {
      let [realDx] = this.calculateRealDist(item, 0, distVector);
      if (altKey) {
        realDx = realDx * 2;
      }
      const newWidth = item.width - realDx;
      let newHeight = item.height;
      if (metaKey) {
        newHeight = newWidth;
      } else if (shiftKey) {
        newHeight = item.height * (1 - realDx / item.width);
      }
      let directionNewVector = fromValues(newWidth, newHeight / 2, 0);
      if (altKey) {
        directionNewVector = fromValues(newWidth + realDx / 2, newHeight / 2, 0);
      }
      this.moveDirectionVertex(item, newWidth, newHeight, "to right", directionNewVector, {
        resizingHorizontal: ResizingMode.FIXED
      });
      this.updateGridArea(item);
    }
  }
  moveBottomLeftVertex(distVector) {
    const { shiftKey, altKey, metaKey } = this.$config.get("bodyEvent");
    const item = this.cachedCurrentItemMatrix;
    if (item) {
      let [realDx, realDy] = this.calculateRealDist(item, 3, distVector);
      if (altKey) {
        realDx = realDx * 2;
        realDy = realDy * 2;
      }
      if (shiftKey) {
        realDy = -(realDx * item.height / item.width);
      }
      const newWidth = item.width - realDx;
      const newHeight = metaKey ? newWidth : item.height + realDy;
      let directionNewVector = fromValues(newWidth, 0, 0);
      if (altKey) {
        directionNewVector = fromValues(newWidth + realDx / 2, realDy / 2, 0);
      }
      this.moveDirectionVertex(item, newWidth, newHeight, "to top right", directionNewVector, {
        resizingVertical: ResizingMode.FIXED,
        resizingHorizontal: ResizingMode.FIXED
      });
      this.updateGridArea(item);
    }
  }
  moveVertex() {
    const targetMousePoint = this.$viewport.getWorldPosition();
    const distVector = floor([], subtract([], targetMousePoint, this.initMousePoint));
    if (this.state.moveType === "to top left") {
      this.moveTopLeftVertex(distVector);
    } else if (this.state.moveType === "to top") {
      this.moveTopVertex(distVector);
    } else if (this.state.moveType === "to right") {
      this.moveRightVertex(distVector);
    } else if (this.state.moveType === "to bottom") {
      this.moveBottomVertex(distVector);
    } else if (this.state.moveType === "to left") {
      this.moveLeftVertex(distVector);
    } else if (this.state.moveType === "to top right") {
      this.moveTopRightVertex(distVector);
    } else if (this.state.moveType === "to bottom right") {
      this.moveBottomRightVertex(distVector);
    } else if (this.state.moveType === "to bottom left") {
      this.moveBottomLeftVertex(distVector);
    }
    this.$context.selection.recoverChildren();
    const current = this.$context.selection.current;
    if (current.isInGrid()) {
      this.$commands.emit("setAttribute", this.$context.selection.pack("x", "y", "angle", "width", "height", "resizingHorizontal", "resizingVertical", "grid-column-start", "grid-column-end", "grid-row-start", "grid-row-end"));
    } else {
      this.$commands.emit("setAttribute", this.$context.selection.pack("x", "y", "angle", "width", "height", "resizingHorizontal", "resizingVertical"));
    }
    this.state.dragging = true;
    this.makeSelectionTool();
  }
  updateGridArea() {
    return GridLayoutEngine.updateGridArea(this.$context.selection.current, this.$context.selection.gridInformation, this.$context.viewport.scale);
  }
  moveEndVertex() {
    this.state.dragging = false;
    this.$commands.emit("recoverCursor");
    this.$context.selection.reselect();
    this.nextTick(() => {
      this.$context.selection.recoverChildren();
      if (this.$context.selection.current.isInGrid()) {
        this.$commands.executeCommand("setAttribute", "move selection pointer", this.$context.selection.pack("x", "y", "angle", "width", "height", "resizingHorizontal", "resizingVertical", "grid-column-start", "grid-column-end", "grid-row-start", "grid-row-end"));
      } else {
        this.$commands.executeCommand("setAttribute", "move selection pointer", this.$context.selection.pack("x", "y", "angle", "width", "height", "resizingHorizontal", "resizingVertical"));
      }
      this.$commands.emit("recoverBooleanPath");
    });
  }
  show() {
    this.$el.show();
    this.state.show = true;
  }
  hide() {
    this.$el.hide();
    this.state.show = false;
  }
  initSelectionTool() {
    if (this.$el.isShow() && this.$context.selection.isOne === false) {
      this.hide();
    } else if (this.$el.isHide() && this.$context.selection.isOne) {
      this.show();
    }
    this.makeSelectionTool();
  }
  makeSelectionTool() {
    this.renderPointers();
  }
  getRateDistance(startVetex, endVertex, dist$1 = 0) {
    return lerp$1([], startVetex, endVertex, (dist(startVetex, endVertex) + dist$1) / dist(startVetex, endVertex));
  }
  renderPointers() {
    if (this.$context.selection.isEmpty || this.$config.true("set.move.control.point")) {
      this.refs.$pointerRect.empty();
      return;
    }
    const verties = this.$context.selection.verties;
    if (dist(verties[0], verties[1]) === 0) {
      return;
    }
    const screenVerties = this.$viewport.applyVerties(verties);
    this.state.renderPointerList = [
      screenVerties,
      [
        this.getRateDistance(screenVerties[4], screenVerties[0], 20),
        this.getRateDistance(screenVerties[4], screenVerties[1], 20),
        this.getRateDistance(screenVerties[4], screenVerties[2], 20),
        this.getRateDistance(screenVerties[4], screenVerties[3], 20)
      ]
    ];
    const pointers = this.createRenderPointers(...this.state.renderPointerList);
    if (pointers) {
      const { line: line2, parentRect, point: point2, size: size2, visiblePath } = pointers;
      this.refs.$pointerRect.updateDiff(line2 + parentRect + point2 + size2 + visiblePath);
    }
  }
  createPointer(pointer, number, rotate2) {
    return `<div class='pointer' data-number="${number}" data-pointer="${pointer}" style="transform: translate3d( calc(${pointer[0]}px - 50%), calc(${pointer[1]}px - 50%), 0px) rotateZ(${rotate2 || "0deg"})" ></div>`;
  }
  createPointerSide(pointer, number, rotate2, width2, height2) {
    return `<div class='pointer' data-number="${number}" data-pointer="${pointer}" style="width: ${width2}px; height: ${height2}px;transform: translate3d( calc(${pointer[0]}px - 50%), calc(${pointer[1]}px - 50%), 0px) rotateZ(${rotate2 || "0deg"})" ></div>`;
  }
  createRotatePointer(pointer, number) {
    if (pointer.length === 0)
      return "";
    if (number < 4) {
      return `<div class='rotate-pointer no-fill' data-number="${number}" style="transform: translate3d( calc(${pointer[0]}px - 50%), calc(${pointer[1]}px - 50%), 0px) scale(1.8);" ></div>`;
    }
    return `<div class='rotate-pointer' data-number="${number}" style="transform: translate3d( calc(${pointer[0]}px - 50%), calc(${pointer[1]}px - 50%), 0px)" ></div>`;
  }
  createPointerRect(pointers, rotatePointer = void 0) {
    if (pointers.length === 0)
      return "";
    const current = this.$context.selection.current;
    const isArtBoard = current && current.is("artboard");
    let line2 = "";
    if (!isArtBoard && rotatePointer) {
      const centerPointer = lerp$1([], pointers[0], pointers[1], 0.5);
      line2 += `
                M ${centerPointer[0]},${centerPointer[1]} 
                L ${rotatePointer[0]},${rotatePointer[1]} 
            `;
    }
    return `<svg class='line' overflow="visible"> <path  d=" M ${pointers[0][0]}, ${pointers[0][1]} L ${pointers[1][0]}, ${pointers[1][1]} L ${pointers[2][0]}, ${pointers[2][1]} L ${pointers[3][0]}, ${pointers[3][1]} L ${pointers[0][0]}, ${pointers[0][1]} ${line2} Z" />
        </svg>`;
  }
  createParentRect(pointers = []) {
    if (pointers.length === 0)
      return "";
    return `
        <svg class='line' overflow="visible">
            <path 
                d="
                    M ${pointers[0][0]}, ${pointers[0][1]} 
                    L ${pointers[1][0]}, ${pointers[1][1]} 
                    L ${pointers[2][0]}, ${pointers[2][1]} 
                    L ${pointers[3][0]}, ${pointers[3][1]} 
                    L ${pointers[0][0]}, ${pointers[0][1]}
                    Z
                " 
                stroke="red"
                />
        </svg>`;
  }
  createSize(pointers) {
    const top2 = lerp$1([], pointers[0], pointers[1], 0.5);
    const right2 = lerp$1([], pointers[1], pointers[2], 0.5);
    const bottom2 = lerp$1([], pointers[2], pointers[3], 0.5);
    const left2 = lerp$1([], pointers[3], pointers[0], 0.5);
    const list2 = [
      { start: top2, end: bottom2 },
      { start: right2, end: left2 },
      { start: bottom2, end: top2 },
      { start: left2, end: right2 }
    ].map((it, index2) => {
      return { index: index2, data: it };
    });
    list2.sort((a, b) => {
      return a.data.start[1] > b.data.start[1] ? -1 : 1;
    });
    const item = list2[0];
    const newPointer = lerp$1([], item.data.end, item.data.start, 1 + 16 / dist(item.data.start, item.data.end));
    const width2 = this.$context.selection.current.width;
    const height2 = this.$context.selection.current.height;
    const diff = subtract([], item.data.start, item.data.end);
    const angle = calculateAngle360(diff[0], diff[1]) + 90;
    const widthPx = round(width2, 100);
    const heightPx = round(height2, 100);
    let text2 = widthPx === heightPx ? `WH: ${widthPx}` : `${round(width2, 100)} x ${round(height2, 100)}`;
    if (this.state.isRotate) {
      text2 = `${round(this.$context.selection.current.angle, 100)}\xB0`;
    }
    return `<div data-layout="${this.$context.selection.current.layout}" class='size-pointer' style="transform: translate3d( calc(${newPointer[0]}px - 50%), calc(${newPointer[1]}px - 50%), 0px) rotateZ(${angle}deg)" >${text2}</div>`;
  }
  createVisiblePath() {
    const current = this.$context.selection.current;
    if (!current)
      return "";
    if (!current.isBooleanItem) {
      return "";
    }
    const newPath = current.absolutePath();
    newPath.transformMat4(this.$viewport.matrix);
    return `
        <svg class='line' overflow="visible">
            <path
                d="${newPath.d}"
                stroke="red"
                stroke-width="2"
                fill="none"
                />
        </svg>
        `;
  }
  removeNaN(value) {
    return value.replace(/NaN/g, "0");
  }
  createRenderPointers(pointers, selectionPointers) {
    const current = this.$context.selection.current;
    if (current && current.is("text")) {
      if (current.width === 0 && current.height === 0) {
        return;
      }
    }
    const rotate2 = Length.deg(current.nestedAngle).round(1e3);
    const dist$1 = dist(pointers[0], pointers[2]);
    const width2 = dist(pointers[0], pointers[1]);
    const height2 = dist(pointers[0], pointers[3]);
    return {
      line: this.createPointerRect(pointers),
      size: this.createSize(pointers),
      parentRect: "",
      visiblePath: this.createVisiblePath(),
      point: [
        this.createRotatePointer(selectionPointers[0], 0),
        this.createRotatePointer(selectionPointers[1], 1),
        this.createRotatePointer(selectionPointers[2], 2),
        this.createRotatePointer(selectionPointers[3], 3),
        dist$1 < 20 ? void 0 : this.createPointerSide(lerp$1([], pointers[0], pointers[1], 0.5), 11, rotate2, width2, 5),
        dist$1 < 20 ? void 0 : this.createPointerSide(lerp$1([], pointers[1], pointers[2], 0.5), 12, rotate2, 5, height2),
        dist$1 < 20 ? void 0 : this.createPointerSide(lerp$1([], pointers[2], pointers[3], 0.5), 13, rotate2, width2, 5),
        dist$1 < 20 ? void 0 : this.createPointerSide(lerp$1([], pointers[3], pointers[0], 0.5), 14, rotate2, 5, height2),
        this.createPointer(pointers[0], 1, rotate2),
        this.createPointer(pointers[1], 2, rotate2),
        this.createPointer(pointers[2], 3, rotate2),
        this.createPointer(pointers[3], 4, rotate2),
        this.createPointer(pointers[4], 5, rotate2)
      ].join("")
    };
  }
  checkShow() {
    if (this.$modeView.isCurrentMode(ViewModeType.CanvasView) === false) {
      return false;
    }
    if (this.state.show && this.$context.selection.isOne) {
      return true;
    }
    return false;
  }
  [SUBSCRIBE("hideSelectionToolView")]() {
    this.hide();
  }
}
async function selectionToolView(editor) {
  editor.registerUI("canvas.view", {
    GhostToolView,
    SelectionToolView,
    GroupSelectionToolView
  }, CanvasViewToolLevel.SELECTION_TOOL);
}
var SelectorPopup$1 = "";
class SelectorPopup extends BasePopup {
  getTitle() {
    return this.$i18n("selector.popup.title");
  }
  initState() {
    return {
      selector: "",
      properties: []
    };
  }
  updateData(opt) {
    this.setState(opt, false);
    this.emit("changeSelectorPopup", this.state);
  }
  getBody() {
    return `
    <div class='elf--selector-popup' ref='$popup'>
      <div class="box">
        ${this.templateForSelector()}
        ${this.templateForProperty()}        
      </div>
    </div>`;
  }
  templateForProperty() {
    return createComponent("CSSPropertyEditor", {
      ref: "$propertyEditor",
      onchange: "changePropertyEditor"
    });
  }
  templateForSelector() {
    return `
      <div class='name'>
        <label>${this.$i18n("selector.popup.selector")}</label>
        <div class='input grid-1'>
          <input type='text' value='${this.state.selector}' ref='$selector'/>
        </div>
      </div>
    `;
  }
  [INPUT("$selector")](e) {
    if (this.refs.$selector.value.match(/^[a-zA-Z0-9:_\-.\b]+$/)) {
      this.updateData({ selector: this.refs.$selector.value });
    } else {
      e.preventDefault();
      e.stopPropagation();
      return false;
    }
  }
  refresh() {
    super.refresh();
    this.refs.$selector.val(this.state.selector);
    this.children.$propertyEditor.trigger("showCSSPropertyEditor", this.state.properties);
  }
  [SUBSCRIBE("changePropertyEditor")](properties) {
    this.updateData({
      properties
    });
  }
  [SUBSCRIBE("showSelectorPopup")](data) {
    this.setState(data);
    this.refresh();
    this.show(250);
  }
}
var SelectorProperty$1 = "";
const selectorList = [
  "",
  ":hover",
  ":active",
  ":before",
  ":after",
  ":first-child",
  ":last-child",
  ":link",
  ":active",
  ":focus"
].map((value) => ({ value }));
class SelectorProperty extends BaseProperty {
  getTitle() {
    return this.$i18n("selector.property.title");
  }
  getBody() {
    return `<div class='elf--selector-list' ref='$selectorList'></div>`;
  }
  getTools() {
    return `
      <div style='display:inline-block;'>
        ${createComponent("SelectEditor", {
      ref: "$select",
      key: "selector",
      "none-value": "selector",
      options: selectorList
    })}
      </div>
      <button type="button" ref="$add" title="add Selector">${obj$3.add}</button>
    `;
  }
  makeSelectorTemplate(selector2, index2) {
    index2 = index2.toString();
    return `
      <div class='selector-item' draggable='true' ref='$selectorIndex${index2}' data-index='${index2}'>
        <div class='title'>
          <div class='name'>
            <span>${selector2.selector || `&lt;${this.$i18n("selector.property.none")}&gt;`}</span>
          </div>
          <div class='tools'>
              <button type="button" class="del" data-index="${index2}">${obj$3.remove2}</button>
          </div>
        </div>
      </div>
    `;
  }
  [CLICK("$selectorList .selector-item .name")](e) {
    var index2 = +e.$dt.closest("selector-item").attr("data-index");
    var current = this.$context.selection.current;
    if (!current)
      return;
    this.viewSelectorPicker(index2);
  }
  [CLICK("$selectorList .selector-item .del") + PREVENT + STOP](e) {
    var removeIndex = e.$dt.attr("data-index");
    var current = this.$context.selection.current;
    if (!current)
      return;
    current.removeSelector(removeIndex);
    this.$commands.executeCommand("setAttribute", "change selectors", this.$context.selection.pack("selectors"));
    this.refresh();
  }
  [SUBSCRIBE(REFRESH_SELECTION) + DEBOUNCE(100)]() {
    this.refreshShowIsNot([
      "project",
      "svg-path",
      "svg-brush",
      "svg-textpath",
      "svg-text"
    ]);
  }
  [LOAD("$selectorList")]() {
    var current = this.$context.selection.current;
    if (!current)
      return "";
    var selectors = current.selector ? Selector.parseStyle(current) : current.selectors;
    return (selectors || []).map((selector2, index2) => {
      return this.makeSelectorTemplate(selector2, index2);
    });
  }
  [DRAGSTART("$selectorList .selector-item .title")](e) {
    this.startIndex = +e.$dt.attr("data-index");
  }
  [DRAGOVER("$selectorList .selector-item") + PREVENT]() {
  }
  [DROP("$selectorList .selector-item") + PREVENT](e) {
    var targetIndex = +e.$dt.attr("data-index");
    var current = this.$context.selection.current;
    if (!current)
      return;
    current.sortSelector(this.startIndex, targetIndex);
    this.$commands.executeCommand("setAttribute", "change selectors", this.$context.selection.pack("selectors"));
    this.refresh();
  }
  [CLICK("$add")]() {
    var current = this.$context.selection.current;
    if (current) {
      current.createSelector({
        selector: this.children.$select.getValue()
      });
      this.$commands.executeCommand("setAttribute", "change selectors", this.$context.selection.pack("selectors"));
    }
    this.refresh();
  }
  viewSelectorPicker(index2) {
    if (typeof this.selectedIndex === "number") {
      this.selectItem(this.selectedIndex, false);
    }
    this.selectedIndex = +index2;
    this.selectItem(this.selectedIndex, true);
    this.current = this.$context.selection.current;
    if (!this.current)
      return;
    this.currentSelector = this.current.selectors[this.selectedIndex];
    this.viewSelectorPropertyPopup();
  }
  selectItem(selectedIndex, isSelected = true) {
    if (isSelected) {
      this.getRef("$selectorIndex", selectedIndex).addClass("selected");
    } else {
      this.getRef("$selectorIndex", selectedIndex).removeClass("selected");
    }
    if (this.current) {
      this.current.selectors.forEach((it, index2) => {
        it.selected = index2 === selectedIndex;
      });
    }
  }
  viewSelectorPropertyPopup(position2) {
    this.current = this.$context.selection.current;
    if (!this.current)
      return;
    this.currentSelector = this.current.selectors[this.selectedIndex];
    const back = this.currentSelector;
    const selector2 = back.selector;
    const properties = back.properties;
    this.emit("showSelectorPopup", {
      position: position2,
      selector: selector2,
      properties
    });
  }
  [SUBSCRIBE("changeSelectorPopup")](data) {
    this.current = this.$context.selection.current;
    if (!this.current)
      return;
    this.currentselector = this.current.selectors[this.selectedIndex];
    if (this.currentSelector) {
      this.currentSelector.reset(data);
    }
    this.refresh();
    this.$commands.executeCommand("setAttribute", "change selectors", this.$context.selection.pack("selectors"));
  }
}
function selector(editor) {
  editor.registerUI("inspector.tab.transition", {
    SelectorProperty
  });
  editor.registerUI("popup", {
    SelectorPopup
  });
}
var SVGFilterAssetsProperty$1 = "";
class SVGFilterAssetsProperty extends BaseProperty {
  getTitle() {
    return this.$i18n("svgfilter.asset.property.title");
  }
  initState() {
    return {
      mode: "grid"
    };
  }
  getClassName() {
    return "elf--svgfilter-assets-property";
  }
  [SUBSCRIBE(REFRESH_SELECTION) + DEBOUNCE(100)]() {
    this.show();
  }
  getBody() {
    return `
      <div class='property-item svgfilter-assets'>
        <div class='svgfilter-list' ref='$svgfilterList' data-view-mode='${this.state.mode}'></div>
      </div>
    `;
  }
  [LOAD("$svgfilterList")]() {
    var current = this.$context.selection.currentProject || { svgfilters: [] };
    var svgfilters = current.svgfilters;
    var results = svgfilters.map((svgfilter, index2) => {
      var filters = svgfilter.filters.map((filter2) => {
        return SVGFilter.parse(filter2);
      });
      return `
        <div class='svgfilter-item' data-index="${index2}">
          <div class='preview' data-index="${index2}">
            <svg width="0" height="0">
              <filter id="svgfilter-${index2}">
                ${filters.join("")} 
              </filter>
            </svg>
            <div class='svgfilter-view' style='filter: url(#svgfilter-${index2});'></div>
          </div>
          <div class='title'>
            <div>
              <input type='text' class='id' data-key='id' value='${svgfilter.id}' placeholder="id" />
            </div>
          </div>
          <div class='tools'>
            <button type="button" class='copy'>${obj$3.copy}</button>          
            <button type="button" class='remove'>${obj$3.remove}</button>
          </div>
        </div>
      `;
    });
    results.push(`<div class='add-svgfilter-item'><button type="button">${obj$3.add}</button></div>`);
    return results;
  }
  executeSVGFilter(callback, isRefresh = true, isEmit = true) {
    var project2 = this.$context.selection.currentProject;
    if (project2) {
      callback && callback(project2);
      if (isRefresh)
        this.refresh();
      if (isEmit)
        this.emit("refreshSVGFilterAssets");
    } else {
      window.alert("Please select a project.");
    }
  }
  [CLICK("$svgfilterList .add-svgfilter-item")]() {
    this.executeSVGFilter((project2) => {
      project2.createSVGFilter({
        id: uuidShort(),
        filters: []
      });
    });
  }
  [CLICK("$svgfilterList .remove")](e) {
    var $item = e.$dt.closest("svgfilter-item");
    var index2 = +$item.attr("data-index");
    this.executeSVGFilter((project2) => {
      project2.removeSVGFilter(index2);
    });
  }
  [CLICK("$svgfilterList .copy")](e) {
    var $item = e.$dt.closest("svgfilter-item");
    var index2 = +$item.attr("data-index");
    this.executeSVGFilter((project2) => {
      project2.copySVGFilter(index2);
    });
  }
  [INPUT("$svgfilterList input")](e) {
    var $item = e.$dt.closest("svgfilter-item");
    var index2 = +$item.attr("data-index");
    var obj2 = e.$dt.attrKeyValue("data-key");
    this.executeSVGFilter((project2) => {
      project2.setSVGFilterValue(index2, obj2);
      this.emit("refreshSVGArea");
    }, false);
  }
  [CLICK("$svgfilterList .preview")](e) {
    var $item = e.$dt.closest("svgfilter-item");
    var index2 = +$item.attr("data-index");
    this.state.$item = $item;
    this.state.$el = e.$dt.$(".svgfilter-view");
    var currentProject = this.$context.selection.currentProject || {
      svgfilters: []
    };
    var svgfilter = currentProject.svgfilters[index2];
    this.emit("showSVGFilterPopup", {
      changeEvent: "changeSVGFilterAssets",
      id: this.id,
      index: index2,
      filters: svgfilter.filters
    });
  }
  [SUBSCRIBE("updateSVGFilterAssets")](params) {
    this.executeSVGFilter((project2) => {
      project2.setSVGFilterValue(params.index, {
        filters: params.filters
      });
      this.state.$item.$("filter").html(params.filters.join("\n"));
      this.emit("refreshSVGArea");
    }, false);
  }
  [SUBSCRIBE("changeSVGFilterAssets")](params) {
    if (params.id === this.id) {
      this.trigger("updateSVGFilterAssets", params);
    }
  }
  [SUBSCRIBE("refreshSVGFilterAssets")]() {
    this.refresh();
  }
}
function svgFilterAsset(editor) {
  editor.registerElement({
    SVGFilterAssetsProperty
  });
}
var alpha = `
1   0   0   0   0
0   1   0   0   0
0   0   1   0   0
0   0   0   .5  0 
`;
var blue = `
0   0   0   0   0
0   0   0   0   0
0   0   1   0   0
0   0   0   1   0 
`;
var BlueMagenta2 = `
1   0   0   0   0
0   0   0   0   0
0   0   1  .5   0
0   0   0   1   0 
`;
var BlueShadowMagentHightlight = `
1   0   0   0   0
0   0   0   0   0
0   0   1   1   0
0   0   0   1   0 
`;
var cyan = `
0   0   0   0   0
0   1   0   0   0
0   0   1   0   0
0   0   0   1   0 
`;
var darken = `
.5   0   0   0   0
0  .5   0   0   0
0   0  .5   0   0
0   0   0   1   0 
`;
var ElimBlue = `
1   0   0   0   0
0   1   0   0   0
0   0   1   0   0
0   0   -2   1   0 
`;
var GrayOnDark = `
0   0   1   0   0
0   0   1   0   0
0   0   1   0   0
0   0   0   1   0  
`;
var GrayOnLight = `
1   0   0   0   0
1   0   0   0   0
1   0   0   0   0
0   0   0   1   0 
`;
var GrayOnMid = `
0   1   0   0   0
0   1   0   0   0
0   1   0   0   0
0   0   0   1   0 
`;
var green = `
0   0   0   0   0
0   1   0   0   0
0   0   0   0   0
0   0   0   1   0 
`;
var HardGreen = `
1   0   0   0   0
0   1   0   1   0
0   0   1   0   0
0   0   0   1   0 
`;
var HardYellow = `
1   0   0   1   0
0   1   0   1   0
0   0   1   0   0
0   0   0   1   0 
`;
var IdenticalRedOverlay = `
1   0   0   0   0
0   0   0   0   0
0   0   0   0   0
0   0   0   1   0 
`;
var lighten = `
1.5   0   0   0   0
0   1.5   0   0   0
0   0   1.5   0   0
0   0   0   1   0 
`;
var lime = `
1   0   0   0   0
0   2   0   0   0
0   0   0  .5   0
0   0   0   1   0 
`;
var magenta = `
1   0   0   0   0
0   0   0   0   0
0   0   1   0   0
0   0   0   1   0 
`;
var NoGreenMagenta = `
1   1   0   0   0
0   0   0   0   0
0   1   1   0   0
0   0   0   1   0 
`;
var NoGreenRed = `
1   1   0   0   0
0   0   0   0   0
0   0   1   0   0
0   0   0   1   0 
`;
var peachy = `
1   0   0   0   0
0  .5   0   0   0
0   0   0  .5   0
0   0   0   1   0 
`;
var red = `
1   0   0   0   0
0   0   0   0   0
0   0   0   0   0
0   0   0   1   0
`;
var RedOverlay = `
1   0   0   0   0
0   0   0   0   0
0   0   1  -1   0
0   0   0   1   0 
`;
var yellow = `
1   0   0   0   0
0   1   0   0   0
0   0   0   0   0
0   0   0   1   0 
`;
var YesGreenColorizedMagenta = `
1   1   0   0   0
0   1   0   0   0
0   1   1   0   0
0   0   0   1   0 
`;
var colormatrix = {
  red,
  green,
  blue,
  yellow,
  magenta,
  cyan,
  alpha,
  BlueMagenta2,
  BlueShadowMagentHightlight,
  darken,
  ElimBlue,
  GrayOnDark,
  GrayOnLight,
  GrayOnMid,
  HardGreen,
  HardYellow,
  IdenticalRedOverlay,
  lighten,
  lime,
  NoGreenMagenta,
  NoGreenRed,
  peachy,
  RedOverlay,
  YesGreenColorizedMagenta
};
var ColorMatrixEditor$1 = "";
const COLUMN = 6;
const sampleList = Object.keys(colormatrix).map((it) => {
  return { title: it, values: colormatrix[it] };
});
class ColorMatrixEditor extends EditorElement {
  initState() {
    return {
      values: normalize(this.props.values)
    };
  }
  template() {
    return `
            <div class='elf--color-matrix-editor' >
                <div ref='$body'></div>
                <div class='title'> Mix Color Template </div>
                <div class='color-matrix-template' ref='$sample'></div>
            </div>
        `;
  }
  [BIND("$body")]() {
    return {
      cssText: `
                display: grid;
                grid-template-columns: repeat(${COLUMN}, 1fr);
                grid-column-gap: 2px;
                grid-row-gap: 2px;
                text-align: left; 
            `
    };
  }
  [LOAD("$sample")]() {
    return sampleList.map((it, index2) => {
      return `<div class='sample-item' title='${it.title}' data-index="${index2}">${it.title}</div>`;
    });
  }
  [CLICK("$sample .sample-item")](e) {
    var index2 = +e.$dt.attr("data-index");
    var sample2 = sampleList[index2];
    this.updateData({
      values: normalize(sample2.values)
    });
    this.load("$body");
  }
  [LOAD("$body")]() {
    var { values } = this.state;
    var text2 = ["R", "G", "B", "A"];
    var a = values.map((value, index2) => {
      var h = "";
      if (index2 % (COLUMN - 1) === 0) {
        h = `<div>${text2[Math.floor(index2 / (COLUMN - 1))]}</div>`;
      }
      var result = `
                ${h}
                <div class='number-editor'>
                    <input type="number" value="${value}" step="0.01" data-index="${index2}" />
                </div>
            `;
      return result;
    });
    var header = `
            <div></div>
            <div>R</div>
            <div>G</div>
            <div>B</div>
            <div>A</div>
            <div>M</div>
        `;
    return header + a;
  }
  updateData(data) {
    this.setState(data, false);
    this.parent.trigger(this.props.onchange, this.props.key, this.state.values, this.props.params);
  }
  [INPUT("$body input")](e) {
    var $el = e.$dt;
    var index2 = +$el.attr("data-index");
    var value = +$el.value;
    this.state.values[index2] = value;
    this.updateData();
  }
}
var FuncFilterEditor$1 = "";
class FuncFilterEditor extends EditorElement {
  initState() {
    return __spreadValues({
      label: this.props.label || ""
    }, this.parse(this.props.value));
  }
  parse(value) {
    var [type, ...values] = value.split(" ");
    if (type === "linear") {
      var [slop, intercept] = values;
    } else if (type === "gamma") {
      var [amplitude, exponent, offset] = values;
    }
    return {
      type,
      values,
      slop,
      intercept,
      amplitude,
      exponent,
      offset
    };
  }
  template() {
    return `<div class='small-editor func-filter' ref='$body'></div>`;
  }
  [LOAD("$body")]() {
    var { type, label } = this.state;
    var hasLabel = label ? "has-label" : "";
    return `
            ${createComponent("SelectEditor", {
      label,
      ref: "$type",
      key: "type",
      value: this.state.type,
      options: ["identity", "table", "discrete", "linear", "gamma"],
      onchange: "changeType"
    })}
        <div class='elf--func-filter-editor ${hasLabel}' ref='$container' data-selected-type='${type}'>
            ${label ? `<label></label>` : ""}
            <div data-type='identity'>
            </div>
            <div data-type='table'>
                ${createComponent("TextEditor", {
      label: "tableValues",
      ref: "$values",
      key: "values",
      value: this.state.values.join(" "),
      onchange: (key, value) => {
        this.updateData({
          [key]: value.split(" ")
        });
      }
    })}
            </div>
            <div data-type='linear'>
                ${["slop", "intercept"].map((it) => {
      return `
                        <div>
                            ${createComponent("NumberRangeEditor", {
        label: it,
        ref: `$${it}`,
        key: it,
        value: this.state[it],
        onchange: (key, value) => {
          this.updateData({
            [key]: value
          });
        }
      })}
                        </div>                    
                    `;
    }).join("")}
            </div>
            <div data-type='gamma'>
                ${["amplitude", "exponent", "offset"].map((it) => {
      return `
                        <div>
                            ${createComponent("NumberRangeEditor", {
        label: it,
        ref: `$${it}`,
        key: it,
        value: this.state[it],
        onchange: (key, value) => {
          this.updateData({
            [key]: value
          });
        }
      })}
                        </div>                    
                    `;
    }).join("")}            
            </div>                                                
        </div>
    `;
  }
  [SUBSCRIBE("changeType")](key, type) {
    this.updateData({ type });
    this.refresh();
  }
  getValue() {
    switch (this.state.type) {
      case "table":
      case "discrete":
        return [this.state.type, ...this.state.values].join(" ");
      case "linear":
        return [this.state.type, this.state.slop, this.state.intercept].join(" ");
      case "gamma":
        return [
          this.state.type,
          this.state.amplitude,
          this.state.exponent,
          this.state.offset
        ].join(" ");
    }
    return "identity";
  }
  setValue(value) {
    this.setState(__spreadValues({}, this.parse(value)));
  }
  updateData(data) {
    this.setState(data, false);
    this.parent.trigger(this.props.onchange, this.props.key, this.getValue(), this.props.params);
  }
}
var dancingStroke = [
  {
    type: "SourceAlpha",
    id: "strokeSource",
    bound: { x: 100, y: 100 },
    connected: [
      {
        id: "morphology"
      }
    ]
  },
  {
    type: "Morphology",
    id: "morphology",
    operator: "dilate",
    radius: "3 3",
    bound: { x: 100, y: 200 },
    in: [{ id: "strokeSource" }],
    connected: [{ id: "composite" }]
  },
  {
    type: "Flood",
    id: "flood",
    bound: { x: 100, y: 200 },
    color: "#30597E",
    opacity: 1,
    connected: [{ id: "composite" }]
  },
  {
    type: "Composite",
    id: "composite",
    bound: { x: 400, y: 150 },
    in: [{ id: "flood" }, { id: "morphology" }],
    operator: "in",
    connected: [
      {
        id: "composite2"
      }
    ]
  },
  {
    type: "SourceAlpha",
    id: "strokeSourceAlpha2",
    bound: { x: 400, y: 200 },
    connected: [
      {
        id: "composite2"
      }
    ]
  },
  {
    type: "Composite",
    id: "composite2",
    bound: { x: 400, y: 150 },
    in: [{ id: "composite" }, { id: "strokeSourceAlpha2" }],
    operator: "out",
    connected: [
      {
        id: "displacementMap"
      }
    ]
  },
  {
    type: "Turbulence",
    id: "turbulence",
    filterType: "fractalNoise",
    baseFrequency: "0.01 0.02",
    numOctaves: 1,
    seed: 0,
    stitchTiles: "stitch",
    bound: { x: 400, y: 200 },
    connected: [
      {
        id: "displacementMap"
      }
    ]
  },
  {
    type: "DisplacementMap",
    id: "displacementMap",
    scale: 17,
    xChannelSelector: "A",
    yChannelSelector: "A",
    bound: { x: 400, y: 200 },
    in: [{ id: "composite2" }, { id: "turbulence" }],
    connected: [
      {
        id: "merge"
      }
    ]
  },
  {
    type: "SourceGraphic",
    id: "strokeSourceGraphic",
    bound: { x: 400, y: 200 },
    connected: [
      {
        id: "merge"
      }
    ]
  },
  {
    type: "Merge",
    id: "merge",
    bound: { x: 500, y: 150 },
    in: [{ id: "strokeSourceGraphic" }, { id: "displacementMap" }]
  }
];
var grayscale = [
  {
    type: "Saturate",
    values: "0"
  }
];
var innerShadow = [
  {
    type: "Flood",
    id: "flood",
    bound: { x: 100, y: 200 },
    color: "black",
    opacity: 1,
    connected: [{ id: "composite1" }]
  },
  {
    type: "SourceAlpha",
    id: "shadowSource",
    bound: { x: 100, y: 100 },
    connected: [
      {
        id: "composite1"
      }
    ]
  },
  {
    type: "Composite",
    id: "composite1",
    bound: { x: 200, y: 150 },
    in: [{ id: "flood" }, { id: "shadowSource" }],
    operator: "out",
    connected: [
      {
        id: "offset"
      }
    ]
  },
  {
    type: "Offset",
    id: "offset",
    bound: { x: 300, y: 150 },
    dx: 4,
    dy: 4,
    in: [{ id: "composite1" }],
    connected: [{ id: "blur" }]
  },
  {
    type: "GaussianBlur",
    id: "blur",
    bound: { x: 400, y: 150 },
    stdDeviationX: 4,
    stdDeviationY: 4,
    edge: "none",
    in: [{ id: "offset" }],
    connected: [
      {
        id: "composite2"
      }
    ]
  },
  {
    type: "SourceAlpha",
    id: "shadowSource2",
    bound: { x: 400, y: 250 },
    connected: [
      {
        id: "composite2"
      }
    ]
  },
  {
    type: "Composite",
    id: "composite2",
    bound: { x: 500, y: 150 },
    in: [{ id: "blur" }, { id: "shadowSource2" }],
    operator: "out",
    connected: [
      {
        id: "merge"
      }
    ]
  },
  {
    type: "SourceGraphic",
    id: "shadowSource3",
    bound: { x: 500, y: 250 },
    connected: [
      {
        id: "merge"
      }
    ]
  },
  {
    type: "Merge",
    id: "merge",
    bound: { x: 600, y: 150 },
    in: [{ id: "composite2" }, { id: "shadowSource3" }]
  }
];
var shadow = [
  {
    type: "SourceAlpha",
    id: "shadowSource",
    bound: { x: 100, y: 100 },
    connected: [
      {
        id: "offset"
      }
    ]
  },
  {
    type: "Offset",
    id: "offset",
    bound: { x: 200, y: 100 },
    dx: 10,
    dy: 10,
    in: [{ id: "shadowSource" }],
    connected: [{ id: "blur" }]
  },
  {
    type: "GaussianBlur",
    id: "blur",
    bound: { x: 300, y: 100 },
    stdDeviationX: 5,
    stdDeviationY: 5,
    in: [{ id: "offset" }],
    connected: [
      {
        id: "composite"
      }
    ]
  },
  {
    type: "Flood",
    id: "flood",
    bound: { x: 100, y: 200 },
    color: "black",
    opacity: 0.7,
    connected: [{ id: "composite" }]
  },
  {
    type: "Composite",
    id: "composite",
    bound: { x: 400, y: 150 },
    in: [{ id: "flood" }, { id: "blur" }],
    operator: "in",
    connected: [
      {
        id: "merge"
      }
    ]
  },
  {
    type: "SourceAlpha",
    id: "shadowSource2",
    bound: { x: 400, y: 200 },
    connected: [
      {
        id: "merge"
      }
    ]
  },
  {
    type: "Merge",
    id: "merge",
    bound: { x: 500, y: 150 },
    in: [{ id: "composite" }, { id: "shadowSource2" }]
  }
];
var stroke = [
  {
    type: "SourceAlpha",
    id: "strokeSource",
    bound: { x: 100, y: 100 },
    connected: [
      {
        id: "morphology"
      }
    ]
  },
  {
    type: "Morphology",
    id: "morphology",
    operator: "dilate",
    radius: "3 3",
    bound: { x: 100, y: 200 },
    in: [{ id: "strokeSource" }],
    connected: [{ id: "composite" }]
  },
  {
    type: "Flood",
    id: "flood",
    bound: { x: 100, y: 200 },
    color: "#30597E",
    opacity: 1,
    connected: [{ id: "composite" }]
  },
  {
    type: "Composite",
    id: "composite",
    bound: { x: 400, y: 150 },
    in: [{ id: "flood" }, { id: "morphology" }],
    operator: "in",
    connected: [
      {
        id: "merge"
      }
    ]
  },
  {
    type: "SourceGraphic",
    id: "strokeSourceGraphic",
    bound: { x: 400, y: 200 },
    connected: [
      {
        id: "merge"
      }
    ]
  },
  {
    type: "Merge",
    id: "merge",
    bound: { x: 500, y: 150 },
    in: [{ id: "composite" }, { id: "strokeSourceGraphic" }]
  }
];
var svgFilterPreset = {
  dancingStroke,
  stroke,
  grayscale,
  shadow,
  innerShadow
};
var SVGFilterEditor$1 = "";
const filterTypes = [
  {
    label: "GRAPHIC REFERENCES",
    items: [
      { label: "Source Graphic", value: "SourceGraphic" },
      { label: "Source Alpha", value: "SourceAlpha" },
      { label: "Background Image", value: "BackgroundImage" },
      { label: "Background Alpha", value: "BackgroundAlpha" },
      { label: "Fill Paint", value: "FillPaint" },
      { label: "Stroke Paint", value: "StrokePaint" }
    ]
  },
  {
    label: "SOURCES",
    items: [
      { label: "Flood", value: "Flood" },
      { label: "Turbulence", value: "Turbulence" },
      { label: "Image", value: "Image" }
    ]
  },
  {
    label: "MODIFIER",
    items: [
      { label: "Color Matrix", value: "ColorMatrix" },
      { label: "Saturate", value: "Saturate" },
      { label: "HueRotate", value: "HueRotate" },
      { label: "LuminanceToAlpha", value: "LuminanceAlpha" },
      { label: "Drop Shadow", value: "DropShadow" },
      { label: "Morphology", value: "Morphology" },
      { label: "Convolve Matrix", value: "ConvolveMatrix" },
      { label: "Offset", value: "Offset" },
      { label: "Gaussian Blur", value: "GaussianBlur" },
      { label: "Tile", value: "Tile" }
    ]
  },
  {
    label: "LIGHTING",
    items: [
      { label: "Specular Lighting", value: "SpecularLighting" },
      { label: "Diffuse Lighting", value: "DiffuseLighting" },
      { label: "Point Light", value: "PointLight" },
      { label: "Spot Light", value: "SpotLight" },
      { label: "Distant Light", value: "DistantLight" }
    ]
  },
  {
    label: "COMBINERS",
    items: [
      { label: "Blend", value: "Blend" },
      { label: "Composite", value: "Composite" },
      { label: "Merge", value: "Merge" },
      { label: "DisplacementMap", value: "DisplacementMap" }
    ]
  }
];
const SVGFilterTemplateList = [
  {
    label: "Template",
    items: [
      { label: "Grayscale", value: "grayscale" },
      { label: "Shadow", value: "shadow" },
      { label: "Inner Shadow", value: "innerShadow" },
      { label: "Stroke", value: "stroke" },
      { label: "Dancing Stroke", value: "dancingStroke" }
    ]
  }
];
function getIcon(type) {
  switch (type) {
    case "SpecularLighting":
      return iconUse("specular");
    case "DiffuseLighting":
      return iconUse("diffuse");
    case "SourceGraphic":
    case "SourceAlpha":
      return iconUse("image");
    case "BackgroundImage":
    case "BackgroundAlpha":
      return iconUse("outline_image");
    case "Flood":
      return iconUse("palette");
    case "Image":
      return iconUse("landscape");
    case "GaussianBlur":
      return iconUse("blur");
    case "ColorMatrix":
      return iconUse("blur_linear");
    case "Turbulence":
      return iconUse("waves");
    case "Saturate":
      return iconUse("vintage");
    case "HueRotate":
      return iconUse("looks");
    case "LuminanceAlpha":
      return iconUse("opacity");
    case "DropShadow":
      return iconUse("shadow");
    case "Morphology":
      return iconUse("broken_image");
    case "ConvolveMatrix":
      return iconUse("camera_roll");
    case "Offset":
      return iconUse("transform");
    case "Tile":
      return iconUse("view_comfy");
    case "Blend":
      return iconUse("gradient");
    case "Composite":
      return iconUse("merge");
    case "Merge":
      return iconUse("settings_input_component");
    case "DisplacementMap":
      return iconUse("texture");
  }
  return "";
}
function getSourceTypeString(type) {
  switch (type) {
    case "SourceGraphic":
    case "SourceAlpha":
    case "BackgroundImage":
    case "BackgroundAlpha":
    case "FillPaint":
    case "StrokePaint":
      return "graphic";
    case "Flood":
    case "Turbulence":
    case "Image":
      return "source";
    case "GaussianBlur":
    case "ColorMatrix":
    case "Saturate":
    case "HueRotate":
    case "LuminanceAlpha":
    case "DropShadow":
    case "Morphology":
    case "ConvolveMatrix":
    case "Offset":
    case "Tile":
      return "modifier";
    case "SpecularLighting":
    case "DiffuseLighting":
    case "SpotLight":
    case "PointLight":
    case "DistantLight":
      return "lighting";
    case "Blend":
    case "Composite":
    case "Merge":
    case "DisplacementMap":
      return "combiner";
  }
  return "";
}
const width = 40;
const half_height = 20;
const connectedXAxis = {
  1: [width + 5]
};
const connectedYAxis = {
  1: [half_height]
};
const inXAxis = {
  1: [-7],
  2: [-7],
  3: [-7],
  4: [-7],
  5: [-7]
};
let inYAxis = {
  1: [0],
  2: [-7, 7],
  3: [-14, 0, 14],
  4: [-21, -7, 7, 21],
  5: [-28, -14, 0, 14, 28]
};
Object.keys(inYAxis).forEach((len2) => {
  inYAxis[len2] = inYAxis[len2].map((it) => it + half_height);
});
class SVGFilterEditor extends EditorElement {
  makeFilterSelect() {
    return `
  
    <div class='filter-item-list' ref="$filterSelect">
  
      ${mapjoin(filterTypes, (f) => {
      return `
          <div class='group' label="${this.$i18n(f.label)}">
            ${mapjoin(f.items, (i) => {
        return `
                <div class='item' draggable="true" value="${i.value}">
                  <span class='icon'>${getIcon(i.value)}</span>
                  ${this.$i18n(i.label)}
                </div>
                `;
      })}
          </div>
        `;
    })}
    </div>
    `;
  }
  makeFilterTemplateSelect() {
    return `
  
    <div class='filter-item-list' ref="$filterTemplateSelect">
  
      ${mapjoin(SVGFilterTemplateList, (f) => {
      return `
          <div class='group' label="${this.$i18n(f.label)}">
            ${mapjoin(f.items, (i) => {
        return ` <div class='item' draggable="true" value="${i.value}">${this.$i18n(i.label)}</div>`;
      })}
          </div>
        `;
    })}
    </div>
    `;
  }
  initState() {
    var filters = this.parseFilter(this.props.value || []);
    return {
      filters,
      selectedTabIndex: 1,
      selectedIndex: -1,
      selectedFilter: null
    };
  }
  template() {
    return `
      <div class='elf--svg-filter-editor filter-list'>
        <div class='left'>
          <div class="tab number-tab" ref="$tab">
            <div class="tab-header full" ref="$header">
              <div class="tab-item selected" data-value="1" title='Item'>
                <label class='icon'>${this.$i18n("svg.filter.editor.tab.filter")}</label>
              </div>
              <div class="tab-item" data-value="2" title="Preset">
                <label class='icon'>${this.$i18n("svg.filter.editor.tab.preset")}</label>
              </div>
              <div class="tab-item" data-value="3" title="Asset">
                <label class='icon'>${this.$i18n("svg.filter.editor.tab.asset")}</label>
              </div>
            </div>
            <div class="tab-body">
              <div class="tab-content scrollbar selected" data-value="1">
                ${this.makeFilterSelect()}
              </div>
              <div class="tab-content  scrollbar" data-value="2">
                ${this.makeFilterTemplateSelect()}
              </div>
                     
            </div>
          </div>
        </div>
        <div  class='center'>
          <div class='graph'>
            <div class='drag-line-panel' ref='$dragLinePanel'></div>          
            <div class='connected-line-panel' ref='$connectedLinePanel'></div>
            <div class='graph-panel' ref='$graphPanel' droppable="true"></div>
          </div>
        </div>
        <div class='right'>
          <div class='filter-list' ref='$filterList'></div>
        </div>
      </div>`;
  }
  [CLICK("$header .tab-item:not(.empty-item)")](e) {
    var selectedTabIndex = +e.$dt.attr("data-value");
    if (this.state.selectedTabIndex === selectedTabIndex) {
      return;
    }
    this.$el.$$(`[data-value="${this.state.selectedTabIndex}"]`).forEach((it) => it.removeClass("selected"));
    this.$el.$$(`[data-value="${selectedTabIndex}"]`).forEach((it) => it.addClass("selected"));
    this.setState({ selectedTabIndex }, false);
  }
  [DRAGSTART("$filterSelect .item")](e) {
    var filter2 = e.$dt.attr("value");
    e.dataTransfer.setData("filter/type", filter2);
  }
  [DRAGOVER("$connectedLinePanel") + PREVENT]() {
  }
  [DROP("$connectedLinePanel") + PREVENT](e) {
    var offset = { x: e.offsetX, y: e.offsetY };
    var filterType = e.dataTransfer.getData("filter/type");
    this.makeFilterNode(filterType, { bound: offset });
  }
  makeFilterNode(filterType, opt = {}) {
    this.state.filters.push(this.makeFilter(filterType, opt));
    this.state.selectedIndex = this.state.filters.length - 1;
    this.state.selectedFilter = this.state.filters[this.state.selectedIndex];
    this.refresh();
    this.modifyFilter();
  }
  applyTemplate(templateType) {
    var template = svgFilterPreset[templateType];
    if (template) {
      this.setState({
        selectedIndex: -1,
        selectedFilter: null,
        filters: this.parseFilter(template)
      }, false);
      this.refresh();
      this.modifyFilter();
    }
  }
  getSpec(filterType) {
    return SVGFilterSpecList[filterType];
  }
  makeFilterEditorTemplate(s, filter2, key) {
    var objectId = `${filter2.type}${key}${this.state.selectedIndex}${Date.now()}`;
    if (s.inputType === "color-matrix") {
      return createComponent("ColorMatrixEditor", {
        ref: `$colorMatrix${objectId}`,
        label: s.title,
        key,
        column: s.column,
        values: filter2[key].join(" "),
        onchange: "changeRangeEditor"
      });
    } else if (s.inputType === "input-array") {
      return createComponent("InputArrayEditor", {
        ref: `$inputArray${objectId}`,
        label: s.title,
        key,
        "column-label": "R,G,B,A,M",
        "row-label": "R,G,B,A",
        column: s.column,
        values: filter2[key].join(" "),
        onchange: "changeRangeEditor"
      });
    } else if (s.inputType === "blend") {
      return createComponent("BlendSelectEditor", {
        ref: `$blend${objectId}`,
        label: s.title,
        key,
        value: filter2[key].toString(),
        onchange: "changeRangeEditor"
      });
    } else if (s.inputType === "select") {
      var options2 = s.options;
      if (isFunction(s.options)) {
        options2 = s.options(this.state.filters);
      }
      return createComponent("SelectEditor", {
        ref: `$select${objectId}`,
        label: s.title,
        options: options2,
        key,
        value: filter2[key].toString(),
        onchange: "changeRangeEditor"
      });
    } else if (s.inputType === "text") {
      return createComponent("TextEditor", {
        ref: `$text${objectId}`,
        label: s.title,
        key,
        value: filter2[key].toString(),
        onchange: "changeTextEditor"
      });
    } else if (s.inputType === "number-range") {
      return createComponent("NumberRangeEditor", {
        ref: `$numberrange${objectId}`,
        label: s.title,
        layout: "block",
        min: s.min,
        max: s.max,
        step: s.step,
        key,
        value: filter2[key].toString(),
        onchange: "changeRangeEditor"
      });
    } else if (s.inputType === "color") {
      return createComponent("ColorViewEditor", {
        ref: `$colorview${objectId}`,
        label: s.title,
        key,
        value: filter2[key].toString(),
        onchange: "changeRangeEditor"
      });
    } else if (s.inputType === "FuncFilter") {
      return createComponent("FuncFilterEditor", {
        ref: `$funcFilter${objectId}`,
        label: s.title,
        key,
        value: filter2[key].toString(),
        onchange: "changeFuncFilterEditor"
      });
    } else if (s.inputType === "ImageSelectEditor") {
      return createComponent("ImageSelectEditor", {
        ref: `$imageSelect${objectId}`,
        label: s.title,
        key,
        value: filter2[key].toString(),
        onchange: "changeRangeEditor"
      });
    }
    return createComponent("RangeEditor", {
      ref: `$range${objectId}`,
      layout: "block",
      label: s.title,
      min: s.min,
      max: s.max,
      step: s.step,
      key,
      value: filter2[key].toString(),
      units: s.units,
      onchange: "changeRangeEditor"
    });
  }
  makeOneFilterTemplate(spec, filter2) {
    return `
    <div class="filter-item">
      <div class="title">
        <label>${filter2.type}</label>
        <div class="filter-menu">
          <button type="button" class="del">${iconUse("remove")}</button>
        </div>
      </div>
      <div class="filter-ui">
        ${keyMapJoin(spec, (key, value) => {
      return this.makeFilterEditorTemplate(value, filter2, key);
    })}

      </div>
    </div>
  `;
  }
  makeFilterTemplate(filter2) {
    return this.makeOneFilterTemplate(this.getSpec(filter2.type), filter2);
  }
  [LOAD("$filterList")]() {
    if (this.state.selectedFilter && this.state.selectedFilter.isSource() === false) {
      return this.makeFilterTemplate(this.state.selectedFilter);
    }
    return "";
  }
  modifyFilter() {
    this.state.filters.forEach((f) => {
      if (f.isLight() && f.connected.length) {
        f.connected.forEach((c2) => {
          this.state.filters.filter((s) => s.id === c2.id).forEach((lightManager) => {
            lightManager.reset({
              lightInfo: f.toLightString()
            });
          });
        });
      }
    });
    this.parent.trigger(this.props.onchange, this.props.key, this.state.filters);
  }
  parseFilter(list2 = []) {
    return list2.map((it) => SVGFilter.parse(it));
  }
  makeFilter(type, opt = {}) {
    return SVGFilter.parse(__spreadProps(__spreadValues({}, opt), { type }));
  }
  [CLICK("$filterSelect .item[value]")](e) {
    var filterType = e.$dt.attr("value");
    this.makeFilterNode(filterType);
  }
  [CLICK("$filterTemplateSelect .item[value]")](e) {
    var templateType = e.$dt.attr("value");
    this.applyTemplate(templateType);
  }
  [CLICK("$filterList .filter-menu .del")]() {
    this.removeFilter(this.state.selectedFilter.id);
  }
  [LOAD("$graphPanel")]() {
    return this.makeGraphPanel();
  }
  selectFilter(index2) {
    this.setState({
      selectedIndex: index2,
      selectedFilter: this.state.filters[index2]
    }, false);
    this.load("$filterList");
  }
  [POINTERSTART("$graphPanel .filter-node") + MOVE() + END()](e) {
    this.$target = e.$dt;
    this.$point = null;
    this.pointType = "object";
    this.pointIndex = 0;
    var rect2 = this.refs.$graphPanel.rect();
    this.rect = rect2;
    var index2 = +this.$target.attr("data-index");
    this.selectFilter(index2);
    this.$target.onlyOneClass("selected");
    var pointer = Dom.create(e.target);
    if (pointer.hasClass("out")) {
      this.$point = pointer;
      this.pointType = "out";
      this.pointIndex = 0;
    } else if (pointer.hasClass("in")) {
      this.$point = pointer;
      this.pointType = "in";
      this.pointIndex = +pointer.attr("data-index");
    } else {
      var filter2 = this.state.selectedFilter;
      this.startXY = clone$1(filter2.bound);
    }
    if (this.pointType === "in" || this.pointType === "out") {
      var inRect = pointer.rect();
      var x = inRect.x - rect2.x;
      var y = inRect.y - rect2.y;
      var centerX = x + inRect.width / 2;
      var centerY = y + inRect.height / 2;
      this.startXY = { x: centerX, y: centerY };
    }
    this.startXY.dx = 0;
    this.startXY.dy = 0;
    this.load("$dragLinePanel");
  }
  [LOAD("$dragLinePanel")]() {
    if (this.pointType === "in" || this.pointType === "out") {
      var { x, y, dx, dy } = this.startXY;
      return `
      <svg>
        <path 
          class="drag-line"
          fill="transparent"
          stroke-width="1"
          d="
            M${x},${y}
            L${x + dx},${y + dy} 
            Z
          "
        />
      </svg>
      `;
    } else {
      return "";
    }
  }
  makeConnectedPath(points) {
    var manager = new PathStringManager();
    var first = points[0];
    var last = points[points.length - 1];
    if (!first)
      return "";
    if (!last)
      return "";
    var dist2 = Math.abs(first.x - last.x) / 2;
    manager.M(first).C({ x: first.x + dist2, y: first.y }, { x: last.x - dist2, y: last.y }, last);
    return manager.d;
  }
  createPath(sourceItem, connectedInfo) {
    if (connectedInfo.path) {
      return connectedInfo.path;
    }
    var sourceX = sourceItem.bound.x + connectedXAxis["1"][0];
    var sourceY = sourceItem.bound.y + connectedYAxis["1"][0];
    var target = this.state.filters.map((it, index3) => {
      return { it, index: index3 };
    }).find((it) => {
      if (!it)
        return false;
      if (!it.it)
        return false;
      return it && it.it.id === connectedInfo.id;
    });
    var len2 = `${target.it.getInCount()}`;
    var source2 = target.it.in.map((it, index3) => {
      return { it, index: index3 };
    }).find((it) => {
      if (!it)
        return false;
      if (!it.it)
        return false;
      return it.it.id === sourceItem.id;
    });
    if (!source2) {
      return [];
    }
    var index2 = source2.index;
    var targetX = target.it.bound.x + inXAxis[len2][0];
    var targetY = target.it.bound.y + inYAxis[len2][index2];
    return [
      { x: sourceX, y: sourceY },
      { x: targetX, y: targetY }
    ];
  }
  [LOAD("$connectedLinePanel")]() {
    return `
      <svg>
        ${this.state.filters.map((it) => {
      return it.connected.map((connectedItem) => {
        var path = this.createPath(it, connectedItem);
        var sourceType = getSourceTypeString(it.type);
        return `
              <path 
                class="connected-line"
                data-source-type="${sourceType}"
                d="${this.makeConnectedPath(path)}"
              />

              ${path.length && `
                <circle 
                  data-source-type="${sourceType}"
                  data-target-id="${connectedItem.id}"
                  data-source-id="${it.id}"
                  class="connected-remove-circle"
                  cx="${(path[0].x + path[1].x) / 2}"
                  cy="${(path[0].y + path[1].y) / 2}"
                />
              `}
              
            `;
      }).join("");
    }).join("")}
      </svg>
    `;
  }
  [CLICK("$connectedLinePanel .connected-remove-circle")](e) {
    var [tid, sid] = e.$dt.attrs("data-target-id", "data-source-id");
    var filters = this.state.filters;
    filters.filter((it) => it.id === sid).forEach((it) => {
      it.connected = it.connected.filter((c2) => c2.id != tid);
    });
    filters.filter((it) => it.id === tid).forEach((it) => {
      it.in = it.in.map((inObject) => {
        if (inObject && inObject.id == sid) {
          return null;
        }
        return inObject;
      });
    });
    this.refresh();
    this.modifyFilter();
  }
  getCenterXY($target) {
    var inRect = $target.rect();
    var x = inRect.x - this.rect.x;
    var y = inRect.y - this.rect.y;
    var centerX = x + inRect.width / 2;
    var centerY = y + inRect.height / 2;
    return { x: centerX, y: centerY };
  }
  end(dx, dy) {
    if (this.pointType === "in" || this.pointType === "out") {
      this.startXY.dx = dx;
      this.startXY.dy = dy;
      var filter2 = this.state.selectedFilter;
      var e = this.$config.get("bodyEvent");
      var $target = Dom.create(e.target);
      var $targetNode = $target.closest("filter-node");
      if (this.pointType === "out") {
        if ($target.hasClass("in")) {
          var targetFilter = this.state.filters[+$targetNode.attr("data-index")];
          if (targetFilter) {
            if (!targetFilter.hasLight() && filter2.isLight())
              ;
            else {
              var targetIndex = +$target.attr("data-index");
              if (!targetFilter.in[targetIndex]) {
                targetFilter.setIn(targetIndex, filter2);
                filter2.setConnected(targetFilter);
              }
            }
          }
        }
      } else if (this.pointType === "in") {
        if ($target.hasClass("out")) {
          var targetFilter = this.state.filters[+$targetNode.attr("data-index")];
          if (targetFilter) {
            if (filter2.hasLight() && !targetFilter.isLight())
              ;
            else {
              if (!filter2.in[this.pointIndex]) {
                filter2.setIn(this.pointIndex, targetFilter);
                targetFilter.setConnected(filter2);
              }
            }
          }
        }
      }
      this.pointType = "";
    }
    this.load("$dragLinePanel");
    this.load("$connectedLinePanel");
    this.modifyFilter();
  }
  move(dx, dy) {
    var filter2 = this.state.selectedFilter;
    if (filter2) {
      this.startXY.dx = dx;
      this.startXY.dy = dy;
      if (this.pointType === "in") {
        this.load("$dragLinePanel");
      } else if (this.pointType === "out") {
        this.load("$dragLinePanel");
      } else {
        filter2.reset({
          bound: { x: this.startXY.x + dx, y: this.startXY.y + dy }
        });
        this.$target.css({
          left: filter2.bound.x,
          top: filter2.bound.y
        });
        this.load("$connectedLinePanel");
      }
    }
  }
  makeGraphPanel() {
    return this.state.filters.map((it, index2) => {
      const selectedClass = index2 === this.state.selectedIndex ? "selected" : "";
      return `
        <div class='filter-node ${selectedClass}' data-type="${it.type}" data-index="${index2}" data-filter-id="${it.id}" style='left: ${it.bound.x}px;top: ${it.bound.y}px;'>
          <div class='label'>${this.$i18n(it.type)}</div>
          <div class='remove'>${iconUse("close")}</div>
          <div class='preview' data-source-type="${getSourceTypeString(it.type)}" data-filter-type='${it.type}'>${getIcon(it.type)}</div>
          <div class='in-list'>
            ${repeat(it.getInCount()).map((itIn, inIndex) => {
        return `<div class='in' data-index='${inIndex}'></div>`;
      }).join("")}
          </div>
          
          <div class='out' data-index="0">${iconUse("chevron_right")}</div>
          ${it.hasLight() ? `<div class='light'  data-index="0"></div>` : ""}
        </div>
      `;
    });
  }
  [SUBSCRIBE_SELF("changeFuncFilterEditor")](key, value) {
    var filter2 = this.state.selectedFilter;
    if (filter2) {
      filter2.reset({
        [key]: value
      });
    }
    this.modifyFilter();
  }
  [SUBSCRIBE_SELF("changeRangeEditor")](key, value) {
    var filter2 = this.state.selectedFilter;
    if (filter2) {
      filter2.reset({
        [key]: value
      });
    }
    this.modifyFilter();
  }
  [SUBSCRIBE_SELF("changeTextEditor")](key, value) {
    var filter2 = this.state.selectedFilter;
    if (filter2) {
      filter2.reset({
        [key]: value
      });
    }
    this.modifyFilter();
  }
  removeFilter(id) {
    var filters = this.state.filters.filter((it) => it.id != id);
    filters.forEach((it) => {
      it.connected = it.connected.filter((c2) => c2.id != id);
      it.in = it.in.filter((c2) => c2.id != id);
    });
    if (this.state.selectedFilter.id === id) {
      this.state.selectedFilter = null;
      this.state.selectedIndex = -1;
    }
    this.setState({
      filters
    });
    this.modifyFilter();
  }
  [CLICK("$graphPanel .filter-node .remove")](e) {
    var $target = e.$dt.closest("filter-node");
    var index2 = +$target.attr("data-index");
    var f = this.state.filters[index2];
    this.removeFilter(f.id);
  }
}
var SVGFilterPopup$1 = "";
class SVGFilterPopup extends BasePopup {
  getTitle() {
    return this.$i18n("svgfilter.popup.title");
  }
  getClassName() {
    return "transparent";
  }
  initState() {
    return {
      changeEvent: "changeSVGFilterPopup",
      id: "",
      preview: true,
      filters: []
    };
  }
  updateData(opt) {
    this.setState(opt, false);
    this.emit(this.state.changeEvent, this.state);
  }
  getBody() {
    return `
    <div class='elf--svg-filter-popup' ref='$popup'>
      <div class="box">
        <div class='editor' ref='$editor'></div>
      </div>
    </div>`;
  }
  [LOAD("$editor")]() {
    return createComponent("SVGFilterEditor", {
      ref: "$filter",
      title: "Filter Type",
      key: "filter",
      value: this.state.filters,
      onchange: (key, filters) => {
        this.updateData({
          filters
        });
      }
    });
  }
  [SUBSCRIBE("showSVGFilterPopup")](data) {
    data.filters = data.filters.map((it) => {
      return SVGFilter.parse(it);
    });
    data.preview = isNotUndefined(data.preview) ? data.preview : true;
    this.setState(data);
    this.show(1e3);
  }
  [SUBSCRIBE("hideSVGFilterPopup")]() {
    this.$el.hide();
  }
}
var SVGFilterSelectEditor$1 = "";
class SVGFilterSelectEditor extends EditorElement {
  initState() {
    var value = this.props.value;
    return {
      options: [],
      label: this.props.label || "",
      value
    };
  }
  template() {
    var { label } = this.state;
    var hasLabel = label ? "has-label" : "";
    return `
            <div class='elf--svg-filter-select-editor ${hasLabel}'>
                ${label ? `<label>${label}</label>` : ""}
                <select ref='$options'></select>
                <button type='button' class='open thin' ref='$open' title='Open SVG Filter Editor'>${obj$3.fullscreen}</button>
                <button type='button' class='remove thin' ref='$remove' title='Remove'>${obj$3.remove}</button>
            </div>
        `;
  }
  [CLICK("$remove")]() {
    this.updateData({
      value: ""
    });
  }
  [CLICK("$open")]() {
    var value = this.state.value;
    if (value.includes("id")) {
      var currentProject = this.$context.selection.currentProject;
      var index2 = currentProject.getSVGFilterIndex(value);
      if (index2 > -1) {
        this.trigger("openSVGFilterPopup", index2);
      }
    }
  }
  getValue() {
    return this.state.value;
  }
  setValue(value) {
    this.setState({ value });
  }
  [BIND("$options")]() {
    return {
      "data-count": this.state.options.length.toString()
    };
  }
  [LOAD("$options")]() {
    var current = this.$context.selection.currentProject;
    var options2 = "";
    if (current) {
      options2 = current.svgfilters.map((it) => it.id);
      options2 = options2.length ? "," + options2.join(",") : "";
    }
    options2 += ",-,new";
    options2 = options2.split(",");
    var arr = options2.map((it) => {
      var value = it;
      var label = it;
      if (value.includes(":")) {
        var [value, label] = value.split(":");
      }
      if (label === "") {
        label = this.props["none-value"] ? this.props["none-value"] : "";
      } else if (label === "-") {
        label = "----------";
        value = "";
      }
      var selected = value === this.state.value ? "selected" : "";
      return `<option ${selected} value="${value}">${label}</option>`;
    });
    return arr;
  }
  setOptions(options2 = "") {
    this.setState({
      options: options2.split(this.state.splitChar).map((it) => it.trim())
    });
  }
  [CHANGE("$options")]() {
    var value = this.refs.$options.value;
    if (value == "new") {
      this.$commands.emit("addSVGFilterAssetItem", (index2, id) => {
        this.updateData({ value: id });
        this.refresh();
        this.trigger("openSVGFilterPopup", index2);
      });
    } else if (value === "-")
      ;
    else {
      this.updateData({ value });
    }
  }
  updateData(data) {
    this.setState(data, false);
    this.parent.trigger(this.props.onchange, this.props.key, this.state.value, this.props.params);
  }
  [SUBSCRIBE("refreshSVGArea") + DEBOUNCE(1e3)]() {
    this.load("$options");
  }
  [SUBSCRIBE("openSVGFilterPopup")](index2) {
    this.emit("refreshSVGFilterAssets");
    this.emit("refreshSVGArea");
    var currentProject = this.$context.selection.currentProject || {
      svgfilters: []
    };
    var svgfilter = currentProject.svgfilters[index2];
    this.emit("showSVGFilterPopup", {
      changeEvent: "changeSVGFilterEditorRealUpdate",
      preview: false,
      index: index2,
      filters: svgfilter.filters
    });
  }
  [SUBSCRIBE("changeSVGFilterEditorRealUpdate")](params) {
    var project2 = this.$context.selection.currentProject;
    if (project2) {
      project2.setSVGFilterValue(params.index, {
        filters: params.filters
      });
      this.emit("refreshSVGFilterAssets");
      this.emit("refreshSVGArea");
    }
  }
}
function svgItem(editor) {
  editor.registerElement({
    ColorMatrixEditor,
    FuncFilterEditor,
    SVGFilterSelectEditor,
    SVGFilterEditor
  });
  editor.registerUI("inspector.tab.style", {
    SVGItemProperty: ObjectProperty.create({
      title: editor.$i18n("svg.item.property.title"),
      editableProperty: "svg-item",
      preventUpdate: true
    })
  });
  editor.registerUI("popup", {
    SVGFilterPopup
  });
  editor.registerInspector("svg-item", (current) => {
    return [
      {
        key: "edit",
        editor: "Button",
        editorOptions: {
          text: "Edit",
          action: ["open.editor", current]
        }
      },
      {
        type: "column",
        size: [2, 1],
        columns: [
          { type: "label", label: editor.$i18n("svg.item.property.fill") },
          {
            key: "fillRule",
            editor: "ToggleCheckBox",
            editorOptions: {
              toggleLabels: [iconUse("join_full"), iconUse("join_right")],
              toggleValues: ["nonzero", "evenodd"]
            },
            defaultValue: current.fillRule || "nonzero"
          }
        ]
      },
      {
        type: "column",
        size: [2, 1],
        columns: [
          {
            key: "fill",
            editor: "FillSingleEditor",
            editorOptions: {
              wide: true
            },
            defaultValue: current.fill
          },
          {
            key: "fillOpacity",
            editor: "number-input",
            editorOptions: {
              compact: true,
              label: "opacity",
              min: 0,
              max: 1,
              step: 0.01
            },
            defaultValue: current.fillOpacity
          }
        ]
      },
      {
        type: "column",
        size: [2, 1],
        columns: [
          { type: "label", label: editor.$i18n("svg.item.property.stroke") }
        ]
      },
      {
        type: "column",
        size: [2, 1],
        columns: [
          {
            key: "stroke",
            editor: "fill-single",
            editorOptions: {
              wide: true
            },
            defaultValue: current.stroke
          },
          {
            key: "strokeWidth",
            editor: "number-input",
            editorOptions: {
              compact: true,
              label: "line_weight"
            },
            defaultValue: current.strokeWidth
          }
        ]
      },
      {
        type: "column",
        size: [2, 1],
        columns: [
          {
            key: "strokeDasharray",
            editor: "StrokeDashArrayEditor",
            editorOptions: {
              label: editor.$i18n("svg.item.property.dashArray")
            },
            defaultValue: current.strokeDasharray || ""
          },
          {
            key: "strokeDashoffset",
            editor: "number-input",
            editorOptions: {
              compact: true,
              label: "power_input",
              min: -1e3,
              max: 1e3,
              step: 1
            },
            defaultValue: current.strokeDashoffset
          }
        ]
      },
      {
        key: "strokeLinecap",
        editor: "ToggleCheckBox",
        editorOptions: {
          label: editor.$i18n("svg.item.property.lineCap"),
          toggleLabels: [
            iconUse("line_cap_butt"),
            iconUse("line_cap_round"),
            iconUse("line_cap_square")
          ],
          toggleValues: [
            StrokeLineCap.BUTT,
            StrokeLineJoin.ROUND,
            StrokeLineCap.SQUARE
          ]
        },
        defaultValue: current.strokeLinecap || StrokeLineCap.BUTT
      },
      {
        key: "strokeLinejoin",
        editor: "ToggleCheckBox",
        editorOptions: {
          label: editor.$i18n("svg.item.property.lineJoin"),
          toggleLabels: [
            iconUse("line_join_miter"),
            iconUse("line_join_round"),
            iconUse("line_join_bevel")
          ],
          toggleValues: [
            StrokeLineJoin.MITER,
            StrokeLineJoin.ROUND,
            StrokeLineJoin.BEVEL
          ]
        },
        defaultValue: current.strokeLinejoin || StrokeLineJoin.MITER
      },
      {
        key: "mixBlendMode",
        editor: "BlendSelectEditor",
        editorOptions: {
          label: editor.$i18n("svg.item.property.blend")
        },
        defaultValue: current.mixBlendMode
      }
    ];
  });
  editor.registerInspector("polygon", (item) => {
    return [
      {
        key: "count",
        editor: "NumberInputEditor",
        editorOptions: {
          label: "Count",
          min: 3,
          max: 100,
          step: 1
        },
        defaultValue: item.count
      },
      {
        key: "button",
        editor: "Button",
        editorOptions: {
          label: "Copy ",
          text: "as path",
          command: "copy.path"
        }
      },
      {
        key: "button2",
        editor: "Button",
        editorOptions: {
          label: "Test Popup",
          action: [
            "showComponentPopup",
            {
              title: "Sample Test Popup",
              width: 400,
              inspector: [
                {
                  key: "test",
                  editor: "Button",
                  editorOptions: {
                    label: "Test",
                    text: "text",
                    onClick: () => {
                      window.alert("yellow");
                    }
                  }
                }
              ]
            }
          ]
        }
      }
    ];
  });
  editor.registerInspector("spline", () => {
    return [
      {
        key: "boundary",
        editor: "SelectIconEditor",
        editorOptions: {
          label: "Boundary",
          options: ["clamped", "open", "closed"]
        }
      },
      {
        key: "button",
        editor: "Button",
        editorOptions: {
          label: "Copy ",
          text: "as path",
          action: "copy.path"
        }
      }
    ];
  });
  editor.registerInspector("star", (item) => {
    return [
      {
        key: "isCurve",
        editor: "ToggleCheckBox",
        editorOptions: {
          label: "Curve",
          defaultValue: item.isCurve
        }
      },
      {
        key: "count",
        editor: "NumberInputEditor",
        editorOptions: {
          label: "Count",
          min: 3,
          max: 100,
          step: 1,
          wide: "true"
        }
      },
      {
        key: "radius",
        editor: "NumberInputEditor",
        editorOptions: {
          label: "Inner Radius",
          min: -1,
          max: 1,
          step: 0.01,
          wide: "true"
        }
      },
      {
        key: "tension",
        editor: "NumberInputEditor",
        editorOptions: {
          label: "Tension",
          min: 0,
          max: 1,
          step: 0.01,
          wide: "true"
        }
      },
      {
        key: "button",
        editor: "Button",
        editorOptions: {
          label: "Copy ",
          text: "as path",
          action: "copy.path"
        }
      }
    ];
  });
}
class SVGTextProperty extends BaseProperty {
  getTitle() {
    return this.$i18n("svg.text.property.title");
  }
  [SUBSCRIBE(REFRESH_SELECTION)]() {
    this.refreshShow(["svg-textpath", "svg-text", "svg-tspan"]);
  }
  refresh() {
    var current = this.$context.selection.current;
    if (current) {
      this.setAllValue([
        "lengthAdjust",
        "textLength",
        "startOffset",
        "text-anchor",
        "text"
      ]);
    }
  }
  setAllValue(list2 = []) {
    var current = this.$context.selection.current;
    if (!current)
      return;
    list2.forEach((key) => {
      this.children[`$${key}`].setValue(current[key]);
    });
  }
  getBody() {
    return `
      <div class='property-item '>
        ${createComponent("TextAreaEditor", {
      ref: "$text",
      label: this.$i18n("svg.text.property.textarea"),
      key: "text",
      onchange: "changeTextValue"
    })}
      </div>        
      <div class='property-item'>
        ${createComponent("SelectIconEditor", {
      ref: "$text-anchor",
      label: this.$i18n("svg.text.property.anchor"),
      key: "textAnchor",
      options: ["start", "middle", "end"],
      onchange: "changeTextValue"
    })}
          
      </div>            
      <div class='property-item '>
        ${createComponent("SelectEditor", {
      ref: "$lengthAdjust",
      label: this.$i18n("svg.text.property.length.adjust"),
      key: "lengthAdjust",
      value: "spacing",
      options: ["spacing", "spacingAndGlyphs"],
      onchange: "changeTextValue"
    })}
          
      </div>        
      <div class='property-item '>
        ${createComponent("RangeEditor", {
      ref: "$textLength",
      label: this.$i18n("svg.text.property.text.length"),
      key: "textLength",
      min: 0,
      max: 1e3,
      step: 0.1,
      onchange: "changeTextValue"
    })}
          
      </div>        
      <div class='property-item '>
        ${createComponent("RangeEditor", {
      ref: "$startOffset",
      label: this.$i18n("svg.text.property.start.offset"),
      key: "startOffset",
      min: 0,
      max: 1e3,
      step: 0.1,
      onchange: "changeTextValue"
    })}
          
      </div>                    
    `;
  }
  [SUBSCRIBE_SELF("changeTextValue")](key, value) {
    this.$commands.executeCommand("setAttribute", `change svg text property: ${key}`, this.$context.selection.packByValue({
      [key]: value
    }));
  }
}
function svgText(editor) {
  editor.registerUI("inspector.tab.style", {
    SVGTextProperty
  });
}
function text(editor) {
  editor.registerUI("inspector.tab.style", {
    TextProperty: ObjectProperty.create({
      title: editor.$i18n("text.property.title"),
      editableProperty: "text-style",
      preventUpdate: true
    })
  });
  editor.registerInspector("text-style", (current) => {
    return [
      {
        type: "column",
        size: [2, 1, 1],
        columns: [
          {
            key: "textAlign",
            editor: "SelectIconEditor",
            editorOptions: {
              compact: true,
              options: ["left", "center", "right", "justify"],
              icons: [
                "align_left",
                "align_center",
                "align_right",
                "align_justify"
              ]
            },
            defaultValue: current.textAlign || TextAlign.LEFT
          },
          "-",
          {
            key: "textTransform",
            editor: "SelectIconEditor",
            editorOptions: {
              options: [
                { value: TextTransform.CAPITALIZE, text: "Ag" },
                { value: TextTransform.UPPERCASE, text: "AG" },
                { value: TextTransform.LOWERCASE, text: "ag" }
              ],
              compact: true,
              icons: ["horizontal_rule"]
            },
            defaultValue: current.textTransform
          }
        ]
      },
      {
        type: "column",
        size: [3, 2, 1],
        gap: 20,
        columns: [
          {
            key: "textDecoration",
            editor: "SelectIconEditor",
            editorOptions: {
              options: [
                { value: TextDecoration.NONE, text: "None" },
                { value: TextDecoration.UNDERLINE, text: "Underline" },
                { value: TextDecoration.LINE_THROUGH, text: "LineThrough" }
              ],
              icons: ["horizontal_rule", "underline", "strikethrough"],
              onchange: "changeTextValue"
            },
            defaultValue: current.textDecoration
          },
          {
            key: "fontStyle",
            editor: "SelectIconEditor",
            editorOptions: {
              compact: true,
              options: ["normal", "italic"],
              icons: ["title", "italic"]
            },
            defaultValue: current.fontStyle
          },
          {
            key: "textClip",
            editor: "ToggleButton",
            editorOptions: {
              checkedValue: TextClip.TEXT,
              toggleLabels: [iconUse("vignette"), iconUse("vignette")],
              toggleTitles: ["", "Text Clip"],
              toggleValues: [TextClip.NONE, TextClip.TEXT]
            },
            defaultValue: current.textClip || TextClip.NONE
          }
        ]
      }
    ];
  });
}
var textShadow$1 = [
  { name: "Mystic", shadow: `20px 0px 10px rgb(0, 0, 0)` },
  { name: "Monoton", shadow: `0px -78px rgb(255, 196, 0)` },
  { name: "Radioactive", shadow: `-18px -18px 20px rgb(87, 255, 9);` },
  { name: "Bungee", shadow: `-18px 18px 0 rgb(66, 45, 45)` },
  { name: "Sprint", shadow: `-20px -108px 0px rgba(255, 255, 255, 0.445)` },
  { name: "Prickly", shadow: `-18px -18px 2px #777` },
  {
    name: "Codystar",
    shadow: `1px 1px 10px rgb(16, 72, 255), 1px 1px 10px rgb(0, 195, 255)`
  },
  { name: "Elegant", shadow: `-18px 8px 18px #b4bbbb` },
  {
    name: "Playful",
    shadow: `
        -2px -2px 0px #888,
        4px 4px 0px #888,
        7px 7px 0px #888
    `
  }
];
var TextShadowProperty$1 = "";
class TextShadowProperty extends BaseProperty {
  getTitle() {
    return this.$i18n("text.shadow.property.title");
  }
  getBody() {
    return `
      <div class="full text-shadow-item" ref="$shadowList"></div>
    `;
  }
  getTools() {
    return `
      <select class='text-shadow-samples' ref="$select">
      ${textShadow$1.map((item, index2) => {
      return `
          <option value="${index2}">${item.name}</option>
        `;
    }).join("")}
      </select>
      <button type="button" ref='$add'>${obj$3.add}</button>
    `;
  }
  [CLICK("$add")]() {
    const index2 = +this.refs.$select.value;
    this.children.$textshadow.trigger("add", textShadow$1[index2].shadow);
  }
  [LOAD("$shadowList")]() {
    var current = this.$context.selection.current || {};
    return createComponent("TextShadowEditor", {
      ref: "$textshadow",
      key: "textShadow",
      value: current.textShadow,
      onchange: (key, value) => {
        this.$commands.executeCommand("setAttribute", "change text shadow", this.$context.selection.packByValue({
          [key]: value
        }));
      }
    });
  }
  get editableProperty() {
    return "textShadow";
  }
  [SUBSCRIBE(REFRESH_SELECTION) + IF("checkShow") + DEBOUNCE(100)]() {
    this.refresh();
  }
}
function textShadow(editor) {
  editor.registerUI("inspector.tab.style", {
    TextShadowProperty
  });
}
var TransitionProperty$1 = "";
const TRANSITION_TIMING_REG = /((cubic-bezier|steps)\(([^)]*)\))/gi;
class Transition extends PropertyItem {
  static parse(obj2) {
    return new Transition(obj2);
  }
  getDefaultObject() {
    return {
      name: "all",
      duration: Length.second(0),
      timingFunction: "linear",
      delay: Length.second(0)
    };
  }
  toCloneObject() {
    return {
      name: this.json.name,
      duration: this.json.duration + "",
      timingFunction: this.json.timingFunction,
      delay: this.json.delay + ""
    };
  }
  toCSS() {
    return {
      transition: this.toString()
    };
  }
  toString() {
    var json = this.json;
    return [json.name, json.duration, json.timingFunction, json.delay].join(" ");
  }
  static join(list2) {
    return list2.map((it) => new Transition(it).toString()).join(",");
  }
  static add(transition2, item = {}) {
    const list2 = Transition.parseStyle(transition2);
    list2.push(Transition.parse(item));
    return Transition.join(list2);
  }
  static remove(transition2, removeIndex) {
    return Transition.filter(transition2, (it, index2) => {
      return removeIndex != index2;
    });
  }
  static filter(transition2, filterFunction) {
    return Transition.join(Transition.parseStyle(transition2).filter((it) => filterFunction(it)));
  }
  static replace(transition2, replaceIndex, valueObject) {
    var list2 = Transition.parseStyle(transition2);
    if (list2[replaceIndex]) {
      list2[replaceIndex] = valueObject;
    } else {
      list2.push(valueObject);
    }
    return Transition.join(list2);
  }
  static get(transition2, index2) {
    var arr = Transition.parseStyle(transition2);
    return arr[index2];
  }
  static parseStyle(transition2) {
    var list2 = [];
    if (!transition2)
      return list2;
    const result = customParseConvertMatches(transition2, TRANSITION_TIMING_REG);
    list2 = result.str.split(",").map((it) => {
      const fields2 = it.split(" ").filter(Boolean);
      if (fields2.length >= 4) {
        return {
          name: fields2[0],
          duration: Length.parse(fields2[1]),
          timingFunction: customParseReverseMatches(fields2[2], result.matches),
          delay: Length.parse(fields2[3])
        };
      } else if (fields2.length >= 3) {
        return {
          name: fields2[0],
          duration: Length.parse(fields2[1]),
          delay: Length.parse(fields2[2])
        };
      } else if (fields2.length >= 1) {
        return {
          name: fields2[0],
          duration: Length.parse(fields2[1])
        };
      } else {
        return {};
      }
    });
    return list2.map((it) => Transition.parse(it));
  }
}
class TransitionProperty extends BaseProperty {
  getTitle() {
    return this.$i18n("transition.property.title");
  }
  getBody() {
    return `<div class='elf--transition-list' ref='$transitionList'></div>`;
  }
  getTools() {
    return `
        <button type="button" ref="$add" title="add Transition">${iconUse("add")}</button>
    `;
  }
  isFirstShow() {
    return true;
  }
  [LOAD("$transitionList") + DOMDIFF]() {
    var current = this.$context.selection.current;
    if (!current)
      return "";
    return Transition.parseStyle(current.transition).map((it, index2) => {
      const selectedClass = this.state.selectedIndex === index2 ? "selected" : "";
      const path = curveToPath(it.timingFunction, 30, 30);
      return `
      <div class='transition-group-item'>
        <div class='transition-item ${selectedClass}' data-index='${index2}' ref="transitionIndex${index2}">
            <div class='timing preview' data-index='${index2}' ref='$preview${index2}'>
              <svg class='item-canvas' width="30" height="30" viewBox="0 0 30 30">
                <path d="${path}" stroke="white" stroke-width="1" fill='none' />
              </svg>
            </div>
            <div class='name'>
              <div class='labels'>
                <span class='property-name' title='Property'>${it.name}</span>
                <span class='duration' title='Duration'><small>Duration: ${it.duration}</small></span>
                <span class='delay' title='Delay'><small>Delay: ${it.delay}</small></span>
              </div>
            </div>
            <div class='tools'>
                <button type="button" class="del" data-index="${index2}">
                  ${iconUse("remove2")}
                </button>
            </div>
        </div>
      </div>        
      `;
    });
  }
  [SUBSCRIBE(REFRESH_SELECTION)]() {
    this.refreshShowIsNot([]);
  }
  [CLICK("$add")]() {
    var current = this.$context.selection.current;
    if (current) {
      this.$commands.executeCommand("setAttribute", "add transition", this.$context.selection.packByValue({
        transition: (item) => Transition.add(item.transition)
      }));
      this.nextTick(() => {
        window.setTimeout(() => {
          this.refresh();
        }, 100);
      });
    } else {
      window.alert("Select a layer");
    }
  }
  getCurrentTransition() {
    return this.current.transitions[this.selectedIndex];
  }
  [CLICK("$transitionList .tools .del")](e) {
    var removeIndex = e.$dt.attr("data-index");
    var current = this.$context.selection.current;
    if (!current)
      return;
    current.reset({
      transition: Transition.remove(current.transition, removeIndex)
    });
    this.emit("refreshElement", current);
    this.refresh();
  }
  selectItem(selectedIndex, isSelected = true) {
    if (isSelected) {
      this.refs[`transitionIndex${selectedIndex}`].addClass("selected");
    } else {
      this.refs[`transitionIndex${selectedIndex}`].removeClass("selected");
    }
  }
  viewTransitionPicker($preview) {
    if (typeof this.selectedIndex === "number") {
      this.selectItem(this.selectedIndex, false);
    }
    this.selectedIndex = +$preview.attr("data-index");
    this.current = this.$context.selection.current;
    if (!this.current)
      return;
    this.currentTransition = Transition.get(this.current.transition, this.selectedIndex);
    this.viewTransitionPropertyPopup();
  }
  viewTransitionPropertyPopup() {
    if (!this.currentTransition)
      return;
    const transition2 = this.currentTransition;
    this.emit("showTransitionPropertyPopup", {
      changeEvent: "changeTransitionPropertyPopup",
      data: transition2.toCloneObject(),
      instance: this
    });
  }
  [CLICK("$transitionList .preview")](e) {
    this.viewTransitionPicker(e.$dt);
  }
  getRef(...args2) {
    return this.refs[args2.join("")];
  }
  [SUBSCRIBE("changeTransitionPropertyPopup")](data) {
    if (this.currentTransition) {
      this.currentTransition.reset(__spreadValues({}, data));
      if (this.current) {
        this.current.reset({
          transition: Transition.replace(this.current.transition, this.selectedIndex, this.currentTransition)
        });
        this.emit("refreshElement", this.current);
        this.refresh();
      }
    }
  }
}
var TransitionPropertyPopup$1 = "";
const property_list = [
  "none",
  "all",
  "background-color",
  "background-position",
  "background-size",
  "border",
  "border-color",
  "border-width",
  "border-bottom",
  "border-bottom-color",
  "border-bottom-left-radius",
  "border-bottom-right-radius",
  "border-bottom-width",
  "border-left",
  "border-left-color",
  "border-left-width",
  "border-radius",
  "border-right",
  "border-right-color",
  "border-right-width",
  "border-spacing",
  "border-top",
  "border-top-color",
  "border-top-left-radius",
  "border-top-right-radius",
  "border-top-width",
  "bottom",
  "box-shadow",
  "color",
  "filter",
  "font-size",
  "font-size-adjust",
  "font-weight",
  "height",
  "left",
  "letter-spacing",
  "line-height",
  "margin",
  "margin-bottom",
  "margin-left",
  "margin-right",
  "margin-top",
  "max-height",
  "max-width",
  "min-height",
  "min-width",
  "opacity",
  "padding",
  "padding-bottom",
  "padding-left",
  "padding-right",
  "padding-top",
  "perspective",
  "perspective-origin",
  "right",
  "text-decoration",
  "text-decoration-color",
  "text-indent",
  "text-shadow",
  "top",
  "transform",
  "vertical-align",
  "visibility",
  "width",
  "word-spacing",
  "z-index"
].map((it) => ({
  value: it,
  text: it
}));
class TransitionPropertyPopup extends BasePopup {
  getTitle() {
    return "Transition";
  }
  initState() {
    return {
      changeEvent: "",
      instance: {},
      data: {
        timingFunction: "linear",
        duration: "0s",
        delay: "0s",
        name: "all"
      }
    };
  }
  updateData(opt) {
    this.state.data = __spreadValues(__spreadValues({}, this.state.data), opt);
    if (this.state.instance) {
      this.state.instance.trigger(this.state.changeEvent, this.state.data);
    }
  }
  getBody() {
    return `<div class='elf--transition-property-popup' ref='$popup'></div>`;
  }
  [LOAD("$popup")]() {
    return `
      <div class="box">
        ${this.templateForProperty()}
        ${this.templateForTimingFunction()}
        ${this.templateForDelay()}
        ${this.templateForDuration()}
      </div>
    `;
  }
  templateForTimingFunction() {
    return `
    <div class='timing-function'>
      <label>Timing function</label>
      ${createComponent("CubicBezierEditor", {
      ref: "$cubicBezierEditor",
      key: "timingFunction",
      value: this.state.data.timingFunction || "linear",
      onChange: "changeCubicBezier"
    })}
    </div>
    `;
  }
  [SUBSCRIBE_SELF("changeTransition")](key, value) {
    this.updateData({
      [key]: value
    });
  }
  templateForProperty() {
    return `
      <div class='name'>
        ${createComponent("SelectEditor", {
      ref: "$property",
      icon: true,
      label: "Property",
      key: "name",
      value: this.state.data.name,
      options: property_list,
      onChange: "changeTransition"
    })}
      </div>
    `;
  }
  templateForDelay() {
    return `
    <div class='delay'>
      ${createComponent("RangeEditor", {
      ref: "$delay",
      label: "Delay",
      key: "delay",
      value: this.state.data.delay,
      units: ["s", "ms"],
      onChange: "changeRangeEditor"
    })}
    </div>
    `;
  }
  templateForDuration() {
    return `
    <div class='duration'>
      ${createComponent("RangeEditor", {
      ref: "$duration",
      label: "Duration",
      key: "duration",
      value: this.state.data.duration,
      units: ["s", "ms"],
      onChange: "changeRangeEditor"
    })}
    </div>
    `;
  }
  [SUBSCRIBE_SELF("changeRangeEditor")](key, value) {
    this.updateData({ [key]: value });
  }
  [SUBSCRIBE_SELF("changeCubicBezier")](key, value) {
    this.updateData({ [key]: value });
  }
  [SUBSCRIBE("showTransitionPropertyPopup")](data) {
    this.setState(data);
    this.show(250);
    this.children.$cubicBezierEditor.trigger("showCubicBezierEditor", data.data.timingFunction);
  }
  [SUBSCRIBE("hideTransitionPropertyPopup")]() {
    this.$el.hide();
  }
}
function transition(editor) {
  editor.registerUI("inspector.tab.transition", {
    TransitionProperty
  });
  editor.registerUI("popup", {
    TransitionPropertyPopup
  });
}
var VideoProperty$1 = "";
class VideoProperty extends BaseProperty {
  getClassName() {
    return "item elf--video-property";
  }
  getTitle() {
    return this.$i18n("video.property.title");
  }
  initState() {
    return {
      $video: { el: {} },
      status: "play",
      volume: 1
    };
  }
  getBody() {
    return `<div ref='$body' style='padding-top: 3px;'></div>`;
  }
  get video() {
    return this.state.$video.el;
  }
  get volumeStatus() {
    if (this.state.volume === 0)
      return "muted";
    if (this.state.volume > 0.5)
      return "up";
    return "down";
  }
  play() {
    if (this.video)
      this.video.play();
  }
  pause() {
    if (this.video)
      this.video.pause();
  }
  [LOAD("$body")]() {
    var current = this.$context.selection.current || { playTime: "0:1:1" };
    var currentTime = current.currentTime || 0;
    var duration = (current.playTime || "0:1:1").split(":").pop();
    return `
        <div ref='$tools' class='play-control' data-selected-value="${this.state.status}">
          <button type="button" data-value="play" >${obj$3.play} ${this.$i18n("video.property.play")}</button>
          <button type="button" data-value="pause">${obj$3.pause}  ${this.$i18n("video.property.pause")}</button>      
          <div>
            ${createComponent("NumberRangeEditor", {
      ref: "$currentTime",
      min: 0,
      max: duration,
      value: currentTime,
      step: 1e-3,
      onchange: "changeCurrentTime"
    })}
          </div>
        </div>    
        <div class='property-item animation-property-item has-label'>        
          <div class='group'>
            <span class='add-timeline-property' data-property='volume'></span>
            ${this.$i18n("video.property.volume")}
          </div>
          <div ref='$volume_control' class='volume-control' data-selected-value='${this.volumeStatus}'>
            <span data-value='muted'>${obj$3.volume_off}</span>
            <span data-value='down'>${obj$3.volume_down}</span>
            <span data-value='up'>${obj$3.volume_up}</span>
            <input type="range" ref='$volume' min="0" max="1" step="0.001" value="${this.state.volume}" />
          </div>          
        </div>
        <div class='property-item animation-property-item has-label'>        
          <div class='group'>
            <span class='add-timeline-property' data-property='playbackRate'></span>
            ${this.$i18n("video.property.playbackRate")}
          </div>
          <div>
            ${createComponent("NumberRangeEditor", {
      ref: "$playbackRate",
      min: 0.1,
      max: 10,
      clamp: true,
      value: this.state.playbackRate,
      step: 1e-3,
      onchange: "changePlaybackRate"
    })}
          </div>
        </div>        
        <div class='property-item animation-property-item full'>
          <div class='group'>
            <span class='add-timeline-property' data-property='playTime'></span>
            ${this.$i18n("video.property.playTime")}
          </div>
          ${createComponent("MediaProgressEditor", {
      ref: "$progress",
      key: "playTime",
      value: current.playTime,
      onchange: "changeSelect"
    })}
        </div>
      `;
  }
  [SUBSCRIBE("changeCurrentTime")](key, currentTime) {
    this.setState({ currentTime }, false);
    this.$commands.executeCommand("setAttribute", "change video property", this.$context.selection.packByValue({ currentTime }));
  }
  [SUBSCRIBE("changePlaybackRate")](key, playbackRate) {
    this.setState({ playbackRate }, false);
    this.$commands.executeCommand("setAttribute", "change video property", this.$context.selection.packByValue({ playbackRate }));
  }
  [CHANGEINPUT("$volume")]() {
    const volume = Number(this.refs.$volume.value);
    this.setState({ volume }, false);
    this.bindData("$volume_control");
    this.$commands.executeCommand("setAttribute", "change video property", this.$context.selection.packByValue({ volume }));
  }
  [BIND("$volume_control")]() {
    return {
      "data-selected-value": this.volumeStatus
    };
  }
  [BIND("$tools")]() {
    return {
      "data-selected-value": this.state.status
    };
  }
  [CLICK("$tools button")](e) {
    var playType = e.$dt.attr("data-value");
    switch (playType) {
      case "play":
        this.setState({ status: "pause" }, false);
        this.play();
        break;
      case "pause":
        this.setState({ status: "play" }, false);
        this.pause();
        break;
    }
    this.bindData("$tools");
  }
  [SUBSCRIBE_SELF("changeValue") + DEBOUNCE(100)](key, value) {
    if (!this.state.$video)
      return;
    this.$commands.executeCommand("setAttribute", "change video property", this.$context.selection.packByValue({ [key]: value }));
  }
  [SUBSCRIBE_SELF("changeSelect")](key, value) {
    this.$commands.executeCommand("setAttribute", "change video property", this.$context.selection.packByValue({ [key]: value }));
  }
  [SUBSCRIBE_SELF("updateVideoEvent")]() {
    if (this.video.paused) {
      this.setState({
        status: "play",
        currentTime: this.video.currentTime
      }, false);
      this.bindData("$tools");
    }
    this.children.$currentTime.setValue(this.video.currentTime);
  }
  [SUBSCRIBE(REFRESH_SELECTION) + DEBOUNCE(100)]() {
    const current = this.$context.selection.current;
    this.refreshShow(["video"]);
    if (current && current.is("video")) {
      this.emit("refElement", current.id, ($el) => {
        const $video = $el.$("video");
        this.state.$video = $video;
        this.setState({
          volume: current.volume,
          currentTime: current.currentTime,
          playbackRate: current.playbackRate
        }, false);
        this.video.ontimeupdate = (e) => {
          this.trigger("updateVideoEvent", e);
        };
        this.video.onprogress = (e) => {
          this.trigger("updateVideoEvent", e);
        };
        this.load("$body");
      });
    }
  }
}
function video(editor) {
  editor.registerUI("inspector.tab.style", {
    VideoProperty
  });
}
var ComponentPopup$1 = "";
class ComponentPopup extends BasePopup {
  getClassName() {
    return "component-property w(800)";
  }
  getTitle() {
    return "Component";
  }
  initState() {
    return {
      title: "",
      inspector: []
    };
  }
  refresh() {
    this.setTitle(this.state.title || this.getTitle());
    this.load();
  }
  getBody() {
    return `
      <div ref='$body'></div>
    `;
  }
  [BIND("$body")]() {
    return {
      style: {
        width: this.state.width || 250
      }
    };
  }
  [LOAD("$body")]() {
    const inspector = this.state.inspector;
    return createComponent("ComponentEditor", {
      inspector,
      onchange: "changeComponent"
    });
  }
  [SUBSCRIBE_SELF("changeComponent")](key, value) {
    if (isFunction(this.state.changeEvent)) {
      this.emit(this.state.changeEvent, key, value);
    }
  }
  [SUBSCRIBE(SHOW_COMPONENT_POPUP)](data) {
    this.setState(data, false);
    this.refresh();
    this.show(data.width);
  }
}
var ComponentProperty$1 = "";
class ComponentProperty extends BaseProperty {
  getClassName() {
    return "component-property";
  }
  getTitle() {
    return "Component";
  }
  isShow() {
    var _a;
    var current = (_a = this.$context.selection) == null ? void 0 : _a.current;
    const inspector = this.$context.components.createInspector(current);
    if (current && (current.is("component") || inspector.length > 0)) {
      return true;
    }
    return false;
  }
  [SUBSCRIBE(REFRESH_SELECTION) + DEBOUNCE(100)]() {
    this.refreshShow(() => {
      const current = this.$context.selection.current;
      const inspector = this.$context.components.createInspector(current);
      return inspector.length > 0;
    });
  }
  refresh() {
    var current = this.$context.selection.current;
    if (current) {
      this.setTitle(current.getDefaultTitle() || current.itemType || current.name);
      this.load();
    }
  }
  getBody() {
    return `
      <div ref='$body'></div>
    `;
  }
  [LOAD("$body")]() {
    var _a;
    var current = (_a = this.$context.selection) == null ? void 0 : _a.current;
    if (!current)
      return "";
    const inspector = this.$context.components.createInspector(current);
    inspector.forEach((it) => {
      if (isString(it)) {
        return;
      }
      let defaultValue2 = current[it.key] || it.defaultValue;
      if (isFunction(it.convertDefaultValue)) {
        defaultValue2 = it.convertDefaultValue(current, it.key);
      }
      it.defaultValue = defaultValue2;
    });
    return createComponent("ComponentEditor", {
      ref: "$comp",
      inspector,
      onchange: "changeComponentProperty"
    });
  }
  [SUBSCRIBE_SELF("changeComponentProperty")](key, value) {
    this.$commands.executeCommand("setAttribute", "change component : " + key, this.$context.selection.packByValue({
      [key]: value
    }));
  }
}
function component(editor) {
  editor.registerUI("inspector.tab.style", {
    ComponentProperty
  });
  editor.registerUI("popup", {
    ComponentPopup
  });
}
var ContentProperty$1 = "";
class ContentProperty extends BaseProperty {
  getTitle() {
    return "Content";
  }
  [SUBSCRIBE(REFRESH_SELECTION, REFRESH_CONTENT) + DEBOUNCE(100)]() {
    this.refreshShow(["text"]);
  }
  getBody() {
    return `
      <div class="property-item elf--content-item">
        <textarea ref="$contentItem"></textarea>
      </div>
    `;
  }
  [BIND("$contentItem")]() {
    var current = this.$context.selection.current;
    if (!current)
      return "";
    return {
      value: current.content || ""
    };
  }
  [INPUT("$contentItem")]() {
    this.setContent();
  }
  setContent() {
    var current = this.$context.selection.current;
    if (current) {
      var data = {
        content: this.refs.$contentItem.value
      };
      current.reset(data);
      this.emit(UPDATE_CANVAS, current);
    }
  }
}
function content(editor) {
  editor.registerElement({
    ContentProperty
  });
}
var designEditorPlugins = [
  configs,
  commands$1,
  defaultConfigs,
  defaultIcons,
  defaultMessages,
  defaultItems,
  defaultPatterns,
  rendererHtml,
  rendererJson,
  rendererSvg,
  baseEditor,
  propertyEditor,
  color,
  gradient,
  alignment,
  position,
  layout$2,
  boxModel,
  pathTool,
  artboard,
  svgText,
  font,
  text,
  textShadow,
  content,
  appearance,
  component,
  backgroundImage,
  patternAsset,
  border,
  borderRadius,
  video,
  image,
  svgFilterAsset,
  svgItem,
  layerTree,
  backgroundClip,
  borderImage,
  filter,
  backdropFilter,
  boxShadow,
  clipPath,
  gradientAsset,
  exportResource,
  transition,
  keyframe,
  animation,
  selector,
  codeview,
  history,
  project,
  selectionInfoView,
  selectionToolView,
  guideLineView,
  layerAppendView,
  lineView,
  hoverView,
  pathDrawView,
  pathEditorView,
  gradientEditorView,
  fillEditorView,
  ClippathEditorView,
  imageAsset,
  sample,
  function(editor) {
    editor.registerMenu("context.menu.layer2", [
      {
        type: "button",
        title: "Layer"
      }
    ]);
    editor.registerMenu("context.menu.layer", [
      {
        type: "button",
        title: "Sample"
      },
      {
        type: "button",
        title: "Sample"
      },
      {
        type: "button",
        title: "Sample",
        action: (editor2) => {
          console.log(editor2);
        }
      },
      {
        type: "button",
        title: "Sample"
      },
      {
        type: "dropdown",
        title: "dropdown",
        items: [
          {
            title: "menu.item.fullscreen.title",
            command: "toggle.fullscreen",
            shortcut: "ALT+/",
            closable: true
          }
        ]
      }
    ]);
    editor.registerUI("context.menu", {
      ContextMenuView
    });
  }
];
class Inspector extends EditorElement {
  afterRender() {
    this.$el.toggle(this.$config.is("editor.design.mode", DesignMode.DESIGN));
  }
  [BIND("$el")]() {
    return {
      style: {
        display: this.$config.is("editor.design.mode", DesignMode.DESIGN) ? "block" : "none"
      }
    };
  }
  template() {
    return /* @__PURE__ */ createElementJsx("div", {
      class: "feature-control inspector"
    }, /* @__PURE__ */ createElementJsx("div", null, /* @__PURE__ */ createElementJsx(Tabs, {
      ref: "$tab",
      selectedValue: "style",
      onchange: (value) => {
        this.$config.set("inspector.selectedValue", value);
      }
    }, /* @__PURE__ */ createElementJsx(TabPanel, {
      value: "style",
      title: this.$i18n("inspector.tab.title.design")
    }, /* @__PURE__ */ createElementJsx("div", {
      style: "display: flex; flex-direction: column;"
    }, this.$injectManager.generate("inspector.tab.style", true), /* @__PURE__ */ createElementJsx("div", {
      class: "empty",
      style: "order: 1000000;"
    }))), /* @__PURE__ */ createElementJsx(TabPanel, {
      value: "transition",
      title: this.$i18n("inspector.tab.title.transition")
    }, /* @__PURE__ */ createElementJsx("div", {
      style: "display: flex; flex-direction: column;"
    }, this.$injectManager.generate("inspector.tab.transition", true), /* @__PURE__ */ createElementJsx("div", {
      class: "empty",
      style: "order: 1000000;"
    }))), /* @__PURE__ */ createElementJsx(TabPanel, {
      value: "code",
      title: this.$i18n("inspector.tab.title.code")
    }, /* @__PURE__ */ createElementJsx("div", {
      style: "display: flex; flex-direction: column;"
    }, this.$injectManager.generate("inspector.tab.code", true), /* @__PURE__ */ createElementJsx("div", {
      class: "empty",
      style: "order: 1000000;"
    }))), this.$injectManager.getTargetUI("inspector.tab").map((it) => {
      const { value, title: title2, loadElements } = it.class;
      return /* @__PURE__ */ createElementJsx(TabPanel, {
        value,
        title: title2,
        icon: it.icon
      }, /* @__PURE__ */ createElementJsx("div", {
        style: "display: flex: flex-direction: column;"
      }, loadElements.map((element) => createElement(element)), this.$injectManager.generate("inspector.tab." + it.value, true), /* @__PURE__ */ createElementJsx("div", {
        class: "empty",
        style: "order: 1000000;"
      })));
    }))));
  }
}
class AssetItems extends EditorElement {
  template() {
    return `
      <div class='asset-items'>
        ${this.$injectManager.generate("asset")}
      </div>
    `;
  }
}
var CustomAssets$1 = "";
class CustomAssets extends EditorElement {
  template() {
    return `
      <div class='elf--custom-assets'>
        <div class='custom-assets-tools'>
          <div class='title'><label>Custom Assets</label></div>
          <div class='tools'>
            <button type="button" ref='$addCustomAsset'>${iconUse("add")}</button>
          </div>
        </div>
        <div class='elf--asset-list' ref='$list'></div>
      </div>
    `;
  }
  async [LOAD("$list")]() {
    const data = await this.$storageManager.getCustomAssetList();
    return data.map((it) => {
      return `
        <div class='asset-preview' draggable="true" data-preview-id="${it.id}">
          <div class='thumbnail'><img src='${it.preview}' /></div>
          <div class='tools'>
            <div class='title'>${it.component.name}</div>
            <div class='buttons'>
              <button type="button" class='remove-asset-preview' title="remove asset" data-preview-id="${it.id}">${iconUse("remove")}</button>
            </div>
          </div>
        </div>
      `;
    });
  }
  async [CLICK("$list .remove-asset-preview")](e) {
    if (window.confirm(this.$i18n("app.confirm.message.artboard.items.removeCustomAsset"))) {
      const id = e.$dt.data("preview-id");
      await this.$storageManager.removeCustomAsset(id);
      this.refresh();
    }
  }
  [DRAGSTART("$list .asset-preview")](e) {
    const id = e.$dt.data("preview-id");
    e.dataTransfer.effectAllowed = "copy";
    e.dataTransfer.setData("text/asset", id);
  }
  [CLICK("$addCustomAsset")]() {
    this.$commands.emit("savePNG", async (datauri) => {
      await this.$storageManager.saveCustomAsset(datauri);
      this.refresh();
    });
  }
}
var LibraryItems$1 = "";
class LibraryItems extends EditorElement {
  template() {
    return `
      <div class='elf--library-items'>
        <div>
          ${createComponent("TextEditor", {
      label: "Search",
      key: "search",
      onchange: this.subscribe((key, value) => {
        this.broadcast("search", value);
      }, 300)
    })}
        </div>
        ${this.$injectManager.generate("library")}
      </div>
    `;
  }
}
var ObjectItems$1 = "";
class SingleObjectItems extends EditorElement {
  template() {
    return `
        <div class="object-items single">
          <div>
            ${createComponent("LayerTreeProperty")}
          </div>
        </div>
    `;
  }
}
class ItemLayerTab extends EditorElement {
  components() {
    return {
      AssetItems,
      LibraryItems,
      CustomAssets,
      SingleObjectItems
    };
  }
  initState() {
    return {
      selectedIndexValue: 2
    };
  }
  afterRender() {
    this.$el.toggle(this.$config.get("editor.design.mode") === "item");
  }
  [BIND("$el")]() {
    return {
      style: {
        display: this.$config.get("editor.design.mode") === "item" ? "block" : "none"
      }
    };
  }
  template() {
    return `
      <div class='layer-tab'>
        <div class="tab number-tab side-tab side-tab-left" data-selected-value="2" ref="$tab">
          <div class="tab-header" ref="$header">   
            <div class="tab-item selected" data-value="2" data-direction="right" data-tooltip="${this.$i18n("app.tab.title.layers")}">
              <label>${iconUse("layers")}</label>
            </div>            
            <div class='tab-item' data-value='6' data-direction="right"  data-tooltip="${this.$i18n("app.tab.title.components")}">
              <label>${iconUse("plugin")}</label>
            </div>            

            ${this.$injectManager.getTargetUI("leftbar.tab").filter((it) => {
      return it.class.designMode && it.class.designMode.includes("item");
    }).map((it) => {
      const { value, title: title2 } = it.class;
      let iconString = it.class.icon;
      if (obj$3[it.class.icon]) {
        iconString = iconUse(it.class.icon);
      }
      return `
                <div class='tab-item' data-value='${value}' data-direction="right"  data-tooltip="${title2}">
                  <label>${iconString || title2}</label>
                </div>
              `;
    })}

          </div>
          <div class="tab-body" ref="$body">
            <div class="tab-content selected" data-value="2">
              ${createComponent("SingleObjectItems")}
            </div>
            <div class='tab-content' data-value='6'>
              ${createComponent("CustomAssets")}
            </div>
            ${this.$injectManager.getTargetUI("leftbar.tab").filter((it) => {
      return it.class.designMode && it.class.designMode.includes("item");
    }).map((it) => {
      const { value } = it.class;
      return `
                <div class='tab-content' data-value='${value}'>
                  ${this.$injectManager.generate(`leftbar.tab.${value}`)}
                </div>
              `;
    })}
          </div>
        </div>
      </div>
    `;
  }
  [CLICK("$header .tab-item:not(.extra-item)")](e) {
    var selectedIndexValue = e.$dt.attr("data-value");
    if (this.state.selectedIndexValue === selectedIndexValue) {
      return;
    }
    this.$el.$$(`[data-value="${this.state.selectedIndexValue}"]`).forEach((it) => it.removeClass("selected"));
    this.$el.$$(`[data-value="${selectedIndexValue}"]`).forEach((it) => it.addClass("selected"));
    this.setState({ selectedIndexValue }, false);
  }
}
class ObjectItems extends EditorElement {
  template() {
    return `
        <div class="object-items">
          <div>
            ${createComponent("ProjectProperty")}
          </div>
          <div>
            ${createComponent("LayerTreeProperty")}
          </div>
        </div>
    `;
  }
}
class LayerTab extends EditorElement {
  components() {
    return {
      AssetItems,
      LibraryItems,
      CustomAssets,
      ObjectItems
    };
  }
  initState() {
    return {
      selectedIndexValue: 2
    };
  }
  template() {
    return `
      <div class='layer-tab'>
        <div class="tab number-tab side-tab side-tab-left" data-selected-value="2" ref="$tab">
          <div class="tab-header" ref="$header">   
            <div class="tab-item selected" data-value="2" data-direction="right" data-tooltip="${this.$i18n("app.tab.title.layers")}">
              <label>${iconUse("layers")}</label>
            </div>            
            <div class='tab-item' data-value='3' data-direction="right"  data-tooltip="${this.$i18n("app.tab.title.libraries")}">
              <label>${iconUse("auto_awesome")}</label>
            </div>                     
            <div class='tab-item' data-value='5' data-direction="right"  data-tooltip="${this.$i18n("app.tab.title.assets")}">
              <label>${iconUse("apps")}</label>
            </div>   
            <div class='tab-item' data-value='6' data-direction="right"  data-tooltip="${this.$i18n("app.tab.title.components")}">
              <label>${iconUse("plugin")}</label>
            </div>            

            ${this.$injectManager.getTargetUI("leftbar.tab").map((it) => {
      const { value, title: title2 } = it.class;
      let iconString = it.class.icon;
      if (obj$3[it.class.icon]) {
        iconString = iconUse(it.class.icon);
      }
      return `
                <div class='tab-item' data-value='${value}' data-direction="right"  data-tooltip="${title2}">
                  <label>${iconString || title2}</label>
                </div>
              `;
    })}

          </div>
          <div class="tab-body" ref="$body">
            <div class="tab-content selected" data-value="2">
              ${createComponent("ObjectItems")}
            </div>
            <div class='tab-content' data-value='3'>
              ${createComponent("LibraryItems")}
            </div>            
            <div class='tab-content' data-value='5'>
              ${createComponent("AssetItems")}            
              <div class='assets'>
                ${createComponent("GradientAssetsProperty")}
                ${createComponent("PatternAssetsProperty")}
                ${createComponent("ImageAssetsProperty")}
                ${createComponent("VideoAssetsProperty")}
                ${""}
              </div>
            </div>
            <div class='tab-content' data-value='6'>
              ${createComponent("CustomAssets")}
            </div>
            ${this.$injectManager.getTargetUI("leftbar.tab").map((it) => {
      const { value } = it.class;
      return `
                <div class='tab-content' data-value='${value}'>
                  ${this.$injectManager.generate(`leftbar.tab.${value}`)}
                </div>
              `;
    })}
          </div>
        </div>
      </div>
    `;
  }
  [CLICK("$header .tab-item:not(.extra-item)")](e) {
    var selectedIndexValue = e.$dt.attr("data-value");
    if (this.state.selectedIndexValue === selectedIndexValue) {
      return;
    }
    this.$el.$$(`[data-value="${this.state.selectedIndexValue}"]`).forEach((it) => it.removeClass("selected"));
    this.$el.$$(`[data-value="${selectedIndexValue}"]`).forEach((it) => it.addClass("selected"));
    this.setState({ selectedIndexValue }, false);
  }
}
class SingleInspector extends EditorElement {
  afterRender() {
    this.$el.toggle(this.$config.get("editor.design.mode") === "item");
  }
  [BIND("$el")]() {
    return {
      style: {
        display: this.$config.get("editor.design.mode") === "item" ? "block" : "none"
      }
    };
  }
  template() {
    return `
      <div class="feature-control inspector">
        <div>
              ${createComponent("AlignmentProperty")}
              ${createComponent("DepthProperty")}
              ${createComponent("PathToolProperty")}
              ${createComponent("PositionProperty")}
              ${createComponent("AppearanceProperty")}

              ${this.$injectManager.generate("inspector.tab.style")}                             
              <div class='empty'></div>
        </div>
      </div>
    `;
  }
}
var SwitchLeftPanel$1 = "";
class SwitchLeftPanel extends EditorElement {
  template() {
    return `
            <button class="elf--switch-left-panel" data-tooltip="Toggle left panel" data-direction="top left">${iconUse("switch_left")}</button>
        `;
  }
  [CLICK()]() {
    this.$config.toggle("show.left.panel");
  }
}
var SwitchRightPanel$1 = "";
class SwitchRightPanel extends EditorElement {
  template() {
    return `
            <button class="elf--switch-right-panel" data-tooltip="Toggle right panel" data-direction="top right">${iconUse("switch_right")}</button>
        `;
  }
  [CLICK()]() {
    this.$config.toggle("show.right.panel");
  }
}
class LanguageSelector extends EditorElement {
  get locales() {
    return Object.keys(this.$editor.i18n.locales);
  }
  template() {
    var languages = this.locales.map((lang) => {
      var label = this.$i18n(`app.lang.${lang}`);
      return { text: label, value: lang };
    });
    return `
            <div class='status-selector'>
                <div class='item'>
                    ${createComponent("SelectEditor", {
      ref: "$locale",
      options: languages,
      value: this.$editor.locale,
      onchange: "changeLocale"
    })}
                    /> 
                </div>
            </div>
        `;
  }
  [SUBSCRIBE_SELF("changeLocale")](key, locale) {
    this.$command.emit("setLocale", locale);
  }
}
class LayoutSelector extends EditorElement {
  template() {
    var layouts = ["all", "css", "svg"].map((layout2) => {
      var label = this.$i18n(`app.layout.${layout2}`);
      return { value: layout2, text: label };
    });
    return `
            <div class='status-selector'>
                <div class='item'>
                    ${createComponent("SelectEditor", {
      ref: "$locale",
      options: layouts,
      value: this.$editor.layout,
      onchange: "changeEditorLayoutValue"
    })}
                        
                    /> 
                </div>
            </div>
        `;
  }
  [SUBSCRIBE_SELF("changeEditorLayoutValue")](key, layout2) {
    this.$config.set("editor.layout.mode", layout2);
  }
}
var ToolBar$1 = "";
var DefaultMenu = [
  {
    type: "dropdown",
    style: {
      "margin-left": "12px"
    },
    icon: `<div class="logo-item"><label class='logo'></label></div>`,
    items: [
      {
        title: "menu.item.fullscreen.title",
        command: "toggle.fullscreen",
        shortcut: "ALT+/"
      },
      { title: "menu.item.shortcuts.title", command: "showShortcutWindow" },
      "-",
      { title: "menu.item.export.title", command: "showExportView" },
      { title: "menu.item.export.title", command: "showEmbedEditorWindow" },
      { title: "menu.item.download.title", command: "downloadJSON" },
      {
        title: "menu.item.save.title",
        command: "saveJSON",
        nextTick: () => {
          globalThis.emit("notify", "alert", "Save", "Save the content on localStorage", 2e3);
        }
      },
      {
        title: "menu.item.language.title",
        items: [
          {
            title: "English",
            command: "setLocale",
            args: [Language.EN],
            checked: (editor) => editor.locale === Language.EN
          },
          {
            title: "Fran\xE7ais",
            command: "setLocale",
            args: [Language.FR],
            checked: (editor) => editor.locale === Language.FR
          },
          {
            title: "Korean",
            command: "setLocale",
            args: [Language.KO],
            checked: (editor) => editor.locale === Language.KO
          }
        ]
      },
      "-",
      {
        title: "EasyLogic Studio",
        items: [
          {
            type: "link",
            title: "Github",
            href: "https://github.com/easylogic/editor"
          },
          {
            type: "link",
            title: "Learn",
            href: "https://www.easylogic.studio"
          }
        ]
      }
    ]
  },
  {
    type: "button",
    icon: "navigation",
    events: ["config:editing.mode"],
    selected: (editor) => {
      return editor.context.config.is("editing.mode", EditingMode.SELECT);
    },
    action: (editor) => {
      editor.emit("addLayerView", "select");
      editor.context.config.is("editing.mode.itemType", EditingMode.SELECT);
    }
  },
  {
    type: "button",
    icon: "artboard",
    events: ["config:editing.mode", "config:editing.mode.itemType"],
    selected: (editor) => {
      return editor.context.config.is("editing.mode", EditingMode.APPEND) && editor.context.config.is("editing.mode.itemType", "artboard");
    },
    action: (editor) => {
      editor.emit("addLayerView", "artboard");
    }
  },
  {
    type: "dropdown",
    icon: (editor, dropdown) => {
      var _a;
      return ((_a = dropdown.findItem(editor.context.config.get("editing.css.itemType"))) == null ? void 0 : _a.icon) || iconUse("rect");
    },
    items: [
      {
        icon: iconUse("rect"),
        title: "Rect Layer",
        key: "rect",
        command: "addLayerView",
        args: [
          "rect",
          {
            backgroundColor: "#ececec"
          }
        ],
        closable: true,
        nextTick: (editor) => {
          editor.context.config.set("editing.css.itemType", "rect");
        },
        shortcut: KeyStringMaker({ key: "R" })
      },
      {
        icon: iconUse("lens"),
        title: "Circle Layer",
        key: "circle",
        command: "addLayerView",
        args: ["circle"],
        closable: true,
        nextTick: (editor) => {
          editor.context.config.set("editing.css.itemType", "circle");
        },
        shortcut: KeyStringMaker({ key: "O" })
      },
      {
        icon: iconUse("title"),
        title: "Text",
        key: "text",
        command: "addLayerView",
        args: ["text"],
        closable: true,
        nextTick: (editor) => {
          editor.context.config.set("editing.css.itemType", "text");
        },
        shortcut: KeyStringMaker({ key: "T" })
      },
      {
        icon: iconUse("image"),
        title: "Image",
        key: "image",
        command: "addLayerView",
        args: ["image"],
        closable: true,
        nextTick: (editor) => {
          editor.context.config.set("editing.css.itemType", "image");
        },
        shortcut: KeyStringMaker({ key: "I" })
      },
      "-",
      {
        icon: iconUse("video"),
        title: "Video",
        key: "video",
        command: "addLayerView",
        args: ["video"],
        closable: true,
        nextTick: (editor) => {
          editor.context.config.set("editing.css.itemType", "video");
        },
        shortcut: KeyStringMaker({ key: "V" })
      },
      {
        icon: iconUse("iframe"),
        title: "IFrame",
        key: "iframe",
        command: "addLayerView",
        args: ["iframe"],
        closable: true,
        nextTick: (editor) => {
          editor.context.config.set("editing.css.itemType", "iframe");
        },
        shortcut: KeyStringMaker({ key: "F" })
      },
      {
        icon: iconUse("rect"),
        title: "SampleLayer",
        key: "sample",
        command: "addLayerView",
        args: ["sample"],
        closable: true,
        nextTick: (editor) => {
          editor.context.config.set("editing.css.itemType", "sample");
        }
      }
    ],
    events: [
      "config:editing.mode",
      "config:editing.mode.itemType",
      "config:editing.css.itemType"
    ],
    selected: (editor) => {
      return editor.context.config.is("editing.mode", EditingMode.APPEND) && (editor.context.config.is("editing.mode.itemType", "rect") || editor.context.config.is("editing.mode.itemType", "circle") || editor.context.config.is("editing.mode.itemType", "text") || editor.context.config.is("editing.mode.itemType", "image") || editor.context.config.is("editing.mode.itemType", "video") || editor.context.config.is("editing.mode.itemType", "iframe"));
    },
    selectedKey: (editor) => {
      return editor.context.config.get("editing.css.itemType");
    }
  },
  {
    type: "dropdown",
    icon: (editor, dropdown) => {
      var _a;
      return ((_a = dropdown.findItem(editor.context.config.get("editing.draw.itemType"))) == null ? void 0 : _a.icon) || iconUse("pentool");
    },
    items: [
      {
        icon: iconUse("pentool"),
        title: "Pen",
        key: "path",
        command: "addLayerView",
        args: ["path"],
        closable: true,
        nextTick: (editor) => {
          editor.context.config.set("editing.draw.itemType", "path");
        },
        shortcut: KeyStringMaker({ key: "P" })
      },
      {
        icon: iconUse("brush"),
        title: "Pencil",
        key: "brush",
        command: "addLayerView",
        args: ["brush"],
        closable: true,
        nextTick: (editor) => {
          editor.context.config.set("editing.draw.itemType", "brush");
        },
        shortcut: KeyStringMaker({ key: "B" })
      }
    ],
    events: [
      "config:editing.mode",
      "config:editing.mode.itemType",
      "config:editing.draw.itemType"
    ],
    selected: (editor) => {
      return editor.context.config.is("editing.mode.itemType", "path") || editor.context.config.is("editing.mode.itemType", "draw");
    },
    selectedKey: (editor) => {
      return editor.context.config.get("editing.draw.itemType");
    }
  },
  {
    type: "dropdown",
    icon: (editor, dropdown) => {
      var _a;
      return ((_a = dropdown.findItem(editor.context.config.get("editing.svg.itemType"))) == null ? void 0 : _a.icon) || iconUse("outline_rect");
    },
    items: [
      {
        icon: iconUse("outline_rect"),
        title: "Rectangle",
        key: "svg-rect",
        command: "addLayerView",
        args: ["svg-rect"],
        closable: true,
        nextTick: (editor) => {
          editor.context.config.set("editing.svg.itemType", "svg-rect");
        },
        shortcut: KeyStringMaker({ key: "Shift+R" })
      },
      {
        icon: iconUse("outline_circle"),
        title: "Circle",
        key: "svg-circle",
        command: "addLayerView",
        args: ["svg-circle"],
        closable: true,
        nextTick: (editor) => {
          editor.context.config.set("editing.svg.itemType", "svg-circle");
        },
        shortcut: KeyStringMaker({ key: "Shift+O" })
      },
      {
        icon: iconUse("polygon"),
        title: "Polygon",
        key: "svg-polygon",
        command: "addLayerView",
        args: [
          "polygon",
          {
            backgroundColor: "transparent"
          }
        ],
        closable: true,
        nextTick: (editor) => {
          editor.context.config.set("editing.svg.itemType", "polygon");
        },
        shortcut: KeyStringMaker({ key: "Shift+P" })
      },
      {
        icon: iconUse("star"),
        title: "Star",
        key: "star",
        command: "addLayerView",
        args: [
          "star",
          {
            backgroundColor: "transparent"
          }
        ],
        closable: true,
        nextTick: (editor) => {
          editor.context.config.set("editing.svg.itemType", "star");
        },
        shortcut: KeyStringMaker({ key: "Shift+S" })
      },
      "-",
      {
        icon: iconUse("smooth"),
        title: "Spline",
        key: "spline",
        command: "addLayerView",
        args: [
          "spline",
          {
            backgroundColor: "transparent"
          }
        ],
        closable: true,
        nextTick: (editor) => {
          editor.context.config.set("editing.svg.itemType", "spline");
        },
        shortcut: KeyStringMaker({ key: "Shift+L" })
      },
      {
        icon: iconUse("text_rotate"),
        title: "TextPath",
        key: "svg-texpath",
        command: "addLayerView",
        args: [
          "svg-textpath",
          {
            backgroundColor: "transparent"
          }
        ],
        closable: true,
        nextTick: (editor) => {
          editor.context.config.set("editing.svg.itemType", "svg-textpath");
        },
        shortcut: KeyStringMaker({ key: "Shift+T" })
      }
    ],
    events: [
      "config:editing.mode",
      "config:editing.mode.itemType",
      "config:editing.svg.itemType"
    ],
    selected: (editor) => {
      return editor.context.config.is("editing.mode", EditingMode.APPEND) && (editor.context.config.is("editing.mode.itemType", "svg-rect") || editor.context.config.is("editing.mode.itemType", "svg-circle") || editor.context.config.is("editing.mode.itemType", "polygon") || editor.context.config.is("editing.mode.itemType", "star") || editor.context.config.is("editing.mode.itemType", "spline") || editor.context.config.is("editing.mode.itemType", "svg-textpath"));
    },
    selectedKey: (editor) => {
      return editor.context.config.get("editing.svg.itemType");
    }
  }
];
var RightMenu = [
  {
    type: "button",
    icon: (editor) => {
      if (editor.context.config.is("editor.theme", "dark")) {
        return "dark";
      } else {
        return "light";
      }
    },
    action: (editor) => {
      if (editor.context.config.get("editor.theme") === "dark") {
        editor.context.config.set("editor.theme", "light");
      } else {
        editor.context.config.set("editor.theme", "dark");
      }
    }
  }
];
var ToolbarMenu = {
  left: () => {
    return DefaultMenu;
  },
  center: () => {
    return [
      {
        type: "button",
        icon: "navigation",
        action: (editor) => {
          editor.context.commands.emit("addCubeBox");
        }
      }
    ];
  },
  right: () => {
    return RightMenu;
  }
};
class Download extends MenuItem {
  getIconString() {
    return "source";
  }
  getTitle() {
    return this.$i18n("menu.item.download.title");
  }
  clickButton() {
    this.$commands.emit("downloadJSON");
  }
}
class Outline extends MenuItem {
  getIconString() {
    return "outline";
  }
  getTitle() {
    return "Outline";
  }
  isHideTitle() {
    return true;
  }
  clickButton() {
    this.$config.toggle("show.outline");
    this.$commands.emit("addLayerView", "select");
  }
  [CONFIG("show.outline")](isShow) {
    this.setSelected(isShow);
  }
}
class Redo extends MenuItem {
  getIconString() {
    return "redo";
  }
  getTitle() {
    return "Redo";
  }
  isHideTitle() {
    return true;
  }
  clickButton() {
    this.$commands.emit("history.redo");
  }
}
class Save extends MenuItem {
  getIconString() {
    return "storage";
  }
  getTitle() {
    return this.$i18n("menu.item.save.title");
  }
  clickButton() {
    this.$commands.emit("saveJSON");
    this.nextTick(() => {
      this.emit("notify", "alert", "Save", "Save the content on localStorage", 2e3);
    });
  }
}
class Undo extends MenuItem {
  getIconString() {
    return "undo";
  }
  getTitle() {
    return "Undo";
  }
  isHideTitle() {
    return true;
  }
  clickButton() {
    this.$commands.emit("history.undo");
  }
}
class ToolBar extends EditorElement {
  initState() {
    return {
      items: [
        {
          title: "menu.item.fullscreen.title",
          command: "toggle.fullscreen",
          shortcut: "ALT+/"
        },
        { title: "menu.item.shortcuts.title", command: "showShortcutWindow" },
        "-",
        { title: "menu.item.export.title", command: "showExportView" },
        { title: "menu.item.export.title", command: "showEmbedEditorWindow" },
        { title: "menu.item.download.title", command: "downloadJSON" },
        {
          title: "menu.item.save.title",
          command: "saveJSON",
          nextTick: () => {
            this.alert("Save", "Save the content on localStorage", 2e3);
          }
        },
        {
          title: "menu.item.language.title",
          items: [
            {
              title: "English",
              command: "setLocale",
              args: [Language.EN],
              checked: () => this.$editor.locale === Language.EN
            },
            {
              title: "Fran\xE7ais",
              command: "setLocale",
              args: [Language.FR],
              checked: () => this.$editor.locale === Language.FR
            },
            {
              title: "Korean",
              command: "setLocale",
              args: [Language.KO],
              checked: () => this.$editor.locale === Language.KO
            }
          ]
        },
        "-",
        {
          title: "EasyLogic Studio",
          items: [
            {
              type: "link",
              title: "Github",
              href: "https://github.com/easylogic/editor"
            },
            {
              type: "link",
              title: "Learn",
              href: "https://www.easylogic.studio"
            }
          ]
        }
      ]
    };
  }
  components() {
    return {
      ToolBarRenderer: ToolBarRenderer$1,
      LayoutSelector,
      LanguageSelector,
      ThemeChanger,
      Outline,
      ExportView,
      Download,
      Save,
      Undo,
      Redo,
      DropdownMenu
    };
  }
  template() {
    return `
            <div class='elf--tool-bar'>
                ${createComponent("ToolBarRenderer", {
      items: ToolbarMenu.left(this.$editor)
    })}
                <div class='center'>
                  ${createComponent("ToolBarRenderer", {
      items: this.$menu.getTargetMenu("toolbar.center")
    })}       
                  ${this.$injectManager.generate("toolbar.center")}                
                </div>
                <div class='right'>
                    ${createComponent("ToolBarRenderer", {
      items: this.$menu.getTargetMenu("toolbar.right")
    })}                                
                    ${this.$injectManager.generate("toolbar.right")}
                    ${createComponent("ThemeChanger")}
                </div>
            </div>
        `;
  }
  [LOAD("$logo")]() {
    return `
            <div class="logo-item">           
                ${createComponent("DropdownMenu", {
      ref: "$menu",
      items: this.state.items,
      dy: 6
    }, [createElement("label", { class: "logo" })])}
            </div>                                
        `;
  }
  [CONFIG("language.locale")]() {
    this.refresh();
  }
}
var CanvasView$1 = "";
var DragAreaView$1 = "";
class DragAreaRectView extends EditorElement {
  initState() {
    return {
      mode: "selection",
      x: 0,
      y: 0,
      width: 1e4,
      height: 1e4,
      cachedCurrentElement: {},
      html: ""
    };
  }
  template() {
    return `
            <div class="elf--drag-area-view" ref="$dragAreaView" style="pointer-events:none;">
                <div class='drag-area-rect' ref='$dragAreaRect'></div>
            </div>            
        `;
  }
  [SUBSCRIBE("drawAreaView")](style) {
    this.refs.$dragAreaRect.css(style);
  }
  [SUBSCRIBE("initDrawAreaView")]() {
    this.trigger("drawAreaView", {
      left: Length.px(-1e4),
      top: Length.px(0),
      width: Length.px(0),
      height: Length.px(0)
    });
  }
  [SUBSCRIBE("startDragAreaView")]() {
    this.initMousePoint = this.$viewport.getWorldPosition();
    this.dragRect = {
      left: Length.px(this.initMousePoint[0]),
      top: Length.px(this.initMousePoint[1]),
      width: Length.px(0),
      height: Length.px(0)
    };
    this.trigger("drawAreaView", this.dragRect);
  }
  getSelectedItems(rect2, areaVerties) {
    var project2 = this.$context.selection.currentProject;
    let items = [];
    let selectedArtboard = [];
    if (project2) {
      if (rect2.width === 0 && rect2.height === 0) {
        items = [];
      } else {
        project2.layers.forEach((layer) => {
          if (layer.is("artboard") && layer.isIncludeByArea(areaVerties)) {
            selectedArtboard.push(layer);
          } else if (layer.is("artboard") && layer.checkInArea(areaVerties) && layer.hasChildren() === false) {
            items.push(layer);
          } else {
            items.push.apply(items, layer.checkInAreaForAll(areaVerties));
          }
        });
        items = items.filter((it) => {
          return it.isDragSelectable;
        });
        if (items.length > 1) {
          items = items.filter((it) => {
            return it.is("artboard") === false;
          });
        }
      }
    }
    const selectedItems = selectedArtboard.length ? selectedArtboard : items;
    return selectedItems;
  }
  [SUBSCRIBE("moveDragAreaView")]() {
    const e = this.$config.get("bodyEvent");
    const targetMousePoint = this.$viewport.getWorldPosition();
    const newDist = floor([], subtract([], targetMousePoint, this.initMousePoint));
    if (e.shiftKey) {
      newDist[1] = newDist[0];
    }
    const startVertex = floor([], this.initMousePoint);
    const endVertex = floor([], add$1([], this.initMousePoint, newDist));
    const start2 = this.$viewport.applyVertex(startVertex);
    const end2 = this.$viewport.applyVertex(endVertex);
    const locaRect = toRectVerties([start2, end2]);
    this.dragRect = {
      left: locaRect[0][0],
      top: locaRect[0][1],
      width: Math.abs(locaRect[1][0] - locaRect[0][0]),
      height: Math.abs(locaRect[3][1] - locaRect[0][1])
    };
    this.trigger("drawAreaView", {
      left: Length.px(this.dragRect.left),
      top: Length.px(this.dragRect.top),
      width: Length.px(this.dragRect.width),
      height: Length.px(this.dragRect.height)
    });
    var { left: x, top: y, width: width2, height: height2 } = this.dragRect;
    var rect2 = {
      x,
      y,
      width: width2,
      height: height2
    };
    const selectedItems = this.getSelectedItems(rect2, toRectVertiesWithoutTransformOrigin([startVertex, endVertex]));
    if (this.$context.selection.selectByGroup(...selectedItems)) {
      this.emit(REFRESH_SELECTION);
    }
  }
  [SUBSCRIBE("endDragAreaView")]() {
    const targetMousePoint = this.$viewport.getWorldPosition();
    const newDist = floor([], subtract([], targetMousePoint, this.initMousePoint));
    this.$config.init("set.move.control.point", false);
    if (newDist[0] === 0 && newDist[1] === 0) {
      this.$context.selection.empty();
    }
    this.trigger("initDrawAreaView");
    this.$context.selection.reselect();
    this.$commands.emit("history.refreshSelection");
  }
}
class DragAreaView extends EditorElement {
  initState() {
    return {
      mode: "selection",
      x: 0,
      y: 0,
      width: 1e4,
      height: 1e4,
      cachedCurrentElement: {},
      html: ""
    };
  }
  template() {
    return `
            <div class="elf--drag-area-view" ref="$dragAreaView"></div>            
        `;
  }
  checkSelectionArea(e) {
    const mousePoint = this.$viewport.getWorldPosition(e);
    if (this.$context.selection.hasPoint(mousePoint)) {
      return true;
    }
  }
  checkEditMode(e) {
    if (this.$config.get("set.tool.hand")) {
      return false;
    }
    const code2 = this.$context.shortcuts.getGeneratedKeyCode(KEY_CODE.space);
    if (this.$context.keyboardManager.check(code2)) {
      return false;
    }
    const mousePoint = this.$viewport.getWorldPosition(e);
    this.inSelection = false;
    if (this.$context.selection.hasPoint(mousePoint)) {
      this.inSelection = true;
      if (this.$context.selection.current.is("artboard")) {
        if (this.$context.selection.current.hasChildren()) {
          this.$config.init("set.dragarea.mode", true);
          this.$config.init("set.move.mode", false);
          return true;
        } else {
          this.$config.init("set.dragarea.mode", false);
          this.$config.init("set.move.mode", true);
          return true;
        }
      } else {
        this.$config.init("set.dragarea.mode", false);
        this.$config.init("set.move.mode", true);
        return true;
      }
    }
    this.mouseOverItem = this.$context.selection.filteredLayers[0];
    if (this.mouseOverItem) {
      this.$config.init("set.dragarea.mode", false);
      this.$config.init("set.move.mode", true);
    } else {
      this.$config.init("set.dragarea.mode", true);
      this.$config.init("set.move.mode", false);
    }
    return true;
  }
  [POINTERSTART("$dragAreaView") + IF("checkEditMode") + MOVE("movePointer") + END("moveEndPointer")]() {
    if (this.$config.get("set.dragarea.mode")) {
      this.emit("startDragAreaView");
    }
    this.$config.set("editing.mode.itemType", "select");
  }
  initializeDragSelection() {
    this.$context.selection.reselect();
    this.$context.snapManager.clear();
    this.emit(REFRESH_SELECTION);
  }
  movePointer() {
    if (this.$config.get("set.dragarea.mode")) {
      this.emit("moveDragAreaView");
    }
  }
  moveEndPointer() {
    if (this.$config.get("set.dragarea.mode")) {
      this.emit("endDragAreaView");
    }
    this.$config.init("set.dragarea.mode", false);
    this.$config.init("set.move.mode", false);
  }
}
var HTMLRenderView$1 = "";
class HTMLRenderView extends EditorElement {
  initState() {
    return {
      mode: "selection",
      x: 0,
      y: 0,
      width: 1e4,
      height: 1e4,
      cachedCurrentElement: {},
      doubleClickTime: 0
    };
  }
  template() {
    return `
            <div class='elf--element-view' ref='$body'>
                <div class='canvas-view' 
                        data-renderer-id='${this.$editor.EDITOR_ID}' 
                        ref='$view' 
                        data-outline="${this.$config.get("show.outline")}"
                ></div>
                ${this.$injectManager.generate("render.view")}
            </div>
        `;
  }
  [BIND("$view")]() {
    const { translate: translate2, transformOrigin: origin, scale: scale2 } = this.$viewport;
    const transform2 = `translate(${translate2[0]}px, ${translate2[1]}px) scale(${scale2 || 1})`;
    const transformOrigin = `${origin[0]}px ${origin[1]}px`;
    return {
      style: {
        "transform-origin": transformOrigin,
        transform: transform2
      }
    };
  }
  [CONFIG("show.outline")]() {
    this.refs.$view.attr("data-outline", this.$config.get("show.outline"));
  }
  [SUBSCRIBE("refElement")](id, callback) {
    isFunction(callback) && callback(this.getElement(id));
  }
  [SUBSCRIBE(UPDATE_CANVAS)](obj2) {
    this.refreshSelectionStyleView(obj2);
  }
  [SUBSCRIBE(UPDATE_VIEWPORT)]() {
    this.bindData("$view");
  }
  [SUBSCRIBE("refreshAllElementBoundSize")]() {
    this.refreshAllElementBoundSize();
  }
  [SUBSCRIBE("refreshElementBoundSize")](parentObj) {
    this.refreshElementBoundSize(parentObj);
  }
  [SUBSCRIBE("updateAllCanvas")](parentLayer) {
    this.updateAllCanvas(parentLayer);
  }
  [SUBSCRIBE("refreshAllCanvas")]() {
    this.refreshAllCanvas();
  }
  [SUBSCRIBE("playTimeline", "moveTimeline")]() {
    const project2 = this.$context.selection.currentProject;
    var timeline = project2.getSelectedTimeline();
    if (timeline) {
      timeline.animations.map((it) => this.$model.get(it.id)).forEach((current) => {
        this.updateTimelineElement(current, true, false);
      });
    }
  }
  clearElementAll() {
    this.state.cachedCurrentElement = {};
  }
  clearElement(id) {
    this.state.cachedCurrentElement[id] = void 0;
  }
  getElement(id) {
    this.state.cachedCurrentElement[id] = this.refs.$view.$(`[data-id="${id}"]`);
    return this.state.cachedCurrentElement[id];
  }
  [FOCUSOUT("$view .element-item.text .text-content")](e) {
    e.$dt.removeAttr("contenteditable");
    e.$dt.removeClass("focused");
  }
  [KEYUP("$view .element-item.text .text-content")](e) {
    var content2 = e.$dt.html();
    var text2 = e.$dt.text();
    var id = e.$dt.parent().attr("data-id");
    var arr = [];
    this.$context.selection.items.filter((it) => it.id === id).forEach((item) => {
      item.reset({
        content: content2,
        text: text2
      });
      arr.push({ id: item.id, content: content2, text: text2 });
      this.refreshElementRect(item);
    });
    this.emit("refreshContent", arr);
  }
  checkEditMode(e) {
    this.state.hasDoubleClick = false;
    if (window.performance.now() - this.state.doubleClickTime < this.$config.get("event.doubleclick.timing")) {
      this.state.hasDoubleClick = true;
      return false;
    }
    if (this.$config.get("set.tool.hand")) {
      return false;
    }
    const code2 = this.$context.shortcuts.getGeneratedKeyCode(KEY_CODE.space);
    if (this.$context.keyboardManager.check(code2)) {
      return false;
    }
    const $target = Dom.create(e.target);
    if ($target.hasClass("canvas-view")) {
      return false;
    }
    if (!e.shiftKey) {
      const mousePoint = this.$viewport.getWorldPosition(e);
      if (this.$context.selection.hasPoint(mousePoint)) {
        if (this.$context.selection.hasHoverItem()) {
          if (this.$context.selection.hasParent(this.$context.selection.hoverId) === false) {
            this.$context.selection.selectHoverItem();
          }
        }
        return true;
      }
      if (this.$context.selection.hasHoverItem()) {
        this.$context.selection.selectHoverItem();
        return true;
      }
    }
    const $element = $target.closest("element-item");
    if ($element) {
      if ($element.hasClass("focused")) {
        return false;
      }
      var id = $element.attr("data-id");
      if (e.altKey === false) {
        const item = this.$model.get(id);
        if (item.is("artboard") && item.hasChildren()) {
          this.$config.init("set.dragarea.mode", true);
          return true;
        }
      }
    } else {
      return false;
    }
    return true;
  }
  [DOUBLECLICK("$view")](e) {
    this.state.doubleClickTime = window.performance.now();
    const $item = Dom.create(e.target).closest("element-item");
    if ($item) {
      const id = $item.attr("data-id");
      const item = this.$model.get(id);
      if (item.is("text")) {
        const $content = $item.$(".text-content");
        this.nextTick(() => {
          $content.addClass("focused");
          $content.attr("contenteditable", "true");
          $content.focus();
          $content.select();
        }, 100);
      } else {
        this.$context.commands.emit("doubleclick.item", e, id);
      }
    }
  }
  [CONTEXTMENU("$view") + PREVENT](e) {
    const $target = Dom.create(e.target);
    const $element = $target.closest("element-item");
    var id = $element && $element.attr("data-id");
    this.$context.selection.select(id);
    this.emit(REFRESH_SELECTION);
    this.emit(OPEN_CONTEXT_MENU, {
      target: "context.menu.layer",
      items: [
        "-",
        {
          type: "button",
          checked: true,
          title: "yellow",
          action: () => {
            console.log("console.log", "yellow");
          }
        }
      ],
      x: e.clientX,
      y: e.clientY,
      id
    });
  }
  [POINTERSTART("$view") + IF("checkEditMode") + MOVE("calculateMovedElement") + FIRSTMOVE("calculateFirstMovedElement") + END("calculateEndedElement")](e) {
    this.initMousePoint = this.$viewport.getWorldPosition(e);
    this.$config.init("set.move.control.point", true);
    this.$config.set("editing.mode.itemType", "select");
    if (this.$config.get("set.dragarea.mode")) {
      this.emit("startDragAreaView");
      return;
    }
    let isInSelectedArea = this.$context.selection.hasPoint(this.initMousePoint);
    const $target = Dom.create(e.target);
    if ($target.hasClass("canvas-view")) {
      this.$context.selection.select();
      this.initializeDragSelection();
      this.$commands.emit("history.refreshSelection");
      return false;
    }
    const $element = $target.closest("element-item");
    var id = $element && $element.attr("data-id");
    if (e.altKey) {
      if (isInSelectedArea)
        ;
      else {
        if (this.$context.selection.check({ id }) === false) {
          this.$context.selection.selectByGroup(id);
        }
      }
      if (this.$context.selection.isEmpty === false) {
        this.$context.selection.selectAfterCopy();
        this.refreshAllCanvas();
        this.emit("refreshLayerTreeView");
        this.initializeDragSelection();
        this.$commands.emit("history.refreshSelection");
      }
    } else {
      if (isInSelectedArea)
        ;
      else {
        if (e.shiftKey) {
          this.$context.selection.toggleById(id);
        } else {
          if (this.$context.selection.check({ id }) === false) {
            const current = this.$model.get(id);
            if (current && current.is("artboard") && current.hasChildren())
              ;
            else if (current.hasChildren()) {
              this.$context.selection.selectByGroup(id);
            } else {
              this.$context.selection.selectByGroup(id);
            }
          }
        }
      }
      this.initializeDragSelection();
      this.$commands.emit("history.refreshSelection");
    }
  }
  initializeDragSelection() {
    this.$context.selection.reselect();
    this.$context.snapManager.clear();
    this.emit("startGhostToolView");
  }
  calculateFirstMovedElement() {
    this.emit("hideSelectionToolView");
    this.emit("moveFirstGhostToolView");
  }
  calculateMovedElement() {
    if (this.$config.get("set.dragarea.mode")) {
      this.emit("moveDragAreaView");
      return;
    }
    const targetMousePoint = this.$viewport.getWorldPosition();
    this.emit("moveGhostToolView");
    if (this.$context.selection.isLayoutItem) {
      return;
    }
    const newDist = floor([], subtract([], targetMousePoint, this.initMousePoint));
    this.moveTo(newDist);
    if (this.$context.selection.changeInLayoutArea(this.$viewport.applyVertexInverse(targetMousePoint))) {
      this.initMousePoint = targetMousePoint;
      this.$context.selection.reselect();
      this.$context.snapManager.clear();
      this.refreshAllCanvas();
      this.emit("refreshLayerTreeView");
    }
    this.$commands.emit("setAttribute", this.$context.selection.pack("x", "y"));
  }
  moveTo(dist2) {
    const snap = this.$context.snapManager.check(this.$context.selection.cachedRectVerties.map((v) => {
      return add$1([], v, dist2);
    }), 3 / this.$viewport.scale);
    const localDist = add$1([], snap.dist, dist2);
    const result = {};
    this.$context.selection.cachedItemMatrices.forEach((it) => {
      const oldVertex = it.verties[4];
      const newVertex = add$1([], oldVertex, localDist);
      const newDist = subtract([], transformMat4([], newVertex, it.parentMatrixInverse), transformMat4([], oldVertex, it.parentMatrixInverse));
      if (this.$context.selection.isOne) {
        result[it.id] = {
          x: Math.round(it.x + newDist[0]),
          y: Math.round(it.y + newDist[1])
        };
      } else {
        result[it.id] = {
          x: it.x + newDist[0],
          y: it.y + newDist[1]
        };
      }
    });
    this.$context.selection.reset(result);
  }
  calculateEndedElement(dx, dy) {
    if (this.state.hasDoubleClick) {
      this.state.doubleClickTime = window.performance.now();
      return;
    }
    const targetMousePoint = this.$viewport.getWorldPosition();
    const newDist = dist(targetMousePoint, this.initMousePoint);
    this.$config.init("set.move.control.point", false);
    const hasMoved = Math.abs(dx) > 0.5 || Math.abs(dy) > 0.5;
    this.emit("endGhostToolView", hasMoved);
    if (this.$config.get("set.dragarea.mode")) {
      this.emit("endDragAreaView");
      this.$config.init("set.dragarea.mode", false);
      return;
    }
    if (newDist < 1)
      ;
    else {
      this.$context.selection.reselect();
      this.$context.snapManager.clear();
      this.$commands.executeCommand("setAttribute", "move item", this.$context.selection.pack("x", "y"));
      this.nextTick(() => {
        this.$commands.emit("recoverBooleanPath");
      });
    }
    this.emit(REFRESH_SELECTION);
    this.$config.set("editing.mode.itemType", "select");
  }
  refreshSelectionStyleView(obj2) {
    let target = [];
    if (obj2) {
      if (isArray(obj2)) {
        target = obj2;
      } else {
        target = [obj2];
      }
    } else {
      target = this.$context.selection.items;
    }
    target.forEach((current) => {
      this.updateElement(current);
    });
  }
  updateElement(item) {
    if (item) {
      this.$editor.html.update(item, this.getElement(item.id), this.$editor);
    }
  }
  updateTimelineElement(item) {
    if (item) {
      this.$editor.html.update(item, this.getElement(item.id), this.$editor);
    }
  }
  refreshAllCanvas() {
    this.clearElementAll();
    const project2 = this.$context.selection.currentProject;
    const html = this.$editor.html.render(project2, null, this.$editor) || "";
    this.refs.$view.updateDiff(html, void 0, {
      checkPassed: (oldEl, newEl) => {
        const isPassed = oldEl.getAttribute("data-id") === newEl.getAttribute("data-id");
        return isPassed;
      }
    });
    this.updateAllCanvas(project2);
  }
  updateAllCanvas(parentLayer) {
    parentLayer.layers.forEach((item) => {
      this.updateElement(item, this.getElement(item.id));
      this.updateAllCanvas(item);
    });
  }
  refreshAllElementBoundSize() {
    var selectionList = this.$context.selection.items.map((it) => {
      if (it.is("artboard")) {
        return it;
      }
      return it.parent;
    });
    var list2 = [...new Set(selectionList)];
    if (list2.length) {
      list2.forEach((it) => {
        this.refreshElementBoundSize(it);
      });
    } else {
      this.$context.selection.currentProject.artboards.forEach((it) => {
        this.refreshElementBoundSize(it);
      });
    }
  }
  refreshElementRect(item) {
    var $el = this.getElement(item.id);
    let offset = $el.offsetRect();
    if (offset.width === 0 || offset.height === 0) {
      return;
    }
    item.reset(offset);
    this.refreshSelectionStyleView(item);
    if (this.$context.selection.check(item)) {
      this.emit(REFRESH_SELECTION_TOOL);
    }
    this.emit(UPDATE_CANVAS, item);
  }
  refreshSelfElement(item) {
    var $el = this.getElement(item.id);
    if ($el) {
      this.refreshElementRect(item);
    }
  }
  refreshElementBoundSize(it) {
    if (it) {
      this.refreshSelfElement(it);
      it.layers.forEach((child) => {
        this.refreshElementBoundSize(child);
      });
    }
  }
  [OBSERVER("mutation") + PARAMS({
    childList: true,
    subtree: true
  })](mutations) {
    const s = new Set(mutations.map((mutation) => {
      return Dom.create(mutation.target).attr("data-id");
    }).filter(Boolean));
    [...s].forEach((id) => {
      const item = this.$editor.get(id);
      this.refreshElementBoundSize(item);
    });
  }
}
var PageTools$1 = "";
class PageTools extends EditorElement {
  template() {
    return `     
      <div class='elf--page-tools'>
        <button type='button' ref='$minus'>${iconUse("remove2")}</button>
        <div class='select'>
          ${createComponent("NumberInputEditor", {
      ref: "$scaleInput",
      min: 10,
      max: 240,
      step: 1,
      key: "scale",
      value: this.$viewport.scale * 100,
      onchange: this.subscribe((key, scale2) => {
        this.$viewport.setScale(scale2 / 100);
        this.emit(UPDATE_VIEWPORT);
        this.trigger(UPDATE_VIEWPORT);
      }, 1e3)
    })}
        </div>
        <label>%</label>
        <button type='button' ref='$plus'>${iconUse("add")}</button>        
        <button type='button' ref='$center' data-tooltip="Move to Center" data-direction="top">${iconUse("gps_fixed")}</button>    
        <button type='button' ref='$ruler' data-tooltip="Toggle Ruler" data-direction="top">${iconUse("straighten")}</button>    
        <button type='button' ref='$fullscreen' data-tooltip="FullScreen Canvas" data-direction="top">${iconUse("fullscreen")}</button>                        
        <button type='button' ref='$pantool' class="${classnames({
      on: this.$config.get("set.tool.hand")
    })}" data-tooltip="Hand | H" data-direction="top">${iconUse("pantool")}</button>   
        <!--span class="divider">|</span>
        <button type="button" ref="$selectedCount" style="color:var(--elf--selected-color);font-weight: bold;text-shadow: 1px 1px 1px rgba(255, 255, 255, 0.1)"></button-->
        <!--span ref="$buttons"></span-->
        ${this.$injectManager.generate("page.tools")}                             
      </div>

    `;
  }
  [SUBSCRIBE(UPDATE_VIEWPORT)]() {
    const scale2 = Math.floor(this.$viewport.scale * 100);
    if (this.children.$scaleInput) {
      this.children.$scaleInput.setValue(scale2);
    }
  }
  [CLICK("$plus")]() {
    const oldScale = this.$viewport.scale;
    this.$viewport.setScale(oldScale + 0.01);
    this.emit(UPDATE_VIEWPORT);
    this.trigger(UPDATE_VIEWPORT);
  }
  [CLICK("$minus")]() {
    const oldScale = this.$viewport.scale;
    this.$viewport.setScale(oldScale - 0.01);
    this.emit(UPDATE_VIEWPORT);
    this.trigger(UPDATE_VIEWPORT);
  }
  [CLICK("$center")]() {
    this.$commands.emit("moveSelectionToCenter");
  }
  [CLICK("$pantool")]() {
    this.$config.toggle("set.tool.hand");
  }
  [CLICK("$ruler")]() {
    this.$config.toggle("show.ruler");
  }
  [CLICK("$fullscreen")]() {
    this.emit("bodypanel.toggle.fullscreen");
  }
  [CLICK("$buttons button")](e) {
    const itemId = e.$dt.data("item-id");
    const pathIndex = e.$dt.data("path-index");
    const current = this.$editor.get(itemId);
    if (current.editablePath) {
      this.$commands.emit("open.editor", current);
    } else {
      const pathList = PathParser.fromSVGString(current.absolutePath().d).toPathList();
      this.emit("showPathEditor", "modify", {
        box: "canvas",
        current,
        matrix: current.matrix,
        d: pathList[pathIndex].d,
        changeEvent: (data) => {
          pathList[pathIndex].reset(data.d);
          const newPathD = current.invertPath(PathParser.joinPathList(pathList).d).d;
          this.$commands.executeCommand("setAttribute", "modify sub path", {
            [itemId]: current.updatePath(newPathD)
          });
        }
      });
    }
    this.emit("hideSelectionToolView");
  }
  [CONFIG("set.tool.hand")]() {
    this.refs.$pantool.toggleClass("on", this.$config.get("set.tool.hand"));
  }
  [LOAD("$buttons") + DOMDIFF]() {
    return "";
  }
}
class CanvasView extends EditorElement {
  components() {
    return {
      PageTools,
      DragAreaRectView,
      HTMLRenderView,
      DragAreaView
    };
  }
  initState() {
    return {
      cursor: "auto",
      cursorArgs: []
    };
  }
  afterRender() {
    this.nextTick(() => {
      this.refreshCanvasSize();
      this.$commands.emit("moveSelectionToCenter", true);
      this.refreshCursor();
    });
  }
  template() {
    return /* @__PURE__ */ createElementJsx("div", {
      class: "elf--page-container",
      tabIndex: "-1",
      ref: "$container"
    }, /* @__PURE__ */ createElementJsx("div", {
      class: "page-view",
      ref: "$pageView"
    }, /* @__PURE__ */ createElementJsx("div", {
      class: "page-lock scrollbar",
      ref: "$lock"
    }, /* @__PURE__ */ createElementJsx(DragAreaView, {
      ref: "$dragArea"
    }), /* @__PURE__ */ createElementJsx(HTMLRenderView, {
      ref: "$htmlRenderView"
    }), /* @__PURE__ */ createElementJsx(DragAreaRectView, {
      ref: "$dragAreaRectView"
    }), this.$injectManager.generate("canvas.view", true))), "$", createComponent("PageTools", { ref: "pageTools" }));
  }
  [BIND("$pageView")]() {
    return {
      style: {
        "--elf--canvas-background-color": this.$config.get("style.canvas.background.color")
      }
    };
  }
  checkSpace() {
    if (this.$config.get("set.tool.hand")) {
      return true;
    }
    return this.$context.keyboardManager.check(this.$context.shortcuts.getGeneratedKeyCode(KEY_CODE.space));
  }
  [POINTERSTART("$lock") + IF("checkSpace") + MOVE("movePan") + END("moveEndPan")]() {
    this.startMovePan();
  }
  [CONFIG("set.tool.hand")](value) {
    if (value) {
      this.startMovePan();
      this.$commands.emit("refreshCursor", "grab");
    } else {
      this.$commands.emit("recoverCursor", "auto");
    }
  }
  startMovePan() {
    this.lastDist = create$3();
  }
  movePan(dx, dy) {
    this.$commands.emit("refreshCursor", "grabbing");
    const currentDist = fromValues(dx, dy, 0);
    this.$viewport.pan(...transformMat4([], subtract([], this.lastDist, currentDist), this.$viewport.scaleMatrixInverse));
    this.lastDist = currentDist;
  }
  refreshCursor() {
    if (this.$config.get("set.tool.hand") === false) {
      this.$commands.emit("refreshCursor", "auto");
    } else {
      this.$commands.emit("refreshCursor", "grab");
    }
  }
  moveEndPan() {
    this.refreshCursor();
  }
  [DRAGOVER("$lock") + PREVENT]() {
  }
  [DROP("$lock") + PREVENT](e) {
    const newCenter = this.$viewport.getWorldPosition(e);
    if (e.dataTransfer.getData("text/asset")) {
      this.$commands.emit("drop.asset", {
        asset: { id: e.dataTransfer.getData("text/asset"), center: newCenter }
      });
    } else {
      const id = Dom.create(e.target).attr("data-id");
      if (id) {
        this.$commands.emit("drop.asset", {
          gradient: e.dataTransfer.getData("text/gradient"),
          pattern: e.dataTransfer.getData("text/pattern"),
          color: e.dataTransfer.getData("text/color"),
          imageUrl: e.dataTransfer.getData("image/info")
        }, id);
      } else {
        const imageUrl = e.dataTransfer.getData("image/info");
        this.$commands.emit("dropImageUrl", imageUrl);
      }
    }
  }
  [WHEEL("$lock") + PREVENT](e) {
    const [dx, dy] = normalizeWheelEvent(e);
    if (!this.state.gesture) {
      if (e.ctrlKey) {
        this.$viewport.setMousePoint(e.clientX, e.clientY);
      }
      this.emit("startGesture");
      this.state.gesture = true;
    } else {
      if (e.ctrlKey) {
        const zoomFactor = 1 - 2.5 * dy / 100;
        this.$viewport.zoom(zoomFactor);
      } else {
        const newDx = -2.5 * dx;
        const newDy = -2.5 * dy;
        this.$viewport.pan(-newDx / this.$viewport.scale, -newDy / this.$viewport.scale, 0);
      }
    }
    window.clearTimeout(this.state.timer);
    this.state.timer = window.setTimeout(() => {
      this.state.gesture = void 0;
      this.emit("endGesture");
    }, 200);
  }
  refreshCanvasSize() {
    this.$viewport.refreshCanvasSize(this.refs.$lock.rect());
  }
  [SUBSCRIBE(RESIZE_WINDOW, RESIZE_CANVAS)]() {
    this.refreshCanvasSize();
  }
  [SUBSCRIBE(UPDATE_VIEWPORT)]() {
    this.$commands.emit("refreshCursor", "auto");
  }
}
var HorizontalRuler$1 = "";
let pathString$1 = [];
class HorizontalRuler extends EditorElement {
  template() {
    return `
            <div class="elf--horizontal-ruler">
                <div class='horizontal-ruler-container' ref='$layerRuler'>
                    <svg class="lines" width="100%" width="100%" overflow="hidden">
                        <path ref="$rulerLines" d="" />
                    </svg>
                </div>                            
                <div class='horizontal-ruler-container' ref='$ruler'></div>
                <div class='horizontal-ruler-container' ref='$lines'></div>
                <div class='horizontal-ruler-container'>
                    <div class="cursor" ref="$cursor"></div>
                </div>
            </div>
        `;
  }
  afterRender() {
    this.refreshCanvasSize();
  }
  refreshCanvasSize() {
    this.state.rect = this.$el.rect();
  }
  initializeRect() {
    if (!this.state.rect || this.state.rect.width == 0) {
      this.state.rect = this.$el.rect();
    }
  }
  makeLine(pathString2, baseNumber, minX, maxX, realWidth, width2, epsilon = 3, lineWidth = 30, expect = 10) {
    let startX = minX - minX % baseNumber;
    let endX = maxX + maxX % baseNumber;
    const firstX = (startX - minX) / realWidth * width2;
    const secondX = (startX + baseNumber - minX) / realWidth * width2;
    if (Math.abs(secondX - firstX) < epsilon)
      return;
    for (var i = startX; i < endX; i += baseNumber) {
      if (i != 0 && i % expect === 0)
        continue;
      const x = Math.floor((i - minX) / realWidth * width2);
      pathString2[pathString2.length] = `M ${x} ${30 - lineWidth} L ${x} 30 `;
    }
  }
  makeLineText(baseNumber, minX, maxX, realWidth, width2, epsilon = 3) {
    const text2 = [];
    let startX = minX - minX % baseNumber;
    let endX = maxX + maxX % baseNumber;
    const firstX = (startX - minX) / realWidth * width2;
    const secondX = (startX + baseNumber - minX) / realWidth * width2;
    if (Math.abs(secondX - firstX) < epsilon)
      return;
    for (var i = startX; i < endX; i += baseNumber) {
      const x = Math.floor((i - minX) / realWidth * width2);
      text2[text2.length] = `<text x="${x}" y="${0}" dx="0" dy="6" text-anchor="middle" alignment-baseline="bottom" >${i}</text>`;
    }
    return text2.join("");
  }
  makeRulerForCurrentArtboard() {
    const current = this.$context.selection.current;
    if (!current)
      return "";
    const currentArtboard = current.artboard;
    if (!currentArtboard)
      return "";
    const verties = currentArtboard.verties;
    const { minX, width: realWidth } = this.$viewport;
    const width2 = this.state.rect.width;
    const firstX = (verties[0][0] - minX) / realWidth * width2;
    const secondX = (verties[2][0] - minX) / realWidth * width2;
    return `
            M ${firstX} 20 
            L ${firstX} 30 
            L ${secondX} 30 
            L ${secondX} 20 
            Z
        `;
  }
  makeRulerForCurrent() {
    const current = this.$context.selection.current;
    if (!current)
      return "";
    const verties = this.$context.selection.verties;
    const xList = verties.map((it) => it[0]);
    const currentMinX = Math.min.apply(Math, xList);
    const currentMaxX = Math.max.apply(Math, xList);
    const { minX, width: realWidth } = this.$viewport;
    const width2 = this.state.rect.width;
    const firstX = (currentMinX - minX) / realWidth * width2;
    const secondX = (currentMaxX - minX) / realWidth * width2;
    return `
            M ${firstX} 0 
            L ${firstX} 20 
            L ${secondX} 20 
            L ${secondX} 0 
            Z
        `;
  }
  makeRuler() {
    const { minX, maxX, width: realWidth } = this.$viewport;
    const width2 = this.state.rect.width;
    pathString$1 = [];
    this.makeLine(pathString$1, 1e3, minX, maxX, realWidth, width2, 10, 24, 1e4);
    this.makeLine(pathString$1, 200, minX, maxX, realWidth, width2, 10, 20, 5e3);
    this.makeLine(pathString$1, 100, minX, maxX, realWidth, width2, 10, 20, 200);
    this.makeLine(pathString$1, 50, minX, maxX, realWidth, width2, 10, 20, 100);
    this.makeLine(pathString$1, 10, minX, maxX, realWidth, width2, 10, 18, 50);
    this.makeLine(pathString$1, 5, minX, maxX, realWidth, width2, 10, 15, 10);
    this.makeLine(pathString$1, 1, minX, maxX, realWidth, width2, 10, 13, 5);
    return pathString$1.join("");
  }
  makeRulerText() {
    const { minX, maxX, width: realWidth } = this.$viewport;
    const width2 = this.state.rect.width;
    const dist2 = Math.abs(maxX - minX);
    return [
      dist2 > 3e3 ? this.makeLineText(3e3, minX, maxX, realWidth, width2, 24) : "",
      2e3 < dist2 && dist2 < 3e3 ? this.makeLineText(500, minX, maxX, realWidth, width2, 22) : "",
      1e3 < dist2 && dist2 < 2e3 ? this.makeLineText(100, minX, maxX, realWidth, width2, 20) : "",
      800 < dist2 && dist2 < 1e3 ? this.makeLineText(100, minX, maxX, realWidth, width2, 20) : "",
      500 < dist2 && dist2 < 800 ? this.makeLineText(100, minX, maxX, realWidth, width2, 20) : "",
      500 < dist2 && dist2 < 800 ? this.makeLineText(50, minX, maxX, realWidth, width2, 20) : "",
      200 < dist2 && dist2 < 500 ? this.makeLineText(50, minX, maxX, realWidth, width2, 20) : "",
      50 < dist2 && dist2 < 200 ? this.makeLineText(10, minX, maxX, realWidth, width2, 20) : "",
      15 < dist2 && dist2 < 50 ? this.makeLineText(5, minX, maxX, realWidth, width2, 20) : "",
      0 < dist2 && dist2 < 15 ? this.makeLineText(1, minX, maxX, realWidth, width2, 20) : ""
    ].join("");
  }
  [LOAD("$ruler") + DOMDIFF]() {
    this.initializeRect();
    return `
            <svg width="100%" width="100%" overflow="hidden">
                <path d="${this.makeRuler()}" fill="transparent" stroke-width="0.5" stroke="white" transform="translate(0.5, 0)" />
                ${this.makeRulerText()}                
            </svg>
        `;
  }
  [LOAD("$lines") + DOMDIFF]() {
    this.initializeRect();
    const lines = this.$config.get("horizontal.line").map((it) => {
      const pos = this.$viewport.applyVertex([it, 0, 0]);
      return `<path d="M ${pos[0]} 0 L ${pos[0]} 30"  transform="translate(0.5, 0)" />`;
    }).join("");
    return `
            <svg width="100%" height="100%" class="horizontal-line" overflow="hidden">${lines}</svg>
        `;
  }
  [BIND("$rulerLines")]() {
    return {
      d: this.makeRulerForCurrent()
    };
  }
  makeRulerCursor() {
    const targetMousePoint = this.$viewport.getWorldPosition();
    const { minX, width: realWidth } = this.$viewport;
    this.initializeRect();
    const width2 = this.state.rect.width;
    const distX = targetMousePoint[0] - minX;
    const x = distX === 0 ? 0 : distX / realWidth * width2;
    return `M ${x - 0.5} 0 L ${x - 0.5} 20`;
  }
  [BIND("$cursor")]() {
    const targetMousePoint = this.$viewport.getWorldPosition();
    const { minX, width: realWidth } = this.$viewport;
    this.initializeRect();
    const width2 = this.state.rect.width;
    const distX = targetMousePoint[0] - minX;
    const x = distX === 0 ? 0 : distX / realWidth * width2;
    return {
      cssText: `
                --elf--horizontal-cursor-position: ${x}px;
            `
    };
  }
  [MOUSEOVER()]() {
    this.$commands.emit("refreshCursor", "ns-resize");
  }
  [POINTERSTART() + MOVE() + END()]() {
    const pos = round$2([], this.$viewport.getWorldPosition());
    this.startIndex = this.$config.push("vertical.line", pos[1]);
    this.$config.init("vertical.line.selected.index", this.startIndex);
    this.$context.snapManager.clear();
  }
  move() {
    const newPos = this.$context.snapManager.getWorldPosition();
    if (this.$viewport.minY < newPos[1] && newPos[1] < this.$viewport.maxY) {
      this.$config.setIndexValue("vertical.line", this.startIndex, newPos[1]);
    }
  }
  end() {
    const pos = round$2([], this.$viewport.getWorldPosition());
    if (this.$viewport.minY < pos[1] && pos[1] < this.$viewport.maxY)
      ;
    else {
      this.$config.removeIndex("vertical.line", this.startIndex);
    }
    this.startIndex = null;
    this.$commands.emit("recoverCursor");
  }
  refresh() {
    if (this.$config.get("show.ruler")) {
      this.load();
    }
  }
  [SUBSCRIBE(UPDATE_VIEWPORT, REFRESH_SELECTION)]() {
    this.refresh();
  }
  [SUBSCRIBE(UPDATE_CANVAS) + THROTTLE(10)]() {
    if (this.$context.selection.current) {
      const current = this.$context.selection.current;
      if (current.changedRect) {
        this.refresh();
      }
    }
  }
  [SUBSCRIBE(RESIZE_WINDOW, RESIZE_CANVAS)]() {
    this.refreshCanvasSize();
  }
  [CONFIG("onMouseMovepageContainer")]() {
    this.bindData("$cursor");
    this.bindData("$rulerLines");
  }
  [CONFIG("horizontal.line")]() {
    this.load("$lines");
  }
}
var VerticalRuler$1 = "";
let pathString = [];
class VerticalRuler extends EditorElement {
  template() {
    return `
          <div class="elf--vertical-ruler">
            <div class='vertical-ruler-container' ref='$layerRuler'>
                <svg class="lines" width="100%" height="100%" overflow="hidden">
                    <path ref="$rulerLines" d=""/>
                </svg>
            </div>                                        
            <div class='vertical-ruler-container' ref='$body'></div>
            <div class='vertical-ruler-container' ref='$lines'></div>            
            <div class='vertical-ruler-container'>
                <div class="cursor" ref="$cursor"></div>
            </div>                
          </div>
        `;
  }
  afterRender() {
    this.refreshCanvasSize();
  }
  refreshCanvasSize() {
    this.state.rect = this.$el.rect();
  }
  initializeRect() {
    if (!this.state.rect || this.state.rect.width == 0) {
      this.state.rect = this.$el.rect();
    }
  }
  [MOUSEOVER()]() {
    this.$commands.emit("refreshCursor", "ew-resize");
  }
  [POINTERSTART() + MOVE() + END()]() {
    const pos = round$2([], this.$viewport.getWorldPosition());
    this.startIndex = this.$config.push("horizontal.line", pos[0]);
    this.$config.init("horizontal.line.selected.index", this.startIndex);
    this.$context.snapManager.clear();
  }
  move() {
    const newPos = this.$context.snapManager.getWorldPosition();
    if (this.$viewport.minX < newPos[0] && newPos[0] < this.$viewport.maxX) {
      this.$config.setIndexValue("horizontal.line", this.startIndex, newPos[0]);
    }
  }
  end() {
    const pos = round$2([], this.$viewport.getWorldPosition());
    if (this.$viewport.minX < pos[0] && pos[0] < this.$viewport.maxX)
      ;
    else {
      this.$config.removeIndex("horizontal.line", this.startIndex);
    }
    this.startIndex = null;
    this.$commands.emit("recoverCursor");
  }
  makeLine(pathString2, baseNumber, minY, maxY, realHeight, height2, epsilon = 3, lineWidth = 30, expect = 10) {
    let startY = minY - minY % baseNumber;
    let endY = maxY + maxY % baseNumber;
    const firstY = (startY - minY) / realHeight * height2;
    const secondY = (startY + baseNumber - minY) / realHeight * height2;
    if (Math.abs(secondY - firstY) < epsilon)
      return;
    for (var i = startY; i < endY; i += baseNumber) {
      if (i != 0 && i % expect === 0)
        continue;
      const y = Math.floor((i - minY) / realHeight * height2);
      pathString2[pathString2.length] = `M ${30 - lineWidth} ${y} L 30 ${y}`;
    }
  }
  makeLineText(baseNumber, minY, maxY, realHeight, height2, epsilon = 3) {
    const text2 = [];
    let startY = minY - minY % baseNumber;
    let endY = maxY + maxY % baseNumber;
    const firstY = (startY - minY) / realHeight * height2;
    const secondY = (startY + baseNumber - minY) / realHeight * height2;
    if (Math.abs(secondY - firstY) < epsilon)
      return;
    for (var i = startY; i < endY; i += baseNumber) {
      const y = Math.floor((i - minY) / realHeight * height2);
      text2[text2.length] = `<text x="${0}" y="${y}" dy="4" dominant-baseline="central" transform="rotate(-90, 1, ${y})">${i}</text>`;
    }
    return text2.join("");
  }
  makeRulerForCurrentArtboard() {
    const current = this.$context.selection.current;
    if (!current)
      return "";
    const currentArtboard = current.artboard;
    if (!currentArtboard)
      return "";
    const verties = currentArtboard.verties;
    const { minY, height: realHeight } = this.$viewport;
    const height2 = this.state.rect.height;
    const firstY = (verties[0][1] - minY) / realHeight * height2;
    const secondY = (verties[2][1] - minY) / realHeight * height2;
    return `
            M 20 ${firstY}
            L 30 ${firstY}
            L 30 ${secondY}
            L 20 ${secondY}
            Z
        `;
  }
  makeRulerForCurrent() {
    const current = this.$context.selection.current;
    if (!current)
      return "";
    const { minY, height: realHeight } = this.$viewport;
    const height2 = this.state.rect.height;
    const verties = this.$context.selection.verties;
    const yList = verties.map((it) => it[1]);
    const currentMinY = Math.min.apply(Math, yList);
    const currentMaxY = Math.max.apply(Math, yList);
    const firstY = (currentMinY - minY) / realHeight * height2;
    const secondY = (currentMaxY - minY) / realHeight * height2;
    return `
            M 0 ${firstY}
            L 20 ${firstY}
            L 20 ${secondY}
            L 0 ${secondY}
            Z
        `;
  }
  makeRuler() {
    const { minY, maxY, height: realHeight } = this.$viewport;
    const height2 = this.state.rect.height;
    pathString = [];
    this.makeLine(pathString, 1e3, minY, maxY, realHeight, height2, 10, 20, 1e4);
    this.makeLine(pathString, 200, minY, maxY, realHeight, height2, 10, 16, 5e3);
    this.makeLine(pathString, 100, minY, maxY, realHeight, height2, 10, 18, 200);
    this.makeLine(pathString, 50, minY, maxY, realHeight, height2, 10, 18, 100);
    this.makeLine(pathString, 10, minY, maxY, realHeight, height2, 10, 18, 50);
    this.makeLine(pathString, 5, minY, maxY, realHeight, height2, 10, 15, 10);
    this.makeLine(pathString, 1, minY, maxY, realHeight, height2, 10, 14, 5);
    return pathString.join("");
  }
  makeRulerText() {
    const { minY, maxY, height: realHeight } = this.$viewport;
    const height2 = this.state.rect.height;
    const dist2 = Math.abs(maxY - minY);
    return [
      dist2 > 3e3 ? this.makeLineText(3e3, minY, maxY, realHeight, height2, 24) : "",
      2e3 < dist2 && dist2 < 3e3 ? this.makeLineText(500, minY, maxY, realHeight, height2, 22) : "",
      1e3 < dist2 && dist2 < 2e3 ? this.makeLineText(100, minY, maxY, realHeight, height2, 20) : "",
      800 < dist2 && dist2 < 1e3 ? this.makeLineText(100, minY, maxY, realHeight, height2, 20) : "",
      500 < dist2 && dist2 < 800 ? this.makeLineText(100, minY, maxY, realHeight, height2, 20) : "",
      500 < dist2 && dist2 < 800 ? this.makeLineText(50, minY, maxY, realHeight, height2, 20) : "",
      200 < dist2 && dist2 < 500 ? this.makeLineText(50, minY, maxY, realHeight, height2, 20) : "",
      50 < dist2 && dist2 < 200 ? this.makeLineText(10, minY, maxY, realHeight, height2, 20) : "",
      15 < dist2 && dist2 < 50 ? this.makeLineText(5, minY, maxY, realHeight, height2, 20) : "",
      0 < dist2 && dist2 < 15 ? this.makeLineText(1, minY, maxY, realHeight, height2, 20) : ""
    ].join("");
  }
  [LOAD("$body") + DOMDIFF]() {
    if (!this.state.rect || this.state.rect.width == 0) {
      this.state.rect = this.$el.rect();
    }
    return `
            <svg width="100%" height="100%" overflow="hidden">
                <path d="${this.makeRuler()}" fill="transparent" stroke-width="0.5" stroke="white" transform="translate(0, 0.5)" />
                ${this.makeRulerText()}
            </svg>
        `;
  }
  [LOAD("$lines") + DOMDIFF]() {
    this.initializeRect();
    const lines = this.$config.get("vertical.line").map((it) => {
      const pos = this.$viewport.applyVertex([0, it, 0]);
      return `<path d="M 0 ${pos[1]} L 30 ${pos[1]}"  transform="translate(0, 0.5)" />`;
    }).join("");
    return `
            <svg width="100%" height="100%" class="vertical-line" overflow="hidden">${lines}</svg>
        `;
  }
  [BIND("$rulerLines")]() {
    return {
      d: this.makeRulerForCurrent()
    };
  }
  [BIND("$cursor")]() {
    const targetMousePoint = this.$viewport.getWorldPosition();
    const { minY, height: realHeight } = this.$viewport;
    this.initializeRect();
    const height2 = this.state.rect.height;
    const distY = targetMousePoint[1] - minY;
    const y = distY === 0 ? 0 : distY / realHeight * height2;
    return {
      cssText: `
                --elf--vertical-cursor-position: ${y}px;
            `
    };
  }
  refresh() {
    if (this.$config.get("show.ruler")) {
      this.load();
    }
  }
  [SUBSCRIBE(UPDATE_CANVAS) + THROTTLE(10)]() {
    const current = this.$context.selection.current;
    if (current && current.changedRect) {
      this.refresh();
    }
  }
  [SUBSCRIBE(UPDATE_VIEWPORT, REFRESH_SELECTION)]() {
    this.refresh();
  }
  [SUBSCRIBE(RESIZE_WINDOW, RESIZE_CANVAS)]() {
    this.refreshCanvasSize();
  }
  [CONFIG("onMouseMovepageContainer")]() {
    this.bindData("$cursor");
    this.bindData("$rulerLines");
  }
  [CONFIG("vertical.line")]() {
    this.load("$lines");
  }
}
var BodyPanel$1 = "";
class BodyPanel extends EditorElement {
  components() {
    return {
      CanvasView,
      VerticalRuler,
      HorizontalRuler,
      PageSubEditor
    };
  }
  template() {
    return `
      <div class="elf--body-panel">
        <div class="submenu-area">
          ${createComponent("PageSubEditor", { ref: "subeditor" })}
        </div>
        <div class='editing-area' ref="$area">
          ${createComponent("HorizontalRuler", { ref: "hruler" })}
          ${createComponent("VerticalRuler", { ref: "vruler" })}
          <div class="canvas-layout">
            ${createComponent("CanvasView", { ref: "canvas" })}
          </div>

        </div>
      </div>
    `;
  }
  [BIND("$el")]() {
    return {
      class: `elf--body-panel ${this.$config.get("show.ruler") ? "ruler" : ""}`
    };
  }
  [CONFIG("show.ruler")]() {
    this.refresh();
  }
  [SUBSCRIBE("bodypanel.toggle.fullscreen")]() {
    this.refs.$el.toggleFullscreen();
  }
  [CONFIG("editor.cursor")]() {
    this.state.cursor = this.$config.get("editor.cursor");
    this.state.cursorArgs = this.$config.get("editor.cursor.args");
    this.bindData("$container");
  }
  [CONFIG("editor.cursor.args")]() {
    this.state.cursor = this.$config.get("editor.cursor");
    this.state.cursorArgs = this.$config.get("editor.cursor.args");
    this.bindData("$area");
  }
  async [BIND("$area")]() {
    const cursor = await this.$context.cursorManager.load(this.state.cursor, ...this.state.cursorArgs || []);
    return {
      style: {
        cursor
      }
    };
  }
}
var ContextMenuManager$1 = "";
class ContextMenuManager extends EditorElement {
  template() {
    return /* @__PURE__ */ createElementJsx("div", {
      class: "elf--context-menu-manger"
    }, this.$injectManager.generate("context.menu"));
  }
  [SUBSCRIBE(OPEN_CONTEXT_MENU)](obj2) {
    this.$context.config.set("context.menu.open", obj2);
  }
}
class DesignEditor extends BaseLayout {
  initialize() {
    super.initialize();
    this.$context.pathkit.load();
  }
  afterRender() {
    super.afterRender();
    this.$config.init("editor.layout.elements", this.refs);
    this.$commands.emit("load.json", this.opt.data);
  }
  getManagers() {
    return {
      snapManager: SnapManager,
      selection: SelectionManager,
      segmentSelection: SegmentSelectionManager,
      timeline: TimelineSelectionManager,
      history: HistoryManager,
      modelManager: ModelManager,
      lockManager: LockManager,
      visibleManager: VisibleManager,
      clipboard: ClipboardManager,
      pathkit: PathKitManager
    };
  }
  components() {
    return {
      LayerTab,
      ItemLayerTab,
      ToolBar,
      Inspector,
      SingleInspector,
      BodyPanel,
      PopupManager,
      KeyboardManager,
      IconManager,
      SwitchLeftPanel,
      SwitchRightPanel,
      ContextMenuManager
    };
  }
  getPlugins() {
    return designEditorPlugins;
  }
  initState() {
    return {
      leftSize: 340,
      rightSize: 280,
      bottomSize: 0,
      lastBottomSize: 150
    };
  }
  template() {
    const isItemMode = this.$config.is("editor.design.mode", "item");
    return `
      <div class="elf-studio designeditor">
        <div class="layout-main">
          <div class='layout-top' ref='$top'>
            ${createComponent("ToolBar")}
          </div>
          <div class="layout-middle" ref='$middle'>      
            <div class="layout-body" ref='$bodyPanel'>
              ${createComponent("BodyPanel", { ref: "$bodyPanelView" })}
            </div>                           
            <div class='layout-left' ref='$leftPanel'>
              ${isItemMode ? createComponent("ItemLayerTab") : createComponent("LayerTab")}
            </div>
            <div class="layout-right" ref='$rightPanel'>
              ${isItemMode ? createComponent("SingleInspector") : createComponent("Inspector")}
            </div>
            <div class='splitter' ref='$splitter'></div>            
          </div>
          ${createComponent("KeyboardManager")}
        </div>
        ${createComponent("PopupManager")}
        ${createComponent("IconManager")}
        ${createComponent("ContextMenuManager")}
      </div>
    `;
  }
  [BIND("$el")]() {
    return {
      "data-design-mode": this.$config.get("editor.design.mode")
    };
  }
  [BIND("$splitter")]() {
    let left2 = this.state.leftSize;
    if (this.$config.false("show.left.panel")) {
      left2 = 0;
    }
    return {
      style: {
        left: left2
      }
    };
  }
  [BIND("$leftArrow")]() {
    let left2 = this.state.leftSize;
    if (this.$config.false("show.left.panel")) {
      left2 = 0;
    }
    return {
      style: {
        left: left2
      }
    };
  }
  [BIND("$leftPanel")]() {
    let left2 = `0px`;
    let width2 = this.state.leftSize;
    let bottom2 = this.state.bottomSize;
    if (this.$config.false("show.left.panel")) {
      left2 = `-${this.state.leftSize}px`;
    }
    return {
      style: { left: left2, width: width2, bottom: bottom2 }
    };
  }
  [BIND("$rightPanel")]() {
    let right2 = 0;
    let bottom2 = this.state.bottomSize;
    if (this.$config.false("show.right.panel")) {
      right2 = -this.state.rightSize;
    }
    return {
      style: {
        right: right2,
        bottom: bottom2
      }
    };
  }
  [BIND("$rightArrow")]() {
    let right2 = 6;
    let bottom2 = this.state.bottomSize;
    if (this.$config.true("show.right.panel")) {
      right2 = this.state.rightSize + 6;
    }
    return {
      style: {
        right: right2,
        bottom: bottom2
      }
    };
  }
  [BIND("$bodyPanel")]() {
    let left2 = this.state.leftSize;
    let right2 = this.state.rightSize;
    let bottom2 = this.state.bottomSize;
    if (this.$config.false("show.left.panel")) {
      left2 = 0;
    }
    if (this.$config.false("show.right.panel")) {
      right2 = 0;
    }
    return {
      style: {
        left: left2,
        right: right2,
        bottom: bottom2
      }
    };
  }
  [POINTERSTART("$splitter") + MOVE("moveSplitter") + END("moveEndSplitter")]() {
    this.minSize = this.$theme("left_size");
    this.maxSize = this.$theme("left_max_size");
    this.leftSize = Length.parse(this.refs.$splitter.css("left")).value;
    this.refs.$splitter.addClass("selected");
  }
  moveSplitter(dx) {
    this.setState({
      leftSize: Math.max(Math.min(this.leftSize + dx, this.maxSize), this.minSize)
    });
  }
  moveEndSplitter() {
    this.refs.$splitter.removeClass("selected");
  }
  refresh() {
    this.bindData("$el");
    this.bindData("$splitter");
    this.bindData("$headerPanel");
    this.bindData("$leftPanel");
    this.bindData("$rightPanel");
    this.bindData("$toggleRightButton");
    this.bindData("$toggleLeftButton");
    this.bindData("$bodyPanel");
    this.bindData("$footerPanel");
    this.emit("resizeEditor");
  }
  [CONFIG("show.left.panel")]() {
    this.refresh();
    this.nextTick(() => {
      this.emit(RESIZE_CANVAS);
      this.$config.init("editor.layout.elements", this.refs);
    });
  }
  [CONFIG("show.right.panel")]() {
    this.refresh();
    this.nextTick(() => {
      this.emit(RESIZE_CANVAS);
      this.$config.init("editor.layout.elements", this.refs);
    });
  }
  [CONFIG("editor.design.mode")]() {
    this.bindData("$el");
  }
  [DRAGOVER("$middle") + PREVENT]() {
  }
  [DROP("$middle") + PREVENT]() {
  }
  [SUBSCRIBE("toggle.fullscreen")]() {
    this.$el.toggleFullscreen();
  }
  [SUBSCRIBE("getLayoutElement")](callback) {
    if (isFunction(callback)) {
      callback(this.refs);
    }
  }
  [SUBSCRIBE(RESIZE_WINDOW, RESIZE_CANVAS)]() {
    this.$config.init("editor.layout.elements", this.refs);
  }
}
var Canvas3DView$1 = "";
/**
 * @license
 * Copyright 2010-2022 Three.js Authors
 * SPDX-License-Identifier: MIT
 */
const REVISION = "139";
const MOUSE = { LEFT: 0, MIDDLE: 1, RIGHT: 2, ROTATE: 0, DOLLY: 1, PAN: 2 };
const TOUCH = { ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3 };
const CullFaceNone = 0;
const CullFaceBack = 1;
const CullFaceFront = 2;
const PCFShadowMap = 1;
const PCFSoftShadowMap = 2;
const VSMShadowMap = 3;
const FrontSide = 0;
const BackSide = 1;
const DoubleSide = 2;
const FlatShading = 1;
const NoBlending = 0;
const NormalBlending = 1;
const AdditiveBlending = 2;
const SubtractiveBlending = 3;
const MultiplyBlending = 4;
const CustomBlending = 5;
const AddEquation = 100;
const SubtractEquation = 101;
const ReverseSubtractEquation = 102;
const MinEquation = 103;
const MaxEquation = 104;
const ZeroFactor = 200;
const OneFactor = 201;
const SrcColorFactor = 202;
const OneMinusSrcColorFactor = 203;
const SrcAlphaFactor = 204;
const OneMinusSrcAlphaFactor = 205;
const DstAlphaFactor = 206;
const OneMinusDstAlphaFactor = 207;
const DstColorFactor = 208;
const OneMinusDstColorFactor = 209;
const SrcAlphaSaturateFactor = 210;
const NeverDepth = 0;
const AlwaysDepth = 1;
const LessDepth = 2;
const LessEqualDepth = 3;
const EqualDepth = 4;
const GreaterEqualDepth = 5;
const GreaterDepth = 6;
const NotEqualDepth = 7;
const MultiplyOperation = 0;
const MixOperation = 1;
const AddOperation = 2;
const NoToneMapping = 0;
const LinearToneMapping = 1;
const ReinhardToneMapping = 2;
const CineonToneMapping = 3;
const ACESFilmicToneMapping = 4;
const CustomToneMapping = 5;
const UVMapping = 300;
const CubeReflectionMapping = 301;
const CubeRefractionMapping = 302;
const EquirectangularReflectionMapping = 303;
const EquirectangularRefractionMapping = 304;
const CubeUVReflectionMapping = 306;
const RepeatWrapping = 1e3;
const ClampToEdgeWrapping = 1001;
const MirroredRepeatWrapping = 1002;
const NearestFilter = 1003;
const NearestMipmapNearestFilter = 1004;
const NearestMipmapLinearFilter = 1005;
const LinearFilter = 1006;
const LinearMipmapNearestFilter = 1007;
const LinearMipmapLinearFilter = 1008;
const UnsignedByteType = 1009;
const ByteType = 1010;
const ShortType = 1011;
const UnsignedShortType = 1012;
const IntType = 1013;
const UnsignedIntType = 1014;
const FloatType = 1015;
const HalfFloatType = 1016;
const UnsignedShort4444Type = 1017;
const UnsignedShort5551Type = 1018;
const UnsignedInt248Type = 1020;
const AlphaFormat = 1021;
const RGBFormat = 1022;
const RGBAFormat = 1023;
const LuminanceFormat = 1024;
const LuminanceAlphaFormat = 1025;
const DepthFormat = 1026;
const DepthStencilFormat = 1027;
const RedFormat = 1028;
const RedIntegerFormat = 1029;
const RGFormat = 1030;
const RGIntegerFormat = 1031;
const RGBAIntegerFormat = 1033;
const RGB_S3TC_DXT1_Format = 33776;
const RGBA_S3TC_DXT1_Format = 33777;
const RGBA_S3TC_DXT3_Format = 33778;
const RGBA_S3TC_DXT5_Format = 33779;
const RGB_PVRTC_4BPPV1_Format = 35840;
const RGB_PVRTC_2BPPV1_Format = 35841;
const RGBA_PVRTC_4BPPV1_Format = 35842;
const RGBA_PVRTC_2BPPV1_Format = 35843;
const RGB_ETC1_Format = 36196;
const RGB_ETC2_Format = 37492;
const RGBA_ETC2_EAC_Format = 37496;
const RGBA_ASTC_4x4_Format = 37808;
const RGBA_ASTC_5x4_Format = 37809;
const RGBA_ASTC_5x5_Format = 37810;
const RGBA_ASTC_6x5_Format = 37811;
const RGBA_ASTC_6x6_Format = 37812;
const RGBA_ASTC_8x5_Format = 37813;
const RGBA_ASTC_8x6_Format = 37814;
const RGBA_ASTC_8x8_Format = 37815;
const RGBA_ASTC_10x5_Format = 37816;
const RGBA_ASTC_10x6_Format = 37817;
const RGBA_ASTC_10x8_Format = 37818;
const RGBA_ASTC_10x10_Format = 37819;
const RGBA_ASTC_12x10_Format = 37820;
const RGBA_ASTC_12x12_Format = 37821;
const RGBA_BPTC_Format = 36492;
const LoopOnce = 2200;
const LoopRepeat = 2201;
const LoopPingPong = 2202;
const InterpolateDiscrete = 2300;
const InterpolateLinear = 2301;
const InterpolateSmooth = 2302;
const ZeroCurvatureEnding = 2400;
const ZeroSlopeEnding = 2401;
const WrapAroundEnding = 2402;
const NormalAnimationBlendMode = 2500;
const AdditiveAnimationBlendMode = 2501;
const TrianglesDrawMode = 0;
const LinearEncoding = 3e3;
const sRGBEncoding = 3001;
const BasicDepthPacking = 3200;
const RGBADepthPacking = 3201;
const TangentSpaceNormalMap = 0;
const ObjectSpaceNormalMap = 1;
const SRGBColorSpace = "srgb";
const LinearSRGBColorSpace = "srgb-linear";
const KeepStencilOp = 7680;
const AlwaysStencilFunc = 519;
const StaticDrawUsage = 35044;
const DynamicDrawUsage = 35048;
const GLSL3 = "300 es";
const _SRGBAFormat = 1035;
class EventDispatcher {
  addEventListener(type, listener) {
    if (this._listeners === void 0)
      this._listeners = {};
    const listeners = this._listeners;
    if (listeners[type] === void 0) {
      listeners[type] = [];
    }
    if (listeners[type].indexOf(listener) === -1) {
      listeners[type].push(listener);
    }
  }
  hasEventListener(type, listener) {
    if (this._listeners === void 0)
      return false;
    const listeners = this._listeners;
    return listeners[type] !== void 0 && listeners[type].indexOf(listener) !== -1;
  }
  removeEventListener(type, listener) {
    if (this._listeners === void 0)
      return;
    const listeners = this._listeners;
    const listenerArray = listeners[type];
    if (listenerArray !== void 0) {
      const index2 = listenerArray.indexOf(listener);
      if (index2 !== -1) {
        listenerArray.splice(index2, 1);
      }
    }
  }
  dispatchEvent(event) {
    if (this._listeners === void 0)
      return;
    const listeners = this._listeners;
    const listenerArray = listeners[event.type];
    if (listenerArray !== void 0) {
      event.target = this;
      const array = listenerArray.slice(0);
      for (let i = 0, l = array.length; i < l; i++) {
        array[i].call(this, event);
      }
      event.target = null;
    }
  }
}
const _lut = [];
for (let i = 0; i < 256; i++) {
  _lut[i] = (i < 16 ? "0" : "") + i.toString(16);
}
const DEG2RAD = Math.PI / 180;
const RAD2DEG = 180 / Math.PI;
function generateUUID() {
  const d0 = Math.random() * 4294967295 | 0;
  const d1 = Math.random() * 4294967295 | 0;
  const d2 = Math.random() * 4294967295 | 0;
  const d3 = Math.random() * 4294967295 | 0;
  const uuid2 = _lut[d0 & 255] + _lut[d0 >> 8 & 255] + _lut[d0 >> 16 & 255] + _lut[d0 >> 24 & 255] + "-" + _lut[d1 & 255] + _lut[d1 >> 8 & 255] + "-" + _lut[d1 >> 16 & 15 | 64] + _lut[d1 >> 24 & 255] + "-" + _lut[d2 & 63 | 128] + _lut[d2 >> 8 & 255] + "-" + _lut[d2 >> 16 & 255] + _lut[d2 >> 24 & 255] + _lut[d3 & 255] + _lut[d3 >> 8 & 255] + _lut[d3 >> 16 & 255] + _lut[d3 >> 24 & 255];
  return uuid2.toLowerCase();
}
function clamp(value, min, max) {
  return Math.max(min, Math.min(max, value));
}
function euclideanModulo(n, m) {
  return (n % m + m) % m;
}
function lerp(x, y, t) {
  return (1 - t) * x + t * y;
}
function isPowerOfTwo(value) {
  return (value & value - 1) === 0 && value !== 0;
}
function ceilPowerOfTwo(value) {
  return Math.pow(2, Math.ceil(Math.log(value) / Math.LN2));
}
function floorPowerOfTwo(value) {
  return Math.pow(2, Math.floor(Math.log(value) / Math.LN2));
}
class Vector2 {
  constructor(x = 0, y = 0) {
    this.x = x;
    this.y = y;
  }
  get width() {
    return this.x;
  }
  set width(value) {
    this.x = value;
  }
  get height() {
    return this.y;
  }
  set height(value) {
    this.y = value;
  }
  set(x, y) {
    this.x = x;
    this.y = y;
    return this;
  }
  setScalar(scalar) {
    this.x = scalar;
    this.y = scalar;
    return this;
  }
  setX(x) {
    this.x = x;
    return this;
  }
  setY(y) {
    this.y = y;
    return this;
  }
  setComponent(index2, value) {
    switch (index2) {
      case 0:
        this.x = value;
        break;
      case 1:
        this.y = value;
        break;
      default:
        throw new Error("index is out of range: " + index2);
    }
    return this;
  }
  getComponent(index2) {
    switch (index2) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      default:
        throw new Error("index is out of range: " + index2);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y);
  }
  copy(v) {
    this.x = v.x;
    this.y = v.y;
    return this;
  }
  add(v, w) {
    if (w !== void 0) {
      console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.");
      return this.addVectors(v, w);
    }
    this.x += v.x;
    this.y += v.y;
    return this;
  }
  addScalar(s) {
    this.x += s;
    this.y += s;
    return this;
  }
  addVectors(a, b) {
    this.x = a.x + b.x;
    this.y = a.y + b.y;
    return this;
  }
  addScaledVector(v, s) {
    this.x += v.x * s;
    this.y += v.y * s;
    return this;
  }
  sub(v, w) {
    if (w !== void 0) {
      console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.");
      return this.subVectors(v, w);
    }
    this.x -= v.x;
    this.y -= v.y;
    return this;
  }
  subScalar(s) {
    this.x -= s;
    this.y -= s;
    return this;
  }
  subVectors(a, b) {
    this.x = a.x - b.x;
    this.y = a.y - b.y;
    return this;
  }
  multiply(v) {
    this.x *= v.x;
    this.y *= v.y;
    return this;
  }
  multiplyScalar(scalar) {
    this.x *= scalar;
    this.y *= scalar;
    return this;
  }
  divide(v) {
    this.x /= v.x;
    this.y /= v.y;
    return this;
  }
  divideScalar(scalar) {
    return this.multiplyScalar(1 / scalar);
  }
  applyMatrix3(m) {
    const x = this.x, y = this.y;
    const e = m.elements;
    this.x = e[0] * x + e[3] * y + e[6];
    this.y = e[1] * x + e[4] * y + e[7];
    return this;
  }
  min(v) {
    this.x = Math.min(this.x, v.x);
    this.y = Math.min(this.y, v.y);
    return this;
  }
  max(v) {
    this.x = Math.max(this.x, v.x);
    this.y = Math.max(this.y, v.y);
    return this;
  }
  clamp(min, max) {
    this.x = Math.max(min.x, Math.min(max.x, this.x));
    this.y = Math.max(min.y, Math.min(max.y, this.y));
    return this;
  }
  clampScalar(minVal, maxVal) {
    this.x = Math.max(minVal, Math.min(maxVal, this.x));
    this.y = Math.max(minVal, Math.min(maxVal, this.y));
    return this;
  }
  clampLength(min, max) {
    const length2 = this.length();
    return this.divideScalar(length2 || 1).multiplyScalar(Math.max(min, Math.min(max, length2)));
  }
  floor() {
    this.x = Math.floor(this.x);
    this.y = Math.floor(this.y);
    return this;
  }
  ceil() {
    this.x = Math.ceil(this.x);
    this.y = Math.ceil(this.y);
    return this;
  }
  round() {
    this.x = Math.round(this.x);
    this.y = Math.round(this.y);
    return this;
  }
  roundToZero() {
    this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
    this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
    return this;
  }
  negate() {
    this.x = -this.x;
    this.y = -this.y;
    return this;
  }
  dot(v) {
    return this.x * v.x + this.y * v.y;
  }
  cross(v) {
    return this.x * v.y - this.y * v.x;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  angle() {
    const angle = Math.atan2(-this.y, -this.x) + Math.PI;
    return angle;
  }
  distanceTo(v) {
    return Math.sqrt(this.distanceToSquared(v));
  }
  distanceToSquared(v) {
    const dx = this.x - v.x, dy = this.y - v.y;
    return dx * dx + dy * dy;
  }
  manhattanDistanceTo(v) {
    return Math.abs(this.x - v.x) + Math.abs(this.y - v.y);
  }
  setLength(length2) {
    return this.normalize().multiplyScalar(length2);
  }
  lerp(v, alpha2) {
    this.x += (v.x - this.x) * alpha2;
    this.y += (v.y - this.y) * alpha2;
    return this;
  }
  lerpVectors(v1, v2, alpha2) {
    this.x = v1.x + (v2.x - v1.x) * alpha2;
    this.y = v1.y + (v2.y - v1.y) * alpha2;
    return this;
  }
  equals(v) {
    return v.x === this.x && v.y === this.y;
  }
  fromArray(array, offset = 0) {
    this.x = array[offset];
    this.y = array[offset + 1];
    return this;
  }
  toArray(array = [], offset = 0) {
    array[offset] = this.x;
    array[offset + 1] = this.y;
    return array;
  }
  fromBufferAttribute(attribute, index2, offset) {
    if (offset !== void 0) {
      console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute().");
    }
    this.x = attribute.getX(index2);
    this.y = attribute.getY(index2);
    return this;
  }
  rotateAround(center2, angle) {
    const c2 = Math.cos(angle), s = Math.sin(angle);
    const x = this.x - center2.x;
    const y = this.y - center2.y;
    this.x = x * c2 - y * s + center2.x;
    this.y = x * s + y * c2 + center2.y;
    return this;
  }
  random() {
    this.x = Math.random();
    this.y = Math.random();
    return this;
  }
  *[Symbol.iterator]() {
    yield this.x;
    yield this.y;
  }
}
Vector2.prototype.isVector2 = true;
class Matrix3 {
  constructor() {
    this.elements = [
      1,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1
    ];
    if (arguments.length > 0) {
      console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.");
    }
  }
  set(n11, n12, n13, n21, n22, n23, n31, n32, n33) {
    const te = this.elements;
    te[0] = n11;
    te[1] = n21;
    te[2] = n31;
    te[3] = n12;
    te[4] = n22;
    te[5] = n32;
    te[6] = n13;
    te[7] = n23;
    te[8] = n33;
    return this;
  }
  identity() {
    this.set(1, 0, 0, 0, 1, 0, 0, 0, 1);
    return this;
  }
  copy(m) {
    const te = this.elements;
    const me = m.elements;
    te[0] = me[0];
    te[1] = me[1];
    te[2] = me[2];
    te[3] = me[3];
    te[4] = me[4];
    te[5] = me[5];
    te[6] = me[6];
    te[7] = me[7];
    te[8] = me[8];
    return this;
  }
  extractBasis(xAxis, yAxis, zAxis) {
    xAxis.setFromMatrix3Column(this, 0);
    yAxis.setFromMatrix3Column(this, 1);
    zAxis.setFromMatrix3Column(this, 2);
    return this;
  }
  setFromMatrix4(m) {
    const me = m.elements;
    this.set(me[0], me[4], me[8], me[1], me[5], me[9], me[2], me[6], me[10]);
    return this;
  }
  multiply(m) {
    return this.multiplyMatrices(this, m);
  }
  premultiply(m) {
    return this.multiplyMatrices(m, this);
  }
  multiplyMatrices(a, b) {
    const ae = a.elements;
    const be = b.elements;
    const te = this.elements;
    const a11 = ae[0], a12 = ae[3], a13 = ae[6];
    const a21 = ae[1], a22 = ae[4], a23 = ae[7];
    const a31 = ae[2], a32 = ae[5], a33 = ae[8];
    const b11 = be[0], b12 = be[3], b13 = be[6];
    const b21 = be[1], b22 = be[4], b23 = be[7];
    const b31 = be[2], b32 = be[5], b33 = be[8];
    te[0] = a11 * b11 + a12 * b21 + a13 * b31;
    te[3] = a11 * b12 + a12 * b22 + a13 * b32;
    te[6] = a11 * b13 + a12 * b23 + a13 * b33;
    te[1] = a21 * b11 + a22 * b21 + a23 * b31;
    te[4] = a21 * b12 + a22 * b22 + a23 * b32;
    te[7] = a21 * b13 + a22 * b23 + a23 * b33;
    te[2] = a31 * b11 + a32 * b21 + a33 * b31;
    te[5] = a31 * b12 + a32 * b22 + a33 * b32;
    te[8] = a31 * b13 + a32 * b23 + a33 * b33;
    return this;
  }
  multiplyScalar(s) {
    const te = this.elements;
    te[0] *= s;
    te[3] *= s;
    te[6] *= s;
    te[1] *= s;
    te[4] *= s;
    te[7] *= s;
    te[2] *= s;
    te[5] *= s;
    te[8] *= s;
    return this;
  }
  determinant() {
    const te = this.elements;
    const a = te[0], b = te[1], c2 = te[2], d = te[3], e = te[4], f = te[5], g = te[6], h = te[7], i = te[8];
    return a * e * i - a * f * h - b * d * i + b * f * g + c2 * d * h - c2 * e * g;
  }
  invert() {
    const te = this.elements, n11 = te[0], n21 = te[1], n31 = te[2], n12 = te[3], n22 = te[4], n32 = te[5], n13 = te[6], n23 = te[7], n33 = te[8], t11 = n33 * n22 - n32 * n23, t12 = n32 * n13 - n33 * n12, t13 = n23 * n12 - n22 * n13, det = n11 * t11 + n21 * t12 + n31 * t13;
    if (det === 0)
      return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
    const detInv = 1 / det;
    te[0] = t11 * detInv;
    te[1] = (n31 * n23 - n33 * n21) * detInv;
    te[2] = (n32 * n21 - n31 * n22) * detInv;
    te[3] = t12 * detInv;
    te[4] = (n33 * n11 - n31 * n13) * detInv;
    te[5] = (n31 * n12 - n32 * n11) * detInv;
    te[6] = t13 * detInv;
    te[7] = (n21 * n13 - n23 * n11) * detInv;
    te[8] = (n22 * n11 - n21 * n12) * detInv;
    return this;
  }
  transpose() {
    let tmp2;
    const m = this.elements;
    tmp2 = m[1];
    m[1] = m[3];
    m[3] = tmp2;
    tmp2 = m[2];
    m[2] = m[6];
    m[6] = tmp2;
    tmp2 = m[5];
    m[5] = m[7];
    m[7] = tmp2;
    return this;
  }
  getNormalMatrix(matrix4) {
    return this.setFromMatrix4(matrix4).invert().transpose();
  }
  transposeIntoArray(r) {
    const m = this.elements;
    r[0] = m[0];
    r[1] = m[3];
    r[2] = m[6];
    r[3] = m[1];
    r[4] = m[4];
    r[5] = m[7];
    r[6] = m[2];
    r[7] = m[5];
    r[8] = m[8];
    return this;
  }
  setUvTransform(tx, ty, sx, sy, rotation, cx, cy) {
    const c2 = Math.cos(rotation);
    const s = Math.sin(rotation);
    this.set(sx * c2, sx * s, -sx * (c2 * cx + s * cy) + cx + tx, -sy * s, sy * c2, -sy * (-s * cx + c2 * cy) + cy + ty, 0, 0, 1);
    return this;
  }
  scale(sx, sy) {
    const te = this.elements;
    te[0] *= sx;
    te[3] *= sx;
    te[6] *= sx;
    te[1] *= sy;
    te[4] *= sy;
    te[7] *= sy;
    return this;
  }
  rotate(theta) {
    const c2 = Math.cos(theta);
    const s = Math.sin(theta);
    const te = this.elements;
    const a11 = te[0], a12 = te[3], a13 = te[6];
    const a21 = te[1], a22 = te[4], a23 = te[7];
    te[0] = c2 * a11 + s * a21;
    te[3] = c2 * a12 + s * a22;
    te[6] = c2 * a13 + s * a23;
    te[1] = -s * a11 + c2 * a21;
    te[4] = -s * a12 + c2 * a22;
    te[7] = -s * a13 + c2 * a23;
    return this;
  }
  translate(tx, ty) {
    const te = this.elements;
    te[0] += tx * te[2];
    te[3] += tx * te[5];
    te[6] += tx * te[8];
    te[1] += ty * te[2];
    te[4] += ty * te[5];
    te[7] += ty * te[8];
    return this;
  }
  equals(matrix) {
    const te = this.elements;
    const me = matrix.elements;
    for (let i = 0; i < 9; i++) {
      if (te[i] !== me[i])
        return false;
    }
    return true;
  }
  fromArray(array, offset = 0) {
    for (let i = 0; i < 9; i++) {
      this.elements[i] = array[i + offset];
    }
    return this;
  }
  toArray(array = [], offset = 0) {
    const te = this.elements;
    array[offset] = te[0];
    array[offset + 1] = te[1];
    array[offset + 2] = te[2];
    array[offset + 3] = te[3];
    array[offset + 4] = te[4];
    array[offset + 5] = te[5];
    array[offset + 6] = te[6];
    array[offset + 7] = te[7];
    array[offset + 8] = te[8];
    return array;
  }
  clone() {
    return new this.constructor().fromArray(this.elements);
  }
}
Matrix3.prototype.isMatrix3 = true;
function arrayNeedsUint32(array) {
  for (let i = array.length - 1; i >= 0; --i) {
    if (array[i] > 65535)
      return true;
  }
  return false;
}
const TYPED_ARRAYS = {
  Int8Array,
  Uint8Array,
  Uint8ClampedArray,
  Int16Array,
  Uint16Array,
  Int32Array,
  Uint32Array,
  Float32Array,
  Float64Array
};
function getTypedArray(type, buffer) {
  return new TYPED_ARRAYS[type](buffer);
}
function createElementNS(name) {
  return document.createElementNS("http://www.w3.org/1999/xhtml", name);
}
function SRGBToLinear(c2) {
  return c2 < 0.04045 ? c2 * 0.0773993808 : Math.pow(c2 * 0.9478672986 + 0.0521327014, 2.4);
}
function LinearToSRGB(c2) {
  return c2 < 31308e-7 ? c2 * 12.92 : 1.055 * Math.pow(c2, 0.41666) - 0.055;
}
const FN = {
  [SRGBColorSpace]: { [LinearSRGBColorSpace]: SRGBToLinear },
  [LinearSRGBColorSpace]: { [SRGBColorSpace]: LinearToSRGB }
};
const ColorManagement = {
  legacyMode: true,
  get workingColorSpace() {
    return LinearSRGBColorSpace;
  },
  set workingColorSpace(colorSpace) {
    console.warn("THREE.ColorManagement: .workingColorSpace is readonly.");
  },
  convert: function(color2, sourceColorSpace, targetColorSpace) {
    if (this.legacyMode || sourceColorSpace === targetColorSpace || !sourceColorSpace || !targetColorSpace) {
      return color2;
    }
    if (FN[sourceColorSpace] && FN[sourceColorSpace][targetColorSpace] !== void 0) {
      const fn = FN[sourceColorSpace][targetColorSpace];
      color2.r = fn(color2.r);
      color2.g = fn(color2.g);
      color2.b = fn(color2.b);
      return color2;
    }
    throw new Error("Unsupported color space conversion.");
  },
  fromWorkingColorSpace: function(color2, targetColorSpace) {
    return this.convert(color2, this.workingColorSpace, targetColorSpace);
  },
  toWorkingColorSpace: function(color2, sourceColorSpace) {
    return this.convert(color2, sourceColorSpace, this.workingColorSpace);
  }
};
const _colorKeywords = {
  "aliceblue": 15792383,
  "antiquewhite": 16444375,
  "aqua": 65535,
  "aquamarine": 8388564,
  "azure": 15794175,
  "beige": 16119260,
  "bisque": 16770244,
  "black": 0,
  "blanchedalmond": 16772045,
  "blue": 255,
  "blueviolet": 9055202,
  "brown": 10824234,
  "burlywood": 14596231,
  "cadetblue": 6266528,
  "chartreuse": 8388352,
  "chocolate": 13789470,
  "coral": 16744272,
  "cornflowerblue": 6591981,
  "cornsilk": 16775388,
  "crimson": 14423100,
  "cyan": 65535,
  "darkblue": 139,
  "darkcyan": 35723,
  "darkgoldenrod": 12092939,
  "darkgray": 11119017,
  "darkgreen": 25600,
  "darkgrey": 11119017,
  "darkkhaki": 12433259,
  "darkmagenta": 9109643,
  "darkolivegreen": 5597999,
  "darkorange": 16747520,
  "darkorchid": 10040012,
  "darkred": 9109504,
  "darksalmon": 15308410,
  "darkseagreen": 9419919,
  "darkslateblue": 4734347,
  "darkslategray": 3100495,
  "darkslategrey": 3100495,
  "darkturquoise": 52945,
  "darkviolet": 9699539,
  "deeppink": 16716947,
  "deepskyblue": 49151,
  "dimgray": 6908265,
  "dimgrey": 6908265,
  "dodgerblue": 2003199,
  "firebrick": 11674146,
  "floralwhite": 16775920,
  "forestgreen": 2263842,
  "fuchsia": 16711935,
  "gainsboro": 14474460,
  "ghostwhite": 16316671,
  "gold": 16766720,
  "goldenrod": 14329120,
  "gray": 8421504,
  "green": 32768,
  "greenyellow": 11403055,
  "grey": 8421504,
  "honeydew": 15794160,
  "hotpink": 16738740,
  "indianred": 13458524,
  "indigo": 4915330,
  "ivory": 16777200,
  "khaki": 15787660,
  "lavender": 15132410,
  "lavenderblush": 16773365,
  "lawngreen": 8190976,
  "lemonchiffon": 16775885,
  "lightblue": 11393254,
  "lightcoral": 15761536,
  "lightcyan": 14745599,
  "lightgoldenrodyellow": 16448210,
  "lightgray": 13882323,
  "lightgreen": 9498256,
  "lightgrey": 13882323,
  "lightpink": 16758465,
  "lightsalmon": 16752762,
  "lightseagreen": 2142890,
  "lightskyblue": 8900346,
  "lightslategray": 7833753,
  "lightslategrey": 7833753,
  "lightsteelblue": 11584734,
  "lightyellow": 16777184,
  "lime": 65280,
  "limegreen": 3329330,
  "linen": 16445670,
  "magenta": 16711935,
  "maroon": 8388608,
  "mediumaquamarine": 6737322,
  "mediumblue": 205,
  "mediumorchid": 12211667,
  "mediumpurple": 9662683,
  "mediumseagreen": 3978097,
  "mediumslateblue": 8087790,
  "mediumspringgreen": 64154,
  "mediumturquoise": 4772300,
  "mediumvioletred": 13047173,
  "midnightblue": 1644912,
  "mintcream": 16121850,
  "mistyrose": 16770273,
  "moccasin": 16770229,
  "navajowhite": 16768685,
  "navy": 128,
  "oldlace": 16643558,
  "olive": 8421376,
  "olivedrab": 7048739,
  "orange": 16753920,
  "orangered": 16729344,
  "orchid": 14315734,
  "palegoldenrod": 15657130,
  "palegreen": 10025880,
  "paleturquoise": 11529966,
  "palevioletred": 14381203,
  "papayawhip": 16773077,
  "peachpuff": 16767673,
  "peru": 13468991,
  "pink": 16761035,
  "plum": 14524637,
  "powderblue": 11591910,
  "purple": 8388736,
  "rebeccapurple": 6697881,
  "red": 16711680,
  "rosybrown": 12357519,
  "royalblue": 4286945,
  "saddlebrown": 9127187,
  "salmon": 16416882,
  "sandybrown": 16032864,
  "seagreen": 3050327,
  "seashell": 16774638,
  "sienna": 10506797,
  "silver": 12632256,
  "skyblue": 8900331,
  "slateblue": 6970061,
  "slategray": 7372944,
  "slategrey": 7372944,
  "snow": 16775930,
  "springgreen": 65407,
  "steelblue": 4620980,
  "tan": 13808780,
  "teal": 32896,
  "thistle": 14204888,
  "tomato": 16737095,
  "turquoise": 4251856,
  "violet": 15631086,
  "wheat": 16113331,
  "white": 16777215,
  "whitesmoke": 16119285,
  "yellow": 16776960,
  "yellowgreen": 10145074
};
const _rgb = { r: 0, g: 0, b: 0 };
const _hslA = { h: 0, s: 0, l: 0 };
const _hslB = { h: 0, s: 0, l: 0 };
function hue2rgb(p, q, t) {
  if (t < 0)
    t += 1;
  if (t > 1)
    t -= 1;
  if (t < 1 / 6)
    return p + (q - p) * 6 * t;
  if (t < 1 / 2)
    return q;
  if (t < 2 / 3)
    return p + (q - p) * 6 * (2 / 3 - t);
  return p;
}
function toComponents(source2, target) {
  target.r = source2.r;
  target.g = source2.g;
  target.b = source2.b;
  return target;
}
class Color {
  constructor(r, g, b) {
    if (g === void 0 && b === void 0) {
      return this.set(r);
    }
    return this.setRGB(r, g, b);
  }
  set(value) {
    if (value && value.isColor) {
      this.copy(value);
    } else if (typeof value === "number") {
      this.setHex(value);
    } else if (typeof value === "string") {
      this.setStyle(value);
    }
    return this;
  }
  setScalar(scalar) {
    this.r = scalar;
    this.g = scalar;
    this.b = scalar;
    return this;
  }
  setHex(hex2, colorSpace = SRGBColorSpace) {
    hex2 = Math.floor(hex2);
    this.r = (hex2 >> 16 & 255) / 255;
    this.g = (hex2 >> 8 & 255) / 255;
    this.b = (hex2 & 255) / 255;
    ColorManagement.toWorkingColorSpace(this, colorSpace);
    return this;
  }
  setRGB(r, g, b, colorSpace = LinearSRGBColorSpace) {
    this.r = r;
    this.g = g;
    this.b = b;
    ColorManagement.toWorkingColorSpace(this, colorSpace);
    return this;
  }
  setHSL(h, s, l, colorSpace = LinearSRGBColorSpace) {
    h = euclideanModulo(h, 1);
    s = clamp(s, 0, 1);
    l = clamp(l, 0, 1);
    if (s === 0) {
      this.r = this.g = this.b = l;
    } else {
      const p = l <= 0.5 ? l * (1 + s) : l + s - l * s;
      const q = 2 * l - p;
      this.r = hue2rgb(q, p, h + 1 / 3);
      this.g = hue2rgb(q, p, h);
      this.b = hue2rgb(q, p, h - 1 / 3);
    }
    ColorManagement.toWorkingColorSpace(this, colorSpace);
    return this;
  }
  setStyle(style, colorSpace = SRGBColorSpace) {
    function handleAlpha(string) {
      if (string === void 0)
        return;
      if (parseFloat(string) < 1) {
        console.warn("THREE.Color: Alpha component of " + style + " will be ignored.");
      }
    }
    let m;
    if (m = /^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(style)) {
      let color2;
      const name = m[1];
      const components = m[2];
      switch (name) {
        case "rgb":
        case "rgba":
          if (color2 = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components)) {
            this.r = Math.min(255, parseInt(color2[1], 10)) / 255;
            this.g = Math.min(255, parseInt(color2[2], 10)) / 255;
            this.b = Math.min(255, parseInt(color2[3], 10)) / 255;
            ColorManagement.toWorkingColorSpace(this, colorSpace);
            handleAlpha(color2[4]);
            return this;
          }
          if (color2 = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components)) {
            this.r = Math.min(100, parseInt(color2[1], 10)) / 100;
            this.g = Math.min(100, parseInt(color2[2], 10)) / 100;
            this.b = Math.min(100, parseInt(color2[3], 10)) / 100;
            ColorManagement.toWorkingColorSpace(this, colorSpace);
            handleAlpha(color2[4]);
            return this;
          }
          break;
        case "hsl":
        case "hsla":
          if (color2 = /^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components)) {
            const h = parseFloat(color2[1]) / 360;
            const s = parseInt(color2[2], 10) / 100;
            const l = parseInt(color2[3], 10) / 100;
            handleAlpha(color2[4]);
            return this.setHSL(h, s, l, colorSpace);
          }
          break;
      }
    } else if (m = /^\#([A-Fa-f\d]+)$/.exec(style)) {
      const hex2 = m[1];
      const size2 = hex2.length;
      if (size2 === 3) {
        this.r = parseInt(hex2.charAt(0) + hex2.charAt(0), 16) / 255;
        this.g = parseInt(hex2.charAt(1) + hex2.charAt(1), 16) / 255;
        this.b = parseInt(hex2.charAt(2) + hex2.charAt(2), 16) / 255;
        ColorManagement.toWorkingColorSpace(this, colorSpace);
        return this;
      } else if (size2 === 6) {
        this.r = parseInt(hex2.charAt(0) + hex2.charAt(1), 16) / 255;
        this.g = parseInt(hex2.charAt(2) + hex2.charAt(3), 16) / 255;
        this.b = parseInt(hex2.charAt(4) + hex2.charAt(5), 16) / 255;
        ColorManagement.toWorkingColorSpace(this, colorSpace);
        return this;
      }
    }
    if (style && style.length > 0) {
      return this.setColorName(style, colorSpace);
    }
    return this;
  }
  setColorName(style, colorSpace = SRGBColorSpace) {
    const hex2 = _colorKeywords[style.toLowerCase()];
    if (hex2 !== void 0) {
      this.setHex(hex2, colorSpace);
    } else {
      console.warn("THREE.Color: Unknown color " + style);
    }
    return this;
  }
  clone() {
    return new this.constructor(this.r, this.g, this.b);
  }
  copy(color2) {
    this.r = color2.r;
    this.g = color2.g;
    this.b = color2.b;
    return this;
  }
  copySRGBToLinear(color2) {
    this.r = SRGBToLinear(color2.r);
    this.g = SRGBToLinear(color2.g);
    this.b = SRGBToLinear(color2.b);
    return this;
  }
  copyLinearToSRGB(color2) {
    this.r = LinearToSRGB(color2.r);
    this.g = LinearToSRGB(color2.g);
    this.b = LinearToSRGB(color2.b);
    return this;
  }
  convertSRGBToLinear() {
    this.copySRGBToLinear(this);
    return this;
  }
  convertLinearToSRGB() {
    this.copyLinearToSRGB(this);
    return this;
  }
  getHex(colorSpace = SRGBColorSpace) {
    ColorManagement.fromWorkingColorSpace(toComponents(this, _rgb), colorSpace);
    return clamp(_rgb.r * 255, 0, 255) << 16 ^ clamp(_rgb.g * 255, 0, 255) << 8 ^ clamp(_rgb.b * 255, 0, 255) << 0;
  }
  getHexString(colorSpace = SRGBColorSpace) {
    return ("000000" + this.getHex(colorSpace).toString(16)).slice(-6);
  }
  getHSL(target, colorSpace = LinearSRGBColorSpace) {
    ColorManagement.fromWorkingColorSpace(toComponents(this, _rgb), colorSpace);
    const r = _rgb.r, g = _rgb.g, b = _rgb.b;
    const max = Math.max(r, g, b);
    const min = Math.min(r, g, b);
    let hue, saturation;
    const lightness = (min + max) / 2;
    if (min === max) {
      hue = 0;
      saturation = 0;
    } else {
      const delta = max - min;
      saturation = lightness <= 0.5 ? delta / (max + min) : delta / (2 - max - min);
      switch (max) {
        case r:
          hue = (g - b) / delta + (g < b ? 6 : 0);
          break;
        case g:
          hue = (b - r) / delta + 2;
          break;
        case b:
          hue = (r - g) / delta + 4;
          break;
      }
      hue /= 6;
    }
    target.h = hue;
    target.s = saturation;
    target.l = lightness;
    return target;
  }
  getRGB(target, colorSpace = LinearSRGBColorSpace) {
    ColorManagement.fromWorkingColorSpace(toComponents(this, _rgb), colorSpace);
    target.r = _rgb.r;
    target.g = _rgb.g;
    target.b = _rgb.b;
    return target;
  }
  getStyle(colorSpace = SRGBColorSpace) {
    ColorManagement.fromWorkingColorSpace(toComponents(this, _rgb), colorSpace);
    if (colorSpace !== SRGBColorSpace) {
      return `color(${colorSpace} ${_rgb.r} ${_rgb.g} ${_rgb.b})`;
    }
    return `rgb(${_rgb.r * 255 | 0},${_rgb.g * 255 | 0},${_rgb.b * 255 | 0})`;
  }
  offsetHSL(h, s, l) {
    this.getHSL(_hslA);
    _hslA.h += h;
    _hslA.s += s;
    _hslA.l += l;
    this.setHSL(_hslA.h, _hslA.s, _hslA.l);
    return this;
  }
  add(color2) {
    this.r += color2.r;
    this.g += color2.g;
    this.b += color2.b;
    return this;
  }
  addColors(color1, color2) {
    this.r = color1.r + color2.r;
    this.g = color1.g + color2.g;
    this.b = color1.b + color2.b;
    return this;
  }
  addScalar(s) {
    this.r += s;
    this.g += s;
    this.b += s;
    return this;
  }
  sub(color2) {
    this.r = Math.max(0, this.r - color2.r);
    this.g = Math.max(0, this.g - color2.g);
    this.b = Math.max(0, this.b - color2.b);
    return this;
  }
  multiply(color2) {
    this.r *= color2.r;
    this.g *= color2.g;
    this.b *= color2.b;
    return this;
  }
  multiplyScalar(s) {
    this.r *= s;
    this.g *= s;
    this.b *= s;
    return this;
  }
  lerp(color2, alpha2) {
    this.r += (color2.r - this.r) * alpha2;
    this.g += (color2.g - this.g) * alpha2;
    this.b += (color2.b - this.b) * alpha2;
    return this;
  }
  lerpColors(color1, color2, alpha2) {
    this.r = color1.r + (color2.r - color1.r) * alpha2;
    this.g = color1.g + (color2.g - color1.g) * alpha2;
    this.b = color1.b + (color2.b - color1.b) * alpha2;
    return this;
  }
  lerpHSL(color2, alpha2) {
    this.getHSL(_hslA);
    color2.getHSL(_hslB);
    const h = lerp(_hslA.h, _hslB.h, alpha2);
    const s = lerp(_hslA.s, _hslB.s, alpha2);
    const l = lerp(_hslA.l, _hslB.l, alpha2);
    this.setHSL(h, s, l);
    return this;
  }
  equals(c2) {
    return c2.r === this.r && c2.g === this.g && c2.b === this.b;
  }
  fromArray(array, offset = 0) {
    this.r = array[offset];
    this.g = array[offset + 1];
    this.b = array[offset + 2];
    return this;
  }
  toArray(array = [], offset = 0) {
    array[offset] = this.r;
    array[offset + 1] = this.g;
    array[offset + 2] = this.b;
    return array;
  }
  fromBufferAttribute(attribute, index2) {
    this.r = attribute.getX(index2);
    this.g = attribute.getY(index2);
    this.b = attribute.getZ(index2);
    if (attribute.normalized === true) {
      this.r /= 255;
      this.g /= 255;
      this.b /= 255;
    }
    return this;
  }
  toJSON() {
    return this.getHex();
  }
}
Color.NAMES = _colorKeywords;
Color.prototype.isColor = true;
Color.prototype.r = 1;
Color.prototype.g = 1;
Color.prototype.b = 1;
let _canvas;
class ImageUtils {
  static getDataURL(image2) {
    if (/^data:/i.test(image2.src)) {
      return image2.src;
    }
    if (typeof HTMLCanvasElement == "undefined") {
      return image2.src;
    }
    let canvas;
    if (image2 instanceof HTMLCanvasElement) {
      canvas = image2;
    } else {
      if (_canvas === void 0)
        _canvas = createElementNS("canvas");
      _canvas.width = image2.width;
      _canvas.height = image2.height;
      const context = _canvas.getContext("2d");
      if (image2 instanceof ImageData) {
        context.putImageData(image2, 0, 0);
      } else {
        context.drawImage(image2, 0, 0, image2.width, image2.height);
      }
      canvas = _canvas;
    }
    if (canvas.width > 2048 || canvas.height > 2048) {
      console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", image2);
      return canvas.toDataURL("image/jpeg", 0.6);
    } else {
      return canvas.toDataURL("image/png");
    }
  }
  static sRGBToLinear(image2) {
    if (typeof HTMLImageElement !== "undefined" && image2 instanceof HTMLImageElement || typeof HTMLCanvasElement !== "undefined" && image2 instanceof HTMLCanvasElement || typeof ImageBitmap !== "undefined" && image2 instanceof ImageBitmap) {
      const canvas = createElementNS("canvas");
      canvas.width = image2.width;
      canvas.height = image2.height;
      const context = canvas.getContext("2d");
      context.drawImage(image2, 0, 0, image2.width, image2.height);
      const imageData = context.getImageData(0, 0, image2.width, image2.height);
      const data = imageData.data;
      for (let i = 0; i < data.length; i++) {
        data[i] = SRGBToLinear(data[i] / 255) * 255;
      }
      context.putImageData(imageData, 0, 0);
      return canvas;
    } else if (image2.data) {
      const data = image2.data.slice(0);
      for (let i = 0; i < data.length; i++) {
        if (data instanceof Uint8Array || data instanceof Uint8ClampedArray) {
          data[i] = Math.floor(SRGBToLinear(data[i] / 255) * 255);
        } else {
          data[i] = SRGBToLinear(data[i]);
        }
      }
      return {
        data,
        width: image2.width,
        height: image2.height
      };
    } else {
      console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied.");
      return image2;
    }
  }
}
class Source {
  constructor(data = null) {
    this.uuid = generateUUID();
    this.data = data;
    this.version = 0;
  }
  set needsUpdate(value) {
    if (value === true)
      this.version++;
  }
  toJSON(meta) {
    const isRootObject = meta === void 0 || typeof meta === "string";
    if (!isRootObject && meta.images[this.uuid] !== void 0) {
      return meta.images[this.uuid];
    }
    const output = {
      uuid: this.uuid,
      url: ""
    };
    const data = this.data;
    if (data !== null) {
      let url;
      if (Array.isArray(data)) {
        url = [];
        for (let i = 0, l = data.length; i < l; i++) {
          if (data[i].isDataTexture) {
            url.push(serializeImage(data[i].image));
          } else {
            url.push(serializeImage(data[i]));
          }
        }
      } else {
        url = serializeImage(data);
      }
      output.url = url;
    }
    if (!isRootObject) {
      meta.images[this.uuid] = output;
    }
    return output;
  }
}
function serializeImage(image2) {
  if (typeof HTMLImageElement !== "undefined" && image2 instanceof HTMLImageElement || typeof HTMLCanvasElement !== "undefined" && image2 instanceof HTMLCanvasElement || typeof ImageBitmap !== "undefined" && image2 instanceof ImageBitmap) {
    return ImageUtils.getDataURL(image2);
  } else {
    if (image2.data) {
      return {
        data: Array.prototype.slice.call(image2.data),
        width: image2.width,
        height: image2.height,
        type: image2.data.constructor.name
      };
    } else {
      console.warn("THREE.Texture: Unable to serialize Texture.");
      return {};
    }
  }
}
Source.prototype.isSource = true;
let textureId = 0;
class Texture extends EventDispatcher {
  constructor(image2 = Texture.DEFAULT_IMAGE, mapping = Texture.DEFAULT_MAPPING, wrapS = ClampToEdgeWrapping, wrapT = ClampToEdgeWrapping, magFilter = LinearFilter, minFilter = LinearMipmapLinearFilter, format2 = RGBAFormat, type = UnsignedByteType, anisotropy = 1, encoding = LinearEncoding) {
    super();
    Object.defineProperty(this, "id", { value: textureId++ });
    this.uuid = generateUUID();
    this.name = "";
    this.source = new Source(image2);
    this.mipmaps = [];
    this.mapping = mapping;
    this.wrapS = wrapS;
    this.wrapT = wrapT;
    this.magFilter = magFilter;
    this.minFilter = minFilter;
    this.anisotropy = anisotropy;
    this.format = format2;
    this.internalFormat = null;
    this.type = type;
    this.offset = new Vector2(0, 0);
    this.repeat = new Vector2(1, 1);
    this.center = new Vector2(0, 0);
    this.rotation = 0;
    this.matrixAutoUpdate = true;
    this.matrix = new Matrix3();
    this.generateMipmaps = true;
    this.premultiplyAlpha = false;
    this.flipY = true;
    this.unpackAlignment = 4;
    this.encoding = encoding;
    this.userData = {};
    this.version = 0;
    this.onUpdate = null;
    this.isRenderTargetTexture = false;
    this.needsPMREMUpdate = false;
  }
  get image() {
    return this.source.data;
  }
  set image(value) {
    this.source.data = value;
  }
  updateMatrix() {
    this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(source2) {
    this.name = source2.name;
    this.source = source2.source;
    this.mipmaps = source2.mipmaps.slice(0);
    this.mapping = source2.mapping;
    this.wrapS = source2.wrapS;
    this.wrapT = source2.wrapT;
    this.magFilter = source2.magFilter;
    this.minFilter = source2.minFilter;
    this.anisotropy = source2.anisotropy;
    this.format = source2.format;
    this.internalFormat = source2.internalFormat;
    this.type = source2.type;
    this.offset.copy(source2.offset);
    this.repeat.copy(source2.repeat);
    this.center.copy(source2.center);
    this.rotation = source2.rotation;
    this.matrixAutoUpdate = source2.matrixAutoUpdate;
    this.matrix.copy(source2.matrix);
    this.generateMipmaps = source2.generateMipmaps;
    this.premultiplyAlpha = source2.premultiplyAlpha;
    this.flipY = source2.flipY;
    this.unpackAlignment = source2.unpackAlignment;
    this.encoding = source2.encoding;
    this.userData = JSON.parse(JSON.stringify(source2.userData));
    this.needsUpdate = true;
    return this;
  }
  toJSON(meta) {
    const isRootObject = meta === void 0 || typeof meta === "string";
    if (!isRootObject && meta.textures[this.uuid] !== void 0) {
      return meta.textures[this.uuid];
    }
    const output = {
      metadata: {
        version: 4.5,
        type: "Texture",
        generator: "Texture.toJSON"
      },
      uuid: this.uuid,
      name: this.name,
      image: this.source.toJSON(meta).uuid,
      mapping: this.mapping,
      repeat: [this.repeat.x, this.repeat.y],
      offset: [this.offset.x, this.offset.y],
      center: [this.center.x, this.center.y],
      rotation: this.rotation,
      wrap: [this.wrapS, this.wrapT],
      format: this.format,
      type: this.type,
      encoding: this.encoding,
      minFilter: this.minFilter,
      magFilter: this.magFilter,
      anisotropy: this.anisotropy,
      flipY: this.flipY,
      premultiplyAlpha: this.premultiplyAlpha,
      unpackAlignment: this.unpackAlignment
    };
    if (JSON.stringify(this.userData) !== "{}")
      output.userData = this.userData;
    if (!isRootObject) {
      meta.textures[this.uuid] = output;
    }
    return output;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  transformUv(uv) {
    if (this.mapping !== UVMapping)
      return uv;
    uv.applyMatrix3(this.matrix);
    if (uv.x < 0 || uv.x > 1) {
      switch (this.wrapS) {
        case RepeatWrapping:
          uv.x = uv.x - Math.floor(uv.x);
          break;
        case ClampToEdgeWrapping:
          uv.x = uv.x < 0 ? 0 : 1;
          break;
        case MirroredRepeatWrapping:
          if (Math.abs(Math.floor(uv.x) % 2) === 1) {
            uv.x = Math.ceil(uv.x) - uv.x;
          } else {
            uv.x = uv.x - Math.floor(uv.x);
          }
          break;
      }
    }
    if (uv.y < 0 || uv.y > 1) {
      switch (this.wrapT) {
        case RepeatWrapping:
          uv.y = uv.y - Math.floor(uv.y);
          break;
        case ClampToEdgeWrapping:
          uv.y = uv.y < 0 ? 0 : 1;
          break;
        case MirroredRepeatWrapping:
          if (Math.abs(Math.floor(uv.y) % 2) === 1) {
            uv.y = Math.ceil(uv.y) - uv.y;
          } else {
            uv.y = uv.y - Math.floor(uv.y);
          }
          break;
      }
    }
    if (this.flipY) {
      uv.y = 1 - uv.y;
    }
    return uv;
  }
  set needsUpdate(value) {
    if (value === true) {
      this.version++;
      this.source.needsUpdate = true;
    }
  }
}
Texture.DEFAULT_IMAGE = null;
Texture.DEFAULT_MAPPING = UVMapping;
Texture.prototype.isTexture = true;
class Vector4 {
  constructor(x = 0, y = 0, z = 0, w = 1) {
    this.x = x;
    this.y = y;
    this.z = z;
    this.w = w;
  }
  get width() {
    return this.z;
  }
  set width(value) {
    this.z = value;
  }
  get height() {
    return this.w;
  }
  set height(value) {
    this.w = value;
  }
  set(x, y, z, w) {
    this.x = x;
    this.y = y;
    this.z = z;
    this.w = w;
    return this;
  }
  setScalar(scalar) {
    this.x = scalar;
    this.y = scalar;
    this.z = scalar;
    this.w = scalar;
    return this;
  }
  setX(x) {
    this.x = x;
    return this;
  }
  setY(y) {
    this.y = y;
    return this;
  }
  setZ(z) {
    this.z = z;
    return this;
  }
  setW(w) {
    this.w = w;
    return this;
  }
  setComponent(index2, value) {
    switch (index2) {
      case 0:
        this.x = value;
        break;
      case 1:
        this.y = value;
        break;
      case 2:
        this.z = value;
        break;
      case 3:
        this.w = value;
        break;
      default:
        throw new Error("index is out of range: " + index2);
    }
    return this;
  }
  getComponent(index2) {
    switch (index2) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      case 3:
        return this.w;
      default:
        throw new Error("index is out of range: " + index2);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z, this.w);
  }
  copy(v) {
    this.x = v.x;
    this.y = v.y;
    this.z = v.z;
    this.w = v.w !== void 0 ? v.w : 1;
    return this;
  }
  add(v, w) {
    if (w !== void 0) {
      console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.");
      return this.addVectors(v, w);
    }
    this.x += v.x;
    this.y += v.y;
    this.z += v.z;
    this.w += v.w;
    return this;
  }
  addScalar(s) {
    this.x += s;
    this.y += s;
    this.z += s;
    this.w += s;
    return this;
  }
  addVectors(a, b) {
    this.x = a.x + b.x;
    this.y = a.y + b.y;
    this.z = a.z + b.z;
    this.w = a.w + b.w;
    return this;
  }
  addScaledVector(v, s) {
    this.x += v.x * s;
    this.y += v.y * s;
    this.z += v.z * s;
    this.w += v.w * s;
    return this;
  }
  sub(v, w) {
    if (w !== void 0) {
      console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.");
      return this.subVectors(v, w);
    }
    this.x -= v.x;
    this.y -= v.y;
    this.z -= v.z;
    this.w -= v.w;
    return this;
  }
  subScalar(s) {
    this.x -= s;
    this.y -= s;
    this.z -= s;
    this.w -= s;
    return this;
  }
  subVectors(a, b) {
    this.x = a.x - b.x;
    this.y = a.y - b.y;
    this.z = a.z - b.z;
    this.w = a.w - b.w;
    return this;
  }
  multiply(v) {
    this.x *= v.x;
    this.y *= v.y;
    this.z *= v.z;
    this.w *= v.w;
    return this;
  }
  multiplyScalar(scalar) {
    this.x *= scalar;
    this.y *= scalar;
    this.z *= scalar;
    this.w *= scalar;
    return this;
  }
  applyMatrix4(m) {
    const x = this.x, y = this.y, z = this.z, w = this.w;
    const e = m.elements;
    this.x = e[0] * x + e[4] * y + e[8] * z + e[12] * w;
    this.y = e[1] * x + e[5] * y + e[9] * z + e[13] * w;
    this.z = e[2] * x + e[6] * y + e[10] * z + e[14] * w;
    this.w = e[3] * x + e[7] * y + e[11] * z + e[15] * w;
    return this;
  }
  divideScalar(scalar) {
    return this.multiplyScalar(1 / scalar);
  }
  setAxisAngleFromQuaternion(q) {
    this.w = 2 * Math.acos(q.w);
    const s = Math.sqrt(1 - q.w * q.w);
    if (s < 1e-4) {
      this.x = 1;
      this.y = 0;
      this.z = 0;
    } else {
      this.x = q.x / s;
      this.y = q.y / s;
      this.z = q.z / s;
    }
    return this;
  }
  setAxisAngleFromRotationMatrix(m) {
    let angle, x, y, z;
    const epsilon = 0.01, epsilon2 = 0.1, te = m.elements, m11 = te[0], m12 = te[4], m13 = te[8], m21 = te[1], m22 = te[5], m23 = te[9], m31 = te[2], m32 = te[6], m33 = te[10];
    if (Math.abs(m12 - m21) < epsilon && Math.abs(m13 - m31) < epsilon && Math.abs(m23 - m32) < epsilon) {
      if (Math.abs(m12 + m21) < epsilon2 && Math.abs(m13 + m31) < epsilon2 && Math.abs(m23 + m32) < epsilon2 && Math.abs(m11 + m22 + m33 - 3) < epsilon2) {
        this.set(1, 0, 0, 0);
        return this;
      }
      angle = Math.PI;
      const xx = (m11 + 1) / 2;
      const yy = (m22 + 1) / 2;
      const zz = (m33 + 1) / 2;
      const xy2 = (m12 + m21) / 4;
      const xz = (m13 + m31) / 4;
      const yz = (m23 + m32) / 4;
      if (xx > yy && xx > zz) {
        if (xx < epsilon) {
          x = 0;
          y = 0.707106781;
          z = 0.707106781;
        } else {
          x = Math.sqrt(xx);
          y = xy2 / x;
          z = xz / x;
        }
      } else if (yy > zz) {
        if (yy < epsilon) {
          x = 0.707106781;
          y = 0;
          z = 0.707106781;
        } else {
          y = Math.sqrt(yy);
          x = xy2 / y;
          z = yz / y;
        }
      } else {
        if (zz < epsilon) {
          x = 0.707106781;
          y = 0.707106781;
          z = 0;
        } else {
          z = Math.sqrt(zz);
          x = xz / z;
          y = yz / z;
        }
      }
      this.set(x, y, z, angle);
      return this;
    }
    let s = Math.sqrt((m32 - m23) * (m32 - m23) + (m13 - m31) * (m13 - m31) + (m21 - m12) * (m21 - m12));
    if (Math.abs(s) < 1e-3)
      s = 1;
    this.x = (m32 - m23) / s;
    this.y = (m13 - m31) / s;
    this.z = (m21 - m12) / s;
    this.w = Math.acos((m11 + m22 + m33 - 1) / 2);
    return this;
  }
  min(v) {
    this.x = Math.min(this.x, v.x);
    this.y = Math.min(this.y, v.y);
    this.z = Math.min(this.z, v.z);
    this.w = Math.min(this.w, v.w);
    return this;
  }
  max(v) {
    this.x = Math.max(this.x, v.x);
    this.y = Math.max(this.y, v.y);
    this.z = Math.max(this.z, v.z);
    this.w = Math.max(this.w, v.w);
    return this;
  }
  clamp(min, max) {
    this.x = Math.max(min.x, Math.min(max.x, this.x));
    this.y = Math.max(min.y, Math.min(max.y, this.y));
    this.z = Math.max(min.z, Math.min(max.z, this.z));
    this.w = Math.max(min.w, Math.min(max.w, this.w));
    return this;
  }
  clampScalar(minVal, maxVal) {
    this.x = Math.max(minVal, Math.min(maxVal, this.x));
    this.y = Math.max(minVal, Math.min(maxVal, this.y));
    this.z = Math.max(minVal, Math.min(maxVal, this.z));
    this.w = Math.max(minVal, Math.min(maxVal, this.w));
    return this;
  }
  clampLength(min, max) {
    const length2 = this.length();
    return this.divideScalar(length2 || 1).multiplyScalar(Math.max(min, Math.min(max, length2)));
  }
  floor() {
    this.x = Math.floor(this.x);
    this.y = Math.floor(this.y);
    this.z = Math.floor(this.z);
    this.w = Math.floor(this.w);
    return this;
  }
  ceil() {
    this.x = Math.ceil(this.x);
    this.y = Math.ceil(this.y);
    this.z = Math.ceil(this.z);
    this.w = Math.ceil(this.w);
    return this;
  }
  round() {
    this.x = Math.round(this.x);
    this.y = Math.round(this.y);
    this.z = Math.round(this.z);
    this.w = Math.round(this.w);
    return this;
  }
  roundToZero() {
    this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
    this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
    this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z);
    this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w);
    return this;
  }
  negate() {
    this.x = -this.x;
    this.y = -this.y;
    this.z = -this.z;
    this.w = -this.w;
    return this;
  }
  dot(v) {
    return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(length2) {
    return this.normalize().multiplyScalar(length2);
  }
  lerp(v, alpha2) {
    this.x += (v.x - this.x) * alpha2;
    this.y += (v.y - this.y) * alpha2;
    this.z += (v.z - this.z) * alpha2;
    this.w += (v.w - this.w) * alpha2;
    return this;
  }
  lerpVectors(v1, v2, alpha2) {
    this.x = v1.x + (v2.x - v1.x) * alpha2;
    this.y = v1.y + (v2.y - v1.y) * alpha2;
    this.z = v1.z + (v2.z - v1.z) * alpha2;
    this.w = v1.w + (v2.w - v1.w) * alpha2;
    return this;
  }
  equals(v) {
    return v.x === this.x && v.y === this.y && v.z === this.z && v.w === this.w;
  }
  fromArray(array, offset = 0) {
    this.x = array[offset];
    this.y = array[offset + 1];
    this.z = array[offset + 2];
    this.w = array[offset + 3];
    return this;
  }
  toArray(array = [], offset = 0) {
    array[offset] = this.x;
    array[offset + 1] = this.y;
    array[offset + 2] = this.z;
    array[offset + 3] = this.w;
    return array;
  }
  fromBufferAttribute(attribute, index2, offset) {
    if (offset !== void 0) {
      console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute().");
    }
    this.x = attribute.getX(index2);
    this.y = attribute.getY(index2);
    this.z = attribute.getZ(index2);
    this.w = attribute.getW(index2);
    return this;
  }
  random() {
    this.x = Math.random();
    this.y = Math.random();
    this.z = Math.random();
    this.w = Math.random();
    return this;
  }
  *[Symbol.iterator]() {
    yield this.x;
    yield this.y;
    yield this.z;
    yield this.w;
  }
}
Vector4.prototype.isVector4 = true;
class WebGLRenderTarget extends EventDispatcher {
  constructor(width2, height2, options2 = {}) {
    super();
    this.width = width2;
    this.height = height2;
    this.depth = 1;
    this.scissor = new Vector4(0, 0, width2, height2);
    this.scissorTest = false;
    this.viewport = new Vector4(0, 0, width2, height2);
    const image2 = { width: width2, height: height2, depth: 1 };
    this.texture = new Texture(image2, options2.mapping, options2.wrapS, options2.wrapT, options2.magFilter, options2.minFilter, options2.format, options2.type, options2.anisotropy, options2.encoding);
    this.texture.isRenderTargetTexture = true;
    this.texture.flipY = false;
    this.texture.generateMipmaps = options2.generateMipmaps !== void 0 ? options2.generateMipmaps : false;
    this.texture.internalFormat = options2.internalFormat !== void 0 ? options2.internalFormat : null;
    this.texture.minFilter = options2.minFilter !== void 0 ? options2.minFilter : LinearFilter;
    this.depthBuffer = options2.depthBuffer !== void 0 ? options2.depthBuffer : true;
    this.stencilBuffer = options2.stencilBuffer !== void 0 ? options2.stencilBuffer : false;
    this.depthTexture = options2.depthTexture !== void 0 ? options2.depthTexture : null;
    this.samples = options2.samples !== void 0 ? options2.samples : 0;
  }
  setSize(width2, height2, depth = 1) {
    if (this.width !== width2 || this.height !== height2 || this.depth !== depth) {
      this.width = width2;
      this.height = height2;
      this.depth = depth;
      this.texture.image.width = width2;
      this.texture.image.height = height2;
      this.texture.image.depth = depth;
      this.dispose();
    }
    this.viewport.set(0, 0, width2, height2);
    this.scissor.set(0, 0, width2, height2);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(source2) {
    this.width = source2.width;
    this.height = source2.height;
    this.depth = source2.depth;
    this.viewport.copy(source2.viewport);
    this.texture = source2.texture.clone();
    this.texture.isRenderTargetTexture = true;
    this.texture.image = Object.assign({}, source2.texture.image);
    this.depthBuffer = source2.depthBuffer;
    this.stencilBuffer = source2.stencilBuffer;
    if (source2.depthTexture !== null)
      this.depthTexture = source2.depthTexture.clone();
    this.samples = source2.samples;
    return this;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
WebGLRenderTarget.prototype.isWebGLRenderTarget = true;
class DataArrayTexture extends Texture {
  constructor(data = null, width2 = 1, height2 = 1, depth = 1) {
    super(null);
    this.image = { data, width: width2, height: height2, depth };
    this.magFilter = NearestFilter;
    this.minFilter = NearestFilter;
    this.wrapR = ClampToEdgeWrapping;
    this.generateMipmaps = false;
    this.flipY = false;
    this.unpackAlignment = 1;
  }
}
DataArrayTexture.prototype.isDataArrayTexture = true;
class WebGLArrayRenderTarget extends WebGLRenderTarget {
  constructor(width2, height2, depth) {
    super(width2, height2);
    this.depth = depth;
    this.texture = new DataArrayTexture(null, width2, height2, depth);
    this.texture.isRenderTargetTexture = true;
  }
}
WebGLArrayRenderTarget.prototype.isWebGLArrayRenderTarget = true;
class Data3DTexture extends Texture {
  constructor(data = null, width2 = 1, height2 = 1, depth = 1) {
    super(null);
    this.image = { data, width: width2, height: height2, depth };
    this.magFilter = NearestFilter;
    this.minFilter = NearestFilter;
    this.wrapR = ClampToEdgeWrapping;
    this.generateMipmaps = false;
    this.flipY = false;
    this.unpackAlignment = 1;
  }
}
Data3DTexture.prototype.isData3DTexture = true;
class WebGL3DRenderTarget extends WebGLRenderTarget {
  constructor(width2, height2, depth) {
    super(width2, height2);
    this.depth = depth;
    this.texture = new Data3DTexture(null, width2, height2, depth);
    this.texture.isRenderTargetTexture = true;
  }
}
WebGL3DRenderTarget.prototype.isWebGL3DRenderTarget = true;
class WebGLMultipleRenderTargets extends WebGLRenderTarget {
  constructor(width2, height2, count, options2 = {}) {
    super(width2, height2, options2);
    const texture2 = this.texture;
    this.texture = [];
    for (let i = 0; i < count; i++) {
      this.texture[i] = texture2.clone();
      this.texture[i].isRenderTargetTexture = true;
    }
  }
  setSize(width2, height2, depth = 1) {
    if (this.width !== width2 || this.height !== height2 || this.depth !== depth) {
      this.width = width2;
      this.height = height2;
      this.depth = depth;
      for (let i = 0, il = this.texture.length; i < il; i++) {
        this.texture[i].image.width = width2;
        this.texture[i].image.height = height2;
        this.texture[i].image.depth = depth;
      }
      this.dispose();
    }
    this.viewport.set(0, 0, width2, height2);
    this.scissor.set(0, 0, width2, height2);
    return this;
  }
  copy(source2) {
    this.dispose();
    this.width = source2.width;
    this.height = source2.height;
    this.depth = source2.depth;
    this.viewport.set(0, 0, this.width, this.height);
    this.scissor.set(0, 0, this.width, this.height);
    this.depthBuffer = source2.depthBuffer;
    this.stencilBuffer = source2.stencilBuffer;
    this.depthTexture = source2.depthTexture;
    this.texture.length = 0;
    for (let i = 0, il = source2.texture.length; i < il; i++) {
      this.texture[i] = source2.texture[i].clone();
    }
    return this;
  }
}
WebGLMultipleRenderTargets.prototype.isWebGLMultipleRenderTargets = true;
class Quaternion {
  constructor(x = 0, y = 0, z = 0, w = 1) {
    this._x = x;
    this._y = y;
    this._z = z;
    this._w = w;
  }
  static slerp(qa, qb, qm, t) {
    console.warn("THREE.Quaternion: Static .slerp() has been deprecated. Use qm.slerpQuaternions( qa, qb, t ) instead.");
    return qm.slerpQuaternions(qa, qb, t);
  }
  static slerpFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t) {
    let x0 = src0[srcOffset0 + 0], y0 = src0[srcOffset0 + 1], z0 = src0[srcOffset0 + 2], w0 = src0[srcOffset0 + 3];
    const x1 = src1[srcOffset1 + 0], y1 = src1[srcOffset1 + 1], z1 = src1[srcOffset1 + 2], w1 = src1[srcOffset1 + 3];
    if (t === 0) {
      dst[dstOffset + 0] = x0;
      dst[dstOffset + 1] = y0;
      dst[dstOffset + 2] = z0;
      dst[dstOffset + 3] = w0;
      return;
    }
    if (t === 1) {
      dst[dstOffset + 0] = x1;
      dst[dstOffset + 1] = y1;
      dst[dstOffset + 2] = z1;
      dst[dstOffset + 3] = w1;
      return;
    }
    if (w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1) {
      let s = 1 - t;
      const cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1, dir = cos >= 0 ? 1 : -1, sqrSin = 1 - cos * cos;
      if (sqrSin > Number.EPSILON) {
        const sin = Math.sqrt(sqrSin), len2 = Math.atan2(sin, cos * dir);
        s = Math.sin(s * len2) / sin;
        t = Math.sin(t * len2) / sin;
      }
      const tDir = t * dir;
      x0 = x0 * s + x1 * tDir;
      y0 = y0 * s + y1 * tDir;
      z0 = z0 * s + z1 * tDir;
      w0 = w0 * s + w1 * tDir;
      if (s === 1 - t) {
        const f = 1 / Math.sqrt(x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0);
        x0 *= f;
        y0 *= f;
        z0 *= f;
        w0 *= f;
      }
    }
    dst[dstOffset] = x0;
    dst[dstOffset + 1] = y0;
    dst[dstOffset + 2] = z0;
    dst[dstOffset + 3] = w0;
  }
  static multiplyQuaternionsFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1) {
    const x0 = src0[srcOffset0];
    const y0 = src0[srcOffset0 + 1];
    const z0 = src0[srcOffset0 + 2];
    const w0 = src0[srcOffset0 + 3];
    const x1 = src1[srcOffset1];
    const y1 = src1[srcOffset1 + 1];
    const z1 = src1[srcOffset1 + 2];
    const w1 = src1[srcOffset1 + 3];
    dst[dstOffset] = x0 * w1 + w0 * x1 + y0 * z1 - z0 * y1;
    dst[dstOffset + 1] = y0 * w1 + w0 * y1 + z0 * x1 - x0 * z1;
    dst[dstOffset + 2] = z0 * w1 + w0 * z1 + x0 * y1 - y0 * x1;
    dst[dstOffset + 3] = w0 * w1 - x0 * x1 - y0 * y1 - z0 * z1;
    return dst;
  }
  get x() {
    return this._x;
  }
  set x(value) {
    this._x = value;
    this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(value) {
    this._y = value;
    this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(value) {
    this._z = value;
    this._onChangeCallback();
  }
  get w() {
    return this._w;
  }
  set w(value) {
    this._w = value;
    this._onChangeCallback();
  }
  set(x, y, z, w) {
    this._x = x;
    this._y = y;
    this._z = z;
    this._w = w;
    this._onChangeCallback();
    return this;
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._w);
  }
  copy(quaternion) {
    this._x = quaternion.x;
    this._y = quaternion.y;
    this._z = quaternion.z;
    this._w = quaternion.w;
    this._onChangeCallback();
    return this;
  }
  setFromEuler(euler, update2) {
    if (!(euler && euler.isEuler)) {
      throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");
    }
    const x = euler._x, y = euler._y, z = euler._z, order = euler._order;
    const cos = Math.cos;
    const sin = Math.sin;
    const c1 = cos(x / 2);
    const c2 = cos(y / 2);
    const c3 = cos(z / 2);
    const s1 = sin(x / 2);
    const s2 = sin(y / 2);
    const s3 = sin(z / 2);
    switch (order) {
      case "XYZ":
        this._x = s1 * c2 * c3 + c1 * s2 * s3;
        this._y = c1 * s2 * c3 - s1 * c2 * s3;
        this._z = c1 * c2 * s3 + s1 * s2 * c3;
        this._w = c1 * c2 * c3 - s1 * s2 * s3;
        break;
      case "YXZ":
        this._x = s1 * c2 * c3 + c1 * s2 * s3;
        this._y = c1 * s2 * c3 - s1 * c2 * s3;
        this._z = c1 * c2 * s3 - s1 * s2 * c3;
        this._w = c1 * c2 * c3 + s1 * s2 * s3;
        break;
      case "ZXY":
        this._x = s1 * c2 * c3 - c1 * s2 * s3;
        this._y = c1 * s2 * c3 + s1 * c2 * s3;
        this._z = c1 * c2 * s3 + s1 * s2 * c3;
        this._w = c1 * c2 * c3 - s1 * s2 * s3;
        break;
      case "ZYX":
        this._x = s1 * c2 * c3 - c1 * s2 * s3;
        this._y = c1 * s2 * c3 + s1 * c2 * s3;
        this._z = c1 * c2 * s3 - s1 * s2 * c3;
        this._w = c1 * c2 * c3 + s1 * s2 * s3;
        break;
      case "YZX":
        this._x = s1 * c2 * c3 + c1 * s2 * s3;
        this._y = c1 * s2 * c3 + s1 * c2 * s3;
        this._z = c1 * c2 * s3 - s1 * s2 * c3;
        this._w = c1 * c2 * c3 - s1 * s2 * s3;
        break;
      case "XZY":
        this._x = s1 * c2 * c3 - c1 * s2 * s3;
        this._y = c1 * s2 * c3 - s1 * c2 * s3;
        this._z = c1 * c2 * s3 + s1 * s2 * c3;
        this._w = c1 * c2 * c3 + s1 * s2 * s3;
        break;
      default:
        console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + order);
    }
    if (update2 !== false)
      this._onChangeCallback();
    return this;
  }
  setFromAxisAngle(axis, angle) {
    const halfAngle = angle / 2, s = Math.sin(halfAngle);
    this._x = axis.x * s;
    this._y = axis.y * s;
    this._z = axis.z * s;
    this._w = Math.cos(halfAngle);
    this._onChangeCallback();
    return this;
  }
  setFromRotationMatrix(m) {
    const te = m.elements, m11 = te[0], m12 = te[4], m13 = te[8], m21 = te[1], m22 = te[5], m23 = te[9], m31 = te[2], m32 = te[6], m33 = te[10], trace = m11 + m22 + m33;
    if (trace > 0) {
      const s = 0.5 / Math.sqrt(trace + 1);
      this._w = 0.25 / s;
      this._x = (m32 - m23) * s;
      this._y = (m13 - m31) * s;
      this._z = (m21 - m12) * s;
    } else if (m11 > m22 && m11 > m33) {
      const s = 2 * Math.sqrt(1 + m11 - m22 - m33);
      this._w = (m32 - m23) / s;
      this._x = 0.25 * s;
      this._y = (m12 + m21) / s;
      this._z = (m13 + m31) / s;
    } else if (m22 > m33) {
      const s = 2 * Math.sqrt(1 + m22 - m11 - m33);
      this._w = (m13 - m31) / s;
      this._x = (m12 + m21) / s;
      this._y = 0.25 * s;
      this._z = (m23 + m32) / s;
    } else {
      const s = 2 * Math.sqrt(1 + m33 - m11 - m22);
      this._w = (m21 - m12) / s;
      this._x = (m13 + m31) / s;
      this._y = (m23 + m32) / s;
      this._z = 0.25 * s;
    }
    this._onChangeCallback();
    return this;
  }
  setFromUnitVectors(vFrom, vTo) {
    let r = vFrom.dot(vTo) + 1;
    if (r < Number.EPSILON) {
      r = 0;
      if (Math.abs(vFrom.x) > Math.abs(vFrom.z)) {
        this._x = -vFrom.y;
        this._y = vFrom.x;
        this._z = 0;
        this._w = r;
      } else {
        this._x = 0;
        this._y = -vFrom.z;
        this._z = vFrom.y;
        this._w = r;
      }
    } else {
      this._x = vFrom.y * vTo.z - vFrom.z * vTo.y;
      this._y = vFrom.z * vTo.x - vFrom.x * vTo.z;
      this._z = vFrom.x * vTo.y - vFrom.y * vTo.x;
      this._w = r;
    }
    return this.normalize();
  }
  angleTo(q) {
    return 2 * Math.acos(Math.abs(clamp(this.dot(q), -1, 1)));
  }
  rotateTowards(q, step2) {
    const angle = this.angleTo(q);
    if (angle === 0)
      return this;
    const t = Math.min(1, step2 / angle);
    this.slerp(q, t);
    return this;
  }
  identity() {
    return this.set(0, 0, 0, 1);
  }
  invert() {
    return this.conjugate();
  }
  conjugate() {
    this._x *= -1;
    this._y *= -1;
    this._z *= -1;
    this._onChangeCallback();
    return this;
  }
  dot(v) {
    return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;
  }
  lengthSq() {
    return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
  }
  length() {
    return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
  }
  normalize() {
    let l = this.length();
    if (l === 0) {
      this._x = 0;
      this._y = 0;
      this._z = 0;
      this._w = 1;
    } else {
      l = 1 / l;
      this._x = this._x * l;
      this._y = this._y * l;
      this._z = this._z * l;
      this._w = this._w * l;
    }
    this._onChangeCallback();
    return this;
  }
  multiply(q, p) {
    if (p !== void 0) {
      console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.");
      return this.multiplyQuaternions(q, p);
    }
    return this.multiplyQuaternions(this, q);
  }
  premultiply(q) {
    return this.multiplyQuaternions(q, this);
  }
  multiplyQuaternions(a, b) {
    const qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;
    const qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;
    this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
    this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
    this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
    this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;
    this._onChangeCallback();
    return this;
  }
  slerp(qb, t) {
    if (t === 0)
      return this;
    if (t === 1)
      return this.copy(qb);
    const x = this._x, y = this._y, z = this._z, w = this._w;
    let cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;
    if (cosHalfTheta < 0) {
      this._w = -qb._w;
      this._x = -qb._x;
      this._y = -qb._y;
      this._z = -qb._z;
      cosHalfTheta = -cosHalfTheta;
    } else {
      this.copy(qb);
    }
    if (cosHalfTheta >= 1) {
      this._w = w;
      this._x = x;
      this._y = y;
      this._z = z;
      return this;
    }
    const sqrSinHalfTheta = 1 - cosHalfTheta * cosHalfTheta;
    if (sqrSinHalfTheta <= Number.EPSILON) {
      const s = 1 - t;
      this._w = s * w + t * this._w;
      this._x = s * x + t * this._x;
      this._y = s * y + t * this._y;
      this._z = s * z + t * this._z;
      this.normalize();
      this._onChangeCallback();
      return this;
    }
    const sinHalfTheta = Math.sqrt(sqrSinHalfTheta);
    const halfTheta = Math.atan2(sinHalfTheta, cosHalfTheta);
    const ratioA = Math.sin((1 - t) * halfTheta) / sinHalfTheta, ratioB = Math.sin(t * halfTheta) / sinHalfTheta;
    this._w = w * ratioA + this._w * ratioB;
    this._x = x * ratioA + this._x * ratioB;
    this._y = y * ratioA + this._y * ratioB;
    this._z = z * ratioA + this._z * ratioB;
    this._onChangeCallback();
    return this;
  }
  slerpQuaternions(qa, qb, t) {
    return this.copy(qa).slerp(qb, t);
  }
  random() {
    const u1 = Math.random();
    const sqrt1u1 = Math.sqrt(1 - u1);
    const sqrtu1 = Math.sqrt(u1);
    const u2 = 2 * Math.PI * Math.random();
    const u3 = 2 * Math.PI * Math.random();
    return this.set(sqrt1u1 * Math.cos(u2), sqrtu1 * Math.sin(u3), sqrtu1 * Math.cos(u3), sqrt1u1 * Math.sin(u2));
  }
  equals(quaternion) {
    return quaternion._x === this._x && quaternion._y === this._y && quaternion._z === this._z && quaternion._w === this._w;
  }
  fromArray(array, offset = 0) {
    this._x = array[offset];
    this._y = array[offset + 1];
    this._z = array[offset + 2];
    this._w = array[offset + 3];
    this._onChangeCallback();
    return this;
  }
  toArray(array = [], offset = 0) {
    array[offset] = this._x;
    array[offset + 1] = this._y;
    array[offset + 2] = this._z;
    array[offset + 3] = this._w;
    return array;
  }
  fromBufferAttribute(attribute, index2) {
    this._x = attribute.getX(index2);
    this._y = attribute.getY(index2);
    this._z = attribute.getZ(index2);
    this._w = attribute.getW(index2);
    return this;
  }
  _onChange(callback) {
    this._onChangeCallback = callback;
    return this;
  }
  _onChangeCallback() {
  }
}
Quaternion.prototype.isQuaternion = true;
class Vector3 {
  constructor(x = 0, y = 0, z = 0) {
    this.x = x;
    this.y = y;
    this.z = z;
  }
  set(x, y, z) {
    if (z === void 0)
      z = this.z;
    this.x = x;
    this.y = y;
    this.z = z;
    return this;
  }
  setScalar(scalar) {
    this.x = scalar;
    this.y = scalar;
    this.z = scalar;
    return this;
  }
  setX(x) {
    this.x = x;
    return this;
  }
  setY(y) {
    this.y = y;
    return this;
  }
  setZ(z) {
    this.z = z;
    return this;
  }
  setComponent(index2, value) {
    switch (index2) {
      case 0:
        this.x = value;
        break;
      case 1:
        this.y = value;
        break;
      case 2:
        this.z = value;
        break;
      default:
        throw new Error("index is out of range: " + index2);
    }
    return this;
  }
  getComponent(index2) {
    switch (index2) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      default:
        throw new Error("index is out of range: " + index2);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z);
  }
  copy(v) {
    this.x = v.x;
    this.y = v.y;
    this.z = v.z;
    return this;
  }
  add(v, w) {
    if (w !== void 0) {
      console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.");
      return this.addVectors(v, w);
    }
    this.x += v.x;
    this.y += v.y;
    this.z += v.z;
    return this;
  }
  addScalar(s) {
    this.x += s;
    this.y += s;
    this.z += s;
    return this;
  }
  addVectors(a, b) {
    this.x = a.x + b.x;
    this.y = a.y + b.y;
    this.z = a.z + b.z;
    return this;
  }
  addScaledVector(v, s) {
    this.x += v.x * s;
    this.y += v.y * s;
    this.z += v.z * s;
    return this;
  }
  sub(v, w) {
    if (w !== void 0) {
      console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.");
      return this.subVectors(v, w);
    }
    this.x -= v.x;
    this.y -= v.y;
    this.z -= v.z;
    return this;
  }
  subScalar(s) {
    this.x -= s;
    this.y -= s;
    this.z -= s;
    return this;
  }
  subVectors(a, b) {
    this.x = a.x - b.x;
    this.y = a.y - b.y;
    this.z = a.z - b.z;
    return this;
  }
  multiply(v, w) {
    if (w !== void 0) {
      console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.");
      return this.multiplyVectors(v, w);
    }
    this.x *= v.x;
    this.y *= v.y;
    this.z *= v.z;
    return this;
  }
  multiplyScalar(scalar) {
    this.x *= scalar;
    this.y *= scalar;
    this.z *= scalar;
    return this;
  }
  multiplyVectors(a, b) {
    this.x = a.x * b.x;
    this.y = a.y * b.y;
    this.z = a.z * b.z;
    return this;
  }
  applyEuler(euler) {
    if (!(euler && euler.isEuler)) {
      console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.");
    }
    return this.applyQuaternion(_quaternion$4.setFromEuler(euler));
  }
  applyAxisAngle(axis, angle) {
    return this.applyQuaternion(_quaternion$4.setFromAxisAngle(axis, angle));
  }
  applyMatrix3(m) {
    const x = this.x, y = this.y, z = this.z;
    const e = m.elements;
    this.x = e[0] * x + e[3] * y + e[6] * z;
    this.y = e[1] * x + e[4] * y + e[7] * z;
    this.z = e[2] * x + e[5] * y + e[8] * z;
    return this;
  }
  applyNormalMatrix(m) {
    return this.applyMatrix3(m).normalize();
  }
  applyMatrix4(m) {
    const x = this.x, y = this.y, z = this.z;
    const e = m.elements;
    const w = 1 / (e[3] * x + e[7] * y + e[11] * z + e[15]);
    this.x = (e[0] * x + e[4] * y + e[8] * z + e[12]) * w;
    this.y = (e[1] * x + e[5] * y + e[9] * z + e[13]) * w;
    this.z = (e[2] * x + e[6] * y + e[10] * z + e[14]) * w;
    return this;
  }
  applyQuaternion(q) {
    const x = this.x, y = this.y, z = this.z;
    const qx = q.x, qy = q.y, qz = q.z, qw = q.w;
    const ix = qw * x + qy * z - qz * y;
    const iy = qw * y + qz * x - qx * z;
    const iz = qw * z + qx * y - qy * x;
    const iw = -qx * x - qy * y - qz * z;
    this.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
    this.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
    this.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;
    return this;
  }
  project(camera) {
    return this.applyMatrix4(camera.matrixWorldInverse).applyMatrix4(camera.projectionMatrix);
  }
  unproject(camera) {
    return this.applyMatrix4(camera.projectionMatrixInverse).applyMatrix4(camera.matrixWorld);
  }
  transformDirection(m) {
    const x = this.x, y = this.y, z = this.z;
    const e = m.elements;
    this.x = e[0] * x + e[4] * y + e[8] * z;
    this.y = e[1] * x + e[5] * y + e[9] * z;
    this.z = e[2] * x + e[6] * y + e[10] * z;
    return this.normalize();
  }
  divide(v) {
    this.x /= v.x;
    this.y /= v.y;
    this.z /= v.z;
    return this;
  }
  divideScalar(scalar) {
    return this.multiplyScalar(1 / scalar);
  }
  min(v) {
    this.x = Math.min(this.x, v.x);
    this.y = Math.min(this.y, v.y);
    this.z = Math.min(this.z, v.z);
    return this;
  }
  max(v) {
    this.x = Math.max(this.x, v.x);
    this.y = Math.max(this.y, v.y);
    this.z = Math.max(this.z, v.z);
    return this;
  }
  clamp(min, max) {
    this.x = Math.max(min.x, Math.min(max.x, this.x));
    this.y = Math.max(min.y, Math.min(max.y, this.y));
    this.z = Math.max(min.z, Math.min(max.z, this.z));
    return this;
  }
  clampScalar(minVal, maxVal) {
    this.x = Math.max(minVal, Math.min(maxVal, this.x));
    this.y = Math.max(minVal, Math.min(maxVal, this.y));
    this.z = Math.max(minVal, Math.min(maxVal, this.z));
    return this;
  }
  clampLength(min, max) {
    const length2 = this.length();
    return this.divideScalar(length2 || 1).multiplyScalar(Math.max(min, Math.min(max, length2)));
  }
  floor() {
    this.x = Math.floor(this.x);
    this.y = Math.floor(this.y);
    this.z = Math.floor(this.z);
    return this;
  }
  ceil() {
    this.x = Math.ceil(this.x);
    this.y = Math.ceil(this.y);
    this.z = Math.ceil(this.z);
    return this;
  }
  round() {
    this.x = Math.round(this.x);
    this.y = Math.round(this.y);
    this.z = Math.round(this.z);
    return this;
  }
  roundToZero() {
    this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
    this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
    this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z);
    return this;
  }
  negate() {
    this.x = -this.x;
    this.y = -this.y;
    this.z = -this.z;
    return this;
  }
  dot(v) {
    return this.x * v.x + this.y * v.y + this.z * v.z;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(length2) {
    return this.normalize().multiplyScalar(length2);
  }
  lerp(v, alpha2) {
    this.x += (v.x - this.x) * alpha2;
    this.y += (v.y - this.y) * alpha2;
    this.z += (v.z - this.z) * alpha2;
    return this;
  }
  lerpVectors(v1, v2, alpha2) {
    this.x = v1.x + (v2.x - v1.x) * alpha2;
    this.y = v1.y + (v2.y - v1.y) * alpha2;
    this.z = v1.z + (v2.z - v1.z) * alpha2;
    return this;
  }
  cross(v, w) {
    if (w !== void 0) {
      console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.");
      return this.crossVectors(v, w);
    }
    return this.crossVectors(this, v);
  }
  crossVectors(a, b) {
    const ax = a.x, ay = a.y, az = a.z;
    const bx = b.x, by = b.y, bz = b.z;
    this.x = ay * bz - az * by;
    this.y = az * bx - ax * bz;
    this.z = ax * by - ay * bx;
    return this;
  }
  projectOnVector(v) {
    const denominator = v.lengthSq();
    if (denominator === 0)
      return this.set(0, 0, 0);
    const scalar = v.dot(this) / denominator;
    return this.copy(v).multiplyScalar(scalar);
  }
  projectOnPlane(planeNormal) {
    _vector$c.copy(this).projectOnVector(planeNormal);
    return this.sub(_vector$c);
  }
  reflect(normal) {
    return this.sub(_vector$c.copy(normal).multiplyScalar(2 * this.dot(normal)));
  }
  angleTo(v) {
    const denominator = Math.sqrt(this.lengthSq() * v.lengthSq());
    if (denominator === 0)
      return Math.PI / 2;
    const theta = this.dot(v) / denominator;
    return Math.acos(clamp(theta, -1, 1));
  }
  distanceTo(v) {
    return Math.sqrt(this.distanceToSquared(v));
  }
  distanceToSquared(v) {
    const dx = this.x - v.x, dy = this.y - v.y, dz = this.z - v.z;
    return dx * dx + dy * dy + dz * dz;
  }
  manhattanDistanceTo(v) {
    return Math.abs(this.x - v.x) + Math.abs(this.y - v.y) + Math.abs(this.z - v.z);
  }
  setFromSpherical(s) {
    return this.setFromSphericalCoords(s.radius, s.phi, s.theta);
  }
  setFromSphericalCoords(radius, phi, theta) {
    const sinPhiRadius = Math.sin(phi) * radius;
    this.x = sinPhiRadius * Math.sin(theta);
    this.y = Math.cos(phi) * radius;
    this.z = sinPhiRadius * Math.cos(theta);
    return this;
  }
  setFromCylindrical(c2) {
    return this.setFromCylindricalCoords(c2.radius, c2.theta, c2.y);
  }
  setFromCylindricalCoords(radius, theta, y) {
    this.x = radius * Math.sin(theta);
    this.y = y;
    this.z = radius * Math.cos(theta);
    return this;
  }
  setFromMatrixPosition(m) {
    const e = m.elements;
    this.x = e[12];
    this.y = e[13];
    this.z = e[14];
    return this;
  }
  setFromMatrixScale(m) {
    const sx = this.setFromMatrixColumn(m, 0).length();
    const sy = this.setFromMatrixColumn(m, 1).length();
    const sz = this.setFromMatrixColumn(m, 2).length();
    this.x = sx;
    this.y = sy;
    this.z = sz;
    return this;
  }
  setFromMatrixColumn(m, index2) {
    return this.fromArray(m.elements, index2 * 4);
  }
  setFromMatrix3Column(m, index2) {
    return this.fromArray(m.elements, index2 * 3);
  }
  setFromEuler(e) {
    this.x = e._x;
    this.y = e._y;
    this.z = e._z;
    return this;
  }
  equals(v) {
    return v.x === this.x && v.y === this.y && v.z === this.z;
  }
  fromArray(array, offset = 0) {
    this.x = array[offset];
    this.y = array[offset + 1];
    this.z = array[offset + 2];
    return this;
  }
  toArray(array = [], offset = 0) {
    array[offset] = this.x;
    array[offset + 1] = this.y;
    array[offset + 2] = this.z;
    return array;
  }
  fromBufferAttribute(attribute, index2, offset) {
    if (offset !== void 0) {
      console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute().");
    }
    this.x = attribute.getX(index2);
    this.y = attribute.getY(index2);
    this.z = attribute.getZ(index2);
    return this;
  }
  random() {
    this.x = Math.random();
    this.y = Math.random();
    this.z = Math.random();
    return this;
  }
  randomDirection() {
    const u = (Math.random() - 0.5) * 2;
    const t = Math.random() * Math.PI * 2;
    const f = Math.sqrt(1 - u ** 2);
    this.x = f * Math.cos(t);
    this.y = f * Math.sin(t);
    this.z = u;
    return this;
  }
  *[Symbol.iterator]() {
    yield this.x;
    yield this.y;
    yield this.z;
  }
}
Vector3.prototype.isVector3 = true;
const _vector$c = /* @__PURE__ */ new Vector3();
const _quaternion$4 = /* @__PURE__ */ new Quaternion();
class Box3 {
  constructor(min = new Vector3(Infinity, Infinity, Infinity), max = new Vector3(-Infinity, -Infinity, -Infinity)) {
    this.min = min;
    this.max = max;
  }
  set(min, max) {
    this.min.copy(min);
    this.max.copy(max);
    return this;
  }
  setFromArray(array) {
    let minX = Infinity;
    let minY = Infinity;
    let minZ = Infinity;
    let maxX = -Infinity;
    let maxY = -Infinity;
    let maxZ = -Infinity;
    for (let i = 0, l = array.length; i < l; i += 3) {
      const x = array[i];
      const y = array[i + 1];
      const z = array[i + 2];
      if (x < minX)
        minX = x;
      if (y < minY)
        minY = y;
      if (z < minZ)
        minZ = z;
      if (x > maxX)
        maxX = x;
      if (y > maxY)
        maxY = y;
      if (z > maxZ)
        maxZ = z;
    }
    this.min.set(minX, minY, minZ);
    this.max.set(maxX, maxY, maxZ);
    return this;
  }
  setFromBufferAttribute(attribute) {
    let minX = Infinity;
    let minY = Infinity;
    let minZ = Infinity;
    let maxX = -Infinity;
    let maxY = -Infinity;
    let maxZ = -Infinity;
    for (let i = 0, l = attribute.count; i < l; i++) {
      const x = attribute.getX(i);
      const y = attribute.getY(i);
      const z = attribute.getZ(i);
      if (x < minX)
        minX = x;
      if (y < minY)
        minY = y;
      if (z < minZ)
        minZ = z;
      if (x > maxX)
        maxX = x;
      if (y > maxY)
        maxY = y;
      if (z > maxZ)
        maxZ = z;
    }
    this.min.set(minX, minY, minZ);
    this.max.set(maxX, maxY, maxZ);
    return this;
  }
  setFromPoints(points) {
    this.makeEmpty();
    for (let i = 0, il = points.length; i < il; i++) {
      this.expandByPoint(points[i]);
    }
    return this;
  }
  setFromCenterAndSize(center2, size2) {
    const halfSize = _vector$b.copy(size2).multiplyScalar(0.5);
    this.min.copy(center2).sub(halfSize);
    this.max.copy(center2).add(halfSize);
    return this;
  }
  setFromObject(object, precise = false) {
    this.makeEmpty();
    return this.expandByObject(object, precise);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(box) {
    this.min.copy(box.min);
    this.max.copy(box.max);
    return this;
  }
  makeEmpty() {
    this.min.x = this.min.y = this.min.z = Infinity;
    this.max.x = this.max.y = this.max.z = -Infinity;
    return this;
  }
  isEmpty() {
    return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
  }
  getCenter(target) {
    return this.isEmpty() ? target.set(0, 0, 0) : target.addVectors(this.min, this.max).multiplyScalar(0.5);
  }
  getSize(target) {
    return this.isEmpty() ? target.set(0, 0, 0) : target.subVectors(this.max, this.min);
  }
  expandByPoint(point2) {
    this.min.min(point2);
    this.max.max(point2);
    return this;
  }
  expandByVector(vector) {
    this.min.sub(vector);
    this.max.add(vector);
    return this;
  }
  expandByScalar(scalar) {
    this.min.addScalar(-scalar);
    this.max.addScalar(scalar);
    return this;
  }
  expandByObject(object, precise = false) {
    object.updateWorldMatrix(false, false);
    const geometry = object.geometry;
    if (geometry !== void 0) {
      if (precise && geometry.attributes != void 0 && geometry.attributes.position !== void 0) {
        const position2 = geometry.attributes.position;
        for (let i = 0, l = position2.count; i < l; i++) {
          _vector$b.fromBufferAttribute(position2, i).applyMatrix4(object.matrixWorld);
          this.expandByPoint(_vector$b);
        }
      } else {
        if (geometry.boundingBox === null) {
          geometry.computeBoundingBox();
        }
        _box$3.copy(geometry.boundingBox);
        _box$3.applyMatrix4(object.matrixWorld);
        this.union(_box$3);
      }
    }
    const children2 = object.children;
    for (let i = 0, l = children2.length; i < l; i++) {
      this.expandByObject(children2[i], precise);
    }
    return this;
  }
  containsPoint(point2) {
    return point2.x < this.min.x || point2.x > this.max.x || point2.y < this.min.y || point2.y > this.max.y || point2.z < this.min.z || point2.z > this.max.z ? false : true;
  }
  containsBox(box) {
    return this.min.x <= box.min.x && box.max.x <= this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y && this.min.z <= box.min.z && box.max.z <= this.max.z;
  }
  getParameter(point2, target) {
    return target.set((point2.x - this.min.x) / (this.max.x - this.min.x), (point2.y - this.min.y) / (this.max.y - this.min.y), (point2.z - this.min.z) / (this.max.z - this.min.z));
  }
  intersectsBox(box) {
    return box.max.x < this.min.x || box.min.x > this.max.x || box.max.y < this.min.y || box.min.y > this.max.y || box.max.z < this.min.z || box.min.z > this.max.z ? false : true;
  }
  intersectsSphere(sphere) {
    this.clampPoint(sphere.center, _vector$b);
    return _vector$b.distanceToSquared(sphere.center) <= sphere.radius * sphere.radius;
  }
  intersectsPlane(plane) {
    let min, max;
    if (plane.normal.x > 0) {
      min = plane.normal.x * this.min.x;
      max = plane.normal.x * this.max.x;
    } else {
      min = plane.normal.x * this.max.x;
      max = plane.normal.x * this.min.x;
    }
    if (plane.normal.y > 0) {
      min += plane.normal.y * this.min.y;
      max += plane.normal.y * this.max.y;
    } else {
      min += plane.normal.y * this.max.y;
      max += plane.normal.y * this.min.y;
    }
    if (plane.normal.z > 0) {
      min += plane.normal.z * this.min.z;
      max += plane.normal.z * this.max.z;
    } else {
      min += plane.normal.z * this.max.z;
      max += plane.normal.z * this.min.z;
    }
    return min <= -plane.constant && max >= -plane.constant;
  }
  intersectsTriangle(triangle) {
    if (this.isEmpty()) {
      return false;
    }
    this.getCenter(_center);
    _extents.subVectors(this.max, _center);
    _v0$2.subVectors(triangle.a, _center);
    _v1$7.subVectors(triangle.b, _center);
    _v2$3.subVectors(triangle.c, _center);
    _f0.subVectors(_v1$7, _v0$2);
    _f1.subVectors(_v2$3, _v1$7);
    _f2.subVectors(_v0$2, _v2$3);
    let axes = [
      0,
      -_f0.z,
      _f0.y,
      0,
      -_f1.z,
      _f1.y,
      0,
      -_f2.z,
      _f2.y,
      _f0.z,
      0,
      -_f0.x,
      _f1.z,
      0,
      -_f1.x,
      _f2.z,
      0,
      -_f2.x,
      -_f0.y,
      _f0.x,
      0,
      -_f1.y,
      _f1.x,
      0,
      -_f2.y,
      _f2.x,
      0
    ];
    if (!satForAxes(axes, _v0$2, _v1$7, _v2$3, _extents)) {
      return false;
    }
    axes = [1, 0, 0, 0, 1, 0, 0, 0, 1];
    if (!satForAxes(axes, _v0$2, _v1$7, _v2$3, _extents)) {
      return false;
    }
    _triangleNormal.crossVectors(_f0, _f1);
    axes = [_triangleNormal.x, _triangleNormal.y, _triangleNormal.z];
    return satForAxes(axes, _v0$2, _v1$7, _v2$3, _extents);
  }
  clampPoint(point2, target) {
    return target.copy(point2).clamp(this.min, this.max);
  }
  distanceToPoint(point2) {
    const clampedPoint = _vector$b.copy(point2).clamp(this.min, this.max);
    return clampedPoint.sub(point2).length();
  }
  getBoundingSphere(target) {
    this.getCenter(target.center);
    target.radius = this.getSize(_vector$b).length() * 0.5;
    return target;
  }
  intersect(box) {
    this.min.max(box.min);
    this.max.min(box.max);
    if (this.isEmpty())
      this.makeEmpty();
    return this;
  }
  union(box) {
    this.min.min(box.min);
    this.max.max(box.max);
    return this;
  }
  applyMatrix4(matrix) {
    if (this.isEmpty())
      return this;
    _points[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(matrix);
    _points[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(matrix);
    _points[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(matrix);
    _points[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(matrix);
    _points[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(matrix);
    _points[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(matrix);
    _points[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(matrix);
    _points[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(matrix);
    this.setFromPoints(_points);
    return this;
  }
  translate(offset) {
    this.min.add(offset);
    this.max.add(offset);
    return this;
  }
  equals(box) {
    return box.min.equals(this.min) && box.max.equals(this.max);
  }
}
Box3.prototype.isBox3 = true;
const _points = [
  /* @__PURE__ */ new Vector3(),
  /* @__PURE__ */ new Vector3(),
  /* @__PURE__ */ new Vector3(),
  /* @__PURE__ */ new Vector3(),
  /* @__PURE__ */ new Vector3(),
  /* @__PURE__ */ new Vector3(),
  /* @__PURE__ */ new Vector3(),
  /* @__PURE__ */ new Vector3()
];
const _vector$b = /* @__PURE__ */ new Vector3();
const _box$3 = /* @__PURE__ */ new Box3();
const _v0$2 = /* @__PURE__ */ new Vector3();
const _v1$7 = /* @__PURE__ */ new Vector3();
const _v2$3 = /* @__PURE__ */ new Vector3();
const _f0 = /* @__PURE__ */ new Vector3();
const _f1 = /* @__PURE__ */ new Vector3();
const _f2 = /* @__PURE__ */ new Vector3();
const _center = /* @__PURE__ */ new Vector3();
const _extents = /* @__PURE__ */ new Vector3();
const _triangleNormal = /* @__PURE__ */ new Vector3();
const _testAxis = /* @__PURE__ */ new Vector3();
function satForAxes(axes, v0, v1, v2, extents) {
  for (let i = 0, j = axes.length - 3; i <= j; i += 3) {
    _testAxis.fromArray(axes, i);
    const r = extents.x * Math.abs(_testAxis.x) + extents.y * Math.abs(_testAxis.y) + extents.z * Math.abs(_testAxis.z);
    const p0 = v0.dot(_testAxis);
    const p1 = v1.dot(_testAxis);
    const p2 = v2.dot(_testAxis);
    if (Math.max(-Math.max(p0, p1, p2), Math.min(p0, p1, p2)) > r) {
      return false;
    }
  }
  return true;
}
const _box$2 = /* @__PURE__ */ new Box3();
const _v1$6 = /* @__PURE__ */ new Vector3();
const _toFarthestPoint = /* @__PURE__ */ new Vector3();
const _toPoint = /* @__PURE__ */ new Vector3();
class Sphere {
  constructor(center2 = new Vector3(), radius = -1) {
    this.center = center2;
    this.radius = radius;
  }
  set(center2, radius) {
    this.center.copy(center2);
    this.radius = radius;
    return this;
  }
  setFromPoints(points, optionalCenter) {
    const center2 = this.center;
    if (optionalCenter !== void 0) {
      center2.copy(optionalCenter);
    } else {
      _box$2.setFromPoints(points).getCenter(center2);
    }
    let maxRadiusSq = 0;
    for (let i = 0, il = points.length; i < il; i++) {
      maxRadiusSq = Math.max(maxRadiusSq, center2.distanceToSquared(points[i]));
    }
    this.radius = Math.sqrt(maxRadiusSq);
    return this;
  }
  copy(sphere) {
    this.center.copy(sphere.center);
    this.radius = sphere.radius;
    return this;
  }
  isEmpty() {
    return this.radius < 0;
  }
  makeEmpty() {
    this.center.set(0, 0, 0);
    this.radius = -1;
    return this;
  }
  containsPoint(point2) {
    return point2.distanceToSquared(this.center) <= this.radius * this.radius;
  }
  distanceToPoint(point2) {
    return point2.distanceTo(this.center) - this.radius;
  }
  intersectsSphere(sphere) {
    const radiusSum = this.radius + sphere.radius;
    return sphere.center.distanceToSquared(this.center) <= radiusSum * radiusSum;
  }
  intersectsBox(box) {
    return box.intersectsSphere(this);
  }
  intersectsPlane(plane) {
    return Math.abs(plane.distanceToPoint(this.center)) <= this.radius;
  }
  clampPoint(point2, target) {
    const deltaLengthSq = this.center.distanceToSquared(point2);
    target.copy(point2);
    if (deltaLengthSq > this.radius * this.radius) {
      target.sub(this.center).normalize();
      target.multiplyScalar(this.radius).add(this.center);
    }
    return target;
  }
  getBoundingBox(target) {
    if (this.isEmpty()) {
      target.makeEmpty();
      return target;
    }
    target.set(this.center, this.center);
    target.expandByScalar(this.radius);
    return target;
  }
  applyMatrix4(matrix) {
    this.center.applyMatrix4(matrix);
    this.radius = this.radius * matrix.getMaxScaleOnAxis();
    return this;
  }
  translate(offset) {
    this.center.add(offset);
    return this;
  }
  expandByPoint(point2) {
    _toPoint.subVectors(point2, this.center);
    const lengthSq = _toPoint.lengthSq();
    if (lengthSq > this.radius * this.radius) {
      const length2 = Math.sqrt(lengthSq);
      const missingRadiusHalf = (length2 - this.radius) * 0.5;
      this.center.add(_toPoint.multiplyScalar(missingRadiusHalf / length2));
      this.radius += missingRadiusHalf;
    }
    return this;
  }
  union(sphere) {
    if (this.center.equals(sphere.center) === true) {
      _toFarthestPoint.set(0, 0, 1).multiplyScalar(sphere.radius);
    } else {
      _toFarthestPoint.subVectors(sphere.center, this.center).normalize().multiplyScalar(sphere.radius);
    }
    this.expandByPoint(_v1$6.copy(sphere.center).add(_toFarthestPoint));
    this.expandByPoint(_v1$6.copy(sphere.center).sub(_toFarthestPoint));
    return this;
  }
  equals(sphere) {
    return sphere.center.equals(this.center) && sphere.radius === this.radius;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const _vector$a = /* @__PURE__ */ new Vector3();
const _segCenter = /* @__PURE__ */ new Vector3();
const _segDir = /* @__PURE__ */ new Vector3();
const _diff = /* @__PURE__ */ new Vector3();
const _edge1 = /* @__PURE__ */ new Vector3();
const _edge2 = /* @__PURE__ */ new Vector3();
const _normal$1 = /* @__PURE__ */ new Vector3();
class Ray {
  constructor(origin = new Vector3(), direction2 = new Vector3(0, 0, -1)) {
    this.origin = origin;
    this.direction = direction2;
  }
  set(origin, direction2) {
    this.origin.copy(origin);
    this.direction.copy(direction2);
    return this;
  }
  copy(ray) {
    this.origin.copy(ray.origin);
    this.direction.copy(ray.direction);
    return this;
  }
  at(t, target) {
    return target.copy(this.direction).multiplyScalar(t).add(this.origin);
  }
  lookAt(v) {
    this.direction.copy(v).sub(this.origin).normalize();
    return this;
  }
  recast(t) {
    this.origin.copy(this.at(t, _vector$a));
    return this;
  }
  closestPointToPoint(point2, target) {
    target.subVectors(point2, this.origin);
    const directionDistance = target.dot(this.direction);
    if (directionDistance < 0) {
      return target.copy(this.origin);
    }
    return target.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);
  }
  distanceToPoint(point2) {
    return Math.sqrt(this.distanceSqToPoint(point2));
  }
  distanceSqToPoint(point2) {
    const directionDistance = _vector$a.subVectors(point2, this.origin).dot(this.direction);
    if (directionDistance < 0) {
      return this.origin.distanceToSquared(point2);
    }
    _vector$a.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);
    return _vector$a.distanceToSquared(point2);
  }
  distanceSqToSegment(v0, v1, optionalPointOnRay, optionalPointOnSegment) {
    _segCenter.copy(v0).add(v1).multiplyScalar(0.5);
    _segDir.copy(v1).sub(v0).normalize();
    _diff.copy(this.origin).sub(_segCenter);
    const segExtent = v0.distanceTo(v1) * 0.5;
    const a01 = -this.direction.dot(_segDir);
    const b0 = _diff.dot(this.direction);
    const b1 = -_diff.dot(_segDir);
    const c2 = _diff.lengthSq();
    const det = Math.abs(1 - a01 * a01);
    let s0, s1, sqrDist, extDet;
    if (det > 0) {
      s0 = a01 * b1 - b0;
      s1 = a01 * b0 - b1;
      extDet = segExtent * det;
      if (s0 >= 0) {
        if (s1 >= -extDet) {
          if (s1 <= extDet) {
            const invDet = 1 / det;
            s0 *= invDet;
            s1 *= invDet;
            sqrDist = s0 * (s0 + a01 * s1 + 2 * b0) + s1 * (a01 * s0 + s1 + 2 * b1) + c2;
          } else {
            s1 = segExtent;
            s0 = Math.max(0, -(a01 * s1 + b0));
            sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c2;
          }
        } else {
          s1 = -segExtent;
          s0 = Math.max(0, -(a01 * s1 + b0));
          sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c2;
        }
      } else {
        if (s1 <= -extDet) {
          s0 = Math.max(0, -(-a01 * segExtent + b0));
          s1 = s0 > 0 ? -segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
          sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c2;
        } else if (s1 <= extDet) {
          s0 = 0;
          s1 = Math.min(Math.max(-segExtent, -b1), segExtent);
          sqrDist = s1 * (s1 + 2 * b1) + c2;
        } else {
          s0 = Math.max(0, -(a01 * segExtent + b0));
          s1 = s0 > 0 ? segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
          sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c2;
        }
      }
    } else {
      s1 = a01 > 0 ? -segExtent : segExtent;
      s0 = Math.max(0, -(a01 * s1 + b0));
      sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c2;
    }
    if (optionalPointOnRay) {
      optionalPointOnRay.copy(this.direction).multiplyScalar(s0).add(this.origin);
    }
    if (optionalPointOnSegment) {
      optionalPointOnSegment.copy(_segDir).multiplyScalar(s1).add(_segCenter);
    }
    return sqrDist;
  }
  intersectSphere(sphere, target) {
    _vector$a.subVectors(sphere.center, this.origin);
    const tca = _vector$a.dot(this.direction);
    const d2 = _vector$a.dot(_vector$a) - tca * tca;
    const radius2 = sphere.radius * sphere.radius;
    if (d2 > radius2)
      return null;
    const thc = Math.sqrt(radius2 - d2);
    const t0 = tca - thc;
    const t1 = tca + thc;
    if (t0 < 0 && t1 < 0)
      return null;
    if (t0 < 0)
      return this.at(t1, target);
    return this.at(t0, target);
  }
  intersectsSphere(sphere) {
    return this.distanceSqToPoint(sphere.center) <= sphere.radius * sphere.radius;
  }
  distanceToPlane(plane) {
    const denominator = plane.normal.dot(this.direction);
    if (denominator === 0) {
      if (plane.distanceToPoint(this.origin) === 0) {
        return 0;
      }
      return null;
    }
    const t = -(this.origin.dot(plane.normal) + plane.constant) / denominator;
    return t >= 0 ? t : null;
  }
  intersectPlane(plane, target) {
    const t = this.distanceToPlane(plane);
    if (t === null) {
      return null;
    }
    return this.at(t, target);
  }
  intersectsPlane(plane) {
    const distToPoint = plane.distanceToPoint(this.origin);
    if (distToPoint === 0) {
      return true;
    }
    const denominator = plane.normal.dot(this.direction);
    if (denominator * distToPoint < 0) {
      return true;
    }
    return false;
  }
  intersectBox(box, target) {
    let tmin, tmax, tymin, tymax, tzmin, tzmax;
    const invdirx = 1 / this.direction.x, invdiry = 1 / this.direction.y, invdirz = 1 / this.direction.z;
    const origin = this.origin;
    if (invdirx >= 0) {
      tmin = (box.min.x - origin.x) * invdirx;
      tmax = (box.max.x - origin.x) * invdirx;
    } else {
      tmin = (box.max.x - origin.x) * invdirx;
      tmax = (box.min.x - origin.x) * invdirx;
    }
    if (invdiry >= 0) {
      tymin = (box.min.y - origin.y) * invdiry;
      tymax = (box.max.y - origin.y) * invdiry;
    } else {
      tymin = (box.max.y - origin.y) * invdiry;
      tymax = (box.min.y - origin.y) * invdiry;
    }
    if (tmin > tymax || tymin > tmax)
      return null;
    if (tymin > tmin || tmin !== tmin)
      tmin = tymin;
    if (tymax < tmax || tmax !== tmax)
      tmax = tymax;
    if (invdirz >= 0) {
      tzmin = (box.min.z - origin.z) * invdirz;
      tzmax = (box.max.z - origin.z) * invdirz;
    } else {
      tzmin = (box.max.z - origin.z) * invdirz;
      tzmax = (box.min.z - origin.z) * invdirz;
    }
    if (tmin > tzmax || tzmin > tmax)
      return null;
    if (tzmin > tmin || tmin !== tmin)
      tmin = tzmin;
    if (tzmax < tmax || tmax !== tmax)
      tmax = tzmax;
    if (tmax < 0)
      return null;
    return this.at(tmin >= 0 ? tmin : tmax, target);
  }
  intersectsBox(box) {
    return this.intersectBox(box, _vector$a) !== null;
  }
  intersectTriangle(a, b, c2, backfaceCulling, target) {
    _edge1.subVectors(b, a);
    _edge2.subVectors(c2, a);
    _normal$1.crossVectors(_edge1, _edge2);
    let DdN = this.direction.dot(_normal$1);
    let sign2;
    if (DdN > 0) {
      if (backfaceCulling)
        return null;
      sign2 = 1;
    } else if (DdN < 0) {
      sign2 = -1;
      DdN = -DdN;
    } else {
      return null;
    }
    _diff.subVectors(this.origin, a);
    const DdQxE2 = sign2 * this.direction.dot(_edge2.crossVectors(_diff, _edge2));
    if (DdQxE2 < 0) {
      return null;
    }
    const DdE1xQ = sign2 * this.direction.dot(_edge1.cross(_diff));
    if (DdE1xQ < 0) {
      return null;
    }
    if (DdQxE2 + DdE1xQ > DdN) {
      return null;
    }
    const QdN = -sign2 * _diff.dot(_normal$1);
    if (QdN < 0) {
      return null;
    }
    return this.at(QdN / DdN, target);
  }
  applyMatrix4(matrix4) {
    this.origin.applyMatrix4(matrix4);
    this.direction.transformDirection(matrix4);
    return this;
  }
  equals(ray) {
    return ray.origin.equals(this.origin) && ray.direction.equals(this.direction);
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class Matrix4 {
  constructor() {
    this.elements = [
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ];
    if (arguments.length > 0) {
      console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.");
    }
  }
  set(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {
    const te = this.elements;
    te[0] = n11;
    te[4] = n12;
    te[8] = n13;
    te[12] = n14;
    te[1] = n21;
    te[5] = n22;
    te[9] = n23;
    te[13] = n24;
    te[2] = n31;
    te[6] = n32;
    te[10] = n33;
    te[14] = n34;
    te[3] = n41;
    te[7] = n42;
    te[11] = n43;
    te[15] = n44;
    return this;
  }
  identity() {
    this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
    return this;
  }
  clone() {
    return new Matrix4().fromArray(this.elements);
  }
  copy(m) {
    const te = this.elements;
    const me = m.elements;
    te[0] = me[0];
    te[1] = me[1];
    te[2] = me[2];
    te[3] = me[3];
    te[4] = me[4];
    te[5] = me[5];
    te[6] = me[6];
    te[7] = me[7];
    te[8] = me[8];
    te[9] = me[9];
    te[10] = me[10];
    te[11] = me[11];
    te[12] = me[12];
    te[13] = me[13];
    te[14] = me[14];
    te[15] = me[15];
    return this;
  }
  copyPosition(m) {
    const te = this.elements, me = m.elements;
    te[12] = me[12];
    te[13] = me[13];
    te[14] = me[14];
    return this;
  }
  setFromMatrix3(m) {
    const me = m.elements;
    this.set(me[0], me[3], me[6], 0, me[1], me[4], me[7], 0, me[2], me[5], me[8], 0, 0, 0, 0, 1);
    return this;
  }
  extractBasis(xAxis, yAxis, zAxis) {
    xAxis.setFromMatrixColumn(this, 0);
    yAxis.setFromMatrixColumn(this, 1);
    zAxis.setFromMatrixColumn(this, 2);
    return this;
  }
  makeBasis(xAxis, yAxis, zAxis) {
    this.set(xAxis.x, yAxis.x, zAxis.x, 0, xAxis.y, yAxis.y, zAxis.y, 0, xAxis.z, yAxis.z, zAxis.z, 0, 0, 0, 0, 1);
    return this;
  }
  extractRotation(m) {
    const te = this.elements;
    const me = m.elements;
    const scaleX = 1 / _v1$5.setFromMatrixColumn(m, 0).length();
    const scaleY = 1 / _v1$5.setFromMatrixColumn(m, 1).length();
    const scaleZ = 1 / _v1$5.setFromMatrixColumn(m, 2).length();
    te[0] = me[0] * scaleX;
    te[1] = me[1] * scaleX;
    te[2] = me[2] * scaleX;
    te[3] = 0;
    te[4] = me[4] * scaleY;
    te[5] = me[5] * scaleY;
    te[6] = me[6] * scaleY;
    te[7] = 0;
    te[8] = me[8] * scaleZ;
    te[9] = me[9] * scaleZ;
    te[10] = me[10] * scaleZ;
    te[11] = 0;
    te[12] = 0;
    te[13] = 0;
    te[14] = 0;
    te[15] = 1;
    return this;
  }
  makeRotationFromEuler(euler) {
    if (!(euler && euler.isEuler)) {
      console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
    }
    const te = this.elements;
    const x = euler.x, y = euler.y, z = euler.z;
    const a = Math.cos(x), b = Math.sin(x);
    const c2 = Math.cos(y), d = Math.sin(y);
    const e = Math.cos(z), f = Math.sin(z);
    if (euler.order === "XYZ") {
      const ae = a * e, af = a * f, be = b * e, bf = b * f;
      te[0] = c2 * e;
      te[4] = -c2 * f;
      te[8] = d;
      te[1] = af + be * d;
      te[5] = ae - bf * d;
      te[9] = -b * c2;
      te[2] = bf - ae * d;
      te[6] = be + af * d;
      te[10] = a * c2;
    } else if (euler.order === "YXZ") {
      const ce = c2 * e, cf = c2 * f, de = d * e, df = d * f;
      te[0] = ce + df * b;
      te[4] = de * b - cf;
      te[8] = a * d;
      te[1] = a * f;
      te[5] = a * e;
      te[9] = -b;
      te[2] = cf * b - de;
      te[6] = df + ce * b;
      te[10] = a * c2;
    } else if (euler.order === "ZXY") {
      const ce = c2 * e, cf = c2 * f, de = d * e, df = d * f;
      te[0] = ce - df * b;
      te[4] = -a * f;
      te[8] = de + cf * b;
      te[1] = cf + de * b;
      te[5] = a * e;
      te[9] = df - ce * b;
      te[2] = -a * d;
      te[6] = b;
      te[10] = a * c2;
    } else if (euler.order === "ZYX") {
      const ae = a * e, af = a * f, be = b * e, bf = b * f;
      te[0] = c2 * e;
      te[4] = be * d - af;
      te[8] = ae * d + bf;
      te[1] = c2 * f;
      te[5] = bf * d + ae;
      te[9] = af * d - be;
      te[2] = -d;
      te[6] = b * c2;
      te[10] = a * c2;
    } else if (euler.order === "YZX") {
      const ac = a * c2, ad = a * d, bc = b * c2, bd = b * d;
      te[0] = c2 * e;
      te[4] = bd - ac * f;
      te[8] = bc * f + ad;
      te[1] = f;
      te[5] = a * e;
      te[9] = -b * e;
      te[2] = -d * e;
      te[6] = ad * f + bc;
      te[10] = ac - bd * f;
    } else if (euler.order === "XZY") {
      const ac = a * c2, ad = a * d, bc = b * c2, bd = b * d;
      te[0] = c2 * e;
      te[4] = -f;
      te[8] = d * e;
      te[1] = ac * f + bd;
      te[5] = a * e;
      te[9] = ad * f - bc;
      te[2] = bc * f - ad;
      te[6] = b * e;
      te[10] = bd * f + ac;
    }
    te[3] = 0;
    te[7] = 0;
    te[11] = 0;
    te[12] = 0;
    te[13] = 0;
    te[14] = 0;
    te[15] = 1;
    return this;
  }
  makeRotationFromQuaternion(q) {
    return this.compose(_zero, q, _one);
  }
  lookAt(eye, target, up) {
    const te = this.elements;
    _z.subVectors(eye, target);
    if (_z.lengthSq() === 0) {
      _z.z = 1;
    }
    _z.normalize();
    _x.crossVectors(up, _z);
    if (_x.lengthSq() === 0) {
      if (Math.abs(up.z) === 1) {
        _z.x += 1e-4;
      } else {
        _z.z += 1e-4;
      }
      _z.normalize();
      _x.crossVectors(up, _z);
    }
    _x.normalize();
    _y.crossVectors(_z, _x);
    te[0] = _x.x;
    te[4] = _y.x;
    te[8] = _z.x;
    te[1] = _x.y;
    te[5] = _y.y;
    te[9] = _z.y;
    te[2] = _x.z;
    te[6] = _y.z;
    te[10] = _z.z;
    return this;
  }
  multiply(m, n) {
    if (n !== void 0) {
      console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.");
      return this.multiplyMatrices(m, n);
    }
    return this.multiplyMatrices(this, m);
  }
  premultiply(m) {
    return this.multiplyMatrices(m, this);
  }
  multiplyMatrices(a, b) {
    const ae = a.elements;
    const be = b.elements;
    const te = this.elements;
    const a11 = ae[0], a12 = ae[4], a13 = ae[8], a14 = ae[12];
    const a21 = ae[1], a22 = ae[5], a23 = ae[9], a24 = ae[13];
    const a31 = ae[2], a32 = ae[6], a33 = ae[10], a34 = ae[14];
    const a41 = ae[3], a42 = ae[7], a43 = ae[11], a44 = ae[15];
    const b11 = be[0], b12 = be[4], b13 = be[8], b14 = be[12];
    const b21 = be[1], b22 = be[5], b23 = be[9], b24 = be[13];
    const b31 = be[2], b32 = be[6], b33 = be[10], b34 = be[14];
    const b41 = be[3], b42 = be[7], b43 = be[11], b44 = be[15];
    te[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
    te[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
    te[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
    te[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;
    te[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
    te[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
    te[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
    te[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;
    te[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
    te[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
    te[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
    te[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;
    te[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
    te[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
    te[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
    te[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;
    return this;
  }
  multiplyScalar(s) {
    const te = this.elements;
    te[0] *= s;
    te[4] *= s;
    te[8] *= s;
    te[12] *= s;
    te[1] *= s;
    te[5] *= s;
    te[9] *= s;
    te[13] *= s;
    te[2] *= s;
    te[6] *= s;
    te[10] *= s;
    te[14] *= s;
    te[3] *= s;
    te[7] *= s;
    te[11] *= s;
    te[15] *= s;
    return this;
  }
  determinant() {
    const te = this.elements;
    const n11 = te[0], n12 = te[4], n13 = te[8], n14 = te[12];
    const n21 = te[1], n22 = te[5], n23 = te[9], n24 = te[13];
    const n31 = te[2], n32 = te[6], n33 = te[10], n34 = te[14];
    const n41 = te[3], n42 = te[7], n43 = te[11], n44 = te[15];
    return n41 * (+n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34) + n42 * (+n11 * n23 * n34 - n11 * n24 * n33 + n14 * n21 * n33 - n13 * n21 * n34 + n13 * n24 * n31 - n14 * n23 * n31) + n43 * (+n11 * n24 * n32 - n11 * n22 * n34 - n14 * n21 * n32 + n12 * n21 * n34 + n14 * n22 * n31 - n12 * n24 * n31) + n44 * (-n13 * n22 * n31 - n11 * n23 * n32 + n11 * n22 * n33 + n13 * n21 * n32 - n12 * n21 * n33 + n12 * n23 * n31);
  }
  transpose() {
    const te = this.elements;
    let tmp2;
    tmp2 = te[1];
    te[1] = te[4];
    te[4] = tmp2;
    tmp2 = te[2];
    te[2] = te[8];
    te[8] = tmp2;
    tmp2 = te[6];
    te[6] = te[9];
    te[9] = tmp2;
    tmp2 = te[3];
    te[3] = te[12];
    te[12] = tmp2;
    tmp2 = te[7];
    te[7] = te[13];
    te[13] = tmp2;
    tmp2 = te[11];
    te[11] = te[14];
    te[14] = tmp2;
    return this;
  }
  setPosition(x, y, z) {
    const te = this.elements;
    if (x.isVector3) {
      te[12] = x.x;
      te[13] = x.y;
      te[14] = x.z;
    } else {
      te[12] = x;
      te[13] = y;
      te[14] = z;
    }
    return this;
  }
  invert() {
    const te = this.elements, n11 = te[0], n21 = te[1], n31 = te[2], n41 = te[3], n12 = te[4], n22 = te[5], n32 = te[6], n42 = te[7], n13 = te[8], n23 = te[9], n33 = te[10], n43 = te[11], n14 = te[12], n24 = te[13], n34 = te[14], n44 = te[15], t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44, t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44, t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44, t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;
    const det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;
    if (det === 0)
      return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    const detInv = 1 / det;
    te[0] = t11 * detInv;
    te[1] = (n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44) * detInv;
    te[2] = (n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44) * detInv;
    te[3] = (n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43) * detInv;
    te[4] = t12 * detInv;
    te[5] = (n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44) * detInv;
    te[6] = (n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44) * detInv;
    te[7] = (n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43) * detInv;
    te[8] = t13 * detInv;
    te[9] = (n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44) * detInv;
    te[10] = (n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44) * detInv;
    te[11] = (n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43) * detInv;
    te[12] = t14 * detInv;
    te[13] = (n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34) * detInv;
    te[14] = (n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34) * detInv;
    te[15] = (n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33) * detInv;
    return this;
  }
  scale(v) {
    const te = this.elements;
    const x = v.x, y = v.y, z = v.z;
    te[0] *= x;
    te[4] *= y;
    te[8] *= z;
    te[1] *= x;
    te[5] *= y;
    te[9] *= z;
    te[2] *= x;
    te[6] *= y;
    te[10] *= z;
    te[3] *= x;
    te[7] *= y;
    te[11] *= z;
    return this;
  }
  getMaxScaleOnAxis() {
    const te = this.elements;
    const scaleXSq = te[0] * te[0] + te[1] * te[1] + te[2] * te[2];
    const scaleYSq = te[4] * te[4] + te[5] * te[5] + te[6] * te[6];
    const scaleZSq = te[8] * te[8] + te[9] * te[9] + te[10] * te[10];
    return Math.sqrt(Math.max(scaleXSq, scaleYSq, scaleZSq));
  }
  makeTranslation(x, y, z) {
    this.set(1, 0, 0, x, 0, 1, 0, y, 0, 0, 1, z, 0, 0, 0, 1);
    return this;
  }
  makeRotationX(theta) {
    const c2 = Math.cos(theta), s = Math.sin(theta);
    this.set(1, 0, 0, 0, 0, c2, -s, 0, 0, s, c2, 0, 0, 0, 0, 1);
    return this;
  }
  makeRotationY(theta) {
    const c2 = Math.cos(theta), s = Math.sin(theta);
    this.set(c2, 0, s, 0, 0, 1, 0, 0, -s, 0, c2, 0, 0, 0, 0, 1);
    return this;
  }
  makeRotationZ(theta) {
    const c2 = Math.cos(theta), s = Math.sin(theta);
    this.set(c2, -s, 0, 0, s, c2, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
    return this;
  }
  makeRotationAxis(axis, angle) {
    const c2 = Math.cos(angle);
    const s = Math.sin(angle);
    const t = 1 - c2;
    const x = axis.x, y = axis.y, z = axis.z;
    const tx = t * x, ty = t * y;
    this.set(tx * x + c2, tx * y - s * z, tx * z + s * y, 0, tx * y + s * z, ty * y + c2, ty * z - s * x, 0, tx * z - s * y, ty * z + s * x, t * z * z + c2, 0, 0, 0, 0, 1);
    return this;
  }
  makeScale(x, y, z) {
    this.set(x, 0, 0, 0, 0, y, 0, 0, 0, 0, z, 0, 0, 0, 0, 1);
    return this;
  }
  makeShear(xy2, xz, yx, yz, zx, zy) {
    this.set(1, yx, zx, 0, xy2, 1, zy, 0, xz, yz, 1, 0, 0, 0, 0, 1);
    return this;
  }
  compose(position2, quaternion, scale2) {
    const te = this.elements;
    const x = quaternion._x, y = quaternion._y, z = quaternion._z, w = quaternion._w;
    const x2 = x + x, y2 = y + y, z2 = z + z;
    const xx = x * x2, xy2 = x * y2, xz = x * z2;
    const yy = y * y2, yz = y * z2, zz = z * z2;
    const wx = w * x2, wy = w * y2, wz = w * z2;
    const sx = scale2.x, sy = scale2.y, sz = scale2.z;
    te[0] = (1 - (yy + zz)) * sx;
    te[1] = (xy2 + wz) * sx;
    te[2] = (xz - wy) * sx;
    te[3] = 0;
    te[4] = (xy2 - wz) * sy;
    te[5] = (1 - (xx + zz)) * sy;
    te[6] = (yz + wx) * sy;
    te[7] = 0;
    te[8] = (xz + wy) * sz;
    te[9] = (yz - wx) * sz;
    te[10] = (1 - (xx + yy)) * sz;
    te[11] = 0;
    te[12] = position2.x;
    te[13] = position2.y;
    te[14] = position2.z;
    te[15] = 1;
    return this;
  }
  decompose(position2, quaternion, scale2) {
    const te = this.elements;
    let sx = _v1$5.set(te[0], te[1], te[2]).length();
    const sy = _v1$5.set(te[4], te[5], te[6]).length();
    const sz = _v1$5.set(te[8], te[9], te[10]).length();
    const det = this.determinant();
    if (det < 0)
      sx = -sx;
    position2.x = te[12];
    position2.y = te[13];
    position2.z = te[14];
    _m1$2.copy(this);
    const invSX = 1 / sx;
    const invSY = 1 / sy;
    const invSZ = 1 / sz;
    _m1$2.elements[0] *= invSX;
    _m1$2.elements[1] *= invSX;
    _m1$2.elements[2] *= invSX;
    _m1$2.elements[4] *= invSY;
    _m1$2.elements[5] *= invSY;
    _m1$2.elements[6] *= invSY;
    _m1$2.elements[8] *= invSZ;
    _m1$2.elements[9] *= invSZ;
    _m1$2.elements[10] *= invSZ;
    quaternion.setFromRotationMatrix(_m1$2);
    scale2.x = sx;
    scale2.y = sy;
    scale2.z = sz;
    return this;
  }
  makePerspective(left2, right2, top2, bottom2, near, far) {
    if (far === void 0) {
      console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");
    }
    const te = this.elements;
    const x = 2 * near / (right2 - left2);
    const y = 2 * near / (top2 - bottom2);
    const a = (right2 + left2) / (right2 - left2);
    const b = (top2 + bottom2) / (top2 - bottom2);
    const c2 = -(far + near) / (far - near);
    const d = -2 * far * near / (far - near);
    te[0] = x;
    te[4] = 0;
    te[8] = a;
    te[12] = 0;
    te[1] = 0;
    te[5] = y;
    te[9] = b;
    te[13] = 0;
    te[2] = 0;
    te[6] = 0;
    te[10] = c2;
    te[14] = d;
    te[3] = 0;
    te[7] = 0;
    te[11] = -1;
    te[15] = 0;
    return this;
  }
  makeOrthographic(left2, right2, top2, bottom2, near, far) {
    const te = this.elements;
    const w = 1 / (right2 - left2);
    const h = 1 / (top2 - bottom2);
    const p = 1 / (far - near);
    const x = (right2 + left2) * w;
    const y = (top2 + bottom2) * h;
    const z = (far + near) * p;
    te[0] = 2 * w;
    te[4] = 0;
    te[8] = 0;
    te[12] = -x;
    te[1] = 0;
    te[5] = 2 * h;
    te[9] = 0;
    te[13] = -y;
    te[2] = 0;
    te[6] = 0;
    te[10] = -2 * p;
    te[14] = -z;
    te[3] = 0;
    te[7] = 0;
    te[11] = 0;
    te[15] = 1;
    return this;
  }
  equals(matrix) {
    const te = this.elements;
    const me = matrix.elements;
    for (let i = 0; i < 16; i++) {
      if (te[i] !== me[i])
        return false;
    }
    return true;
  }
  fromArray(array, offset = 0) {
    for (let i = 0; i < 16; i++) {
      this.elements[i] = array[i + offset];
    }
    return this;
  }
  toArray(array = [], offset = 0) {
    const te = this.elements;
    array[offset] = te[0];
    array[offset + 1] = te[1];
    array[offset + 2] = te[2];
    array[offset + 3] = te[3];
    array[offset + 4] = te[4];
    array[offset + 5] = te[5];
    array[offset + 6] = te[6];
    array[offset + 7] = te[7];
    array[offset + 8] = te[8];
    array[offset + 9] = te[9];
    array[offset + 10] = te[10];
    array[offset + 11] = te[11];
    array[offset + 12] = te[12];
    array[offset + 13] = te[13];
    array[offset + 14] = te[14];
    array[offset + 15] = te[15];
    return array;
  }
}
Matrix4.prototype.isMatrix4 = true;
const _v1$5 = /* @__PURE__ */ new Vector3();
const _m1$2 = /* @__PURE__ */ new Matrix4();
const _zero = /* @__PURE__ */ new Vector3(0, 0, 0);
const _one = /* @__PURE__ */ new Vector3(1, 1, 1);
const _x = /* @__PURE__ */ new Vector3();
const _y = /* @__PURE__ */ new Vector3();
const _z = /* @__PURE__ */ new Vector3();
const _matrix$1 = /* @__PURE__ */ new Matrix4();
const _quaternion$3 = /* @__PURE__ */ new Quaternion();
class Euler {
  constructor(x = 0, y = 0, z = 0, order = Euler.DefaultOrder) {
    this._x = x;
    this._y = y;
    this._z = z;
    this._order = order;
  }
  get x() {
    return this._x;
  }
  set x(value) {
    this._x = value;
    this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(value) {
    this._y = value;
    this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(value) {
    this._z = value;
    this._onChangeCallback();
  }
  get order() {
    return this._order;
  }
  set order(value) {
    this._order = value;
    this._onChangeCallback();
  }
  set(x, y, z, order = this._order) {
    this._x = x;
    this._y = y;
    this._z = z;
    this._order = order;
    this._onChangeCallback();
    return this;
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._order);
  }
  copy(euler) {
    this._x = euler._x;
    this._y = euler._y;
    this._z = euler._z;
    this._order = euler._order;
    this._onChangeCallback();
    return this;
  }
  setFromRotationMatrix(m, order = this._order, update2 = true) {
    const te = m.elements;
    const m11 = te[0], m12 = te[4], m13 = te[8];
    const m21 = te[1], m22 = te[5], m23 = te[9];
    const m31 = te[2], m32 = te[6], m33 = te[10];
    switch (order) {
      case "XYZ":
        this._y = Math.asin(clamp(m13, -1, 1));
        if (Math.abs(m13) < 0.9999999) {
          this._x = Math.atan2(-m23, m33);
          this._z = Math.atan2(-m12, m11);
        } else {
          this._x = Math.atan2(m32, m22);
          this._z = 0;
        }
        break;
      case "YXZ":
        this._x = Math.asin(-clamp(m23, -1, 1));
        if (Math.abs(m23) < 0.9999999) {
          this._y = Math.atan2(m13, m33);
          this._z = Math.atan2(m21, m22);
        } else {
          this._y = Math.atan2(-m31, m11);
          this._z = 0;
        }
        break;
      case "ZXY":
        this._x = Math.asin(clamp(m32, -1, 1));
        if (Math.abs(m32) < 0.9999999) {
          this._y = Math.atan2(-m31, m33);
          this._z = Math.atan2(-m12, m22);
        } else {
          this._y = 0;
          this._z = Math.atan2(m21, m11);
        }
        break;
      case "ZYX":
        this._y = Math.asin(-clamp(m31, -1, 1));
        if (Math.abs(m31) < 0.9999999) {
          this._x = Math.atan2(m32, m33);
          this._z = Math.atan2(m21, m11);
        } else {
          this._x = 0;
          this._z = Math.atan2(-m12, m22);
        }
        break;
      case "YZX":
        this._z = Math.asin(clamp(m21, -1, 1));
        if (Math.abs(m21) < 0.9999999) {
          this._x = Math.atan2(-m23, m22);
          this._y = Math.atan2(-m31, m11);
        } else {
          this._x = 0;
          this._y = Math.atan2(m13, m33);
        }
        break;
      case "XZY":
        this._z = Math.asin(-clamp(m12, -1, 1));
        if (Math.abs(m12) < 0.9999999) {
          this._x = Math.atan2(m32, m22);
          this._y = Math.atan2(m13, m11);
        } else {
          this._x = Math.atan2(-m23, m33);
          this._y = 0;
        }
        break;
      default:
        console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + order);
    }
    this._order = order;
    if (update2 === true)
      this._onChangeCallback();
    return this;
  }
  setFromQuaternion(q, order, update2) {
    _matrix$1.makeRotationFromQuaternion(q);
    return this.setFromRotationMatrix(_matrix$1, order, update2);
  }
  setFromVector3(v, order = this._order) {
    return this.set(v.x, v.y, v.z, order);
  }
  reorder(newOrder) {
    _quaternion$3.setFromEuler(this);
    return this.setFromQuaternion(_quaternion$3, newOrder);
  }
  equals(euler) {
    return euler._x === this._x && euler._y === this._y && euler._z === this._z && euler._order === this._order;
  }
  fromArray(array) {
    this._x = array[0];
    this._y = array[1];
    this._z = array[2];
    if (array[3] !== void 0)
      this._order = array[3];
    this._onChangeCallback();
    return this;
  }
  toArray(array = [], offset = 0) {
    array[offset] = this._x;
    array[offset + 1] = this._y;
    array[offset + 2] = this._z;
    array[offset + 3] = this._order;
    return array;
  }
  _onChange(callback) {
    this._onChangeCallback = callback;
    return this;
  }
  _onChangeCallback() {
  }
}
Euler.prototype.isEuler = true;
Euler.DefaultOrder = "XYZ";
Euler.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"];
class Layers {
  constructor() {
    this.mask = 1 | 0;
  }
  set(channel) {
    this.mask = (1 << channel | 0) >>> 0;
  }
  enable(channel) {
    this.mask |= 1 << channel | 0;
  }
  enableAll() {
    this.mask = 4294967295 | 0;
  }
  toggle(channel) {
    this.mask ^= 1 << channel | 0;
  }
  disable(channel) {
    this.mask &= ~(1 << channel | 0);
  }
  disableAll() {
    this.mask = 0;
  }
  test(layers2) {
    return (this.mask & layers2.mask) !== 0;
  }
  isEnabled(channel) {
    return (this.mask & (1 << channel | 0)) !== 0;
  }
}
let _object3DId = 0;
const _v1$4 = /* @__PURE__ */ new Vector3();
const _q1 = /* @__PURE__ */ new Quaternion();
const _m1$1 = /* @__PURE__ */ new Matrix4();
const _target = /* @__PURE__ */ new Vector3();
const _position$3 = /* @__PURE__ */ new Vector3();
const _scale$2 = /* @__PURE__ */ new Vector3();
const _quaternion$2 = /* @__PURE__ */ new Quaternion();
const _xAxis = /* @__PURE__ */ new Vector3(1, 0, 0);
const _yAxis = /* @__PURE__ */ new Vector3(0, 1, 0);
const _zAxis = /* @__PURE__ */ new Vector3(0, 0, 1);
const _addedEvent = { type: "added" };
const _removedEvent = { type: "removed" };
class Object3D extends EventDispatcher {
  constructor() {
    super();
    Object.defineProperty(this, "id", { value: _object3DId++ });
    this.uuid = generateUUID();
    this.name = "";
    this.type = "Object3D";
    this.parent = null;
    this.children = [];
    this.up = Object3D.DefaultUp.clone();
    const position2 = new Vector3();
    const rotation = new Euler();
    const quaternion = new Quaternion();
    const scale2 = new Vector3(1, 1, 1);
    function onRotationChange() {
      quaternion.setFromEuler(rotation, false);
    }
    function onQuaternionChange() {
      rotation.setFromQuaternion(quaternion, void 0, false);
    }
    rotation._onChange(onRotationChange);
    quaternion._onChange(onQuaternionChange);
    Object.defineProperties(this, {
      position: {
        configurable: true,
        enumerable: true,
        value: position2
      },
      rotation: {
        configurable: true,
        enumerable: true,
        value: rotation
      },
      quaternion: {
        configurable: true,
        enumerable: true,
        value: quaternion
      },
      scale: {
        configurable: true,
        enumerable: true,
        value: scale2
      },
      modelViewMatrix: {
        value: new Matrix4()
      },
      normalMatrix: {
        value: new Matrix3()
      }
    });
    this.matrix = new Matrix4();
    this.matrixWorld = new Matrix4();
    this.matrixAutoUpdate = Object3D.DefaultMatrixAutoUpdate;
    this.matrixWorldNeedsUpdate = false;
    this.layers = new Layers();
    this.visible = true;
    this.castShadow = false;
    this.receiveShadow = false;
    this.frustumCulled = true;
    this.renderOrder = 0;
    this.animations = [];
    this.userData = {};
  }
  onBeforeRender() {
  }
  onAfterRender() {
  }
  applyMatrix4(matrix) {
    if (this.matrixAutoUpdate)
      this.updateMatrix();
    this.matrix.premultiply(matrix);
    this.matrix.decompose(this.position, this.quaternion, this.scale);
  }
  applyQuaternion(q) {
    this.quaternion.premultiply(q);
    return this;
  }
  setRotationFromAxisAngle(axis, angle) {
    this.quaternion.setFromAxisAngle(axis, angle);
  }
  setRotationFromEuler(euler) {
    this.quaternion.setFromEuler(euler, true);
  }
  setRotationFromMatrix(m) {
    this.quaternion.setFromRotationMatrix(m);
  }
  setRotationFromQuaternion(q) {
    this.quaternion.copy(q);
  }
  rotateOnAxis(axis, angle) {
    _q1.setFromAxisAngle(axis, angle);
    this.quaternion.multiply(_q1);
    return this;
  }
  rotateOnWorldAxis(axis, angle) {
    _q1.setFromAxisAngle(axis, angle);
    this.quaternion.premultiply(_q1);
    return this;
  }
  rotateX(angle) {
    return this.rotateOnAxis(_xAxis, angle);
  }
  rotateY(angle) {
    return this.rotateOnAxis(_yAxis, angle);
  }
  rotateZ(angle) {
    return this.rotateOnAxis(_zAxis, angle);
  }
  translateOnAxis(axis, distance2) {
    _v1$4.copy(axis).applyQuaternion(this.quaternion);
    this.position.add(_v1$4.multiplyScalar(distance2));
    return this;
  }
  translateX(distance2) {
    return this.translateOnAxis(_xAxis, distance2);
  }
  translateY(distance2) {
    return this.translateOnAxis(_yAxis, distance2);
  }
  translateZ(distance2) {
    return this.translateOnAxis(_zAxis, distance2);
  }
  localToWorld(vector) {
    return vector.applyMatrix4(this.matrixWorld);
  }
  worldToLocal(vector) {
    return vector.applyMatrix4(_m1$1.copy(this.matrixWorld).invert());
  }
  lookAt(x, y, z) {
    if (x.isVector3) {
      _target.copy(x);
    } else {
      _target.set(x, y, z);
    }
    const parent = this.parent;
    this.updateWorldMatrix(true, false);
    _position$3.setFromMatrixPosition(this.matrixWorld);
    if (this.isCamera || this.isLight) {
      _m1$1.lookAt(_position$3, _target, this.up);
    } else {
      _m1$1.lookAt(_target, _position$3, this.up);
    }
    this.quaternion.setFromRotationMatrix(_m1$1);
    if (parent) {
      _m1$1.extractRotation(parent.matrixWorld);
      _q1.setFromRotationMatrix(_m1$1);
      this.quaternion.premultiply(_q1.invert());
    }
  }
  add(object) {
    if (arguments.length > 1) {
      for (let i = 0; i < arguments.length; i++) {
        this.add(arguments[i]);
      }
      return this;
    }
    if (object === this) {
      console.error("THREE.Object3D.add: object can't be added as a child of itself.", object);
      return this;
    }
    if (object && object.isObject3D) {
      if (object.parent !== null) {
        object.parent.remove(object);
      }
      object.parent = this;
      this.children.push(object);
      object.dispatchEvent(_addedEvent);
    } else {
      console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", object);
    }
    return this;
  }
  remove(object) {
    if (arguments.length > 1) {
      for (let i = 0; i < arguments.length; i++) {
        this.remove(arguments[i]);
      }
      return this;
    }
    const index2 = this.children.indexOf(object);
    if (index2 !== -1) {
      object.parent = null;
      this.children.splice(index2, 1);
      object.dispatchEvent(_removedEvent);
    }
    return this;
  }
  removeFromParent() {
    const parent = this.parent;
    if (parent !== null) {
      parent.remove(this);
    }
    return this;
  }
  clear() {
    for (let i = 0; i < this.children.length; i++) {
      const object = this.children[i];
      object.parent = null;
      object.dispatchEvent(_removedEvent);
    }
    this.children.length = 0;
    return this;
  }
  attach(object) {
    this.updateWorldMatrix(true, false);
    _m1$1.copy(this.matrixWorld).invert();
    if (object.parent !== null) {
      object.parent.updateWorldMatrix(true, false);
      _m1$1.multiply(object.parent.matrixWorld);
    }
    object.applyMatrix4(_m1$1);
    this.add(object);
    object.updateWorldMatrix(false, true);
    return this;
  }
  getObjectById(id) {
    return this.getObjectByProperty("id", id);
  }
  getObjectByName(name) {
    return this.getObjectByProperty("name", name);
  }
  getObjectByProperty(name, value) {
    if (this[name] === value)
      return this;
    for (let i = 0, l = this.children.length; i < l; i++) {
      const child = this.children[i];
      const object = child.getObjectByProperty(name, value);
      if (object !== void 0) {
        return object;
      }
    }
    return void 0;
  }
  getWorldPosition(target) {
    this.updateWorldMatrix(true, false);
    return target.setFromMatrixPosition(this.matrixWorld);
  }
  getWorldQuaternion(target) {
    this.updateWorldMatrix(true, false);
    this.matrixWorld.decompose(_position$3, target, _scale$2);
    return target;
  }
  getWorldScale(target) {
    this.updateWorldMatrix(true, false);
    this.matrixWorld.decompose(_position$3, _quaternion$2, target);
    return target;
  }
  getWorldDirection(target) {
    this.updateWorldMatrix(true, false);
    const e = this.matrixWorld.elements;
    return target.set(e[8], e[9], e[10]).normalize();
  }
  raycast() {
  }
  traverse(callback) {
    callback(this);
    const children2 = this.children;
    for (let i = 0, l = children2.length; i < l; i++) {
      children2[i].traverse(callback);
    }
  }
  traverseVisible(callback) {
    if (this.visible === false)
      return;
    callback(this);
    const children2 = this.children;
    for (let i = 0, l = children2.length; i < l; i++) {
      children2[i].traverseVisible(callback);
    }
  }
  traverseAncestors(callback) {
    const parent = this.parent;
    if (parent !== null) {
      callback(parent);
      parent.traverseAncestors(callback);
    }
  }
  updateMatrix() {
    this.matrix.compose(this.position, this.quaternion, this.scale);
    this.matrixWorldNeedsUpdate = true;
  }
  updateMatrixWorld(force) {
    if (this.matrixAutoUpdate)
      this.updateMatrix();
    if (this.matrixWorldNeedsUpdate || force) {
      if (this.parent === null) {
        this.matrixWorld.copy(this.matrix);
      } else {
        this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
      }
      this.matrixWorldNeedsUpdate = false;
      force = true;
    }
    const children2 = this.children;
    for (let i = 0, l = children2.length; i < l; i++) {
      children2[i].updateMatrixWorld(force);
    }
  }
  updateWorldMatrix(updateParents, updateChildren) {
    const parent = this.parent;
    if (updateParents === true && parent !== null) {
      parent.updateWorldMatrix(true, false);
    }
    if (this.matrixAutoUpdate)
      this.updateMatrix();
    if (this.parent === null) {
      this.matrixWorld.copy(this.matrix);
    } else {
      this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
    }
    if (updateChildren === true) {
      const children2 = this.children;
      for (let i = 0, l = children2.length; i < l; i++) {
        children2[i].updateWorldMatrix(false, true);
      }
    }
  }
  toJSON(meta) {
    const isRootObject = meta === void 0 || typeof meta === "string";
    const output = {};
    if (isRootObject) {
      meta = {
        geometries: {},
        materials: {},
        textures: {},
        images: {},
        shapes: {},
        skeletons: {},
        animations: {},
        nodes: {}
      };
      output.metadata = {
        version: 4.5,
        type: "Object",
        generator: "Object3D.toJSON"
      };
    }
    const object = {};
    object.uuid = this.uuid;
    object.type = this.type;
    if (this.name !== "")
      object.name = this.name;
    if (this.castShadow === true)
      object.castShadow = true;
    if (this.receiveShadow === true)
      object.receiveShadow = true;
    if (this.visible === false)
      object.visible = false;
    if (this.frustumCulled === false)
      object.frustumCulled = false;
    if (this.renderOrder !== 0)
      object.renderOrder = this.renderOrder;
    if (JSON.stringify(this.userData) !== "{}")
      object.userData = this.userData;
    object.layers = this.layers.mask;
    object.matrix = this.matrix.toArray();
    if (this.matrixAutoUpdate === false)
      object.matrixAutoUpdate = false;
    if (this.isInstancedMesh) {
      object.type = "InstancedMesh";
      object.count = this.count;
      object.instanceMatrix = this.instanceMatrix.toJSON();
      if (this.instanceColor !== null)
        object.instanceColor = this.instanceColor.toJSON();
    }
    function serialize(library, element) {
      if (library[element.uuid] === void 0) {
        library[element.uuid] = element.toJSON(meta);
      }
      return element.uuid;
    }
    if (this.isScene) {
      if (this.background) {
        if (this.background.isColor) {
          object.background = this.background.toJSON();
        } else if (this.background.isTexture) {
          object.background = this.background.toJSON(meta).uuid;
        }
      }
      if (this.environment && this.environment.isTexture) {
        object.environment = this.environment.toJSON(meta).uuid;
      }
    } else if (this.isMesh || this.isLine || this.isPoints) {
      object.geometry = serialize(meta.geometries, this.geometry);
      const parameters = this.geometry.parameters;
      if (parameters !== void 0 && parameters.shapes !== void 0) {
        const shapes = parameters.shapes;
        if (Array.isArray(shapes)) {
          for (let i = 0, l = shapes.length; i < l; i++) {
            const shape2 = shapes[i];
            serialize(meta.shapes, shape2);
          }
        } else {
          serialize(meta.shapes, shapes);
        }
      }
    }
    if (this.isSkinnedMesh) {
      object.bindMode = this.bindMode;
      object.bindMatrix = this.bindMatrix.toArray();
      if (this.skeleton !== void 0) {
        serialize(meta.skeletons, this.skeleton);
        object.skeleton = this.skeleton.uuid;
      }
    }
    if (this.material !== void 0) {
      if (Array.isArray(this.material)) {
        const uuids = [];
        for (let i = 0, l = this.material.length; i < l; i++) {
          uuids.push(serialize(meta.materials, this.material[i]));
        }
        object.material = uuids;
      } else {
        object.material = serialize(meta.materials, this.material);
      }
    }
    if (this.children.length > 0) {
      object.children = [];
      for (let i = 0; i < this.children.length; i++) {
        object.children.push(this.children[i].toJSON(meta).object);
      }
    }
    if (this.animations.length > 0) {
      object.animations = [];
      for (let i = 0; i < this.animations.length; i++) {
        const animation2 = this.animations[i];
        object.animations.push(serialize(meta.animations, animation2));
      }
    }
    if (isRootObject) {
      const geometries = extractFromCache(meta.geometries);
      const materials = extractFromCache(meta.materials);
      const textures = extractFromCache(meta.textures);
      const images = extractFromCache(meta.images);
      const shapes = extractFromCache(meta.shapes);
      const skeletons = extractFromCache(meta.skeletons);
      const animations = extractFromCache(meta.animations);
      const nodes = extractFromCache(meta.nodes);
      if (geometries.length > 0)
        output.geometries = geometries;
      if (materials.length > 0)
        output.materials = materials;
      if (textures.length > 0)
        output.textures = textures;
      if (images.length > 0)
        output.images = images;
      if (shapes.length > 0)
        output.shapes = shapes;
      if (skeletons.length > 0)
        output.skeletons = skeletons;
      if (animations.length > 0)
        output.animations = animations;
      if (nodes.length > 0)
        output.nodes = nodes;
    }
    output.object = object;
    return output;
    function extractFromCache(cache) {
      const values = [];
      for (const key in cache) {
        const data = cache[key];
        delete data.metadata;
        values.push(data);
      }
      return values;
    }
  }
  clone(recursive) {
    return new this.constructor().copy(this, recursive);
  }
  copy(source2, recursive = true) {
    this.name = source2.name;
    this.up.copy(source2.up);
    this.position.copy(source2.position);
    this.rotation.order = source2.rotation.order;
    this.quaternion.copy(source2.quaternion);
    this.scale.copy(source2.scale);
    this.matrix.copy(source2.matrix);
    this.matrixWorld.copy(source2.matrixWorld);
    this.matrixAutoUpdate = source2.matrixAutoUpdate;
    this.matrixWorldNeedsUpdate = source2.matrixWorldNeedsUpdate;
    this.layers.mask = source2.layers.mask;
    this.visible = source2.visible;
    this.castShadow = source2.castShadow;
    this.receiveShadow = source2.receiveShadow;
    this.frustumCulled = source2.frustumCulled;
    this.renderOrder = source2.renderOrder;
    this.userData = JSON.parse(JSON.stringify(source2.userData));
    if (recursive === true) {
      for (let i = 0; i < source2.children.length; i++) {
        const child = source2.children[i];
        this.add(child.clone());
      }
    }
    return this;
  }
}
Object3D.DefaultUp = new Vector3(0, 1, 0);
Object3D.DefaultMatrixAutoUpdate = true;
Object3D.prototype.isObject3D = true;
const _v0$1 = /* @__PURE__ */ new Vector3();
const _v1$3 = /* @__PURE__ */ new Vector3();
const _v2$2 = /* @__PURE__ */ new Vector3();
const _v3$1 = /* @__PURE__ */ new Vector3();
const _vab = /* @__PURE__ */ new Vector3();
const _vac = /* @__PURE__ */ new Vector3();
const _vbc = /* @__PURE__ */ new Vector3();
const _vap = /* @__PURE__ */ new Vector3();
const _vbp = /* @__PURE__ */ new Vector3();
const _vcp = /* @__PURE__ */ new Vector3();
class Triangle {
  constructor(a = new Vector3(), b = new Vector3(), c2 = new Vector3()) {
    this.a = a;
    this.b = b;
    this.c = c2;
  }
  static getNormal(a, b, c2, target) {
    target.subVectors(c2, b);
    _v0$1.subVectors(a, b);
    target.cross(_v0$1);
    const targetLengthSq = target.lengthSq();
    if (targetLengthSq > 0) {
      return target.multiplyScalar(1 / Math.sqrt(targetLengthSq));
    }
    return target.set(0, 0, 0);
  }
  static getBarycoord(point2, a, b, c2, target) {
    _v0$1.subVectors(c2, a);
    _v1$3.subVectors(b, a);
    _v2$2.subVectors(point2, a);
    const dot00 = _v0$1.dot(_v0$1);
    const dot01 = _v0$1.dot(_v1$3);
    const dot02 = _v0$1.dot(_v2$2);
    const dot11 = _v1$3.dot(_v1$3);
    const dot12 = _v1$3.dot(_v2$2);
    const denom = dot00 * dot11 - dot01 * dot01;
    if (denom === 0) {
      return target.set(-2, -1, -1);
    }
    const invDenom = 1 / denom;
    const u = (dot11 * dot02 - dot01 * dot12) * invDenom;
    const v = (dot00 * dot12 - dot01 * dot02) * invDenom;
    return target.set(1 - u - v, v, u);
  }
  static containsPoint(point2, a, b, c2) {
    this.getBarycoord(point2, a, b, c2, _v3$1);
    return _v3$1.x >= 0 && _v3$1.y >= 0 && _v3$1.x + _v3$1.y <= 1;
  }
  static getUV(point2, p1, p2, p3, uv1, uv2, uv3, target) {
    this.getBarycoord(point2, p1, p2, p3, _v3$1);
    target.set(0, 0);
    target.addScaledVector(uv1, _v3$1.x);
    target.addScaledVector(uv2, _v3$1.y);
    target.addScaledVector(uv3, _v3$1.z);
    return target;
  }
  static isFrontFacing(a, b, c2, direction2) {
    _v0$1.subVectors(c2, b);
    _v1$3.subVectors(a, b);
    return _v0$1.cross(_v1$3).dot(direction2) < 0 ? true : false;
  }
  set(a, b, c2) {
    this.a.copy(a);
    this.b.copy(b);
    this.c.copy(c2);
    return this;
  }
  setFromPointsAndIndices(points, i0, i1, i2) {
    this.a.copy(points[i0]);
    this.b.copy(points[i1]);
    this.c.copy(points[i2]);
    return this;
  }
  setFromAttributeAndIndices(attribute, i0, i1, i2) {
    this.a.fromBufferAttribute(attribute, i0);
    this.b.fromBufferAttribute(attribute, i1);
    this.c.fromBufferAttribute(attribute, i2);
    return this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(triangle) {
    this.a.copy(triangle.a);
    this.b.copy(triangle.b);
    this.c.copy(triangle.c);
    return this;
  }
  getArea() {
    _v0$1.subVectors(this.c, this.b);
    _v1$3.subVectors(this.a, this.b);
    return _v0$1.cross(_v1$3).length() * 0.5;
  }
  getMidpoint(target) {
    return target.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
  }
  getNormal(target) {
    return Triangle.getNormal(this.a, this.b, this.c, target);
  }
  getPlane(target) {
    return target.setFromCoplanarPoints(this.a, this.b, this.c);
  }
  getBarycoord(point2, target) {
    return Triangle.getBarycoord(point2, this.a, this.b, this.c, target);
  }
  getUV(point2, uv1, uv2, uv3, target) {
    return Triangle.getUV(point2, this.a, this.b, this.c, uv1, uv2, uv3, target);
  }
  containsPoint(point2) {
    return Triangle.containsPoint(point2, this.a, this.b, this.c);
  }
  isFrontFacing(direction2) {
    return Triangle.isFrontFacing(this.a, this.b, this.c, direction2);
  }
  intersectsBox(box) {
    return box.intersectsTriangle(this);
  }
  closestPointToPoint(p, target) {
    const a = this.a, b = this.b, c2 = this.c;
    let v, w;
    _vab.subVectors(b, a);
    _vac.subVectors(c2, a);
    _vap.subVectors(p, a);
    const d1 = _vab.dot(_vap);
    const d2 = _vac.dot(_vap);
    if (d1 <= 0 && d2 <= 0) {
      return target.copy(a);
    }
    _vbp.subVectors(p, b);
    const d3 = _vab.dot(_vbp);
    const d4 = _vac.dot(_vbp);
    if (d3 >= 0 && d4 <= d3) {
      return target.copy(b);
    }
    const vc = d1 * d4 - d3 * d2;
    if (vc <= 0 && d1 >= 0 && d3 <= 0) {
      v = d1 / (d1 - d3);
      return target.copy(a).addScaledVector(_vab, v);
    }
    _vcp.subVectors(p, c2);
    const d5 = _vab.dot(_vcp);
    const d6 = _vac.dot(_vcp);
    if (d6 >= 0 && d5 <= d6) {
      return target.copy(c2);
    }
    const vb = d5 * d2 - d1 * d6;
    if (vb <= 0 && d2 >= 0 && d6 <= 0) {
      w = d2 / (d2 - d6);
      return target.copy(a).addScaledVector(_vac, w);
    }
    const va = d3 * d6 - d5 * d4;
    if (va <= 0 && d4 - d3 >= 0 && d5 - d6 >= 0) {
      _vbc.subVectors(c2, b);
      w = (d4 - d3) / (d4 - d3 + (d5 - d6));
      return target.copy(b).addScaledVector(_vbc, w);
    }
    const denom = 1 / (va + vb + vc);
    v = vb * denom;
    w = vc * denom;
    return target.copy(a).addScaledVector(_vab, v).addScaledVector(_vac, w);
  }
  equals(triangle) {
    return triangle.a.equals(this.a) && triangle.b.equals(this.b) && triangle.c.equals(this.c);
  }
}
let materialId = 0;
class Material extends EventDispatcher {
  constructor() {
    super();
    Object.defineProperty(this, "id", { value: materialId++ });
    this.uuid = generateUUID();
    this.name = "";
    this.type = "Material";
    this.fog = true;
    this.blending = NormalBlending;
    this.side = FrontSide;
    this.vertexColors = false;
    this.opacity = 1;
    this.transparent = false;
    this.blendSrc = SrcAlphaFactor;
    this.blendDst = OneMinusSrcAlphaFactor;
    this.blendEquation = AddEquation;
    this.blendSrcAlpha = null;
    this.blendDstAlpha = null;
    this.blendEquationAlpha = null;
    this.depthFunc = LessEqualDepth;
    this.depthTest = true;
    this.depthWrite = true;
    this.stencilWriteMask = 255;
    this.stencilFunc = AlwaysStencilFunc;
    this.stencilRef = 0;
    this.stencilFuncMask = 255;
    this.stencilFail = KeepStencilOp;
    this.stencilZFail = KeepStencilOp;
    this.stencilZPass = KeepStencilOp;
    this.stencilWrite = false;
    this.clippingPlanes = null;
    this.clipIntersection = false;
    this.clipShadows = false;
    this.shadowSide = null;
    this.colorWrite = true;
    this.precision = null;
    this.polygonOffset = false;
    this.polygonOffsetFactor = 0;
    this.polygonOffsetUnits = 0;
    this.dithering = false;
    this.alphaToCoverage = false;
    this.premultipliedAlpha = false;
    this.visible = true;
    this.toneMapped = true;
    this.userData = {};
    this.version = 0;
    this._alphaTest = 0;
  }
  get alphaTest() {
    return this._alphaTest;
  }
  set alphaTest(value) {
    if (this._alphaTest > 0 !== value > 0) {
      this.version++;
    }
    this._alphaTest = value;
  }
  onBuild() {
  }
  onBeforeRender() {
  }
  onBeforeCompile() {
  }
  customProgramCacheKey() {
    return this.onBeforeCompile.toString();
  }
  setValues(values) {
    if (values === void 0)
      return;
    for (const key in values) {
      const newValue = values[key];
      if (newValue === void 0) {
        console.warn("THREE.Material: '" + key + "' parameter is undefined.");
        continue;
      }
      if (key === "shading") {
        console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.");
        this.flatShading = newValue === FlatShading ? true : false;
        continue;
      }
      const currentValue = this[key];
      if (currentValue === void 0) {
        console.warn("THREE." + this.type + ": '" + key + "' is not a property of this material.");
        continue;
      }
      if (currentValue && currentValue.isColor) {
        currentValue.set(newValue);
      } else if (currentValue && currentValue.isVector3 && (newValue && newValue.isVector3)) {
        currentValue.copy(newValue);
      } else {
        this[key] = newValue;
      }
    }
  }
  toJSON(meta) {
    const isRootObject = meta === void 0 || typeof meta === "string";
    if (isRootObject) {
      meta = {
        textures: {},
        images: {}
      };
    }
    const data = {
      metadata: {
        version: 4.5,
        type: "Material",
        generator: "Material.toJSON"
      }
    };
    data.uuid = this.uuid;
    data.type = this.type;
    if (this.name !== "")
      data.name = this.name;
    if (this.color && this.color.isColor)
      data.color = this.color.getHex();
    if (this.roughness !== void 0)
      data.roughness = this.roughness;
    if (this.metalness !== void 0)
      data.metalness = this.metalness;
    if (this.sheen !== void 0)
      data.sheen = this.sheen;
    if (this.sheenColor && this.sheenColor.isColor)
      data.sheenColor = this.sheenColor.getHex();
    if (this.sheenRoughness !== void 0)
      data.sheenRoughness = this.sheenRoughness;
    if (this.emissive && this.emissive.isColor)
      data.emissive = this.emissive.getHex();
    if (this.emissiveIntensity && this.emissiveIntensity !== 1)
      data.emissiveIntensity = this.emissiveIntensity;
    if (this.specular && this.specular.isColor)
      data.specular = this.specular.getHex();
    if (this.specularIntensity !== void 0)
      data.specularIntensity = this.specularIntensity;
    if (this.specularColor && this.specularColor.isColor)
      data.specularColor = this.specularColor.getHex();
    if (this.shininess !== void 0)
      data.shininess = this.shininess;
    if (this.clearcoat !== void 0)
      data.clearcoat = this.clearcoat;
    if (this.clearcoatRoughness !== void 0)
      data.clearcoatRoughness = this.clearcoatRoughness;
    if (this.clearcoatMap && this.clearcoatMap.isTexture) {
      data.clearcoatMap = this.clearcoatMap.toJSON(meta).uuid;
    }
    if (this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture) {
      data.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(meta).uuid;
    }
    if (this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture) {
      data.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(meta).uuid;
      data.clearcoatNormalScale = this.clearcoatNormalScale.toArray();
    }
    if (this.map && this.map.isTexture)
      data.map = this.map.toJSON(meta).uuid;
    if (this.matcap && this.matcap.isTexture)
      data.matcap = this.matcap.toJSON(meta).uuid;
    if (this.alphaMap && this.alphaMap.isTexture)
      data.alphaMap = this.alphaMap.toJSON(meta).uuid;
    if (this.lightMap && this.lightMap.isTexture) {
      data.lightMap = this.lightMap.toJSON(meta).uuid;
      data.lightMapIntensity = this.lightMapIntensity;
    }
    if (this.aoMap && this.aoMap.isTexture) {
      data.aoMap = this.aoMap.toJSON(meta).uuid;
      data.aoMapIntensity = this.aoMapIntensity;
    }
    if (this.bumpMap && this.bumpMap.isTexture) {
      data.bumpMap = this.bumpMap.toJSON(meta).uuid;
      data.bumpScale = this.bumpScale;
    }
    if (this.normalMap && this.normalMap.isTexture) {
      data.normalMap = this.normalMap.toJSON(meta).uuid;
      data.normalMapType = this.normalMapType;
      data.normalScale = this.normalScale.toArray();
    }
    if (this.displacementMap && this.displacementMap.isTexture) {
      data.displacementMap = this.displacementMap.toJSON(meta).uuid;
      data.displacementScale = this.displacementScale;
      data.displacementBias = this.displacementBias;
    }
    if (this.roughnessMap && this.roughnessMap.isTexture)
      data.roughnessMap = this.roughnessMap.toJSON(meta).uuid;
    if (this.metalnessMap && this.metalnessMap.isTexture)
      data.metalnessMap = this.metalnessMap.toJSON(meta).uuid;
    if (this.emissiveMap && this.emissiveMap.isTexture)
      data.emissiveMap = this.emissiveMap.toJSON(meta).uuid;
    if (this.specularMap && this.specularMap.isTexture)
      data.specularMap = this.specularMap.toJSON(meta).uuid;
    if (this.specularIntensityMap && this.specularIntensityMap.isTexture)
      data.specularIntensityMap = this.specularIntensityMap.toJSON(meta).uuid;
    if (this.specularColorMap && this.specularColorMap.isTexture)
      data.specularColorMap = this.specularColorMap.toJSON(meta).uuid;
    if (this.envMap && this.envMap.isTexture) {
      data.envMap = this.envMap.toJSON(meta).uuid;
      if (this.combine !== void 0)
        data.combine = this.combine;
    }
    if (this.envMapIntensity !== void 0)
      data.envMapIntensity = this.envMapIntensity;
    if (this.reflectivity !== void 0)
      data.reflectivity = this.reflectivity;
    if (this.refractionRatio !== void 0)
      data.refractionRatio = this.refractionRatio;
    if (this.gradientMap && this.gradientMap.isTexture) {
      data.gradientMap = this.gradientMap.toJSON(meta).uuid;
    }
    if (this.transmission !== void 0)
      data.transmission = this.transmission;
    if (this.transmissionMap && this.transmissionMap.isTexture)
      data.transmissionMap = this.transmissionMap.toJSON(meta).uuid;
    if (this.thickness !== void 0)
      data.thickness = this.thickness;
    if (this.thicknessMap && this.thicknessMap.isTexture)
      data.thicknessMap = this.thicknessMap.toJSON(meta).uuid;
    if (this.attenuationDistance !== void 0)
      data.attenuationDistance = this.attenuationDistance;
    if (this.attenuationColor !== void 0)
      data.attenuationColor = this.attenuationColor.getHex();
    if (this.size !== void 0)
      data.size = this.size;
    if (this.shadowSide !== null)
      data.shadowSide = this.shadowSide;
    if (this.sizeAttenuation !== void 0)
      data.sizeAttenuation = this.sizeAttenuation;
    if (this.blending !== NormalBlending)
      data.blending = this.blending;
    if (this.side !== FrontSide)
      data.side = this.side;
    if (this.vertexColors)
      data.vertexColors = true;
    if (this.opacity < 1)
      data.opacity = this.opacity;
    if (this.transparent === true)
      data.transparent = this.transparent;
    data.depthFunc = this.depthFunc;
    data.depthTest = this.depthTest;
    data.depthWrite = this.depthWrite;
    data.colorWrite = this.colorWrite;
    data.stencilWrite = this.stencilWrite;
    data.stencilWriteMask = this.stencilWriteMask;
    data.stencilFunc = this.stencilFunc;
    data.stencilRef = this.stencilRef;
    data.stencilFuncMask = this.stencilFuncMask;
    data.stencilFail = this.stencilFail;
    data.stencilZFail = this.stencilZFail;
    data.stencilZPass = this.stencilZPass;
    if (this.rotation !== void 0 && this.rotation !== 0)
      data.rotation = this.rotation;
    if (this.polygonOffset === true)
      data.polygonOffset = true;
    if (this.polygonOffsetFactor !== 0)
      data.polygonOffsetFactor = this.polygonOffsetFactor;
    if (this.polygonOffsetUnits !== 0)
      data.polygonOffsetUnits = this.polygonOffsetUnits;
    if (this.linewidth !== void 0 && this.linewidth !== 1)
      data.linewidth = this.linewidth;
    if (this.dashSize !== void 0)
      data.dashSize = this.dashSize;
    if (this.gapSize !== void 0)
      data.gapSize = this.gapSize;
    if (this.scale !== void 0)
      data.scale = this.scale;
    if (this.dithering === true)
      data.dithering = true;
    if (this.alphaTest > 0)
      data.alphaTest = this.alphaTest;
    if (this.alphaToCoverage === true)
      data.alphaToCoverage = this.alphaToCoverage;
    if (this.premultipliedAlpha === true)
      data.premultipliedAlpha = this.premultipliedAlpha;
    if (this.wireframe === true)
      data.wireframe = this.wireframe;
    if (this.wireframeLinewidth > 1)
      data.wireframeLinewidth = this.wireframeLinewidth;
    if (this.wireframeLinecap !== "round")
      data.wireframeLinecap = this.wireframeLinecap;
    if (this.wireframeLinejoin !== "round")
      data.wireframeLinejoin = this.wireframeLinejoin;
    if (this.flatShading === true)
      data.flatShading = this.flatShading;
    if (this.visible === false)
      data.visible = false;
    if (this.toneMapped === false)
      data.toneMapped = false;
    if (JSON.stringify(this.userData) !== "{}")
      data.userData = this.userData;
    function extractFromCache(cache) {
      const values = [];
      for (const key in cache) {
        const data2 = cache[key];
        delete data2.metadata;
        values.push(data2);
      }
      return values;
    }
    if (isRootObject) {
      const textures = extractFromCache(meta.textures);
      const images = extractFromCache(meta.images);
      if (textures.length > 0)
        data.textures = textures;
      if (images.length > 0)
        data.images = images;
    }
    return data;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(source2) {
    this.name = source2.name;
    this.fog = source2.fog;
    this.blending = source2.blending;
    this.side = source2.side;
    this.vertexColors = source2.vertexColors;
    this.opacity = source2.opacity;
    this.transparent = source2.transparent;
    this.blendSrc = source2.blendSrc;
    this.blendDst = source2.blendDst;
    this.blendEquation = source2.blendEquation;
    this.blendSrcAlpha = source2.blendSrcAlpha;
    this.blendDstAlpha = source2.blendDstAlpha;
    this.blendEquationAlpha = source2.blendEquationAlpha;
    this.depthFunc = source2.depthFunc;
    this.depthTest = source2.depthTest;
    this.depthWrite = source2.depthWrite;
    this.stencilWriteMask = source2.stencilWriteMask;
    this.stencilFunc = source2.stencilFunc;
    this.stencilRef = source2.stencilRef;
    this.stencilFuncMask = source2.stencilFuncMask;
    this.stencilFail = source2.stencilFail;
    this.stencilZFail = source2.stencilZFail;
    this.stencilZPass = source2.stencilZPass;
    this.stencilWrite = source2.stencilWrite;
    const srcPlanes = source2.clippingPlanes;
    let dstPlanes = null;
    if (srcPlanes !== null) {
      const n = srcPlanes.length;
      dstPlanes = new Array(n);
      for (let i = 0; i !== n; ++i) {
        dstPlanes[i] = srcPlanes[i].clone();
      }
    }
    this.clippingPlanes = dstPlanes;
    this.clipIntersection = source2.clipIntersection;
    this.clipShadows = source2.clipShadows;
    this.shadowSide = source2.shadowSide;
    this.colorWrite = source2.colorWrite;
    this.precision = source2.precision;
    this.polygonOffset = source2.polygonOffset;
    this.polygonOffsetFactor = source2.polygonOffsetFactor;
    this.polygonOffsetUnits = source2.polygonOffsetUnits;
    this.dithering = source2.dithering;
    this.alphaTest = source2.alphaTest;
    this.alphaToCoverage = source2.alphaToCoverage;
    this.premultipliedAlpha = source2.premultipliedAlpha;
    this.visible = source2.visible;
    this.toneMapped = source2.toneMapped;
    this.userData = JSON.parse(JSON.stringify(source2.userData));
    return this;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  set needsUpdate(value) {
    if (value === true)
      this.version++;
  }
}
Material.prototype.isMaterial = true;
Material.fromType = function() {
  return null;
};
class MeshBasicMaterial extends Material {
  constructor(parameters) {
    super();
    this.type = "MeshBasicMaterial";
    this.color = new Color(16777215);
    this.map = null;
    this.lightMap = null;
    this.lightMapIntensity = 1;
    this.aoMap = null;
    this.aoMapIntensity = 1;
    this.specularMap = null;
    this.alphaMap = null;
    this.envMap = null;
    this.combine = MultiplyOperation;
    this.reflectivity = 1;
    this.refractionRatio = 0.98;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.wireframeLinecap = "round";
    this.wireframeLinejoin = "round";
    this.setValues(parameters);
  }
  copy(source2) {
    super.copy(source2);
    this.color.copy(source2.color);
    this.map = source2.map;
    this.lightMap = source2.lightMap;
    this.lightMapIntensity = source2.lightMapIntensity;
    this.aoMap = source2.aoMap;
    this.aoMapIntensity = source2.aoMapIntensity;
    this.specularMap = source2.specularMap;
    this.alphaMap = source2.alphaMap;
    this.envMap = source2.envMap;
    this.combine = source2.combine;
    this.reflectivity = source2.reflectivity;
    this.refractionRatio = source2.refractionRatio;
    this.wireframe = source2.wireframe;
    this.wireframeLinewidth = source2.wireframeLinewidth;
    this.wireframeLinecap = source2.wireframeLinecap;
    this.wireframeLinejoin = source2.wireframeLinejoin;
    return this;
  }
}
MeshBasicMaterial.prototype.isMeshBasicMaterial = true;
const _vector$9 = /* @__PURE__ */ new Vector3();
const _vector2$1 = /* @__PURE__ */ new Vector2();
class BufferAttribute {
  constructor(array, itemSize, normalized) {
    if (Array.isArray(array)) {
      throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
    }
    this.name = "";
    this.array = array;
    this.itemSize = itemSize;
    this.count = array !== void 0 ? array.length / itemSize : 0;
    this.normalized = normalized === true;
    this.usage = StaticDrawUsage;
    this.updateRange = { offset: 0, count: -1 };
    this.version = 0;
  }
  onUploadCallback() {
  }
  set needsUpdate(value) {
    if (value === true)
      this.version++;
  }
  setUsage(value) {
    this.usage = value;
    return this;
  }
  copy(source2) {
    this.name = source2.name;
    this.array = new source2.array.constructor(source2.array);
    this.itemSize = source2.itemSize;
    this.count = source2.count;
    this.normalized = source2.normalized;
    this.usage = source2.usage;
    return this;
  }
  copyAt(index1, attribute, index2) {
    index1 *= this.itemSize;
    index2 *= attribute.itemSize;
    for (let i = 0, l = this.itemSize; i < l; i++) {
      this.array[index1 + i] = attribute.array[index2 + i];
    }
    return this;
  }
  copyArray(array) {
    this.array.set(array);
    return this;
  }
  copyColorsArray(colors2) {
    const array = this.array;
    let offset = 0;
    for (let i = 0, l = colors2.length; i < l; i++) {
      let color2 = colors2[i];
      if (color2 === void 0) {
        console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined", i);
        color2 = new Color();
      }
      array[offset++] = color2.r;
      array[offset++] = color2.g;
      array[offset++] = color2.b;
    }
    return this;
  }
  copyVector2sArray(vectors) {
    const array = this.array;
    let offset = 0;
    for (let i = 0, l = vectors.length; i < l; i++) {
      let vector = vectors[i];
      if (vector === void 0) {
        console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined", i);
        vector = new Vector2();
      }
      array[offset++] = vector.x;
      array[offset++] = vector.y;
    }
    return this;
  }
  copyVector3sArray(vectors) {
    const array = this.array;
    let offset = 0;
    for (let i = 0, l = vectors.length; i < l; i++) {
      let vector = vectors[i];
      if (vector === void 0) {
        console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined", i);
        vector = new Vector3();
      }
      array[offset++] = vector.x;
      array[offset++] = vector.y;
      array[offset++] = vector.z;
    }
    return this;
  }
  copyVector4sArray(vectors) {
    const array = this.array;
    let offset = 0;
    for (let i = 0, l = vectors.length; i < l; i++) {
      let vector = vectors[i];
      if (vector === void 0) {
        console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined", i);
        vector = new Vector4();
      }
      array[offset++] = vector.x;
      array[offset++] = vector.y;
      array[offset++] = vector.z;
      array[offset++] = vector.w;
    }
    return this;
  }
  applyMatrix3(m) {
    if (this.itemSize === 2) {
      for (let i = 0, l = this.count; i < l; i++) {
        _vector2$1.fromBufferAttribute(this, i);
        _vector2$1.applyMatrix3(m);
        this.setXY(i, _vector2$1.x, _vector2$1.y);
      }
    } else if (this.itemSize === 3) {
      for (let i = 0, l = this.count; i < l; i++) {
        _vector$9.fromBufferAttribute(this, i);
        _vector$9.applyMatrix3(m);
        this.setXYZ(i, _vector$9.x, _vector$9.y, _vector$9.z);
      }
    }
    return this;
  }
  applyMatrix4(m) {
    for (let i = 0, l = this.count; i < l; i++) {
      _vector$9.fromBufferAttribute(this, i);
      _vector$9.applyMatrix4(m);
      this.setXYZ(i, _vector$9.x, _vector$9.y, _vector$9.z);
    }
    return this;
  }
  applyNormalMatrix(m) {
    for (let i = 0, l = this.count; i < l; i++) {
      _vector$9.fromBufferAttribute(this, i);
      _vector$9.applyNormalMatrix(m);
      this.setXYZ(i, _vector$9.x, _vector$9.y, _vector$9.z);
    }
    return this;
  }
  transformDirection(m) {
    for (let i = 0, l = this.count; i < l; i++) {
      _vector$9.fromBufferAttribute(this, i);
      _vector$9.transformDirection(m);
      this.setXYZ(i, _vector$9.x, _vector$9.y, _vector$9.z);
    }
    return this;
  }
  set(value, offset = 0) {
    this.array.set(value, offset);
    return this;
  }
  getX(index2) {
    return this.array[index2 * this.itemSize];
  }
  setX(index2, x) {
    this.array[index2 * this.itemSize] = x;
    return this;
  }
  getY(index2) {
    return this.array[index2 * this.itemSize + 1];
  }
  setY(index2, y) {
    this.array[index2 * this.itemSize + 1] = y;
    return this;
  }
  getZ(index2) {
    return this.array[index2 * this.itemSize + 2];
  }
  setZ(index2, z) {
    this.array[index2 * this.itemSize + 2] = z;
    return this;
  }
  getW(index2) {
    return this.array[index2 * this.itemSize + 3];
  }
  setW(index2, w) {
    this.array[index2 * this.itemSize + 3] = w;
    return this;
  }
  setXY(index2, x, y) {
    index2 *= this.itemSize;
    this.array[index2 + 0] = x;
    this.array[index2 + 1] = y;
    return this;
  }
  setXYZ(index2, x, y, z) {
    index2 *= this.itemSize;
    this.array[index2 + 0] = x;
    this.array[index2 + 1] = y;
    this.array[index2 + 2] = z;
    return this;
  }
  setXYZW(index2, x, y, z, w) {
    index2 *= this.itemSize;
    this.array[index2 + 0] = x;
    this.array[index2 + 1] = y;
    this.array[index2 + 2] = z;
    this.array[index2 + 3] = w;
    return this;
  }
  onUpload(callback) {
    this.onUploadCallback = callback;
    return this;
  }
  clone() {
    return new this.constructor(this.array, this.itemSize).copy(this);
  }
  toJSON() {
    const data = {
      itemSize: this.itemSize,
      type: this.array.constructor.name,
      array: Array.prototype.slice.call(this.array),
      normalized: this.normalized
    };
    if (this.name !== "")
      data.name = this.name;
    if (this.usage !== StaticDrawUsage)
      data.usage = this.usage;
    if (this.updateRange.offset !== 0 || this.updateRange.count !== -1)
      data.updateRange = this.updateRange;
    return data;
  }
}
BufferAttribute.prototype.isBufferAttribute = true;
class Uint16BufferAttribute extends BufferAttribute {
  constructor(array, itemSize, normalized) {
    super(new Uint16Array(array), itemSize, normalized);
  }
}
class Uint32BufferAttribute extends BufferAttribute {
  constructor(array, itemSize, normalized) {
    super(new Uint32Array(array), itemSize, normalized);
  }
}
class Float16BufferAttribute extends BufferAttribute {
  constructor(array, itemSize, normalized) {
    super(new Uint16Array(array), itemSize, normalized);
  }
}
Float16BufferAttribute.prototype.isFloat16BufferAttribute = true;
class Float32BufferAttribute extends BufferAttribute {
  constructor(array, itemSize, normalized) {
    super(new Float32Array(array), itemSize, normalized);
  }
}
let _id$1 = 0;
const _m1 = /* @__PURE__ */ new Matrix4();
const _obj = /* @__PURE__ */ new Object3D();
const _offset = /* @__PURE__ */ new Vector3();
const _box$1 = /* @__PURE__ */ new Box3();
const _boxMorphTargets = /* @__PURE__ */ new Box3();
const _vector$8 = /* @__PURE__ */ new Vector3();
class BufferGeometry extends EventDispatcher {
  constructor() {
    super();
    Object.defineProperty(this, "id", { value: _id$1++ });
    this.uuid = generateUUID();
    this.name = "";
    this.type = "BufferGeometry";
    this.index = null;
    this.attributes = {};
    this.morphAttributes = {};
    this.morphTargetsRelative = false;
    this.groups = [];
    this.boundingBox = null;
    this.boundingSphere = null;
    this.drawRange = { start: 0, count: Infinity };
    this.userData = {};
  }
  getIndex() {
    return this.index;
  }
  setIndex(index2) {
    if (Array.isArray(index2)) {
      this.index = new (arrayNeedsUint32(index2) ? Uint32BufferAttribute : Uint16BufferAttribute)(index2, 1);
    } else {
      this.index = index2;
    }
    return this;
  }
  getAttribute(name) {
    return this.attributes[name];
  }
  setAttribute(name, attribute) {
    this.attributes[name] = attribute;
    return this;
  }
  deleteAttribute(name) {
    delete this.attributes[name];
    return this;
  }
  hasAttribute(name) {
    return this.attributes[name] !== void 0;
  }
  addGroup(start2, count, materialIndex = 0) {
    this.groups.push({
      start: start2,
      count,
      materialIndex
    });
  }
  clearGroups() {
    this.groups = [];
  }
  setDrawRange(start2, count) {
    this.drawRange.start = start2;
    this.drawRange.count = count;
  }
  applyMatrix4(matrix) {
    const position2 = this.attributes.position;
    if (position2 !== void 0) {
      position2.applyMatrix4(matrix);
      position2.needsUpdate = true;
    }
    const normal = this.attributes.normal;
    if (normal !== void 0) {
      const normalMatrix = new Matrix3().getNormalMatrix(matrix);
      normal.applyNormalMatrix(normalMatrix);
      normal.needsUpdate = true;
    }
    const tangent = this.attributes.tangent;
    if (tangent !== void 0) {
      tangent.transformDirection(matrix);
      tangent.needsUpdate = true;
    }
    if (this.boundingBox !== null) {
      this.computeBoundingBox();
    }
    if (this.boundingSphere !== null) {
      this.computeBoundingSphere();
    }
    return this;
  }
  applyQuaternion(q) {
    _m1.makeRotationFromQuaternion(q);
    this.applyMatrix4(_m1);
    return this;
  }
  rotateX(angle) {
    _m1.makeRotationX(angle);
    this.applyMatrix4(_m1);
    return this;
  }
  rotateY(angle) {
    _m1.makeRotationY(angle);
    this.applyMatrix4(_m1);
    return this;
  }
  rotateZ(angle) {
    _m1.makeRotationZ(angle);
    this.applyMatrix4(_m1);
    return this;
  }
  translate(x, y, z) {
    _m1.makeTranslation(x, y, z);
    this.applyMatrix4(_m1);
    return this;
  }
  scale(x, y, z) {
    _m1.makeScale(x, y, z);
    this.applyMatrix4(_m1);
    return this;
  }
  lookAt(vector) {
    _obj.lookAt(vector);
    _obj.updateMatrix();
    this.applyMatrix4(_obj.matrix);
    return this;
  }
  center() {
    this.computeBoundingBox();
    this.boundingBox.getCenter(_offset).negate();
    this.translate(_offset.x, _offset.y, _offset.z);
    return this;
  }
  setFromPoints(points) {
    const position2 = [];
    for (let i = 0, l = points.length; i < l; i++) {
      const point2 = points[i];
      position2.push(point2.x, point2.y, point2.z || 0);
    }
    this.setAttribute("position", new Float32BufferAttribute(position2, 3));
    return this;
  }
  computeBoundingBox() {
    if (this.boundingBox === null) {
      this.boundingBox = new Box3();
    }
    const position2 = this.attributes.position;
    const morphAttributesPosition = this.morphAttributes.position;
    if (position2 && position2.isGLBufferAttribute) {
      console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this);
      this.boundingBox.set(new Vector3(-Infinity, -Infinity, -Infinity), new Vector3(Infinity, Infinity, Infinity));
      return;
    }
    if (position2 !== void 0) {
      this.boundingBox.setFromBufferAttribute(position2);
      if (morphAttributesPosition) {
        for (let i = 0, il = morphAttributesPosition.length; i < il; i++) {
          const morphAttribute = morphAttributesPosition[i];
          _box$1.setFromBufferAttribute(morphAttribute);
          if (this.morphTargetsRelative) {
            _vector$8.addVectors(this.boundingBox.min, _box$1.min);
            this.boundingBox.expandByPoint(_vector$8);
            _vector$8.addVectors(this.boundingBox.max, _box$1.max);
            this.boundingBox.expandByPoint(_vector$8);
          } else {
            this.boundingBox.expandByPoint(_box$1.min);
            this.boundingBox.expandByPoint(_box$1.max);
          }
        }
      }
    } else {
      this.boundingBox.makeEmpty();
    }
    if (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) {
      console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
    }
  }
  computeBoundingSphere() {
    if (this.boundingSphere === null) {
      this.boundingSphere = new Sphere();
    }
    const position2 = this.attributes.position;
    const morphAttributesPosition = this.morphAttributes.position;
    if (position2 && position2.isGLBufferAttribute) {
      console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this);
      this.boundingSphere.set(new Vector3(), Infinity);
      return;
    }
    if (position2) {
      const center2 = this.boundingSphere.center;
      _box$1.setFromBufferAttribute(position2);
      if (morphAttributesPosition) {
        for (let i = 0, il = morphAttributesPosition.length; i < il; i++) {
          const morphAttribute = morphAttributesPosition[i];
          _boxMorphTargets.setFromBufferAttribute(morphAttribute);
          if (this.morphTargetsRelative) {
            _vector$8.addVectors(_box$1.min, _boxMorphTargets.min);
            _box$1.expandByPoint(_vector$8);
            _vector$8.addVectors(_box$1.max, _boxMorphTargets.max);
            _box$1.expandByPoint(_vector$8);
          } else {
            _box$1.expandByPoint(_boxMorphTargets.min);
            _box$1.expandByPoint(_boxMorphTargets.max);
          }
        }
      }
      _box$1.getCenter(center2);
      let maxRadiusSq = 0;
      for (let i = 0, il = position2.count; i < il; i++) {
        _vector$8.fromBufferAttribute(position2, i);
        maxRadiusSq = Math.max(maxRadiusSq, center2.distanceToSquared(_vector$8));
      }
      if (morphAttributesPosition) {
        for (let i = 0, il = morphAttributesPosition.length; i < il; i++) {
          const morphAttribute = morphAttributesPosition[i];
          const morphTargetsRelative = this.morphTargetsRelative;
          for (let j = 0, jl = morphAttribute.count; j < jl; j++) {
            _vector$8.fromBufferAttribute(morphAttribute, j);
            if (morphTargetsRelative) {
              _offset.fromBufferAttribute(position2, j);
              _vector$8.add(_offset);
            }
            maxRadiusSq = Math.max(maxRadiusSq, center2.distanceToSquared(_vector$8));
          }
        }
      }
      this.boundingSphere.radius = Math.sqrt(maxRadiusSq);
      if (isNaN(this.boundingSphere.radius)) {
        console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
      }
    }
  }
  computeTangents() {
    const index2 = this.index;
    const attributes = this.attributes;
    if (index2 === null || attributes.position === void 0 || attributes.normal === void 0 || attributes.uv === void 0) {
      console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
      return;
    }
    const indices = index2.array;
    const positions = attributes.position.array;
    const normals = attributes.normal.array;
    const uvs = attributes.uv.array;
    const nVertices = positions.length / 3;
    if (this.hasAttribute("tangent") === false) {
      this.setAttribute("tangent", new BufferAttribute(new Float32Array(4 * nVertices), 4));
    }
    const tangents = this.getAttribute("tangent").array;
    const tan1 = [], tan2 = [];
    for (let i = 0; i < nVertices; i++) {
      tan1[i] = new Vector3();
      tan2[i] = new Vector3();
    }
    const vA = new Vector3(), vB = new Vector3(), vC = new Vector3(), uvA = new Vector2(), uvB = new Vector2(), uvC = new Vector2(), sdir = new Vector3(), tdir = new Vector3();
    function handleTriangle(a, b, c2) {
      vA.fromArray(positions, a * 3);
      vB.fromArray(positions, b * 3);
      vC.fromArray(positions, c2 * 3);
      uvA.fromArray(uvs, a * 2);
      uvB.fromArray(uvs, b * 2);
      uvC.fromArray(uvs, c2 * 2);
      vB.sub(vA);
      vC.sub(vA);
      uvB.sub(uvA);
      uvC.sub(uvA);
      const r = 1 / (uvB.x * uvC.y - uvC.x * uvB.y);
      if (!isFinite(r))
        return;
      sdir.copy(vB).multiplyScalar(uvC.y).addScaledVector(vC, -uvB.y).multiplyScalar(r);
      tdir.copy(vC).multiplyScalar(uvB.x).addScaledVector(vB, -uvC.x).multiplyScalar(r);
      tan1[a].add(sdir);
      tan1[b].add(sdir);
      tan1[c2].add(sdir);
      tan2[a].add(tdir);
      tan2[b].add(tdir);
      tan2[c2].add(tdir);
    }
    let groups = this.groups;
    if (groups.length === 0) {
      groups = [{
        start: 0,
        count: indices.length
      }];
    }
    for (let i = 0, il = groups.length; i < il; ++i) {
      const group2 = groups[i];
      const start2 = group2.start;
      const count = group2.count;
      for (let j = start2, jl = start2 + count; j < jl; j += 3) {
        handleTriangle(indices[j + 0], indices[j + 1], indices[j + 2]);
      }
    }
    const tmp2 = new Vector3(), tmp22 = new Vector3();
    const n = new Vector3(), n2 = new Vector3();
    function handleVertex(v) {
      n.fromArray(normals, v * 3);
      n2.copy(n);
      const t = tan1[v];
      tmp2.copy(t);
      tmp2.sub(n.multiplyScalar(n.dot(t))).normalize();
      tmp22.crossVectors(n2, t);
      const test = tmp22.dot(tan2[v]);
      const w = test < 0 ? -1 : 1;
      tangents[v * 4] = tmp2.x;
      tangents[v * 4 + 1] = tmp2.y;
      tangents[v * 4 + 2] = tmp2.z;
      tangents[v * 4 + 3] = w;
    }
    for (let i = 0, il = groups.length; i < il; ++i) {
      const group2 = groups[i];
      const start2 = group2.start;
      const count = group2.count;
      for (let j = start2, jl = start2 + count; j < jl; j += 3) {
        handleVertex(indices[j + 0]);
        handleVertex(indices[j + 1]);
        handleVertex(indices[j + 2]);
      }
    }
  }
  computeVertexNormals() {
    const index2 = this.index;
    const positionAttribute = this.getAttribute("position");
    if (positionAttribute !== void 0) {
      let normalAttribute = this.getAttribute("normal");
      if (normalAttribute === void 0) {
        normalAttribute = new BufferAttribute(new Float32Array(positionAttribute.count * 3), 3);
        this.setAttribute("normal", normalAttribute);
      } else {
        for (let i = 0, il = normalAttribute.count; i < il; i++) {
          normalAttribute.setXYZ(i, 0, 0, 0);
        }
      }
      const pA = new Vector3(), pB = new Vector3(), pC = new Vector3();
      const nA = new Vector3(), nB = new Vector3(), nC = new Vector3();
      const cb = new Vector3(), ab = new Vector3();
      if (index2) {
        for (let i = 0, il = index2.count; i < il; i += 3) {
          const vA = index2.getX(i + 0);
          const vB = index2.getX(i + 1);
          const vC = index2.getX(i + 2);
          pA.fromBufferAttribute(positionAttribute, vA);
          pB.fromBufferAttribute(positionAttribute, vB);
          pC.fromBufferAttribute(positionAttribute, vC);
          cb.subVectors(pC, pB);
          ab.subVectors(pA, pB);
          cb.cross(ab);
          nA.fromBufferAttribute(normalAttribute, vA);
          nB.fromBufferAttribute(normalAttribute, vB);
          nC.fromBufferAttribute(normalAttribute, vC);
          nA.add(cb);
          nB.add(cb);
          nC.add(cb);
          normalAttribute.setXYZ(vA, nA.x, nA.y, nA.z);
          normalAttribute.setXYZ(vB, nB.x, nB.y, nB.z);
          normalAttribute.setXYZ(vC, nC.x, nC.y, nC.z);
        }
      } else {
        for (let i = 0, il = positionAttribute.count; i < il; i += 3) {
          pA.fromBufferAttribute(positionAttribute, i + 0);
          pB.fromBufferAttribute(positionAttribute, i + 1);
          pC.fromBufferAttribute(positionAttribute, i + 2);
          cb.subVectors(pC, pB);
          ab.subVectors(pA, pB);
          cb.cross(ab);
          normalAttribute.setXYZ(i + 0, cb.x, cb.y, cb.z);
          normalAttribute.setXYZ(i + 1, cb.x, cb.y, cb.z);
          normalAttribute.setXYZ(i + 2, cb.x, cb.y, cb.z);
        }
      }
      this.normalizeNormals();
      normalAttribute.needsUpdate = true;
    }
  }
  merge(geometry, offset) {
    if (!(geometry && geometry.isBufferGeometry)) {
      console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.", geometry);
      return;
    }
    if (offset === void 0) {
      offset = 0;
      console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge.");
    }
    const attributes = this.attributes;
    for (const key in attributes) {
      if (geometry.attributes[key] === void 0)
        continue;
      const attribute1 = attributes[key];
      const attributeArray1 = attribute1.array;
      const attribute2 = geometry.attributes[key];
      const attributeArray2 = attribute2.array;
      const attributeOffset = attribute2.itemSize * offset;
      const length2 = Math.min(attributeArray2.length, attributeArray1.length - attributeOffset);
      for (let i = 0, j = attributeOffset; i < length2; i++, j++) {
        attributeArray1[j] = attributeArray2[i];
      }
    }
    return this;
  }
  normalizeNormals() {
    const normals = this.attributes.normal;
    for (let i = 0, il = normals.count; i < il; i++) {
      _vector$8.fromBufferAttribute(normals, i);
      _vector$8.normalize();
      normals.setXYZ(i, _vector$8.x, _vector$8.y, _vector$8.z);
    }
  }
  toNonIndexed() {
    function convertBufferAttribute(attribute, indices2) {
      const array = attribute.array;
      const itemSize = attribute.itemSize;
      const normalized = attribute.normalized;
      const array2 = new array.constructor(indices2.length * itemSize);
      let index2 = 0, index22 = 0;
      for (let i = 0, l = indices2.length; i < l; i++) {
        if (attribute.isInterleavedBufferAttribute) {
          index2 = indices2[i] * attribute.data.stride + attribute.offset;
        } else {
          index2 = indices2[i] * itemSize;
        }
        for (let j = 0; j < itemSize; j++) {
          array2[index22++] = array[index2++];
        }
      }
      return new BufferAttribute(array2, itemSize, normalized);
    }
    if (this.index === null) {
      console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed.");
      return this;
    }
    const geometry2 = new BufferGeometry();
    const indices = this.index.array;
    const attributes = this.attributes;
    for (const name in attributes) {
      const attribute = attributes[name];
      const newAttribute = convertBufferAttribute(attribute, indices);
      geometry2.setAttribute(name, newAttribute);
    }
    const morphAttributes = this.morphAttributes;
    for (const name in morphAttributes) {
      const morphArray = [];
      const morphAttribute = morphAttributes[name];
      for (let i = 0, il = morphAttribute.length; i < il; i++) {
        const attribute = morphAttribute[i];
        const newAttribute = convertBufferAttribute(attribute, indices);
        morphArray.push(newAttribute);
      }
      geometry2.morphAttributes[name] = morphArray;
    }
    geometry2.morphTargetsRelative = this.morphTargetsRelative;
    const groups = this.groups;
    for (let i = 0, l = groups.length; i < l; i++) {
      const group2 = groups[i];
      geometry2.addGroup(group2.start, group2.count, group2.materialIndex);
    }
    return geometry2;
  }
  toJSON() {
    const data = {
      metadata: {
        version: 4.5,
        type: "BufferGeometry",
        generator: "BufferGeometry.toJSON"
      }
    };
    data.uuid = this.uuid;
    data.type = this.type;
    if (this.name !== "")
      data.name = this.name;
    if (Object.keys(this.userData).length > 0)
      data.userData = this.userData;
    if (this.parameters !== void 0) {
      const parameters = this.parameters;
      for (const key in parameters) {
        if (parameters[key] !== void 0)
          data[key] = parameters[key];
      }
      return data;
    }
    data.data = { attributes: {} };
    const index2 = this.index;
    if (index2 !== null) {
      data.data.index = {
        type: index2.array.constructor.name,
        array: Array.prototype.slice.call(index2.array)
      };
    }
    const attributes = this.attributes;
    for (const key in attributes) {
      const attribute = attributes[key];
      data.data.attributes[key] = attribute.toJSON(data.data);
    }
    const morphAttributes = {};
    let hasMorphAttributes = false;
    for (const key in this.morphAttributes) {
      const attributeArray = this.morphAttributes[key];
      const array = [];
      for (let i = 0, il = attributeArray.length; i < il; i++) {
        const attribute = attributeArray[i];
        array.push(attribute.toJSON(data.data));
      }
      if (array.length > 0) {
        morphAttributes[key] = array;
        hasMorphAttributes = true;
      }
    }
    if (hasMorphAttributes) {
      data.data.morphAttributes = morphAttributes;
      data.data.morphTargetsRelative = this.morphTargetsRelative;
    }
    const groups = this.groups;
    if (groups.length > 0) {
      data.data.groups = JSON.parse(JSON.stringify(groups));
    }
    const boundingSphere = this.boundingSphere;
    if (boundingSphere !== null) {
      data.data.boundingSphere = {
        center: boundingSphere.center.toArray(),
        radius: boundingSphere.radius
      };
    }
    return data;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(source2) {
    this.index = null;
    this.attributes = {};
    this.morphAttributes = {};
    this.groups = [];
    this.boundingBox = null;
    this.boundingSphere = null;
    const data = {};
    this.name = source2.name;
    const index2 = source2.index;
    if (index2 !== null) {
      this.setIndex(index2.clone(data));
    }
    const attributes = source2.attributes;
    for (const name in attributes) {
      const attribute = attributes[name];
      this.setAttribute(name, attribute.clone(data));
    }
    const morphAttributes = source2.morphAttributes;
    for (const name in morphAttributes) {
      const array = [];
      const morphAttribute = morphAttributes[name];
      for (let i = 0, l = morphAttribute.length; i < l; i++) {
        array.push(morphAttribute[i].clone(data));
      }
      this.morphAttributes[name] = array;
    }
    this.morphTargetsRelative = source2.morphTargetsRelative;
    const groups = source2.groups;
    for (let i = 0, l = groups.length; i < l; i++) {
      const group2 = groups[i];
      this.addGroup(group2.start, group2.count, group2.materialIndex);
    }
    const boundingBox = source2.boundingBox;
    if (boundingBox !== null) {
      this.boundingBox = boundingBox.clone();
    }
    const boundingSphere = source2.boundingSphere;
    if (boundingSphere !== null) {
      this.boundingSphere = boundingSphere.clone();
    }
    this.drawRange.start = source2.drawRange.start;
    this.drawRange.count = source2.drawRange.count;
    this.userData = source2.userData;
    if (source2.parameters !== void 0)
      this.parameters = Object.assign({}, source2.parameters);
    return this;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
BufferGeometry.prototype.isBufferGeometry = true;
const _inverseMatrix$2 = /* @__PURE__ */ new Matrix4();
const _ray$2 = /* @__PURE__ */ new Ray();
const _sphere$3 = /* @__PURE__ */ new Sphere();
const _vA$1 = /* @__PURE__ */ new Vector3();
const _vB$1 = /* @__PURE__ */ new Vector3();
const _vC$1 = /* @__PURE__ */ new Vector3();
const _tempA = /* @__PURE__ */ new Vector3();
const _tempB = /* @__PURE__ */ new Vector3();
const _tempC = /* @__PURE__ */ new Vector3();
const _morphA = /* @__PURE__ */ new Vector3();
const _morphB = /* @__PURE__ */ new Vector3();
const _morphC = /* @__PURE__ */ new Vector3();
const _uvA$1 = /* @__PURE__ */ new Vector2();
const _uvB$1 = /* @__PURE__ */ new Vector2();
const _uvC$1 = /* @__PURE__ */ new Vector2();
const _intersectionPoint = /* @__PURE__ */ new Vector3();
const _intersectionPointWorld = /* @__PURE__ */ new Vector3();
class Mesh extends Object3D {
  constructor(geometry = new BufferGeometry(), material = new MeshBasicMaterial()) {
    super();
    this.type = "Mesh";
    this.geometry = geometry;
    this.material = material;
    this.updateMorphTargets();
  }
  copy(source2) {
    super.copy(source2);
    if (source2.morphTargetInfluences !== void 0) {
      this.morphTargetInfluences = source2.morphTargetInfluences.slice();
    }
    if (source2.morphTargetDictionary !== void 0) {
      this.morphTargetDictionary = Object.assign({}, source2.morphTargetDictionary);
    }
    this.material = source2.material;
    this.geometry = source2.geometry;
    return this;
  }
  updateMorphTargets() {
    const geometry = this.geometry;
    if (geometry.isBufferGeometry) {
      const morphAttributes = geometry.morphAttributes;
      const keys2 = Object.keys(morphAttributes);
      if (keys2.length > 0) {
        const morphAttribute = morphAttributes[keys2[0]];
        if (morphAttribute !== void 0) {
          this.morphTargetInfluences = [];
          this.morphTargetDictionary = {};
          for (let m = 0, ml = morphAttribute.length; m < ml; m++) {
            const name = morphAttribute[m].name || String(m);
            this.morphTargetInfluences.push(0);
            this.morphTargetDictionary[name] = m;
          }
        }
      }
    } else {
      const morphTargets = geometry.morphTargets;
      if (morphTargets !== void 0 && morphTargets.length > 0) {
        console.error("THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
      }
    }
  }
  raycast(raycaster, intersects2) {
    const geometry = this.geometry;
    const material = this.material;
    const matrixWorld = this.matrixWorld;
    if (material === void 0)
      return;
    if (geometry.boundingSphere === null)
      geometry.computeBoundingSphere();
    _sphere$3.copy(geometry.boundingSphere);
    _sphere$3.applyMatrix4(matrixWorld);
    if (raycaster.ray.intersectsSphere(_sphere$3) === false)
      return;
    _inverseMatrix$2.copy(matrixWorld).invert();
    _ray$2.copy(raycaster.ray).applyMatrix4(_inverseMatrix$2);
    if (geometry.boundingBox !== null) {
      if (_ray$2.intersectsBox(geometry.boundingBox) === false)
        return;
    }
    let intersection;
    if (geometry.isBufferGeometry) {
      const index2 = geometry.index;
      const position2 = geometry.attributes.position;
      const morphPosition = geometry.morphAttributes.position;
      const morphTargetsRelative = geometry.morphTargetsRelative;
      const uv = geometry.attributes.uv;
      const uv2 = geometry.attributes.uv2;
      const groups = geometry.groups;
      const drawRange = geometry.drawRange;
      if (index2 !== null) {
        if (Array.isArray(material)) {
          for (let i = 0, il = groups.length; i < il; i++) {
            const group2 = groups[i];
            const groupMaterial = material[group2.materialIndex];
            const start2 = Math.max(group2.start, drawRange.start);
            const end2 = Math.min(index2.count, Math.min(group2.start + group2.count, drawRange.start + drawRange.count));
            for (let j = start2, jl = end2; j < jl; j += 3) {
              const a = index2.getX(j);
              const b = index2.getX(j + 1);
              const c2 = index2.getX(j + 2);
              intersection = checkBufferGeometryIntersection(this, groupMaterial, raycaster, _ray$2, position2, morphPosition, morphTargetsRelative, uv, uv2, a, b, c2);
              if (intersection) {
                intersection.faceIndex = Math.floor(j / 3);
                intersection.face.materialIndex = group2.materialIndex;
                intersects2.push(intersection);
              }
            }
          }
        } else {
          const start2 = Math.max(0, drawRange.start);
          const end2 = Math.min(index2.count, drawRange.start + drawRange.count);
          for (let i = start2, il = end2; i < il; i += 3) {
            const a = index2.getX(i);
            const b = index2.getX(i + 1);
            const c2 = index2.getX(i + 2);
            intersection = checkBufferGeometryIntersection(this, material, raycaster, _ray$2, position2, morphPosition, morphTargetsRelative, uv, uv2, a, b, c2);
            if (intersection) {
              intersection.faceIndex = Math.floor(i / 3);
              intersects2.push(intersection);
            }
          }
        }
      } else if (position2 !== void 0) {
        if (Array.isArray(material)) {
          for (let i = 0, il = groups.length; i < il; i++) {
            const group2 = groups[i];
            const groupMaterial = material[group2.materialIndex];
            const start2 = Math.max(group2.start, drawRange.start);
            const end2 = Math.min(position2.count, Math.min(group2.start + group2.count, drawRange.start + drawRange.count));
            for (let j = start2, jl = end2; j < jl; j += 3) {
              const a = j;
              const b = j + 1;
              const c2 = j + 2;
              intersection = checkBufferGeometryIntersection(this, groupMaterial, raycaster, _ray$2, position2, morphPosition, morphTargetsRelative, uv, uv2, a, b, c2);
              if (intersection) {
                intersection.faceIndex = Math.floor(j / 3);
                intersection.face.materialIndex = group2.materialIndex;
                intersects2.push(intersection);
              }
            }
          }
        } else {
          const start2 = Math.max(0, drawRange.start);
          const end2 = Math.min(position2.count, drawRange.start + drawRange.count);
          for (let i = start2, il = end2; i < il; i += 3) {
            const a = i;
            const b = i + 1;
            const c2 = i + 2;
            intersection = checkBufferGeometryIntersection(this, material, raycaster, _ray$2, position2, morphPosition, morphTargetsRelative, uv, uv2, a, b, c2);
            if (intersection) {
              intersection.faceIndex = Math.floor(i / 3);
              intersects2.push(intersection);
            }
          }
        }
      }
    } else if (geometry.isGeometry) {
      console.error("THREE.Mesh.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
    }
  }
}
Mesh.prototype.isMesh = true;
function checkIntersection(object, material, raycaster, ray, pA, pB, pC, point2) {
  let intersect;
  if (material.side === BackSide) {
    intersect = ray.intersectTriangle(pC, pB, pA, true, point2);
  } else {
    intersect = ray.intersectTriangle(pA, pB, pC, material.side !== DoubleSide, point2);
  }
  if (intersect === null)
    return null;
  _intersectionPointWorld.copy(point2);
  _intersectionPointWorld.applyMatrix4(object.matrixWorld);
  const distance2 = raycaster.ray.origin.distanceTo(_intersectionPointWorld);
  if (distance2 < raycaster.near || distance2 > raycaster.far)
    return null;
  return {
    distance: distance2,
    point: _intersectionPointWorld.clone(),
    object
  };
}
function checkBufferGeometryIntersection(object, material, raycaster, ray, position2, morphPosition, morphTargetsRelative, uv, uv2, a, b, c2) {
  _vA$1.fromBufferAttribute(position2, a);
  _vB$1.fromBufferAttribute(position2, b);
  _vC$1.fromBufferAttribute(position2, c2);
  const morphInfluences = object.morphTargetInfluences;
  if (morphPosition && morphInfluences) {
    _morphA.set(0, 0, 0);
    _morphB.set(0, 0, 0);
    _morphC.set(0, 0, 0);
    for (let i = 0, il = morphPosition.length; i < il; i++) {
      const influence = morphInfluences[i];
      const morphAttribute = morphPosition[i];
      if (influence === 0)
        continue;
      _tempA.fromBufferAttribute(morphAttribute, a);
      _tempB.fromBufferAttribute(morphAttribute, b);
      _tempC.fromBufferAttribute(morphAttribute, c2);
      if (morphTargetsRelative) {
        _morphA.addScaledVector(_tempA, influence);
        _morphB.addScaledVector(_tempB, influence);
        _morphC.addScaledVector(_tempC, influence);
      } else {
        _morphA.addScaledVector(_tempA.sub(_vA$1), influence);
        _morphB.addScaledVector(_tempB.sub(_vB$1), influence);
        _morphC.addScaledVector(_tempC.sub(_vC$1), influence);
      }
    }
    _vA$1.add(_morphA);
    _vB$1.add(_morphB);
    _vC$1.add(_morphC);
  }
  if (object.isSkinnedMesh) {
    object.boneTransform(a, _vA$1);
    object.boneTransform(b, _vB$1);
    object.boneTransform(c2, _vC$1);
  }
  const intersection = checkIntersection(object, material, raycaster, ray, _vA$1, _vB$1, _vC$1, _intersectionPoint);
  if (intersection) {
    if (uv) {
      _uvA$1.fromBufferAttribute(uv, a);
      _uvB$1.fromBufferAttribute(uv, b);
      _uvC$1.fromBufferAttribute(uv, c2);
      intersection.uv = Triangle.getUV(_intersectionPoint, _vA$1, _vB$1, _vC$1, _uvA$1, _uvB$1, _uvC$1, new Vector2());
    }
    if (uv2) {
      _uvA$1.fromBufferAttribute(uv2, a);
      _uvB$1.fromBufferAttribute(uv2, b);
      _uvC$1.fromBufferAttribute(uv2, c2);
      intersection.uv2 = Triangle.getUV(_intersectionPoint, _vA$1, _vB$1, _vC$1, _uvA$1, _uvB$1, _uvC$1, new Vector2());
    }
    const face2 = {
      a,
      b,
      c: c2,
      normal: new Vector3(),
      materialIndex: 0
    };
    Triangle.getNormal(_vA$1, _vB$1, _vC$1, face2.normal);
    intersection.face = face2;
  }
  return intersection;
}
class BoxGeometry extends BufferGeometry {
  constructor(width2 = 1, height2 = 1, depth = 1, widthSegments = 1, heightSegments = 1, depthSegments = 1) {
    super();
    this.type = "BoxGeometry";
    this.parameters = {
      width: width2,
      height: height2,
      depth,
      widthSegments,
      heightSegments,
      depthSegments
    };
    const scope = this;
    widthSegments = Math.floor(widthSegments);
    heightSegments = Math.floor(heightSegments);
    depthSegments = Math.floor(depthSegments);
    const indices = [];
    const vertices = [];
    const normals = [];
    const uvs = [];
    let numberOfVertices = 0;
    let groupStart = 0;
    buildPlane("z", "y", "x", -1, -1, depth, height2, width2, depthSegments, heightSegments, 0);
    buildPlane("z", "y", "x", 1, -1, depth, height2, -width2, depthSegments, heightSegments, 1);
    buildPlane("x", "z", "y", 1, 1, width2, depth, height2, widthSegments, depthSegments, 2);
    buildPlane("x", "z", "y", 1, -1, width2, depth, -height2, widthSegments, depthSegments, 3);
    buildPlane("x", "y", "z", 1, -1, width2, height2, depth, widthSegments, heightSegments, 4);
    buildPlane("x", "y", "z", -1, -1, width2, height2, -depth, widthSegments, heightSegments, 5);
    this.setIndex(indices);
    this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
    this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
    function buildPlane(u, v, w, udir, vdir, width3, height3, depth2, gridX, gridY, materialIndex) {
      const segmentWidth = width3 / gridX;
      const segmentHeight = height3 / gridY;
      const widthHalf = width3 / 2;
      const heightHalf = height3 / 2;
      const depthHalf = depth2 / 2;
      const gridX1 = gridX + 1;
      const gridY1 = gridY + 1;
      let vertexCounter = 0;
      let groupCount = 0;
      const vector = new Vector3();
      for (let iy = 0; iy < gridY1; iy++) {
        const y = iy * segmentHeight - heightHalf;
        for (let ix = 0; ix < gridX1; ix++) {
          const x = ix * segmentWidth - widthHalf;
          vector[u] = x * udir;
          vector[v] = y * vdir;
          vector[w] = depthHalf;
          vertices.push(vector.x, vector.y, vector.z);
          vector[u] = 0;
          vector[v] = 0;
          vector[w] = depth2 > 0 ? 1 : -1;
          normals.push(vector.x, vector.y, vector.z);
          uvs.push(ix / gridX);
          uvs.push(1 - iy / gridY);
          vertexCounter += 1;
        }
      }
      for (let iy = 0; iy < gridY; iy++) {
        for (let ix = 0; ix < gridX; ix++) {
          const a = numberOfVertices + ix + gridX1 * iy;
          const b = numberOfVertices + ix + gridX1 * (iy + 1);
          const c2 = numberOfVertices + (ix + 1) + gridX1 * (iy + 1);
          const d = numberOfVertices + (ix + 1) + gridX1 * iy;
          indices.push(a, b, d);
          indices.push(b, c2, d);
          groupCount += 6;
        }
      }
      scope.addGroup(groupStart, groupCount, materialIndex);
      groupStart += groupCount;
      numberOfVertices += vertexCounter;
    }
  }
  static fromJSON(data) {
    return new BoxGeometry(data.width, data.height, data.depth, data.widthSegments, data.heightSegments, data.depthSegments);
  }
}
function cloneUniforms(src) {
  const dst = {};
  for (const u in src) {
    dst[u] = {};
    for (const p in src[u]) {
      const property = src[u][p];
      if (property && (property.isColor || property.isMatrix3 || property.isMatrix4 || property.isVector2 || property.isVector3 || property.isVector4 || property.isTexture || property.isQuaternion)) {
        dst[u][p] = property.clone();
      } else if (Array.isArray(property)) {
        dst[u][p] = property.slice();
      } else {
        dst[u][p] = property;
      }
    }
  }
  return dst;
}
function mergeUniforms(uniforms) {
  const merged = {};
  for (let u = 0; u < uniforms.length; u++) {
    const tmp2 = cloneUniforms(uniforms[u]);
    for (const p in tmp2) {
      merged[p] = tmp2[p];
    }
  }
  return merged;
}
const UniformsUtils = { clone: cloneUniforms, merge: mergeUniforms };
var default_vertex = "void main() {\n	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}";
var default_fragment = "void main() {\n	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}";
class ShaderMaterial extends Material {
  constructor(parameters) {
    super();
    this.type = "ShaderMaterial";
    this.defines = {};
    this.uniforms = {};
    this.vertexShader = default_vertex;
    this.fragmentShader = default_fragment;
    this.linewidth = 1;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.fog = false;
    this.lights = false;
    this.clipping = false;
    this.extensions = {
      derivatives: false,
      fragDepth: false,
      drawBuffers: false,
      shaderTextureLOD: false
    };
    this.defaultAttributeValues = {
      "color": [1, 1, 1],
      "uv": [0, 0],
      "uv2": [0, 0]
    };
    this.index0AttributeName = void 0;
    this.uniformsNeedUpdate = false;
    this.glslVersion = null;
    if (parameters !== void 0) {
      if (parameters.attributes !== void 0) {
        console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.");
      }
      this.setValues(parameters);
    }
  }
  copy(source2) {
    super.copy(source2);
    this.fragmentShader = source2.fragmentShader;
    this.vertexShader = source2.vertexShader;
    this.uniforms = cloneUniforms(source2.uniforms);
    this.defines = Object.assign({}, source2.defines);
    this.wireframe = source2.wireframe;
    this.wireframeLinewidth = source2.wireframeLinewidth;
    this.lights = source2.lights;
    this.clipping = source2.clipping;
    this.extensions = Object.assign({}, source2.extensions);
    this.glslVersion = source2.glslVersion;
    return this;
  }
  toJSON(meta) {
    const data = super.toJSON(meta);
    data.glslVersion = this.glslVersion;
    data.uniforms = {};
    for (const name in this.uniforms) {
      const uniform = this.uniforms[name];
      const value = uniform.value;
      if (value && value.isTexture) {
        data.uniforms[name] = {
          type: "t",
          value: value.toJSON(meta).uuid
        };
      } else if (value && value.isColor) {
        data.uniforms[name] = {
          type: "c",
          value: value.getHex()
        };
      } else if (value && value.isVector2) {
        data.uniforms[name] = {
          type: "v2",
          value: value.toArray()
        };
      } else if (value && value.isVector3) {
        data.uniforms[name] = {
          type: "v3",
          value: value.toArray()
        };
      } else if (value && value.isVector4) {
        data.uniforms[name] = {
          type: "v4",
          value: value.toArray()
        };
      } else if (value && value.isMatrix3) {
        data.uniforms[name] = {
          type: "m3",
          value: value.toArray()
        };
      } else if (value && value.isMatrix4) {
        data.uniforms[name] = {
          type: "m4",
          value: value.toArray()
        };
      } else {
        data.uniforms[name] = {
          value
        };
      }
    }
    if (Object.keys(this.defines).length > 0)
      data.defines = this.defines;
    data.vertexShader = this.vertexShader;
    data.fragmentShader = this.fragmentShader;
    const extensions = {};
    for (const key in this.extensions) {
      if (this.extensions[key] === true)
        extensions[key] = true;
    }
    if (Object.keys(extensions).length > 0)
      data.extensions = extensions;
    return data;
  }
}
ShaderMaterial.prototype.isShaderMaterial = true;
class Camera extends Object3D {
  constructor() {
    super();
    this.type = "Camera";
    this.matrixWorldInverse = new Matrix4();
    this.projectionMatrix = new Matrix4();
    this.projectionMatrixInverse = new Matrix4();
  }
  copy(source2, recursive) {
    super.copy(source2, recursive);
    this.matrixWorldInverse.copy(source2.matrixWorldInverse);
    this.projectionMatrix.copy(source2.projectionMatrix);
    this.projectionMatrixInverse.copy(source2.projectionMatrixInverse);
    return this;
  }
  getWorldDirection(target) {
    this.updateWorldMatrix(true, false);
    const e = this.matrixWorld.elements;
    return target.set(-e[8], -e[9], -e[10]).normalize();
  }
  updateMatrixWorld(force) {
    super.updateMatrixWorld(force);
    this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  updateWorldMatrix(updateParents, updateChildren) {
    super.updateWorldMatrix(updateParents, updateChildren);
    this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
Camera.prototype.isCamera = true;
class PerspectiveCamera extends Camera {
  constructor(fov2 = 50, aspect2 = 1, near = 0.1, far = 2e3) {
    super();
    this.type = "PerspectiveCamera";
    this.fov = fov2;
    this.zoom = 1;
    this.near = near;
    this.far = far;
    this.focus = 10;
    this.aspect = aspect2;
    this.view = null;
    this.filmGauge = 35;
    this.filmOffset = 0;
    this.updateProjectionMatrix();
  }
  copy(source2, recursive) {
    super.copy(source2, recursive);
    this.fov = source2.fov;
    this.zoom = source2.zoom;
    this.near = source2.near;
    this.far = source2.far;
    this.focus = source2.focus;
    this.aspect = source2.aspect;
    this.view = source2.view === null ? null : Object.assign({}, source2.view);
    this.filmGauge = source2.filmGauge;
    this.filmOffset = source2.filmOffset;
    return this;
  }
  setFocalLength(focalLength) {
    const vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;
    this.fov = RAD2DEG * 2 * Math.atan(vExtentSlope);
    this.updateProjectionMatrix();
  }
  getFocalLength() {
    const vExtentSlope = Math.tan(DEG2RAD * 0.5 * this.fov);
    return 0.5 * this.getFilmHeight() / vExtentSlope;
  }
  getEffectiveFOV() {
    return RAD2DEG * 2 * Math.atan(Math.tan(DEG2RAD * 0.5 * this.fov) / this.zoom);
  }
  getFilmWidth() {
    return this.filmGauge * Math.min(this.aspect, 1);
  }
  getFilmHeight() {
    return this.filmGauge / Math.max(this.aspect, 1);
  }
  setViewOffset(fullWidth, fullHeight, x, y, width2, height2) {
    this.aspect = fullWidth / fullHeight;
    if (this.view === null) {
      this.view = {
        enabled: true,
        fullWidth: 1,
        fullHeight: 1,
        offsetX: 0,
        offsetY: 0,
        width: 1,
        height: 1
      };
    }
    this.view.enabled = true;
    this.view.fullWidth = fullWidth;
    this.view.fullHeight = fullHeight;
    this.view.offsetX = x;
    this.view.offsetY = y;
    this.view.width = width2;
    this.view.height = height2;
    this.updateProjectionMatrix();
  }
  clearViewOffset() {
    if (this.view !== null) {
      this.view.enabled = false;
    }
    this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    const near = this.near;
    let top2 = near * Math.tan(DEG2RAD * 0.5 * this.fov) / this.zoom;
    let height2 = 2 * top2;
    let width2 = this.aspect * height2;
    let left2 = -0.5 * width2;
    const view = this.view;
    if (this.view !== null && this.view.enabled) {
      const fullWidth = view.fullWidth, fullHeight = view.fullHeight;
      left2 += view.offsetX * width2 / fullWidth;
      top2 -= view.offsetY * height2 / fullHeight;
      width2 *= view.width / fullWidth;
      height2 *= view.height / fullHeight;
    }
    const skew = this.filmOffset;
    if (skew !== 0)
      left2 += near * skew / this.getFilmWidth();
    this.projectionMatrix.makePerspective(left2, left2 + width2, top2, top2 - height2, near, this.far);
    this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(meta) {
    const data = super.toJSON(meta);
    data.object.fov = this.fov;
    data.object.zoom = this.zoom;
    data.object.near = this.near;
    data.object.far = this.far;
    data.object.focus = this.focus;
    data.object.aspect = this.aspect;
    if (this.view !== null)
      data.object.view = Object.assign({}, this.view);
    data.object.filmGauge = this.filmGauge;
    data.object.filmOffset = this.filmOffset;
    return data;
  }
}
PerspectiveCamera.prototype.isPerspectiveCamera = true;
const fov = 90, aspect = 1;
class CubeCamera extends Object3D {
  constructor(near, far, renderTarget) {
    super();
    this.type = "CubeCamera";
    if (renderTarget.isWebGLCubeRenderTarget !== true) {
      console.error("THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.");
      return;
    }
    this.renderTarget = renderTarget;
    const cameraPX = new PerspectiveCamera(fov, aspect, near, far);
    cameraPX.layers = this.layers;
    cameraPX.up.set(0, -1, 0);
    cameraPX.lookAt(new Vector3(1, 0, 0));
    this.add(cameraPX);
    const cameraNX = new PerspectiveCamera(fov, aspect, near, far);
    cameraNX.layers = this.layers;
    cameraNX.up.set(0, -1, 0);
    cameraNX.lookAt(new Vector3(-1, 0, 0));
    this.add(cameraNX);
    const cameraPY = new PerspectiveCamera(fov, aspect, near, far);
    cameraPY.layers = this.layers;
    cameraPY.up.set(0, 0, 1);
    cameraPY.lookAt(new Vector3(0, 1, 0));
    this.add(cameraPY);
    const cameraNY = new PerspectiveCamera(fov, aspect, near, far);
    cameraNY.layers = this.layers;
    cameraNY.up.set(0, 0, -1);
    cameraNY.lookAt(new Vector3(0, -1, 0));
    this.add(cameraNY);
    const cameraPZ = new PerspectiveCamera(fov, aspect, near, far);
    cameraPZ.layers = this.layers;
    cameraPZ.up.set(0, -1, 0);
    cameraPZ.lookAt(new Vector3(0, 0, 1));
    this.add(cameraPZ);
    const cameraNZ = new PerspectiveCamera(fov, aspect, near, far);
    cameraNZ.layers = this.layers;
    cameraNZ.up.set(0, -1, 0);
    cameraNZ.lookAt(new Vector3(0, 0, -1));
    this.add(cameraNZ);
  }
  update(renderer, scene) {
    if (this.parent === null)
      this.updateMatrixWorld();
    const renderTarget = this.renderTarget;
    const [cameraPX, cameraNX, cameraPY, cameraNY, cameraPZ, cameraNZ] = this.children;
    const currentRenderTarget = renderer.getRenderTarget();
    const currentOutputEncoding = renderer.outputEncoding;
    const currentToneMapping = renderer.toneMapping;
    const currentXrEnabled = renderer.xr.enabled;
    renderer.outputEncoding = LinearEncoding;
    renderer.toneMapping = NoToneMapping;
    renderer.xr.enabled = false;
    const generateMipmaps = renderTarget.texture.generateMipmaps;
    renderTarget.texture.generateMipmaps = false;
    renderer.setRenderTarget(renderTarget, 0);
    renderer.render(scene, cameraPX);
    renderer.setRenderTarget(renderTarget, 1);
    renderer.render(scene, cameraNX);
    renderer.setRenderTarget(renderTarget, 2);
    renderer.render(scene, cameraPY);
    renderer.setRenderTarget(renderTarget, 3);
    renderer.render(scene, cameraNY);
    renderer.setRenderTarget(renderTarget, 4);
    renderer.render(scene, cameraPZ);
    renderTarget.texture.generateMipmaps = generateMipmaps;
    renderer.setRenderTarget(renderTarget, 5);
    renderer.render(scene, cameraNZ);
    renderer.setRenderTarget(currentRenderTarget);
    renderer.outputEncoding = currentOutputEncoding;
    renderer.toneMapping = currentToneMapping;
    renderer.xr.enabled = currentXrEnabled;
    renderTarget.texture.needsPMREMUpdate = true;
  }
}
class CubeTexture extends Texture {
  constructor(images, mapping, wrapS, wrapT, magFilter, minFilter, format2, type, anisotropy, encoding) {
    images = images !== void 0 ? images : [];
    mapping = mapping !== void 0 ? mapping : CubeReflectionMapping;
    super(images, mapping, wrapS, wrapT, magFilter, minFilter, format2, type, anisotropy, encoding);
    this.flipY = false;
  }
  get images() {
    return this.image;
  }
  set images(value) {
    this.image = value;
  }
}
CubeTexture.prototype.isCubeTexture = true;
class WebGLCubeRenderTarget extends WebGLRenderTarget {
  constructor(size2, options2 = {}) {
    super(size2, size2, options2);
    const image2 = { width: size2, height: size2, depth: 1 };
    const images = [image2, image2, image2, image2, image2, image2];
    this.texture = new CubeTexture(images, options2.mapping, options2.wrapS, options2.wrapT, options2.magFilter, options2.minFilter, options2.format, options2.type, options2.anisotropy, options2.encoding);
    this.texture.isRenderTargetTexture = true;
    this.texture.generateMipmaps = options2.generateMipmaps !== void 0 ? options2.generateMipmaps : false;
    this.texture.minFilter = options2.minFilter !== void 0 ? options2.minFilter : LinearFilter;
  }
  fromEquirectangularTexture(renderer, texture2) {
    this.texture.type = texture2.type;
    this.texture.encoding = texture2.encoding;
    this.texture.generateMipmaps = texture2.generateMipmaps;
    this.texture.minFilter = texture2.minFilter;
    this.texture.magFilter = texture2.magFilter;
    const shader = {
      uniforms: {
        tEquirect: { value: null }
      },
      vertexShader: `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,
      fragmentShader: `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`
    };
    const geometry = new BoxGeometry(5, 5, 5);
    const material = new ShaderMaterial({
      name: "CubemapFromEquirect",
      uniforms: cloneUniforms(shader.uniforms),
      vertexShader: shader.vertexShader,
      fragmentShader: shader.fragmentShader,
      side: BackSide,
      blending: NoBlending
    });
    material.uniforms.tEquirect.value = texture2;
    const mesh = new Mesh(geometry, material);
    const currentMinFilter = texture2.minFilter;
    if (texture2.minFilter === LinearMipmapLinearFilter)
      texture2.minFilter = LinearFilter;
    const camera = new CubeCamera(1, 10, this);
    camera.update(renderer, mesh);
    texture2.minFilter = currentMinFilter;
    mesh.geometry.dispose();
    mesh.material.dispose();
    return this;
  }
  clear(renderer, color2, depth, stencil) {
    const currentRenderTarget = renderer.getRenderTarget();
    for (let i = 0; i < 6; i++) {
      renderer.setRenderTarget(this, i);
      renderer.clear(color2, depth, stencil);
    }
    renderer.setRenderTarget(currentRenderTarget);
  }
}
WebGLCubeRenderTarget.prototype.isWebGLCubeRenderTarget = true;
const _vector1 = /* @__PURE__ */ new Vector3();
const _vector2 = /* @__PURE__ */ new Vector3();
const _normalMatrix = /* @__PURE__ */ new Matrix3();
class Plane {
  constructor(normal = new Vector3(1, 0, 0), constant = 0) {
    this.normal = normal;
    this.constant = constant;
  }
  set(normal, constant) {
    this.normal.copy(normal);
    this.constant = constant;
    return this;
  }
  setComponents(x, y, z, w) {
    this.normal.set(x, y, z);
    this.constant = w;
    return this;
  }
  setFromNormalAndCoplanarPoint(normal, point2) {
    this.normal.copy(normal);
    this.constant = -point2.dot(this.normal);
    return this;
  }
  setFromCoplanarPoints(a, b, c2) {
    const normal = _vector1.subVectors(c2, b).cross(_vector2.subVectors(a, b)).normalize();
    this.setFromNormalAndCoplanarPoint(normal, a);
    return this;
  }
  copy(plane) {
    this.normal.copy(plane.normal);
    this.constant = plane.constant;
    return this;
  }
  normalize() {
    const inverseNormalLength = 1 / this.normal.length();
    this.normal.multiplyScalar(inverseNormalLength);
    this.constant *= inverseNormalLength;
    return this;
  }
  negate() {
    this.constant *= -1;
    this.normal.negate();
    return this;
  }
  distanceToPoint(point2) {
    return this.normal.dot(point2) + this.constant;
  }
  distanceToSphere(sphere) {
    return this.distanceToPoint(sphere.center) - sphere.radius;
  }
  projectPoint(point2, target) {
    return target.copy(this.normal).multiplyScalar(-this.distanceToPoint(point2)).add(point2);
  }
  intersectLine(line2, target) {
    const direction2 = line2.delta(_vector1);
    const denominator = this.normal.dot(direction2);
    if (denominator === 0) {
      if (this.distanceToPoint(line2.start) === 0) {
        return target.copy(line2.start);
      }
      return null;
    }
    const t = -(line2.start.dot(this.normal) + this.constant) / denominator;
    if (t < 0 || t > 1) {
      return null;
    }
    return target.copy(direction2).multiplyScalar(t).add(line2.start);
  }
  intersectsLine(line2) {
    const startSign = this.distanceToPoint(line2.start);
    const endSign = this.distanceToPoint(line2.end);
    return startSign < 0 && endSign > 0 || endSign < 0 && startSign > 0;
  }
  intersectsBox(box) {
    return box.intersectsPlane(this);
  }
  intersectsSphere(sphere) {
    return sphere.intersectsPlane(this);
  }
  coplanarPoint(target) {
    return target.copy(this.normal).multiplyScalar(-this.constant);
  }
  applyMatrix4(matrix, optionalNormalMatrix) {
    const normalMatrix = optionalNormalMatrix || _normalMatrix.getNormalMatrix(matrix);
    const referencePoint = this.coplanarPoint(_vector1).applyMatrix4(matrix);
    const normal = this.normal.applyMatrix3(normalMatrix).normalize();
    this.constant = -referencePoint.dot(normal);
    return this;
  }
  translate(offset) {
    this.constant -= offset.dot(this.normal);
    return this;
  }
  equals(plane) {
    return plane.normal.equals(this.normal) && plane.constant === this.constant;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
Plane.prototype.isPlane = true;
const _sphere$2 = /* @__PURE__ */ new Sphere();
const _vector$7 = /* @__PURE__ */ new Vector3();
class Frustum {
  constructor(p0 = new Plane(), p1 = new Plane(), p2 = new Plane(), p3 = new Plane(), p4 = new Plane(), p5 = new Plane()) {
    this.planes = [p0, p1, p2, p3, p4, p5];
  }
  set(p0, p1, p2, p3, p4, p5) {
    const planes = this.planes;
    planes[0].copy(p0);
    planes[1].copy(p1);
    planes[2].copy(p2);
    planes[3].copy(p3);
    planes[4].copy(p4);
    planes[5].copy(p5);
    return this;
  }
  copy(frustum) {
    const planes = this.planes;
    for (let i = 0; i < 6; i++) {
      planes[i].copy(frustum.planes[i]);
    }
    return this;
  }
  setFromProjectionMatrix(m) {
    const planes = this.planes;
    const me = m.elements;
    const me0 = me[0], me1 = me[1], me2 = me[2], me3 = me[3];
    const me4 = me[4], me5 = me[5], me6 = me[6], me7 = me[7];
    const me8 = me[8], me9 = me[9], me10 = me[10], me11 = me[11];
    const me12 = me[12], me13 = me[13], me14 = me[14], me15 = me[15];
    planes[0].setComponents(me3 - me0, me7 - me4, me11 - me8, me15 - me12).normalize();
    planes[1].setComponents(me3 + me0, me7 + me4, me11 + me8, me15 + me12).normalize();
    planes[2].setComponents(me3 + me1, me7 + me5, me11 + me9, me15 + me13).normalize();
    planes[3].setComponents(me3 - me1, me7 - me5, me11 - me9, me15 - me13).normalize();
    planes[4].setComponents(me3 - me2, me7 - me6, me11 - me10, me15 - me14).normalize();
    planes[5].setComponents(me3 + me2, me7 + me6, me11 + me10, me15 + me14).normalize();
    return this;
  }
  intersectsObject(object) {
    const geometry = object.geometry;
    if (geometry.boundingSphere === null)
      geometry.computeBoundingSphere();
    _sphere$2.copy(geometry.boundingSphere).applyMatrix4(object.matrixWorld);
    return this.intersectsSphere(_sphere$2);
  }
  intersectsSprite(sprite) {
    _sphere$2.center.set(0, 0, 0);
    _sphere$2.radius = 0.7071067811865476;
    _sphere$2.applyMatrix4(sprite.matrixWorld);
    return this.intersectsSphere(_sphere$2);
  }
  intersectsSphere(sphere) {
    const planes = this.planes;
    const center2 = sphere.center;
    const negRadius = -sphere.radius;
    for (let i = 0; i < 6; i++) {
      const distance2 = planes[i].distanceToPoint(center2);
      if (distance2 < negRadius) {
        return false;
      }
    }
    return true;
  }
  intersectsBox(box) {
    const planes = this.planes;
    for (let i = 0; i < 6; i++) {
      const plane = planes[i];
      _vector$7.x = plane.normal.x > 0 ? box.max.x : box.min.x;
      _vector$7.y = plane.normal.y > 0 ? box.max.y : box.min.y;
      _vector$7.z = plane.normal.z > 0 ? box.max.z : box.min.z;
      if (plane.distanceToPoint(_vector$7) < 0) {
        return false;
      }
    }
    return true;
  }
  containsPoint(point2) {
    const planes = this.planes;
    for (let i = 0; i < 6; i++) {
      if (planes[i].distanceToPoint(point2) < 0) {
        return false;
      }
    }
    return true;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
function WebGLAnimation() {
  let context = null;
  let isAnimating = false;
  let animationLoop = null;
  let requestId = null;
  function onAnimationFrame(time, frame) {
    animationLoop(time, frame);
    requestId = context.requestAnimationFrame(onAnimationFrame);
  }
  return {
    start: function() {
      if (isAnimating === true)
        return;
      if (animationLoop === null)
        return;
      requestId = context.requestAnimationFrame(onAnimationFrame);
      isAnimating = true;
    },
    stop: function() {
      context.cancelAnimationFrame(requestId);
      isAnimating = false;
    },
    setAnimationLoop: function(callback) {
      animationLoop = callback;
    },
    setContext: function(value) {
      context = value;
    }
  };
}
function WebGLAttributes(gl, capabilities) {
  const isWebGL2 = capabilities.isWebGL2;
  const buffers = /* @__PURE__ */ new WeakMap();
  function createBuffer(attribute, bufferType) {
    const array = attribute.array;
    const usage = attribute.usage;
    const buffer = gl.createBuffer();
    gl.bindBuffer(bufferType, buffer);
    gl.bufferData(bufferType, array, usage);
    attribute.onUploadCallback();
    let type;
    if (array instanceof Float32Array) {
      type = 5126;
    } else if (array instanceof Uint16Array) {
      if (attribute.isFloat16BufferAttribute) {
        if (isWebGL2) {
          type = 5131;
        } else {
          throw new Error("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.");
        }
      } else {
        type = 5123;
      }
    } else if (array instanceof Int16Array) {
      type = 5122;
    } else if (array instanceof Uint32Array) {
      type = 5125;
    } else if (array instanceof Int32Array) {
      type = 5124;
    } else if (array instanceof Int8Array) {
      type = 5120;
    } else if (array instanceof Uint8Array) {
      type = 5121;
    } else if (array instanceof Uint8ClampedArray) {
      type = 5121;
    } else {
      throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: " + array);
    }
    return {
      buffer,
      type,
      bytesPerElement: array.BYTES_PER_ELEMENT,
      version: attribute.version
    };
  }
  function updateBuffer(buffer, attribute, bufferType) {
    const array = attribute.array;
    const updateRange = attribute.updateRange;
    gl.bindBuffer(bufferType, buffer);
    if (updateRange.count === -1) {
      gl.bufferSubData(bufferType, 0, array);
    } else {
      if (isWebGL2) {
        gl.bufferSubData(bufferType, updateRange.offset * array.BYTES_PER_ELEMENT, array, updateRange.offset, updateRange.count);
      } else {
        gl.bufferSubData(bufferType, updateRange.offset * array.BYTES_PER_ELEMENT, array.subarray(updateRange.offset, updateRange.offset + updateRange.count));
      }
      updateRange.count = -1;
    }
  }
  function get2(attribute) {
    if (attribute.isInterleavedBufferAttribute)
      attribute = attribute.data;
    return buffers.get(attribute);
  }
  function remove3(attribute) {
    if (attribute.isInterleavedBufferAttribute)
      attribute = attribute.data;
    const data = buffers.get(attribute);
    if (data) {
      gl.deleteBuffer(data.buffer);
      buffers.delete(attribute);
    }
  }
  function update2(attribute, bufferType) {
    if (attribute.isGLBufferAttribute) {
      const cached = buffers.get(attribute);
      if (!cached || cached.version < attribute.version) {
        buffers.set(attribute, {
          buffer: attribute.buffer,
          type: attribute.type,
          bytesPerElement: attribute.elementSize,
          version: attribute.version
        });
      }
      return;
    }
    if (attribute.isInterleavedBufferAttribute)
      attribute = attribute.data;
    const data = buffers.get(attribute);
    if (data === void 0) {
      buffers.set(attribute, createBuffer(attribute, bufferType));
    } else if (data.version < attribute.version) {
      updateBuffer(data.buffer, attribute, bufferType);
      data.version = attribute.version;
    }
  }
  return {
    get: get2,
    remove: remove3,
    update: update2
  };
}
class PlaneGeometry extends BufferGeometry {
  constructor(width2 = 1, height2 = 1, widthSegments = 1, heightSegments = 1) {
    super();
    this.type = "PlaneGeometry";
    this.parameters = {
      width: width2,
      height: height2,
      widthSegments,
      heightSegments
    };
    const width_half = width2 / 2;
    const height_half = height2 / 2;
    const gridX = Math.floor(widthSegments);
    const gridY = Math.floor(heightSegments);
    const gridX1 = gridX + 1;
    const gridY1 = gridY + 1;
    const segment_width = width2 / gridX;
    const segment_height = height2 / gridY;
    const indices = [];
    const vertices = [];
    const normals = [];
    const uvs = [];
    for (let iy = 0; iy < gridY1; iy++) {
      const y = iy * segment_height - height_half;
      for (let ix = 0; ix < gridX1; ix++) {
        const x = ix * segment_width - width_half;
        vertices.push(x, -y, 0);
        normals.push(0, 0, 1);
        uvs.push(ix / gridX);
        uvs.push(1 - iy / gridY);
      }
    }
    for (let iy = 0; iy < gridY; iy++) {
      for (let ix = 0; ix < gridX; ix++) {
        const a = ix + gridX1 * iy;
        const b = ix + gridX1 * (iy + 1);
        const c2 = ix + 1 + gridX1 * (iy + 1);
        const d = ix + 1 + gridX1 * iy;
        indices.push(a, b, d);
        indices.push(b, c2, d);
      }
    }
    this.setIndex(indices);
    this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
    this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
  }
  static fromJSON(data) {
    return new PlaneGeometry(data.width, data.height, data.widthSegments, data.heightSegments);
  }
}
var alphamap_fragment = "#ifdef USE_ALPHAMAP\n	diffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif";
var alphamap_pars_fragment = "#ifdef USE_ALPHAMAP\n	uniform sampler2D alphaMap;\n#endif";
var alphatest_fragment = "#ifdef USE_ALPHATEST\n	if ( diffuseColor.a < alphaTest ) discard;\n#endif";
var alphatest_pars_fragment = "#ifdef USE_ALPHATEST\n	uniform float alphaTest;\n#endif";
var aomap_fragment = "#ifdef USE_AOMAP\n	float ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n	reflectedLight.indirectDiffuse *= ambientOcclusion;\n	#if defined( USE_ENVMAP ) && defined( STANDARD )\n		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n	#endif\n#endif";
var aomap_pars_fragment = "#ifdef USE_AOMAP\n	uniform sampler2D aoMap;\n	uniform float aoMapIntensity;\n#endif";
var begin_vertex = "vec3 transformed = vec3( position );";
var beginnormal_vertex = "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n	vec3 objectTangent = vec3( tangent.xyz );\n#endif";
var bsdfs = "vec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n	return RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n	float a2 = pow2( alpha );\n	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n	return 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n	float a2 = pow2( alpha );\n	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n	return RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float roughness ) {\n	float alpha = pow2( roughness );\n	vec3 halfDir = normalize( lightDir + viewDir );\n	float dotNL = saturate( dot( normal, lightDir ) );\n	float dotNV = saturate( dot( normal, viewDir ) );\n	float dotNH = saturate( dot( normal, halfDir ) );\n	float dotVH = saturate( dot( viewDir, halfDir ) );\n	vec3 F = F_Schlick( f0, f90, dotVH );\n	float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n	float D = D_GGX( alpha, dotNH );\n	return F * ( V * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n	const float LUT_SIZE = 64.0;\n	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n	const float LUT_BIAS = 0.5 / LUT_SIZE;\n	float dotNV = saturate( dot( N, V ) );\n	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n	uv = uv * LUT_SCALE + LUT_BIAS;\n	return uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n	float l = length( f );\n	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n	float x = dot( v1, v2 );\n	float y = abs( x );\n	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n	float b = 3.4175940 + ( 4.1616724 + y ) * y;\n	float v = a / b;\n	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n	return cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n	vec3 lightNormal = cross( v1, v2 );\n	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n	vec3 T1, T2;\n	T1 = normalize( V - N * dot( V, N ) );\n	T2 = - cross( N, T1 );\n	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n	vec3 coords[ 4 ];\n	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n	coords[ 0 ] = normalize( coords[ 0 ] );\n	coords[ 1 ] = normalize( coords[ 1 ] );\n	coords[ 2 ] = normalize( coords[ 2 ] );\n	coords[ 3 ] = normalize( coords[ 3 ] );\n	vec3 vectorFormFactor = vec3( 0.0 );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n	return vec3( result );\n}\nfloat G_BlinnPhong_Implicit( ) {\n	return 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {\n	vec3 halfDir = normalize( lightDir + viewDir );\n	float dotNH = saturate( dot( normal, halfDir ) );\n	float dotVH = saturate( dot( viewDir, halfDir ) );\n	vec3 F = F_Schlick( specularColor, 1.0, dotVH );\n	float G = G_BlinnPhong_Implicit( );\n	float D = D_BlinnPhong( shininess, dotNH );\n	return F * ( G * D );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie( float roughness, float dotNH ) {\n	float alpha = pow2( roughness );\n	float invAlpha = 1.0 / alpha;\n	float cos2h = dotNH * dotNH;\n	float sin2h = max( 1.0 - cos2h, 0.0078125 );\n	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n}\nfloat V_Neubelt( float dotNV, float dotNL ) {\n	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\n}\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {\n	vec3 halfDir = normalize( lightDir + viewDir );\n	float dotNL = saturate( dot( normal, lightDir ) );\n	float dotNV = saturate( dot( normal, viewDir ) );\n	float dotNH = saturate( dot( normal, halfDir ) );\n	float D = D_Charlie( sheenRoughness, dotNH );\n	float V = V_Neubelt( dotNV, dotNL );\n	return sheenColor * ( D * V );\n}\n#endif";
var bumpmap_pars_fragment = "#ifdef USE_BUMPMAP\n	uniform sampler2D bumpMap;\n	uniform float bumpScale;\n	vec2 dHdxy_fwd() {\n		vec2 dSTdx = dFdx( vUv );\n		vec2 dSTdy = dFdy( vUv );\n		float Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n		float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n		float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n		return vec2( dBx, dBy );\n	}\n	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n		vec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n		vec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n		vec3 vN = surf_norm;\n		vec3 R1 = cross( vSigmaY, vN );\n		vec3 R2 = cross( vN, vSigmaX );\n		float fDet = dot( vSigmaX, R1 ) * faceDirection;\n		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n		return normalize( abs( fDet ) * surf_norm - vGrad );\n	}\n#endif";
var clipping_planes_fragment = "#if NUM_CLIPPING_PLANES > 0\n	vec4 plane;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n		plane = clippingPlanes[ i ];\n		if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n	}\n	#pragma unroll_loop_end\n	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n		bool clipped = true;\n		#pragma unroll_loop_start\n		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n			plane = clippingPlanes[ i ];\n			clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n		}\n		#pragma unroll_loop_end\n		if ( clipped ) discard;\n	#endif\n#endif";
var clipping_planes_pars_fragment = "#if NUM_CLIPPING_PLANES > 0\n	varying vec3 vClipPosition;\n	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif";
var clipping_planes_pars_vertex = "#if NUM_CLIPPING_PLANES > 0\n	varying vec3 vClipPosition;\n#endif";
var clipping_planes_vertex = "#if NUM_CLIPPING_PLANES > 0\n	vClipPosition = - mvPosition.xyz;\n#endif";
var color_fragment = "#if defined( USE_COLOR_ALPHA )\n	diffuseColor *= vColor;\n#elif defined( USE_COLOR )\n	diffuseColor.rgb *= vColor;\n#endif";
var color_pars_fragment = "#if defined( USE_COLOR_ALPHA )\n	varying vec4 vColor;\n#elif defined( USE_COLOR )\n	varying vec3 vColor;\n#endif";
var color_pars_vertex = "#if defined( USE_COLOR_ALPHA )\n	varying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n	varying vec3 vColor;\n#endif";
var color_vertex = "#if defined( USE_COLOR_ALPHA )\n	vColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n	vColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n	vColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n	vColor.xyz *= instanceColor.xyz;\n#endif";
var common = "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n	const highp float a = 12.9898, b = 78.233, c = 43758.5453;\n	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n	return fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n	float precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n	float precisionSafeLength( vec3 v ) {\n		float maxComponent = max3( abs( v ) );\n		return length( v / maxComponent ) * maxComponent;\n	}\n#endif\nstruct IncidentLight {\n	vec3 color;\n	vec3 direction;\n	bool visible;\n};\nstruct ReflectedLight {\n	vec3 directDiffuse;\n	vec3 directSpecular;\n	vec3 indirectDiffuse;\n	vec3 indirectSpecular;\n};\nstruct GeometricContext {\n	vec3 position;\n	vec3 normal;\n	vec3 viewDir;\n#ifdef USE_CLEARCOAT\n	vec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n	mat3 tmp;\n	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n	return tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n	vec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n	return dot( weights, color.rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n	return m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n	return vec2( u, v );\n}";
var cube_uv_reflection_fragment = "#ifdef ENVMAP_TYPE_CUBE_UV\n	#define cubeUV_minMipLevel 4.0\n	#define cubeUV_minTileSize 16.0\n	float getFace( vec3 direction ) {\n		vec3 absDirection = abs( direction );\n		float face = - 1.0;\n		if ( absDirection.x > absDirection.z ) {\n			if ( absDirection.x > absDirection.y )\n				face = direction.x > 0.0 ? 0.0 : 3.0;\n			else\n				face = direction.y > 0.0 ? 1.0 : 4.0;\n		} else {\n			if ( absDirection.z > absDirection.y )\n				face = direction.z > 0.0 ? 2.0 : 5.0;\n			else\n				face = direction.y > 0.0 ? 1.0 : 4.0;\n		}\n		return face;\n	}\n	vec2 getUV( vec3 direction, float face ) {\n		vec2 uv;\n		if ( face == 0.0 ) {\n			uv = vec2( direction.z, direction.y ) / abs( direction.x );\n		} else if ( face == 1.0 ) {\n			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n		} else if ( face == 2.0 ) {\n			uv = vec2( - direction.x, direction.y ) / abs( direction.z );\n		} else if ( face == 3.0 ) {\n			uv = vec2( - direction.z, direction.y ) / abs( direction.x );\n		} else if ( face == 4.0 ) {\n			uv = vec2( - direction.x, direction.z ) / abs( direction.y );\n		} else {\n			uv = vec2( direction.x, direction.y ) / abs( direction.z );\n		}\n		return 0.5 * ( uv + 1.0 );\n	}\n	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n		float face = getFace( direction );\n		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n		mipInt = max( mipInt, cubeUV_minMipLevel );\n		float faceSize = exp2( mipInt );\n		vec2 uv = getUV( direction, face ) * ( faceSize - 1.0 ) + 0.5;\n		if ( face > 2.0 ) {\n			uv.y += faceSize;\n			face -= 3.0;\n		}\n		uv.x += face * faceSize;\n		uv.x += filterInt * 3.0 * cubeUV_minTileSize;\n		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );\n		uv.x *= CUBEUV_TEXEL_WIDTH;\n		uv.y *= CUBEUV_TEXEL_HEIGHT;\n		#ifdef texture2DGradEXT\n			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;\n		#else\n			return texture2D( envMap, uv ).rgb;\n		#endif\n	}\n	#define r0 1.0\n	#define v0 0.339\n	#define m0 - 2.0\n	#define r1 0.8\n	#define v1 0.276\n	#define m1 - 1.0\n	#define r4 0.4\n	#define v4 0.046\n	#define m4 2.0\n	#define r5 0.305\n	#define v5 0.016\n	#define m5 3.0\n	#define r6 0.21\n	#define v6 0.0038\n	#define m6 4.0\n	float roughnessToMip( float roughness ) {\n		float mip = 0.0;\n		if ( roughness >= r1 ) {\n			mip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;\n		} else if ( roughness >= r4 ) {\n			mip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;\n		} else if ( roughness >= r5 ) {\n			mip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;\n		} else if ( roughness >= r6 ) {\n			mip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;\n		} else {\n			mip = - 2.0 * log2( 1.16 * roughness );		}\n		return mip;\n	}\n	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n		float mip = clamp( roughnessToMip( roughness ), m0, CUBEUV_MAX_MIP );\n		float mipF = fract( mip );\n		float mipInt = floor( mip );\n		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n		if ( mipF == 0.0 ) {\n			return vec4( color0, 1.0 );\n		} else {\n			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n			return vec4( mix( color0, color1, mipF ), 1.0 );\n		}\n	}\n#endif";
var defaultnormal_vertex = "vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n	mat3 m = mat3( instanceMatrix );\n	transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n	transformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n	transformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n	vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n	#ifdef FLIP_SIDED\n		transformedTangent = - transformedTangent;\n	#endif\n#endif";
var displacementmap_pars_vertex = "#ifdef USE_DISPLACEMENTMAP\n	uniform sampler2D displacementMap;\n	uniform float displacementScale;\n	uniform float displacementBias;\n#endif";
var displacementmap_vertex = "#ifdef USE_DISPLACEMENTMAP\n	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif";
var emissivemap_fragment = "#ifdef USE_EMISSIVEMAP\n	vec4 emissiveColor = texture2D( emissiveMap, vUv );\n	totalEmissiveRadiance *= emissiveColor.rgb;\n#endif";
var emissivemap_pars_fragment = "#ifdef USE_EMISSIVEMAP\n	uniform sampler2D emissiveMap;\n#endif";
var encodings_fragment = "gl_FragColor = linearToOutputTexel( gl_FragColor );";
var encodings_pars_fragment = "vec4 LinearToLinear( in vec4 value ) {\n	return value;\n}\nvec4 LinearTosRGB( in vec4 value ) {\n	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}";
var envmap_fragment = "#ifdef USE_ENVMAP\n	#ifdef ENV_WORLDPOS\n		vec3 cameraToFrag;\n		if ( isOrthographic ) {\n			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n		} else {\n			cameraToFrag = normalize( vWorldPosition - cameraPosition );\n		}\n		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n		#ifdef ENVMAP_MODE_REFLECTION\n			vec3 reflectVec = reflect( cameraToFrag, worldNormal );\n		#else\n			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n		#endif\n	#else\n		vec3 reflectVec = vReflect;\n	#endif\n	#ifdef ENVMAP_TYPE_CUBE\n		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n	#elif defined( ENVMAP_TYPE_CUBE_UV )\n		vec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n	#else\n		vec4 envColor = vec4( 0.0 );\n	#endif\n	#ifdef ENVMAP_BLENDING_MULTIPLY\n		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n	#elif defined( ENVMAP_BLENDING_MIX )\n		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n	#elif defined( ENVMAP_BLENDING_ADD )\n		outgoingLight += envColor.xyz * specularStrength * reflectivity;\n	#endif\n#endif";
var envmap_common_pars_fragment = "#ifdef USE_ENVMAP\n	uniform float envMapIntensity;\n	uniform float flipEnvMap;\n	#ifdef ENVMAP_TYPE_CUBE\n		uniform samplerCube envMap;\n	#else\n		uniform sampler2D envMap;\n	#endif\n	\n#endif";
var envmap_pars_fragment = "#ifdef USE_ENVMAP\n	uniform float reflectivity;\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n		#define ENV_WORLDPOS\n	#endif\n	#ifdef ENV_WORLDPOS\n		varying vec3 vWorldPosition;\n		uniform float refractionRatio;\n	#else\n		varying vec3 vReflect;\n	#endif\n#endif";
var envmap_pars_vertex = "#ifdef USE_ENVMAP\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n		#define ENV_WORLDPOS\n	#endif\n	#ifdef ENV_WORLDPOS\n		\n		varying vec3 vWorldPosition;\n	#else\n		varying vec3 vReflect;\n		uniform float refractionRatio;\n	#endif\n#endif";
var envmap_vertex = "#ifdef USE_ENVMAP\n	#ifdef ENV_WORLDPOS\n		vWorldPosition = worldPosition.xyz;\n	#else\n		vec3 cameraToVertex;\n		if ( isOrthographic ) {\n			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n		} else {\n			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n		}\n		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n		#ifdef ENVMAP_MODE_REFLECTION\n			vReflect = reflect( cameraToVertex, worldNormal );\n		#else\n			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n		#endif\n	#endif\n#endif";
var fog_vertex = "#ifdef USE_FOG\n	vFogDepth = - mvPosition.z;\n#endif";
var fog_pars_vertex = "#ifdef USE_FOG\n	varying float vFogDepth;\n#endif";
var fog_fragment = "#ifdef USE_FOG\n	#ifdef FOG_EXP2\n		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n	#else\n		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n	#endif\n	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif";
var fog_pars_fragment = "#ifdef USE_FOG\n	uniform vec3 fogColor;\n	varying float vFogDepth;\n	#ifdef FOG_EXP2\n		uniform float fogDensity;\n	#else\n		uniform float fogNear;\n		uniform float fogFar;\n	#endif\n#endif";
var gradientmap_pars_fragment = "#ifdef USE_GRADIENTMAP\n	uniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n	float dotNL = dot( normal, lightDirection );\n	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n	#ifdef USE_GRADIENTMAP\n		return vec3( texture2D( gradientMap, coord ).r );\n	#else\n		return ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n	#endif\n}";
var lightmap_fragment = "#ifdef USE_LIGHTMAP\n	vec4 lightMapTexel = texture2D( lightMap, vUv2 );\n	vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n	reflectedLight.indirectDiffuse += lightMapIrradiance;\n#endif";
var lightmap_pars_fragment = "#ifdef USE_LIGHTMAP\n	uniform sampler2D lightMap;\n	uniform float lightMapIntensity;\n#endif";
var lights_lambert_vertex = "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n	vLightBack = vec3( 0.0 );\n	vIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\nvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\nvIndirectFront += getLightProbeIrradiance( lightProbe, geometry.normal );\n#ifdef DOUBLE_SIDED\n	vIndirectBack += getAmbientLightIrradiance( ambientLightColor );\n	vIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry.normal );\n#endif\n#if NUM_POINT_LIGHTS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n		getPointLightInfo( pointLights[ i ], geometry, directLight );\n		dotNL = dot( geometry.normal, directLight.direction );\n		directLightColor_Diffuse = directLight.color;\n		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n		#ifdef DOUBLE_SIDED\n			vLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n		#endif\n	}\n	#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHTS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n		getSpotLightInfo( spotLights[ i ], geometry, directLight );\n		dotNL = dot( geometry.normal, directLight.direction );\n		directLightColor_Diffuse = directLight.color;\n		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n		#ifdef DOUBLE_SIDED\n			vLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n		#endif\n	}\n	#pragma unroll_loop_end\n#endif\n#if NUM_DIR_LIGHTS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n		getDirectionalLightInfo( directionalLights[ i ], geometry, directLight );\n		dotNL = dot( geometry.normal, directLight.direction );\n		directLightColor_Diffuse = directLight.color;\n		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n		#ifdef DOUBLE_SIDED\n			vLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n		#endif\n	}\n	#pragma unroll_loop_end\n#endif\n#if NUM_HEMI_LIGHTS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n		vIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n		#ifdef DOUBLE_SIDED\n			vIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry.normal );\n		#endif\n	}\n	#pragma unroll_loop_end\n#endif";
var lights_pars_begin = "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n	float x = normal.x, y = normal.y, z = normal.z;\n	vec3 result = shCoefficients[ 0 ] * 0.886227;\n	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n	return result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\n	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n	return irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n	vec3 irradiance = ambientLightColor;\n	return irradiance;\n}\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n	#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n		float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n		if ( cutoffDistance > 0.0 ) {\n			distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n		}\n		return distanceFalloff;\n	#else\n		if ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n			return pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );\n		}\n		return 1.0;\n	#endif\n}\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n	return smoothstep( coneCosine, penumbraCosine, angleCosine );\n}\n#if NUM_DIR_LIGHTS > 0\n	struct DirectionalLight {\n		vec3 direction;\n		vec3 color;\n	};\n	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n	void getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {\n		light.color = directionalLight.color;\n		light.direction = directionalLight.direction;\n		light.visible = true;\n	}\n#endif\n#if NUM_POINT_LIGHTS > 0\n	struct PointLight {\n		vec3 position;\n		vec3 color;\n		float distance;\n		float decay;\n	};\n	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n	void getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {\n		vec3 lVector = pointLight.position - geometry.position;\n		light.direction = normalize( lVector );\n		float lightDistance = length( lVector );\n		light.color = pointLight.color;\n		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n		light.visible = ( light.color != vec3( 0.0 ) );\n	}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n	struct SpotLight {\n		vec3 position;\n		vec3 direction;\n		vec3 color;\n		float distance;\n		float decay;\n		float coneCos;\n		float penumbraCos;\n	};\n	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n	void getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {\n		vec3 lVector = spotLight.position - geometry.position;\n		light.direction = normalize( lVector );\n		float angleCos = dot( light.direction, spotLight.direction );\n		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n		if ( spotAttenuation > 0.0 ) {\n			float lightDistance = length( lVector );\n			light.color = spotLight.color * spotAttenuation;\n			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n			light.visible = ( light.color != vec3( 0.0 ) );\n		} else {\n			light.color = vec3( 0.0 );\n			light.visible = false;\n		}\n	}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n	struct RectAreaLight {\n		vec3 color;\n		vec3 position;\n		vec3 halfWidth;\n		vec3 halfHeight;\n	};\n	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;\n	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n	struct HemisphereLight {\n		vec3 direction;\n		vec3 skyColor;\n		vec3 groundColor;\n	};\n	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\n		float dotNL = dot( normal, hemiLight.direction );\n		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n		return irradiance;\n	}\n#endif";
var envmap_physical_pars_fragment = "#if defined( USE_ENVMAP )\n	vec3 getIBLIrradiance( const in vec3 normal ) {\n		#if defined( ENVMAP_TYPE_CUBE_UV )\n			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n			vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n			return PI * envMapColor.rgb * envMapIntensity;\n		#else\n			return vec3( 0.0 );\n		#endif\n	}\n	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\n		#if defined( ENVMAP_TYPE_CUBE_UV )\n			vec3 reflectVec = reflect( - viewDir, normal );\n			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n			vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n			return envMapColor.rgb * envMapIntensity;\n		#else\n			return vec3( 0.0 );\n		#endif\n	}\n#endif";
var lights_toon_fragment = "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;";
var lights_toon_pars_fragment = "varying vec3 vViewPosition;\nstruct ToonMaterial {\n	vec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n	vec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct				RE_Direct_Toon\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )	(0)";
var lights_phong_fragment = "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;";
var lights_phong_pars_fragment = "varying vec3 vViewPosition;\nstruct BlinnPhongMaterial {\n	vec3 diffuseColor;\n	vec3 specularColor;\n	float specularShininess;\n	float specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n	vec3 irradiance = dotNL * directLight.color;\n	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct				RE_Direct_BlinnPhong\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )	(0)";
var lights_physical_fragment = "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;\nmaterial.roughness = min( material.roughness, 1.0 );\n#ifdef IOR\n	#ifdef SPECULAR\n		float specularIntensityFactor = specularIntensity;\n		vec3 specularColorFactor = specularColor;\n		#ifdef USE_SPECULARINTENSITYMAP\n			specularIntensityFactor *= texture2D( specularIntensityMap, vUv ).a;\n		#endif\n		#ifdef USE_SPECULARCOLORMAP\n			specularColorFactor *= texture2D( specularColorMap, vUv ).rgb;\n		#endif\n		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );\n	#else\n		float specularIntensityFactor = 1.0;\n		vec3 specularColorFactor = vec3( 1.0 );\n		material.specularF90 = 1.0;\n	#endif\n	material.specularColor = mix( min( pow2( ( ior - 1.0 ) / ( ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\n#else\n	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\n	material.specularF90 = 1.0;\n#endif\n#ifdef USE_CLEARCOAT\n	material.clearcoat = clearcoat;\n	material.clearcoatRoughness = clearcoatRoughness;\n	material.clearcoatF0 = vec3( 0.04 );\n	material.clearcoatF90 = 1.0;\n	#ifdef USE_CLEARCOATMAP\n		material.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n	#endif\n	#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n	#endif\n	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n	material.clearcoatRoughness += geometryRoughness;\n	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_SHEEN\n	material.sheenColor = sheenColor;\n	#ifdef USE_SHEENCOLORMAP\n		material.sheenColor *= texture2D( sheenColorMap, vUv ).rgb;\n	#endif\n	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );\n	#ifdef USE_SHEENROUGHNESSMAP\n		material.sheenRoughness *= texture2D( sheenRoughnessMap, vUv ).a;\n	#endif\n#endif";
var lights_physical_pars_fragment = "struct PhysicalMaterial {\n	vec3 diffuseColor;\n	float roughness;\n	vec3 specularColor;\n	float specularF90;\n	#ifdef USE_CLEARCOAT\n		float clearcoat;\n		float clearcoatRoughness;\n		vec3 clearcoatF0;\n		float clearcoatF90;\n	#endif\n	#ifdef USE_SHEEN\n		vec3 sheenColor;\n		float sheenRoughness;\n	#endif\n};\nvec3 clearcoatSpecular = vec3( 0.0 );\nvec3 sheenSpecular = vec3( 0.0 );\nfloat IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness) {\n	float dotNV = saturate( dot( normal, viewDir ) );\n	float r2 = roughness * roughness;\n	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;\n	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;\n	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );\n	return saturate( DG * RECIPROCAL_PI );\n}\nvec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n	float dotNV = saturate( dot( normal, viewDir ) );\n	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n	vec4 r = roughness * c0 + c1;\n	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;\n	return fab;\n}\nvec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {\n	vec2 fab = DFGApprox( normal, viewDir, roughness );\n	return specularColor * fab.x + specularF90 * fab.y;\n}\nvoid computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n	vec2 fab = DFGApprox( normal, viewDir, roughness );\n	vec3 FssEss = specularColor * fab.x + specularF90 * fab.y;\n	float Ess = fab.x + fab.y;\n	float Ems = 1.0 - Ess;\n	vec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n	singleScatter += FssEss;\n	multiScatter += Fms * Ems;\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n		vec3 normal = geometry.normal;\n		vec3 viewDir = geometry.viewDir;\n		vec3 position = geometry.position;\n		vec3 lightPos = rectAreaLight.position;\n		vec3 halfWidth = rectAreaLight.halfWidth;\n		vec3 halfHeight = rectAreaLight.halfHeight;\n		vec3 lightColor = rectAreaLight.color;\n		float roughness = material.roughness;\n		vec3 rectCoords[ 4 ];\n		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n		vec2 uv = LTC_Uv( normal, viewDir, roughness );\n		vec4 t1 = texture2D( ltc_1, uv );\n		vec4 t2 = texture2D( ltc_2, uv );\n		mat3 mInv = mat3(\n			vec3( t1.x, 0, t1.y ),\n			vec3(    0, 1,    0 ),\n			vec3( t1.z, 0, t1.w )\n		);\n		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n	}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n	vec3 irradiance = dotNL * directLight.color;\n	#ifdef USE_CLEARCOAT\n		float dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n		vec3 ccIrradiance = dotNLcc * directLight.color;\n		clearcoatSpecular += ccIrradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n	#endif\n	#ifdef USE_SHEEN\n		sheenSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenColor, material.sheenRoughness );\n	#endif\n	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.roughness );\n	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n	#ifdef USE_CLEARCOAT\n		clearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n	#endif\n	#ifdef USE_SHEEN\n		sheenSpecular += irradiance * material.sheenColor * IBLSheenBRDF( geometry.normal, geometry.viewDir, material.sheenRoughness );\n	#endif\n	vec3 singleScattering = vec3( 0.0 );\n	vec3 multiScattering = vec3( 0.0 );\n	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n	computeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );\n	vec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n	reflectedLight.indirectSpecular += radiance * singleScattering;\n	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct				RE_Direct_Physical\n#define RE_Direct_RectArea		RE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular		RE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}";
var lights_fragment_begin = "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef USE_CLEARCOAT\n	geometry.clearcoatNormal = clearcoatNormal;\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n	PointLight pointLight;\n	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n	PointLightShadow pointLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n		pointLight = pointLights[ i ];\n		getPointLightInfo( pointLight, geometry, directLight );\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n		pointLightShadow = pointLightShadows[ i ];\n		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n	SpotLight spotLight;\n	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n	SpotLightShadow spotLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n		spotLight = spotLights[ i ];\n		getSpotLightInfo( spotLight, geometry, directLight );\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n		spotLightShadow = spotLightShadows[ i ];\n		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n	DirectionalLight directionalLight;\n	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n	DirectionalLightShadow directionalLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n		directionalLight = directionalLights[ i ];\n		getDirectionalLightInfo( directionalLight, geometry, directLight );\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n		directionalLightShadow = directionalLightShadows[ i ];\n		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n	RectAreaLight rectAreaLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n		rectAreaLight = rectAreaLights[ i ];\n		RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n	vec3 iblIrradiance = vec3( 0.0 );\n	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n	irradiance += getLightProbeIrradiance( lightProbe, geometry.normal );\n	#if ( NUM_HEMI_LIGHTS > 0 )\n		#pragma unroll_loop_start\n		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n		}\n		#pragma unroll_loop_end\n	#endif\n#endif\n#if defined( RE_IndirectSpecular )\n	vec3 radiance = vec3( 0.0 );\n	vec3 clearcoatRadiance = vec3( 0.0 );\n#endif";
var lights_fragment_maps = "#if defined( RE_IndirectDiffuse )\n	#ifdef USE_LIGHTMAP\n		vec4 lightMapTexel = texture2D( lightMap, vUv2 );\n		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n		irradiance += lightMapIrradiance;\n	#endif\n	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n		iblIrradiance += getIBLIrradiance( geometry.normal );\n	#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n	radiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );\n	#ifdef USE_CLEARCOAT\n		clearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );\n	#endif\n#endif";
var lights_fragment_end = "#if defined( RE_IndirectDiffuse )\n	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif";
var logdepthbuf_fragment = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif";
var logdepthbuf_pars_fragment = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n	uniform float logDepthBufFC;\n	varying float vFragDepth;\n	varying float vIsPerspective;\n#endif";
var logdepthbuf_pars_vertex = "#ifdef USE_LOGDEPTHBUF\n	#ifdef USE_LOGDEPTHBUF_EXT\n		varying float vFragDepth;\n		varying float vIsPerspective;\n	#else\n		uniform float logDepthBufFC;\n	#endif\n#endif";
var logdepthbuf_vertex = "#ifdef USE_LOGDEPTHBUF\n	#ifdef USE_LOGDEPTHBUF_EXT\n		vFragDepth = 1.0 + gl_Position.w;\n		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n	#else\n		if ( isPerspectiveMatrix( projectionMatrix ) ) {\n			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n			gl_Position.z *= gl_Position.w;\n		}\n	#endif\n#endif";
var map_fragment = "#ifdef USE_MAP\n	vec4 sampledDiffuseColor = texture2D( map, vUv );\n	#ifdef DECODE_VIDEO_TEXTURE\n		sampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );\n	#endif\n	diffuseColor *= sampledDiffuseColor;\n#endif";
var map_pars_fragment = "#ifdef USE_MAP\n	uniform sampler2D map;\n#endif";
var map_particle_fragment = "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n	vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n	diffuseColor *= texture2D( map, uv );\n#endif\n#ifdef USE_ALPHAMAP\n	diffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif";
var map_particle_pars_fragment = "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n	uniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n	uniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n	uniform sampler2D alphaMap;\n#endif";
var metalnessmap_fragment = "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n	vec4 texelMetalness = texture2D( metalnessMap, vUv );\n	metalnessFactor *= texelMetalness.b;\n#endif";
var metalnessmap_pars_fragment = "#ifdef USE_METALNESSMAP\n	uniform sampler2D metalnessMap;\n#endif";
var morphcolor_vertex = "#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )\n	vColor *= morphTargetBaseInfluence;\n	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n		#if defined( USE_COLOR_ALPHA )\n			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];\n		#elif defined( USE_COLOR )\n			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];\n		#endif\n	}\n#endif";
var morphnormal_vertex = "#ifdef USE_MORPHNORMALS\n	objectNormal *= morphTargetBaseInfluence;\n	#ifdef MORPHTARGETS_TEXTURE\n		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n			if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];\n		}\n	#else\n		objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n		objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n		objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n		objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n	#endif\n#endif";
var morphtarget_pars_vertex = "#ifdef USE_MORPHTARGETS\n	uniform float morphTargetBaseInfluence;\n	#ifdef MORPHTARGETS_TEXTURE\n		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n		uniform sampler2DArray morphTargetsTexture;\n		uniform ivec2 morphTargetsTextureSize;\n		vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {\n			int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;\n			int y = texelIndex / morphTargetsTextureSize.x;\n			int x = texelIndex - y * morphTargetsTextureSize.x;\n			ivec3 morphUV = ivec3( x, y, morphTargetIndex );\n			return texelFetch( morphTargetsTexture, morphUV, 0 );\n		}\n	#else\n		#ifndef USE_MORPHNORMALS\n			uniform float morphTargetInfluences[ 8 ];\n		#else\n			uniform float morphTargetInfluences[ 4 ];\n		#endif\n	#endif\n#endif";
var morphtarget_vertex = "#ifdef USE_MORPHTARGETS\n	transformed *= morphTargetBaseInfluence;\n	#ifdef MORPHTARGETS_TEXTURE\n		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n			if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];\n		}\n	#else\n		transformed += morphTarget0 * morphTargetInfluences[ 0 ];\n		transformed += morphTarget1 * morphTargetInfluences[ 1 ];\n		transformed += morphTarget2 * morphTargetInfluences[ 2 ];\n		transformed += morphTarget3 * morphTargetInfluences[ 3 ];\n		#ifndef USE_MORPHNORMALS\n			transformed += morphTarget4 * morphTargetInfluences[ 4 ];\n			transformed += morphTarget5 * morphTargetInfluences[ 5 ];\n			transformed += morphTarget6 * morphTargetInfluences[ 6 ];\n			transformed += morphTarget7 * morphTargetInfluences[ 7 ];\n		#endif\n	#endif\n#endif";
var normal_fragment_begin = "float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n	vec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n	vec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n	vec3 normal = normalize( cross( fdx, fdy ) );\n#else\n	vec3 normal = normalize( vNormal );\n	#ifdef DOUBLE_SIDED\n		normal = normal * faceDirection;\n	#endif\n	#ifdef USE_TANGENT\n		vec3 tangent = normalize( vTangent );\n		vec3 bitangent = normalize( vBitangent );\n		#ifdef DOUBLE_SIDED\n			tangent = tangent * faceDirection;\n			bitangent = bitangent * faceDirection;\n		#endif\n		#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n			mat3 vTBN = mat3( tangent, bitangent, normal );\n		#endif\n	#endif\n#endif\nvec3 geometryNormal = normal;";
var normal_fragment_maps = "#ifdef OBJECTSPACE_NORMALMAP\n	normal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n	#ifdef FLIP_SIDED\n		normal = - normal;\n	#endif\n	#ifdef DOUBLE_SIDED\n		normal = normal * faceDirection;\n	#endif\n	normal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n	vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n	mapN.xy *= normalScale;\n	#ifdef USE_TANGENT\n		normal = normalize( vTBN * mapN );\n	#else\n		normal = perturbNormal2Arb( - vViewPosition, normal, mapN, faceDirection );\n	#endif\n#elif defined( USE_BUMPMAP )\n	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif";
var normal_pars_fragment = "#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n	#ifdef USE_TANGENT\n		varying vec3 vTangent;\n		varying vec3 vBitangent;\n	#endif\n#endif";
var normal_pars_vertex = "#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n	#ifdef USE_TANGENT\n		varying vec3 vTangent;\n		varying vec3 vBitangent;\n	#endif\n#endif";
var normal_vertex = "#ifndef FLAT_SHADED\n	vNormal = normalize( transformedNormal );\n	#ifdef USE_TANGENT\n		vTangent = normalize( transformedTangent );\n		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n	#endif\n#endif";
var normalmap_pars_fragment = "#ifdef USE_NORMALMAP\n	uniform sampler2D normalMap;\n	uniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n	uniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n	vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {\n		vec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n		vec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n		vec2 st0 = dFdx( vUv.st );\n		vec2 st1 = dFdy( vUv.st );\n		vec3 N = surf_norm;\n		vec3 q1perp = cross( q1, N );\n		vec3 q0perp = cross( N, q0 );\n		vec3 T = q1perp * st0.x + q0perp * st1.x;\n		vec3 B = q1perp * st0.y + q0perp * st1.y;\n		float det = max( dot( T, T ), dot( B, B ) );\n		float scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );\n		return normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );\n	}\n#endif";
var clearcoat_normal_fragment_begin = "#ifdef USE_CLEARCOAT\n	vec3 clearcoatNormal = geometryNormal;\n#endif";
var clearcoat_normal_fragment_maps = "#ifdef USE_CLEARCOAT_NORMALMAP\n	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n	clearcoatMapN.xy *= clearcoatNormalScale;\n	#ifdef USE_TANGENT\n		clearcoatNormal = normalize( vTBN * clearcoatMapN );\n	#else\n		clearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );\n	#endif\n#endif";
var clearcoat_pars_fragment = "#ifdef USE_CLEARCOATMAP\n	uniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n	uniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n	uniform sampler2D clearcoatNormalMap;\n	uniform vec2 clearcoatNormalScale;\n#endif";
var output_fragment = "#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= transmissionAlpha + 0.1;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );";
var packing = "vec3 packNormalToRGB( const in vec3 normal ) {\n	return normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n	return 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n	vec4 r = vec4( fract( v * PackFactors ), v );\n	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n	return dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n	return ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n	return linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n	return ( near * far ) / ( ( far - near ) * invClipZ - far );\n}";
var premultiplied_alpha_fragment = "#ifdef PREMULTIPLIED_ALPHA\n	gl_FragColor.rgb *= gl_FragColor.a;\n#endif";
var project_vertex = "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n	mvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;";
var dithering_fragment = "#ifdef DITHERING\n	gl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif";
var dithering_pars_fragment = "#ifdef DITHERING\n	vec3 dithering( vec3 color ) {\n		float grid_position = rand( gl_FragCoord.xy );\n		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n		return color + dither_shift_RGB;\n	}\n#endif";
var roughnessmap_fragment = "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n	vec4 texelRoughness = texture2D( roughnessMap, vUv );\n	roughnessFactor *= texelRoughness.g;\n#endif";
var roughnessmap_pars_fragment = "#ifdef USE_ROUGHNESSMAP\n	uniform sampler2D roughnessMap;\n#endif";
var shadowmap_pars_fragment = "#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n		struct DirectionalLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n		struct SpotLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n		struct PointLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n			float shadowCameraNear;\n			float shadowCameraFar;\n		};\n		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n	#endif\n	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n	}\n	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n		return unpackRGBATo2Half( texture2D( shadow, uv ) );\n	}\n	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n		float occlusion = 1.0;\n		vec2 distribution = texture2DDistribution( shadow, uv );\n		float hard_shadow = step( compare , distribution.x );\n		if (hard_shadow != 1.0 ) {\n			float distance = compare - distribution.x ;\n			float variance = max( 0.00000, distribution.y * distribution.y );\n			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n		}\n		return occlusion;\n	}\n	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n		float shadow = 1.0;\n		shadowCoord.xyz /= shadowCoord.w;\n		shadowCoord.z += shadowBias;\n		bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n		bool inFrustum = all( inFrustumVec );\n		bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n		bool frustumTest = all( frustumTestVec );\n		if ( frustumTest ) {\n		#if defined( SHADOWMAP_TYPE_PCF )\n			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n			float dx0 = - texelSize.x * shadowRadius;\n			float dy0 = - texelSize.y * shadowRadius;\n			float dx1 = + texelSize.x * shadowRadius;\n			float dy1 = + texelSize.y * shadowRadius;\n			float dx2 = dx0 / 2.0;\n			float dy2 = dy0 / 2.0;\n			float dx3 = dx1 / 2.0;\n			float dy3 = dy1 / 2.0;\n			shadow = (\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n			) * ( 1.0 / 17.0 );\n		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n			float dx = texelSize.x;\n			float dy = texelSize.y;\n			vec2 uv = shadowCoord.xy;\n			vec2 f = fract( uv * shadowMapSize + 0.5 );\n			uv -= f * texelSize;\n			shadow = (\n				texture2DCompare( shadowMap, uv, shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \n					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n					 f.x ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \n					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n					 f.x ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \n					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n					 f.y ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \n					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n					 f.y ) +\n				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \n						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n						  f.x ),\n					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \n						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n						  f.x ),\n					 f.y )\n			) * ( 1.0 / 9.0 );\n		#elif defined( SHADOWMAP_TYPE_VSM )\n			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n		#else\n			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n		#endif\n		}\n		return shadow;\n	}\n	vec2 cubeToUV( vec3 v, float texelSizeY ) {\n		vec3 absV = abs( v );\n		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n		absV *= scaleToCube;\n		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n		vec2 planar = v.xy;\n		float almostATexel = 1.5 * texelSizeY;\n		float almostOne = 1.0 - almostATexel;\n		if ( absV.z >= almostOne ) {\n			if ( v.z > 0.0 )\n				planar.x = 4.0 - v.x;\n		} else if ( absV.x >= almostOne ) {\n			float signX = sign( v.x );\n			planar.x = v.z * signX + 2.0 * signX;\n		} else if ( absV.y >= almostOne ) {\n			float signY = sign( v.y );\n			planar.x = v.x + 2.0 * signY + 2.0;\n			planar.y = v.z * signY - 2.0;\n		}\n		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n	}\n	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n		vec3 lightToPosition = shadowCoord.xyz;\n		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;\n		vec3 bd3D = normalize( lightToPosition );\n		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n			return (\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n			) * ( 1.0 / 9.0 );\n		#else\n			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n		#endif\n	}\n#endif";
var shadowmap_pars_vertex = "#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n		struct DirectionalLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n		uniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n		struct SpotLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n		struct PointLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n			float shadowCameraNear;\n			float shadowCameraFar;\n		};\n		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n	#endif\n#endif";
var shadowmap_vertex = "#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\n		vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n		vec4 shadowWorldPosition;\n	#endif\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n		vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );\n		vSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n		vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n	}\n	#pragma unroll_loop_end\n	#endif\n#endif";
var shadowmask_pars_fragment = "float getShadowMask() {\n	float shadow = 1.0;\n	#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n	DirectionalLightShadow directionalLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n		directionalLight = directionalLightShadows[ i ];\n		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n	SpotLightShadow spotLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n		spotLight = spotLightShadows[ i ];\n		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n	PointLightShadow pointLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n		pointLight = pointLightShadows[ i ];\n		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#endif\n	return shadow;\n}";
var skinbase_vertex = "#ifdef USE_SKINNING\n	mat4 boneMatX = getBoneMatrix( skinIndex.x );\n	mat4 boneMatY = getBoneMatrix( skinIndex.y );\n	mat4 boneMatZ = getBoneMatrix( skinIndex.z );\n	mat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif";
var skinning_pars_vertex = "#ifdef USE_SKINNING\n	uniform mat4 bindMatrix;\n	uniform mat4 bindMatrixInverse;\n	#ifdef BONE_TEXTURE\n		uniform highp sampler2D boneTexture;\n		uniform int boneTextureSize;\n		mat4 getBoneMatrix( const in float i ) {\n			float j = i * 4.0;\n			float x = mod( j, float( boneTextureSize ) );\n			float y = floor( j / float( boneTextureSize ) );\n			float dx = 1.0 / float( boneTextureSize );\n			float dy = 1.0 / float( boneTextureSize );\n			y = dy * ( y + 0.5 );\n			vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n			vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n			vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n			vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n			mat4 bone = mat4( v1, v2, v3, v4 );\n			return bone;\n		}\n	#else\n		uniform mat4 boneMatrices[ MAX_BONES ];\n		mat4 getBoneMatrix( const in float i ) {\n			mat4 bone = boneMatrices[ int(i) ];\n			return bone;\n		}\n	#endif\n#endif";
var skinning_vertex = "#ifdef USE_SKINNING\n	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n	vec4 skinned = vec4( 0.0 );\n	skinned += boneMatX * skinVertex * skinWeight.x;\n	skinned += boneMatY * skinVertex * skinWeight.y;\n	skinned += boneMatZ * skinVertex * skinWeight.z;\n	skinned += boneMatW * skinVertex * skinWeight.w;\n	transformed = ( bindMatrixInverse * skinned ).xyz;\n#endif";
var skinnormal_vertex = "#ifdef USE_SKINNING\n	mat4 skinMatrix = mat4( 0.0 );\n	skinMatrix += skinWeight.x * boneMatX;\n	skinMatrix += skinWeight.y * boneMatY;\n	skinMatrix += skinWeight.z * boneMatZ;\n	skinMatrix += skinWeight.w * boneMatW;\n	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n	#ifdef USE_TANGENT\n		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n	#endif\n#endif";
var specularmap_fragment = "float specularStrength;\n#ifdef USE_SPECULARMAP\n	vec4 texelSpecular = texture2D( specularMap, vUv );\n	specularStrength = texelSpecular.r;\n#else\n	specularStrength = 1.0;\n#endif";
var specularmap_pars_fragment = "#ifdef USE_SPECULARMAP\n	uniform sampler2D specularMap;\n#endif";
var tonemapping_fragment = "#if defined( TONE_MAPPING )\n	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif";
var tonemapping_pars_fragment = "#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n	return toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n	color *= toneMappingExposure;\n	return saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n	color *= toneMappingExposure;\n	color = max( vec3( 0.0 ), color - 0.004 );\n	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n	return a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n	const mat3 ACESInputMat = mat3(\n		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),\n		vec3( 0.04823, 0.01566, 0.83777 )\n	);\n	const mat3 ACESOutputMat = mat3(\n		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),\n		vec3( -0.07367, -0.00605,  1.07602 )\n	);\n	color *= toneMappingExposure / 0.6;\n	color = ACESInputMat * color;\n	color = RRTAndODTFit( color );\n	color = ACESOutputMat * color;\n	return saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }";
var transmission_fragment = "#ifdef USE_TRANSMISSION\n	float transmissionAlpha = 1.0;\n	float transmissionFactor = transmission;\n	float thicknessFactor = thickness;\n	#ifdef USE_TRANSMISSIONMAP\n		transmissionFactor *= texture2D( transmissionMap, vUv ).r;\n	#endif\n	#ifdef USE_THICKNESSMAP\n		thicknessFactor *= texture2D( thicknessMap, vUv ).g;\n	#endif\n	vec3 pos = vWorldPosition;\n	vec3 v = normalize( cameraPosition - pos );\n	vec3 n = inverseTransformDirection( normal, viewMatrix );\n	vec4 transmission = getIBLVolumeRefraction(\n		n, v, roughnessFactor, material.diffuseColor, material.specularColor, material.specularF90,\n		pos, modelMatrix, viewMatrix, projectionMatrix, ior, thicknessFactor,\n		attenuationColor, attenuationDistance );\n	totalDiffuse = mix( totalDiffuse, transmission.rgb, transmissionFactor );\n	transmissionAlpha = mix( transmissionAlpha, transmission.a, transmissionFactor );\n#endif";
var transmission_pars_fragment = "#ifdef USE_TRANSMISSION\n	uniform float transmission;\n	uniform float thickness;\n	uniform float attenuationDistance;\n	uniform vec3 attenuationColor;\n	#ifdef USE_TRANSMISSIONMAP\n		uniform sampler2D transmissionMap;\n	#endif\n	#ifdef USE_THICKNESSMAP\n		uniform sampler2D thicknessMap;\n	#endif\n	uniform vec2 transmissionSamplerSize;\n	uniform sampler2D transmissionSamplerMap;\n	uniform mat4 modelMatrix;\n	uniform mat4 projectionMatrix;\n	varying vec3 vWorldPosition;\n	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {\n		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\n		vec3 modelScale;\n		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n		return normalize( refractionVector ) * thickness * modelScale;\n	}\n	float applyIorToRoughness( const in float roughness, const in float ior ) {\n		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n	}\n	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {\n		float framebufferLod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\n		#ifdef texture2DLodEXT\n			return texture2DLodEXT( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n		#else\n			return texture2D( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n		#endif\n	}\n	vec3 applyVolumeAttenuation( const in vec3 radiance, const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {\n		if ( attenuationDistance == 0.0 ) {\n			return radiance;\n		} else {\n			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\n			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance * radiance;\n		}\n	}\n	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,\n		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,\n		const in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,\n		const in vec3 attenuationColor, const in float attenuationDistance ) {\n		vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n		vec3 refractedRayExit = position + transmissionRay;\n		vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n		vec2 refractionCoords = ndcPos.xy / ndcPos.w;\n		refractionCoords += 1.0;\n		refractionCoords /= 2.0;\n		vec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\n		vec3 attenuatedColor = applyVolumeAttenuation( transmittedLight.rgb, length( transmissionRay ), attenuationColor, attenuationDistance );\n		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\n		return vec4( ( 1.0 - F ) * attenuatedColor * diffuseColor, transmittedLight.a );\n	}\n#endif";
var uv_pars_fragment = "#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n	varying vec2 vUv;\n#endif";
var uv_pars_vertex = "#ifdef USE_UV\n	#ifdef UVS_VERTEX_ONLY\n		vec2 vUv;\n	#else\n		varying vec2 vUv;\n	#endif\n	uniform mat3 uvTransform;\n#endif";
var uv_vertex = "#ifdef USE_UV\n	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif";
var uv2_pars_fragment = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n	varying vec2 vUv2;\n#endif";
var uv2_pars_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n	attribute vec2 uv2;\n	varying vec2 vUv2;\n	uniform mat3 uv2Transform;\n#endif";
var uv2_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n	vUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif";
var worldpos_vertex = "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION )\n	vec4 worldPosition = vec4( transformed, 1.0 );\n	#ifdef USE_INSTANCING\n		worldPosition = instanceMatrix * worldPosition;\n	#endif\n	worldPosition = modelMatrix * worldPosition;\n#endif";
const vertex$g = "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n	gl_Position = vec4( position.xy, 1.0, 1.0 );\n}";
const fragment$g = "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n	gl_FragColor = texture2D( t2D, vUv );\n	#ifdef DECODE_VIDEO_TEXTURE\n		gl_FragColor = vec4( mix( pow( gl_FragColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), gl_FragColor.rgb * 0.0773993808, vec3( lessThanEqual( gl_FragColor.rgb, vec3( 0.04045 ) ) ) ), gl_FragColor.w );\n	#endif\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n}";
const vertex$f = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vWorldDirection = transformDirection( position, modelMatrix );\n	#include <begin_vertex>\n	#include <project_vertex>\n	gl_Position.z = gl_Position.w;\n}";
const fragment$f = "#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n	vec3 vReflect = vWorldDirection;\n	#include <envmap_fragment>\n	gl_FragColor = envColor;\n	gl_FragColor.a *= opacity;\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n}";
const vertex$e = "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n	#include <uv_vertex>\n	#include <skinbase_vertex>\n	#ifdef USE_DISPLACEMENTMAP\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vHighPrecisionZW = gl_Position.zw;\n}";
const fragment$e = "#if DEPTH_PACKING == 3200\n	uniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( 1.0 );\n	#if DEPTH_PACKING == 3200\n		diffuseColor.a = opacity;\n	#endif\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <logdepthbuf_fragment>\n	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n	#if DEPTH_PACKING == 3200\n		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n	#elif DEPTH_PACKING == 3201\n		gl_FragColor = packDepthToRGBA( fragCoordZ );\n	#endif\n}";
const vertex$d = "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <skinbase_vertex>\n	#ifdef USE_DISPLACEMENTMAP\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <worldpos_vertex>\n	#include <clipping_planes_vertex>\n	vWorldPosition = worldPosition.xyz;\n}";
const fragment$d = "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( 1.0 );\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	float dist = length( vWorldPosition - referencePosition );\n	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n	dist = saturate( dist );\n	gl_FragColor = packDepthToRGBA( dist );\n}";
const vertex$c = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vWorldDirection = transformDirection( position, modelMatrix );\n	#include <begin_vertex>\n	#include <project_vertex>\n}";
const fragment$c = "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vec3 direction = normalize( vWorldDirection );\n	vec2 sampleUV = equirectUv( direction );\n	gl_FragColor = texture2D( tEquirect, sampleUV );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n}";
const vertex$b = "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	vLineDistance = scale * lineDistance;\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n}";
const fragment$b = "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	if ( mod( vLineDistance, totalSize ) > dashSize ) {\n		discard;\n	}\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <color_fragment>\n	outgoingLight = diffuseColor.rgb;\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n}";
const vertex$a = "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinbase_vertex>\n		#include <skinnormal_vertex>\n		#include <defaultnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <fog_vertex>\n}";
const fragment$a = "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	#ifdef USE_LIGHTMAP\n		vec4 lightMapTexel = texture2D( lightMap, vUv2 );\n		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;\n	#else\n		reflectedLight.indirectDiffuse += vec3( 1.0 );\n	#endif\n	#include <aomap_fragment>\n	reflectedLight.indirectDiffuse *= diffuseColor.rgb;\n	vec3 outgoingLight = reflectedLight.indirectDiffuse;\n	#include <envmap_fragment>\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
const vertex$9 = "#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n	varying vec3 vLightBack;\n	varying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <lights_lambert_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}";
const fragment$9 = "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n	varying vec3 vLightBack;\n	varying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	#include <emissivemap_fragment>\n	#ifdef DOUBLE_SIDED\n		reflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n	#else\n		reflectedLight.indirectDiffuse += vIndirectFront;\n	#endif\n	#include <lightmap_fragment>\n	reflectedLight.indirectDiffuse *= BRDF_Lambert( diffuseColor.rgb );\n	#ifdef DOUBLE_SIDED\n		reflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n	#else\n		reflectedLight.directDiffuse = vLightFront;\n	#endif\n	reflectedLight.directDiffuse *= BRDF_Lambert( diffuseColor.rgb ) * getShadowMask();\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n	#include <envmap_fragment>\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
const vertex$8 = "#define MATCAP\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n	vViewPosition = - mvPosition.xyz;\n}";
const fragment$8 = "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	vec3 viewDir = normalize( vViewPosition );\n	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n	vec3 y = cross( viewDir, x );\n	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n	#ifdef USE_MATCAP\n		vec4 matcapColor = texture2D( matcap, uv );\n	#else\n		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );\n	#endif\n	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
const vertex$7 = "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n	varying vec3 vViewPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n	vViewPosition = - mvPosition.xyz;\n#endif\n}";
const fragment$7 = "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n	varying vec3 vViewPosition;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	#include <logdepthbuf_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n	#ifdef OPAQUE\n		gl_FragColor.a = 1.0;\n	#endif\n}";
const vertex$6 = "#define PHONG\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}";
const fragment$6 = "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_phong_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n	#include <envmap_fragment>\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
const vertex$5 = "#define STANDARD\nvarying vec3 vViewPosition;\n#ifdef USE_TRANSMISSION\n	varying vec3 vWorldPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n	vWorldPosition = worldPosition.xyz;\n#endif\n}";
const fragment$5 = "#define STANDARD\n#ifdef PHYSICAL\n	#define IOR\n	#define SPECULAR\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef IOR\n	uniform float ior;\n#endif\n#ifdef SPECULAR\n	uniform float specularIntensity;\n	uniform vec3 specularColor;\n	#ifdef USE_SPECULARINTENSITYMAP\n		uniform sampler2D specularIntensityMap;\n	#endif\n	#ifdef USE_SPECULARCOLORMAP\n		uniform sampler2D specularColorMap;\n	#endif\n#endif\n#ifdef USE_CLEARCOAT\n	uniform float clearcoat;\n	uniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n	uniform vec3 sheenColor;\n	uniform float sheenRoughness;\n	#ifdef USE_SHEENCOLORMAP\n		uniform sampler2D sheenColorMap;\n	#endif\n	#ifdef USE_SHEENROUGHNESSMAP\n		uniform sampler2D sheenRoughnessMap;\n	#endif\n#endif\nvarying vec3 vViewPosition;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_physical_pars_fragment>\n#include <transmission_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <roughnessmap_fragment>\n	#include <metalnessmap_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <clearcoat_normal_fragment_begin>\n	#include <clearcoat_normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_physical_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n	#include <transmission_fragment>\n	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n	#ifdef USE_SHEEN\n		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );\n		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecular;\n	#endif\n	#ifdef USE_CLEARCOAT\n		float dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\n		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;\n	#endif\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
const vertex$4 = "#define TOON\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}";
const fragment$4 = "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_toon_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
const vertex$3 = "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <project_vertex>\n	gl_PointSize = size;\n	#ifdef USE_SIZEATTENUATION\n		bool isPerspective = isPerspectiveMatrix( projectionMatrix );\n		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n	#endif\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <worldpos_vertex>\n	#include <fog_vertex>\n}";
const fragment$3 = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_particle_fragment>\n	#include <color_fragment>\n	#include <alphatest_fragment>\n	outgoingLight = diffuseColor.rgb;\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n}";
const vertex$2 = "#include <common>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}";
const fragment$2 = "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n}";
const vertex$1 = "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n	vec2 scale;\n	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n	#ifndef USE_SIZEATTENUATION\n		bool isPerspective = isPerspectiveMatrix( projectionMatrix );\n		if ( isPerspective ) scale *= - mvPosition.z;\n	#endif\n	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n	vec2 rotatedPosition;\n	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n	mvPosition.xy += rotatedPosition;\n	gl_Position = projectionMatrix * mvPosition;\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n}";
const fragment$1 = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	outgoingLight = diffuseColor.rgb;\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n}";
const ShaderChunk = {
  alphamap_fragment,
  alphamap_pars_fragment,
  alphatest_fragment,
  alphatest_pars_fragment,
  aomap_fragment,
  aomap_pars_fragment,
  begin_vertex,
  beginnormal_vertex,
  bsdfs,
  bumpmap_pars_fragment,
  clipping_planes_fragment,
  clipping_planes_pars_fragment,
  clipping_planes_pars_vertex,
  clipping_planes_vertex,
  color_fragment,
  color_pars_fragment,
  color_pars_vertex,
  color_vertex,
  common,
  cube_uv_reflection_fragment,
  defaultnormal_vertex,
  displacementmap_pars_vertex,
  displacementmap_vertex,
  emissivemap_fragment,
  emissivemap_pars_fragment,
  encodings_fragment,
  encodings_pars_fragment,
  envmap_fragment,
  envmap_common_pars_fragment,
  envmap_pars_fragment,
  envmap_pars_vertex,
  envmap_physical_pars_fragment,
  envmap_vertex,
  fog_vertex,
  fog_pars_vertex,
  fog_fragment,
  fog_pars_fragment,
  gradientmap_pars_fragment,
  lightmap_fragment,
  lightmap_pars_fragment,
  lights_lambert_vertex,
  lights_pars_begin,
  lights_toon_fragment,
  lights_toon_pars_fragment,
  lights_phong_fragment,
  lights_phong_pars_fragment,
  lights_physical_fragment,
  lights_physical_pars_fragment,
  lights_fragment_begin,
  lights_fragment_maps,
  lights_fragment_end,
  logdepthbuf_fragment,
  logdepthbuf_pars_fragment,
  logdepthbuf_pars_vertex,
  logdepthbuf_vertex,
  map_fragment,
  map_pars_fragment,
  map_particle_fragment,
  map_particle_pars_fragment,
  metalnessmap_fragment,
  metalnessmap_pars_fragment,
  morphcolor_vertex,
  morphnormal_vertex,
  morphtarget_pars_vertex,
  morphtarget_vertex,
  normal_fragment_begin,
  normal_fragment_maps,
  normal_pars_fragment,
  normal_pars_vertex,
  normal_vertex,
  normalmap_pars_fragment,
  clearcoat_normal_fragment_begin,
  clearcoat_normal_fragment_maps,
  clearcoat_pars_fragment,
  output_fragment,
  packing,
  premultiplied_alpha_fragment,
  project_vertex,
  dithering_fragment,
  dithering_pars_fragment,
  roughnessmap_fragment,
  roughnessmap_pars_fragment,
  shadowmap_pars_fragment,
  shadowmap_pars_vertex,
  shadowmap_vertex,
  shadowmask_pars_fragment,
  skinbase_vertex,
  skinning_pars_vertex,
  skinning_vertex,
  skinnormal_vertex,
  specularmap_fragment,
  specularmap_pars_fragment,
  tonemapping_fragment,
  tonemapping_pars_fragment,
  transmission_fragment,
  transmission_pars_fragment,
  uv_pars_fragment,
  uv_pars_vertex,
  uv_vertex,
  uv2_pars_fragment,
  uv2_pars_vertex,
  uv2_vertex,
  worldpos_vertex,
  background_vert: vertex$g,
  background_frag: fragment$g,
  cube_vert: vertex$f,
  cube_frag: fragment$f,
  depth_vert: vertex$e,
  depth_frag: fragment$e,
  distanceRGBA_vert: vertex$d,
  distanceRGBA_frag: fragment$d,
  equirect_vert: vertex$c,
  equirect_frag: fragment$c,
  linedashed_vert: vertex$b,
  linedashed_frag: fragment$b,
  meshbasic_vert: vertex$a,
  meshbasic_frag: fragment$a,
  meshlambert_vert: vertex$9,
  meshlambert_frag: fragment$9,
  meshmatcap_vert: vertex$8,
  meshmatcap_frag: fragment$8,
  meshnormal_vert: vertex$7,
  meshnormal_frag: fragment$7,
  meshphong_vert: vertex$6,
  meshphong_frag: fragment$6,
  meshphysical_vert: vertex$5,
  meshphysical_frag: fragment$5,
  meshtoon_vert: vertex$4,
  meshtoon_frag: fragment$4,
  points_vert: vertex$3,
  points_frag: fragment$3,
  shadow_vert: vertex$2,
  shadow_frag: fragment$2,
  sprite_vert: vertex$1,
  sprite_frag: fragment$1
};
const UniformsLib = {
  common: {
    diffuse: { value: new Color(16777215) },
    opacity: { value: 1 },
    map: { value: null },
    uvTransform: { value: new Matrix3() },
    uv2Transform: { value: new Matrix3() },
    alphaMap: { value: null },
    alphaTest: { value: 0 }
  },
  specularmap: {
    specularMap: { value: null }
  },
  envmap: {
    envMap: { value: null },
    flipEnvMap: { value: -1 },
    reflectivity: { value: 1 },
    ior: { value: 1.5 },
    refractionRatio: { value: 0.98 }
  },
  aomap: {
    aoMap: { value: null },
    aoMapIntensity: { value: 1 }
  },
  lightmap: {
    lightMap: { value: null },
    lightMapIntensity: { value: 1 }
  },
  emissivemap: {
    emissiveMap: { value: null }
  },
  bumpmap: {
    bumpMap: { value: null },
    bumpScale: { value: 1 }
  },
  normalmap: {
    normalMap: { value: null },
    normalScale: { value: new Vector2(1, 1) }
  },
  displacementmap: {
    displacementMap: { value: null },
    displacementScale: { value: 1 },
    displacementBias: { value: 0 }
  },
  roughnessmap: {
    roughnessMap: { value: null }
  },
  metalnessmap: {
    metalnessMap: { value: null }
  },
  gradientmap: {
    gradientMap: { value: null }
  },
  fog: {
    fogDensity: { value: 25e-5 },
    fogNear: { value: 1 },
    fogFar: { value: 2e3 },
    fogColor: { value: new Color(16777215) }
  },
  lights: {
    ambientLightColor: { value: [] },
    lightProbe: { value: [] },
    directionalLights: { value: [], properties: {
      direction: {},
      color: {}
    } },
    directionalLightShadows: { value: [], properties: {
      shadowBias: {},
      shadowNormalBias: {},
      shadowRadius: {},
      shadowMapSize: {}
    } },
    directionalShadowMap: { value: [] },
    directionalShadowMatrix: { value: [] },
    spotLights: { value: [], properties: {
      color: {},
      position: {},
      direction: {},
      distance: {},
      coneCos: {},
      penumbraCos: {},
      decay: {}
    } },
    spotLightShadows: { value: [], properties: {
      shadowBias: {},
      shadowNormalBias: {},
      shadowRadius: {},
      shadowMapSize: {}
    } },
    spotShadowMap: { value: [] },
    spotShadowMatrix: { value: [] },
    pointLights: { value: [], properties: {
      color: {},
      position: {},
      decay: {},
      distance: {}
    } },
    pointLightShadows: { value: [], properties: {
      shadowBias: {},
      shadowNormalBias: {},
      shadowRadius: {},
      shadowMapSize: {},
      shadowCameraNear: {},
      shadowCameraFar: {}
    } },
    pointShadowMap: { value: [] },
    pointShadowMatrix: { value: [] },
    hemisphereLights: { value: [], properties: {
      direction: {},
      skyColor: {},
      groundColor: {}
    } },
    rectAreaLights: { value: [], properties: {
      color: {},
      position: {},
      width: {},
      height: {}
    } },
    ltc_1: { value: null },
    ltc_2: { value: null }
  },
  points: {
    diffuse: { value: new Color(16777215) },
    opacity: { value: 1 },
    size: { value: 1 },
    scale: { value: 1 },
    map: { value: null },
    alphaMap: { value: null },
    alphaTest: { value: 0 },
    uvTransform: { value: new Matrix3() }
  },
  sprite: {
    diffuse: { value: new Color(16777215) },
    opacity: { value: 1 },
    center: { value: new Vector2(0.5, 0.5) },
    rotation: { value: 0 },
    map: { value: null },
    alphaMap: { value: null },
    alphaTest: { value: 0 },
    uvTransform: { value: new Matrix3() }
  }
};
const ShaderLib = {
  basic: {
    uniforms: mergeUniforms([
      UniformsLib.common,
      UniformsLib.specularmap,
      UniformsLib.envmap,
      UniformsLib.aomap,
      UniformsLib.lightmap,
      UniformsLib.fog
    ]),
    vertexShader: ShaderChunk.meshbasic_vert,
    fragmentShader: ShaderChunk.meshbasic_frag
  },
  lambert: {
    uniforms: mergeUniforms([
      UniformsLib.common,
      UniformsLib.specularmap,
      UniformsLib.envmap,
      UniformsLib.aomap,
      UniformsLib.lightmap,
      UniformsLib.emissivemap,
      UniformsLib.fog,
      UniformsLib.lights,
      {
        emissive: { value: new Color(0) }
      }
    ]),
    vertexShader: ShaderChunk.meshlambert_vert,
    fragmentShader: ShaderChunk.meshlambert_frag
  },
  phong: {
    uniforms: mergeUniforms([
      UniformsLib.common,
      UniformsLib.specularmap,
      UniformsLib.envmap,
      UniformsLib.aomap,
      UniformsLib.lightmap,
      UniformsLib.emissivemap,
      UniformsLib.bumpmap,
      UniformsLib.normalmap,
      UniformsLib.displacementmap,
      UniformsLib.fog,
      UniformsLib.lights,
      {
        emissive: { value: new Color(0) },
        specular: { value: new Color(1118481) },
        shininess: { value: 30 }
      }
    ]),
    vertexShader: ShaderChunk.meshphong_vert,
    fragmentShader: ShaderChunk.meshphong_frag
  },
  standard: {
    uniforms: mergeUniforms([
      UniformsLib.common,
      UniformsLib.envmap,
      UniformsLib.aomap,
      UniformsLib.lightmap,
      UniformsLib.emissivemap,
      UniformsLib.bumpmap,
      UniformsLib.normalmap,
      UniformsLib.displacementmap,
      UniformsLib.roughnessmap,
      UniformsLib.metalnessmap,
      UniformsLib.fog,
      UniformsLib.lights,
      {
        emissive: { value: new Color(0) },
        roughness: { value: 1 },
        metalness: { value: 0 },
        envMapIntensity: { value: 1 }
      }
    ]),
    vertexShader: ShaderChunk.meshphysical_vert,
    fragmentShader: ShaderChunk.meshphysical_frag
  },
  toon: {
    uniforms: mergeUniforms([
      UniformsLib.common,
      UniformsLib.aomap,
      UniformsLib.lightmap,
      UniformsLib.emissivemap,
      UniformsLib.bumpmap,
      UniformsLib.normalmap,
      UniformsLib.displacementmap,
      UniformsLib.gradientmap,
      UniformsLib.fog,
      UniformsLib.lights,
      {
        emissive: { value: new Color(0) }
      }
    ]),
    vertexShader: ShaderChunk.meshtoon_vert,
    fragmentShader: ShaderChunk.meshtoon_frag
  },
  matcap: {
    uniforms: mergeUniforms([
      UniformsLib.common,
      UniformsLib.bumpmap,
      UniformsLib.normalmap,
      UniformsLib.displacementmap,
      UniformsLib.fog,
      {
        matcap: { value: null }
      }
    ]),
    vertexShader: ShaderChunk.meshmatcap_vert,
    fragmentShader: ShaderChunk.meshmatcap_frag
  },
  points: {
    uniforms: mergeUniforms([
      UniformsLib.points,
      UniformsLib.fog
    ]),
    vertexShader: ShaderChunk.points_vert,
    fragmentShader: ShaderChunk.points_frag
  },
  dashed: {
    uniforms: mergeUniforms([
      UniformsLib.common,
      UniformsLib.fog,
      {
        scale: { value: 1 },
        dashSize: { value: 1 },
        totalSize: { value: 2 }
      }
    ]),
    vertexShader: ShaderChunk.linedashed_vert,
    fragmentShader: ShaderChunk.linedashed_frag
  },
  depth: {
    uniforms: mergeUniforms([
      UniformsLib.common,
      UniformsLib.displacementmap
    ]),
    vertexShader: ShaderChunk.depth_vert,
    fragmentShader: ShaderChunk.depth_frag
  },
  normal: {
    uniforms: mergeUniforms([
      UniformsLib.common,
      UniformsLib.bumpmap,
      UniformsLib.normalmap,
      UniformsLib.displacementmap,
      {
        opacity: { value: 1 }
      }
    ]),
    vertexShader: ShaderChunk.meshnormal_vert,
    fragmentShader: ShaderChunk.meshnormal_frag
  },
  sprite: {
    uniforms: mergeUniforms([
      UniformsLib.sprite,
      UniformsLib.fog
    ]),
    vertexShader: ShaderChunk.sprite_vert,
    fragmentShader: ShaderChunk.sprite_frag
  },
  background: {
    uniforms: {
      uvTransform: { value: new Matrix3() },
      t2D: { value: null }
    },
    vertexShader: ShaderChunk.background_vert,
    fragmentShader: ShaderChunk.background_frag
  },
  cube: {
    uniforms: mergeUniforms([
      UniformsLib.envmap,
      {
        opacity: { value: 1 }
      }
    ]),
    vertexShader: ShaderChunk.cube_vert,
    fragmentShader: ShaderChunk.cube_frag
  },
  equirect: {
    uniforms: {
      tEquirect: { value: null }
    },
    vertexShader: ShaderChunk.equirect_vert,
    fragmentShader: ShaderChunk.equirect_frag
  },
  distanceRGBA: {
    uniforms: mergeUniforms([
      UniformsLib.common,
      UniformsLib.displacementmap,
      {
        referencePosition: { value: new Vector3() },
        nearDistance: { value: 1 },
        farDistance: { value: 1e3 }
      }
    ]),
    vertexShader: ShaderChunk.distanceRGBA_vert,
    fragmentShader: ShaderChunk.distanceRGBA_frag
  },
  shadow: {
    uniforms: mergeUniforms([
      UniformsLib.lights,
      UniformsLib.fog,
      {
        color: { value: new Color(0) },
        opacity: { value: 1 }
      }
    ]),
    vertexShader: ShaderChunk.shadow_vert,
    fragmentShader: ShaderChunk.shadow_frag
  }
};
ShaderLib.physical = {
  uniforms: mergeUniforms([
    ShaderLib.standard.uniforms,
    {
      clearcoat: { value: 0 },
      clearcoatMap: { value: null },
      clearcoatRoughness: { value: 0 },
      clearcoatRoughnessMap: { value: null },
      clearcoatNormalScale: { value: new Vector2(1, 1) },
      clearcoatNormalMap: { value: null },
      sheen: { value: 0 },
      sheenColor: { value: new Color(0) },
      sheenColorMap: { value: null },
      sheenRoughness: { value: 1 },
      sheenRoughnessMap: { value: null },
      transmission: { value: 0 },
      transmissionMap: { value: null },
      transmissionSamplerSize: { value: new Vector2() },
      transmissionSamplerMap: { value: null },
      thickness: { value: 0 },
      thicknessMap: { value: null },
      attenuationDistance: { value: 0 },
      attenuationColor: { value: new Color(0) },
      specularIntensity: { value: 1 },
      specularIntensityMap: { value: null },
      specularColor: { value: new Color(1, 1, 1) },
      specularColorMap: { value: null }
    }
  ]),
  vertexShader: ShaderChunk.meshphysical_vert,
  fragmentShader: ShaderChunk.meshphysical_frag
};
function WebGLBackground(renderer, cubemaps, state, objects, alpha2, premultipliedAlpha) {
  const clearColor = new Color(0);
  let clearAlpha = alpha2 === true ? 0 : 1;
  let planeMesh;
  let boxMesh;
  let currentBackground = null;
  let currentBackgroundVersion = 0;
  let currentTonemapping = null;
  function render(renderList, scene) {
    let forceClear = false;
    let background = scene.isScene === true ? scene.background : null;
    if (background && background.isTexture) {
      background = cubemaps.get(background);
    }
    const xr = renderer.xr;
    const session = xr.getSession && xr.getSession();
    if (session && session.environmentBlendMode === "additive") {
      background = null;
    }
    if (background === null) {
      setClear(clearColor, clearAlpha);
    } else if (background && background.isColor) {
      setClear(background, 1);
      forceClear = true;
    }
    if (renderer.autoClear || forceClear) {
      renderer.clear(renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil);
    }
    if (background && (background.isCubeTexture || background.mapping === CubeUVReflectionMapping)) {
      if (boxMesh === void 0) {
        boxMesh = new Mesh(new BoxGeometry(1, 1, 1), new ShaderMaterial({
          name: "BackgroundCubeMaterial",
          uniforms: cloneUniforms(ShaderLib.cube.uniforms),
          vertexShader: ShaderLib.cube.vertexShader,
          fragmentShader: ShaderLib.cube.fragmentShader,
          side: BackSide,
          depthTest: false,
          depthWrite: false,
          fog: false
        }));
        boxMesh.geometry.deleteAttribute("normal");
        boxMesh.geometry.deleteAttribute("uv");
        boxMesh.onBeforeRender = function(renderer2, scene2, camera) {
          this.matrixWorld.copyPosition(camera.matrixWorld);
        };
        Object.defineProperty(boxMesh.material, "envMap", {
          get: function() {
            return this.uniforms.envMap.value;
          }
        });
        objects.update(boxMesh);
      }
      boxMesh.material.uniforms.envMap.value = background;
      boxMesh.material.uniforms.flipEnvMap.value = background.isCubeTexture && background.isRenderTargetTexture === false ? -1 : 1;
      if (currentBackground !== background || currentBackgroundVersion !== background.version || currentTonemapping !== renderer.toneMapping) {
        boxMesh.material.needsUpdate = true;
        currentBackground = background;
        currentBackgroundVersion = background.version;
        currentTonemapping = renderer.toneMapping;
      }
      renderList.unshift(boxMesh, boxMesh.geometry, boxMesh.material, 0, 0, null);
    } else if (background && background.isTexture) {
      if (planeMesh === void 0) {
        planeMesh = new Mesh(new PlaneGeometry(2, 2), new ShaderMaterial({
          name: "BackgroundMaterial",
          uniforms: cloneUniforms(ShaderLib.background.uniforms),
          vertexShader: ShaderLib.background.vertexShader,
          fragmentShader: ShaderLib.background.fragmentShader,
          side: FrontSide,
          depthTest: false,
          depthWrite: false,
          fog: false
        }));
        planeMesh.geometry.deleteAttribute("normal");
        Object.defineProperty(planeMesh.material, "map", {
          get: function() {
            return this.uniforms.t2D.value;
          }
        });
        objects.update(planeMesh);
      }
      planeMesh.material.uniforms.t2D.value = background;
      if (background.matrixAutoUpdate === true) {
        background.updateMatrix();
      }
      planeMesh.material.uniforms.uvTransform.value.copy(background.matrix);
      if (currentBackground !== background || currentBackgroundVersion !== background.version || currentTonemapping !== renderer.toneMapping) {
        planeMesh.material.needsUpdate = true;
        currentBackground = background;
        currentBackgroundVersion = background.version;
        currentTonemapping = renderer.toneMapping;
      }
      renderList.unshift(planeMesh, planeMesh.geometry, planeMesh.material, 0, 0, null);
    }
  }
  function setClear(color2, alpha3) {
    state.buffers.color.setClear(color2.r, color2.g, color2.b, alpha3, premultipliedAlpha);
  }
  return {
    getClearColor: function() {
      return clearColor;
    },
    setClearColor: function(color2, alpha3 = 1) {
      clearColor.set(color2);
      clearAlpha = alpha3;
      setClear(clearColor, clearAlpha);
    },
    getClearAlpha: function() {
      return clearAlpha;
    },
    setClearAlpha: function(alpha3) {
      clearAlpha = alpha3;
      setClear(clearColor, clearAlpha);
    },
    render
  };
}
function WebGLBindingStates(gl, extensions, attributes, capabilities) {
  const maxVertexAttributes = gl.getParameter(34921);
  const extension = capabilities.isWebGL2 ? null : extensions.get("OES_vertex_array_object");
  const vaoAvailable = capabilities.isWebGL2 || extension !== null;
  const bindingStates = {};
  const defaultState = createBindingState(null);
  let currentState = defaultState;
  let forceUpdate = false;
  function setup(object, material, program, geometry, index2) {
    let updateBuffers = false;
    if (vaoAvailable) {
      const state = getBindingState(geometry, program, material);
      if (currentState !== state) {
        currentState = state;
        bindVertexArrayObject(currentState.object);
      }
      updateBuffers = needsUpdate(geometry, index2);
      if (updateBuffers)
        saveCache(geometry, index2);
    } else {
      const wireframe = material.wireframe === true;
      if (currentState.geometry !== geometry.id || currentState.program !== program.id || currentState.wireframe !== wireframe) {
        currentState.geometry = geometry.id;
        currentState.program = program.id;
        currentState.wireframe = wireframe;
        updateBuffers = true;
      }
    }
    if (object.isInstancedMesh === true) {
      updateBuffers = true;
    }
    if (index2 !== null) {
      attributes.update(index2, 34963);
    }
    if (updateBuffers || forceUpdate) {
      forceUpdate = false;
      setupVertexAttributes(object, material, program, geometry);
      if (index2 !== null) {
        gl.bindBuffer(34963, attributes.get(index2).buffer);
      }
    }
  }
  function createVertexArrayObject() {
    if (capabilities.isWebGL2)
      return gl.createVertexArray();
    return extension.createVertexArrayOES();
  }
  function bindVertexArrayObject(vao) {
    if (capabilities.isWebGL2)
      return gl.bindVertexArray(vao);
    return extension.bindVertexArrayOES(vao);
  }
  function deleteVertexArrayObject(vao) {
    if (capabilities.isWebGL2)
      return gl.deleteVertexArray(vao);
    return extension.deleteVertexArrayOES(vao);
  }
  function getBindingState(geometry, program, material) {
    const wireframe = material.wireframe === true;
    let programMap = bindingStates[geometry.id];
    if (programMap === void 0) {
      programMap = {};
      bindingStates[geometry.id] = programMap;
    }
    let stateMap = programMap[program.id];
    if (stateMap === void 0) {
      stateMap = {};
      programMap[program.id] = stateMap;
    }
    let state = stateMap[wireframe];
    if (state === void 0) {
      state = createBindingState(createVertexArrayObject());
      stateMap[wireframe] = state;
    }
    return state;
  }
  function createBindingState(vao) {
    const newAttributes = [];
    const enabledAttributes = [];
    const attributeDivisors = [];
    for (let i = 0; i < maxVertexAttributes; i++) {
      newAttributes[i] = 0;
      enabledAttributes[i] = 0;
      attributeDivisors[i] = 0;
    }
    return {
      geometry: null,
      program: null,
      wireframe: false,
      newAttributes,
      enabledAttributes,
      attributeDivisors,
      object: vao,
      attributes: {},
      index: null
    };
  }
  function needsUpdate(geometry, index2) {
    const cachedAttributes = currentState.attributes;
    const geometryAttributes = geometry.attributes;
    let attributesNum = 0;
    for (const key in geometryAttributes) {
      const cachedAttribute = cachedAttributes[key];
      const geometryAttribute = geometryAttributes[key];
      if (cachedAttribute === void 0)
        return true;
      if (cachedAttribute.attribute !== geometryAttribute)
        return true;
      if (cachedAttribute.data !== geometryAttribute.data)
        return true;
      attributesNum++;
    }
    if (currentState.attributesNum !== attributesNum)
      return true;
    if (currentState.index !== index2)
      return true;
    return false;
  }
  function saveCache(geometry, index2) {
    const cache = {};
    const attributes2 = geometry.attributes;
    let attributesNum = 0;
    for (const key in attributes2) {
      const attribute = attributes2[key];
      const data = {};
      data.attribute = attribute;
      if (attribute.data) {
        data.data = attribute.data;
      }
      cache[key] = data;
      attributesNum++;
    }
    currentState.attributes = cache;
    currentState.attributesNum = attributesNum;
    currentState.index = index2;
  }
  function initAttributes() {
    const newAttributes = currentState.newAttributes;
    for (let i = 0, il = newAttributes.length; i < il; i++) {
      newAttributes[i] = 0;
    }
  }
  function enableAttribute(attribute) {
    enableAttributeAndDivisor(attribute, 0);
  }
  function enableAttributeAndDivisor(attribute, meshPerAttribute) {
    const newAttributes = currentState.newAttributes;
    const enabledAttributes = currentState.enabledAttributes;
    const attributeDivisors = currentState.attributeDivisors;
    newAttributes[attribute] = 1;
    if (enabledAttributes[attribute] === 0) {
      gl.enableVertexAttribArray(attribute);
      enabledAttributes[attribute] = 1;
    }
    if (attributeDivisors[attribute] !== meshPerAttribute) {
      const extension2 = capabilities.isWebGL2 ? gl : extensions.get("ANGLE_instanced_arrays");
      extension2[capabilities.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](attribute, meshPerAttribute);
      attributeDivisors[attribute] = meshPerAttribute;
    }
  }
  function disableUnusedAttributes() {
    const newAttributes = currentState.newAttributes;
    const enabledAttributes = currentState.enabledAttributes;
    for (let i = 0, il = enabledAttributes.length; i < il; i++) {
      if (enabledAttributes[i] !== newAttributes[i]) {
        gl.disableVertexAttribArray(i);
        enabledAttributes[i] = 0;
      }
    }
  }
  function vertexAttribPointer(index2, size2, type, normalized, stride, offset) {
    if (capabilities.isWebGL2 === true && (type === 5124 || type === 5125)) {
      gl.vertexAttribIPointer(index2, size2, type, stride, offset);
    } else {
      gl.vertexAttribPointer(index2, size2, type, normalized, stride, offset);
    }
  }
  function setupVertexAttributes(object, material, program, geometry) {
    if (capabilities.isWebGL2 === false && (object.isInstancedMesh || geometry.isInstancedBufferGeometry)) {
      if (extensions.get("ANGLE_instanced_arrays") === null)
        return;
    }
    initAttributes();
    const geometryAttributes = geometry.attributes;
    const programAttributes = program.getAttributes();
    const materialDefaultAttributeValues = material.defaultAttributeValues;
    for (const name in programAttributes) {
      const programAttribute = programAttributes[name];
      if (programAttribute.location >= 0) {
        let geometryAttribute = geometryAttributes[name];
        if (geometryAttribute === void 0) {
          if (name === "instanceMatrix" && object.instanceMatrix)
            geometryAttribute = object.instanceMatrix;
          if (name === "instanceColor" && object.instanceColor)
            geometryAttribute = object.instanceColor;
        }
        if (geometryAttribute !== void 0) {
          const normalized = geometryAttribute.normalized;
          const size2 = geometryAttribute.itemSize;
          const attribute = attributes.get(geometryAttribute);
          if (attribute === void 0)
            continue;
          const buffer = attribute.buffer;
          const type = attribute.type;
          const bytesPerElement = attribute.bytesPerElement;
          if (geometryAttribute.isInterleavedBufferAttribute) {
            const data = geometryAttribute.data;
            const stride = data.stride;
            const offset = geometryAttribute.offset;
            if (data.isInstancedInterleavedBuffer) {
              for (let i = 0; i < programAttribute.locationSize; i++) {
                enableAttributeAndDivisor(programAttribute.location + i, data.meshPerAttribute);
              }
              if (object.isInstancedMesh !== true && geometry._maxInstanceCount === void 0) {
                geometry._maxInstanceCount = data.meshPerAttribute * data.count;
              }
            } else {
              for (let i = 0; i < programAttribute.locationSize; i++) {
                enableAttribute(programAttribute.location + i);
              }
            }
            gl.bindBuffer(34962, buffer);
            for (let i = 0; i < programAttribute.locationSize; i++) {
              vertexAttribPointer(programAttribute.location + i, size2 / programAttribute.locationSize, type, normalized, stride * bytesPerElement, (offset + size2 / programAttribute.locationSize * i) * bytesPerElement);
            }
          } else {
            if (geometryAttribute.isInstancedBufferAttribute) {
              for (let i = 0; i < programAttribute.locationSize; i++) {
                enableAttributeAndDivisor(programAttribute.location + i, geometryAttribute.meshPerAttribute);
              }
              if (object.isInstancedMesh !== true && geometry._maxInstanceCount === void 0) {
                geometry._maxInstanceCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;
              }
            } else {
              for (let i = 0; i < programAttribute.locationSize; i++) {
                enableAttribute(programAttribute.location + i);
              }
            }
            gl.bindBuffer(34962, buffer);
            for (let i = 0; i < programAttribute.locationSize; i++) {
              vertexAttribPointer(programAttribute.location + i, size2 / programAttribute.locationSize, type, normalized, size2 * bytesPerElement, size2 / programAttribute.locationSize * i * bytesPerElement);
            }
          }
        } else if (materialDefaultAttributeValues !== void 0) {
          const value = materialDefaultAttributeValues[name];
          if (value !== void 0) {
            switch (value.length) {
              case 2:
                gl.vertexAttrib2fv(programAttribute.location, value);
                break;
              case 3:
                gl.vertexAttrib3fv(programAttribute.location, value);
                break;
              case 4:
                gl.vertexAttrib4fv(programAttribute.location, value);
                break;
              default:
                gl.vertexAttrib1fv(programAttribute.location, value);
            }
          }
        }
      }
    }
    disableUnusedAttributes();
  }
  function dispose() {
    reset();
    for (const geometryId in bindingStates) {
      const programMap = bindingStates[geometryId];
      for (const programId in programMap) {
        const stateMap = programMap[programId];
        for (const wireframe in stateMap) {
          deleteVertexArrayObject(stateMap[wireframe].object);
          delete stateMap[wireframe];
        }
        delete programMap[programId];
      }
      delete bindingStates[geometryId];
    }
  }
  function releaseStatesOfGeometry(geometry) {
    if (bindingStates[geometry.id] === void 0)
      return;
    const programMap = bindingStates[geometry.id];
    for (const programId in programMap) {
      const stateMap = programMap[programId];
      for (const wireframe in stateMap) {
        deleteVertexArrayObject(stateMap[wireframe].object);
        delete stateMap[wireframe];
      }
      delete programMap[programId];
    }
    delete bindingStates[geometry.id];
  }
  function releaseStatesOfProgram(program) {
    for (const geometryId in bindingStates) {
      const programMap = bindingStates[geometryId];
      if (programMap[program.id] === void 0)
        continue;
      const stateMap = programMap[program.id];
      for (const wireframe in stateMap) {
        deleteVertexArrayObject(stateMap[wireframe].object);
        delete stateMap[wireframe];
      }
      delete programMap[program.id];
    }
  }
  function reset() {
    resetDefaultState();
    forceUpdate = true;
    if (currentState === defaultState)
      return;
    currentState = defaultState;
    bindVertexArrayObject(currentState.object);
  }
  function resetDefaultState() {
    defaultState.geometry = null;
    defaultState.program = null;
    defaultState.wireframe = false;
  }
  return {
    setup,
    reset,
    resetDefaultState,
    dispose,
    releaseStatesOfGeometry,
    releaseStatesOfProgram,
    initAttributes,
    enableAttribute,
    disableUnusedAttributes
  };
}
function WebGLBufferRenderer(gl, extensions, info, capabilities) {
  const isWebGL2 = capabilities.isWebGL2;
  let mode;
  function setMode(value) {
    mode = value;
  }
  function render(start2, count) {
    gl.drawArrays(mode, start2, count);
    info.update(count, mode, 1);
  }
  function renderInstances(start2, count, primcount) {
    if (primcount === 0)
      return;
    let extension, methodName;
    if (isWebGL2) {
      extension = gl;
      methodName = "drawArraysInstanced";
    } else {
      extension = extensions.get("ANGLE_instanced_arrays");
      methodName = "drawArraysInstancedANGLE";
      if (extension === null) {
        console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
        return;
      }
    }
    extension[methodName](mode, start2, count, primcount);
    info.update(count, mode, primcount);
  }
  this.setMode = setMode;
  this.render = render;
  this.renderInstances = renderInstances;
}
function WebGLCapabilities(gl, extensions, parameters) {
  let maxAnisotropy;
  function getMaxAnisotropy() {
    if (maxAnisotropy !== void 0)
      return maxAnisotropy;
    if (extensions.has("EXT_texture_filter_anisotropic") === true) {
      const extension = extensions.get("EXT_texture_filter_anisotropic");
      maxAnisotropy = gl.getParameter(extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
    } else {
      maxAnisotropy = 0;
    }
    return maxAnisotropy;
  }
  function getMaxPrecision(precision2) {
    if (precision2 === "highp") {
      if (gl.getShaderPrecisionFormat(35633, 36338).precision > 0 && gl.getShaderPrecisionFormat(35632, 36338).precision > 0) {
        return "highp";
      }
      precision2 = "mediump";
    }
    if (precision2 === "mediump") {
      if (gl.getShaderPrecisionFormat(35633, 36337).precision > 0 && gl.getShaderPrecisionFormat(35632, 36337).precision > 0) {
        return "mediump";
      }
    }
    return "lowp";
  }
  const isWebGL2 = typeof WebGL2RenderingContext !== "undefined" && gl instanceof WebGL2RenderingContext || typeof WebGL2ComputeRenderingContext !== "undefined" && gl instanceof WebGL2ComputeRenderingContext;
  let precision = parameters.precision !== void 0 ? parameters.precision : "highp";
  const maxPrecision = getMaxPrecision(precision);
  if (maxPrecision !== precision) {
    console.warn("THREE.WebGLRenderer:", precision, "not supported, using", maxPrecision, "instead.");
    precision = maxPrecision;
  }
  const drawBuffers = isWebGL2 || extensions.has("WEBGL_draw_buffers");
  const logarithmicDepthBuffer = parameters.logarithmicDepthBuffer === true;
  const maxTextures = gl.getParameter(34930);
  const maxVertexTextures = gl.getParameter(35660);
  const maxTextureSize = gl.getParameter(3379);
  const maxCubemapSize = gl.getParameter(34076);
  const maxAttributes = gl.getParameter(34921);
  const maxVertexUniforms = gl.getParameter(36347);
  const maxVaryings = gl.getParameter(36348);
  const maxFragmentUniforms = gl.getParameter(36349);
  const vertexTextures = maxVertexTextures > 0;
  const floatFragmentTextures = isWebGL2 || extensions.has("OES_texture_float");
  const floatVertexTextures = vertexTextures && floatFragmentTextures;
  const maxSamples = isWebGL2 ? gl.getParameter(36183) : 0;
  return {
    isWebGL2,
    drawBuffers,
    getMaxAnisotropy,
    getMaxPrecision,
    precision,
    logarithmicDepthBuffer,
    maxTextures,
    maxVertexTextures,
    maxTextureSize,
    maxCubemapSize,
    maxAttributes,
    maxVertexUniforms,
    maxVaryings,
    maxFragmentUniforms,
    vertexTextures,
    floatFragmentTextures,
    floatVertexTextures,
    maxSamples
  };
}
function WebGLClipping(properties) {
  const scope = this;
  let globalState = null, numGlobalPlanes = 0, localClippingEnabled = false, renderingShadows = false;
  const plane = new Plane(), viewNormalMatrix = new Matrix3(), uniform = { value: null, needsUpdate: false };
  this.uniform = uniform;
  this.numPlanes = 0;
  this.numIntersection = 0;
  this.init = function(planes, enableLocalClipping, camera) {
    const enabled = planes.length !== 0 || enableLocalClipping || numGlobalPlanes !== 0 || localClippingEnabled;
    localClippingEnabled = enableLocalClipping;
    globalState = projectPlanes(planes, camera, 0);
    numGlobalPlanes = planes.length;
    return enabled;
  };
  this.beginShadows = function() {
    renderingShadows = true;
    projectPlanes(null);
  };
  this.endShadows = function() {
    renderingShadows = false;
    resetGlobalState();
  };
  this.setState = function(material, camera, useCache) {
    const planes = material.clippingPlanes, clipIntersection = material.clipIntersection, clipShadows = material.clipShadows;
    const materialProperties = properties.get(material);
    if (!localClippingEnabled || planes === null || planes.length === 0 || renderingShadows && !clipShadows) {
      if (renderingShadows) {
        projectPlanes(null);
      } else {
        resetGlobalState();
      }
    } else {
      const nGlobal = renderingShadows ? 0 : numGlobalPlanes, lGlobal = nGlobal * 4;
      let dstArray = materialProperties.clippingState || null;
      uniform.value = dstArray;
      dstArray = projectPlanes(planes, camera, lGlobal, useCache);
      for (let i = 0; i !== lGlobal; ++i) {
        dstArray[i] = globalState[i];
      }
      materialProperties.clippingState = dstArray;
      this.numIntersection = clipIntersection ? this.numPlanes : 0;
      this.numPlanes += nGlobal;
    }
  };
  function resetGlobalState() {
    if (uniform.value !== globalState) {
      uniform.value = globalState;
      uniform.needsUpdate = numGlobalPlanes > 0;
    }
    scope.numPlanes = numGlobalPlanes;
    scope.numIntersection = 0;
  }
  function projectPlanes(planes, camera, dstOffset, skipTransform) {
    const nPlanes = planes !== null ? planes.length : 0;
    let dstArray = null;
    if (nPlanes !== 0) {
      dstArray = uniform.value;
      if (skipTransform !== true || dstArray === null) {
        const flatSize = dstOffset + nPlanes * 4, viewMatrix = camera.matrixWorldInverse;
        viewNormalMatrix.getNormalMatrix(viewMatrix);
        if (dstArray === null || dstArray.length < flatSize) {
          dstArray = new Float32Array(flatSize);
        }
        for (let i = 0, i4 = dstOffset; i !== nPlanes; ++i, i4 += 4) {
          plane.copy(planes[i]).applyMatrix4(viewMatrix, viewNormalMatrix);
          plane.normal.toArray(dstArray, i4);
          dstArray[i4 + 3] = plane.constant;
        }
      }
      uniform.value = dstArray;
      uniform.needsUpdate = true;
    }
    scope.numPlanes = nPlanes;
    scope.numIntersection = 0;
    return dstArray;
  }
}
function WebGLCubeMaps(renderer) {
  let cubemaps = /* @__PURE__ */ new WeakMap();
  function mapTextureMapping(texture2, mapping) {
    if (mapping === EquirectangularReflectionMapping) {
      texture2.mapping = CubeReflectionMapping;
    } else if (mapping === EquirectangularRefractionMapping) {
      texture2.mapping = CubeRefractionMapping;
    }
    return texture2;
  }
  function get2(texture2) {
    if (texture2 && texture2.isTexture && texture2.isRenderTargetTexture === false) {
      const mapping = texture2.mapping;
      if (mapping === EquirectangularReflectionMapping || mapping === EquirectangularRefractionMapping) {
        if (cubemaps.has(texture2)) {
          const cubemap = cubemaps.get(texture2).texture;
          return mapTextureMapping(cubemap, texture2.mapping);
        } else {
          const image2 = texture2.image;
          if (image2 && image2.height > 0) {
            const renderTarget = new WebGLCubeRenderTarget(image2.height / 2);
            renderTarget.fromEquirectangularTexture(renderer, texture2);
            cubemaps.set(texture2, renderTarget);
            texture2.addEventListener("dispose", onTextureDispose);
            return mapTextureMapping(renderTarget.texture, texture2.mapping);
          } else {
            return null;
          }
        }
      }
    }
    return texture2;
  }
  function onTextureDispose(event) {
    const texture2 = event.target;
    texture2.removeEventListener("dispose", onTextureDispose);
    const cubemap = cubemaps.get(texture2);
    if (cubemap !== void 0) {
      cubemaps.delete(texture2);
      cubemap.dispose();
    }
  }
  function dispose() {
    cubemaps = /* @__PURE__ */ new WeakMap();
  }
  return {
    get: get2,
    dispose
  };
}
class OrthographicCamera extends Camera {
  constructor(left2 = -1, right2 = 1, top2 = 1, bottom2 = -1, near = 0.1, far = 2e3) {
    super();
    this.type = "OrthographicCamera";
    this.zoom = 1;
    this.view = null;
    this.left = left2;
    this.right = right2;
    this.top = top2;
    this.bottom = bottom2;
    this.near = near;
    this.far = far;
    this.updateProjectionMatrix();
  }
  copy(source2, recursive) {
    super.copy(source2, recursive);
    this.left = source2.left;
    this.right = source2.right;
    this.top = source2.top;
    this.bottom = source2.bottom;
    this.near = source2.near;
    this.far = source2.far;
    this.zoom = source2.zoom;
    this.view = source2.view === null ? null : Object.assign({}, source2.view);
    return this;
  }
  setViewOffset(fullWidth, fullHeight, x, y, width2, height2) {
    if (this.view === null) {
      this.view = {
        enabled: true,
        fullWidth: 1,
        fullHeight: 1,
        offsetX: 0,
        offsetY: 0,
        width: 1,
        height: 1
      };
    }
    this.view.enabled = true;
    this.view.fullWidth = fullWidth;
    this.view.fullHeight = fullHeight;
    this.view.offsetX = x;
    this.view.offsetY = y;
    this.view.width = width2;
    this.view.height = height2;
    this.updateProjectionMatrix();
  }
  clearViewOffset() {
    if (this.view !== null) {
      this.view.enabled = false;
    }
    this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    const dx = (this.right - this.left) / (2 * this.zoom);
    const dy = (this.top - this.bottom) / (2 * this.zoom);
    const cx = (this.right + this.left) / 2;
    const cy = (this.top + this.bottom) / 2;
    let left2 = cx - dx;
    let right2 = cx + dx;
    let top2 = cy + dy;
    let bottom2 = cy - dy;
    if (this.view !== null && this.view.enabled) {
      const scaleW = (this.right - this.left) / this.view.fullWidth / this.zoom;
      const scaleH2 = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
      left2 += scaleW * this.view.offsetX;
      right2 = left2 + scaleW * this.view.width;
      top2 -= scaleH2 * this.view.offsetY;
      bottom2 = top2 - scaleH2 * this.view.height;
    }
    this.projectionMatrix.makeOrthographic(left2, right2, top2, bottom2, this.near, this.far);
    this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(meta) {
    const data = super.toJSON(meta);
    data.object.zoom = this.zoom;
    data.object.left = this.left;
    data.object.right = this.right;
    data.object.top = this.top;
    data.object.bottom = this.bottom;
    data.object.near = this.near;
    data.object.far = this.far;
    if (this.view !== null)
      data.object.view = Object.assign({}, this.view);
    return data;
  }
}
OrthographicCamera.prototype.isOrthographicCamera = true;
const LOD_MIN = 4;
const EXTRA_LOD_SIGMA = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582];
const MAX_SAMPLES = 20;
const _flatCamera = /* @__PURE__ */ new OrthographicCamera();
const _clearColor = /* @__PURE__ */ new Color();
let _oldTarget = null;
const PHI = (1 + Math.sqrt(5)) / 2;
const INV_PHI = 1 / PHI;
const _axisDirections = [
  /* @__PURE__ */ new Vector3(1, 1, 1),
  /* @__PURE__ */ new Vector3(-1, 1, 1),
  /* @__PURE__ */ new Vector3(1, 1, -1),
  /* @__PURE__ */ new Vector3(-1, 1, -1),
  /* @__PURE__ */ new Vector3(0, PHI, INV_PHI),
  /* @__PURE__ */ new Vector3(0, PHI, -INV_PHI),
  /* @__PURE__ */ new Vector3(INV_PHI, 0, PHI),
  /* @__PURE__ */ new Vector3(-INV_PHI, 0, PHI),
  /* @__PURE__ */ new Vector3(PHI, INV_PHI, 0),
  /* @__PURE__ */ new Vector3(-PHI, INV_PHI, 0)
];
class PMREMGenerator {
  constructor(renderer) {
    this._renderer = renderer;
    this._pingPongRenderTarget = null;
    this._lodMax = 0;
    this._cubeSize = 0;
    this._lodPlanes = [];
    this._sizeLods = [];
    this._sigmas = [];
    this._blurMaterial = null;
    this._cubemapMaterial = null;
    this._equirectMaterial = null;
    this._compileMaterial(this._blurMaterial);
  }
  fromScene(scene, sigma = 0, near = 0.1, far = 100) {
    _oldTarget = this._renderer.getRenderTarget();
    this._setSize(256);
    const cubeUVRenderTarget = this._allocateTargets();
    cubeUVRenderTarget.depthBuffer = true;
    this._sceneToCubeUV(scene, near, far, cubeUVRenderTarget);
    if (sigma > 0) {
      this._blur(cubeUVRenderTarget, 0, 0, sigma);
    }
    this._applyPMREM(cubeUVRenderTarget);
    this._cleanup(cubeUVRenderTarget);
    return cubeUVRenderTarget;
  }
  fromEquirectangular(equirectangular, renderTarget = null) {
    return this._fromTexture(equirectangular, renderTarget);
  }
  fromCubemap(cubemap, renderTarget = null) {
    return this._fromTexture(cubemap, renderTarget);
  }
  compileCubemapShader() {
    if (this._cubemapMaterial === null) {
      this._cubemapMaterial = _getCubemapMaterial();
      this._compileMaterial(this._cubemapMaterial);
    }
  }
  compileEquirectangularShader() {
    if (this._equirectMaterial === null) {
      this._equirectMaterial = _getEquirectMaterial();
      this._compileMaterial(this._equirectMaterial);
    }
  }
  dispose() {
    this._dispose();
    if (this._cubemapMaterial !== null)
      this._cubemapMaterial.dispose();
    if (this._equirectMaterial !== null)
      this._equirectMaterial.dispose();
  }
  _setSize(cubeSize) {
    this._lodMax = Math.floor(Math.log2(cubeSize));
    this._cubeSize = Math.pow(2, this._lodMax);
  }
  _dispose() {
    if (this._blurMaterial !== null)
      this._blurMaterial.dispose();
    if (this._pingPongRenderTarget !== null)
      this._pingPongRenderTarget.dispose();
    for (let i = 0; i < this._lodPlanes.length; i++) {
      this._lodPlanes[i].dispose();
    }
  }
  _cleanup(outputTarget) {
    this._renderer.setRenderTarget(_oldTarget);
    outputTarget.scissorTest = false;
    _setViewport(outputTarget, 0, 0, outputTarget.width, outputTarget.height);
  }
  _fromTexture(texture2, renderTarget) {
    if (texture2.mapping === CubeReflectionMapping || texture2.mapping === CubeRefractionMapping) {
      this._setSize(texture2.image.length === 0 ? 16 : texture2.image[0].width || texture2.image[0].image.width);
    } else {
      this._setSize(texture2.image.width / 4);
    }
    _oldTarget = this._renderer.getRenderTarget();
    const cubeUVRenderTarget = renderTarget || this._allocateTargets();
    this._textureToCubeUV(texture2, cubeUVRenderTarget);
    this._applyPMREM(cubeUVRenderTarget);
    this._cleanup(cubeUVRenderTarget);
    return cubeUVRenderTarget;
  }
  _allocateTargets() {
    const width2 = 3 * Math.max(this._cubeSize, 16 * 7);
    const height2 = 4 * this._cubeSize - 32;
    const params = {
      magFilter: LinearFilter,
      minFilter: LinearFilter,
      generateMipmaps: false,
      type: HalfFloatType,
      format: RGBAFormat,
      encoding: LinearEncoding,
      depthBuffer: false
    };
    const cubeUVRenderTarget = _createRenderTarget(width2, height2, params);
    if (this._pingPongRenderTarget === null || this._pingPongRenderTarget.width !== width2) {
      if (this._pingPongRenderTarget !== null) {
        this._dispose();
      }
      this._pingPongRenderTarget = _createRenderTarget(width2, height2, params);
      const { _lodMax } = this;
      ({ sizeLods: this._sizeLods, lodPlanes: this._lodPlanes, sigmas: this._sigmas } = _createPlanes(_lodMax));
      this._blurMaterial = _getBlurShader(_lodMax, width2, height2);
    }
    return cubeUVRenderTarget;
  }
  _compileMaterial(material) {
    const tmpMesh = new Mesh(this._lodPlanes[0], material);
    this._renderer.compile(tmpMesh, _flatCamera);
  }
  _sceneToCubeUV(scene, near, far, cubeUVRenderTarget) {
    const fov2 = 90;
    const aspect2 = 1;
    const cubeCamera = new PerspectiveCamera(fov2, aspect2, near, far);
    const upSign = [1, -1, 1, 1, 1, 1];
    const forwardSign = [1, 1, 1, -1, -1, -1];
    const renderer = this._renderer;
    const originalAutoClear = renderer.autoClear;
    const toneMapping = renderer.toneMapping;
    renderer.getClearColor(_clearColor);
    renderer.toneMapping = NoToneMapping;
    renderer.autoClear = false;
    const backgroundMaterial = new MeshBasicMaterial({
      name: "PMREM.Background",
      side: BackSide,
      depthWrite: false,
      depthTest: false
    });
    const backgroundBox = new Mesh(new BoxGeometry(), backgroundMaterial);
    let useSolidColor = false;
    const background = scene.background;
    if (background) {
      if (background.isColor) {
        backgroundMaterial.color.copy(background);
        scene.background = null;
        useSolidColor = true;
      }
    } else {
      backgroundMaterial.color.copy(_clearColor);
      useSolidColor = true;
    }
    for (let i = 0; i < 6; i++) {
      const col = i % 3;
      if (col === 0) {
        cubeCamera.up.set(0, upSign[i], 0);
        cubeCamera.lookAt(forwardSign[i], 0, 0);
      } else if (col === 1) {
        cubeCamera.up.set(0, 0, upSign[i]);
        cubeCamera.lookAt(0, forwardSign[i], 0);
      } else {
        cubeCamera.up.set(0, upSign[i], 0);
        cubeCamera.lookAt(0, 0, forwardSign[i]);
      }
      const size2 = this._cubeSize;
      _setViewport(cubeUVRenderTarget, col * size2, i > 2 ? size2 : 0, size2, size2);
      renderer.setRenderTarget(cubeUVRenderTarget);
      if (useSolidColor) {
        renderer.render(backgroundBox, cubeCamera);
      }
      renderer.render(scene, cubeCamera);
    }
    backgroundBox.geometry.dispose();
    backgroundBox.material.dispose();
    renderer.toneMapping = toneMapping;
    renderer.autoClear = originalAutoClear;
    scene.background = background;
  }
  _textureToCubeUV(texture2, cubeUVRenderTarget) {
    const renderer = this._renderer;
    const isCubeTexture = texture2.mapping === CubeReflectionMapping || texture2.mapping === CubeRefractionMapping;
    if (isCubeTexture) {
      if (this._cubemapMaterial === null) {
        this._cubemapMaterial = _getCubemapMaterial();
      }
      this._cubemapMaterial.uniforms.flipEnvMap.value = texture2.isRenderTargetTexture === false ? -1 : 1;
    } else {
      if (this._equirectMaterial === null) {
        this._equirectMaterial = _getEquirectMaterial();
      }
    }
    const material = isCubeTexture ? this._cubemapMaterial : this._equirectMaterial;
    const mesh = new Mesh(this._lodPlanes[0], material);
    const uniforms = material.uniforms;
    uniforms["envMap"].value = texture2;
    const size2 = this._cubeSize;
    _setViewport(cubeUVRenderTarget, 0, 0, 3 * size2, 2 * size2);
    renderer.setRenderTarget(cubeUVRenderTarget);
    renderer.render(mesh, _flatCamera);
  }
  _applyPMREM(cubeUVRenderTarget) {
    const renderer = this._renderer;
    const autoClear = renderer.autoClear;
    renderer.autoClear = false;
    for (let i = 1; i < this._lodPlanes.length; i++) {
      const sigma = Math.sqrt(this._sigmas[i] * this._sigmas[i] - this._sigmas[i - 1] * this._sigmas[i - 1]);
      const poleAxis = _axisDirections[(i - 1) % _axisDirections.length];
      this._blur(cubeUVRenderTarget, i - 1, i, sigma, poleAxis);
    }
    renderer.autoClear = autoClear;
  }
  _blur(cubeUVRenderTarget, lodIn, lodOut, sigma, poleAxis) {
    const pingPongRenderTarget = this._pingPongRenderTarget;
    this._halfBlur(cubeUVRenderTarget, pingPongRenderTarget, lodIn, lodOut, sigma, "latitudinal", poleAxis);
    this._halfBlur(pingPongRenderTarget, cubeUVRenderTarget, lodOut, lodOut, sigma, "longitudinal", poleAxis);
  }
  _halfBlur(targetIn, targetOut, lodIn, lodOut, sigmaRadians, direction2, poleAxis) {
    const renderer = this._renderer;
    const blurMaterial = this._blurMaterial;
    if (direction2 !== "latitudinal" && direction2 !== "longitudinal") {
      console.error("blur direction must be either latitudinal or longitudinal!");
    }
    const STANDARD_DEVIATIONS = 3;
    const blurMesh = new Mesh(this._lodPlanes[lodOut], blurMaterial);
    const blurUniforms = blurMaterial.uniforms;
    const pixels = this._sizeLods[lodIn] - 1;
    const radiansPerPixel = isFinite(sigmaRadians) ? Math.PI / (2 * pixels) : 2 * Math.PI / (2 * MAX_SAMPLES - 1);
    const sigmaPixels = sigmaRadians / radiansPerPixel;
    const samples = isFinite(sigmaRadians) ? 1 + Math.floor(STANDARD_DEVIATIONS * sigmaPixels) : MAX_SAMPLES;
    if (samples > MAX_SAMPLES) {
      console.warn(`sigmaRadians, ${sigmaRadians}, is too large and will clip, as it requested ${samples} samples when the maximum is set to ${MAX_SAMPLES}`);
    }
    const weights = [];
    let sum = 0;
    for (let i = 0; i < MAX_SAMPLES; ++i) {
      const x2 = i / sigmaPixels;
      const weight = Math.exp(-x2 * x2 / 2);
      weights.push(weight);
      if (i === 0) {
        sum += weight;
      } else if (i < samples) {
        sum += 2 * weight;
      }
    }
    for (let i = 0; i < weights.length; i++) {
      weights[i] = weights[i] / sum;
    }
    blurUniforms["envMap"].value = targetIn.texture;
    blurUniforms["samples"].value = samples;
    blurUniforms["weights"].value = weights;
    blurUniforms["latitudinal"].value = direction2 === "latitudinal";
    if (poleAxis) {
      blurUniforms["poleAxis"].value = poleAxis;
    }
    const { _lodMax } = this;
    blurUniforms["dTheta"].value = radiansPerPixel;
    blurUniforms["mipInt"].value = _lodMax - lodIn;
    const outputSize = this._sizeLods[lodOut];
    const x = 3 * outputSize * (lodOut > _lodMax - LOD_MIN ? lodOut - _lodMax + LOD_MIN : 0);
    const y = 4 * (this._cubeSize - outputSize);
    _setViewport(targetOut, x, y, 3 * outputSize, 2 * outputSize);
    renderer.setRenderTarget(targetOut);
    renderer.render(blurMesh, _flatCamera);
  }
}
function _createPlanes(lodMax) {
  const lodPlanes = [];
  const sizeLods = [];
  const sigmas = [];
  let lod = lodMax;
  const totalLods = lodMax - LOD_MIN + 1 + EXTRA_LOD_SIGMA.length;
  for (let i = 0; i < totalLods; i++) {
    const sizeLod = Math.pow(2, lod);
    sizeLods.push(sizeLod);
    let sigma = 1 / sizeLod;
    if (i > lodMax - LOD_MIN) {
      sigma = EXTRA_LOD_SIGMA[i - lodMax + LOD_MIN - 1];
    } else if (i === 0) {
      sigma = 0;
    }
    sigmas.push(sigma);
    const texelSize = 1 / (sizeLod - 1);
    const min = -texelSize / 2;
    const max = 1 + texelSize / 2;
    const uv1 = [min, min, max, min, max, max, min, min, max, max, min, max];
    const cubeFaces = 6;
    const vertices = 6;
    const positionSize = 3;
    const uvSize = 2;
    const faceIndexSize = 1;
    const position2 = new Float32Array(positionSize * vertices * cubeFaces);
    const uv = new Float32Array(uvSize * vertices * cubeFaces);
    const faceIndex = new Float32Array(faceIndexSize * vertices * cubeFaces);
    for (let face2 = 0; face2 < cubeFaces; face2++) {
      const x = face2 % 3 * 2 / 3 - 1;
      const y = face2 > 2 ? 0 : -1;
      const coordinates = [
        x,
        y,
        0,
        x + 2 / 3,
        y,
        0,
        x + 2 / 3,
        y + 1,
        0,
        x,
        y,
        0,
        x + 2 / 3,
        y + 1,
        0,
        x,
        y + 1,
        0
      ];
      position2.set(coordinates, positionSize * vertices * face2);
      uv.set(uv1, uvSize * vertices * face2);
      const fill = [face2, face2, face2, face2, face2, face2];
      faceIndex.set(fill, faceIndexSize * vertices * face2);
    }
    const planes = new BufferGeometry();
    planes.setAttribute("position", new BufferAttribute(position2, positionSize));
    planes.setAttribute("uv", new BufferAttribute(uv, uvSize));
    planes.setAttribute("faceIndex", new BufferAttribute(faceIndex, faceIndexSize));
    lodPlanes.push(planes);
    if (lod > LOD_MIN) {
      lod--;
    }
  }
  return { lodPlanes, sizeLods, sigmas };
}
function _createRenderTarget(width2, height2, params) {
  const cubeUVRenderTarget = new WebGLRenderTarget(width2, height2, params);
  cubeUVRenderTarget.texture.mapping = CubeUVReflectionMapping;
  cubeUVRenderTarget.texture.name = "PMREM.cubeUv";
  cubeUVRenderTarget.scissorTest = true;
  return cubeUVRenderTarget;
}
function _setViewport(target, x, y, width2, height2) {
  target.viewport.set(x, y, width2, height2);
  target.scissor.set(x, y, width2, height2);
}
function _getBlurShader(lodMax, width2, height2) {
  const weights = new Float32Array(MAX_SAMPLES);
  const poleAxis = new Vector3(0, 1, 0);
  const shaderMaterial = new ShaderMaterial({
    name: "SphericalGaussianBlur",
    defines: {
      "n": MAX_SAMPLES,
      "CUBEUV_TEXEL_WIDTH": 1 / width2,
      "CUBEUV_TEXEL_HEIGHT": 1 / height2,
      "CUBEUV_MAX_MIP": `${lodMax}.0`
    },
    uniforms: {
      "envMap": { value: null },
      "samples": { value: 1 },
      "weights": { value: weights },
      "latitudinal": { value: false },
      "dTheta": { value: 0 },
      "mipInt": { value: 0 },
      "poleAxis": { value: poleAxis }
    },
    vertexShader: _getCommonVertexShader(),
    fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`,
    blending: NoBlending,
    depthTest: false,
    depthWrite: false
  });
  return shaderMaterial;
}
function _getEquirectMaterial() {
  return new ShaderMaterial({
    name: "EquirectangularToCubeUV",
    uniforms: {
      "envMap": { value: null }
    },
    vertexShader: _getCommonVertexShader(),
    fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`,
    blending: NoBlending,
    depthTest: false,
    depthWrite: false
  });
}
function _getCubemapMaterial() {
  return new ShaderMaterial({
    name: "CubemapToCubeUV",
    uniforms: {
      "envMap": { value: null },
      "flipEnvMap": { value: -1 }
    },
    vertexShader: _getCommonVertexShader(),
    fragmentShader: `

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`,
    blending: NoBlending,
    depthTest: false,
    depthWrite: false
  });
}
function _getCommonVertexShader() {
  return `

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`;
}
function WebGLCubeUVMaps(renderer) {
  let cubeUVmaps = /* @__PURE__ */ new WeakMap();
  let pmremGenerator = null;
  function get2(texture2) {
    if (texture2 && texture2.isTexture) {
      const mapping = texture2.mapping;
      const isEquirectMap = mapping === EquirectangularReflectionMapping || mapping === EquirectangularRefractionMapping;
      const isCubeMap = mapping === CubeReflectionMapping || mapping === CubeRefractionMapping;
      if (isEquirectMap || isCubeMap) {
        if (texture2.isRenderTargetTexture && texture2.needsPMREMUpdate === true) {
          texture2.needsPMREMUpdate = false;
          let renderTarget = cubeUVmaps.get(texture2);
          if (pmremGenerator === null)
            pmremGenerator = new PMREMGenerator(renderer);
          renderTarget = isEquirectMap ? pmremGenerator.fromEquirectangular(texture2, renderTarget) : pmremGenerator.fromCubemap(texture2, renderTarget);
          cubeUVmaps.set(texture2, renderTarget);
          return renderTarget.texture;
        } else {
          if (cubeUVmaps.has(texture2)) {
            return cubeUVmaps.get(texture2).texture;
          } else {
            const image2 = texture2.image;
            if (isEquirectMap && image2 && image2.height > 0 || isCubeMap && image2 && isCubeTextureComplete(image2)) {
              if (pmremGenerator === null)
                pmremGenerator = new PMREMGenerator(renderer);
              const renderTarget = isEquirectMap ? pmremGenerator.fromEquirectangular(texture2) : pmremGenerator.fromCubemap(texture2);
              cubeUVmaps.set(texture2, renderTarget);
              texture2.addEventListener("dispose", onTextureDispose);
              return renderTarget.texture;
            } else {
              return null;
            }
          }
        }
      }
    }
    return texture2;
  }
  function isCubeTextureComplete(image2) {
    let count = 0;
    const length2 = 6;
    for (let i = 0; i < length2; i++) {
      if (image2[i] !== void 0)
        count++;
    }
    return count === length2;
  }
  function onTextureDispose(event) {
    const texture2 = event.target;
    texture2.removeEventListener("dispose", onTextureDispose);
    const cubemapUV = cubeUVmaps.get(texture2);
    if (cubemapUV !== void 0) {
      cubeUVmaps.delete(texture2);
      cubemapUV.dispose();
    }
  }
  function dispose() {
    cubeUVmaps = /* @__PURE__ */ new WeakMap();
    if (pmremGenerator !== null) {
      pmremGenerator.dispose();
      pmremGenerator = null;
    }
  }
  return {
    get: get2,
    dispose
  };
}
function WebGLExtensions(gl) {
  const extensions = {};
  function getExtension(name) {
    if (extensions[name] !== void 0) {
      return extensions[name];
    }
    let extension;
    switch (name) {
      case "WEBGL_depth_texture":
        extension = gl.getExtension("WEBGL_depth_texture") || gl.getExtension("MOZ_WEBGL_depth_texture") || gl.getExtension("WEBKIT_WEBGL_depth_texture");
        break;
      case "EXT_texture_filter_anisotropic":
        extension = gl.getExtension("EXT_texture_filter_anisotropic") || gl.getExtension("MOZ_EXT_texture_filter_anisotropic") || gl.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
        break;
      case "WEBGL_compressed_texture_s3tc":
        extension = gl.getExtension("WEBGL_compressed_texture_s3tc") || gl.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || gl.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
        break;
      case "WEBGL_compressed_texture_pvrtc":
        extension = gl.getExtension("WEBGL_compressed_texture_pvrtc") || gl.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
        break;
      default:
        extension = gl.getExtension(name);
    }
    extensions[name] = extension;
    return extension;
  }
  return {
    has: function(name) {
      return getExtension(name) !== null;
    },
    init: function(capabilities) {
      if (capabilities.isWebGL2) {
        getExtension("EXT_color_buffer_float");
      } else {
        getExtension("WEBGL_depth_texture");
        getExtension("OES_texture_float");
        getExtension("OES_texture_half_float");
        getExtension("OES_texture_half_float_linear");
        getExtension("OES_standard_derivatives");
        getExtension("OES_element_index_uint");
        getExtension("OES_vertex_array_object");
        getExtension("ANGLE_instanced_arrays");
      }
      getExtension("OES_texture_float_linear");
      getExtension("EXT_color_buffer_half_float");
      getExtension("WEBGL_multisampled_render_to_texture");
    },
    get: function(name) {
      const extension = getExtension(name);
      if (extension === null) {
        console.warn("THREE.WebGLRenderer: " + name + " extension not supported.");
      }
      return extension;
    }
  };
}
function WebGLGeometries(gl, attributes, info, bindingStates) {
  const geometries = {};
  const wireframeAttributes = /* @__PURE__ */ new WeakMap();
  function onGeometryDispose(event) {
    const geometry = event.target;
    if (geometry.index !== null) {
      attributes.remove(geometry.index);
    }
    for (const name in geometry.attributes) {
      attributes.remove(geometry.attributes[name]);
    }
    geometry.removeEventListener("dispose", onGeometryDispose);
    delete geometries[geometry.id];
    const attribute = wireframeAttributes.get(geometry);
    if (attribute) {
      attributes.remove(attribute);
      wireframeAttributes.delete(geometry);
    }
    bindingStates.releaseStatesOfGeometry(geometry);
    if (geometry.isInstancedBufferGeometry === true) {
      delete geometry._maxInstanceCount;
    }
    info.memory.geometries--;
  }
  function get2(object, geometry) {
    if (geometries[geometry.id] === true)
      return geometry;
    geometry.addEventListener("dispose", onGeometryDispose);
    geometries[geometry.id] = true;
    info.memory.geometries++;
    return geometry;
  }
  function update2(geometry) {
    const geometryAttributes = geometry.attributes;
    for (const name in geometryAttributes) {
      attributes.update(geometryAttributes[name], 34962);
    }
    const morphAttributes = geometry.morphAttributes;
    for (const name in morphAttributes) {
      const array = morphAttributes[name];
      for (let i = 0, l = array.length; i < l; i++) {
        attributes.update(array[i], 34962);
      }
    }
  }
  function updateWireframeAttribute(geometry) {
    const indices = [];
    const geometryIndex = geometry.index;
    const geometryPosition = geometry.attributes.position;
    let version = 0;
    if (geometryIndex !== null) {
      const array = geometryIndex.array;
      version = geometryIndex.version;
      for (let i = 0, l = array.length; i < l; i += 3) {
        const a = array[i + 0];
        const b = array[i + 1];
        const c2 = array[i + 2];
        indices.push(a, b, b, c2, c2, a);
      }
    } else {
      const array = geometryPosition.array;
      version = geometryPosition.version;
      for (let i = 0, l = array.length / 3 - 1; i < l; i += 3) {
        const a = i + 0;
        const b = i + 1;
        const c2 = i + 2;
        indices.push(a, b, b, c2, c2, a);
      }
    }
    const attribute = new (arrayNeedsUint32(indices) ? Uint32BufferAttribute : Uint16BufferAttribute)(indices, 1);
    attribute.version = version;
    const previousAttribute = wireframeAttributes.get(geometry);
    if (previousAttribute)
      attributes.remove(previousAttribute);
    wireframeAttributes.set(geometry, attribute);
  }
  function getWireframeAttribute(geometry) {
    const currentAttribute = wireframeAttributes.get(geometry);
    if (currentAttribute) {
      const geometryIndex = geometry.index;
      if (geometryIndex !== null) {
        if (currentAttribute.version < geometryIndex.version) {
          updateWireframeAttribute(geometry);
        }
      }
    } else {
      updateWireframeAttribute(geometry);
    }
    return wireframeAttributes.get(geometry);
  }
  return {
    get: get2,
    update: update2,
    getWireframeAttribute
  };
}
function WebGLIndexedBufferRenderer(gl, extensions, info, capabilities) {
  const isWebGL2 = capabilities.isWebGL2;
  let mode;
  function setMode(value) {
    mode = value;
  }
  let type, bytesPerElement;
  function setIndex(value) {
    type = value.type;
    bytesPerElement = value.bytesPerElement;
  }
  function render(start2, count) {
    gl.drawElements(mode, count, type, start2 * bytesPerElement);
    info.update(count, mode, 1);
  }
  function renderInstances(start2, count, primcount) {
    if (primcount === 0)
      return;
    let extension, methodName;
    if (isWebGL2) {
      extension = gl;
      methodName = "drawElementsInstanced";
    } else {
      extension = extensions.get("ANGLE_instanced_arrays");
      methodName = "drawElementsInstancedANGLE";
      if (extension === null) {
        console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
        return;
      }
    }
    extension[methodName](mode, count, type, start2 * bytesPerElement, primcount);
    info.update(count, mode, primcount);
  }
  this.setMode = setMode;
  this.setIndex = setIndex;
  this.render = render;
  this.renderInstances = renderInstances;
}
function WebGLInfo(gl) {
  const memory = {
    geometries: 0,
    textures: 0
  };
  const render = {
    frame: 0,
    calls: 0,
    triangles: 0,
    points: 0,
    lines: 0
  };
  function update2(count, mode, instanceCount) {
    render.calls++;
    switch (mode) {
      case 4:
        render.triangles += instanceCount * (count / 3);
        break;
      case 1:
        render.lines += instanceCount * (count / 2);
        break;
      case 3:
        render.lines += instanceCount * (count - 1);
        break;
      case 2:
        render.lines += instanceCount * count;
        break;
      case 0:
        render.points += instanceCount * count;
        break;
      default:
        console.error("THREE.WebGLInfo: Unknown draw mode:", mode);
        break;
    }
  }
  function reset() {
    render.frame++;
    render.calls = 0;
    render.triangles = 0;
    render.points = 0;
    render.lines = 0;
  }
  return {
    memory,
    render,
    programs: null,
    autoReset: true,
    reset,
    update: update2
  };
}
function numericalSort(a, b) {
  return a[0] - b[0];
}
function absNumericalSort(a, b) {
  return Math.abs(b[1]) - Math.abs(a[1]);
}
function denormalize(morph, attribute) {
  let denominator = 1;
  const array = attribute.isInterleavedBufferAttribute ? attribute.data.array : attribute.array;
  if (array instanceof Int8Array)
    denominator = 127;
  else if (array instanceof Int16Array)
    denominator = 32767;
  else if (array instanceof Int32Array)
    denominator = 2147483647;
  else
    console.error("THREE.WebGLMorphtargets: Unsupported morph attribute data type: ", array);
  morph.divideScalar(denominator);
}
function WebGLMorphtargets(gl, capabilities, textures) {
  const influencesList = {};
  const morphInfluences = new Float32Array(8);
  const morphTextures = /* @__PURE__ */ new WeakMap();
  const morph = new Vector4();
  const workInfluences = [];
  for (let i = 0; i < 8; i++) {
    workInfluences[i] = [i, 0];
  }
  function update2(object, geometry, material, program) {
    const objectInfluences = object.morphTargetInfluences;
    if (capabilities.isWebGL2 === true) {
      const morphAttribute = geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color;
      const morphTargetsCount = morphAttribute !== void 0 ? morphAttribute.length : 0;
      let entry = morphTextures.get(geometry);
      if (entry === void 0 || entry.count !== morphTargetsCount) {
        let disposeTexture = function() {
          texture2.dispose();
          morphTextures.delete(geometry);
          geometry.removeEventListener("dispose", disposeTexture);
        };
        if (entry !== void 0)
          entry.texture.dispose();
        const hasMorphPosition = geometry.morphAttributes.position !== void 0;
        const hasMorphNormals = geometry.morphAttributes.normal !== void 0;
        const hasMorphColors = geometry.morphAttributes.color !== void 0;
        const morphTargets = geometry.morphAttributes.position || [];
        const morphNormals = geometry.morphAttributes.normal || [];
        const morphColors = geometry.morphAttributes.color || [];
        let vertexDataCount = 0;
        if (hasMorphPosition === true)
          vertexDataCount = 1;
        if (hasMorphNormals === true)
          vertexDataCount = 2;
        if (hasMorphColors === true)
          vertexDataCount = 3;
        let width2 = geometry.attributes.position.count * vertexDataCount;
        let height2 = 1;
        if (width2 > capabilities.maxTextureSize) {
          height2 = Math.ceil(width2 / capabilities.maxTextureSize);
          width2 = capabilities.maxTextureSize;
        }
        const buffer = new Float32Array(width2 * height2 * 4 * morphTargetsCount);
        const texture2 = new DataArrayTexture(buffer, width2, height2, morphTargetsCount);
        texture2.type = FloatType;
        texture2.needsUpdate = true;
        const vertexDataStride = vertexDataCount * 4;
        for (let i = 0; i < morphTargetsCount; i++) {
          const morphTarget = morphTargets[i];
          const morphNormal = morphNormals[i];
          const morphColor = morphColors[i];
          const offset = width2 * height2 * 4 * i;
          for (let j = 0; j < morphTarget.count; j++) {
            const stride = j * vertexDataStride;
            if (hasMorphPosition === true) {
              morph.fromBufferAttribute(morphTarget, j);
              if (morphTarget.normalized === true)
                denormalize(morph, morphTarget);
              buffer[offset + stride + 0] = morph.x;
              buffer[offset + stride + 1] = morph.y;
              buffer[offset + stride + 2] = morph.z;
              buffer[offset + stride + 3] = 0;
            }
            if (hasMorphNormals === true) {
              morph.fromBufferAttribute(morphNormal, j);
              if (morphNormal.normalized === true)
                denormalize(morph, morphNormal);
              buffer[offset + stride + 4] = morph.x;
              buffer[offset + stride + 5] = morph.y;
              buffer[offset + stride + 6] = morph.z;
              buffer[offset + stride + 7] = 0;
            }
            if (hasMorphColors === true) {
              morph.fromBufferAttribute(morphColor, j);
              if (morphColor.normalized === true)
                denormalize(morph, morphColor);
              buffer[offset + stride + 8] = morph.x;
              buffer[offset + stride + 9] = morph.y;
              buffer[offset + stride + 10] = morph.z;
              buffer[offset + stride + 11] = morphColor.itemSize === 4 ? morph.w : 1;
            }
          }
        }
        entry = {
          count: morphTargetsCount,
          texture: texture2,
          size: new Vector2(width2, height2)
        };
        morphTextures.set(geometry, entry);
        geometry.addEventListener("dispose", disposeTexture);
      }
      let morphInfluencesSum = 0;
      for (let i = 0; i < objectInfluences.length; i++) {
        morphInfluencesSum += objectInfluences[i];
      }
      const morphBaseInfluence = geometry.morphTargetsRelative ? 1 : 1 - morphInfluencesSum;
      program.getUniforms().setValue(gl, "morphTargetBaseInfluence", morphBaseInfluence);
      program.getUniforms().setValue(gl, "morphTargetInfluences", objectInfluences);
      program.getUniforms().setValue(gl, "morphTargetsTexture", entry.texture, textures);
      program.getUniforms().setValue(gl, "morphTargetsTextureSize", entry.size);
    } else {
      const length2 = objectInfluences === void 0 ? 0 : objectInfluences.length;
      let influences = influencesList[geometry.id];
      if (influences === void 0 || influences.length !== length2) {
        influences = [];
        for (let i = 0; i < length2; i++) {
          influences[i] = [i, 0];
        }
        influencesList[geometry.id] = influences;
      }
      for (let i = 0; i < length2; i++) {
        const influence = influences[i];
        influence[0] = i;
        influence[1] = objectInfluences[i];
      }
      influences.sort(absNumericalSort);
      for (let i = 0; i < 8; i++) {
        if (i < length2 && influences[i][1]) {
          workInfluences[i][0] = influences[i][0];
          workInfluences[i][1] = influences[i][1];
        } else {
          workInfluences[i][0] = Number.MAX_SAFE_INTEGER;
          workInfluences[i][1] = 0;
        }
      }
      workInfluences.sort(numericalSort);
      const morphTargets = geometry.morphAttributes.position;
      const morphNormals = geometry.morphAttributes.normal;
      let morphInfluencesSum = 0;
      for (let i = 0; i < 8; i++) {
        const influence = workInfluences[i];
        const index2 = influence[0];
        const value = influence[1];
        if (index2 !== Number.MAX_SAFE_INTEGER && value) {
          if (morphTargets && geometry.getAttribute("morphTarget" + i) !== morphTargets[index2]) {
            geometry.setAttribute("morphTarget" + i, morphTargets[index2]);
          }
          if (morphNormals && geometry.getAttribute("morphNormal" + i) !== morphNormals[index2]) {
            geometry.setAttribute("morphNormal" + i, morphNormals[index2]);
          }
          morphInfluences[i] = value;
          morphInfluencesSum += value;
        } else {
          if (morphTargets && geometry.hasAttribute("morphTarget" + i) === true) {
            geometry.deleteAttribute("morphTarget" + i);
          }
          if (morphNormals && geometry.hasAttribute("morphNormal" + i) === true) {
            geometry.deleteAttribute("morphNormal" + i);
          }
          morphInfluences[i] = 0;
        }
      }
      const morphBaseInfluence = geometry.morphTargetsRelative ? 1 : 1 - morphInfluencesSum;
      program.getUniforms().setValue(gl, "morphTargetBaseInfluence", morphBaseInfluence);
      program.getUniforms().setValue(gl, "morphTargetInfluences", morphInfluences);
    }
  }
  return {
    update: update2
  };
}
function WebGLObjects(gl, geometries, attributes, info) {
  let updateMap = /* @__PURE__ */ new WeakMap();
  function update2(object) {
    const frame = info.render.frame;
    const geometry = object.geometry;
    const buffergeometry = geometries.get(object, geometry);
    if (updateMap.get(buffergeometry) !== frame) {
      geometries.update(buffergeometry);
      updateMap.set(buffergeometry, frame);
    }
    if (object.isInstancedMesh) {
      if (object.hasEventListener("dispose", onInstancedMeshDispose) === false) {
        object.addEventListener("dispose", onInstancedMeshDispose);
      }
      attributes.update(object.instanceMatrix, 34962);
      if (object.instanceColor !== null) {
        attributes.update(object.instanceColor, 34962);
      }
    }
    return buffergeometry;
  }
  function dispose() {
    updateMap = /* @__PURE__ */ new WeakMap();
  }
  function onInstancedMeshDispose(event) {
    const instancedMesh = event.target;
    instancedMesh.removeEventListener("dispose", onInstancedMeshDispose);
    attributes.remove(instancedMesh.instanceMatrix);
    if (instancedMesh.instanceColor !== null)
      attributes.remove(instancedMesh.instanceColor);
  }
  return {
    update: update2,
    dispose
  };
}
const emptyTexture = new Texture();
const emptyArrayTexture = new DataArrayTexture();
const empty3dTexture = new Data3DTexture();
const emptyCubeTexture = new CubeTexture();
const arrayCacheF32 = [];
const arrayCacheI32 = [];
const mat4array = new Float32Array(16);
const mat3array = new Float32Array(9);
const mat2array = new Float32Array(4);
function flatten(array, nBlocks, blockSize) {
  const firstElem = array[0];
  if (firstElem <= 0 || firstElem > 0)
    return array;
  const n = nBlocks * blockSize;
  let r = arrayCacheF32[n];
  if (r === void 0) {
    r = new Float32Array(n);
    arrayCacheF32[n] = r;
  }
  if (nBlocks !== 0) {
    firstElem.toArray(r, 0);
    for (let i = 1, offset = 0; i !== nBlocks; ++i) {
      offset += blockSize;
      array[i].toArray(r, offset);
    }
  }
  return r;
}
function arraysEqual(a, b) {
  if (a.length !== b.length)
    return false;
  for (let i = 0, l = a.length; i < l; i++) {
    if (a[i] !== b[i])
      return false;
  }
  return true;
}
function copyArray(a, b) {
  for (let i = 0, l = b.length; i < l; i++) {
    a[i] = b[i];
  }
}
function allocTexUnits(textures, n) {
  let r = arrayCacheI32[n];
  if (r === void 0) {
    r = new Int32Array(n);
    arrayCacheI32[n] = r;
  }
  for (let i = 0; i !== n; ++i) {
    r[i] = textures.allocateTextureUnit();
  }
  return r;
}
function setValueV1f(gl, v) {
  const cache = this.cache;
  if (cache[0] === v)
    return;
  gl.uniform1f(this.addr, v);
  cache[0] = v;
}
function setValueV2f(gl, v) {
  const cache = this.cache;
  if (v.x !== void 0) {
    if (cache[0] !== v.x || cache[1] !== v.y) {
      gl.uniform2f(this.addr, v.x, v.y);
      cache[0] = v.x;
      cache[1] = v.y;
    }
  } else {
    if (arraysEqual(cache, v))
      return;
    gl.uniform2fv(this.addr, v);
    copyArray(cache, v);
  }
}
function setValueV3f(gl, v) {
  const cache = this.cache;
  if (v.x !== void 0) {
    if (cache[0] !== v.x || cache[1] !== v.y || cache[2] !== v.z) {
      gl.uniform3f(this.addr, v.x, v.y, v.z);
      cache[0] = v.x;
      cache[1] = v.y;
      cache[2] = v.z;
    }
  } else if (v.r !== void 0) {
    if (cache[0] !== v.r || cache[1] !== v.g || cache[2] !== v.b) {
      gl.uniform3f(this.addr, v.r, v.g, v.b);
      cache[0] = v.r;
      cache[1] = v.g;
      cache[2] = v.b;
    }
  } else {
    if (arraysEqual(cache, v))
      return;
    gl.uniform3fv(this.addr, v);
    copyArray(cache, v);
  }
}
function setValueV4f(gl, v) {
  const cache = this.cache;
  if (v.x !== void 0) {
    if (cache[0] !== v.x || cache[1] !== v.y || cache[2] !== v.z || cache[3] !== v.w) {
      gl.uniform4f(this.addr, v.x, v.y, v.z, v.w);
      cache[0] = v.x;
      cache[1] = v.y;
      cache[2] = v.z;
      cache[3] = v.w;
    }
  } else {
    if (arraysEqual(cache, v))
      return;
    gl.uniform4fv(this.addr, v);
    copyArray(cache, v);
  }
}
function setValueM2(gl, v) {
  const cache = this.cache;
  const elements = v.elements;
  if (elements === void 0) {
    if (arraysEqual(cache, v))
      return;
    gl.uniformMatrix2fv(this.addr, false, v);
    copyArray(cache, v);
  } else {
    if (arraysEqual(cache, elements))
      return;
    mat2array.set(elements);
    gl.uniformMatrix2fv(this.addr, false, mat2array);
    copyArray(cache, elements);
  }
}
function setValueM3(gl, v) {
  const cache = this.cache;
  const elements = v.elements;
  if (elements === void 0) {
    if (arraysEqual(cache, v))
      return;
    gl.uniformMatrix3fv(this.addr, false, v);
    copyArray(cache, v);
  } else {
    if (arraysEqual(cache, elements))
      return;
    mat3array.set(elements);
    gl.uniformMatrix3fv(this.addr, false, mat3array);
    copyArray(cache, elements);
  }
}
function setValueM4(gl, v) {
  const cache = this.cache;
  const elements = v.elements;
  if (elements === void 0) {
    if (arraysEqual(cache, v))
      return;
    gl.uniformMatrix4fv(this.addr, false, v);
    copyArray(cache, v);
  } else {
    if (arraysEqual(cache, elements))
      return;
    mat4array.set(elements);
    gl.uniformMatrix4fv(this.addr, false, mat4array);
    copyArray(cache, elements);
  }
}
function setValueV1i(gl, v) {
  const cache = this.cache;
  if (cache[0] === v)
    return;
  gl.uniform1i(this.addr, v);
  cache[0] = v;
}
function setValueV2i(gl, v) {
  const cache = this.cache;
  if (arraysEqual(cache, v))
    return;
  gl.uniform2iv(this.addr, v);
  copyArray(cache, v);
}
function setValueV3i(gl, v) {
  const cache = this.cache;
  if (arraysEqual(cache, v))
    return;
  gl.uniform3iv(this.addr, v);
  copyArray(cache, v);
}
function setValueV4i(gl, v) {
  const cache = this.cache;
  if (arraysEqual(cache, v))
    return;
  gl.uniform4iv(this.addr, v);
  copyArray(cache, v);
}
function setValueV1ui(gl, v) {
  const cache = this.cache;
  if (cache[0] === v)
    return;
  gl.uniform1ui(this.addr, v);
  cache[0] = v;
}
function setValueV2ui(gl, v) {
  const cache = this.cache;
  if (arraysEqual(cache, v))
    return;
  gl.uniform2uiv(this.addr, v);
  copyArray(cache, v);
}
function setValueV3ui(gl, v) {
  const cache = this.cache;
  if (arraysEqual(cache, v))
    return;
  gl.uniform3uiv(this.addr, v);
  copyArray(cache, v);
}
function setValueV4ui(gl, v) {
  const cache = this.cache;
  if (arraysEqual(cache, v))
    return;
  gl.uniform4uiv(this.addr, v);
  copyArray(cache, v);
}
function setValueT1(gl, v, textures) {
  const cache = this.cache;
  const unit = textures.allocateTextureUnit();
  if (cache[0] !== unit) {
    gl.uniform1i(this.addr, unit);
    cache[0] = unit;
  }
  textures.setTexture2D(v || emptyTexture, unit);
}
function setValueT3D1(gl, v, textures) {
  const cache = this.cache;
  const unit = textures.allocateTextureUnit();
  if (cache[0] !== unit) {
    gl.uniform1i(this.addr, unit);
    cache[0] = unit;
  }
  textures.setTexture3D(v || empty3dTexture, unit);
}
function setValueT6(gl, v, textures) {
  const cache = this.cache;
  const unit = textures.allocateTextureUnit();
  if (cache[0] !== unit) {
    gl.uniform1i(this.addr, unit);
    cache[0] = unit;
  }
  textures.setTextureCube(v || emptyCubeTexture, unit);
}
function setValueT2DArray1(gl, v, textures) {
  const cache = this.cache;
  const unit = textures.allocateTextureUnit();
  if (cache[0] !== unit) {
    gl.uniform1i(this.addr, unit);
    cache[0] = unit;
  }
  textures.setTexture2DArray(v || emptyArrayTexture, unit);
}
function getSingularSetter(type) {
  switch (type) {
    case 5126:
      return setValueV1f;
    case 35664:
      return setValueV2f;
    case 35665:
      return setValueV3f;
    case 35666:
      return setValueV4f;
    case 35674:
      return setValueM2;
    case 35675:
      return setValueM3;
    case 35676:
      return setValueM4;
    case 5124:
    case 35670:
      return setValueV1i;
    case 35667:
    case 35671:
      return setValueV2i;
    case 35668:
    case 35672:
      return setValueV3i;
    case 35669:
    case 35673:
      return setValueV4i;
    case 5125:
      return setValueV1ui;
    case 36294:
      return setValueV2ui;
    case 36295:
      return setValueV3ui;
    case 36296:
      return setValueV4ui;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return setValueT1;
    case 35679:
    case 36299:
    case 36307:
      return setValueT3D1;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return setValueT6;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
      return setValueT2DArray1;
  }
}
function setValueV1fArray(gl, v) {
  gl.uniform1fv(this.addr, v);
}
function setValueV2fArray(gl, v) {
  const data = flatten(v, this.size, 2);
  gl.uniform2fv(this.addr, data);
}
function setValueV3fArray(gl, v) {
  const data = flatten(v, this.size, 3);
  gl.uniform3fv(this.addr, data);
}
function setValueV4fArray(gl, v) {
  const data = flatten(v, this.size, 4);
  gl.uniform4fv(this.addr, data);
}
function setValueM2Array(gl, v) {
  const data = flatten(v, this.size, 4);
  gl.uniformMatrix2fv(this.addr, false, data);
}
function setValueM3Array(gl, v) {
  const data = flatten(v, this.size, 9);
  gl.uniformMatrix3fv(this.addr, false, data);
}
function setValueM4Array(gl, v) {
  const data = flatten(v, this.size, 16);
  gl.uniformMatrix4fv(this.addr, false, data);
}
function setValueV1iArray(gl, v) {
  gl.uniform1iv(this.addr, v);
}
function setValueV2iArray(gl, v) {
  gl.uniform2iv(this.addr, v);
}
function setValueV3iArray(gl, v) {
  gl.uniform3iv(this.addr, v);
}
function setValueV4iArray(gl, v) {
  gl.uniform4iv(this.addr, v);
}
function setValueV1uiArray(gl, v) {
  gl.uniform1uiv(this.addr, v);
}
function setValueV2uiArray(gl, v) {
  gl.uniform2uiv(this.addr, v);
}
function setValueV3uiArray(gl, v) {
  gl.uniform3uiv(this.addr, v);
}
function setValueV4uiArray(gl, v) {
  gl.uniform4uiv(this.addr, v);
}
function setValueT1Array(gl, v, textures) {
  const n = v.length;
  const units = allocTexUnits(textures, n);
  gl.uniform1iv(this.addr, units);
  for (let i = 0; i !== n; ++i) {
    textures.setTexture2D(v[i] || emptyTexture, units[i]);
  }
}
function setValueT3DArray(gl, v, textures) {
  const n = v.length;
  const units = allocTexUnits(textures, n);
  gl.uniform1iv(this.addr, units);
  for (let i = 0; i !== n; ++i) {
    textures.setTexture3D(v[i] || empty3dTexture, units[i]);
  }
}
function setValueT6Array(gl, v, textures) {
  const n = v.length;
  const units = allocTexUnits(textures, n);
  gl.uniform1iv(this.addr, units);
  for (let i = 0; i !== n; ++i) {
    textures.setTextureCube(v[i] || emptyCubeTexture, units[i]);
  }
}
function setValueT2DArrayArray(gl, v, textures) {
  const n = v.length;
  const units = allocTexUnits(textures, n);
  gl.uniform1iv(this.addr, units);
  for (let i = 0; i !== n; ++i) {
    textures.setTexture2DArray(v[i] || emptyArrayTexture, units[i]);
  }
}
function getPureArraySetter(type) {
  switch (type) {
    case 5126:
      return setValueV1fArray;
    case 35664:
      return setValueV2fArray;
    case 35665:
      return setValueV3fArray;
    case 35666:
      return setValueV4fArray;
    case 35674:
      return setValueM2Array;
    case 35675:
      return setValueM3Array;
    case 35676:
      return setValueM4Array;
    case 5124:
    case 35670:
      return setValueV1iArray;
    case 35667:
    case 35671:
      return setValueV2iArray;
    case 35668:
    case 35672:
      return setValueV3iArray;
    case 35669:
    case 35673:
      return setValueV4iArray;
    case 5125:
      return setValueV1uiArray;
    case 36294:
      return setValueV2uiArray;
    case 36295:
      return setValueV3uiArray;
    case 36296:
      return setValueV4uiArray;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return setValueT1Array;
    case 35679:
    case 36299:
    case 36307:
      return setValueT3DArray;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return setValueT6Array;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
      return setValueT2DArrayArray;
  }
}
function SingleUniform(id, activeInfo, addr) {
  this.id = id;
  this.addr = addr;
  this.cache = [];
  this.setValue = getSingularSetter(activeInfo.type);
}
function PureArrayUniform(id, activeInfo, addr) {
  this.id = id;
  this.addr = addr;
  this.cache = [];
  this.size = activeInfo.size;
  this.setValue = getPureArraySetter(activeInfo.type);
}
PureArrayUniform.prototype.updateCache = function(data) {
  const cache = this.cache;
  if (data instanceof Float32Array && cache.length !== data.length) {
    this.cache = new Float32Array(data.length);
  }
  copyArray(cache, data);
};
function StructuredUniform(id) {
  this.id = id;
  this.seq = [];
  this.map = {};
}
StructuredUniform.prototype.setValue = function(gl, value, textures) {
  const seq = this.seq;
  for (let i = 0, n = seq.length; i !== n; ++i) {
    const u = seq[i];
    u.setValue(gl, value[u.id], textures);
  }
};
const RePathPart = /(\w+)(\])?(\[|\.)?/g;
function addUniform(container, uniformObject) {
  container.seq.push(uniformObject);
  container.map[uniformObject.id] = uniformObject;
}
function parseUniform(activeInfo, addr, container) {
  const path = activeInfo.name, pathLength = path.length;
  RePathPart.lastIndex = 0;
  while (true) {
    const match = RePathPart.exec(path), matchEnd = RePathPart.lastIndex;
    let id = match[1];
    const idIsIndex = match[2] === "]", subscript = match[3];
    if (idIsIndex)
      id = id | 0;
    if (subscript === void 0 || subscript === "[" && matchEnd + 2 === pathLength) {
      addUniform(container, subscript === void 0 ? new SingleUniform(id, activeInfo, addr) : new PureArrayUniform(id, activeInfo, addr));
      break;
    } else {
      const map2 = container.map;
      let next = map2[id];
      if (next === void 0) {
        next = new StructuredUniform(id);
        addUniform(container, next);
      }
      container = next;
    }
  }
}
function WebGLUniforms(gl, program) {
  this.seq = [];
  this.map = {};
  const n = gl.getProgramParameter(program, 35718);
  for (let i = 0; i < n; ++i) {
    const info = gl.getActiveUniform(program, i), addr = gl.getUniformLocation(program, info.name);
    parseUniform(info, addr, this);
  }
}
WebGLUniforms.prototype.setValue = function(gl, name, value, textures) {
  const u = this.map[name];
  if (u !== void 0)
    u.setValue(gl, value, textures);
};
WebGLUniforms.prototype.setOptional = function(gl, object, name) {
  const v = object[name];
  if (v !== void 0)
    this.setValue(gl, name, v);
};
WebGLUniforms.upload = function(gl, seq, values, textures) {
  for (let i = 0, n = seq.length; i !== n; ++i) {
    const u = seq[i], v = values[u.id];
    if (v.needsUpdate !== false) {
      u.setValue(gl, v.value, textures);
    }
  }
};
WebGLUniforms.seqWithValue = function(seq, values) {
  const r = [];
  for (let i = 0, n = seq.length; i !== n; ++i) {
    const u = seq[i];
    if (u.id in values)
      r.push(u);
  }
  return r;
};
function WebGLShader(gl, type, string) {
  const shader = gl.createShader(type);
  gl.shaderSource(shader, string);
  gl.compileShader(shader);
  return shader;
}
let programIdCount = 0;
function handleSource(string, errorLine) {
  const lines = string.split("\n");
  const lines2 = [];
  const from = Math.max(errorLine - 6, 0);
  const to = Math.min(errorLine + 6, lines.length);
  for (let i = from; i < to; i++) {
    lines2.push(i + 1 + ": " + lines[i]);
  }
  return lines2.join("\n");
}
function getEncodingComponents(encoding) {
  switch (encoding) {
    case LinearEncoding:
      return ["Linear", "( value )"];
    case sRGBEncoding:
      return ["sRGB", "( value )"];
    default:
      console.warn("THREE.WebGLProgram: Unsupported encoding:", encoding);
      return ["Linear", "( value )"];
  }
}
function getShaderErrors(gl, shader, type) {
  const status = gl.getShaderParameter(shader, 35713);
  const errors = gl.getShaderInfoLog(shader).trim();
  if (status && errors === "")
    return "";
  const errorLine = parseInt(/ERROR: 0:(\d+)/.exec(errors)[1]);
  return type.toUpperCase() + "\n\n" + errors + "\n\n" + handleSource(gl.getShaderSource(shader), errorLine);
}
function getTexelEncodingFunction(functionName, encoding) {
  const components = getEncodingComponents(encoding);
  return "vec4 " + functionName + "( vec4 value ) { return LinearTo" + components[0] + components[1] + "; }";
}
function getToneMappingFunction(functionName, toneMapping) {
  let toneMappingName;
  switch (toneMapping) {
    case LinearToneMapping:
      toneMappingName = "Linear";
      break;
    case ReinhardToneMapping:
      toneMappingName = "Reinhard";
      break;
    case CineonToneMapping:
      toneMappingName = "OptimizedCineon";
      break;
    case ACESFilmicToneMapping:
      toneMappingName = "ACESFilmic";
      break;
    case CustomToneMapping:
      toneMappingName = "Custom";
      break;
    default:
      console.warn("THREE.WebGLProgram: Unsupported toneMapping:", toneMapping);
      toneMappingName = "Linear";
  }
  return "vec3 " + functionName + "( vec3 color ) { return " + toneMappingName + "ToneMapping( color ); }";
}
function generateExtensions(parameters) {
  const chunks = [
    parameters.extensionDerivatives || !!parameters.envMapCubeUVHeight || parameters.bumpMap || parameters.tangentSpaceNormalMap || parameters.clearcoatNormalMap || parameters.flatShading || parameters.shaderID === "physical" ? "#extension GL_OES_standard_derivatives : enable" : "",
    (parameters.extensionFragDepth || parameters.logarithmicDepthBuffer) && parameters.rendererExtensionFragDepth ? "#extension GL_EXT_frag_depth : enable" : "",
    parameters.extensionDrawBuffers && parameters.rendererExtensionDrawBuffers ? "#extension GL_EXT_draw_buffers : require" : "",
    (parameters.extensionShaderTextureLOD || parameters.envMap || parameters.transmission) && parameters.rendererExtensionShaderTextureLod ? "#extension GL_EXT_shader_texture_lod : enable" : ""
  ];
  return chunks.filter(filterEmptyLine).join("\n");
}
function generateDefines(defines) {
  const chunks = [];
  for (const name in defines) {
    const value = defines[name];
    if (value === false)
      continue;
    chunks.push("#define " + name + " " + value);
  }
  return chunks.join("\n");
}
function fetchAttributeLocations(gl, program) {
  const attributes = {};
  const n = gl.getProgramParameter(program, 35721);
  for (let i = 0; i < n; i++) {
    const info = gl.getActiveAttrib(program, i);
    const name = info.name;
    let locationSize = 1;
    if (info.type === 35674)
      locationSize = 2;
    if (info.type === 35675)
      locationSize = 3;
    if (info.type === 35676)
      locationSize = 4;
    attributes[name] = {
      type: info.type,
      location: gl.getAttribLocation(program, name),
      locationSize
    };
  }
  return attributes;
}
function filterEmptyLine(string) {
  return string !== "";
}
function replaceLightNums(string, parameters) {
  return string.replace(/NUM_DIR_LIGHTS/g, parameters.numDirLights).replace(/NUM_SPOT_LIGHTS/g, parameters.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, parameters.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, parameters.numPointLights).replace(/NUM_HEMI_LIGHTS/g, parameters.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, parameters.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g, parameters.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, parameters.numPointLightShadows);
}
function replaceClippingPlaneNums(string, parameters) {
  return string.replace(/NUM_CLIPPING_PLANES/g, parameters.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, parameters.numClippingPlanes - parameters.numClipIntersection);
}
const includePattern = /^[ \t]*#include +<([\w\d./]+)>/gm;
function resolveIncludes(string) {
  return string.replace(includePattern, includeReplacer);
}
function includeReplacer(match, include) {
  const string = ShaderChunk[include];
  if (string === void 0) {
    throw new Error("Can not resolve #include <" + include + ">");
  }
  return resolveIncludes(string);
}
const deprecatedUnrollLoopPattern = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g;
const unrollLoopPattern = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
function unrollLoops(string) {
  return string.replace(unrollLoopPattern, loopReplacer).replace(deprecatedUnrollLoopPattern, deprecatedLoopReplacer);
}
function deprecatedLoopReplacer(match, start2, end2, snippet) {
  console.warn("WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead.");
  return loopReplacer(match, start2, end2, snippet);
}
function loopReplacer(match, start2, end2, snippet) {
  let string = "";
  for (let i = parseInt(start2); i < parseInt(end2); i++) {
    string += snippet.replace(/\[\s*i\s*\]/g, "[ " + i + " ]").replace(/UNROLLED_LOOP_INDEX/g, i);
  }
  return string;
}
function generatePrecision(parameters) {
  let precisionstring = "precision " + parameters.precision + " float;\nprecision " + parameters.precision + " int;";
  if (parameters.precision === "highp") {
    precisionstring += "\n#define HIGH_PRECISION";
  } else if (parameters.precision === "mediump") {
    precisionstring += "\n#define MEDIUM_PRECISION";
  } else if (parameters.precision === "lowp") {
    precisionstring += "\n#define LOW_PRECISION";
  }
  return precisionstring;
}
function generateShadowMapTypeDefine(parameters) {
  let shadowMapTypeDefine = "SHADOWMAP_TYPE_BASIC";
  if (parameters.shadowMapType === PCFShadowMap) {
    shadowMapTypeDefine = "SHADOWMAP_TYPE_PCF";
  } else if (parameters.shadowMapType === PCFSoftShadowMap) {
    shadowMapTypeDefine = "SHADOWMAP_TYPE_PCF_SOFT";
  } else if (parameters.shadowMapType === VSMShadowMap) {
    shadowMapTypeDefine = "SHADOWMAP_TYPE_VSM";
  }
  return shadowMapTypeDefine;
}
function generateEnvMapTypeDefine(parameters) {
  let envMapTypeDefine = "ENVMAP_TYPE_CUBE";
  if (parameters.envMap) {
    switch (parameters.envMapMode) {
      case CubeReflectionMapping:
      case CubeRefractionMapping:
        envMapTypeDefine = "ENVMAP_TYPE_CUBE";
        break;
      case CubeUVReflectionMapping:
        envMapTypeDefine = "ENVMAP_TYPE_CUBE_UV";
        break;
    }
  }
  return envMapTypeDefine;
}
function generateEnvMapModeDefine(parameters) {
  let envMapModeDefine = "ENVMAP_MODE_REFLECTION";
  if (parameters.envMap) {
    switch (parameters.envMapMode) {
      case CubeRefractionMapping:
        envMapModeDefine = "ENVMAP_MODE_REFRACTION";
        break;
    }
  }
  return envMapModeDefine;
}
function generateEnvMapBlendingDefine(parameters) {
  let envMapBlendingDefine = "ENVMAP_BLENDING_NONE";
  if (parameters.envMap) {
    switch (parameters.combine) {
      case MultiplyOperation:
        envMapBlendingDefine = "ENVMAP_BLENDING_MULTIPLY";
        break;
      case MixOperation:
        envMapBlendingDefine = "ENVMAP_BLENDING_MIX";
        break;
      case AddOperation:
        envMapBlendingDefine = "ENVMAP_BLENDING_ADD";
        break;
    }
  }
  return envMapBlendingDefine;
}
function generateCubeUVSize(parameters) {
  const imageHeight = parameters.envMapCubeUVHeight;
  if (imageHeight === null)
    return null;
  const maxMip = Math.log2(imageHeight / 32 + 1) + 3;
  const texelHeight = 1 / imageHeight;
  const texelWidth = 1 / (3 * Math.max(Math.pow(2, maxMip), 7 * 16));
  return { texelWidth, texelHeight, maxMip };
}
function WebGLProgram(renderer, cacheKey2, parameters, bindingStates) {
  const gl = renderer.getContext();
  const defines = parameters.defines;
  let vertexShader = parameters.vertexShader;
  let fragmentShader = parameters.fragmentShader;
  const shadowMapTypeDefine = generateShadowMapTypeDefine(parameters);
  const envMapTypeDefine = generateEnvMapTypeDefine(parameters);
  const envMapModeDefine = generateEnvMapModeDefine(parameters);
  const envMapBlendingDefine = generateEnvMapBlendingDefine(parameters);
  const envMapCubeUVSize = generateCubeUVSize(parameters);
  const customExtensions = parameters.isWebGL2 ? "" : generateExtensions(parameters);
  const customDefines = generateDefines(defines);
  const program = gl.createProgram();
  let prefixVertex, prefixFragment;
  let versionString = parameters.glslVersion ? "#version " + parameters.glslVersion + "\n" : "";
  if (parameters.isRawShaderMaterial) {
    prefixVertex = [
      customDefines
    ].filter(filterEmptyLine).join("\n");
    if (prefixVertex.length > 0) {
      prefixVertex += "\n";
    }
    prefixFragment = [
      customExtensions,
      customDefines
    ].filter(filterEmptyLine).join("\n");
    if (prefixFragment.length > 0) {
      prefixFragment += "\n";
    }
  } else {
    prefixVertex = [
      generatePrecision(parameters),
      "#define SHADER_NAME " + parameters.shaderName,
      customDefines,
      parameters.instancing ? "#define USE_INSTANCING" : "",
      parameters.instancingColor ? "#define USE_INSTANCING_COLOR" : "",
      parameters.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "",
      "#define MAX_BONES " + parameters.maxBones,
      parameters.useFog && parameters.fog ? "#define USE_FOG" : "",
      parameters.useFog && parameters.fogExp2 ? "#define FOG_EXP2" : "",
      parameters.map ? "#define USE_MAP" : "",
      parameters.envMap ? "#define USE_ENVMAP" : "",
      parameters.envMap ? "#define " + envMapModeDefine : "",
      parameters.lightMap ? "#define USE_LIGHTMAP" : "",
      parameters.aoMap ? "#define USE_AOMAP" : "",
      parameters.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
      parameters.bumpMap ? "#define USE_BUMPMAP" : "",
      parameters.normalMap ? "#define USE_NORMALMAP" : "",
      parameters.normalMap && parameters.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "",
      parameters.normalMap && parameters.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "",
      parameters.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
      parameters.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
      parameters.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
      parameters.displacementMap && parameters.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "",
      parameters.specularMap ? "#define USE_SPECULARMAP" : "",
      parameters.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "",
      parameters.specularColorMap ? "#define USE_SPECULARCOLORMAP" : "",
      parameters.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
      parameters.metalnessMap ? "#define USE_METALNESSMAP" : "",
      parameters.alphaMap ? "#define USE_ALPHAMAP" : "",
      parameters.transmission ? "#define USE_TRANSMISSION" : "",
      parameters.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
      parameters.thicknessMap ? "#define USE_THICKNESSMAP" : "",
      parameters.sheenColorMap ? "#define USE_SHEENCOLORMAP" : "",
      parameters.sheenRoughnessMap ? "#define USE_SHEENROUGHNESSMAP" : "",
      parameters.vertexTangents ? "#define USE_TANGENT" : "",
      parameters.vertexColors ? "#define USE_COLOR" : "",
      parameters.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
      parameters.vertexUvs ? "#define USE_UV" : "",
      parameters.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "",
      parameters.flatShading ? "#define FLAT_SHADED" : "",
      parameters.skinning ? "#define USE_SKINNING" : "",
      parameters.useVertexTexture ? "#define BONE_TEXTURE" : "",
      parameters.morphTargets ? "#define USE_MORPHTARGETS" : "",
      parameters.morphNormals && parameters.flatShading === false ? "#define USE_MORPHNORMALS" : "",
      parameters.morphColors && parameters.isWebGL2 ? "#define USE_MORPHCOLORS" : "",
      parameters.morphTargetsCount > 0 && parameters.isWebGL2 ? "#define MORPHTARGETS_TEXTURE" : "",
      parameters.morphTargetsCount > 0 && parameters.isWebGL2 ? "#define MORPHTARGETS_TEXTURE_STRIDE " + parameters.morphTextureStride : "",
      parameters.morphTargetsCount > 0 && parameters.isWebGL2 ? "#define MORPHTARGETS_COUNT " + parameters.morphTargetsCount : "",
      parameters.doubleSided ? "#define DOUBLE_SIDED" : "",
      parameters.flipSided ? "#define FLIP_SIDED" : "",
      parameters.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
      parameters.shadowMapEnabled ? "#define " + shadowMapTypeDefine : "",
      parameters.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",
      parameters.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
      parameters.logarithmicDepthBuffer && parameters.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "",
      "uniform mat4 modelMatrix;",
      "uniform mat4 modelViewMatrix;",
      "uniform mat4 projectionMatrix;",
      "uniform mat4 viewMatrix;",
      "uniform mat3 normalMatrix;",
      "uniform vec3 cameraPosition;",
      "uniform bool isOrthographic;",
      "#ifdef USE_INSTANCING",
      "	attribute mat4 instanceMatrix;",
      "#endif",
      "#ifdef USE_INSTANCING_COLOR",
      "	attribute vec3 instanceColor;",
      "#endif",
      "attribute vec3 position;",
      "attribute vec3 normal;",
      "attribute vec2 uv;",
      "#ifdef USE_TANGENT",
      "	attribute vec4 tangent;",
      "#endif",
      "#if defined( USE_COLOR_ALPHA )",
      "	attribute vec4 color;",
      "#elif defined( USE_COLOR )",
      "	attribute vec3 color;",
      "#endif",
      "#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )",
      "	attribute vec3 morphTarget0;",
      "	attribute vec3 morphTarget1;",
      "	attribute vec3 morphTarget2;",
      "	attribute vec3 morphTarget3;",
      "	#ifdef USE_MORPHNORMALS",
      "		attribute vec3 morphNormal0;",
      "		attribute vec3 morphNormal1;",
      "		attribute vec3 morphNormal2;",
      "		attribute vec3 morphNormal3;",
      "	#else",
      "		attribute vec3 morphTarget4;",
      "		attribute vec3 morphTarget5;",
      "		attribute vec3 morphTarget6;",
      "		attribute vec3 morphTarget7;",
      "	#endif",
      "#endif",
      "#ifdef USE_SKINNING",
      "	attribute vec4 skinIndex;",
      "	attribute vec4 skinWeight;",
      "#endif",
      "\n"
    ].filter(filterEmptyLine).join("\n");
    prefixFragment = [
      customExtensions,
      generatePrecision(parameters),
      "#define SHADER_NAME " + parameters.shaderName,
      customDefines,
      parameters.useFog && parameters.fog ? "#define USE_FOG" : "",
      parameters.useFog && parameters.fogExp2 ? "#define FOG_EXP2" : "",
      parameters.map ? "#define USE_MAP" : "",
      parameters.matcap ? "#define USE_MATCAP" : "",
      parameters.envMap ? "#define USE_ENVMAP" : "",
      parameters.envMap ? "#define " + envMapTypeDefine : "",
      parameters.envMap ? "#define " + envMapModeDefine : "",
      parameters.envMap ? "#define " + envMapBlendingDefine : "",
      envMapCubeUVSize ? "#define CUBEUV_TEXEL_WIDTH " + envMapCubeUVSize.texelWidth : "",
      envMapCubeUVSize ? "#define CUBEUV_TEXEL_HEIGHT " + envMapCubeUVSize.texelHeight : "",
      envMapCubeUVSize ? "#define CUBEUV_MAX_MIP " + envMapCubeUVSize.maxMip + ".0" : "",
      parameters.lightMap ? "#define USE_LIGHTMAP" : "",
      parameters.aoMap ? "#define USE_AOMAP" : "",
      parameters.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
      parameters.bumpMap ? "#define USE_BUMPMAP" : "",
      parameters.normalMap ? "#define USE_NORMALMAP" : "",
      parameters.normalMap && parameters.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "",
      parameters.normalMap && parameters.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "",
      parameters.clearcoat ? "#define USE_CLEARCOAT" : "",
      parameters.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
      parameters.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
      parameters.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
      parameters.specularMap ? "#define USE_SPECULARMAP" : "",
      parameters.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "",
      parameters.specularColorMap ? "#define USE_SPECULARCOLORMAP" : "",
      parameters.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
      parameters.metalnessMap ? "#define USE_METALNESSMAP" : "",
      parameters.alphaMap ? "#define USE_ALPHAMAP" : "",
      parameters.alphaTest ? "#define USE_ALPHATEST" : "",
      parameters.sheen ? "#define USE_SHEEN" : "",
      parameters.sheenColorMap ? "#define USE_SHEENCOLORMAP" : "",
      parameters.sheenRoughnessMap ? "#define USE_SHEENROUGHNESSMAP" : "",
      parameters.transmission ? "#define USE_TRANSMISSION" : "",
      parameters.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
      parameters.thicknessMap ? "#define USE_THICKNESSMAP" : "",
      parameters.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "",
      parameters.vertexTangents ? "#define USE_TANGENT" : "",
      parameters.vertexColors || parameters.instancingColor ? "#define USE_COLOR" : "",
      parameters.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
      parameters.vertexUvs ? "#define USE_UV" : "",
      parameters.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "",
      parameters.gradientMap ? "#define USE_GRADIENTMAP" : "",
      parameters.flatShading ? "#define FLAT_SHADED" : "",
      parameters.doubleSided ? "#define DOUBLE_SIDED" : "",
      parameters.flipSided ? "#define FLIP_SIDED" : "",
      parameters.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
      parameters.shadowMapEnabled ? "#define " + shadowMapTypeDefine : "",
      parameters.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "",
      parameters.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "",
      parameters.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
      parameters.logarithmicDepthBuffer && parameters.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "",
      "uniform mat4 viewMatrix;",
      "uniform vec3 cameraPosition;",
      "uniform bool isOrthographic;",
      parameters.toneMapping !== NoToneMapping ? "#define TONE_MAPPING" : "",
      parameters.toneMapping !== NoToneMapping ? ShaderChunk["tonemapping_pars_fragment"] : "",
      parameters.toneMapping !== NoToneMapping ? getToneMappingFunction("toneMapping", parameters.toneMapping) : "",
      parameters.dithering ? "#define DITHERING" : "",
      parameters.opaque ? "#define OPAQUE" : "",
      ShaderChunk["encodings_pars_fragment"],
      getTexelEncodingFunction("linearToOutputTexel", parameters.outputEncoding),
      parameters.depthPacking ? "#define DEPTH_PACKING " + parameters.depthPacking : "",
      "\n"
    ].filter(filterEmptyLine).join("\n");
  }
  vertexShader = resolveIncludes(vertexShader);
  vertexShader = replaceLightNums(vertexShader, parameters);
  vertexShader = replaceClippingPlaneNums(vertexShader, parameters);
  fragmentShader = resolveIncludes(fragmentShader);
  fragmentShader = replaceLightNums(fragmentShader, parameters);
  fragmentShader = replaceClippingPlaneNums(fragmentShader, parameters);
  vertexShader = unrollLoops(vertexShader);
  fragmentShader = unrollLoops(fragmentShader);
  if (parameters.isWebGL2 && parameters.isRawShaderMaterial !== true) {
    versionString = "#version 300 es\n";
    prefixVertex = [
      "precision mediump sampler2DArray;",
      "#define attribute in",
      "#define varying out",
      "#define texture2D texture"
    ].join("\n") + "\n" + prefixVertex;
    prefixFragment = [
      "#define varying in",
      parameters.glslVersion === GLSL3 ? "" : "layout(location = 0) out highp vec4 pc_fragColor;",
      parameters.glslVersion === GLSL3 ? "" : "#define gl_FragColor pc_fragColor",
      "#define gl_FragDepthEXT gl_FragDepth",
      "#define texture2D texture",
      "#define textureCube texture",
      "#define texture2DProj textureProj",
      "#define texture2DLodEXT textureLod",
      "#define texture2DProjLodEXT textureProjLod",
      "#define textureCubeLodEXT textureLod",
      "#define texture2DGradEXT textureGrad",
      "#define texture2DProjGradEXT textureProjGrad",
      "#define textureCubeGradEXT textureGrad"
    ].join("\n") + "\n" + prefixFragment;
  }
  const vertexGlsl = versionString + prefixVertex + vertexShader;
  const fragmentGlsl = versionString + prefixFragment + fragmentShader;
  const glVertexShader = WebGLShader(gl, 35633, vertexGlsl);
  const glFragmentShader = WebGLShader(gl, 35632, fragmentGlsl);
  gl.attachShader(program, glVertexShader);
  gl.attachShader(program, glFragmentShader);
  if (parameters.index0AttributeName !== void 0) {
    gl.bindAttribLocation(program, 0, parameters.index0AttributeName);
  } else if (parameters.morphTargets === true) {
    gl.bindAttribLocation(program, 0, "position");
  }
  gl.linkProgram(program);
  if (renderer.debug.checkShaderErrors) {
    const programLog = gl.getProgramInfoLog(program).trim();
    const vertexLog = gl.getShaderInfoLog(glVertexShader).trim();
    const fragmentLog = gl.getShaderInfoLog(glFragmentShader).trim();
    let runnable = true;
    let haveDiagnostics = true;
    if (gl.getProgramParameter(program, 35714) === false) {
      runnable = false;
      const vertexErrors = getShaderErrors(gl, glVertexShader, "vertex");
      const fragmentErrors = getShaderErrors(gl, glFragmentShader, "fragment");
      console.error("THREE.WebGLProgram: Shader Error " + gl.getError() + " - VALIDATE_STATUS " + gl.getProgramParameter(program, 35715) + "\n\nProgram Info Log: " + programLog + "\n" + vertexErrors + "\n" + fragmentErrors);
    } else if (programLog !== "") {
      console.warn("THREE.WebGLProgram: Program Info Log:", programLog);
    } else if (vertexLog === "" || fragmentLog === "") {
      haveDiagnostics = false;
    }
    if (haveDiagnostics) {
      this.diagnostics = {
        runnable,
        programLog,
        vertexShader: {
          log: vertexLog,
          prefix: prefixVertex
        },
        fragmentShader: {
          log: fragmentLog,
          prefix: prefixFragment
        }
      };
    }
  }
  gl.deleteShader(glVertexShader);
  gl.deleteShader(glFragmentShader);
  let cachedUniforms;
  this.getUniforms = function() {
    if (cachedUniforms === void 0) {
      cachedUniforms = new WebGLUniforms(gl, program);
    }
    return cachedUniforms;
  };
  let cachedAttributes;
  this.getAttributes = function() {
    if (cachedAttributes === void 0) {
      cachedAttributes = fetchAttributeLocations(gl, program);
    }
    return cachedAttributes;
  };
  this.destroy = function() {
    bindingStates.releaseStatesOfProgram(this);
    gl.deleteProgram(program);
    this.program = void 0;
  };
  this.name = parameters.shaderName;
  this.id = programIdCount++;
  this.cacheKey = cacheKey2;
  this.usedTimes = 1;
  this.program = program;
  this.vertexShader = glVertexShader;
  this.fragmentShader = glFragmentShader;
  return this;
}
let _id = 0;
class WebGLShaderCache {
  constructor() {
    this.shaderCache = /* @__PURE__ */ new Map();
    this.materialCache = /* @__PURE__ */ new Map();
  }
  update(material) {
    const vertexShader = material.vertexShader;
    const fragmentShader = material.fragmentShader;
    const vertexShaderStage = this._getShaderStage(vertexShader);
    const fragmentShaderStage = this._getShaderStage(fragmentShader);
    const materialShaders = this._getShaderCacheForMaterial(material);
    if (materialShaders.has(vertexShaderStage) === false) {
      materialShaders.add(vertexShaderStage);
      vertexShaderStage.usedTimes++;
    }
    if (materialShaders.has(fragmentShaderStage) === false) {
      materialShaders.add(fragmentShaderStage);
      fragmentShaderStage.usedTimes++;
    }
    return this;
  }
  remove(material) {
    const materialShaders = this.materialCache.get(material);
    for (const shaderStage of materialShaders) {
      shaderStage.usedTimes--;
      if (shaderStage.usedTimes === 0)
        this.shaderCache.delete(shaderStage.code);
    }
    this.materialCache.delete(material);
    return this;
  }
  getVertexShaderID(material) {
    return this._getShaderStage(material.vertexShader).id;
  }
  getFragmentShaderID(material) {
    return this._getShaderStage(material.fragmentShader).id;
  }
  dispose() {
    this.shaderCache.clear();
    this.materialCache.clear();
  }
  _getShaderCacheForMaterial(material) {
    const cache = this.materialCache;
    if (cache.has(material) === false) {
      cache.set(material, /* @__PURE__ */ new Set());
    }
    return cache.get(material);
  }
  _getShaderStage(code2) {
    const cache = this.shaderCache;
    if (cache.has(code2) === false) {
      const stage = new WebGLShaderStage(code2);
      cache.set(code2, stage);
    }
    return cache.get(code2);
  }
}
class WebGLShaderStage {
  constructor(code2) {
    this.id = _id++;
    this.code = code2;
    this.usedTimes = 0;
  }
}
function WebGLPrograms(renderer, cubemaps, cubeuvmaps, extensions, capabilities, bindingStates, clipping) {
  const _programLayers = new Layers();
  const _customShaders = new WebGLShaderCache();
  const programs = [];
  const isWebGL2 = capabilities.isWebGL2;
  const logarithmicDepthBuffer = capabilities.logarithmicDepthBuffer;
  const floatVertexTextures = capabilities.floatVertexTextures;
  const maxVertexUniforms = capabilities.maxVertexUniforms;
  const vertexTextures = capabilities.vertexTextures;
  let precision = capabilities.precision;
  const shaderIDs = {
    MeshDepthMaterial: "depth",
    MeshDistanceMaterial: "distanceRGBA",
    MeshNormalMaterial: "normal",
    MeshBasicMaterial: "basic",
    MeshLambertMaterial: "lambert",
    MeshPhongMaterial: "phong",
    MeshToonMaterial: "toon",
    MeshStandardMaterial: "physical",
    MeshPhysicalMaterial: "physical",
    MeshMatcapMaterial: "matcap",
    LineBasicMaterial: "basic",
    LineDashedMaterial: "dashed",
    PointsMaterial: "points",
    ShadowMaterial: "shadow",
    SpriteMaterial: "sprite"
  };
  function getMaxBones(object) {
    const skeleton = object.skeleton;
    const bones = skeleton.bones;
    if (floatVertexTextures) {
      return 1024;
    } else {
      const nVertexUniforms = maxVertexUniforms;
      const nVertexMatrices = Math.floor((nVertexUniforms - 20) / 4);
      const maxBones = Math.min(nVertexMatrices, bones.length);
      if (maxBones < bones.length) {
        console.warn("THREE.WebGLRenderer: Skeleton has " + bones.length + " bones. This GPU supports " + maxBones + ".");
        return 0;
      }
      return maxBones;
    }
  }
  function getParameters(material, lights, shadows, scene, object) {
    const fog = scene.fog;
    const geometry = object.geometry;
    const environment = material.isMeshStandardMaterial ? scene.environment : null;
    const envMap = (material.isMeshStandardMaterial ? cubeuvmaps : cubemaps).get(material.envMap || environment);
    const envMapCubeUVHeight = !!envMap && envMap.mapping === CubeUVReflectionMapping ? envMap.image.height : null;
    const shaderID = shaderIDs[material.type];
    const maxBones = object.isSkinnedMesh ? getMaxBones(object) : 0;
    if (material.precision !== null) {
      precision = capabilities.getMaxPrecision(material.precision);
      if (precision !== material.precision) {
        console.warn("THREE.WebGLProgram.getParameters:", material.precision, "not supported, using", precision, "instead.");
      }
    }
    const morphAttribute = geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color;
    const morphTargetsCount = morphAttribute !== void 0 ? morphAttribute.length : 0;
    let morphTextureStride = 0;
    if (geometry.morphAttributes.position !== void 0)
      morphTextureStride = 1;
    if (geometry.morphAttributes.normal !== void 0)
      morphTextureStride = 2;
    if (geometry.morphAttributes.color !== void 0)
      morphTextureStride = 3;
    let vertexShader, fragmentShader;
    let customVertexShaderID, customFragmentShaderID;
    if (shaderID) {
      const shader = ShaderLib[shaderID];
      vertexShader = shader.vertexShader;
      fragmentShader = shader.fragmentShader;
    } else {
      vertexShader = material.vertexShader;
      fragmentShader = material.fragmentShader;
      _customShaders.update(material);
      customVertexShaderID = _customShaders.getVertexShaderID(material);
      customFragmentShaderID = _customShaders.getFragmentShaderID(material);
    }
    const currentRenderTarget = renderer.getRenderTarget();
    const useAlphaTest = material.alphaTest > 0;
    const useClearcoat = material.clearcoat > 0;
    const parameters = {
      isWebGL2,
      shaderID,
      shaderName: material.type,
      vertexShader,
      fragmentShader,
      defines: material.defines,
      customVertexShaderID,
      customFragmentShaderID,
      isRawShaderMaterial: material.isRawShaderMaterial === true,
      glslVersion: material.glslVersion,
      precision,
      instancing: object.isInstancedMesh === true,
      instancingColor: object.isInstancedMesh === true && object.instanceColor !== null,
      supportsVertexTextures: vertexTextures,
      outputEncoding: currentRenderTarget === null ? renderer.outputEncoding : currentRenderTarget.isXRRenderTarget === true ? currentRenderTarget.texture.encoding : LinearEncoding,
      map: !!material.map,
      matcap: !!material.matcap,
      envMap: !!envMap,
      envMapMode: envMap && envMap.mapping,
      envMapCubeUVHeight,
      lightMap: !!material.lightMap,
      aoMap: !!material.aoMap,
      emissiveMap: !!material.emissiveMap,
      bumpMap: !!material.bumpMap,
      normalMap: !!material.normalMap,
      objectSpaceNormalMap: material.normalMapType === ObjectSpaceNormalMap,
      tangentSpaceNormalMap: material.normalMapType === TangentSpaceNormalMap,
      decodeVideoTexture: !!material.map && material.map.isVideoTexture === true && material.map.encoding === sRGBEncoding,
      clearcoat: useClearcoat,
      clearcoatMap: useClearcoat && !!material.clearcoatMap,
      clearcoatRoughnessMap: useClearcoat && !!material.clearcoatRoughnessMap,
      clearcoatNormalMap: useClearcoat && !!material.clearcoatNormalMap,
      displacementMap: !!material.displacementMap,
      roughnessMap: !!material.roughnessMap,
      metalnessMap: !!material.metalnessMap,
      specularMap: !!material.specularMap,
      specularIntensityMap: !!material.specularIntensityMap,
      specularColorMap: !!material.specularColorMap,
      opaque: material.transparent === false && material.blending === NormalBlending,
      alphaMap: !!material.alphaMap,
      alphaTest: useAlphaTest,
      gradientMap: !!material.gradientMap,
      sheen: material.sheen > 0,
      sheenColorMap: !!material.sheenColorMap,
      sheenRoughnessMap: !!material.sheenRoughnessMap,
      transmission: material.transmission > 0,
      transmissionMap: !!material.transmissionMap,
      thicknessMap: !!material.thicknessMap,
      combine: material.combine,
      vertexTangents: !!material.normalMap && !!geometry.attributes.tangent,
      vertexColors: material.vertexColors,
      vertexAlphas: material.vertexColors === true && !!geometry.attributes.color && geometry.attributes.color.itemSize === 4,
      vertexUvs: !!material.map || !!material.bumpMap || !!material.normalMap || !!material.specularMap || !!material.alphaMap || !!material.emissiveMap || !!material.roughnessMap || !!material.metalnessMap || !!material.clearcoatMap || !!material.clearcoatRoughnessMap || !!material.clearcoatNormalMap || !!material.displacementMap || !!material.transmissionMap || !!material.thicknessMap || !!material.specularIntensityMap || !!material.specularColorMap || !!material.sheenColorMap || !!material.sheenRoughnessMap,
      uvsVertexOnly: !(!!material.map || !!material.bumpMap || !!material.normalMap || !!material.specularMap || !!material.alphaMap || !!material.emissiveMap || !!material.roughnessMap || !!material.metalnessMap || !!material.clearcoatNormalMap || material.transmission > 0 || !!material.transmissionMap || !!material.thicknessMap || !!material.specularIntensityMap || !!material.specularColorMap || material.sheen > 0 || !!material.sheenColorMap || !!material.sheenRoughnessMap) && !!material.displacementMap,
      fog: !!fog,
      useFog: material.fog,
      fogExp2: fog && fog.isFogExp2,
      flatShading: !!material.flatShading,
      sizeAttenuation: material.sizeAttenuation,
      logarithmicDepthBuffer,
      skinning: object.isSkinnedMesh === true && maxBones > 0,
      maxBones,
      useVertexTexture: floatVertexTextures,
      morphTargets: geometry.morphAttributes.position !== void 0,
      morphNormals: geometry.morphAttributes.normal !== void 0,
      morphColors: geometry.morphAttributes.color !== void 0,
      morphTargetsCount,
      morphTextureStride,
      numDirLights: lights.directional.length,
      numPointLights: lights.point.length,
      numSpotLights: lights.spot.length,
      numRectAreaLights: lights.rectArea.length,
      numHemiLights: lights.hemi.length,
      numDirLightShadows: lights.directionalShadowMap.length,
      numPointLightShadows: lights.pointShadowMap.length,
      numSpotLightShadows: lights.spotShadowMap.length,
      numClippingPlanes: clipping.numPlanes,
      numClipIntersection: clipping.numIntersection,
      dithering: material.dithering,
      shadowMapEnabled: renderer.shadowMap.enabled && shadows.length > 0,
      shadowMapType: renderer.shadowMap.type,
      toneMapping: material.toneMapped ? renderer.toneMapping : NoToneMapping,
      physicallyCorrectLights: renderer.physicallyCorrectLights,
      premultipliedAlpha: material.premultipliedAlpha,
      doubleSided: material.side === DoubleSide,
      flipSided: material.side === BackSide,
      depthPacking: material.depthPacking !== void 0 ? material.depthPacking : false,
      index0AttributeName: material.index0AttributeName,
      extensionDerivatives: material.extensions && material.extensions.derivatives,
      extensionFragDepth: material.extensions && material.extensions.fragDepth,
      extensionDrawBuffers: material.extensions && material.extensions.drawBuffers,
      extensionShaderTextureLOD: material.extensions && material.extensions.shaderTextureLOD,
      rendererExtensionFragDepth: isWebGL2 || extensions.has("EXT_frag_depth"),
      rendererExtensionDrawBuffers: isWebGL2 || extensions.has("WEBGL_draw_buffers"),
      rendererExtensionShaderTextureLod: isWebGL2 || extensions.has("EXT_shader_texture_lod"),
      customProgramCacheKey: material.customProgramCacheKey()
    };
    return parameters;
  }
  function getProgramCacheKey(parameters) {
    const array = [];
    if (parameters.shaderID) {
      array.push(parameters.shaderID);
    } else {
      array.push(parameters.customVertexShaderID);
      array.push(parameters.customFragmentShaderID);
    }
    if (parameters.defines !== void 0) {
      for (const name in parameters.defines) {
        array.push(name);
        array.push(parameters.defines[name]);
      }
    }
    if (parameters.isRawShaderMaterial === false) {
      getProgramCacheKeyParameters(array, parameters);
      getProgramCacheKeyBooleans(array, parameters);
      array.push(renderer.outputEncoding);
    }
    array.push(parameters.customProgramCacheKey);
    return array.join();
  }
  function getProgramCacheKeyParameters(array, parameters) {
    array.push(parameters.precision);
    array.push(parameters.outputEncoding);
    array.push(parameters.envMapMode);
    array.push(parameters.envMapCubeUVHeight);
    array.push(parameters.combine);
    array.push(parameters.vertexUvs);
    array.push(parameters.fogExp2);
    array.push(parameters.sizeAttenuation);
    array.push(parameters.maxBones);
    array.push(parameters.morphTargetsCount);
    array.push(parameters.morphAttributeCount);
    array.push(parameters.numDirLights);
    array.push(parameters.numPointLights);
    array.push(parameters.numSpotLights);
    array.push(parameters.numHemiLights);
    array.push(parameters.numRectAreaLights);
    array.push(parameters.numDirLightShadows);
    array.push(parameters.numPointLightShadows);
    array.push(parameters.numSpotLightShadows);
    array.push(parameters.shadowMapType);
    array.push(parameters.toneMapping);
    array.push(parameters.numClippingPlanes);
    array.push(parameters.numClipIntersection);
  }
  function getProgramCacheKeyBooleans(array, parameters) {
    _programLayers.disableAll();
    if (parameters.isWebGL2)
      _programLayers.enable(0);
    if (parameters.supportsVertexTextures)
      _programLayers.enable(1);
    if (parameters.instancing)
      _programLayers.enable(2);
    if (parameters.instancingColor)
      _programLayers.enable(3);
    if (parameters.map)
      _programLayers.enable(4);
    if (parameters.matcap)
      _programLayers.enable(5);
    if (parameters.envMap)
      _programLayers.enable(6);
    if (parameters.lightMap)
      _programLayers.enable(7);
    if (parameters.aoMap)
      _programLayers.enable(8);
    if (parameters.emissiveMap)
      _programLayers.enable(9);
    if (parameters.bumpMap)
      _programLayers.enable(10);
    if (parameters.normalMap)
      _programLayers.enable(11);
    if (parameters.objectSpaceNormalMap)
      _programLayers.enable(12);
    if (parameters.tangentSpaceNormalMap)
      _programLayers.enable(13);
    if (parameters.clearcoat)
      _programLayers.enable(14);
    if (parameters.clearcoatMap)
      _programLayers.enable(15);
    if (parameters.clearcoatRoughnessMap)
      _programLayers.enable(16);
    if (parameters.clearcoatNormalMap)
      _programLayers.enable(17);
    if (parameters.displacementMap)
      _programLayers.enable(18);
    if (parameters.specularMap)
      _programLayers.enable(19);
    if (parameters.roughnessMap)
      _programLayers.enable(20);
    if (parameters.metalnessMap)
      _programLayers.enable(21);
    if (parameters.gradientMap)
      _programLayers.enable(22);
    if (parameters.alphaMap)
      _programLayers.enable(23);
    if (parameters.alphaTest)
      _programLayers.enable(24);
    if (parameters.vertexColors)
      _programLayers.enable(25);
    if (parameters.vertexAlphas)
      _programLayers.enable(26);
    if (parameters.vertexUvs)
      _programLayers.enable(27);
    if (parameters.vertexTangents)
      _programLayers.enable(28);
    if (parameters.uvsVertexOnly)
      _programLayers.enable(29);
    if (parameters.fog)
      _programLayers.enable(30);
    array.push(_programLayers.mask);
    _programLayers.disableAll();
    if (parameters.useFog)
      _programLayers.enable(0);
    if (parameters.flatShading)
      _programLayers.enable(1);
    if (parameters.logarithmicDepthBuffer)
      _programLayers.enable(2);
    if (parameters.skinning)
      _programLayers.enable(3);
    if (parameters.useVertexTexture)
      _programLayers.enable(4);
    if (parameters.morphTargets)
      _programLayers.enable(5);
    if (parameters.morphNormals)
      _programLayers.enable(6);
    if (parameters.morphColors)
      _programLayers.enable(7);
    if (parameters.premultipliedAlpha)
      _programLayers.enable(8);
    if (parameters.shadowMapEnabled)
      _programLayers.enable(9);
    if (parameters.physicallyCorrectLights)
      _programLayers.enable(10);
    if (parameters.doubleSided)
      _programLayers.enable(11);
    if (parameters.flipSided)
      _programLayers.enable(12);
    if (parameters.depthPacking)
      _programLayers.enable(13);
    if (parameters.dithering)
      _programLayers.enable(14);
    if (parameters.specularIntensityMap)
      _programLayers.enable(15);
    if (parameters.specularColorMap)
      _programLayers.enable(16);
    if (parameters.transmission)
      _programLayers.enable(17);
    if (parameters.transmissionMap)
      _programLayers.enable(18);
    if (parameters.thicknessMap)
      _programLayers.enable(19);
    if (parameters.sheen)
      _programLayers.enable(20);
    if (parameters.sheenColorMap)
      _programLayers.enable(21);
    if (parameters.sheenRoughnessMap)
      _programLayers.enable(22);
    if (parameters.decodeVideoTexture)
      _programLayers.enable(23);
    if (parameters.opaque)
      _programLayers.enable(24);
    array.push(_programLayers.mask);
  }
  function getUniforms(material) {
    const shaderID = shaderIDs[material.type];
    let uniforms;
    if (shaderID) {
      const shader = ShaderLib[shaderID];
      uniforms = UniformsUtils.clone(shader.uniforms);
    } else {
      uniforms = material.uniforms;
    }
    return uniforms;
  }
  function acquireProgram(parameters, cacheKey2) {
    let program;
    for (let p = 0, pl = programs.length; p < pl; p++) {
      const preexistingProgram = programs[p];
      if (preexistingProgram.cacheKey === cacheKey2) {
        program = preexistingProgram;
        ++program.usedTimes;
        break;
      }
    }
    if (program === void 0) {
      program = new WebGLProgram(renderer, cacheKey2, parameters, bindingStates);
      programs.push(program);
    }
    return program;
  }
  function releaseProgram(program) {
    if (--program.usedTimes === 0) {
      const i = programs.indexOf(program);
      programs[i] = programs[programs.length - 1];
      programs.pop();
      program.destroy();
    }
  }
  function releaseShaderCache(material) {
    _customShaders.remove(material);
  }
  function dispose() {
    _customShaders.dispose();
  }
  return {
    getParameters,
    getProgramCacheKey,
    getUniforms,
    acquireProgram,
    releaseProgram,
    releaseShaderCache,
    programs,
    dispose
  };
}
function WebGLProperties() {
  let properties = /* @__PURE__ */ new WeakMap();
  function get2(object) {
    let map2 = properties.get(object);
    if (map2 === void 0) {
      map2 = {};
      properties.set(object, map2);
    }
    return map2;
  }
  function remove3(object) {
    properties.delete(object);
  }
  function update2(object, key, value) {
    properties.get(object)[key] = value;
  }
  function dispose() {
    properties = /* @__PURE__ */ new WeakMap();
  }
  return {
    get: get2,
    remove: remove3,
    update: update2,
    dispose
  };
}
function painterSortStable(a, b) {
  if (a.groupOrder !== b.groupOrder) {
    return a.groupOrder - b.groupOrder;
  } else if (a.renderOrder !== b.renderOrder) {
    return a.renderOrder - b.renderOrder;
  } else if (a.material.id !== b.material.id) {
    return a.material.id - b.material.id;
  } else if (a.z !== b.z) {
    return a.z - b.z;
  } else {
    return a.id - b.id;
  }
}
function reversePainterSortStable(a, b) {
  if (a.groupOrder !== b.groupOrder) {
    return a.groupOrder - b.groupOrder;
  } else if (a.renderOrder !== b.renderOrder) {
    return a.renderOrder - b.renderOrder;
  } else if (a.z !== b.z) {
    return b.z - a.z;
  } else {
    return a.id - b.id;
  }
}
function WebGLRenderList() {
  const renderItems = [];
  let renderItemsIndex = 0;
  const opaque = [];
  const transmissive = [];
  const transparent = [];
  function init() {
    renderItemsIndex = 0;
    opaque.length = 0;
    transmissive.length = 0;
    transparent.length = 0;
  }
  function getNextRenderItem(object, geometry, material, groupOrder, z, group2) {
    let renderItem = renderItems[renderItemsIndex];
    if (renderItem === void 0) {
      renderItem = {
        id: object.id,
        object,
        geometry,
        material,
        groupOrder,
        renderOrder: object.renderOrder,
        z,
        group: group2
      };
      renderItems[renderItemsIndex] = renderItem;
    } else {
      renderItem.id = object.id;
      renderItem.object = object;
      renderItem.geometry = geometry;
      renderItem.material = material;
      renderItem.groupOrder = groupOrder;
      renderItem.renderOrder = object.renderOrder;
      renderItem.z = z;
      renderItem.group = group2;
    }
    renderItemsIndex++;
    return renderItem;
  }
  function push(object, geometry, material, groupOrder, z, group2) {
    const renderItem = getNextRenderItem(object, geometry, material, groupOrder, z, group2);
    if (material.transmission > 0) {
      transmissive.push(renderItem);
    } else if (material.transparent === true) {
      transparent.push(renderItem);
    } else {
      opaque.push(renderItem);
    }
  }
  function unshift(object, geometry, material, groupOrder, z, group2) {
    const renderItem = getNextRenderItem(object, geometry, material, groupOrder, z, group2);
    if (material.transmission > 0) {
      transmissive.unshift(renderItem);
    } else if (material.transparent === true) {
      transparent.unshift(renderItem);
    } else {
      opaque.unshift(renderItem);
    }
  }
  function sort(customOpaqueSort, customTransparentSort) {
    if (opaque.length > 1)
      opaque.sort(customOpaqueSort || painterSortStable);
    if (transmissive.length > 1)
      transmissive.sort(customTransparentSort || reversePainterSortStable);
    if (transparent.length > 1)
      transparent.sort(customTransparentSort || reversePainterSortStable);
  }
  function finish() {
    for (let i = renderItemsIndex, il = renderItems.length; i < il; i++) {
      const renderItem = renderItems[i];
      if (renderItem.id === null)
        break;
      renderItem.id = null;
      renderItem.object = null;
      renderItem.geometry = null;
      renderItem.material = null;
      renderItem.group = null;
    }
  }
  return {
    opaque,
    transmissive,
    transparent,
    init,
    push,
    unshift,
    finish,
    sort
  };
}
function WebGLRenderLists() {
  let lists = /* @__PURE__ */ new WeakMap();
  function get2(scene, renderCallDepth) {
    let list2;
    if (lists.has(scene) === false) {
      list2 = new WebGLRenderList();
      lists.set(scene, [list2]);
    } else {
      if (renderCallDepth >= lists.get(scene).length) {
        list2 = new WebGLRenderList();
        lists.get(scene).push(list2);
      } else {
        list2 = lists.get(scene)[renderCallDepth];
      }
    }
    return list2;
  }
  function dispose() {
    lists = /* @__PURE__ */ new WeakMap();
  }
  return {
    get: get2,
    dispose
  };
}
function UniformsCache() {
  const lights = {};
  return {
    get: function(light2) {
      if (lights[light2.id] !== void 0) {
        return lights[light2.id];
      }
      let uniforms;
      switch (light2.type) {
        case "DirectionalLight":
          uniforms = {
            direction: new Vector3(),
            color: new Color()
          };
          break;
        case "SpotLight":
          uniforms = {
            position: new Vector3(),
            direction: new Vector3(),
            color: new Color(),
            distance: 0,
            coneCos: 0,
            penumbraCos: 0,
            decay: 0
          };
          break;
        case "PointLight":
          uniforms = {
            position: new Vector3(),
            color: new Color(),
            distance: 0,
            decay: 0
          };
          break;
        case "HemisphereLight":
          uniforms = {
            direction: new Vector3(),
            skyColor: new Color(),
            groundColor: new Color()
          };
          break;
        case "RectAreaLight":
          uniforms = {
            color: new Color(),
            position: new Vector3(),
            halfWidth: new Vector3(),
            halfHeight: new Vector3()
          };
          break;
      }
      lights[light2.id] = uniforms;
      return uniforms;
    }
  };
}
function ShadowUniformsCache() {
  const lights = {};
  return {
    get: function(light2) {
      if (lights[light2.id] !== void 0) {
        return lights[light2.id];
      }
      let uniforms;
      switch (light2.type) {
        case "DirectionalLight":
          uniforms = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Vector2()
          };
          break;
        case "SpotLight":
          uniforms = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Vector2()
          };
          break;
        case "PointLight":
          uniforms = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Vector2(),
            shadowCameraNear: 1,
            shadowCameraFar: 1e3
          };
          break;
      }
      lights[light2.id] = uniforms;
      return uniforms;
    }
  };
}
let nextVersion = 0;
function shadowCastingLightsFirst(lightA, lightB) {
  return (lightB.castShadow ? 1 : 0) - (lightA.castShadow ? 1 : 0);
}
function WebGLLights(extensions, capabilities) {
  const cache = new UniformsCache();
  const shadowCache = ShadowUniformsCache();
  const state = {
    version: 0,
    hash: {
      directionalLength: -1,
      pointLength: -1,
      spotLength: -1,
      rectAreaLength: -1,
      hemiLength: -1,
      numDirectionalShadows: -1,
      numPointShadows: -1,
      numSpotShadows: -1
    },
    ambient: [0, 0, 0],
    probe: [],
    directional: [],
    directionalShadow: [],
    directionalShadowMap: [],
    directionalShadowMatrix: [],
    spot: [],
    spotShadow: [],
    spotShadowMap: [],
    spotShadowMatrix: [],
    rectArea: [],
    rectAreaLTC1: null,
    rectAreaLTC2: null,
    point: [],
    pointShadow: [],
    pointShadowMap: [],
    pointShadowMatrix: [],
    hemi: []
  };
  for (let i = 0; i < 9; i++)
    state.probe.push(new Vector3());
  const vector3 = new Vector3();
  const matrix4 = new Matrix4();
  const matrix42 = new Matrix4();
  function setup(lights, physicallyCorrectLights) {
    let r = 0, g = 0, b = 0;
    for (let i = 0; i < 9; i++)
      state.probe[i].set(0, 0, 0);
    let directionalLength = 0;
    let pointLength = 0;
    let spotLength = 0;
    let rectAreaLength = 0;
    let hemiLength = 0;
    let numDirectionalShadows = 0;
    let numPointShadows = 0;
    let numSpotShadows = 0;
    lights.sort(shadowCastingLightsFirst);
    const scaleFactor = physicallyCorrectLights !== true ? Math.PI : 1;
    for (let i = 0, l = lights.length; i < l; i++) {
      const light2 = lights[i];
      const color2 = light2.color;
      const intensity = light2.intensity;
      const distance2 = light2.distance;
      const shadowMap = light2.shadow && light2.shadow.map ? light2.shadow.map.texture : null;
      if (light2.isAmbientLight) {
        r += color2.r * intensity * scaleFactor;
        g += color2.g * intensity * scaleFactor;
        b += color2.b * intensity * scaleFactor;
      } else if (light2.isLightProbe) {
        for (let j = 0; j < 9; j++) {
          state.probe[j].addScaledVector(light2.sh.coefficients[j], intensity);
        }
      } else if (light2.isDirectionalLight) {
        const uniforms = cache.get(light2);
        uniforms.color.copy(light2.color).multiplyScalar(light2.intensity * scaleFactor);
        if (light2.castShadow) {
          const shadow2 = light2.shadow;
          const shadowUniforms = shadowCache.get(light2);
          shadowUniforms.shadowBias = shadow2.bias;
          shadowUniforms.shadowNormalBias = shadow2.normalBias;
          shadowUniforms.shadowRadius = shadow2.radius;
          shadowUniforms.shadowMapSize = shadow2.mapSize;
          state.directionalShadow[directionalLength] = shadowUniforms;
          state.directionalShadowMap[directionalLength] = shadowMap;
          state.directionalShadowMatrix[directionalLength] = light2.shadow.matrix;
          numDirectionalShadows++;
        }
        state.directional[directionalLength] = uniforms;
        directionalLength++;
      } else if (light2.isSpotLight) {
        const uniforms = cache.get(light2);
        uniforms.position.setFromMatrixPosition(light2.matrixWorld);
        uniforms.color.copy(color2).multiplyScalar(intensity * scaleFactor);
        uniforms.distance = distance2;
        uniforms.coneCos = Math.cos(light2.angle);
        uniforms.penumbraCos = Math.cos(light2.angle * (1 - light2.penumbra));
        uniforms.decay = light2.decay;
        if (light2.castShadow) {
          const shadow2 = light2.shadow;
          const shadowUniforms = shadowCache.get(light2);
          shadowUniforms.shadowBias = shadow2.bias;
          shadowUniforms.shadowNormalBias = shadow2.normalBias;
          shadowUniforms.shadowRadius = shadow2.radius;
          shadowUniforms.shadowMapSize = shadow2.mapSize;
          state.spotShadow[spotLength] = shadowUniforms;
          state.spotShadowMap[spotLength] = shadowMap;
          state.spotShadowMatrix[spotLength] = light2.shadow.matrix;
          numSpotShadows++;
        }
        state.spot[spotLength] = uniforms;
        spotLength++;
      } else if (light2.isRectAreaLight) {
        const uniforms = cache.get(light2);
        uniforms.color.copy(color2).multiplyScalar(intensity);
        uniforms.halfWidth.set(light2.width * 0.5, 0, 0);
        uniforms.halfHeight.set(0, light2.height * 0.5, 0);
        state.rectArea[rectAreaLength] = uniforms;
        rectAreaLength++;
      } else if (light2.isPointLight) {
        const uniforms = cache.get(light2);
        uniforms.color.copy(light2.color).multiplyScalar(light2.intensity * scaleFactor);
        uniforms.distance = light2.distance;
        uniforms.decay = light2.decay;
        if (light2.castShadow) {
          const shadow2 = light2.shadow;
          const shadowUniforms = shadowCache.get(light2);
          shadowUniforms.shadowBias = shadow2.bias;
          shadowUniforms.shadowNormalBias = shadow2.normalBias;
          shadowUniforms.shadowRadius = shadow2.radius;
          shadowUniforms.shadowMapSize = shadow2.mapSize;
          shadowUniforms.shadowCameraNear = shadow2.camera.near;
          shadowUniforms.shadowCameraFar = shadow2.camera.far;
          state.pointShadow[pointLength] = shadowUniforms;
          state.pointShadowMap[pointLength] = shadowMap;
          state.pointShadowMatrix[pointLength] = light2.shadow.matrix;
          numPointShadows++;
        }
        state.point[pointLength] = uniforms;
        pointLength++;
      } else if (light2.isHemisphereLight) {
        const uniforms = cache.get(light2);
        uniforms.skyColor.copy(light2.color).multiplyScalar(intensity * scaleFactor);
        uniforms.groundColor.copy(light2.groundColor).multiplyScalar(intensity * scaleFactor);
        state.hemi[hemiLength] = uniforms;
        hemiLength++;
      }
    }
    if (rectAreaLength > 0) {
      if (capabilities.isWebGL2) {
        state.rectAreaLTC1 = UniformsLib.LTC_FLOAT_1;
        state.rectAreaLTC2 = UniformsLib.LTC_FLOAT_2;
      } else {
        if (extensions.has("OES_texture_float_linear") === true) {
          state.rectAreaLTC1 = UniformsLib.LTC_FLOAT_1;
          state.rectAreaLTC2 = UniformsLib.LTC_FLOAT_2;
        } else if (extensions.has("OES_texture_half_float_linear") === true) {
          state.rectAreaLTC1 = UniformsLib.LTC_HALF_1;
          state.rectAreaLTC2 = UniformsLib.LTC_HALF_2;
        } else {
          console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.");
        }
      }
    }
    state.ambient[0] = r;
    state.ambient[1] = g;
    state.ambient[2] = b;
    const hash = state.hash;
    if (hash.directionalLength !== directionalLength || hash.pointLength !== pointLength || hash.spotLength !== spotLength || hash.rectAreaLength !== rectAreaLength || hash.hemiLength !== hemiLength || hash.numDirectionalShadows !== numDirectionalShadows || hash.numPointShadows !== numPointShadows || hash.numSpotShadows !== numSpotShadows) {
      state.directional.length = directionalLength;
      state.spot.length = spotLength;
      state.rectArea.length = rectAreaLength;
      state.point.length = pointLength;
      state.hemi.length = hemiLength;
      state.directionalShadow.length = numDirectionalShadows;
      state.directionalShadowMap.length = numDirectionalShadows;
      state.pointShadow.length = numPointShadows;
      state.pointShadowMap.length = numPointShadows;
      state.spotShadow.length = numSpotShadows;
      state.spotShadowMap.length = numSpotShadows;
      state.directionalShadowMatrix.length = numDirectionalShadows;
      state.pointShadowMatrix.length = numPointShadows;
      state.spotShadowMatrix.length = numSpotShadows;
      hash.directionalLength = directionalLength;
      hash.pointLength = pointLength;
      hash.spotLength = spotLength;
      hash.rectAreaLength = rectAreaLength;
      hash.hemiLength = hemiLength;
      hash.numDirectionalShadows = numDirectionalShadows;
      hash.numPointShadows = numPointShadows;
      hash.numSpotShadows = numSpotShadows;
      state.version = nextVersion++;
    }
  }
  function setupView(lights, camera) {
    let directionalLength = 0;
    let pointLength = 0;
    let spotLength = 0;
    let rectAreaLength = 0;
    let hemiLength = 0;
    const viewMatrix = camera.matrixWorldInverse;
    for (let i = 0, l = lights.length; i < l; i++) {
      const light2 = lights[i];
      if (light2.isDirectionalLight) {
        const uniforms = state.directional[directionalLength];
        uniforms.direction.setFromMatrixPosition(light2.matrixWorld);
        vector3.setFromMatrixPosition(light2.target.matrixWorld);
        uniforms.direction.sub(vector3);
        uniforms.direction.transformDirection(viewMatrix);
        directionalLength++;
      } else if (light2.isSpotLight) {
        const uniforms = state.spot[spotLength];
        uniforms.position.setFromMatrixPosition(light2.matrixWorld);
        uniforms.position.applyMatrix4(viewMatrix);
        uniforms.direction.setFromMatrixPosition(light2.matrixWorld);
        vector3.setFromMatrixPosition(light2.target.matrixWorld);
        uniforms.direction.sub(vector3);
        uniforms.direction.transformDirection(viewMatrix);
        spotLength++;
      } else if (light2.isRectAreaLight) {
        const uniforms = state.rectArea[rectAreaLength];
        uniforms.position.setFromMatrixPosition(light2.matrixWorld);
        uniforms.position.applyMatrix4(viewMatrix);
        matrix42.identity();
        matrix4.copy(light2.matrixWorld);
        matrix4.premultiply(viewMatrix);
        matrix42.extractRotation(matrix4);
        uniforms.halfWidth.set(light2.width * 0.5, 0, 0);
        uniforms.halfHeight.set(0, light2.height * 0.5, 0);
        uniforms.halfWidth.applyMatrix4(matrix42);
        uniforms.halfHeight.applyMatrix4(matrix42);
        rectAreaLength++;
      } else if (light2.isPointLight) {
        const uniforms = state.point[pointLength];
        uniforms.position.setFromMatrixPosition(light2.matrixWorld);
        uniforms.position.applyMatrix4(viewMatrix);
        pointLength++;
      } else if (light2.isHemisphereLight) {
        const uniforms = state.hemi[hemiLength];
        uniforms.direction.setFromMatrixPosition(light2.matrixWorld);
        uniforms.direction.transformDirection(viewMatrix);
        uniforms.direction.normalize();
        hemiLength++;
      }
    }
  }
  return {
    setup,
    setupView,
    state
  };
}
function WebGLRenderState(extensions, capabilities) {
  const lights = new WebGLLights(extensions, capabilities);
  const lightsArray = [];
  const shadowsArray = [];
  function init() {
    lightsArray.length = 0;
    shadowsArray.length = 0;
  }
  function pushLight(light2) {
    lightsArray.push(light2);
  }
  function pushShadow(shadowLight) {
    shadowsArray.push(shadowLight);
  }
  function setupLights(physicallyCorrectLights) {
    lights.setup(lightsArray, physicallyCorrectLights);
  }
  function setupLightsView(camera) {
    lights.setupView(lightsArray, camera);
  }
  const state = {
    lightsArray,
    shadowsArray,
    lights
  };
  return {
    init,
    state,
    setupLights,
    setupLightsView,
    pushLight,
    pushShadow
  };
}
function WebGLRenderStates(extensions, capabilities) {
  let renderStates = /* @__PURE__ */ new WeakMap();
  function get2(scene, renderCallDepth = 0) {
    let renderState;
    if (renderStates.has(scene) === false) {
      renderState = new WebGLRenderState(extensions, capabilities);
      renderStates.set(scene, [renderState]);
    } else {
      if (renderCallDepth >= renderStates.get(scene).length) {
        renderState = new WebGLRenderState(extensions, capabilities);
        renderStates.get(scene).push(renderState);
      } else {
        renderState = renderStates.get(scene)[renderCallDepth];
      }
    }
    return renderState;
  }
  function dispose() {
    renderStates = /* @__PURE__ */ new WeakMap();
  }
  return {
    get: get2,
    dispose
  };
}
class MeshDepthMaterial extends Material {
  constructor(parameters) {
    super();
    this.type = "MeshDepthMaterial";
    this.depthPacking = BasicDepthPacking;
    this.map = null;
    this.alphaMap = null;
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.fog = false;
    this.setValues(parameters);
  }
  copy(source2) {
    super.copy(source2);
    this.depthPacking = source2.depthPacking;
    this.map = source2.map;
    this.alphaMap = source2.alphaMap;
    this.displacementMap = source2.displacementMap;
    this.displacementScale = source2.displacementScale;
    this.displacementBias = source2.displacementBias;
    this.wireframe = source2.wireframe;
    this.wireframeLinewidth = source2.wireframeLinewidth;
    return this;
  }
}
MeshDepthMaterial.prototype.isMeshDepthMaterial = true;
class MeshDistanceMaterial extends Material {
  constructor(parameters) {
    super();
    this.type = "MeshDistanceMaterial";
    this.referencePosition = new Vector3();
    this.nearDistance = 1;
    this.farDistance = 1e3;
    this.map = null;
    this.alphaMap = null;
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.fog = false;
    this.setValues(parameters);
  }
  copy(source2) {
    super.copy(source2);
    this.referencePosition.copy(source2.referencePosition);
    this.nearDistance = source2.nearDistance;
    this.farDistance = source2.farDistance;
    this.map = source2.map;
    this.alphaMap = source2.alphaMap;
    this.displacementMap = source2.displacementMap;
    this.displacementScale = source2.displacementScale;
    this.displacementBias = source2.displacementBias;
    return this;
  }
}
MeshDistanceMaterial.prototype.isMeshDistanceMaterial = true;
const vertex = "void main() {\n	gl_Position = vec4( position, 1.0 );\n}";
const fragment = "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n	const float samples = float( VSM_SAMPLES );\n	float mean = 0.0;\n	float squared_mean = 0.0;\n	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );\n	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;\n	for ( float i = 0.0; i < samples; i ++ ) {\n		float uvOffset = uvStart + i * uvStride;\n		#ifdef HORIZONTAL_PASS\n			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );\n			mean += distribution.x;\n			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n		#else\n			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );\n			mean += depth;\n			squared_mean += depth * depth;\n		#endif\n	}\n	mean = mean / samples;\n	squared_mean = squared_mean / samples;\n	float std_dev = sqrt( squared_mean - mean * mean );\n	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}";
function WebGLShadowMap(_renderer, _objects, _capabilities) {
  let _frustum = new Frustum();
  const _shadowMapSize = new Vector2(), _viewportSize = new Vector2(), _viewport = new Vector4(), _depthMaterial = new MeshDepthMaterial({ depthPacking: RGBADepthPacking }), _distanceMaterial = new MeshDistanceMaterial(), _materialCache = {}, _maxTextureSize = _capabilities.maxTextureSize;
  const shadowSide = { 0: BackSide, 1: FrontSide, 2: DoubleSide };
  const shadowMaterialVertical = new ShaderMaterial({
    defines: {
      VSM_SAMPLES: 8
    },
    uniforms: {
      shadow_pass: { value: null },
      resolution: { value: new Vector2() },
      radius: { value: 4 }
    },
    vertexShader: vertex,
    fragmentShader: fragment
  });
  const shadowMaterialHorizontal = shadowMaterialVertical.clone();
  shadowMaterialHorizontal.defines.HORIZONTAL_PASS = 1;
  const fullScreenTri = new BufferGeometry();
  fullScreenTri.setAttribute("position", new BufferAttribute(new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]), 3));
  const fullScreenMesh = new Mesh(fullScreenTri, shadowMaterialVertical);
  const scope = this;
  this.enabled = false;
  this.autoUpdate = true;
  this.needsUpdate = false;
  this.type = PCFShadowMap;
  this.render = function(lights, scene, camera) {
    if (scope.enabled === false)
      return;
    if (scope.autoUpdate === false && scope.needsUpdate === false)
      return;
    if (lights.length === 0)
      return;
    const currentRenderTarget = _renderer.getRenderTarget();
    const activeCubeFace = _renderer.getActiveCubeFace();
    const activeMipmapLevel = _renderer.getActiveMipmapLevel();
    const _state2 = _renderer.state;
    _state2.setBlending(NoBlending);
    _state2.buffers.color.setClear(1, 1, 1, 1);
    _state2.buffers.depth.setTest(true);
    _state2.setScissorTest(false);
    for (let i = 0, il = lights.length; i < il; i++) {
      const light2 = lights[i];
      const shadow2 = light2.shadow;
      if (shadow2 === void 0) {
        console.warn("THREE.WebGLShadowMap:", light2, "has no shadow.");
        continue;
      }
      if (shadow2.autoUpdate === false && shadow2.needsUpdate === false)
        continue;
      _shadowMapSize.copy(shadow2.mapSize);
      const shadowFrameExtents = shadow2.getFrameExtents();
      _shadowMapSize.multiply(shadowFrameExtents);
      _viewportSize.copy(shadow2.mapSize);
      if (_shadowMapSize.x > _maxTextureSize || _shadowMapSize.y > _maxTextureSize) {
        if (_shadowMapSize.x > _maxTextureSize) {
          _viewportSize.x = Math.floor(_maxTextureSize / shadowFrameExtents.x);
          _shadowMapSize.x = _viewportSize.x * shadowFrameExtents.x;
          shadow2.mapSize.x = _viewportSize.x;
        }
        if (_shadowMapSize.y > _maxTextureSize) {
          _viewportSize.y = Math.floor(_maxTextureSize / shadowFrameExtents.y);
          _shadowMapSize.y = _viewportSize.y * shadowFrameExtents.y;
          shadow2.mapSize.y = _viewportSize.y;
        }
      }
      if (shadow2.map === null && !shadow2.isPointLightShadow && this.type === VSMShadowMap) {
        shadow2.map = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y);
        shadow2.map.texture.name = light2.name + ".shadowMap";
        shadow2.mapPass = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y);
        shadow2.camera.updateProjectionMatrix();
      }
      if (shadow2.map === null) {
        const pars = { minFilter: NearestFilter, magFilter: NearestFilter, format: RGBAFormat };
        shadow2.map = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y, pars);
        shadow2.map.texture.name = light2.name + ".shadowMap";
        shadow2.camera.updateProjectionMatrix();
      }
      _renderer.setRenderTarget(shadow2.map);
      _renderer.clear();
      const viewportCount = shadow2.getViewportCount();
      for (let vp = 0; vp < viewportCount; vp++) {
        const viewport = shadow2.getViewport(vp);
        _viewport.set(_viewportSize.x * viewport.x, _viewportSize.y * viewport.y, _viewportSize.x * viewport.z, _viewportSize.y * viewport.w);
        _state2.viewport(_viewport);
        shadow2.updateMatrices(light2, vp);
        _frustum = shadow2.getFrustum();
        renderObject(scene, camera, shadow2.camera, light2, this.type);
      }
      if (!shadow2.isPointLightShadow && this.type === VSMShadowMap) {
        VSMPass(shadow2, camera);
      }
      shadow2.needsUpdate = false;
    }
    scope.needsUpdate = false;
    _renderer.setRenderTarget(currentRenderTarget, activeCubeFace, activeMipmapLevel);
  };
  function VSMPass(shadow2, camera) {
    const geometry = _objects.update(fullScreenMesh);
    if (shadowMaterialVertical.defines.VSM_SAMPLES !== shadow2.blurSamples) {
      shadowMaterialVertical.defines.VSM_SAMPLES = shadow2.blurSamples;
      shadowMaterialHorizontal.defines.VSM_SAMPLES = shadow2.blurSamples;
      shadowMaterialVertical.needsUpdate = true;
      shadowMaterialHorizontal.needsUpdate = true;
    }
    shadowMaterialVertical.uniforms.shadow_pass.value = shadow2.map.texture;
    shadowMaterialVertical.uniforms.resolution.value = shadow2.mapSize;
    shadowMaterialVertical.uniforms.radius.value = shadow2.radius;
    _renderer.setRenderTarget(shadow2.mapPass);
    _renderer.clear();
    _renderer.renderBufferDirect(camera, null, geometry, shadowMaterialVertical, fullScreenMesh, null);
    shadowMaterialHorizontal.uniforms.shadow_pass.value = shadow2.mapPass.texture;
    shadowMaterialHorizontal.uniforms.resolution.value = shadow2.mapSize;
    shadowMaterialHorizontal.uniforms.radius.value = shadow2.radius;
    _renderer.setRenderTarget(shadow2.map);
    _renderer.clear();
    _renderer.renderBufferDirect(camera, null, geometry, shadowMaterialHorizontal, fullScreenMesh, null);
  }
  function getDepthMaterial(object, material, light2, shadowCameraNear, shadowCameraFar, type) {
    let result = null;
    const customMaterial = light2.isPointLight === true ? object.customDistanceMaterial : object.customDepthMaterial;
    if (customMaterial !== void 0) {
      result = customMaterial;
    } else {
      result = light2.isPointLight === true ? _distanceMaterial : _depthMaterial;
    }
    if (_renderer.localClippingEnabled && material.clipShadows === true && material.clippingPlanes.length !== 0 || material.displacementMap && material.displacementScale !== 0 || material.alphaMap && material.alphaTest > 0) {
      const keyA = result.uuid, keyB = material.uuid;
      let materialsForVariant = _materialCache[keyA];
      if (materialsForVariant === void 0) {
        materialsForVariant = {};
        _materialCache[keyA] = materialsForVariant;
      }
      let cachedMaterial = materialsForVariant[keyB];
      if (cachedMaterial === void 0) {
        cachedMaterial = result.clone();
        materialsForVariant[keyB] = cachedMaterial;
      }
      result = cachedMaterial;
    }
    result.visible = material.visible;
    result.wireframe = material.wireframe;
    if (type === VSMShadowMap) {
      result.side = material.shadowSide !== null ? material.shadowSide : material.side;
    } else {
      result.side = material.shadowSide !== null ? material.shadowSide : shadowSide[material.side];
    }
    result.alphaMap = material.alphaMap;
    result.alphaTest = material.alphaTest;
    result.clipShadows = material.clipShadows;
    result.clippingPlanes = material.clippingPlanes;
    result.clipIntersection = material.clipIntersection;
    result.displacementMap = material.displacementMap;
    result.displacementScale = material.displacementScale;
    result.displacementBias = material.displacementBias;
    result.wireframeLinewidth = material.wireframeLinewidth;
    result.linewidth = material.linewidth;
    if (light2.isPointLight === true && result.isMeshDistanceMaterial === true) {
      result.referencePosition.setFromMatrixPosition(light2.matrixWorld);
      result.nearDistance = shadowCameraNear;
      result.farDistance = shadowCameraFar;
    }
    return result;
  }
  function renderObject(object, camera, shadowCamera, light2, type) {
    if (object.visible === false)
      return;
    const visible2 = object.layers.test(camera.layers);
    if (visible2 && (object.isMesh || object.isLine || object.isPoints)) {
      if ((object.castShadow || object.receiveShadow && type === VSMShadowMap) && (!object.frustumCulled || _frustum.intersectsObject(object))) {
        object.modelViewMatrix.multiplyMatrices(shadowCamera.matrixWorldInverse, object.matrixWorld);
        const geometry = _objects.update(object);
        const material = object.material;
        if (Array.isArray(material)) {
          const groups = geometry.groups;
          for (let k = 0, kl = groups.length; k < kl; k++) {
            const group2 = groups[k];
            const groupMaterial = material[group2.materialIndex];
            if (groupMaterial && groupMaterial.visible) {
              const depthMaterial = getDepthMaterial(object, groupMaterial, light2, shadowCamera.near, shadowCamera.far, type);
              _renderer.renderBufferDirect(shadowCamera, null, geometry, depthMaterial, object, group2);
            }
          }
        } else if (material.visible) {
          const depthMaterial = getDepthMaterial(object, material, light2, shadowCamera.near, shadowCamera.far, type);
          _renderer.renderBufferDirect(shadowCamera, null, geometry, depthMaterial, object, null);
        }
      }
    }
    const children2 = object.children;
    for (let i = 0, l = children2.length; i < l; i++) {
      renderObject(children2[i], camera, shadowCamera, light2, type);
    }
  }
}
function WebGLState(gl, extensions, capabilities) {
  const isWebGL2 = capabilities.isWebGL2;
  function ColorBuffer() {
    let locked = false;
    const color2 = new Vector4();
    let currentColorMask = null;
    const currentColorClear = new Vector4(0, 0, 0, 0);
    return {
      setMask: function(colorMask) {
        if (currentColorMask !== colorMask && !locked) {
          gl.colorMask(colorMask, colorMask, colorMask, colorMask);
          currentColorMask = colorMask;
        }
      },
      setLocked: function(lock2) {
        locked = lock2;
      },
      setClear: function(r, g, b, a, premultipliedAlpha) {
        if (premultipliedAlpha === true) {
          r *= a;
          g *= a;
          b *= a;
        }
        color2.set(r, g, b, a);
        if (currentColorClear.equals(color2) === false) {
          gl.clearColor(r, g, b, a);
          currentColorClear.copy(color2);
        }
      },
      reset: function() {
        locked = false;
        currentColorMask = null;
        currentColorClear.set(-1, 0, 0, 0);
      }
    };
  }
  function DepthBuffer() {
    let locked = false;
    let currentDepthMask = null;
    let currentDepthFunc = null;
    let currentDepthClear = null;
    return {
      setTest: function(depthTest) {
        if (depthTest) {
          enable(2929);
        } else {
          disable(2929);
        }
      },
      setMask: function(depthMask) {
        if (currentDepthMask !== depthMask && !locked) {
          gl.depthMask(depthMask);
          currentDepthMask = depthMask;
        }
      },
      setFunc: function(depthFunc) {
        if (currentDepthFunc !== depthFunc) {
          if (depthFunc) {
            switch (depthFunc) {
              case NeverDepth:
                gl.depthFunc(512);
                break;
              case AlwaysDepth:
                gl.depthFunc(519);
                break;
              case LessDepth:
                gl.depthFunc(513);
                break;
              case LessEqualDepth:
                gl.depthFunc(515);
                break;
              case EqualDepth:
                gl.depthFunc(514);
                break;
              case GreaterEqualDepth:
                gl.depthFunc(518);
                break;
              case GreaterDepth:
                gl.depthFunc(516);
                break;
              case NotEqualDepth:
                gl.depthFunc(517);
                break;
              default:
                gl.depthFunc(515);
            }
          } else {
            gl.depthFunc(515);
          }
          currentDepthFunc = depthFunc;
        }
      },
      setLocked: function(lock2) {
        locked = lock2;
      },
      setClear: function(depth) {
        if (currentDepthClear !== depth) {
          gl.clearDepth(depth);
          currentDepthClear = depth;
        }
      },
      reset: function() {
        locked = false;
        currentDepthMask = null;
        currentDepthFunc = null;
        currentDepthClear = null;
      }
    };
  }
  function StencilBuffer() {
    let locked = false;
    let currentStencilMask = null;
    let currentStencilFunc = null;
    let currentStencilRef = null;
    let currentStencilFuncMask = null;
    let currentStencilFail = null;
    let currentStencilZFail = null;
    let currentStencilZPass = null;
    let currentStencilClear = null;
    return {
      setTest: function(stencilTest) {
        if (!locked) {
          if (stencilTest) {
            enable(2960);
          } else {
            disable(2960);
          }
        }
      },
      setMask: function(stencilMask) {
        if (currentStencilMask !== stencilMask && !locked) {
          gl.stencilMask(stencilMask);
          currentStencilMask = stencilMask;
        }
      },
      setFunc: function(stencilFunc, stencilRef, stencilMask) {
        if (currentStencilFunc !== stencilFunc || currentStencilRef !== stencilRef || currentStencilFuncMask !== stencilMask) {
          gl.stencilFunc(stencilFunc, stencilRef, stencilMask);
          currentStencilFunc = stencilFunc;
          currentStencilRef = stencilRef;
          currentStencilFuncMask = stencilMask;
        }
      },
      setOp: function(stencilFail, stencilZFail, stencilZPass) {
        if (currentStencilFail !== stencilFail || currentStencilZFail !== stencilZFail || currentStencilZPass !== stencilZPass) {
          gl.stencilOp(stencilFail, stencilZFail, stencilZPass);
          currentStencilFail = stencilFail;
          currentStencilZFail = stencilZFail;
          currentStencilZPass = stencilZPass;
        }
      },
      setLocked: function(lock2) {
        locked = lock2;
      },
      setClear: function(stencil) {
        if (currentStencilClear !== stencil) {
          gl.clearStencil(stencil);
          currentStencilClear = stencil;
        }
      },
      reset: function() {
        locked = false;
        currentStencilMask = null;
        currentStencilFunc = null;
        currentStencilRef = null;
        currentStencilFuncMask = null;
        currentStencilFail = null;
        currentStencilZFail = null;
        currentStencilZPass = null;
        currentStencilClear = null;
      }
    };
  }
  const colorBuffer = new ColorBuffer();
  const depthBuffer = new DepthBuffer();
  const stencilBuffer = new StencilBuffer();
  let enabledCapabilities = {};
  let currentBoundFramebuffers = {};
  let currentDrawbuffers = /* @__PURE__ */ new WeakMap();
  let defaultDrawbuffers = [];
  let currentProgram = null;
  let currentBlendingEnabled = false;
  let currentBlending = null;
  let currentBlendEquation = null;
  let currentBlendSrc = null;
  let currentBlendDst = null;
  let currentBlendEquationAlpha = null;
  let currentBlendSrcAlpha = null;
  let currentBlendDstAlpha = null;
  let currentPremultipledAlpha = false;
  let currentFlipSided = null;
  let currentCullFace = null;
  let currentLineWidth = null;
  let currentPolygonOffsetFactor = null;
  let currentPolygonOffsetUnits = null;
  const maxTextures = gl.getParameter(35661);
  let lineWidthAvailable = false;
  let version = 0;
  const glVersion = gl.getParameter(7938);
  if (glVersion.indexOf("WebGL") !== -1) {
    version = parseFloat(/^WebGL (\d)/.exec(glVersion)[1]);
    lineWidthAvailable = version >= 1;
  } else if (glVersion.indexOf("OpenGL ES") !== -1) {
    version = parseFloat(/^OpenGL ES (\d)/.exec(glVersion)[1]);
    lineWidthAvailable = version >= 2;
  }
  let currentTextureSlot = null;
  let currentBoundTextures = {};
  const scissorParam = gl.getParameter(3088);
  const viewportParam = gl.getParameter(2978);
  const currentScissor = new Vector4().fromArray(scissorParam);
  const currentViewport = new Vector4().fromArray(viewportParam);
  function createTexture(type, target, count) {
    const data = new Uint8Array(4);
    const texture2 = gl.createTexture();
    gl.bindTexture(type, texture2);
    gl.texParameteri(type, 10241, 9728);
    gl.texParameteri(type, 10240, 9728);
    for (let i = 0; i < count; i++) {
      gl.texImage2D(target + i, 0, 6408, 1, 1, 0, 6408, 5121, data);
    }
    return texture2;
  }
  const emptyTextures = {};
  emptyTextures[3553] = createTexture(3553, 3553, 1);
  emptyTextures[34067] = createTexture(34067, 34069, 6);
  colorBuffer.setClear(0, 0, 0, 1);
  depthBuffer.setClear(1);
  stencilBuffer.setClear(0);
  enable(2929);
  depthBuffer.setFunc(LessEqualDepth);
  setFlipSided(false);
  setCullFace(CullFaceBack);
  enable(2884);
  setBlending(NoBlending);
  function enable(id) {
    if (enabledCapabilities[id] !== true) {
      gl.enable(id);
      enabledCapabilities[id] = true;
    }
  }
  function disable(id) {
    if (enabledCapabilities[id] !== false) {
      gl.disable(id);
      enabledCapabilities[id] = false;
    }
  }
  function bindFramebuffer(target, framebuffer) {
    if (currentBoundFramebuffers[target] !== framebuffer) {
      gl.bindFramebuffer(target, framebuffer);
      currentBoundFramebuffers[target] = framebuffer;
      if (isWebGL2) {
        if (target === 36009) {
          currentBoundFramebuffers[36160] = framebuffer;
        }
        if (target === 36160) {
          currentBoundFramebuffers[36009] = framebuffer;
        }
      }
      return true;
    }
    return false;
  }
  function drawBuffers(renderTarget, framebuffer) {
    let drawBuffers2 = defaultDrawbuffers;
    let needsUpdate = false;
    if (renderTarget) {
      drawBuffers2 = currentDrawbuffers.get(framebuffer);
      if (drawBuffers2 === void 0) {
        drawBuffers2 = [];
        currentDrawbuffers.set(framebuffer, drawBuffers2);
      }
      if (renderTarget.isWebGLMultipleRenderTargets) {
        const textures = renderTarget.texture;
        if (drawBuffers2.length !== textures.length || drawBuffers2[0] !== 36064) {
          for (let i = 0, il = textures.length; i < il; i++) {
            drawBuffers2[i] = 36064 + i;
          }
          drawBuffers2.length = textures.length;
          needsUpdate = true;
        }
      } else {
        if (drawBuffers2[0] !== 36064) {
          drawBuffers2[0] = 36064;
          needsUpdate = true;
        }
      }
    } else {
      if (drawBuffers2[0] !== 1029) {
        drawBuffers2[0] = 1029;
        needsUpdate = true;
      }
    }
    if (needsUpdate) {
      if (capabilities.isWebGL2) {
        gl.drawBuffers(drawBuffers2);
      } else {
        extensions.get("WEBGL_draw_buffers").drawBuffersWEBGL(drawBuffers2);
      }
    }
  }
  function useProgram(program) {
    if (currentProgram !== program) {
      gl.useProgram(program);
      currentProgram = program;
      return true;
    }
    return false;
  }
  const equationToGL = {
    [AddEquation]: 32774,
    [SubtractEquation]: 32778,
    [ReverseSubtractEquation]: 32779
  };
  if (isWebGL2) {
    equationToGL[MinEquation] = 32775;
    equationToGL[MaxEquation] = 32776;
  } else {
    const extension = extensions.get("EXT_blend_minmax");
    if (extension !== null) {
      equationToGL[MinEquation] = extension.MIN_EXT;
      equationToGL[MaxEquation] = extension.MAX_EXT;
    }
  }
  const factorToGL = {
    [ZeroFactor]: 0,
    [OneFactor]: 1,
    [SrcColorFactor]: 768,
    [SrcAlphaFactor]: 770,
    [SrcAlphaSaturateFactor]: 776,
    [DstColorFactor]: 774,
    [DstAlphaFactor]: 772,
    [OneMinusSrcColorFactor]: 769,
    [OneMinusSrcAlphaFactor]: 771,
    [OneMinusDstColorFactor]: 775,
    [OneMinusDstAlphaFactor]: 773
  };
  function setBlending(blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, premultipliedAlpha) {
    if (blending === NoBlending) {
      if (currentBlendingEnabled === true) {
        disable(3042);
        currentBlendingEnabled = false;
      }
      return;
    }
    if (currentBlendingEnabled === false) {
      enable(3042);
      currentBlendingEnabled = true;
    }
    if (blending !== CustomBlending) {
      if (blending !== currentBlending || premultipliedAlpha !== currentPremultipledAlpha) {
        if (currentBlendEquation !== AddEquation || currentBlendEquationAlpha !== AddEquation) {
          gl.blendEquation(32774);
          currentBlendEquation = AddEquation;
          currentBlendEquationAlpha = AddEquation;
        }
        if (premultipliedAlpha) {
          switch (blending) {
            case NormalBlending:
              gl.blendFuncSeparate(1, 771, 1, 771);
              break;
            case AdditiveBlending:
              gl.blendFunc(1, 1);
              break;
            case SubtractiveBlending:
              gl.blendFuncSeparate(0, 769, 0, 1);
              break;
            case MultiplyBlending:
              gl.blendFuncSeparate(0, 768, 0, 770);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", blending);
              break;
          }
        } else {
          switch (blending) {
            case NormalBlending:
              gl.blendFuncSeparate(770, 771, 1, 771);
              break;
            case AdditiveBlending:
              gl.blendFunc(770, 1);
              break;
            case SubtractiveBlending:
              gl.blendFuncSeparate(0, 769, 0, 1);
              break;
            case MultiplyBlending:
              gl.blendFunc(0, 768);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", blending);
              break;
          }
        }
        currentBlendSrc = null;
        currentBlendDst = null;
        currentBlendSrcAlpha = null;
        currentBlendDstAlpha = null;
        currentBlending = blending;
        currentPremultipledAlpha = premultipliedAlpha;
      }
      return;
    }
    blendEquationAlpha = blendEquationAlpha || blendEquation;
    blendSrcAlpha = blendSrcAlpha || blendSrc;
    blendDstAlpha = blendDstAlpha || blendDst;
    if (blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha) {
      gl.blendEquationSeparate(equationToGL[blendEquation], equationToGL[blendEquationAlpha]);
      currentBlendEquation = blendEquation;
      currentBlendEquationAlpha = blendEquationAlpha;
    }
    if (blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha) {
      gl.blendFuncSeparate(factorToGL[blendSrc], factorToGL[blendDst], factorToGL[blendSrcAlpha], factorToGL[blendDstAlpha]);
      currentBlendSrc = blendSrc;
      currentBlendDst = blendDst;
      currentBlendSrcAlpha = blendSrcAlpha;
      currentBlendDstAlpha = blendDstAlpha;
    }
    currentBlending = blending;
    currentPremultipledAlpha = null;
  }
  function setMaterial(material, frontFaceCW) {
    material.side === DoubleSide ? disable(2884) : enable(2884);
    let flipSided = material.side === BackSide;
    if (frontFaceCW)
      flipSided = !flipSided;
    setFlipSided(flipSided);
    material.blending === NormalBlending && material.transparent === false ? setBlending(NoBlending) : setBlending(material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha);
    depthBuffer.setFunc(material.depthFunc);
    depthBuffer.setTest(material.depthTest);
    depthBuffer.setMask(material.depthWrite);
    colorBuffer.setMask(material.colorWrite);
    const stencilWrite = material.stencilWrite;
    stencilBuffer.setTest(stencilWrite);
    if (stencilWrite) {
      stencilBuffer.setMask(material.stencilWriteMask);
      stencilBuffer.setFunc(material.stencilFunc, material.stencilRef, material.stencilFuncMask);
      stencilBuffer.setOp(material.stencilFail, material.stencilZFail, material.stencilZPass);
    }
    setPolygonOffset(material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits);
    material.alphaToCoverage === true ? enable(32926) : disable(32926);
  }
  function setFlipSided(flipSided) {
    if (currentFlipSided !== flipSided) {
      if (flipSided) {
        gl.frontFace(2304);
      } else {
        gl.frontFace(2305);
      }
      currentFlipSided = flipSided;
    }
  }
  function setCullFace(cullFace) {
    if (cullFace !== CullFaceNone) {
      enable(2884);
      if (cullFace !== currentCullFace) {
        if (cullFace === CullFaceBack) {
          gl.cullFace(1029);
        } else if (cullFace === CullFaceFront) {
          gl.cullFace(1028);
        } else {
          gl.cullFace(1032);
        }
      }
    } else {
      disable(2884);
    }
    currentCullFace = cullFace;
  }
  function setLineWidth(width2) {
    if (width2 !== currentLineWidth) {
      if (lineWidthAvailable)
        gl.lineWidth(width2);
      currentLineWidth = width2;
    }
  }
  function setPolygonOffset(polygonOffset, factor, units) {
    if (polygonOffset) {
      enable(32823);
      if (currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units) {
        gl.polygonOffset(factor, units);
        currentPolygonOffsetFactor = factor;
        currentPolygonOffsetUnits = units;
      }
    } else {
      disable(32823);
    }
  }
  function setScissorTest(scissorTest) {
    if (scissorTest) {
      enable(3089);
    } else {
      disable(3089);
    }
  }
  function activeTexture(webglSlot) {
    if (webglSlot === void 0)
      webglSlot = 33984 + maxTextures - 1;
    if (currentTextureSlot !== webglSlot) {
      gl.activeTexture(webglSlot);
      currentTextureSlot = webglSlot;
    }
  }
  function bindTexture(webglType, webglTexture) {
    if (currentTextureSlot === null) {
      activeTexture();
    }
    let boundTexture = currentBoundTextures[currentTextureSlot];
    if (boundTexture === void 0) {
      boundTexture = { type: void 0, texture: void 0 };
      currentBoundTextures[currentTextureSlot] = boundTexture;
    }
    if (boundTexture.type !== webglType || boundTexture.texture !== webglTexture) {
      gl.bindTexture(webglType, webglTexture || emptyTextures[webglType]);
      boundTexture.type = webglType;
      boundTexture.texture = webglTexture;
    }
  }
  function unbindTexture() {
    const boundTexture = currentBoundTextures[currentTextureSlot];
    if (boundTexture !== void 0 && boundTexture.type !== void 0) {
      gl.bindTexture(boundTexture.type, null);
      boundTexture.type = void 0;
      boundTexture.texture = void 0;
    }
  }
  function compressedTexImage2D() {
    try {
      gl.compressedTexImage2D.apply(gl, arguments);
    } catch (error) {
      console.error("THREE.WebGLState:", error);
    }
  }
  function texSubImage2D() {
    try {
      gl.texSubImage2D.apply(gl, arguments);
    } catch (error) {
      console.error("THREE.WebGLState:", error);
    }
  }
  function texSubImage3D() {
    try {
      gl.texSubImage3D.apply(gl, arguments);
    } catch (error) {
      console.error("THREE.WebGLState:", error);
    }
  }
  function compressedTexSubImage2D() {
    try {
      gl.compressedTexSubImage2D.apply(gl, arguments);
    } catch (error) {
      console.error("THREE.WebGLState:", error);
    }
  }
  function texStorage2D() {
    try {
      gl.texStorage2D.apply(gl, arguments);
    } catch (error) {
      console.error("THREE.WebGLState:", error);
    }
  }
  function texStorage3D() {
    try {
      gl.texStorage3D.apply(gl, arguments);
    } catch (error) {
      console.error("THREE.WebGLState:", error);
    }
  }
  function texImage2D() {
    try {
      gl.texImage2D.apply(gl, arguments);
    } catch (error) {
      console.error("THREE.WebGLState:", error);
    }
  }
  function texImage3D() {
    try {
      gl.texImage3D.apply(gl, arguments);
    } catch (error) {
      console.error("THREE.WebGLState:", error);
    }
  }
  function scissor(scissor2) {
    if (currentScissor.equals(scissor2) === false) {
      gl.scissor(scissor2.x, scissor2.y, scissor2.z, scissor2.w);
      currentScissor.copy(scissor2);
    }
  }
  function viewport(viewport2) {
    if (currentViewport.equals(viewport2) === false) {
      gl.viewport(viewport2.x, viewport2.y, viewport2.z, viewport2.w);
      currentViewport.copy(viewport2);
    }
  }
  function reset() {
    gl.disable(3042);
    gl.disable(2884);
    gl.disable(2929);
    gl.disable(32823);
    gl.disable(3089);
    gl.disable(2960);
    gl.disable(32926);
    gl.blendEquation(32774);
    gl.blendFunc(1, 0);
    gl.blendFuncSeparate(1, 0, 1, 0);
    gl.colorMask(true, true, true, true);
    gl.clearColor(0, 0, 0, 0);
    gl.depthMask(true);
    gl.depthFunc(513);
    gl.clearDepth(1);
    gl.stencilMask(4294967295);
    gl.stencilFunc(519, 0, 4294967295);
    gl.stencilOp(7680, 7680, 7680);
    gl.clearStencil(0);
    gl.cullFace(1029);
    gl.frontFace(2305);
    gl.polygonOffset(0, 0);
    gl.activeTexture(33984);
    gl.bindFramebuffer(36160, null);
    if (isWebGL2 === true) {
      gl.bindFramebuffer(36009, null);
      gl.bindFramebuffer(36008, null);
    }
    gl.useProgram(null);
    gl.lineWidth(1);
    gl.scissor(0, 0, gl.canvas.width, gl.canvas.height);
    gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
    enabledCapabilities = {};
    currentTextureSlot = null;
    currentBoundTextures = {};
    currentBoundFramebuffers = {};
    currentDrawbuffers = /* @__PURE__ */ new WeakMap();
    defaultDrawbuffers = [];
    currentProgram = null;
    currentBlendingEnabled = false;
    currentBlending = null;
    currentBlendEquation = null;
    currentBlendSrc = null;
    currentBlendDst = null;
    currentBlendEquationAlpha = null;
    currentBlendSrcAlpha = null;
    currentBlendDstAlpha = null;
    currentPremultipledAlpha = false;
    currentFlipSided = null;
    currentCullFace = null;
    currentLineWidth = null;
    currentPolygonOffsetFactor = null;
    currentPolygonOffsetUnits = null;
    currentScissor.set(0, 0, gl.canvas.width, gl.canvas.height);
    currentViewport.set(0, 0, gl.canvas.width, gl.canvas.height);
    colorBuffer.reset();
    depthBuffer.reset();
    stencilBuffer.reset();
  }
  return {
    buffers: {
      color: colorBuffer,
      depth: depthBuffer,
      stencil: stencilBuffer
    },
    enable,
    disable,
    bindFramebuffer,
    drawBuffers,
    useProgram,
    setBlending,
    setMaterial,
    setFlipSided,
    setCullFace,
    setLineWidth,
    setPolygonOffset,
    setScissorTest,
    activeTexture,
    bindTexture,
    unbindTexture,
    compressedTexImage2D,
    texImage2D,
    texImage3D,
    texStorage2D,
    texStorage3D,
    texSubImage2D,
    texSubImage3D,
    compressedTexSubImage2D,
    scissor,
    viewport,
    reset
  };
}
function WebGLTextures(_gl, extensions, state, properties, capabilities, utils, info) {
  const isWebGL2 = capabilities.isWebGL2;
  const maxTextures = capabilities.maxTextures;
  const maxCubemapSize = capabilities.maxCubemapSize;
  const maxTextureSize = capabilities.maxTextureSize;
  const maxSamples = capabilities.maxSamples;
  const multisampledRTTExt = extensions.has("WEBGL_multisampled_render_to_texture") ? extensions.get("WEBGL_multisampled_render_to_texture") : null;
  const supportsInvalidateFramebuffer = /OculusBrowser/g.test(navigator.userAgent);
  const _videoTextures = /* @__PURE__ */ new WeakMap();
  let _canvas2;
  const _sources = /* @__PURE__ */ new WeakMap();
  let useOffscreenCanvas = false;
  try {
    useOffscreenCanvas = typeof OffscreenCanvas !== "undefined" && new OffscreenCanvas(1, 1).getContext("2d") !== null;
  } catch (err) {
  }
  function createCanvas(width2, height2) {
    return useOffscreenCanvas ? new OffscreenCanvas(width2, height2) : createElementNS("canvas");
  }
  function resizeImage(image2, needsPowerOfTwo, needsNewCanvas, maxSize) {
    let scale2 = 1;
    if (image2.width > maxSize || image2.height > maxSize) {
      scale2 = maxSize / Math.max(image2.width, image2.height);
    }
    if (scale2 < 1 || needsPowerOfTwo === true) {
      if (typeof HTMLImageElement !== "undefined" && image2 instanceof HTMLImageElement || typeof HTMLCanvasElement !== "undefined" && image2 instanceof HTMLCanvasElement || typeof ImageBitmap !== "undefined" && image2 instanceof ImageBitmap) {
        const floor2 = needsPowerOfTwo ? floorPowerOfTwo : Math.floor;
        const width2 = floor2(scale2 * image2.width);
        const height2 = floor2(scale2 * image2.height);
        if (_canvas2 === void 0)
          _canvas2 = createCanvas(width2, height2);
        const canvas = needsNewCanvas ? createCanvas(width2, height2) : _canvas2;
        canvas.width = width2;
        canvas.height = height2;
        const context = canvas.getContext("2d");
        context.drawImage(image2, 0, 0, width2, height2);
        console.warn("THREE.WebGLRenderer: Texture has been resized from (" + image2.width + "x" + image2.height + ") to (" + width2 + "x" + height2 + ").");
        return canvas;
      } else {
        if ("data" in image2) {
          console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + image2.width + "x" + image2.height + ").");
        }
        return image2;
      }
    }
    return image2;
  }
  function isPowerOfTwo$1(image2) {
    return isPowerOfTwo(image2.width) && isPowerOfTwo(image2.height);
  }
  function textureNeedsPowerOfTwo(texture2) {
    if (isWebGL2)
      return false;
    return texture2.wrapS !== ClampToEdgeWrapping || texture2.wrapT !== ClampToEdgeWrapping || texture2.minFilter !== NearestFilter && texture2.minFilter !== LinearFilter;
  }
  function textureNeedsGenerateMipmaps(texture2, supportsMips) {
    return texture2.generateMipmaps && supportsMips && texture2.minFilter !== NearestFilter && texture2.minFilter !== LinearFilter;
  }
  function generateMipmap(target) {
    _gl.generateMipmap(target);
  }
  function getInternalFormat(internalFormatName, glFormat, glType, encoding, isVideoTexture = false) {
    if (isWebGL2 === false)
      return glFormat;
    if (internalFormatName !== null) {
      if (_gl[internalFormatName] !== void 0)
        return _gl[internalFormatName];
      console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + internalFormatName + "'");
    }
    let internalFormat = glFormat;
    if (glFormat === 6403) {
      if (glType === 5126)
        internalFormat = 33326;
      if (glType === 5131)
        internalFormat = 33325;
      if (glType === 5121)
        internalFormat = 33321;
    }
    if (glFormat === 33319) {
      if (glType === 5126)
        internalFormat = 33328;
      if (glType === 5131)
        internalFormat = 33327;
      if (glType === 5121)
        internalFormat = 33323;
    }
    if (glFormat === 6408) {
      if (glType === 5126)
        internalFormat = 34836;
      if (glType === 5131)
        internalFormat = 34842;
      if (glType === 5121)
        internalFormat = encoding === sRGBEncoding && isVideoTexture === false ? 35907 : 32856;
      if (glType === 32819)
        internalFormat = 32854;
      if (glType === 32820)
        internalFormat = 32855;
    }
    if (internalFormat === 33325 || internalFormat === 33326 || internalFormat === 33327 || internalFormat === 33328 || internalFormat === 34842 || internalFormat === 34836) {
      extensions.get("EXT_color_buffer_float");
    }
    return internalFormat;
  }
  function getMipLevels(texture2, image2, supportsMips) {
    if (textureNeedsGenerateMipmaps(texture2, supportsMips) === true || texture2.isFramebufferTexture && texture2.minFilter !== NearestFilter && texture2.minFilter !== LinearFilter) {
      return Math.log2(Math.max(image2.width, image2.height)) + 1;
    } else if (texture2.mipmaps !== void 0 && texture2.mipmaps.length > 0) {
      return texture2.mipmaps.length;
    } else if (texture2.isCompressedTexture && Array.isArray(texture2.image)) {
      return image2.mipmaps.length;
    } else {
      return 1;
    }
  }
  function filterFallback(f) {
    if (f === NearestFilter || f === NearestMipmapNearestFilter || f === NearestMipmapLinearFilter) {
      return 9728;
    }
    return 9729;
  }
  function onTextureDispose(event) {
    const texture2 = event.target;
    texture2.removeEventListener("dispose", onTextureDispose);
    deallocateTexture(texture2);
    if (texture2.isVideoTexture) {
      _videoTextures.delete(texture2);
    }
  }
  function onRenderTargetDispose(event) {
    const renderTarget = event.target;
    renderTarget.removeEventListener("dispose", onRenderTargetDispose);
    deallocateRenderTarget(renderTarget);
  }
  function deallocateTexture(texture2) {
    const textureProperties = properties.get(texture2);
    if (textureProperties.__webglInit === void 0)
      return;
    const source2 = texture2.source;
    const webglTextures = _sources.get(source2);
    if (webglTextures) {
      const webglTexture = webglTextures[textureProperties.__cacheKey];
      webglTexture.usedTimes--;
      if (webglTexture.usedTimes === 0) {
        deleteTexture(texture2);
      }
      if (Object.keys(webglTextures).length === 0) {
        _sources.delete(source2);
      }
    }
    properties.remove(texture2);
  }
  function deleteTexture(texture2) {
    const textureProperties = properties.get(texture2);
    _gl.deleteTexture(textureProperties.__webglTexture);
    const source2 = texture2.source;
    const webglTextures = _sources.get(source2);
    delete webglTextures[textureProperties.__cacheKey];
    info.memory.textures--;
  }
  function deallocateRenderTarget(renderTarget) {
    const texture2 = renderTarget.texture;
    const renderTargetProperties = properties.get(renderTarget);
    const textureProperties = properties.get(texture2);
    if (textureProperties.__webglTexture !== void 0) {
      _gl.deleteTexture(textureProperties.__webglTexture);
      info.memory.textures--;
    }
    if (renderTarget.depthTexture) {
      renderTarget.depthTexture.dispose();
    }
    if (renderTarget.isWebGLCubeRenderTarget) {
      for (let i = 0; i < 6; i++) {
        _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer[i]);
        if (renderTargetProperties.__webglDepthbuffer)
          _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer[i]);
      }
    } else {
      _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer);
      if (renderTargetProperties.__webglDepthbuffer)
        _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer);
      if (renderTargetProperties.__webglMultisampledFramebuffer)
        _gl.deleteFramebuffer(renderTargetProperties.__webglMultisampledFramebuffer);
      if (renderTargetProperties.__webglColorRenderbuffer)
        _gl.deleteRenderbuffer(renderTargetProperties.__webglColorRenderbuffer);
      if (renderTargetProperties.__webglDepthRenderbuffer)
        _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthRenderbuffer);
    }
    if (renderTarget.isWebGLMultipleRenderTargets) {
      for (let i = 0, il = texture2.length; i < il; i++) {
        const attachmentProperties = properties.get(texture2[i]);
        if (attachmentProperties.__webglTexture) {
          _gl.deleteTexture(attachmentProperties.__webglTexture);
          info.memory.textures--;
        }
        properties.remove(texture2[i]);
      }
    }
    properties.remove(texture2);
    properties.remove(renderTarget);
  }
  let textureUnits = 0;
  function resetTextureUnits() {
    textureUnits = 0;
  }
  function allocateTextureUnit() {
    const textureUnit = textureUnits;
    if (textureUnit >= maxTextures) {
      console.warn("THREE.WebGLTextures: Trying to use " + textureUnit + " texture units while this GPU supports only " + maxTextures);
    }
    textureUnits += 1;
    return textureUnit;
  }
  function getTextureCacheKey(texture2) {
    const array = [];
    array.push(texture2.wrapS);
    array.push(texture2.wrapT);
    array.push(texture2.magFilter);
    array.push(texture2.minFilter);
    array.push(texture2.anisotropy);
    array.push(texture2.internalFormat);
    array.push(texture2.format);
    array.push(texture2.type);
    array.push(texture2.generateMipmaps);
    array.push(texture2.premultiplyAlpha);
    array.push(texture2.flipY);
    array.push(texture2.unpackAlignment);
    array.push(texture2.encoding);
    return array.join();
  }
  function setTexture2D(texture2, slot) {
    const textureProperties = properties.get(texture2);
    if (texture2.isVideoTexture)
      updateVideoTexture(texture2);
    if (texture2.isRenderTargetTexture === false && texture2.version > 0 && textureProperties.__version !== texture2.version) {
      const image2 = texture2.image;
      if (image2 === null) {
        console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");
      } else if (image2.complete === false) {
        console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");
      } else {
        uploadTexture(textureProperties, texture2, slot);
        return;
      }
    }
    state.activeTexture(33984 + slot);
    state.bindTexture(3553, textureProperties.__webglTexture);
  }
  function setTexture2DArray(texture2, slot) {
    const textureProperties = properties.get(texture2);
    if (texture2.version > 0 && textureProperties.__version !== texture2.version) {
      uploadTexture(textureProperties, texture2, slot);
      return;
    }
    state.activeTexture(33984 + slot);
    state.bindTexture(35866, textureProperties.__webglTexture);
  }
  function setTexture3D(texture2, slot) {
    const textureProperties = properties.get(texture2);
    if (texture2.version > 0 && textureProperties.__version !== texture2.version) {
      uploadTexture(textureProperties, texture2, slot);
      return;
    }
    state.activeTexture(33984 + slot);
    state.bindTexture(32879, textureProperties.__webglTexture);
  }
  function setTextureCube(texture2, slot) {
    const textureProperties = properties.get(texture2);
    if (texture2.version > 0 && textureProperties.__version !== texture2.version) {
      uploadCubeTexture(textureProperties, texture2, slot);
      return;
    }
    state.activeTexture(33984 + slot);
    state.bindTexture(34067, textureProperties.__webglTexture);
  }
  const wrappingToGL = {
    [RepeatWrapping]: 10497,
    [ClampToEdgeWrapping]: 33071,
    [MirroredRepeatWrapping]: 33648
  };
  const filterToGL = {
    [NearestFilter]: 9728,
    [NearestMipmapNearestFilter]: 9984,
    [NearestMipmapLinearFilter]: 9986,
    [LinearFilter]: 9729,
    [LinearMipmapNearestFilter]: 9985,
    [LinearMipmapLinearFilter]: 9987
  };
  function setTextureParameters(textureType, texture2, supportsMips) {
    if (supportsMips) {
      _gl.texParameteri(textureType, 10242, wrappingToGL[texture2.wrapS]);
      _gl.texParameteri(textureType, 10243, wrappingToGL[texture2.wrapT]);
      if (textureType === 32879 || textureType === 35866) {
        _gl.texParameteri(textureType, 32882, wrappingToGL[texture2.wrapR]);
      }
      _gl.texParameteri(textureType, 10240, filterToGL[texture2.magFilter]);
      _gl.texParameteri(textureType, 10241, filterToGL[texture2.minFilter]);
    } else {
      _gl.texParameteri(textureType, 10242, 33071);
      _gl.texParameteri(textureType, 10243, 33071);
      if (textureType === 32879 || textureType === 35866) {
        _gl.texParameteri(textureType, 32882, 33071);
      }
      if (texture2.wrapS !== ClampToEdgeWrapping || texture2.wrapT !== ClampToEdgeWrapping) {
        console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.");
      }
      _gl.texParameteri(textureType, 10240, filterFallback(texture2.magFilter));
      _gl.texParameteri(textureType, 10241, filterFallback(texture2.minFilter));
      if (texture2.minFilter !== NearestFilter && texture2.minFilter !== LinearFilter) {
        console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.");
      }
    }
    if (extensions.has("EXT_texture_filter_anisotropic") === true) {
      const extension = extensions.get("EXT_texture_filter_anisotropic");
      if (texture2.type === FloatType && extensions.has("OES_texture_float_linear") === false)
        return;
      if (isWebGL2 === false && (texture2.type === HalfFloatType && extensions.has("OES_texture_half_float_linear") === false))
        return;
      if (texture2.anisotropy > 1 || properties.get(texture2).__currentAnisotropy) {
        _gl.texParameterf(textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(texture2.anisotropy, capabilities.getMaxAnisotropy()));
        properties.get(texture2).__currentAnisotropy = texture2.anisotropy;
      }
    }
  }
  function initTexture(textureProperties, texture2) {
    let forceUpload = false;
    if (textureProperties.__webglInit === void 0) {
      textureProperties.__webglInit = true;
      texture2.addEventListener("dispose", onTextureDispose);
    }
    const source2 = texture2.source;
    let webglTextures = _sources.get(source2);
    if (webglTextures === void 0) {
      webglTextures = {};
      _sources.set(source2, webglTextures);
    }
    const textureCacheKey = getTextureCacheKey(texture2);
    if (textureCacheKey !== textureProperties.__cacheKey) {
      if (webglTextures[textureCacheKey] === void 0) {
        webglTextures[textureCacheKey] = {
          texture: _gl.createTexture(),
          usedTimes: 0
        };
        info.memory.textures++;
        forceUpload = true;
      }
      webglTextures[textureCacheKey].usedTimes++;
      const webglTexture = webglTextures[textureProperties.__cacheKey];
      if (webglTexture !== void 0) {
        webglTextures[textureProperties.__cacheKey].usedTimes--;
        if (webglTexture.usedTimes === 0) {
          deleteTexture(texture2);
        }
      }
      textureProperties.__cacheKey = textureCacheKey;
      textureProperties.__webglTexture = webglTextures[textureCacheKey].texture;
    }
    return forceUpload;
  }
  function uploadTexture(textureProperties, texture2, slot) {
    let textureType = 3553;
    if (texture2.isDataArrayTexture)
      textureType = 35866;
    if (texture2.isData3DTexture)
      textureType = 32879;
    const forceUpload = initTexture(textureProperties, texture2);
    const source2 = texture2.source;
    state.activeTexture(33984 + slot);
    state.bindTexture(textureType, textureProperties.__webglTexture);
    if (source2.version !== source2.__currentVersion || forceUpload === true) {
      _gl.pixelStorei(37440, texture2.flipY);
      _gl.pixelStorei(37441, texture2.premultiplyAlpha);
      _gl.pixelStorei(3317, texture2.unpackAlignment);
      _gl.pixelStorei(37443, 0);
      const needsPowerOfTwo = textureNeedsPowerOfTwo(texture2) && isPowerOfTwo$1(texture2.image) === false;
      let image2 = resizeImage(texture2.image, needsPowerOfTwo, false, maxTextureSize);
      image2 = verifyColorSpace(texture2, image2);
      const supportsMips = isPowerOfTwo$1(image2) || isWebGL2, glFormat = utils.convert(texture2.format, texture2.encoding);
      let glType = utils.convert(texture2.type), glInternalFormat = getInternalFormat(texture2.internalFormat, glFormat, glType, texture2.encoding, texture2.isVideoTexture);
      setTextureParameters(textureType, texture2, supportsMips);
      let mipmap;
      const mipmaps = texture2.mipmaps;
      const useTexStorage = isWebGL2 && texture2.isVideoTexture !== true;
      const allocateMemory = textureProperties.__version === void 0;
      const levels = getMipLevels(texture2, image2, supportsMips);
      if (texture2.isDepthTexture) {
        glInternalFormat = 6402;
        if (isWebGL2) {
          if (texture2.type === FloatType) {
            glInternalFormat = 36012;
          } else if (texture2.type === UnsignedIntType) {
            glInternalFormat = 33190;
          } else if (texture2.type === UnsignedInt248Type) {
            glInternalFormat = 35056;
          } else {
            glInternalFormat = 33189;
          }
        } else {
          if (texture2.type === FloatType) {
            console.error("WebGLRenderer: Floating point depth texture requires WebGL2.");
          }
        }
        if (texture2.format === DepthFormat && glInternalFormat === 6402) {
          if (texture2.type !== UnsignedShortType && texture2.type !== UnsignedIntType) {
            console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture.");
            texture2.type = UnsignedShortType;
            glType = utils.convert(texture2.type);
          }
        }
        if (texture2.format === DepthStencilFormat && glInternalFormat === 6402) {
          glInternalFormat = 34041;
          if (texture2.type !== UnsignedInt248Type) {
            console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture.");
            texture2.type = UnsignedInt248Type;
            glType = utils.convert(texture2.type);
          }
        }
        if (useTexStorage && allocateMemory) {
          state.texStorage2D(3553, 1, glInternalFormat, image2.width, image2.height);
        } else {
          state.texImage2D(3553, 0, glInternalFormat, image2.width, image2.height, 0, glFormat, glType, null);
        }
      } else if (texture2.isDataTexture) {
        if (mipmaps.length > 0 && supportsMips) {
          if (useTexStorage && allocateMemory) {
            state.texStorage2D(3553, levels, glInternalFormat, mipmaps[0].width, mipmaps[0].height);
          }
          for (let i = 0, il = mipmaps.length; i < il; i++) {
            mipmap = mipmaps[i];
            if (useTexStorage) {
              state.texSubImage2D(3553, i, 0, 0, mipmap.width, mipmap.height, glFormat, glType, mipmap.data);
            } else {
              state.texImage2D(3553, i, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
            }
          }
          texture2.generateMipmaps = false;
        } else {
          if (useTexStorage) {
            if (allocateMemory) {
              state.texStorage2D(3553, levels, glInternalFormat, image2.width, image2.height);
            }
            state.texSubImage2D(3553, 0, 0, 0, image2.width, image2.height, glFormat, glType, image2.data);
          } else {
            state.texImage2D(3553, 0, glInternalFormat, image2.width, image2.height, 0, glFormat, glType, image2.data);
          }
        }
      } else if (texture2.isCompressedTexture) {
        if (useTexStorage && allocateMemory) {
          state.texStorage2D(3553, levels, glInternalFormat, mipmaps[0].width, mipmaps[0].height);
        }
        for (let i = 0, il = mipmaps.length; i < il; i++) {
          mipmap = mipmaps[i];
          if (texture2.format !== RGBAFormat) {
            if (glFormat !== null) {
              if (useTexStorage) {
                state.compressedTexSubImage2D(3553, i, 0, 0, mipmap.width, mipmap.height, glFormat, mipmap.data);
              } else {
                state.compressedTexImage2D(3553, i, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data);
              }
            } else {
              console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()");
            }
          } else {
            if (useTexStorage) {
              state.texSubImage2D(3553, i, 0, 0, mipmap.width, mipmap.height, glFormat, glType, mipmap.data);
            } else {
              state.texImage2D(3553, i, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
            }
          }
        }
      } else if (texture2.isDataArrayTexture) {
        if (useTexStorage) {
          if (allocateMemory) {
            state.texStorage3D(35866, levels, glInternalFormat, image2.width, image2.height, image2.depth);
          }
          state.texSubImage3D(35866, 0, 0, 0, 0, image2.width, image2.height, image2.depth, glFormat, glType, image2.data);
        } else {
          state.texImage3D(35866, 0, glInternalFormat, image2.width, image2.height, image2.depth, 0, glFormat, glType, image2.data);
        }
      } else if (texture2.isData3DTexture) {
        if (useTexStorage) {
          if (allocateMemory) {
            state.texStorage3D(32879, levels, glInternalFormat, image2.width, image2.height, image2.depth);
          }
          state.texSubImage3D(32879, 0, 0, 0, 0, image2.width, image2.height, image2.depth, glFormat, glType, image2.data);
        } else {
          state.texImage3D(32879, 0, glInternalFormat, image2.width, image2.height, image2.depth, 0, glFormat, glType, image2.data);
        }
      } else if (texture2.isFramebufferTexture) {
        if (useTexStorage && allocateMemory) {
          state.texStorage2D(3553, levels, glInternalFormat, image2.width, image2.height);
        } else {
          state.texImage2D(3553, 0, glInternalFormat, image2.width, image2.height, 0, glFormat, glType, null);
        }
      } else {
        if (mipmaps.length > 0 && supportsMips) {
          if (useTexStorage && allocateMemory) {
            state.texStorage2D(3553, levels, glInternalFormat, mipmaps[0].width, mipmaps[0].height);
          }
          for (let i = 0, il = mipmaps.length; i < il; i++) {
            mipmap = mipmaps[i];
            if (useTexStorage) {
              state.texSubImage2D(3553, i, 0, 0, glFormat, glType, mipmap);
            } else {
              state.texImage2D(3553, i, glInternalFormat, glFormat, glType, mipmap);
            }
          }
          texture2.generateMipmaps = false;
        } else {
          if (useTexStorage) {
            if (allocateMemory) {
              state.texStorage2D(3553, levels, glInternalFormat, image2.width, image2.height);
            }
            state.texSubImage2D(3553, 0, 0, 0, glFormat, glType, image2);
          } else {
            state.texImage2D(3553, 0, glInternalFormat, glFormat, glType, image2);
          }
        }
      }
      if (textureNeedsGenerateMipmaps(texture2, supportsMips)) {
        generateMipmap(textureType);
      }
      source2.__currentVersion = source2.version;
      if (texture2.onUpdate)
        texture2.onUpdate(texture2);
    }
    textureProperties.__version = texture2.version;
  }
  function uploadCubeTexture(textureProperties, texture2, slot) {
    if (texture2.image.length !== 6)
      return;
    const forceUpload = initTexture(textureProperties, texture2);
    const source2 = texture2.source;
    state.activeTexture(33984 + slot);
    state.bindTexture(34067, textureProperties.__webglTexture);
    if (source2.version !== source2.__currentVersion || forceUpload === true) {
      _gl.pixelStorei(37440, texture2.flipY);
      _gl.pixelStorei(37441, texture2.premultiplyAlpha);
      _gl.pixelStorei(3317, texture2.unpackAlignment);
      _gl.pixelStorei(37443, 0);
      const isCompressed = texture2.isCompressedTexture || texture2.image[0].isCompressedTexture;
      const isDataTexture = texture2.image[0] && texture2.image[0].isDataTexture;
      const cubeImage = [];
      for (let i = 0; i < 6; i++) {
        if (!isCompressed && !isDataTexture) {
          cubeImage[i] = resizeImage(texture2.image[i], false, true, maxCubemapSize);
        } else {
          cubeImage[i] = isDataTexture ? texture2.image[i].image : texture2.image[i];
        }
        cubeImage[i] = verifyColorSpace(texture2, cubeImage[i]);
      }
      const image2 = cubeImage[0], supportsMips = isPowerOfTwo$1(image2) || isWebGL2, glFormat = utils.convert(texture2.format, texture2.encoding), glType = utils.convert(texture2.type), glInternalFormat = getInternalFormat(texture2.internalFormat, glFormat, glType, texture2.encoding);
      const useTexStorage = isWebGL2 && texture2.isVideoTexture !== true;
      const allocateMemory = textureProperties.__version === void 0;
      let levels = getMipLevels(texture2, image2, supportsMips);
      setTextureParameters(34067, texture2, supportsMips);
      let mipmaps;
      if (isCompressed) {
        if (useTexStorage && allocateMemory) {
          state.texStorage2D(34067, levels, glInternalFormat, image2.width, image2.height);
        }
        for (let i = 0; i < 6; i++) {
          mipmaps = cubeImage[i].mipmaps;
          for (let j = 0; j < mipmaps.length; j++) {
            const mipmap = mipmaps[j];
            if (texture2.format !== RGBAFormat) {
              if (glFormat !== null) {
                if (useTexStorage) {
                  state.compressedTexSubImage2D(34069 + i, j, 0, 0, mipmap.width, mipmap.height, glFormat, mipmap.data);
                } else {
                  state.compressedTexImage2D(34069 + i, j, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data);
                }
              } else {
                console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()");
              }
            } else {
              if (useTexStorage) {
                state.texSubImage2D(34069 + i, j, 0, 0, mipmap.width, mipmap.height, glFormat, glType, mipmap.data);
              } else {
                state.texImage2D(34069 + i, j, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
              }
            }
          }
        }
      } else {
        mipmaps = texture2.mipmaps;
        if (useTexStorage && allocateMemory) {
          if (mipmaps.length > 0)
            levels++;
          state.texStorage2D(34067, levels, glInternalFormat, cubeImage[0].width, cubeImage[0].height);
        }
        for (let i = 0; i < 6; i++) {
          if (isDataTexture) {
            if (useTexStorage) {
              state.texSubImage2D(34069 + i, 0, 0, 0, cubeImage[i].width, cubeImage[i].height, glFormat, glType, cubeImage[i].data);
            } else {
              state.texImage2D(34069 + i, 0, glInternalFormat, cubeImage[i].width, cubeImage[i].height, 0, glFormat, glType, cubeImage[i].data);
            }
            for (let j = 0; j < mipmaps.length; j++) {
              const mipmap = mipmaps[j];
              const mipmapImage = mipmap.image[i].image;
              if (useTexStorage) {
                state.texSubImage2D(34069 + i, j + 1, 0, 0, mipmapImage.width, mipmapImage.height, glFormat, glType, mipmapImage.data);
              } else {
                state.texImage2D(34069 + i, j + 1, glInternalFormat, mipmapImage.width, mipmapImage.height, 0, glFormat, glType, mipmapImage.data);
              }
            }
          } else {
            if (useTexStorage) {
              state.texSubImage2D(34069 + i, 0, 0, 0, glFormat, glType, cubeImage[i]);
            } else {
              state.texImage2D(34069 + i, 0, glInternalFormat, glFormat, glType, cubeImage[i]);
            }
            for (let j = 0; j < mipmaps.length; j++) {
              const mipmap = mipmaps[j];
              if (useTexStorage) {
                state.texSubImage2D(34069 + i, j + 1, 0, 0, glFormat, glType, mipmap.image[i]);
              } else {
                state.texImage2D(34069 + i, j + 1, glInternalFormat, glFormat, glType, mipmap.image[i]);
              }
            }
          }
        }
      }
      if (textureNeedsGenerateMipmaps(texture2, supportsMips)) {
        generateMipmap(34067);
      }
      source2.__currentVersion = source2.version;
      if (texture2.onUpdate)
        texture2.onUpdate(texture2);
    }
    textureProperties.__version = texture2.version;
  }
  function setupFrameBufferTexture(framebuffer, renderTarget, texture2, attachment, textureTarget) {
    const glFormat = utils.convert(texture2.format, texture2.encoding);
    const glType = utils.convert(texture2.type);
    const glInternalFormat = getInternalFormat(texture2.internalFormat, glFormat, glType, texture2.encoding);
    const renderTargetProperties = properties.get(renderTarget);
    if (!renderTargetProperties.__hasExternalTextures) {
      if (textureTarget === 32879 || textureTarget === 35866) {
        state.texImage3D(textureTarget, 0, glInternalFormat, renderTarget.width, renderTarget.height, renderTarget.depth, 0, glFormat, glType, null);
      } else {
        state.texImage2D(textureTarget, 0, glInternalFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null);
      }
    }
    state.bindFramebuffer(36160, framebuffer);
    if (useMultisampledRTT(renderTarget)) {
      multisampledRTTExt.framebufferTexture2DMultisampleEXT(36160, attachment, textureTarget, properties.get(texture2).__webglTexture, 0, getRenderTargetSamples(renderTarget));
    } else {
      _gl.framebufferTexture2D(36160, attachment, textureTarget, properties.get(texture2).__webglTexture, 0);
    }
    state.bindFramebuffer(36160, null);
  }
  function setupRenderBufferStorage(renderbuffer, renderTarget, isMultisample) {
    _gl.bindRenderbuffer(36161, renderbuffer);
    if (renderTarget.depthBuffer && !renderTarget.stencilBuffer) {
      let glInternalFormat = 33189;
      if (isMultisample || useMultisampledRTT(renderTarget)) {
        const depthTexture = renderTarget.depthTexture;
        if (depthTexture && depthTexture.isDepthTexture) {
          if (depthTexture.type === FloatType) {
            glInternalFormat = 36012;
          } else if (depthTexture.type === UnsignedIntType) {
            glInternalFormat = 33190;
          }
        }
        const samples = getRenderTargetSamples(renderTarget);
        if (useMultisampledRTT(renderTarget)) {
          multisampledRTTExt.renderbufferStorageMultisampleEXT(36161, samples, glInternalFormat, renderTarget.width, renderTarget.height);
        } else {
          _gl.renderbufferStorageMultisample(36161, samples, glInternalFormat, renderTarget.width, renderTarget.height);
        }
      } else {
        _gl.renderbufferStorage(36161, glInternalFormat, renderTarget.width, renderTarget.height);
      }
      _gl.framebufferRenderbuffer(36160, 36096, 36161, renderbuffer);
    } else if (renderTarget.depthBuffer && renderTarget.stencilBuffer) {
      const samples = getRenderTargetSamples(renderTarget);
      if (isMultisample && useMultisampledRTT(renderTarget) === false) {
        _gl.renderbufferStorageMultisample(36161, samples, 35056, renderTarget.width, renderTarget.height);
      } else if (useMultisampledRTT(renderTarget)) {
        multisampledRTTExt.renderbufferStorageMultisampleEXT(36161, samples, 35056, renderTarget.width, renderTarget.height);
      } else {
        _gl.renderbufferStorage(36161, 34041, renderTarget.width, renderTarget.height);
      }
      _gl.framebufferRenderbuffer(36160, 33306, 36161, renderbuffer);
    } else {
      const texture2 = renderTarget.isWebGLMultipleRenderTargets === true ? renderTarget.texture[0] : renderTarget.texture;
      const glFormat = utils.convert(texture2.format, texture2.encoding);
      const glType = utils.convert(texture2.type);
      const glInternalFormat = getInternalFormat(texture2.internalFormat, glFormat, glType, texture2.encoding);
      const samples = getRenderTargetSamples(renderTarget);
      if (isMultisample && useMultisampledRTT(renderTarget) === false) {
        _gl.renderbufferStorageMultisample(36161, samples, glInternalFormat, renderTarget.width, renderTarget.height);
      } else if (useMultisampledRTT(renderTarget)) {
        multisampledRTTExt.renderbufferStorageMultisampleEXT(36161, samples, glInternalFormat, renderTarget.width, renderTarget.height);
      } else {
        _gl.renderbufferStorage(36161, glInternalFormat, renderTarget.width, renderTarget.height);
      }
    }
    _gl.bindRenderbuffer(36161, null);
  }
  function setupDepthTexture(framebuffer, renderTarget) {
    const isCube = renderTarget && renderTarget.isWebGLCubeRenderTarget;
    if (isCube)
      throw new Error("Depth Texture with cube render targets is not supported");
    state.bindFramebuffer(36160, framebuffer);
    if (!(renderTarget.depthTexture && renderTarget.depthTexture.isDepthTexture)) {
      throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
    }
    if (!properties.get(renderTarget.depthTexture).__webglTexture || renderTarget.depthTexture.image.width !== renderTarget.width || renderTarget.depthTexture.image.height !== renderTarget.height) {
      renderTarget.depthTexture.image.width = renderTarget.width;
      renderTarget.depthTexture.image.height = renderTarget.height;
      renderTarget.depthTexture.needsUpdate = true;
    }
    setTexture2D(renderTarget.depthTexture, 0);
    const webglDepthTexture = properties.get(renderTarget.depthTexture).__webglTexture;
    const samples = getRenderTargetSamples(renderTarget);
    if (renderTarget.depthTexture.format === DepthFormat) {
      if (useMultisampledRTT(renderTarget)) {
        multisampledRTTExt.framebufferTexture2DMultisampleEXT(36160, 36096, 3553, webglDepthTexture, 0, samples);
      } else {
        _gl.framebufferTexture2D(36160, 36096, 3553, webglDepthTexture, 0);
      }
    } else if (renderTarget.depthTexture.format === DepthStencilFormat) {
      if (useMultisampledRTT(renderTarget)) {
        multisampledRTTExt.framebufferTexture2DMultisampleEXT(36160, 33306, 3553, webglDepthTexture, 0, samples);
      } else {
        _gl.framebufferTexture2D(36160, 33306, 3553, webglDepthTexture, 0);
      }
    } else {
      throw new Error("Unknown depthTexture format");
    }
  }
  function setupDepthRenderbuffer(renderTarget) {
    const renderTargetProperties = properties.get(renderTarget);
    const isCube = renderTarget.isWebGLCubeRenderTarget === true;
    if (renderTarget.depthTexture && !renderTargetProperties.__autoAllocateDepthBuffer) {
      if (isCube)
        throw new Error("target.depthTexture not supported in Cube render targets");
      setupDepthTexture(renderTargetProperties.__webglFramebuffer, renderTarget);
    } else {
      if (isCube) {
        renderTargetProperties.__webglDepthbuffer = [];
        for (let i = 0; i < 6; i++) {
          state.bindFramebuffer(36160, renderTargetProperties.__webglFramebuffer[i]);
          renderTargetProperties.__webglDepthbuffer[i] = _gl.createRenderbuffer();
          setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer[i], renderTarget, false);
        }
      } else {
        state.bindFramebuffer(36160, renderTargetProperties.__webglFramebuffer);
        renderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer();
        setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer, renderTarget, false);
      }
    }
    state.bindFramebuffer(36160, null);
  }
  function rebindTextures(renderTarget, colorTexture, depthTexture) {
    const renderTargetProperties = properties.get(renderTarget);
    if (colorTexture !== void 0) {
      setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer, renderTarget, renderTarget.texture, 36064, 3553);
    }
    if (depthTexture !== void 0) {
      setupDepthRenderbuffer(renderTarget);
    }
  }
  function setupRenderTarget(renderTarget) {
    const texture2 = renderTarget.texture;
    const renderTargetProperties = properties.get(renderTarget);
    const textureProperties = properties.get(texture2);
    renderTarget.addEventListener("dispose", onRenderTargetDispose);
    if (renderTarget.isWebGLMultipleRenderTargets !== true) {
      if (textureProperties.__webglTexture === void 0) {
        textureProperties.__webglTexture = _gl.createTexture();
      }
      textureProperties.__version = texture2.version;
      info.memory.textures++;
    }
    const isCube = renderTarget.isWebGLCubeRenderTarget === true;
    const isMultipleRenderTargets = renderTarget.isWebGLMultipleRenderTargets === true;
    const supportsMips = isPowerOfTwo$1(renderTarget) || isWebGL2;
    if (isCube) {
      renderTargetProperties.__webglFramebuffer = [];
      for (let i = 0; i < 6; i++) {
        renderTargetProperties.__webglFramebuffer[i] = _gl.createFramebuffer();
      }
    } else {
      renderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();
      if (isMultipleRenderTargets) {
        if (capabilities.drawBuffers) {
          const textures = renderTarget.texture;
          for (let i = 0, il = textures.length; i < il; i++) {
            const attachmentProperties = properties.get(textures[i]);
            if (attachmentProperties.__webglTexture === void 0) {
              attachmentProperties.__webglTexture = _gl.createTexture();
              info.memory.textures++;
            }
          }
        } else {
          console.warn("THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.");
        }
      } else if (isWebGL2 && renderTarget.samples > 0 && useMultisampledRTT(renderTarget) === false) {
        renderTargetProperties.__webglMultisampledFramebuffer = _gl.createFramebuffer();
        renderTargetProperties.__webglColorRenderbuffer = _gl.createRenderbuffer();
        _gl.bindRenderbuffer(36161, renderTargetProperties.__webglColorRenderbuffer);
        const glFormat = utils.convert(texture2.format, texture2.encoding);
        const glType = utils.convert(texture2.type);
        const glInternalFormat = getInternalFormat(texture2.internalFormat, glFormat, glType, texture2.encoding);
        const samples = getRenderTargetSamples(renderTarget);
        _gl.renderbufferStorageMultisample(36161, samples, glInternalFormat, renderTarget.width, renderTarget.height);
        state.bindFramebuffer(36160, renderTargetProperties.__webglMultisampledFramebuffer);
        _gl.framebufferRenderbuffer(36160, 36064, 36161, renderTargetProperties.__webglColorRenderbuffer);
        _gl.bindRenderbuffer(36161, null);
        if (renderTarget.depthBuffer) {
          renderTargetProperties.__webglDepthRenderbuffer = _gl.createRenderbuffer();
          setupRenderBufferStorage(renderTargetProperties.__webglDepthRenderbuffer, renderTarget, true);
        }
        state.bindFramebuffer(36160, null);
      }
    }
    if (isCube) {
      state.bindTexture(34067, textureProperties.__webglTexture);
      setTextureParameters(34067, texture2, supportsMips);
      for (let i = 0; i < 6; i++) {
        setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer[i], renderTarget, texture2, 36064, 34069 + i);
      }
      if (textureNeedsGenerateMipmaps(texture2, supportsMips)) {
        generateMipmap(34067);
      }
      state.unbindTexture();
    } else if (isMultipleRenderTargets) {
      const textures = renderTarget.texture;
      for (let i = 0, il = textures.length; i < il; i++) {
        const attachment = textures[i];
        const attachmentProperties = properties.get(attachment);
        state.bindTexture(3553, attachmentProperties.__webglTexture);
        setTextureParameters(3553, attachment, supportsMips);
        setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer, renderTarget, attachment, 36064 + i, 3553);
        if (textureNeedsGenerateMipmaps(attachment, supportsMips)) {
          generateMipmap(3553);
        }
      }
      state.unbindTexture();
    } else {
      let glTextureType = 3553;
      if (renderTarget.isWebGL3DRenderTarget || renderTarget.isWebGLArrayRenderTarget) {
        if (isWebGL2) {
          glTextureType = renderTarget.isWebGL3DRenderTarget ? 32879 : 35866;
        } else {
          console.error("THREE.WebGLTextures: THREE.Data3DTexture and THREE.DataArrayTexture only supported with WebGL2.");
        }
      }
      state.bindTexture(glTextureType, textureProperties.__webglTexture);
      setTextureParameters(glTextureType, texture2, supportsMips);
      setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer, renderTarget, texture2, 36064, glTextureType);
      if (textureNeedsGenerateMipmaps(texture2, supportsMips)) {
        generateMipmap(glTextureType);
      }
      state.unbindTexture();
    }
    if (renderTarget.depthBuffer) {
      setupDepthRenderbuffer(renderTarget);
    }
  }
  function updateRenderTargetMipmap(renderTarget) {
    const supportsMips = isPowerOfTwo$1(renderTarget) || isWebGL2;
    const textures = renderTarget.isWebGLMultipleRenderTargets === true ? renderTarget.texture : [renderTarget.texture];
    for (let i = 0, il = textures.length; i < il; i++) {
      const texture2 = textures[i];
      if (textureNeedsGenerateMipmaps(texture2, supportsMips)) {
        const target = renderTarget.isWebGLCubeRenderTarget ? 34067 : 3553;
        const webglTexture = properties.get(texture2).__webglTexture;
        state.bindTexture(target, webglTexture);
        generateMipmap(target);
        state.unbindTexture();
      }
    }
  }
  function updateMultisampleRenderTarget(renderTarget) {
    if (isWebGL2 && renderTarget.samples > 0 && useMultisampledRTT(renderTarget) === false) {
      const width2 = renderTarget.width;
      const height2 = renderTarget.height;
      let mask = 16384;
      const invalidationArray = [36064];
      const depthStyle = renderTarget.stencilBuffer ? 33306 : 36096;
      if (renderTarget.depthBuffer) {
        invalidationArray.push(depthStyle);
      }
      const renderTargetProperties = properties.get(renderTarget);
      const ignoreDepthValues = renderTargetProperties.__ignoreDepthValues !== void 0 ? renderTargetProperties.__ignoreDepthValues : false;
      if (ignoreDepthValues === false) {
        if (renderTarget.depthBuffer)
          mask |= 256;
        if (renderTarget.stencilBuffer)
          mask |= 1024;
      }
      state.bindFramebuffer(36008, renderTargetProperties.__webglMultisampledFramebuffer);
      state.bindFramebuffer(36009, renderTargetProperties.__webglFramebuffer);
      if (ignoreDepthValues === true) {
        _gl.invalidateFramebuffer(36008, [depthStyle]);
        _gl.invalidateFramebuffer(36009, [depthStyle]);
      }
      _gl.blitFramebuffer(0, 0, width2, height2, 0, 0, width2, height2, mask, 9728);
      if (supportsInvalidateFramebuffer) {
        _gl.invalidateFramebuffer(36008, invalidationArray);
      }
      state.bindFramebuffer(36008, null);
      state.bindFramebuffer(36009, renderTargetProperties.__webglMultisampledFramebuffer);
    }
  }
  function getRenderTargetSamples(renderTarget) {
    return Math.min(maxSamples, renderTarget.samples);
  }
  function useMultisampledRTT(renderTarget) {
    const renderTargetProperties = properties.get(renderTarget);
    return isWebGL2 && renderTarget.samples > 0 && extensions.has("WEBGL_multisampled_render_to_texture") === true && renderTargetProperties.__useRenderToTexture !== false;
  }
  function updateVideoTexture(texture2) {
    const frame = info.render.frame;
    if (_videoTextures.get(texture2) !== frame) {
      _videoTextures.set(texture2, frame);
      texture2.update();
    }
  }
  function verifyColorSpace(texture2, image2) {
    const encoding = texture2.encoding;
    const format2 = texture2.format;
    const type = texture2.type;
    if (texture2.isCompressedTexture === true || texture2.isVideoTexture === true || texture2.format === _SRGBAFormat)
      return image2;
    if (encoding !== LinearEncoding) {
      if (encoding === sRGBEncoding) {
        if (isWebGL2 === false) {
          if (extensions.has("EXT_sRGB") === true && format2 === RGBAFormat) {
            texture2.format = _SRGBAFormat;
            texture2.minFilter = LinearFilter;
            texture2.generateMipmaps = false;
          } else {
            image2 = ImageUtils.sRGBToLinear(image2);
          }
        } else {
          if (format2 !== RGBAFormat || type !== UnsignedByteType) {
            console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.");
          }
        }
      } else {
        console.error("THREE.WebGLTextures: Unsupported texture encoding:", encoding);
      }
    }
    return image2;
  }
  this.allocateTextureUnit = allocateTextureUnit;
  this.resetTextureUnits = resetTextureUnits;
  this.setTexture2D = setTexture2D;
  this.setTexture2DArray = setTexture2DArray;
  this.setTexture3D = setTexture3D;
  this.setTextureCube = setTextureCube;
  this.rebindTextures = rebindTextures;
  this.setupRenderTarget = setupRenderTarget;
  this.updateRenderTargetMipmap = updateRenderTargetMipmap;
  this.updateMultisampleRenderTarget = updateMultisampleRenderTarget;
  this.setupDepthRenderbuffer = setupDepthRenderbuffer;
  this.setupFrameBufferTexture = setupFrameBufferTexture;
  this.useMultisampledRTT = useMultisampledRTT;
}
function WebGLUtils(gl, extensions, capabilities) {
  const isWebGL2 = capabilities.isWebGL2;
  function convert(p, encoding = null) {
    let extension;
    if (p === UnsignedByteType)
      return 5121;
    if (p === UnsignedShort4444Type)
      return 32819;
    if (p === UnsignedShort5551Type)
      return 32820;
    if (p === ByteType)
      return 5120;
    if (p === ShortType)
      return 5122;
    if (p === UnsignedShortType)
      return 5123;
    if (p === IntType)
      return 5124;
    if (p === UnsignedIntType)
      return 5125;
    if (p === FloatType)
      return 5126;
    if (p === HalfFloatType) {
      if (isWebGL2)
        return 5131;
      extension = extensions.get("OES_texture_half_float");
      if (extension !== null) {
        return extension.HALF_FLOAT_OES;
      } else {
        return null;
      }
    }
    if (p === AlphaFormat)
      return 6406;
    if (p === RGBAFormat)
      return 6408;
    if (p === LuminanceFormat)
      return 6409;
    if (p === LuminanceAlphaFormat)
      return 6410;
    if (p === DepthFormat)
      return 6402;
    if (p === DepthStencilFormat)
      return 34041;
    if (p === RedFormat)
      return 6403;
    if (p === RGBFormat) {
      console.warn("THREE.WebGLRenderer: THREE.RGBFormat has been removed. Use THREE.RGBAFormat instead. https://github.com/mrdoob/three.js/pull/23228");
      return 6408;
    }
    if (p === _SRGBAFormat) {
      extension = extensions.get("EXT_sRGB");
      if (extension !== null) {
        return extension.SRGB_ALPHA_EXT;
      } else {
        return null;
      }
    }
    if (p === RedIntegerFormat)
      return 36244;
    if (p === RGFormat)
      return 33319;
    if (p === RGIntegerFormat)
      return 33320;
    if (p === RGBAIntegerFormat)
      return 36249;
    if (p === RGB_S3TC_DXT1_Format || p === RGBA_S3TC_DXT1_Format || p === RGBA_S3TC_DXT3_Format || p === RGBA_S3TC_DXT5_Format) {
      if (encoding === sRGBEncoding) {
        extension = extensions.get("WEBGL_compressed_texture_s3tc_srgb");
        if (extension !== null) {
          if (p === RGB_S3TC_DXT1_Format)
            return extension.COMPRESSED_SRGB_S3TC_DXT1_EXT;
          if (p === RGBA_S3TC_DXT1_Format)
            return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
          if (p === RGBA_S3TC_DXT3_Format)
            return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
          if (p === RGBA_S3TC_DXT5_Format)
            return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
        } else {
          return null;
        }
      } else {
        extension = extensions.get("WEBGL_compressed_texture_s3tc");
        if (extension !== null) {
          if (p === RGB_S3TC_DXT1_Format)
            return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;
          if (p === RGBA_S3TC_DXT1_Format)
            return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;
          if (p === RGBA_S3TC_DXT3_Format)
            return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;
          if (p === RGBA_S3TC_DXT5_Format)
            return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;
        } else {
          return null;
        }
      }
    }
    if (p === RGB_PVRTC_4BPPV1_Format || p === RGB_PVRTC_2BPPV1_Format || p === RGBA_PVRTC_4BPPV1_Format || p === RGBA_PVRTC_2BPPV1_Format) {
      extension = extensions.get("WEBGL_compressed_texture_pvrtc");
      if (extension !== null) {
        if (p === RGB_PVRTC_4BPPV1_Format)
          return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
        if (p === RGB_PVRTC_2BPPV1_Format)
          return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
        if (p === RGBA_PVRTC_4BPPV1_Format)
          return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
        if (p === RGBA_PVRTC_2BPPV1_Format)
          return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
      } else {
        return null;
      }
    }
    if (p === RGB_ETC1_Format) {
      extension = extensions.get("WEBGL_compressed_texture_etc1");
      if (extension !== null) {
        return extension.COMPRESSED_RGB_ETC1_WEBGL;
      } else {
        return null;
      }
    }
    if (p === RGB_ETC2_Format || p === RGBA_ETC2_EAC_Format) {
      extension = extensions.get("WEBGL_compressed_texture_etc");
      if (extension !== null) {
        if (p === RGB_ETC2_Format)
          return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ETC2 : extension.COMPRESSED_RGB8_ETC2;
        if (p === RGBA_ETC2_EAC_Format)
          return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : extension.COMPRESSED_RGBA8_ETC2_EAC;
      } else {
        return null;
      }
    }
    if (p === RGBA_ASTC_4x4_Format || p === RGBA_ASTC_5x4_Format || p === RGBA_ASTC_5x5_Format || p === RGBA_ASTC_6x5_Format || p === RGBA_ASTC_6x6_Format || p === RGBA_ASTC_8x5_Format || p === RGBA_ASTC_8x6_Format || p === RGBA_ASTC_8x8_Format || p === RGBA_ASTC_10x5_Format || p === RGBA_ASTC_10x6_Format || p === RGBA_ASTC_10x8_Format || p === RGBA_ASTC_10x10_Format || p === RGBA_ASTC_12x10_Format || p === RGBA_ASTC_12x12_Format) {
      extension = extensions.get("WEBGL_compressed_texture_astc");
      if (extension !== null) {
        if (p === RGBA_ASTC_4x4_Format)
          return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : extension.COMPRESSED_RGBA_ASTC_4x4_KHR;
        if (p === RGBA_ASTC_5x4_Format)
          return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : extension.COMPRESSED_RGBA_ASTC_5x4_KHR;
        if (p === RGBA_ASTC_5x5_Format)
          return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : extension.COMPRESSED_RGBA_ASTC_5x5_KHR;
        if (p === RGBA_ASTC_6x5_Format)
          return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : extension.COMPRESSED_RGBA_ASTC_6x5_KHR;
        if (p === RGBA_ASTC_6x6_Format)
          return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : extension.COMPRESSED_RGBA_ASTC_6x6_KHR;
        if (p === RGBA_ASTC_8x5_Format)
          return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : extension.COMPRESSED_RGBA_ASTC_8x5_KHR;
        if (p === RGBA_ASTC_8x6_Format)
          return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : extension.COMPRESSED_RGBA_ASTC_8x6_KHR;
        if (p === RGBA_ASTC_8x8_Format)
          return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : extension.COMPRESSED_RGBA_ASTC_8x8_KHR;
        if (p === RGBA_ASTC_10x5_Format)
          return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : extension.COMPRESSED_RGBA_ASTC_10x5_KHR;
        if (p === RGBA_ASTC_10x6_Format)
          return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : extension.COMPRESSED_RGBA_ASTC_10x6_KHR;
        if (p === RGBA_ASTC_10x8_Format)
          return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : extension.COMPRESSED_RGBA_ASTC_10x8_KHR;
        if (p === RGBA_ASTC_10x10_Format)
          return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : extension.COMPRESSED_RGBA_ASTC_10x10_KHR;
        if (p === RGBA_ASTC_12x10_Format)
          return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : extension.COMPRESSED_RGBA_ASTC_12x10_KHR;
        if (p === RGBA_ASTC_12x12_Format)
          return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : extension.COMPRESSED_RGBA_ASTC_12x12_KHR;
      } else {
        return null;
      }
    }
    if (p === RGBA_BPTC_Format) {
      extension = extensions.get("EXT_texture_compression_bptc");
      if (extension !== null) {
        if (p === RGBA_BPTC_Format)
          return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : extension.COMPRESSED_RGBA_BPTC_UNORM_EXT;
      } else {
        return null;
      }
    }
    if (p === UnsignedInt248Type) {
      if (isWebGL2)
        return 34042;
      extension = extensions.get("WEBGL_depth_texture");
      if (extension !== null) {
        return extension.UNSIGNED_INT_24_8_WEBGL;
      } else {
        return null;
      }
    }
  }
  return { convert };
}
class ArrayCamera extends PerspectiveCamera {
  constructor(array = []) {
    super();
    this.cameras = array;
  }
}
ArrayCamera.prototype.isArrayCamera = true;
class Group extends Object3D {
  constructor() {
    super();
    this.type = "Group";
  }
}
Group.prototype.isGroup = true;
const _moveEvent = { type: "move" };
class WebXRController {
  constructor() {
    this._targetRay = null;
    this._grip = null;
    this._hand = null;
  }
  getHandSpace() {
    if (this._hand === null) {
      this._hand = new Group();
      this._hand.matrixAutoUpdate = false;
      this._hand.visible = false;
      this._hand.joints = {};
      this._hand.inputState = { pinching: false };
    }
    return this._hand;
  }
  getTargetRaySpace() {
    if (this._targetRay === null) {
      this._targetRay = new Group();
      this._targetRay.matrixAutoUpdate = false;
      this._targetRay.visible = false;
      this._targetRay.hasLinearVelocity = false;
      this._targetRay.linearVelocity = new Vector3();
      this._targetRay.hasAngularVelocity = false;
      this._targetRay.angularVelocity = new Vector3();
    }
    return this._targetRay;
  }
  getGripSpace() {
    if (this._grip === null) {
      this._grip = new Group();
      this._grip.matrixAutoUpdate = false;
      this._grip.visible = false;
      this._grip.hasLinearVelocity = false;
      this._grip.linearVelocity = new Vector3();
      this._grip.hasAngularVelocity = false;
      this._grip.angularVelocity = new Vector3();
    }
    return this._grip;
  }
  dispatchEvent(event) {
    if (this._targetRay !== null) {
      this._targetRay.dispatchEvent(event);
    }
    if (this._grip !== null) {
      this._grip.dispatchEvent(event);
    }
    if (this._hand !== null) {
      this._hand.dispatchEvent(event);
    }
    return this;
  }
  disconnect(inputSource) {
    this.dispatchEvent({ type: "disconnected", data: inputSource });
    if (this._targetRay !== null) {
      this._targetRay.visible = false;
    }
    if (this._grip !== null) {
      this._grip.visible = false;
    }
    if (this._hand !== null) {
      this._hand.visible = false;
    }
    return this;
  }
  update(inputSource, frame, referenceSpace) {
    let inputPose = null;
    let gripPose = null;
    let handPose = null;
    const targetRay = this._targetRay;
    const grip = this._grip;
    const hand = this._hand;
    if (inputSource && frame.session.visibilityState !== "visible-blurred") {
      if (targetRay !== null) {
        inputPose = frame.getPose(inputSource.targetRaySpace, referenceSpace);
        if (inputPose !== null) {
          targetRay.matrix.fromArray(inputPose.transform.matrix);
          targetRay.matrix.decompose(targetRay.position, targetRay.rotation, targetRay.scale);
          if (inputPose.linearVelocity) {
            targetRay.hasLinearVelocity = true;
            targetRay.linearVelocity.copy(inputPose.linearVelocity);
          } else {
            targetRay.hasLinearVelocity = false;
          }
          if (inputPose.angularVelocity) {
            targetRay.hasAngularVelocity = true;
            targetRay.angularVelocity.copy(inputPose.angularVelocity);
          } else {
            targetRay.hasAngularVelocity = false;
          }
          this.dispatchEvent(_moveEvent);
        }
      }
      if (hand && inputSource.hand) {
        handPose = true;
        for (const inputjoint of inputSource.hand.values()) {
          const jointPose = frame.getJointPose(inputjoint, referenceSpace);
          if (hand.joints[inputjoint.jointName] === void 0) {
            const joint2 = new Group();
            joint2.matrixAutoUpdate = false;
            joint2.visible = false;
            hand.joints[inputjoint.jointName] = joint2;
            hand.add(joint2);
          }
          const joint = hand.joints[inputjoint.jointName];
          if (jointPose !== null) {
            joint.matrix.fromArray(jointPose.transform.matrix);
            joint.matrix.decompose(joint.position, joint.rotation, joint.scale);
            joint.jointRadius = jointPose.radius;
          }
          joint.visible = jointPose !== null;
        }
        const indexTip = hand.joints["index-finger-tip"];
        const thumbTip = hand.joints["thumb-tip"];
        const distance2 = indexTip.position.distanceTo(thumbTip.position);
        const distanceToPinch = 0.02;
        const threshold = 5e-3;
        if (hand.inputState.pinching && distance2 > distanceToPinch + threshold) {
          hand.inputState.pinching = false;
          this.dispatchEvent({
            type: "pinchend",
            handedness: inputSource.handedness,
            target: this
          });
        } else if (!hand.inputState.pinching && distance2 <= distanceToPinch - threshold) {
          hand.inputState.pinching = true;
          this.dispatchEvent({
            type: "pinchstart",
            handedness: inputSource.handedness,
            target: this
          });
        }
      } else {
        if (grip !== null && inputSource.gripSpace) {
          gripPose = frame.getPose(inputSource.gripSpace, referenceSpace);
          if (gripPose !== null) {
            grip.matrix.fromArray(gripPose.transform.matrix);
            grip.matrix.decompose(grip.position, grip.rotation, grip.scale);
            if (gripPose.linearVelocity) {
              grip.hasLinearVelocity = true;
              grip.linearVelocity.copy(gripPose.linearVelocity);
            } else {
              grip.hasLinearVelocity = false;
            }
            if (gripPose.angularVelocity) {
              grip.hasAngularVelocity = true;
              grip.angularVelocity.copy(gripPose.angularVelocity);
            } else {
              grip.hasAngularVelocity = false;
            }
          }
        }
      }
    }
    if (targetRay !== null) {
      targetRay.visible = inputPose !== null;
    }
    if (grip !== null) {
      grip.visible = gripPose !== null;
    }
    if (hand !== null) {
      hand.visible = handPose !== null;
    }
    return this;
  }
}
class DepthTexture extends Texture {
  constructor(width2, height2, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, format2) {
    format2 = format2 !== void 0 ? format2 : DepthFormat;
    if (format2 !== DepthFormat && format2 !== DepthStencilFormat) {
      throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
    }
    if (type === void 0 && format2 === DepthFormat)
      type = UnsignedShortType;
    if (type === void 0 && format2 === DepthStencilFormat)
      type = UnsignedInt248Type;
    super(null, mapping, wrapS, wrapT, magFilter, minFilter, format2, type, anisotropy);
    this.image = { width: width2, height: height2 };
    this.magFilter = magFilter !== void 0 ? magFilter : NearestFilter;
    this.minFilter = minFilter !== void 0 ? minFilter : NearestFilter;
    this.flipY = false;
    this.generateMipmaps = false;
  }
}
DepthTexture.prototype.isDepthTexture = true;
class WebXRManager extends EventDispatcher {
  constructor(renderer, gl) {
    super();
    const scope = this;
    let session = null;
    let framebufferScaleFactor = 1;
    let referenceSpace = null;
    let referenceSpaceType = "local-floor";
    let pose = null;
    let glBinding = null;
    let glProjLayer = null;
    let glBaseLayer = null;
    let xrFrame = null;
    const attributes = gl.getContextAttributes();
    let initialRenderTarget = null;
    let newRenderTarget = null;
    const controllers = [];
    const inputSourcesMap = /* @__PURE__ */ new Map();
    const cameraL = new PerspectiveCamera();
    cameraL.layers.enable(1);
    cameraL.viewport = new Vector4();
    const cameraR = new PerspectiveCamera();
    cameraR.layers.enable(2);
    cameraR.viewport = new Vector4();
    const cameras = [cameraL, cameraR];
    const cameraVR = new ArrayCamera();
    cameraVR.layers.enable(1);
    cameraVR.layers.enable(2);
    let _currentDepthNear = null;
    let _currentDepthFar = null;
    this.cameraAutoUpdate = true;
    this.enabled = false;
    this.isPresenting = false;
    this.getController = function(index2) {
      let controller = controllers[index2];
      if (controller === void 0) {
        controller = new WebXRController();
        controllers[index2] = controller;
      }
      return controller.getTargetRaySpace();
    };
    this.getControllerGrip = function(index2) {
      let controller = controllers[index2];
      if (controller === void 0) {
        controller = new WebXRController();
        controllers[index2] = controller;
      }
      return controller.getGripSpace();
    };
    this.getHand = function(index2) {
      let controller = controllers[index2];
      if (controller === void 0) {
        controller = new WebXRController();
        controllers[index2] = controller;
      }
      return controller.getHandSpace();
    };
    function onSessionEvent(event) {
      const controller = inputSourcesMap.get(event.inputSource);
      if (controller) {
        controller.dispatchEvent({ type: event.type, data: event.inputSource });
      }
    }
    function onSessionEnd() {
      inputSourcesMap.forEach(function(controller, inputSource) {
        controller.disconnect(inputSource);
      });
      inputSourcesMap.clear();
      _currentDepthNear = null;
      _currentDepthFar = null;
      renderer.setRenderTarget(initialRenderTarget);
      glBaseLayer = null;
      glProjLayer = null;
      glBinding = null;
      session = null;
      newRenderTarget = null;
      animation2.stop();
      scope.isPresenting = false;
      scope.dispatchEvent({ type: "sessionend" });
    }
    this.setFramebufferScaleFactor = function(value) {
      framebufferScaleFactor = value;
      if (scope.isPresenting === true) {
        console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.");
      }
    };
    this.setReferenceSpaceType = function(value) {
      referenceSpaceType = value;
      if (scope.isPresenting === true) {
        console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.");
      }
    };
    this.getReferenceSpace = function() {
      return referenceSpace;
    };
    this.getBaseLayer = function() {
      return glProjLayer !== null ? glProjLayer : glBaseLayer;
    };
    this.getBinding = function() {
      return glBinding;
    };
    this.getFrame = function() {
      return xrFrame;
    };
    this.getSession = function() {
      return session;
    };
    this.setSession = async function(value) {
      session = value;
      if (session !== null) {
        initialRenderTarget = renderer.getRenderTarget();
        session.addEventListener("select", onSessionEvent);
        session.addEventListener("selectstart", onSessionEvent);
        session.addEventListener("selectend", onSessionEvent);
        session.addEventListener("squeeze", onSessionEvent);
        session.addEventListener("squeezestart", onSessionEvent);
        session.addEventListener("squeezeend", onSessionEvent);
        session.addEventListener("end", onSessionEnd);
        session.addEventListener("inputsourceschange", onInputSourcesChange);
        if (attributes.xrCompatible !== true) {
          await gl.makeXRCompatible();
        }
        if (session.renderState.layers === void 0 || renderer.capabilities.isWebGL2 === false) {
          const layerInit = {
            antialias: session.renderState.layers === void 0 ? attributes.antialias : true,
            alpha: attributes.alpha,
            depth: attributes.depth,
            stencil: attributes.stencil,
            framebufferScaleFactor
          };
          glBaseLayer = new XRWebGLLayer(session, gl, layerInit);
          session.updateRenderState({ baseLayer: glBaseLayer });
          newRenderTarget = new WebGLRenderTarget(glBaseLayer.framebufferWidth, glBaseLayer.framebufferHeight, {
            format: RGBAFormat,
            type: UnsignedByteType,
            encoding: renderer.outputEncoding
          });
        } else {
          let depthFormat = null;
          let depthType = null;
          let glDepthFormat = null;
          if (attributes.depth) {
            glDepthFormat = attributes.stencil ? 35056 : 33190;
            depthFormat = attributes.stencil ? DepthStencilFormat : DepthFormat;
            depthType = attributes.stencil ? UnsignedInt248Type : UnsignedShortType;
          }
          const projectionlayerInit = {
            colorFormat: renderer.outputEncoding === sRGBEncoding ? 35907 : 32856,
            depthFormat: glDepthFormat,
            scaleFactor: framebufferScaleFactor
          };
          glBinding = new XRWebGLBinding(session, gl);
          glProjLayer = glBinding.createProjectionLayer(projectionlayerInit);
          session.updateRenderState({ layers: [glProjLayer] });
          newRenderTarget = new WebGLRenderTarget(glProjLayer.textureWidth, glProjLayer.textureHeight, {
            format: RGBAFormat,
            type: UnsignedByteType,
            depthTexture: new DepthTexture(glProjLayer.textureWidth, glProjLayer.textureHeight, depthType, void 0, void 0, void 0, void 0, void 0, void 0, depthFormat),
            stencilBuffer: attributes.stencil,
            encoding: renderer.outputEncoding,
            samples: attributes.antialias ? 4 : 0
          });
          const renderTargetProperties = renderer.properties.get(newRenderTarget);
          renderTargetProperties.__ignoreDepthValues = glProjLayer.ignoreDepthValues;
        }
        newRenderTarget.isXRRenderTarget = true;
        this.setFoveation(1);
        referenceSpace = await session.requestReferenceSpace(referenceSpaceType);
        animation2.setContext(session);
        animation2.start();
        scope.isPresenting = true;
        scope.dispatchEvent({ type: "sessionstart" });
      }
    };
    function onInputSourcesChange(event) {
      const inputSources = session.inputSources;
      for (let i = 0; i < controllers.length; i++) {
        inputSourcesMap.set(inputSources[i], controllers[i]);
      }
      for (let i = 0; i < event.removed.length; i++) {
        const inputSource = event.removed[i];
        const controller = inputSourcesMap.get(inputSource);
        if (controller) {
          controller.dispatchEvent({ type: "disconnected", data: inputSource });
          inputSourcesMap.delete(inputSource);
        }
      }
      for (let i = 0; i < event.added.length; i++) {
        const inputSource = event.added[i];
        const controller = inputSourcesMap.get(inputSource);
        if (controller) {
          controller.dispatchEvent({ type: "connected", data: inputSource });
        }
      }
    }
    const cameraLPos = new Vector3();
    const cameraRPos = new Vector3();
    function setProjectionFromUnion(camera, cameraL2, cameraR2) {
      cameraLPos.setFromMatrixPosition(cameraL2.matrixWorld);
      cameraRPos.setFromMatrixPosition(cameraR2.matrixWorld);
      const ipd = cameraLPos.distanceTo(cameraRPos);
      const projL = cameraL2.projectionMatrix.elements;
      const projR = cameraR2.projectionMatrix.elements;
      const near = projL[14] / (projL[10] - 1);
      const far = projL[14] / (projL[10] + 1);
      const topFov = (projL[9] + 1) / projL[5];
      const bottomFov = (projL[9] - 1) / projL[5];
      const leftFov = (projL[8] - 1) / projL[0];
      const rightFov = (projR[8] + 1) / projR[0];
      const left2 = near * leftFov;
      const right2 = near * rightFov;
      const zOffset = ipd / (-leftFov + rightFov);
      const xOffset = zOffset * -leftFov;
      cameraL2.matrixWorld.decompose(camera.position, camera.quaternion, camera.scale);
      camera.translateX(xOffset);
      camera.translateZ(zOffset);
      camera.matrixWorld.compose(camera.position, camera.quaternion, camera.scale);
      camera.matrixWorldInverse.copy(camera.matrixWorld).invert();
      const near2 = near + zOffset;
      const far2 = far + zOffset;
      const left22 = left2 - xOffset;
      const right22 = right2 + (ipd - xOffset);
      const top2 = topFov * far / far2 * near2;
      const bottom2 = bottomFov * far / far2 * near2;
      camera.projectionMatrix.makePerspective(left22, right22, top2, bottom2, near2, far2);
    }
    function updateCamera(camera, parent) {
      if (parent === null) {
        camera.matrixWorld.copy(camera.matrix);
      } else {
        camera.matrixWorld.multiplyMatrices(parent.matrixWorld, camera.matrix);
      }
      camera.matrixWorldInverse.copy(camera.matrixWorld).invert();
    }
    this.updateCamera = function(camera) {
      if (session === null)
        return;
      cameraVR.near = cameraR.near = cameraL.near = camera.near;
      cameraVR.far = cameraR.far = cameraL.far = camera.far;
      if (_currentDepthNear !== cameraVR.near || _currentDepthFar !== cameraVR.far) {
        session.updateRenderState({
          depthNear: cameraVR.near,
          depthFar: cameraVR.far
        });
        _currentDepthNear = cameraVR.near;
        _currentDepthFar = cameraVR.far;
      }
      const parent = camera.parent;
      const cameras2 = cameraVR.cameras;
      updateCamera(cameraVR, parent);
      for (let i = 0; i < cameras2.length; i++) {
        updateCamera(cameras2[i], parent);
      }
      cameraVR.matrixWorld.decompose(cameraVR.position, cameraVR.quaternion, cameraVR.scale);
      camera.position.copy(cameraVR.position);
      camera.quaternion.copy(cameraVR.quaternion);
      camera.scale.copy(cameraVR.scale);
      camera.matrix.copy(cameraVR.matrix);
      camera.matrixWorld.copy(cameraVR.matrixWorld);
      const children2 = camera.children;
      for (let i = 0, l = children2.length; i < l; i++) {
        children2[i].updateMatrixWorld(true);
      }
      if (cameras2.length === 2) {
        setProjectionFromUnion(cameraVR, cameraL, cameraR);
      } else {
        cameraVR.projectionMatrix.copy(cameraL.projectionMatrix);
      }
    };
    this.getCamera = function() {
      return cameraVR;
    };
    this.getFoveation = function() {
      if (glProjLayer !== null) {
        return glProjLayer.fixedFoveation;
      }
      if (glBaseLayer !== null) {
        return glBaseLayer.fixedFoveation;
      }
      return void 0;
    };
    this.setFoveation = function(foveation) {
      if (glProjLayer !== null) {
        glProjLayer.fixedFoveation = foveation;
      }
      if (glBaseLayer !== null && glBaseLayer.fixedFoveation !== void 0) {
        glBaseLayer.fixedFoveation = foveation;
      }
    };
    let onAnimationFrameCallback = null;
    function onAnimationFrame(time, frame) {
      pose = frame.getViewerPose(referenceSpace);
      xrFrame = frame;
      if (pose !== null) {
        const views = pose.views;
        if (glBaseLayer !== null) {
          renderer.setRenderTargetFramebuffer(newRenderTarget, glBaseLayer.framebuffer);
          renderer.setRenderTarget(newRenderTarget);
        }
        let cameraVRNeedsUpdate = false;
        if (views.length !== cameraVR.cameras.length) {
          cameraVR.cameras.length = 0;
          cameraVRNeedsUpdate = true;
        }
        for (let i = 0; i < views.length; i++) {
          const view = views[i];
          let viewport = null;
          if (glBaseLayer !== null) {
            viewport = glBaseLayer.getViewport(view);
          } else {
            const glSubImage = glBinding.getViewSubImage(glProjLayer, view);
            viewport = glSubImage.viewport;
            if (i === 0) {
              renderer.setRenderTargetTextures(newRenderTarget, glSubImage.colorTexture, glProjLayer.ignoreDepthValues ? void 0 : glSubImage.depthStencilTexture);
              renderer.setRenderTarget(newRenderTarget);
            }
          }
          const camera = cameras[i];
          camera.matrix.fromArray(view.transform.matrix);
          camera.projectionMatrix.fromArray(view.projectionMatrix);
          camera.viewport.set(viewport.x, viewport.y, viewport.width, viewport.height);
          if (i === 0) {
            cameraVR.matrix.copy(camera.matrix);
          }
          if (cameraVRNeedsUpdate === true) {
            cameraVR.cameras.push(camera);
          }
        }
      }
      const inputSources = session.inputSources;
      for (let i = 0; i < controllers.length; i++) {
        const controller = controllers[i];
        const inputSource = inputSources[i];
        controller.update(inputSource, frame, referenceSpace);
      }
      if (onAnimationFrameCallback)
        onAnimationFrameCallback(time, frame);
      xrFrame = null;
    }
    const animation2 = new WebGLAnimation();
    animation2.setAnimationLoop(onAnimationFrame);
    this.setAnimationLoop = function(callback) {
      onAnimationFrameCallback = callback;
    };
    this.dispose = function() {
    };
  }
}
function WebGLMaterials(renderer, properties) {
  function refreshFogUniforms(uniforms, fog) {
    uniforms.fogColor.value.copy(fog.color);
    if (fog.isFog) {
      uniforms.fogNear.value = fog.near;
      uniforms.fogFar.value = fog.far;
    } else if (fog.isFogExp2) {
      uniforms.fogDensity.value = fog.density;
    }
  }
  function refreshMaterialUniforms(uniforms, material, pixelRatio, height2, transmissionRenderTarget) {
    if (material.isMeshBasicMaterial) {
      refreshUniformsCommon(uniforms, material);
    } else if (material.isMeshLambertMaterial) {
      refreshUniformsCommon(uniforms, material);
    } else if (material.isMeshToonMaterial) {
      refreshUniformsCommon(uniforms, material);
      refreshUniformsToon(uniforms, material);
    } else if (material.isMeshPhongMaterial) {
      refreshUniformsCommon(uniforms, material);
      refreshUniformsPhong(uniforms, material);
    } else if (material.isMeshStandardMaterial) {
      refreshUniformsCommon(uniforms, material);
      refreshUniformsStandard(uniforms, material);
      if (material.isMeshPhysicalMaterial) {
        refreshUniformsPhysical(uniforms, material, transmissionRenderTarget);
      }
    } else if (material.isMeshMatcapMaterial) {
      refreshUniformsCommon(uniforms, material);
      refreshUniformsMatcap(uniforms, material);
    } else if (material.isMeshDepthMaterial) {
      refreshUniformsCommon(uniforms, material);
    } else if (material.isMeshDistanceMaterial) {
      refreshUniformsCommon(uniforms, material);
      refreshUniformsDistance(uniforms, material);
    } else if (material.isMeshNormalMaterial) {
      refreshUniformsCommon(uniforms, material);
    } else if (material.isLineBasicMaterial) {
      refreshUniformsLine(uniforms, material);
      if (material.isLineDashedMaterial) {
        refreshUniformsDash(uniforms, material);
      }
    } else if (material.isPointsMaterial) {
      refreshUniformsPoints(uniforms, material, pixelRatio, height2);
    } else if (material.isSpriteMaterial) {
      refreshUniformsSprites(uniforms, material);
    } else if (material.isShadowMaterial) {
      uniforms.color.value.copy(material.color);
      uniforms.opacity.value = material.opacity;
    } else if (material.isShaderMaterial) {
      material.uniformsNeedUpdate = false;
    }
  }
  function refreshUniformsCommon(uniforms, material) {
    uniforms.opacity.value = material.opacity;
    if (material.color) {
      uniforms.diffuse.value.copy(material.color);
    }
    if (material.emissive) {
      uniforms.emissive.value.copy(material.emissive).multiplyScalar(material.emissiveIntensity);
    }
    if (material.map) {
      uniforms.map.value = material.map;
    }
    if (material.alphaMap) {
      uniforms.alphaMap.value = material.alphaMap;
    }
    if (material.bumpMap) {
      uniforms.bumpMap.value = material.bumpMap;
      uniforms.bumpScale.value = material.bumpScale;
      if (material.side === BackSide)
        uniforms.bumpScale.value *= -1;
    }
    if (material.displacementMap) {
      uniforms.displacementMap.value = material.displacementMap;
      uniforms.displacementScale.value = material.displacementScale;
      uniforms.displacementBias.value = material.displacementBias;
    }
    if (material.emissiveMap) {
      uniforms.emissiveMap.value = material.emissiveMap;
    }
    if (material.normalMap) {
      uniforms.normalMap.value = material.normalMap;
      uniforms.normalScale.value.copy(material.normalScale);
      if (material.side === BackSide)
        uniforms.normalScale.value.negate();
    }
    if (material.specularMap) {
      uniforms.specularMap.value = material.specularMap;
    }
    if (material.alphaTest > 0) {
      uniforms.alphaTest.value = material.alphaTest;
    }
    const envMap = properties.get(material).envMap;
    if (envMap) {
      uniforms.envMap.value = envMap;
      uniforms.flipEnvMap.value = envMap.isCubeTexture && envMap.isRenderTargetTexture === false ? -1 : 1;
      uniforms.reflectivity.value = material.reflectivity;
      uniforms.ior.value = material.ior;
      uniforms.refractionRatio.value = material.refractionRatio;
    }
    if (material.lightMap) {
      uniforms.lightMap.value = material.lightMap;
      const scaleFactor = renderer.physicallyCorrectLights !== true ? Math.PI : 1;
      uniforms.lightMapIntensity.value = material.lightMapIntensity * scaleFactor;
    }
    if (material.aoMap) {
      uniforms.aoMap.value = material.aoMap;
      uniforms.aoMapIntensity.value = material.aoMapIntensity;
    }
    let uvScaleMap;
    if (material.map) {
      uvScaleMap = material.map;
    } else if (material.specularMap) {
      uvScaleMap = material.specularMap;
    } else if (material.displacementMap) {
      uvScaleMap = material.displacementMap;
    } else if (material.normalMap) {
      uvScaleMap = material.normalMap;
    } else if (material.bumpMap) {
      uvScaleMap = material.bumpMap;
    } else if (material.roughnessMap) {
      uvScaleMap = material.roughnessMap;
    } else if (material.metalnessMap) {
      uvScaleMap = material.metalnessMap;
    } else if (material.alphaMap) {
      uvScaleMap = material.alphaMap;
    } else if (material.emissiveMap) {
      uvScaleMap = material.emissiveMap;
    } else if (material.clearcoatMap) {
      uvScaleMap = material.clearcoatMap;
    } else if (material.clearcoatNormalMap) {
      uvScaleMap = material.clearcoatNormalMap;
    } else if (material.clearcoatRoughnessMap) {
      uvScaleMap = material.clearcoatRoughnessMap;
    } else if (material.specularIntensityMap) {
      uvScaleMap = material.specularIntensityMap;
    } else if (material.specularColorMap) {
      uvScaleMap = material.specularColorMap;
    } else if (material.transmissionMap) {
      uvScaleMap = material.transmissionMap;
    } else if (material.thicknessMap) {
      uvScaleMap = material.thicknessMap;
    } else if (material.sheenColorMap) {
      uvScaleMap = material.sheenColorMap;
    } else if (material.sheenRoughnessMap) {
      uvScaleMap = material.sheenRoughnessMap;
    }
    if (uvScaleMap !== void 0) {
      if (uvScaleMap.isWebGLRenderTarget) {
        uvScaleMap = uvScaleMap.texture;
      }
      if (uvScaleMap.matrixAutoUpdate === true) {
        uvScaleMap.updateMatrix();
      }
      uniforms.uvTransform.value.copy(uvScaleMap.matrix);
    }
    let uv2ScaleMap;
    if (material.aoMap) {
      uv2ScaleMap = material.aoMap;
    } else if (material.lightMap) {
      uv2ScaleMap = material.lightMap;
    }
    if (uv2ScaleMap !== void 0) {
      if (uv2ScaleMap.isWebGLRenderTarget) {
        uv2ScaleMap = uv2ScaleMap.texture;
      }
      if (uv2ScaleMap.matrixAutoUpdate === true) {
        uv2ScaleMap.updateMatrix();
      }
      uniforms.uv2Transform.value.copy(uv2ScaleMap.matrix);
    }
  }
  function refreshUniformsLine(uniforms, material) {
    uniforms.diffuse.value.copy(material.color);
    uniforms.opacity.value = material.opacity;
  }
  function refreshUniformsDash(uniforms, material) {
    uniforms.dashSize.value = material.dashSize;
    uniforms.totalSize.value = material.dashSize + material.gapSize;
    uniforms.scale.value = material.scale;
  }
  function refreshUniformsPoints(uniforms, material, pixelRatio, height2) {
    uniforms.diffuse.value.copy(material.color);
    uniforms.opacity.value = material.opacity;
    uniforms.size.value = material.size * pixelRatio;
    uniforms.scale.value = height2 * 0.5;
    if (material.map) {
      uniforms.map.value = material.map;
    }
    if (material.alphaMap) {
      uniforms.alphaMap.value = material.alphaMap;
    }
    if (material.alphaTest > 0) {
      uniforms.alphaTest.value = material.alphaTest;
    }
    let uvScaleMap;
    if (material.map) {
      uvScaleMap = material.map;
    } else if (material.alphaMap) {
      uvScaleMap = material.alphaMap;
    }
    if (uvScaleMap !== void 0) {
      if (uvScaleMap.matrixAutoUpdate === true) {
        uvScaleMap.updateMatrix();
      }
      uniforms.uvTransform.value.copy(uvScaleMap.matrix);
    }
  }
  function refreshUniformsSprites(uniforms, material) {
    uniforms.diffuse.value.copy(material.color);
    uniforms.opacity.value = material.opacity;
    uniforms.rotation.value = material.rotation;
    if (material.map) {
      uniforms.map.value = material.map;
    }
    if (material.alphaMap) {
      uniforms.alphaMap.value = material.alphaMap;
    }
    if (material.alphaTest > 0) {
      uniforms.alphaTest.value = material.alphaTest;
    }
    let uvScaleMap;
    if (material.map) {
      uvScaleMap = material.map;
    } else if (material.alphaMap) {
      uvScaleMap = material.alphaMap;
    }
    if (uvScaleMap !== void 0) {
      if (uvScaleMap.matrixAutoUpdate === true) {
        uvScaleMap.updateMatrix();
      }
      uniforms.uvTransform.value.copy(uvScaleMap.matrix);
    }
  }
  function refreshUniformsPhong(uniforms, material) {
    uniforms.specular.value.copy(material.specular);
    uniforms.shininess.value = Math.max(material.shininess, 1e-4);
  }
  function refreshUniformsToon(uniforms, material) {
    if (material.gradientMap) {
      uniforms.gradientMap.value = material.gradientMap;
    }
  }
  function refreshUniformsStandard(uniforms, material) {
    uniforms.roughness.value = material.roughness;
    uniforms.metalness.value = material.metalness;
    if (material.roughnessMap) {
      uniforms.roughnessMap.value = material.roughnessMap;
    }
    if (material.metalnessMap) {
      uniforms.metalnessMap.value = material.metalnessMap;
    }
    const envMap = properties.get(material).envMap;
    if (envMap) {
      uniforms.envMapIntensity.value = material.envMapIntensity;
    }
  }
  function refreshUniformsPhysical(uniforms, material, transmissionRenderTarget) {
    uniforms.ior.value = material.ior;
    if (material.sheen > 0) {
      uniforms.sheenColor.value.copy(material.sheenColor).multiplyScalar(material.sheen);
      uniforms.sheenRoughness.value = material.sheenRoughness;
      if (material.sheenColorMap) {
        uniforms.sheenColorMap.value = material.sheenColorMap;
      }
      if (material.sheenRoughnessMap) {
        uniforms.sheenRoughnessMap.value = material.sheenRoughnessMap;
      }
    }
    if (material.clearcoat > 0) {
      uniforms.clearcoat.value = material.clearcoat;
      uniforms.clearcoatRoughness.value = material.clearcoatRoughness;
      if (material.clearcoatMap) {
        uniforms.clearcoatMap.value = material.clearcoatMap;
      }
      if (material.clearcoatRoughnessMap) {
        uniforms.clearcoatRoughnessMap.value = material.clearcoatRoughnessMap;
      }
      if (material.clearcoatNormalMap) {
        uniforms.clearcoatNormalScale.value.copy(material.clearcoatNormalScale);
        uniforms.clearcoatNormalMap.value = material.clearcoatNormalMap;
        if (material.side === BackSide) {
          uniforms.clearcoatNormalScale.value.negate();
        }
      }
    }
    if (material.transmission > 0) {
      uniforms.transmission.value = material.transmission;
      uniforms.transmissionSamplerMap.value = transmissionRenderTarget.texture;
      uniforms.transmissionSamplerSize.value.set(transmissionRenderTarget.width, transmissionRenderTarget.height);
      if (material.transmissionMap) {
        uniforms.transmissionMap.value = material.transmissionMap;
      }
      uniforms.thickness.value = material.thickness;
      if (material.thicknessMap) {
        uniforms.thicknessMap.value = material.thicknessMap;
      }
      uniforms.attenuationDistance.value = material.attenuationDistance;
      uniforms.attenuationColor.value.copy(material.attenuationColor);
    }
    uniforms.specularIntensity.value = material.specularIntensity;
    uniforms.specularColor.value.copy(material.specularColor);
    if (material.specularIntensityMap) {
      uniforms.specularIntensityMap.value = material.specularIntensityMap;
    }
    if (material.specularColorMap) {
      uniforms.specularColorMap.value = material.specularColorMap;
    }
  }
  function refreshUniformsMatcap(uniforms, material) {
    if (material.matcap) {
      uniforms.matcap.value = material.matcap;
    }
  }
  function refreshUniformsDistance(uniforms, material) {
    uniforms.referencePosition.value.copy(material.referencePosition);
    uniforms.nearDistance.value = material.nearDistance;
    uniforms.farDistance.value = material.farDistance;
  }
  return {
    refreshFogUniforms,
    refreshMaterialUniforms
  };
}
function createCanvasElement() {
  const canvas = createElementNS("canvas");
  canvas.style.display = "block";
  return canvas;
}
function WebGLRenderer(parameters = {}) {
  const _canvas2 = parameters.canvas !== void 0 ? parameters.canvas : createCanvasElement(), _context2 = parameters.context !== void 0 ? parameters.context : null, _depth = parameters.depth !== void 0 ? parameters.depth : true, _stencil = parameters.stencil !== void 0 ? parameters.stencil : true, _antialias = parameters.antialias !== void 0 ? parameters.antialias : false, _premultipliedAlpha = parameters.premultipliedAlpha !== void 0 ? parameters.premultipliedAlpha : true, _preserveDrawingBuffer = parameters.preserveDrawingBuffer !== void 0 ? parameters.preserveDrawingBuffer : false, _powerPreference = parameters.powerPreference !== void 0 ? parameters.powerPreference : "default", _failIfMajorPerformanceCaveat = parameters.failIfMajorPerformanceCaveat !== void 0 ? parameters.failIfMajorPerformanceCaveat : false;
  let _alpha;
  if (parameters.context !== void 0) {
    _alpha = _context2.getContextAttributes().alpha;
  } else {
    _alpha = parameters.alpha !== void 0 ? parameters.alpha : false;
  }
  let currentRenderList = null;
  let currentRenderState = null;
  const renderListStack = [];
  const renderStateStack = [];
  this.domElement = _canvas2;
  this.debug = {
    checkShaderErrors: true
  };
  this.autoClear = true;
  this.autoClearColor = true;
  this.autoClearDepth = true;
  this.autoClearStencil = true;
  this.sortObjects = true;
  this.clippingPlanes = [];
  this.localClippingEnabled = false;
  this.outputEncoding = LinearEncoding;
  this.physicallyCorrectLights = false;
  this.toneMapping = NoToneMapping;
  this.toneMappingExposure = 1;
  const _this = this;
  let _isContextLost = false;
  let _currentActiveCubeFace = 0;
  let _currentActiveMipmapLevel = 0;
  let _currentRenderTarget = null;
  let _currentMaterialId = -1;
  let _currentCamera = null;
  const _currentViewport = new Vector4();
  const _currentScissor = new Vector4();
  let _currentScissorTest = null;
  let _width = _canvas2.width;
  let _height = _canvas2.height;
  let _pixelRatio = 1;
  let _opaqueSort = null;
  let _transparentSort = null;
  const _viewport = new Vector4(0, 0, _width, _height);
  const _scissor = new Vector4(0, 0, _width, _height);
  let _scissorTest = false;
  const _frustum = new Frustum();
  let _clippingEnabled = false;
  let _localClippingEnabled = false;
  let _transmissionRenderTarget = null;
  const _projScreenMatrix2 = new Matrix4();
  const _vector22 = new Vector2();
  const _vector3 = new Vector3();
  const _emptyScene = { background: null, fog: null, environment: null, overrideMaterial: null, isScene: true };
  function getTargetPixelRatio() {
    return _currentRenderTarget === null ? _pixelRatio : 1;
  }
  let _gl = _context2;
  function getContext(contextNames, contextAttributes) {
    for (let i = 0; i < contextNames.length; i++) {
      const contextName = contextNames[i];
      const context = _canvas2.getContext(contextName, contextAttributes);
      if (context !== null)
        return context;
    }
    return null;
  }
  try {
    const contextAttributes = {
      alpha: true,
      depth: _depth,
      stencil: _stencil,
      antialias: _antialias,
      premultipliedAlpha: _premultipliedAlpha,
      preserveDrawingBuffer: _preserveDrawingBuffer,
      powerPreference: _powerPreference,
      failIfMajorPerformanceCaveat: _failIfMajorPerformanceCaveat
    };
    if ("setAttribute" in _canvas2)
      _canvas2.setAttribute("data-engine", `three.js r${REVISION}`);
    _canvas2.addEventListener("webglcontextlost", onContextLost, false);
    _canvas2.addEventListener("webglcontextrestored", onContextRestore, false);
    if (_gl === null) {
      const contextNames = ["webgl2", "webgl", "experimental-webgl"];
      if (_this.isWebGL1Renderer === true) {
        contextNames.shift();
      }
      _gl = getContext(contextNames, contextAttributes);
      if (_gl === null) {
        if (getContext(contextNames)) {
          throw new Error("Error creating WebGL context with your selected attributes.");
        } else {
          throw new Error("Error creating WebGL context.");
        }
      }
    }
    if (_gl.getShaderPrecisionFormat === void 0) {
      _gl.getShaderPrecisionFormat = function() {
        return { "rangeMin": 1, "rangeMax": 1, "precision": 1 };
      };
    }
  } catch (error) {
    console.error("THREE.WebGLRenderer: " + error.message);
    throw error;
  }
  let extensions, capabilities, state, info;
  let properties, textures, cubemaps, cubeuvmaps, attributes, geometries, objects;
  let programCache, materials, renderLists, renderStates, clipping, shadowMap;
  let background, morphtargets, bufferRenderer, indexedBufferRenderer;
  let utils, bindingStates;
  function initGLContext() {
    extensions = new WebGLExtensions(_gl);
    capabilities = new WebGLCapabilities(_gl, extensions, parameters);
    extensions.init(capabilities);
    utils = new WebGLUtils(_gl, extensions, capabilities);
    state = new WebGLState(_gl, extensions, capabilities);
    info = new WebGLInfo(_gl);
    properties = new WebGLProperties();
    textures = new WebGLTextures(_gl, extensions, state, properties, capabilities, utils, info);
    cubemaps = new WebGLCubeMaps(_this);
    cubeuvmaps = new WebGLCubeUVMaps(_this);
    attributes = new WebGLAttributes(_gl, capabilities);
    bindingStates = new WebGLBindingStates(_gl, extensions, attributes, capabilities);
    geometries = new WebGLGeometries(_gl, attributes, info, bindingStates);
    objects = new WebGLObjects(_gl, geometries, attributes, info);
    morphtargets = new WebGLMorphtargets(_gl, capabilities, textures);
    clipping = new WebGLClipping(properties);
    programCache = new WebGLPrograms(_this, cubemaps, cubeuvmaps, extensions, capabilities, bindingStates, clipping);
    materials = new WebGLMaterials(_this, properties);
    renderLists = new WebGLRenderLists();
    renderStates = new WebGLRenderStates(extensions, capabilities);
    background = new WebGLBackground(_this, cubemaps, state, objects, _alpha, _premultipliedAlpha);
    shadowMap = new WebGLShadowMap(_this, objects, capabilities);
    bufferRenderer = new WebGLBufferRenderer(_gl, extensions, info, capabilities);
    indexedBufferRenderer = new WebGLIndexedBufferRenderer(_gl, extensions, info, capabilities);
    info.programs = programCache.programs;
    _this.capabilities = capabilities;
    _this.extensions = extensions;
    _this.properties = properties;
    _this.renderLists = renderLists;
    _this.shadowMap = shadowMap;
    _this.state = state;
    _this.info = info;
  }
  initGLContext();
  const xr = new WebXRManager(_this, _gl);
  this.xr = xr;
  this.getContext = function() {
    return _gl;
  };
  this.getContextAttributes = function() {
    return _gl.getContextAttributes();
  };
  this.forceContextLoss = function() {
    const extension = extensions.get("WEBGL_lose_context");
    if (extension)
      extension.loseContext();
  };
  this.forceContextRestore = function() {
    const extension = extensions.get("WEBGL_lose_context");
    if (extension)
      extension.restoreContext();
  };
  this.getPixelRatio = function() {
    return _pixelRatio;
  };
  this.setPixelRatio = function(value) {
    if (value === void 0)
      return;
    _pixelRatio = value;
    this.setSize(_width, _height, false);
  };
  this.getSize = function(target) {
    return target.set(_width, _height);
  };
  this.setSize = function(width2, height2, updateStyle) {
    if (xr.isPresenting) {
      console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");
      return;
    }
    _width = width2;
    _height = height2;
    _canvas2.width = Math.floor(width2 * _pixelRatio);
    _canvas2.height = Math.floor(height2 * _pixelRatio);
    if (updateStyle !== false) {
      _canvas2.style.width = width2 + "px";
      _canvas2.style.height = height2 + "px";
    }
    this.setViewport(0, 0, width2, height2);
  };
  this.getDrawingBufferSize = function(target) {
    return target.set(_width * _pixelRatio, _height * _pixelRatio).floor();
  };
  this.setDrawingBufferSize = function(width2, height2, pixelRatio) {
    _width = width2;
    _height = height2;
    _pixelRatio = pixelRatio;
    _canvas2.width = Math.floor(width2 * pixelRatio);
    _canvas2.height = Math.floor(height2 * pixelRatio);
    this.setViewport(0, 0, width2, height2);
  };
  this.getCurrentViewport = function(target) {
    return target.copy(_currentViewport);
  };
  this.getViewport = function(target) {
    return target.copy(_viewport);
  };
  this.setViewport = function(x, y, width2, height2) {
    if (x.isVector4) {
      _viewport.set(x.x, x.y, x.z, x.w);
    } else {
      _viewport.set(x, y, width2, height2);
    }
    state.viewport(_currentViewport.copy(_viewport).multiplyScalar(_pixelRatio).floor());
  };
  this.getScissor = function(target) {
    return target.copy(_scissor);
  };
  this.setScissor = function(x, y, width2, height2) {
    if (x.isVector4) {
      _scissor.set(x.x, x.y, x.z, x.w);
    } else {
      _scissor.set(x, y, width2, height2);
    }
    state.scissor(_currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).floor());
  };
  this.getScissorTest = function() {
    return _scissorTest;
  };
  this.setScissorTest = function(boolean) {
    state.setScissorTest(_scissorTest = boolean);
  };
  this.setOpaqueSort = function(method) {
    _opaqueSort = method;
  };
  this.setTransparentSort = function(method) {
    _transparentSort = method;
  };
  this.getClearColor = function(target) {
    return target.copy(background.getClearColor());
  };
  this.setClearColor = function() {
    background.setClearColor.apply(background, arguments);
  };
  this.getClearAlpha = function() {
    return background.getClearAlpha();
  };
  this.setClearAlpha = function() {
    background.setClearAlpha.apply(background, arguments);
  };
  this.clear = function(color2 = true, depth = true, stencil = true) {
    let bits = 0;
    if (color2)
      bits |= 16384;
    if (depth)
      bits |= 256;
    if (stencil)
      bits |= 1024;
    _gl.clear(bits);
  };
  this.clearColor = function() {
    this.clear(true, false, false);
  };
  this.clearDepth = function() {
    this.clear(false, true, false);
  };
  this.clearStencil = function() {
    this.clear(false, false, true);
  };
  this.dispose = function() {
    _canvas2.removeEventListener("webglcontextlost", onContextLost, false);
    _canvas2.removeEventListener("webglcontextrestored", onContextRestore, false);
    renderLists.dispose();
    renderStates.dispose();
    properties.dispose();
    cubemaps.dispose();
    cubeuvmaps.dispose();
    objects.dispose();
    bindingStates.dispose();
    programCache.dispose();
    xr.dispose();
    xr.removeEventListener("sessionstart", onXRSessionStart);
    xr.removeEventListener("sessionend", onXRSessionEnd);
    if (_transmissionRenderTarget) {
      _transmissionRenderTarget.dispose();
      _transmissionRenderTarget = null;
    }
    animation2.stop();
  };
  function onContextLost(event) {
    event.preventDefault();
    console.log("THREE.WebGLRenderer: Context Lost.");
    _isContextLost = true;
  }
  function onContextRestore() {
    console.log("THREE.WebGLRenderer: Context Restored.");
    _isContextLost = false;
    const infoAutoReset = info.autoReset;
    const shadowMapEnabled = shadowMap.enabled;
    const shadowMapAutoUpdate = shadowMap.autoUpdate;
    const shadowMapNeedsUpdate = shadowMap.needsUpdate;
    const shadowMapType = shadowMap.type;
    initGLContext();
    info.autoReset = infoAutoReset;
    shadowMap.enabled = shadowMapEnabled;
    shadowMap.autoUpdate = shadowMapAutoUpdate;
    shadowMap.needsUpdate = shadowMapNeedsUpdate;
    shadowMap.type = shadowMapType;
  }
  function onMaterialDispose(event) {
    const material = event.target;
    material.removeEventListener("dispose", onMaterialDispose);
    deallocateMaterial(material);
  }
  function deallocateMaterial(material) {
    releaseMaterialProgramReferences(material);
    properties.remove(material);
  }
  function releaseMaterialProgramReferences(material) {
    const programs = properties.get(material).programs;
    if (programs !== void 0) {
      programs.forEach(function(program) {
        programCache.releaseProgram(program);
      });
      if (material.isShaderMaterial) {
        programCache.releaseShaderCache(material);
      }
    }
  }
  this.renderBufferDirect = function(camera, scene, geometry, material, object, group2) {
    if (scene === null)
      scene = _emptyScene;
    const frontFaceCW = object.isMesh && object.matrixWorld.determinant() < 0;
    const program = setProgram(camera, scene, geometry, material, object);
    state.setMaterial(material, frontFaceCW);
    let index2 = geometry.index;
    const position2 = geometry.attributes.position;
    if (index2 === null) {
      if (position2 === void 0 || position2.count === 0)
        return;
    } else if (index2.count === 0) {
      return;
    }
    let rangeFactor = 1;
    if (material.wireframe === true) {
      index2 = geometries.getWireframeAttribute(geometry);
      rangeFactor = 2;
    }
    bindingStates.setup(object, material, program, geometry, index2);
    let attribute;
    let renderer = bufferRenderer;
    if (index2 !== null) {
      attribute = attributes.get(index2);
      renderer = indexedBufferRenderer;
      renderer.setIndex(attribute);
    }
    const dataCount = index2 !== null ? index2.count : position2.count;
    const rangeStart = geometry.drawRange.start * rangeFactor;
    const rangeCount = geometry.drawRange.count * rangeFactor;
    const groupStart = group2 !== null ? group2.start * rangeFactor : 0;
    const groupCount = group2 !== null ? group2.count * rangeFactor : Infinity;
    const drawStart = Math.max(rangeStart, groupStart);
    const drawEnd = Math.min(dataCount, rangeStart + rangeCount, groupStart + groupCount) - 1;
    const drawCount = Math.max(0, drawEnd - drawStart + 1);
    if (drawCount === 0)
      return;
    if (object.isMesh) {
      if (material.wireframe === true) {
        state.setLineWidth(material.wireframeLinewidth * getTargetPixelRatio());
        renderer.setMode(1);
      } else {
        renderer.setMode(4);
      }
    } else if (object.isLine) {
      let lineWidth = material.linewidth;
      if (lineWidth === void 0)
        lineWidth = 1;
      state.setLineWidth(lineWidth * getTargetPixelRatio());
      if (object.isLineSegments) {
        renderer.setMode(1);
      } else if (object.isLineLoop) {
        renderer.setMode(2);
      } else {
        renderer.setMode(3);
      }
    } else if (object.isPoints) {
      renderer.setMode(0);
    } else if (object.isSprite) {
      renderer.setMode(4);
    }
    if (object.isInstancedMesh) {
      renderer.renderInstances(drawStart, drawCount, object.count);
    } else if (geometry.isInstancedBufferGeometry) {
      const instanceCount = Math.min(geometry.instanceCount, geometry._maxInstanceCount);
      renderer.renderInstances(drawStart, drawCount, instanceCount);
    } else {
      renderer.render(drawStart, drawCount);
    }
  };
  this.compile = function(scene, camera) {
    currentRenderState = renderStates.get(scene);
    currentRenderState.init();
    renderStateStack.push(currentRenderState);
    scene.traverseVisible(function(object) {
      if (object.isLight && object.layers.test(camera.layers)) {
        currentRenderState.pushLight(object);
        if (object.castShadow) {
          currentRenderState.pushShadow(object);
        }
      }
    });
    currentRenderState.setupLights(_this.physicallyCorrectLights);
    scene.traverse(function(object) {
      const material = object.material;
      if (material) {
        if (Array.isArray(material)) {
          for (let i = 0; i < material.length; i++) {
            const material2 = material[i];
            getProgram(material2, scene, object);
          }
        } else {
          getProgram(material, scene, object);
        }
      }
    });
    renderStateStack.pop();
    currentRenderState = null;
  };
  let onAnimationFrameCallback = null;
  function onAnimationFrame(time) {
    if (onAnimationFrameCallback)
      onAnimationFrameCallback(time);
  }
  function onXRSessionStart() {
    animation2.stop();
  }
  function onXRSessionEnd() {
    animation2.start();
  }
  const animation2 = new WebGLAnimation();
  animation2.setAnimationLoop(onAnimationFrame);
  if (typeof self !== "undefined")
    animation2.setContext(self);
  this.setAnimationLoop = function(callback) {
    onAnimationFrameCallback = callback;
    xr.setAnimationLoop(callback);
    callback === null ? animation2.stop() : animation2.start();
  };
  xr.addEventListener("sessionstart", onXRSessionStart);
  xr.addEventListener("sessionend", onXRSessionEnd);
  this.render = function(scene, camera) {
    if (camera !== void 0 && camera.isCamera !== true) {
      console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
      return;
    }
    if (_isContextLost === true)
      return;
    if (scene.autoUpdate === true)
      scene.updateMatrixWorld();
    if (camera.parent === null)
      camera.updateMatrixWorld();
    if (xr.enabled === true && xr.isPresenting === true) {
      if (xr.cameraAutoUpdate === true)
        xr.updateCamera(camera);
      camera = xr.getCamera();
    }
    if (scene.isScene === true)
      scene.onBeforeRender(_this, scene, camera, _currentRenderTarget);
    currentRenderState = renderStates.get(scene, renderStateStack.length);
    currentRenderState.init();
    renderStateStack.push(currentRenderState);
    _projScreenMatrix2.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
    _frustum.setFromProjectionMatrix(_projScreenMatrix2);
    _localClippingEnabled = this.localClippingEnabled;
    _clippingEnabled = clipping.init(this.clippingPlanes, _localClippingEnabled, camera);
    currentRenderList = renderLists.get(scene, renderListStack.length);
    currentRenderList.init();
    renderListStack.push(currentRenderList);
    projectObject(scene, camera, 0, _this.sortObjects);
    currentRenderList.finish();
    if (_this.sortObjects === true) {
      currentRenderList.sort(_opaqueSort, _transparentSort);
    }
    if (_clippingEnabled === true)
      clipping.beginShadows();
    const shadowsArray = currentRenderState.state.shadowsArray;
    shadowMap.render(shadowsArray, scene, camera);
    if (_clippingEnabled === true)
      clipping.endShadows();
    if (this.info.autoReset === true)
      this.info.reset();
    background.render(currentRenderList, scene);
    currentRenderState.setupLights(_this.physicallyCorrectLights);
    if (camera.isArrayCamera) {
      const cameras = camera.cameras;
      for (let i = 0, l = cameras.length; i < l; i++) {
        const camera2 = cameras[i];
        renderScene(currentRenderList, scene, camera2, camera2.viewport);
      }
    } else {
      renderScene(currentRenderList, scene, camera);
    }
    if (_currentRenderTarget !== null) {
      textures.updateMultisampleRenderTarget(_currentRenderTarget);
      textures.updateRenderTargetMipmap(_currentRenderTarget);
    }
    if (scene.isScene === true)
      scene.onAfterRender(_this, scene, camera);
    bindingStates.resetDefaultState();
    _currentMaterialId = -1;
    _currentCamera = null;
    renderStateStack.pop();
    if (renderStateStack.length > 0) {
      currentRenderState = renderStateStack[renderStateStack.length - 1];
    } else {
      currentRenderState = null;
    }
    renderListStack.pop();
    if (renderListStack.length > 0) {
      currentRenderList = renderListStack[renderListStack.length - 1];
    } else {
      currentRenderList = null;
    }
  };
  function projectObject(object, camera, groupOrder, sortObjects) {
    if (object.visible === false)
      return;
    const visible2 = object.layers.test(camera.layers);
    if (visible2) {
      if (object.isGroup) {
        groupOrder = object.renderOrder;
      } else if (object.isLOD) {
        if (object.autoUpdate === true)
          object.update(camera);
      } else if (object.isLight) {
        currentRenderState.pushLight(object);
        if (object.castShadow) {
          currentRenderState.pushShadow(object);
        }
      } else if (object.isSprite) {
        if (!object.frustumCulled || _frustum.intersectsSprite(object)) {
          if (sortObjects) {
            _vector3.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix2);
          }
          const geometry = objects.update(object);
          const material = object.material;
          if (material.visible) {
            currentRenderList.push(object, geometry, material, groupOrder, _vector3.z, null);
          }
        }
      } else if (object.isMesh || object.isLine || object.isPoints) {
        if (object.isSkinnedMesh) {
          if (object.skeleton.frame !== info.render.frame) {
            object.skeleton.update();
            object.skeleton.frame = info.render.frame;
          }
        }
        if (!object.frustumCulled || _frustum.intersectsObject(object)) {
          if (sortObjects) {
            _vector3.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix2);
          }
          const geometry = objects.update(object);
          const material = object.material;
          if (Array.isArray(material)) {
            const groups = geometry.groups;
            for (let i = 0, l = groups.length; i < l; i++) {
              const group2 = groups[i];
              const groupMaterial = material[group2.materialIndex];
              if (groupMaterial && groupMaterial.visible) {
                currentRenderList.push(object, geometry, groupMaterial, groupOrder, _vector3.z, group2);
              }
            }
          } else if (material.visible) {
            currentRenderList.push(object, geometry, material, groupOrder, _vector3.z, null);
          }
        }
      }
    }
    const children2 = object.children;
    for (let i = 0, l = children2.length; i < l; i++) {
      projectObject(children2[i], camera, groupOrder, sortObjects);
    }
  }
  function renderScene(currentRenderList2, scene, camera, viewport) {
    const opaqueObjects = currentRenderList2.opaque;
    const transmissiveObjects = currentRenderList2.transmissive;
    const transparentObjects = currentRenderList2.transparent;
    currentRenderState.setupLightsView(camera);
    if (transmissiveObjects.length > 0)
      renderTransmissionPass(opaqueObjects, scene, camera);
    if (viewport)
      state.viewport(_currentViewport.copy(viewport));
    if (opaqueObjects.length > 0)
      renderObjects(opaqueObjects, scene, camera);
    if (transmissiveObjects.length > 0)
      renderObjects(transmissiveObjects, scene, camera);
    if (transparentObjects.length > 0)
      renderObjects(transparentObjects, scene, camera);
    state.buffers.depth.setTest(true);
    state.buffers.depth.setMask(true);
    state.buffers.color.setMask(true);
    state.setPolygonOffset(false);
  }
  function renderTransmissionPass(opaqueObjects, scene, camera) {
    const isWebGL2 = capabilities.isWebGL2;
    if (_transmissionRenderTarget === null) {
      _transmissionRenderTarget = new WebGLRenderTarget(1, 1, {
        generateMipmaps: true,
        type: utils.convert(HalfFloatType) !== null ? HalfFloatType : UnsignedByteType,
        minFilter: LinearMipmapLinearFilter,
        samples: isWebGL2 && _antialias === true ? 4 : 0
      });
    }
    _this.getDrawingBufferSize(_vector22);
    if (isWebGL2) {
      _transmissionRenderTarget.setSize(_vector22.x, _vector22.y);
    } else {
      _transmissionRenderTarget.setSize(floorPowerOfTwo(_vector22.x), floorPowerOfTwo(_vector22.y));
    }
    const currentRenderTarget = _this.getRenderTarget();
    _this.setRenderTarget(_transmissionRenderTarget);
    _this.clear();
    const currentToneMapping = _this.toneMapping;
    _this.toneMapping = NoToneMapping;
    renderObjects(opaqueObjects, scene, camera);
    _this.toneMapping = currentToneMapping;
    textures.updateMultisampleRenderTarget(_transmissionRenderTarget);
    textures.updateRenderTargetMipmap(_transmissionRenderTarget);
    _this.setRenderTarget(currentRenderTarget);
  }
  function renderObjects(renderList, scene, camera) {
    const overrideMaterial = scene.isScene === true ? scene.overrideMaterial : null;
    for (let i = 0, l = renderList.length; i < l; i++) {
      const renderItem = renderList[i];
      const object = renderItem.object;
      const geometry = renderItem.geometry;
      const material = overrideMaterial === null ? renderItem.material : overrideMaterial;
      const group2 = renderItem.group;
      if (object.layers.test(camera.layers)) {
        renderObject(object, scene, camera, geometry, material, group2);
      }
    }
  }
  function renderObject(object, scene, camera, geometry, material, group2) {
    object.onBeforeRender(_this, scene, camera, geometry, material, group2);
    object.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, object.matrixWorld);
    object.normalMatrix.getNormalMatrix(object.modelViewMatrix);
    material.onBeforeRender(_this, scene, camera, geometry, object, group2);
    if (material.transparent === true && material.side === DoubleSide) {
      material.side = BackSide;
      material.needsUpdate = true;
      _this.renderBufferDirect(camera, scene, geometry, material, object, group2);
      material.side = FrontSide;
      material.needsUpdate = true;
      _this.renderBufferDirect(camera, scene, geometry, material, object, group2);
      material.side = DoubleSide;
    } else {
      _this.renderBufferDirect(camera, scene, geometry, material, object, group2);
    }
    object.onAfterRender(_this, scene, camera, geometry, material, group2);
  }
  function getProgram(material, scene, object) {
    if (scene.isScene !== true)
      scene = _emptyScene;
    const materialProperties = properties.get(material);
    const lights = currentRenderState.state.lights;
    const shadowsArray = currentRenderState.state.shadowsArray;
    const lightsStateVersion = lights.state.version;
    const parameters2 = programCache.getParameters(material, lights.state, shadowsArray, scene, object);
    const programCacheKey = programCache.getProgramCacheKey(parameters2);
    let programs = materialProperties.programs;
    materialProperties.environment = material.isMeshStandardMaterial ? scene.environment : null;
    materialProperties.fog = scene.fog;
    materialProperties.envMap = (material.isMeshStandardMaterial ? cubeuvmaps : cubemaps).get(material.envMap || materialProperties.environment);
    if (programs === void 0) {
      material.addEventListener("dispose", onMaterialDispose);
      programs = /* @__PURE__ */ new Map();
      materialProperties.programs = programs;
    }
    let program = programs.get(programCacheKey);
    if (program !== void 0) {
      if (materialProperties.currentProgram === program && materialProperties.lightsStateVersion === lightsStateVersion) {
        updateCommonMaterialProperties(material, parameters2);
        return program;
      }
    } else {
      parameters2.uniforms = programCache.getUniforms(material);
      material.onBuild(object, parameters2, _this);
      material.onBeforeCompile(parameters2, _this);
      program = programCache.acquireProgram(parameters2, programCacheKey);
      programs.set(programCacheKey, program);
      materialProperties.uniforms = parameters2.uniforms;
    }
    const uniforms = materialProperties.uniforms;
    if (!material.isShaderMaterial && !material.isRawShaderMaterial || material.clipping === true) {
      uniforms.clippingPlanes = clipping.uniform;
    }
    updateCommonMaterialProperties(material, parameters2);
    materialProperties.needsLights = materialNeedsLights(material);
    materialProperties.lightsStateVersion = lightsStateVersion;
    if (materialProperties.needsLights) {
      uniforms.ambientLightColor.value = lights.state.ambient;
      uniforms.lightProbe.value = lights.state.probe;
      uniforms.directionalLights.value = lights.state.directional;
      uniforms.directionalLightShadows.value = lights.state.directionalShadow;
      uniforms.spotLights.value = lights.state.spot;
      uniforms.spotLightShadows.value = lights.state.spotShadow;
      uniforms.rectAreaLights.value = lights.state.rectArea;
      uniforms.ltc_1.value = lights.state.rectAreaLTC1;
      uniforms.ltc_2.value = lights.state.rectAreaLTC2;
      uniforms.pointLights.value = lights.state.point;
      uniforms.pointLightShadows.value = lights.state.pointShadow;
      uniforms.hemisphereLights.value = lights.state.hemi;
      uniforms.directionalShadowMap.value = lights.state.directionalShadowMap;
      uniforms.directionalShadowMatrix.value = lights.state.directionalShadowMatrix;
      uniforms.spotShadowMap.value = lights.state.spotShadowMap;
      uniforms.spotShadowMatrix.value = lights.state.spotShadowMatrix;
      uniforms.pointShadowMap.value = lights.state.pointShadowMap;
      uniforms.pointShadowMatrix.value = lights.state.pointShadowMatrix;
    }
    const progUniforms = program.getUniforms();
    const uniformsList = WebGLUniforms.seqWithValue(progUniforms.seq, uniforms);
    materialProperties.currentProgram = program;
    materialProperties.uniformsList = uniformsList;
    return program;
  }
  function updateCommonMaterialProperties(material, parameters2) {
    const materialProperties = properties.get(material);
    materialProperties.outputEncoding = parameters2.outputEncoding;
    materialProperties.instancing = parameters2.instancing;
    materialProperties.skinning = parameters2.skinning;
    materialProperties.morphTargets = parameters2.morphTargets;
    materialProperties.morphNormals = parameters2.morphNormals;
    materialProperties.morphColors = parameters2.morphColors;
    materialProperties.morphTargetsCount = parameters2.morphTargetsCount;
    materialProperties.numClippingPlanes = parameters2.numClippingPlanes;
    materialProperties.numIntersection = parameters2.numClipIntersection;
    materialProperties.vertexAlphas = parameters2.vertexAlphas;
    materialProperties.vertexTangents = parameters2.vertexTangents;
    materialProperties.toneMapping = parameters2.toneMapping;
  }
  function setProgram(camera, scene, geometry, material, object) {
    if (scene.isScene !== true)
      scene = _emptyScene;
    textures.resetTextureUnits();
    const fog = scene.fog;
    const environment = material.isMeshStandardMaterial ? scene.environment : null;
    const encoding = _currentRenderTarget === null ? _this.outputEncoding : _currentRenderTarget.isXRRenderTarget === true ? _currentRenderTarget.texture.encoding : LinearEncoding;
    const envMap = (material.isMeshStandardMaterial ? cubeuvmaps : cubemaps).get(material.envMap || environment);
    const vertexAlphas = material.vertexColors === true && !!geometry.attributes.color && geometry.attributes.color.itemSize === 4;
    const vertexTangents = !!material.normalMap && !!geometry.attributes.tangent;
    const morphTargets = !!geometry.morphAttributes.position;
    const morphNormals = !!geometry.morphAttributes.normal;
    const morphColors = !!geometry.morphAttributes.color;
    const toneMapping = material.toneMapped ? _this.toneMapping : NoToneMapping;
    const morphAttribute = geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color;
    const morphTargetsCount = morphAttribute !== void 0 ? morphAttribute.length : 0;
    const materialProperties = properties.get(material);
    const lights = currentRenderState.state.lights;
    if (_clippingEnabled === true) {
      if (_localClippingEnabled === true || camera !== _currentCamera) {
        const useCache = camera === _currentCamera && material.id === _currentMaterialId;
        clipping.setState(material, camera, useCache);
      }
    }
    let needsProgramChange = false;
    if (material.version === materialProperties.__version) {
      if (materialProperties.needsLights && materialProperties.lightsStateVersion !== lights.state.version) {
        needsProgramChange = true;
      } else if (materialProperties.outputEncoding !== encoding) {
        needsProgramChange = true;
      } else if (object.isInstancedMesh && materialProperties.instancing === false) {
        needsProgramChange = true;
      } else if (!object.isInstancedMesh && materialProperties.instancing === true) {
        needsProgramChange = true;
      } else if (object.isSkinnedMesh && materialProperties.skinning === false) {
        needsProgramChange = true;
      } else if (!object.isSkinnedMesh && materialProperties.skinning === true) {
        needsProgramChange = true;
      } else if (materialProperties.envMap !== envMap) {
        needsProgramChange = true;
      } else if (material.fog && materialProperties.fog !== fog) {
        needsProgramChange = true;
      } else if (materialProperties.numClippingPlanes !== void 0 && (materialProperties.numClippingPlanes !== clipping.numPlanes || materialProperties.numIntersection !== clipping.numIntersection)) {
        needsProgramChange = true;
      } else if (materialProperties.vertexAlphas !== vertexAlphas) {
        needsProgramChange = true;
      } else if (materialProperties.vertexTangents !== vertexTangents) {
        needsProgramChange = true;
      } else if (materialProperties.morphTargets !== morphTargets) {
        needsProgramChange = true;
      } else if (materialProperties.morphNormals !== morphNormals) {
        needsProgramChange = true;
      } else if (materialProperties.morphColors !== morphColors) {
        needsProgramChange = true;
      } else if (materialProperties.toneMapping !== toneMapping) {
        needsProgramChange = true;
      } else if (capabilities.isWebGL2 === true && materialProperties.morphTargetsCount !== morphTargetsCount) {
        needsProgramChange = true;
      }
    } else {
      needsProgramChange = true;
      materialProperties.__version = material.version;
    }
    let program = materialProperties.currentProgram;
    if (needsProgramChange === true) {
      program = getProgram(material, scene, object);
    }
    let refreshProgram = false;
    let refreshMaterial = false;
    let refreshLights = false;
    const p_uniforms = program.getUniforms(), m_uniforms = materialProperties.uniforms;
    if (state.useProgram(program.program)) {
      refreshProgram = true;
      refreshMaterial = true;
      refreshLights = true;
    }
    if (material.id !== _currentMaterialId) {
      _currentMaterialId = material.id;
      refreshMaterial = true;
    }
    if (refreshProgram || _currentCamera !== camera) {
      p_uniforms.setValue(_gl, "projectionMatrix", camera.projectionMatrix);
      if (capabilities.logarithmicDepthBuffer) {
        p_uniforms.setValue(_gl, "logDepthBufFC", 2 / (Math.log(camera.far + 1) / Math.LN2));
      }
      if (_currentCamera !== camera) {
        _currentCamera = camera;
        refreshMaterial = true;
        refreshLights = true;
      }
      if (material.isShaderMaterial || material.isMeshPhongMaterial || material.isMeshToonMaterial || material.isMeshStandardMaterial || material.envMap) {
        const uCamPos = p_uniforms.map.cameraPosition;
        if (uCamPos !== void 0) {
          uCamPos.setValue(_gl, _vector3.setFromMatrixPosition(camera.matrixWorld));
        }
      }
      if (material.isMeshPhongMaterial || material.isMeshToonMaterial || material.isMeshLambertMaterial || material.isMeshBasicMaterial || material.isMeshStandardMaterial || material.isShaderMaterial) {
        p_uniforms.setValue(_gl, "isOrthographic", camera.isOrthographicCamera === true);
      }
      if (material.isMeshPhongMaterial || material.isMeshToonMaterial || material.isMeshLambertMaterial || material.isMeshBasicMaterial || material.isMeshStandardMaterial || material.isShaderMaterial || material.isShadowMaterial || object.isSkinnedMesh) {
        p_uniforms.setValue(_gl, "viewMatrix", camera.matrixWorldInverse);
      }
    }
    if (object.isSkinnedMesh) {
      p_uniforms.setOptional(_gl, object, "bindMatrix");
      p_uniforms.setOptional(_gl, object, "bindMatrixInverse");
      const skeleton = object.skeleton;
      if (skeleton) {
        if (capabilities.floatVertexTextures) {
          if (skeleton.boneTexture === null)
            skeleton.computeBoneTexture();
          p_uniforms.setValue(_gl, "boneTexture", skeleton.boneTexture, textures);
          p_uniforms.setValue(_gl, "boneTextureSize", skeleton.boneTextureSize);
        } else {
          p_uniforms.setOptional(_gl, skeleton, "boneMatrices");
        }
      }
    }
    const morphAttributes = geometry.morphAttributes;
    if (morphAttributes.position !== void 0 || morphAttributes.normal !== void 0 || morphAttributes.color !== void 0 && capabilities.isWebGL2 === true) {
      morphtargets.update(object, geometry, material, program);
    }
    if (refreshMaterial || materialProperties.receiveShadow !== object.receiveShadow) {
      materialProperties.receiveShadow = object.receiveShadow;
      p_uniforms.setValue(_gl, "receiveShadow", object.receiveShadow);
    }
    if (refreshMaterial) {
      p_uniforms.setValue(_gl, "toneMappingExposure", _this.toneMappingExposure);
      if (materialProperties.needsLights) {
        markUniformsLightsNeedsUpdate(m_uniforms, refreshLights);
      }
      if (fog && material.fog) {
        materials.refreshFogUniforms(m_uniforms, fog);
      }
      materials.refreshMaterialUniforms(m_uniforms, material, _pixelRatio, _height, _transmissionRenderTarget);
      WebGLUniforms.upload(_gl, materialProperties.uniformsList, m_uniforms, textures);
    }
    if (material.isShaderMaterial && material.uniformsNeedUpdate === true) {
      WebGLUniforms.upload(_gl, materialProperties.uniformsList, m_uniforms, textures);
      material.uniformsNeedUpdate = false;
    }
    if (material.isSpriteMaterial) {
      p_uniforms.setValue(_gl, "center", object.center);
    }
    p_uniforms.setValue(_gl, "modelViewMatrix", object.modelViewMatrix);
    p_uniforms.setValue(_gl, "normalMatrix", object.normalMatrix);
    p_uniforms.setValue(_gl, "modelMatrix", object.matrixWorld);
    return program;
  }
  function markUniformsLightsNeedsUpdate(uniforms, value) {
    uniforms.ambientLightColor.needsUpdate = value;
    uniforms.lightProbe.needsUpdate = value;
    uniforms.directionalLights.needsUpdate = value;
    uniforms.directionalLightShadows.needsUpdate = value;
    uniforms.pointLights.needsUpdate = value;
    uniforms.pointLightShadows.needsUpdate = value;
    uniforms.spotLights.needsUpdate = value;
    uniforms.spotLightShadows.needsUpdate = value;
    uniforms.rectAreaLights.needsUpdate = value;
    uniforms.hemisphereLights.needsUpdate = value;
  }
  function materialNeedsLights(material) {
    return material.isMeshLambertMaterial || material.isMeshToonMaterial || material.isMeshPhongMaterial || material.isMeshStandardMaterial || material.isShadowMaterial || material.isShaderMaterial && material.lights === true;
  }
  this.getActiveCubeFace = function() {
    return _currentActiveCubeFace;
  };
  this.getActiveMipmapLevel = function() {
    return _currentActiveMipmapLevel;
  };
  this.getRenderTarget = function() {
    return _currentRenderTarget;
  };
  this.setRenderTargetTextures = function(renderTarget, colorTexture, depthTexture) {
    properties.get(renderTarget.texture).__webglTexture = colorTexture;
    properties.get(renderTarget.depthTexture).__webglTexture = depthTexture;
    const renderTargetProperties = properties.get(renderTarget);
    renderTargetProperties.__hasExternalTextures = true;
    if (renderTargetProperties.__hasExternalTextures) {
      renderTargetProperties.__autoAllocateDepthBuffer = depthTexture === void 0;
      if (!renderTargetProperties.__autoAllocateDepthBuffer) {
        if (extensions.has("WEBGL_multisampled_render_to_texture") === true) {
          console.warn("THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided");
          renderTargetProperties.__useRenderToTexture = false;
        }
      }
    }
  };
  this.setRenderTargetFramebuffer = function(renderTarget, defaultFramebuffer) {
    const renderTargetProperties = properties.get(renderTarget);
    renderTargetProperties.__webglFramebuffer = defaultFramebuffer;
    renderTargetProperties.__useDefaultFramebuffer = defaultFramebuffer === void 0;
  };
  this.setRenderTarget = function(renderTarget, activeCubeFace = 0, activeMipmapLevel = 0) {
    _currentRenderTarget = renderTarget;
    _currentActiveCubeFace = activeCubeFace;
    _currentActiveMipmapLevel = activeMipmapLevel;
    let useDefaultFramebuffer = true;
    if (renderTarget) {
      const renderTargetProperties = properties.get(renderTarget);
      if (renderTargetProperties.__useDefaultFramebuffer !== void 0) {
        state.bindFramebuffer(36160, null);
        useDefaultFramebuffer = false;
      } else if (renderTargetProperties.__webglFramebuffer === void 0) {
        textures.setupRenderTarget(renderTarget);
      } else if (renderTargetProperties.__hasExternalTextures) {
        textures.rebindTextures(renderTarget, properties.get(renderTarget.texture).__webglTexture, properties.get(renderTarget.depthTexture).__webglTexture);
      }
    }
    let framebuffer = null;
    let isCube = false;
    let isRenderTarget3D = false;
    if (renderTarget) {
      const texture2 = renderTarget.texture;
      if (texture2.isData3DTexture || texture2.isDataArrayTexture) {
        isRenderTarget3D = true;
      }
      const __webglFramebuffer = properties.get(renderTarget).__webglFramebuffer;
      if (renderTarget.isWebGLCubeRenderTarget) {
        framebuffer = __webglFramebuffer[activeCubeFace];
        isCube = true;
      } else if (capabilities.isWebGL2 && renderTarget.samples > 0 && textures.useMultisampledRTT(renderTarget) === false) {
        framebuffer = properties.get(renderTarget).__webglMultisampledFramebuffer;
      } else {
        framebuffer = __webglFramebuffer;
      }
      _currentViewport.copy(renderTarget.viewport);
      _currentScissor.copy(renderTarget.scissor);
      _currentScissorTest = renderTarget.scissorTest;
    } else {
      _currentViewport.copy(_viewport).multiplyScalar(_pixelRatio).floor();
      _currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).floor();
      _currentScissorTest = _scissorTest;
    }
    const framebufferBound = state.bindFramebuffer(36160, framebuffer);
    if (framebufferBound && capabilities.drawBuffers && useDefaultFramebuffer) {
      state.drawBuffers(renderTarget, framebuffer);
    }
    state.viewport(_currentViewport);
    state.scissor(_currentScissor);
    state.setScissorTest(_currentScissorTest);
    if (isCube) {
      const textureProperties = properties.get(renderTarget.texture);
      _gl.framebufferTexture2D(36160, 36064, 34069 + activeCubeFace, textureProperties.__webglTexture, activeMipmapLevel);
    } else if (isRenderTarget3D) {
      const textureProperties = properties.get(renderTarget.texture);
      const layer = activeCubeFace || 0;
      _gl.framebufferTextureLayer(36160, 36064, textureProperties.__webglTexture, activeMipmapLevel || 0, layer);
    }
    _currentMaterialId = -1;
  };
  this.readRenderTargetPixels = function(renderTarget, x, y, width2, height2, buffer, activeCubeFaceIndex) {
    if (!(renderTarget && renderTarget.isWebGLRenderTarget)) {
      console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
      return;
    }
    let framebuffer = properties.get(renderTarget).__webglFramebuffer;
    if (renderTarget.isWebGLCubeRenderTarget && activeCubeFaceIndex !== void 0) {
      framebuffer = framebuffer[activeCubeFaceIndex];
    }
    if (framebuffer) {
      state.bindFramebuffer(36160, framebuffer);
      try {
        const texture2 = renderTarget.texture;
        const textureFormat = texture2.format;
        const textureType = texture2.type;
        if (textureFormat !== RGBAFormat && utils.convert(textureFormat) !== _gl.getParameter(35739)) {
          console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
          return;
        }
        const halfFloatSupportedByExt = textureType === HalfFloatType && (extensions.has("EXT_color_buffer_half_float") || capabilities.isWebGL2 && extensions.has("EXT_color_buffer_float"));
        if (textureType !== UnsignedByteType && utils.convert(textureType) !== _gl.getParameter(35738) && !(textureType === FloatType && (capabilities.isWebGL2 || extensions.has("OES_texture_float") || extensions.has("WEBGL_color_buffer_float"))) && !halfFloatSupportedByExt) {
          console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
          return;
        }
        if (x >= 0 && x <= renderTarget.width - width2 && (y >= 0 && y <= renderTarget.height - height2)) {
          _gl.readPixels(x, y, width2, height2, utils.convert(textureFormat), utils.convert(textureType), buffer);
        }
      } finally {
        const framebuffer2 = _currentRenderTarget !== null ? properties.get(_currentRenderTarget).__webglFramebuffer : null;
        state.bindFramebuffer(36160, framebuffer2);
      }
    }
  };
  this.copyFramebufferToTexture = function(position2, texture2, level = 0) {
    if (texture2.isFramebufferTexture !== true) {
      console.error("THREE.WebGLRenderer: copyFramebufferToTexture() can only be used with FramebufferTexture.");
      return;
    }
    const levelScale = Math.pow(2, -level);
    const width2 = Math.floor(texture2.image.width * levelScale);
    const height2 = Math.floor(texture2.image.height * levelScale);
    textures.setTexture2D(texture2, 0);
    _gl.copyTexSubImage2D(3553, level, 0, 0, position2.x, position2.y, width2, height2);
    state.unbindTexture();
  };
  this.copyTextureToTexture = function(position2, srcTexture, dstTexture, level = 0) {
    const width2 = srcTexture.image.width;
    const height2 = srcTexture.image.height;
    const glFormat = utils.convert(dstTexture.format);
    const glType = utils.convert(dstTexture.type);
    textures.setTexture2D(dstTexture, 0);
    _gl.pixelStorei(37440, dstTexture.flipY);
    _gl.pixelStorei(37441, dstTexture.premultiplyAlpha);
    _gl.pixelStorei(3317, dstTexture.unpackAlignment);
    if (srcTexture.isDataTexture) {
      _gl.texSubImage2D(3553, level, position2.x, position2.y, width2, height2, glFormat, glType, srcTexture.image.data);
    } else {
      if (srcTexture.isCompressedTexture) {
        _gl.compressedTexSubImage2D(3553, level, position2.x, position2.y, srcTexture.mipmaps[0].width, srcTexture.mipmaps[0].height, glFormat, srcTexture.mipmaps[0].data);
      } else {
        _gl.texSubImage2D(3553, level, position2.x, position2.y, glFormat, glType, srcTexture.image);
      }
    }
    if (level === 0 && dstTexture.generateMipmaps)
      _gl.generateMipmap(3553);
    state.unbindTexture();
  };
  this.copyTextureToTexture3D = function(sourceBox, position2, srcTexture, dstTexture, level = 0) {
    if (_this.isWebGL1Renderer) {
      console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");
      return;
    }
    const width2 = sourceBox.max.x - sourceBox.min.x + 1;
    const height2 = sourceBox.max.y - sourceBox.min.y + 1;
    const depth = sourceBox.max.z - sourceBox.min.z + 1;
    const glFormat = utils.convert(dstTexture.format);
    const glType = utils.convert(dstTexture.type);
    let glTarget;
    if (dstTexture.isData3DTexture) {
      textures.setTexture3D(dstTexture, 0);
      glTarget = 32879;
    } else if (dstTexture.isDataArrayTexture) {
      textures.setTexture2DArray(dstTexture, 0);
      glTarget = 35866;
    } else {
      console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");
      return;
    }
    _gl.pixelStorei(37440, dstTexture.flipY);
    _gl.pixelStorei(37441, dstTexture.premultiplyAlpha);
    _gl.pixelStorei(3317, dstTexture.unpackAlignment);
    const unpackRowLen = _gl.getParameter(3314);
    const unpackImageHeight = _gl.getParameter(32878);
    const unpackSkipPixels = _gl.getParameter(3316);
    const unpackSkipRows = _gl.getParameter(3315);
    const unpackSkipImages = _gl.getParameter(32877);
    const image2 = srcTexture.isCompressedTexture ? srcTexture.mipmaps[0] : srcTexture.image;
    _gl.pixelStorei(3314, image2.width);
    _gl.pixelStorei(32878, image2.height);
    _gl.pixelStorei(3316, sourceBox.min.x);
    _gl.pixelStorei(3315, sourceBox.min.y);
    _gl.pixelStorei(32877, sourceBox.min.z);
    if (srcTexture.isDataTexture || srcTexture.isData3DTexture) {
      _gl.texSubImage3D(glTarget, level, position2.x, position2.y, position2.z, width2, height2, depth, glFormat, glType, image2.data);
    } else {
      if (srcTexture.isCompressedTexture) {
        console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture.");
        _gl.compressedTexSubImage3D(glTarget, level, position2.x, position2.y, position2.z, width2, height2, depth, glFormat, image2.data);
      } else {
        _gl.texSubImage3D(glTarget, level, position2.x, position2.y, position2.z, width2, height2, depth, glFormat, glType, image2);
      }
    }
    _gl.pixelStorei(3314, unpackRowLen);
    _gl.pixelStorei(32878, unpackImageHeight);
    _gl.pixelStorei(3316, unpackSkipPixels);
    _gl.pixelStorei(3315, unpackSkipRows);
    _gl.pixelStorei(32877, unpackSkipImages);
    if (level === 0 && dstTexture.generateMipmaps)
      _gl.generateMipmap(glTarget);
    state.unbindTexture();
  };
  this.initTexture = function(texture2) {
    textures.setTexture2D(texture2, 0);
    state.unbindTexture();
  };
  this.resetState = function() {
    _currentActiveCubeFace = 0;
    _currentActiveMipmapLevel = 0;
    _currentRenderTarget = null;
    state.reset();
    bindingStates.reset();
  };
  if (typeof __THREE_DEVTOOLS__ !== "undefined") {
    __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
  }
}
WebGLRenderer.prototype.isWebGLRenderer = true;
class WebGL1Renderer extends WebGLRenderer {
}
WebGL1Renderer.prototype.isWebGL1Renderer = true;
class FogExp2 {
  constructor(color2, density = 25e-5) {
    this.name = "";
    this.color = new Color(color2);
    this.density = density;
  }
  clone() {
    return new FogExp2(this.color, this.density);
  }
  toJSON() {
    return {
      type: "FogExp2",
      color: this.color.getHex(),
      density: this.density
    };
  }
}
FogExp2.prototype.isFogExp2 = true;
class Fog {
  constructor(color2, near = 1, far = 1e3) {
    this.name = "";
    this.color = new Color(color2);
    this.near = near;
    this.far = far;
  }
  clone() {
    return new Fog(this.color, this.near, this.far);
  }
  toJSON() {
    return {
      type: "Fog",
      color: this.color.getHex(),
      near: this.near,
      far: this.far
    };
  }
}
Fog.prototype.isFog = true;
class Scene extends Object3D {
  constructor() {
    super();
    this.type = "Scene";
    this.background = null;
    this.environment = null;
    this.fog = null;
    this.overrideMaterial = null;
    this.autoUpdate = true;
    if (typeof __THREE_DEVTOOLS__ !== "undefined") {
      __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
    }
  }
  copy(source2, recursive) {
    super.copy(source2, recursive);
    if (source2.background !== null)
      this.background = source2.background.clone();
    if (source2.environment !== null)
      this.environment = source2.environment.clone();
    if (source2.fog !== null)
      this.fog = source2.fog.clone();
    if (source2.overrideMaterial !== null)
      this.overrideMaterial = source2.overrideMaterial.clone();
    this.autoUpdate = source2.autoUpdate;
    this.matrixAutoUpdate = source2.matrixAutoUpdate;
    return this;
  }
  toJSON(meta) {
    const data = super.toJSON(meta);
    if (this.fog !== null)
      data.object.fog = this.fog.toJSON();
    return data;
  }
}
Scene.prototype.isScene = true;
class InterleavedBuffer {
  constructor(array, stride) {
    this.array = array;
    this.stride = stride;
    this.count = array !== void 0 ? array.length / stride : 0;
    this.usage = StaticDrawUsage;
    this.updateRange = { offset: 0, count: -1 };
    this.version = 0;
    this.uuid = generateUUID();
  }
  onUploadCallback() {
  }
  set needsUpdate(value) {
    if (value === true)
      this.version++;
  }
  setUsage(value) {
    this.usage = value;
    return this;
  }
  copy(source2) {
    this.array = new source2.array.constructor(source2.array);
    this.count = source2.count;
    this.stride = source2.stride;
    this.usage = source2.usage;
    return this;
  }
  copyAt(index1, attribute, index2) {
    index1 *= this.stride;
    index2 *= attribute.stride;
    for (let i = 0, l = this.stride; i < l; i++) {
      this.array[index1 + i] = attribute.array[index2 + i];
    }
    return this;
  }
  set(value, offset = 0) {
    this.array.set(value, offset);
    return this;
  }
  clone(data) {
    if (data.arrayBuffers === void 0) {
      data.arrayBuffers = {};
    }
    if (this.array.buffer._uuid === void 0) {
      this.array.buffer._uuid = generateUUID();
    }
    if (data.arrayBuffers[this.array.buffer._uuid] === void 0) {
      data.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer;
    }
    const array = new this.array.constructor(data.arrayBuffers[this.array.buffer._uuid]);
    const ib = new this.constructor(array, this.stride);
    ib.setUsage(this.usage);
    return ib;
  }
  onUpload(callback) {
    this.onUploadCallback = callback;
    return this;
  }
  toJSON(data) {
    if (data.arrayBuffers === void 0) {
      data.arrayBuffers = {};
    }
    if (this.array.buffer._uuid === void 0) {
      this.array.buffer._uuid = generateUUID();
    }
    if (data.arrayBuffers[this.array.buffer._uuid] === void 0) {
      data.arrayBuffers[this.array.buffer._uuid] = Array.prototype.slice.call(new Uint32Array(this.array.buffer));
    }
    return {
      uuid: this.uuid,
      buffer: this.array.buffer._uuid,
      type: this.array.constructor.name,
      stride: this.stride
    };
  }
}
InterleavedBuffer.prototype.isInterleavedBuffer = true;
const _vector$6 = /* @__PURE__ */ new Vector3();
class InterleavedBufferAttribute {
  constructor(interleavedBuffer, itemSize, offset, normalized = false) {
    this.name = "";
    this.data = interleavedBuffer;
    this.itemSize = itemSize;
    this.offset = offset;
    this.normalized = normalized === true;
  }
  get count() {
    return this.data.count;
  }
  get array() {
    return this.data.array;
  }
  set needsUpdate(value) {
    this.data.needsUpdate = value;
  }
  applyMatrix4(m) {
    for (let i = 0, l = this.data.count; i < l; i++) {
      _vector$6.fromBufferAttribute(this, i);
      _vector$6.applyMatrix4(m);
      this.setXYZ(i, _vector$6.x, _vector$6.y, _vector$6.z);
    }
    return this;
  }
  applyNormalMatrix(m) {
    for (let i = 0, l = this.count; i < l; i++) {
      _vector$6.fromBufferAttribute(this, i);
      _vector$6.applyNormalMatrix(m);
      this.setXYZ(i, _vector$6.x, _vector$6.y, _vector$6.z);
    }
    return this;
  }
  transformDirection(m) {
    for (let i = 0, l = this.count; i < l; i++) {
      _vector$6.fromBufferAttribute(this, i);
      _vector$6.transformDirection(m);
      this.setXYZ(i, _vector$6.x, _vector$6.y, _vector$6.z);
    }
    return this;
  }
  setX(index2, x) {
    this.data.array[index2 * this.data.stride + this.offset] = x;
    return this;
  }
  setY(index2, y) {
    this.data.array[index2 * this.data.stride + this.offset + 1] = y;
    return this;
  }
  setZ(index2, z) {
    this.data.array[index2 * this.data.stride + this.offset + 2] = z;
    return this;
  }
  setW(index2, w) {
    this.data.array[index2 * this.data.stride + this.offset + 3] = w;
    return this;
  }
  getX(index2) {
    return this.data.array[index2 * this.data.stride + this.offset];
  }
  getY(index2) {
    return this.data.array[index2 * this.data.stride + this.offset + 1];
  }
  getZ(index2) {
    return this.data.array[index2 * this.data.stride + this.offset + 2];
  }
  getW(index2) {
    return this.data.array[index2 * this.data.stride + this.offset + 3];
  }
  setXY(index2, x, y) {
    index2 = index2 * this.data.stride + this.offset;
    this.data.array[index2 + 0] = x;
    this.data.array[index2 + 1] = y;
    return this;
  }
  setXYZ(index2, x, y, z) {
    index2 = index2 * this.data.stride + this.offset;
    this.data.array[index2 + 0] = x;
    this.data.array[index2 + 1] = y;
    this.data.array[index2 + 2] = z;
    return this;
  }
  setXYZW(index2, x, y, z, w) {
    index2 = index2 * this.data.stride + this.offset;
    this.data.array[index2 + 0] = x;
    this.data.array[index2 + 1] = y;
    this.data.array[index2 + 2] = z;
    this.data.array[index2 + 3] = w;
    return this;
  }
  clone(data) {
    if (data === void 0) {
      console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data.");
      const array = [];
      for (let i = 0; i < this.count; i++) {
        const index2 = i * this.data.stride + this.offset;
        for (let j = 0; j < this.itemSize; j++) {
          array.push(this.data.array[index2 + j]);
        }
      }
      return new BufferAttribute(new this.array.constructor(array), this.itemSize, this.normalized);
    } else {
      if (data.interleavedBuffers === void 0) {
        data.interleavedBuffers = {};
      }
      if (data.interleavedBuffers[this.data.uuid] === void 0) {
        data.interleavedBuffers[this.data.uuid] = this.data.clone(data);
      }
      return new InterleavedBufferAttribute(data.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized);
    }
  }
  toJSON(data) {
    if (data === void 0) {
      console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data.");
      const array = [];
      for (let i = 0; i < this.count; i++) {
        const index2 = i * this.data.stride + this.offset;
        for (let j = 0; j < this.itemSize; j++) {
          array.push(this.data.array[index2 + j]);
        }
      }
      return {
        itemSize: this.itemSize,
        type: this.array.constructor.name,
        array,
        normalized: this.normalized
      };
    } else {
      if (data.interleavedBuffers === void 0) {
        data.interleavedBuffers = {};
      }
      if (data.interleavedBuffers[this.data.uuid] === void 0) {
        data.interleavedBuffers[this.data.uuid] = this.data.toJSON(data);
      }
      return {
        isInterleavedBufferAttribute: true,
        itemSize: this.itemSize,
        data: this.data.uuid,
        offset: this.offset,
        normalized: this.normalized
      };
    }
  }
}
InterleavedBufferAttribute.prototype.isInterleavedBufferAttribute = true;
class SpriteMaterial extends Material {
  constructor(parameters) {
    super();
    this.type = "SpriteMaterial";
    this.color = new Color(16777215);
    this.map = null;
    this.alphaMap = null;
    this.rotation = 0;
    this.sizeAttenuation = true;
    this.transparent = true;
    this.setValues(parameters);
  }
  copy(source2) {
    super.copy(source2);
    this.color.copy(source2.color);
    this.map = source2.map;
    this.alphaMap = source2.alphaMap;
    this.rotation = source2.rotation;
    this.sizeAttenuation = source2.sizeAttenuation;
    return this;
  }
}
SpriteMaterial.prototype.isSpriteMaterial = true;
let _geometry;
const _intersectPoint = /* @__PURE__ */ new Vector3();
const _worldScale = /* @__PURE__ */ new Vector3();
const _mvPosition = /* @__PURE__ */ new Vector3();
const _alignedPosition = /* @__PURE__ */ new Vector2();
const _rotatedPosition = /* @__PURE__ */ new Vector2();
const _viewWorldMatrix = /* @__PURE__ */ new Matrix4();
const _vA = /* @__PURE__ */ new Vector3();
const _vB = /* @__PURE__ */ new Vector3();
const _vC = /* @__PURE__ */ new Vector3();
const _uvA = /* @__PURE__ */ new Vector2();
const _uvB = /* @__PURE__ */ new Vector2();
const _uvC = /* @__PURE__ */ new Vector2();
class Sprite extends Object3D {
  constructor(material) {
    super();
    this.type = "Sprite";
    if (_geometry === void 0) {
      _geometry = new BufferGeometry();
      const float32Array = new Float32Array([
        -0.5,
        -0.5,
        0,
        0,
        0,
        0.5,
        -0.5,
        0,
        1,
        0,
        0.5,
        0.5,
        0,
        1,
        1,
        -0.5,
        0.5,
        0,
        0,
        1
      ]);
      const interleavedBuffer = new InterleavedBuffer(float32Array, 5);
      _geometry.setIndex([0, 1, 2, 0, 2, 3]);
      _geometry.setAttribute("position", new InterleavedBufferAttribute(interleavedBuffer, 3, 0, false));
      _geometry.setAttribute("uv", new InterleavedBufferAttribute(interleavedBuffer, 2, 3, false));
    }
    this.geometry = _geometry;
    this.material = material !== void 0 ? material : new SpriteMaterial();
    this.center = new Vector2(0.5, 0.5);
  }
  raycast(raycaster, intersects2) {
    if (raycaster.camera === null) {
      console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.');
    }
    _worldScale.setFromMatrixScale(this.matrixWorld);
    _viewWorldMatrix.copy(raycaster.camera.matrixWorld);
    this.modelViewMatrix.multiplyMatrices(raycaster.camera.matrixWorldInverse, this.matrixWorld);
    _mvPosition.setFromMatrixPosition(this.modelViewMatrix);
    if (raycaster.camera.isPerspectiveCamera && this.material.sizeAttenuation === false) {
      _worldScale.multiplyScalar(-_mvPosition.z);
    }
    const rotation = this.material.rotation;
    let sin, cos;
    if (rotation !== 0) {
      cos = Math.cos(rotation);
      sin = Math.sin(rotation);
    }
    const center2 = this.center;
    transformVertex(_vA.set(-0.5, -0.5, 0), _mvPosition, center2, _worldScale, sin, cos);
    transformVertex(_vB.set(0.5, -0.5, 0), _mvPosition, center2, _worldScale, sin, cos);
    transformVertex(_vC.set(0.5, 0.5, 0), _mvPosition, center2, _worldScale, sin, cos);
    _uvA.set(0, 0);
    _uvB.set(1, 0);
    _uvC.set(1, 1);
    let intersect = raycaster.ray.intersectTriangle(_vA, _vB, _vC, false, _intersectPoint);
    if (intersect === null) {
      transformVertex(_vB.set(-0.5, 0.5, 0), _mvPosition, center2, _worldScale, sin, cos);
      _uvB.set(0, 1);
      intersect = raycaster.ray.intersectTriangle(_vA, _vC, _vB, false, _intersectPoint);
      if (intersect === null) {
        return;
      }
    }
    const distance2 = raycaster.ray.origin.distanceTo(_intersectPoint);
    if (distance2 < raycaster.near || distance2 > raycaster.far)
      return;
    intersects2.push({
      distance: distance2,
      point: _intersectPoint.clone(),
      uv: Triangle.getUV(_intersectPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, new Vector2()),
      face: null,
      object: this
    });
  }
  copy(source2) {
    super.copy(source2);
    if (source2.center !== void 0)
      this.center.copy(source2.center);
    this.material = source2.material;
    return this;
  }
}
Sprite.prototype.isSprite = true;
function transformVertex(vertexPosition, mvPosition, center2, scale2, sin, cos) {
  _alignedPosition.subVectors(vertexPosition, center2).addScalar(0.5).multiply(scale2);
  if (sin !== void 0) {
    _rotatedPosition.x = cos * _alignedPosition.x - sin * _alignedPosition.y;
    _rotatedPosition.y = sin * _alignedPosition.x + cos * _alignedPosition.y;
  } else {
    _rotatedPosition.copy(_alignedPosition);
  }
  vertexPosition.copy(mvPosition);
  vertexPosition.x += _rotatedPosition.x;
  vertexPosition.y += _rotatedPosition.y;
  vertexPosition.applyMatrix4(_viewWorldMatrix);
}
const _v1$2 = /* @__PURE__ */ new Vector3();
const _v2$1 = /* @__PURE__ */ new Vector3();
class LOD extends Object3D {
  constructor() {
    super();
    this._currentLevel = 0;
    this.type = "LOD";
    Object.defineProperties(this, {
      levels: {
        enumerable: true,
        value: []
      },
      isLOD: {
        value: true
      }
    });
    this.autoUpdate = true;
  }
  copy(source2) {
    super.copy(source2, false);
    const levels = source2.levels;
    for (let i = 0, l = levels.length; i < l; i++) {
      const level = levels[i];
      this.addLevel(level.object.clone(), level.distance);
    }
    this.autoUpdate = source2.autoUpdate;
    return this;
  }
  addLevel(object, distance2 = 0) {
    distance2 = Math.abs(distance2);
    const levels = this.levels;
    let l;
    for (l = 0; l < levels.length; l++) {
      if (distance2 < levels[l].distance) {
        break;
      }
    }
    levels.splice(l, 0, { distance: distance2, object });
    this.add(object);
    return this;
  }
  getCurrentLevel() {
    return this._currentLevel;
  }
  getObjectForDistance(distance2) {
    const levels = this.levels;
    if (levels.length > 0) {
      let i, l;
      for (i = 1, l = levels.length; i < l; i++) {
        if (distance2 < levels[i].distance) {
          break;
        }
      }
      return levels[i - 1].object;
    }
    return null;
  }
  raycast(raycaster, intersects2) {
    const levels = this.levels;
    if (levels.length > 0) {
      _v1$2.setFromMatrixPosition(this.matrixWorld);
      const distance2 = raycaster.ray.origin.distanceTo(_v1$2);
      this.getObjectForDistance(distance2).raycast(raycaster, intersects2);
    }
  }
  update(camera) {
    const levels = this.levels;
    if (levels.length > 1) {
      _v1$2.setFromMatrixPosition(camera.matrixWorld);
      _v2$1.setFromMatrixPosition(this.matrixWorld);
      const distance2 = _v1$2.distanceTo(_v2$1) / camera.zoom;
      levels[0].object.visible = true;
      let i, l;
      for (i = 1, l = levels.length; i < l; i++) {
        if (distance2 >= levels[i].distance) {
          levels[i - 1].object.visible = false;
          levels[i].object.visible = true;
        } else {
          break;
        }
      }
      this._currentLevel = i - 1;
      for (; i < l; i++) {
        levels[i].object.visible = false;
      }
    }
  }
  toJSON(meta) {
    const data = super.toJSON(meta);
    if (this.autoUpdate === false)
      data.object.autoUpdate = false;
    data.object.levels = [];
    const levels = this.levels;
    for (let i = 0, l = levels.length; i < l; i++) {
      const level = levels[i];
      data.object.levels.push({
        object: level.object.uuid,
        distance: level.distance
      });
    }
    return data;
  }
}
const _basePosition = /* @__PURE__ */ new Vector3();
const _skinIndex = /* @__PURE__ */ new Vector4();
const _skinWeight = /* @__PURE__ */ new Vector4();
const _vector$5 = /* @__PURE__ */ new Vector3();
const _matrix = /* @__PURE__ */ new Matrix4();
class SkinnedMesh extends Mesh {
  constructor(geometry, material) {
    super(geometry, material);
    this.type = "SkinnedMesh";
    this.bindMode = "attached";
    this.bindMatrix = new Matrix4();
    this.bindMatrixInverse = new Matrix4();
  }
  copy(source2) {
    super.copy(source2);
    this.bindMode = source2.bindMode;
    this.bindMatrix.copy(source2.bindMatrix);
    this.bindMatrixInverse.copy(source2.bindMatrixInverse);
    this.skeleton = source2.skeleton;
    return this;
  }
  bind(skeleton, bindMatrix) {
    this.skeleton = skeleton;
    if (bindMatrix === void 0) {
      this.updateMatrixWorld(true);
      this.skeleton.calculateInverses();
      bindMatrix = this.matrixWorld;
    }
    this.bindMatrix.copy(bindMatrix);
    this.bindMatrixInverse.copy(bindMatrix).invert();
  }
  pose() {
    this.skeleton.pose();
  }
  normalizeSkinWeights() {
    const vector = new Vector4();
    const skinWeight = this.geometry.attributes.skinWeight;
    for (let i = 0, l = skinWeight.count; i < l; i++) {
      vector.fromBufferAttribute(skinWeight, i);
      const scale2 = 1 / vector.manhattanLength();
      if (scale2 !== Infinity) {
        vector.multiplyScalar(scale2);
      } else {
        vector.set(1, 0, 0, 0);
      }
      skinWeight.setXYZW(i, vector.x, vector.y, vector.z, vector.w);
    }
  }
  updateMatrixWorld(force) {
    super.updateMatrixWorld(force);
    if (this.bindMode === "attached") {
      this.bindMatrixInverse.copy(this.matrixWorld).invert();
    } else if (this.bindMode === "detached") {
      this.bindMatrixInverse.copy(this.bindMatrix).invert();
    } else {
      console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode);
    }
  }
  boneTransform(index2, target) {
    const skeleton = this.skeleton;
    const geometry = this.geometry;
    _skinIndex.fromBufferAttribute(geometry.attributes.skinIndex, index2);
    _skinWeight.fromBufferAttribute(geometry.attributes.skinWeight, index2);
    _basePosition.copy(target).applyMatrix4(this.bindMatrix);
    target.set(0, 0, 0);
    for (let i = 0; i < 4; i++) {
      const weight = _skinWeight.getComponent(i);
      if (weight !== 0) {
        const boneIndex = _skinIndex.getComponent(i);
        _matrix.multiplyMatrices(skeleton.bones[boneIndex].matrixWorld, skeleton.boneInverses[boneIndex]);
        target.addScaledVector(_vector$5.copy(_basePosition).applyMatrix4(_matrix), weight);
      }
    }
    return target.applyMatrix4(this.bindMatrixInverse);
  }
}
SkinnedMesh.prototype.isSkinnedMesh = true;
class Bone extends Object3D {
  constructor() {
    super();
    this.type = "Bone";
  }
}
Bone.prototype.isBone = true;
class DataTexture extends Texture {
  constructor(data = null, width2 = 1, height2 = 1, format2, type, mapping, wrapS, wrapT, magFilter = NearestFilter, minFilter = NearestFilter, anisotropy, encoding) {
    super(null, mapping, wrapS, wrapT, magFilter, minFilter, format2, type, anisotropy, encoding);
    this.image = { data, width: width2, height: height2 };
    this.generateMipmaps = false;
    this.flipY = false;
    this.unpackAlignment = 1;
  }
}
DataTexture.prototype.isDataTexture = true;
const _offsetMatrix = /* @__PURE__ */ new Matrix4();
const _identityMatrix = /* @__PURE__ */ new Matrix4();
class Skeleton {
  constructor(bones = [], boneInverses = []) {
    this.uuid = generateUUID();
    this.bones = bones.slice(0);
    this.boneInverses = boneInverses;
    this.boneMatrices = null;
    this.boneTexture = null;
    this.boneTextureSize = 0;
    this.frame = -1;
    this.init();
  }
  init() {
    const bones = this.bones;
    const boneInverses = this.boneInverses;
    this.boneMatrices = new Float32Array(bones.length * 16);
    if (boneInverses.length === 0) {
      this.calculateInverses();
    } else {
      if (bones.length !== boneInverses.length) {
        console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones.");
        this.boneInverses = [];
        for (let i = 0, il = this.bones.length; i < il; i++) {
          this.boneInverses.push(new Matrix4());
        }
      }
    }
  }
  calculateInverses() {
    this.boneInverses.length = 0;
    for (let i = 0, il = this.bones.length; i < il; i++) {
      const inverse = new Matrix4();
      if (this.bones[i]) {
        inverse.copy(this.bones[i].matrixWorld).invert();
      }
      this.boneInverses.push(inverse);
    }
  }
  pose() {
    for (let i = 0, il = this.bones.length; i < il; i++) {
      const bone = this.bones[i];
      if (bone) {
        bone.matrixWorld.copy(this.boneInverses[i]).invert();
      }
    }
    for (let i = 0, il = this.bones.length; i < il; i++) {
      const bone = this.bones[i];
      if (bone) {
        if (bone.parent && bone.parent.isBone) {
          bone.matrix.copy(bone.parent.matrixWorld).invert();
          bone.matrix.multiply(bone.matrixWorld);
        } else {
          bone.matrix.copy(bone.matrixWorld);
        }
        bone.matrix.decompose(bone.position, bone.quaternion, bone.scale);
      }
    }
  }
  update() {
    const bones = this.bones;
    const boneInverses = this.boneInverses;
    const boneMatrices = this.boneMatrices;
    const boneTexture = this.boneTexture;
    for (let i = 0, il = bones.length; i < il; i++) {
      const matrix = bones[i] ? bones[i].matrixWorld : _identityMatrix;
      _offsetMatrix.multiplyMatrices(matrix, boneInverses[i]);
      _offsetMatrix.toArray(boneMatrices, i * 16);
    }
    if (boneTexture !== null) {
      boneTexture.needsUpdate = true;
    }
  }
  clone() {
    return new Skeleton(this.bones, this.boneInverses);
  }
  computeBoneTexture() {
    let size2 = Math.sqrt(this.bones.length * 4);
    size2 = ceilPowerOfTwo(size2);
    size2 = Math.max(size2, 4);
    const boneMatrices = new Float32Array(size2 * size2 * 4);
    boneMatrices.set(this.boneMatrices);
    const boneTexture = new DataTexture(boneMatrices, size2, size2, RGBAFormat, FloatType);
    boneTexture.needsUpdate = true;
    this.boneMatrices = boneMatrices;
    this.boneTexture = boneTexture;
    this.boneTextureSize = size2;
    return this;
  }
  getBoneByName(name) {
    for (let i = 0, il = this.bones.length; i < il; i++) {
      const bone = this.bones[i];
      if (bone.name === name) {
        return bone;
      }
    }
    return void 0;
  }
  dispose() {
    if (this.boneTexture !== null) {
      this.boneTexture.dispose();
      this.boneTexture = null;
    }
  }
  fromJSON(json, bones) {
    this.uuid = json.uuid;
    for (let i = 0, l = json.bones.length; i < l; i++) {
      const uuid2 = json.bones[i];
      let bone = bones[uuid2];
      if (bone === void 0) {
        console.warn("THREE.Skeleton: No bone found with UUID:", uuid2);
        bone = new Bone();
      }
      this.bones.push(bone);
      this.boneInverses.push(new Matrix4().fromArray(json.boneInverses[i]));
    }
    this.init();
    return this;
  }
  toJSON() {
    const data = {
      metadata: {
        version: 4.5,
        type: "Skeleton",
        generator: "Skeleton.toJSON"
      },
      bones: [],
      boneInverses: []
    };
    data.uuid = this.uuid;
    const bones = this.bones;
    const boneInverses = this.boneInverses;
    for (let i = 0, l = bones.length; i < l; i++) {
      const bone = bones[i];
      data.bones.push(bone.uuid);
      const boneInverse = boneInverses[i];
      data.boneInverses.push(boneInverse.toArray());
    }
    return data;
  }
}
class InstancedBufferAttribute extends BufferAttribute {
  constructor(array, itemSize, normalized, meshPerAttribute = 1) {
    if (typeof normalized === "number") {
      meshPerAttribute = normalized;
      normalized = false;
      console.error("THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.");
    }
    super(array, itemSize, normalized);
    this.meshPerAttribute = meshPerAttribute;
  }
  copy(source2) {
    super.copy(source2);
    this.meshPerAttribute = source2.meshPerAttribute;
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    data.meshPerAttribute = this.meshPerAttribute;
    data.isInstancedBufferAttribute = true;
    return data;
  }
}
InstancedBufferAttribute.prototype.isInstancedBufferAttribute = true;
const _instanceLocalMatrix = /* @__PURE__ */ new Matrix4();
const _instanceWorldMatrix = /* @__PURE__ */ new Matrix4();
const _instanceIntersects = [];
const _mesh = /* @__PURE__ */ new Mesh();
class InstancedMesh extends Mesh {
  constructor(geometry, material, count) {
    super(geometry, material);
    this.instanceMatrix = new InstancedBufferAttribute(new Float32Array(count * 16), 16);
    this.instanceColor = null;
    this.count = count;
    this.frustumCulled = false;
  }
  copy(source2) {
    super.copy(source2);
    this.instanceMatrix.copy(source2.instanceMatrix);
    if (source2.instanceColor !== null)
      this.instanceColor = source2.instanceColor.clone();
    this.count = source2.count;
    return this;
  }
  getColorAt(index2, color2) {
    color2.fromArray(this.instanceColor.array, index2 * 3);
  }
  getMatrixAt(index2, matrix) {
    matrix.fromArray(this.instanceMatrix.array, index2 * 16);
  }
  raycast(raycaster, intersects2) {
    const matrixWorld = this.matrixWorld;
    const raycastTimes = this.count;
    _mesh.geometry = this.geometry;
    _mesh.material = this.material;
    if (_mesh.material === void 0)
      return;
    for (let instanceId = 0; instanceId < raycastTimes; instanceId++) {
      this.getMatrixAt(instanceId, _instanceLocalMatrix);
      _instanceWorldMatrix.multiplyMatrices(matrixWorld, _instanceLocalMatrix);
      _mesh.matrixWorld = _instanceWorldMatrix;
      _mesh.raycast(raycaster, _instanceIntersects);
      for (let i = 0, l = _instanceIntersects.length; i < l; i++) {
        const intersect = _instanceIntersects[i];
        intersect.instanceId = instanceId;
        intersect.object = this;
        intersects2.push(intersect);
      }
      _instanceIntersects.length = 0;
    }
  }
  setColorAt(index2, color2) {
    if (this.instanceColor === null) {
      this.instanceColor = new InstancedBufferAttribute(new Float32Array(this.instanceMatrix.count * 3), 3);
    }
    color2.toArray(this.instanceColor.array, index2 * 3);
  }
  setMatrixAt(index2, matrix) {
    matrix.toArray(this.instanceMatrix.array, index2 * 16);
  }
  updateMorphTargets() {
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
InstancedMesh.prototype.isInstancedMesh = true;
class LineBasicMaterial extends Material {
  constructor(parameters) {
    super();
    this.type = "LineBasicMaterial";
    this.color = new Color(16777215);
    this.linewidth = 1;
    this.linecap = "round";
    this.linejoin = "round";
    this.setValues(parameters);
  }
  copy(source2) {
    super.copy(source2);
    this.color.copy(source2.color);
    this.linewidth = source2.linewidth;
    this.linecap = source2.linecap;
    this.linejoin = source2.linejoin;
    return this;
  }
}
LineBasicMaterial.prototype.isLineBasicMaterial = true;
const _start$1 = /* @__PURE__ */ new Vector3();
const _end$1 = /* @__PURE__ */ new Vector3();
const _inverseMatrix$1 = /* @__PURE__ */ new Matrix4();
const _ray$1 = /* @__PURE__ */ new Ray();
const _sphere$1 = /* @__PURE__ */ new Sphere();
class Line extends Object3D {
  constructor(geometry = new BufferGeometry(), material = new LineBasicMaterial()) {
    super();
    this.type = "Line";
    this.geometry = geometry;
    this.material = material;
    this.updateMorphTargets();
  }
  copy(source2) {
    super.copy(source2);
    this.material = source2.material;
    this.geometry = source2.geometry;
    return this;
  }
  computeLineDistances() {
    const geometry = this.geometry;
    if (geometry.isBufferGeometry) {
      if (geometry.index === null) {
        const positionAttribute = geometry.attributes.position;
        const lineDistances = [0];
        for (let i = 1, l = positionAttribute.count; i < l; i++) {
          _start$1.fromBufferAttribute(positionAttribute, i - 1);
          _end$1.fromBufferAttribute(positionAttribute, i);
          lineDistances[i] = lineDistances[i - 1];
          lineDistances[i] += _start$1.distanceTo(_end$1);
        }
        geometry.setAttribute("lineDistance", new Float32BufferAttribute(lineDistances, 1));
      } else {
        console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
      }
    } else if (geometry.isGeometry) {
      console.error("THREE.Line.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
    }
    return this;
  }
  raycast(raycaster, intersects2) {
    const geometry = this.geometry;
    const matrixWorld = this.matrixWorld;
    const threshold = raycaster.params.Line.threshold;
    const drawRange = geometry.drawRange;
    if (geometry.boundingSphere === null)
      geometry.computeBoundingSphere();
    _sphere$1.copy(geometry.boundingSphere);
    _sphere$1.applyMatrix4(matrixWorld);
    _sphere$1.radius += threshold;
    if (raycaster.ray.intersectsSphere(_sphere$1) === false)
      return;
    _inverseMatrix$1.copy(matrixWorld).invert();
    _ray$1.copy(raycaster.ray).applyMatrix4(_inverseMatrix$1);
    const localThreshold = threshold / ((this.scale.x + this.scale.y + this.scale.z) / 3);
    const localThresholdSq = localThreshold * localThreshold;
    const vStart = new Vector3();
    const vEnd = new Vector3();
    const interSegment = new Vector3();
    const interRay = new Vector3();
    const step2 = this.isLineSegments ? 2 : 1;
    if (geometry.isBufferGeometry) {
      const index2 = geometry.index;
      const attributes = geometry.attributes;
      const positionAttribute = attributes.position;
      if (index2 !== null) {
        const start2 = Math.max(0, drawRange.start);
        const end2 = Math.min(index2.count, drawRange.start + drawRange.count);
        for (let i = start2, l = end2 - 1; i < l; i += step2) {
          const a = index2.getX(i);
          const b = index2.getX(i + 1);
          vStart.fromBufferAttribute(positionAttribute, a);
          vEnd.fromBufferAttribute(positionAttribute, b);
          const distSq = _ray$1.distanceSqToSegment(vStart, vEnd, interRay, interSegment);
          if (distSq > localThresholdSq)
            continue;
          interRay.applyMatrix4(this.matrixWorld);
          const distance2 = raycaster.ray.origin.distanceTo(interRay);
          if (distance2 < raycaster.near || distance2 > raycaster.far)
            continue;
          intersects2.push({
            distance: distance2,
            point: interSegment.clone().applyMatrix4(this.matrixWorld),
            index: i,
            face: null,
            faceIndex: null,
            object: this
          });
        }
      } else {
        const start2 = Math.max(0, drawRange.start);
        const end2 = Math.min(positionAttribute.count, drawRange.start + drawRange.count);
        for (let i = start2, l = end2 - 1; i < l; i += step2) {
          vStart.fromBufferAttribute(positionAttribute, i);
          vEnd.fromBufferAttribute(positionAttribute, i + 1);
          const distSq = _ray$1.distanceSqToSegment(vStart, vEnd, interRay, interSegment);
          if (distSq > localThresholdSq)
            continue;
          interRay.applyMatrix4(this.matrixWorld);
          const distance2 = raycaster.ray.origin.distanceTo(interRay);
          if (distance2 < raycaster.near || distance2 > raycaster.far)
            continue;
          intersects2.push({
            distance: distance2,
            point: interSegment.clone().applyMatrix4(this.matrixWorld),
            index: i,
            face: null,
            faceIndex: null,
            object: this
          });
        }
      }
    } else if (geometry.isGeometry) {
      console.error("THREE.Line.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
    }
  }
  updateMorphTargets() {
    const geometry = this.geometry;
    if (geometry.isBufferGeometry) {
      const morphAttributes = geometry.morphAttributes;
      const keys2 = Object.keys(morphAttributes);
      if (keys2.length > 0) {
        const morphAttribute = morphAttributes[keys2[0]];
        if (morphAttribute !== void 0) {
          this.morphTargetInfluences = [];
          this.morphTargetDictionary = {};
          for (let m = 0, ml = morphAttribute.length; m < ml; m++) {
            const name = morphAttribute[m].name || String(m);
            this.morphTargetInfluences.push(0);
            this.morphTargetDictionary[name] = m;
          }
        }
      }
    } else {
      const morphTargets = geometry.morphTargets;
      if (morphTargets !== void 0 && morphTargets.length > 0) {
        console.error("THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.");
      }
    }
  }
}
Line.prototype.isLine = true;
const _start = /* @__PURE__ */ new Vector3();
const _end = /* @__PURE__ */ new Vector3();
class LineSegments extends Line {
  constructor(geometry, material) {
    super(geometry, material);
    this.type = "LineSegments";
  }
  computeLineDistances() {
    const geometry = this.geometry;
    if (geometry.isBufferGeometry) {
      if (geometry.index === null) {
        const positionAttribute = geometry.attributes.position;
        const lineDistances = [];
        for (let i = 0, l = positionAttribute.count; i < l; i += 2) {
          _start.fromBufferAttribute(positionAttribute, i);
          _end.fromBufferAttribute(positionAttribute, i + 1);
          lineDistances[i] = i === 0 ? 0 : lineDistances[i - 1];
          lineDistances[i + 1] = lineDistances[i] + _start.distanceTo(_end);
        }
        geometry.setAttribute("lineDistance", new Float32BufferAttribute(lineDistances, 1));
      } else {
        console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
      }
    } else if (geometry.isGeometry) {
      console.error("THREE.LineSegments.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
    }
    return this;
  }
}
LineSegments.prototype.isLineSegments = true;
class LineLoop extends Line {
  constructor(geometry, material) {
    super(geometry, material);
    this.type = "LineLoop";
  }
}
LineLoop.prototype.isLineLoop = true;
class PointsMaterial extends Material {
  constructor(parameters) {
    super();
    this.type = "PointsMaterial";
    this.color = new Color(16777215);
    this.map = null;
    this.alphaMap = null;
    this.size = 1;
    this.sizeAttenuation = true;
    this.setValues(parameters);
  }
  copy(source2) {
    super.copy(source2);
    this.color.copy(source2.color);
    this.map = source2.map;
    this.alphaMap = source2.alphaMap;
    this.size = source2.size;
    this.sizeAttenuation = source2.sizeAttenuation;
    return this;
  }
}
PointsMaterial.prototype.isPointsMaterial = true;
const _inverseMatrix = /* @__PURE__ */ new Matrix4();
const _ray = /* @__PURE__ */ new Ray();
const _sphere = /* @__PURE__ */ new Sphere();
const _position$2 = /* @__PURE__ */ new Vector3();
class Points extends Object3D {
  constructor(geometry = new BufferGeometry(), material = new PointsMaterial()) {
    super();
    this.type = "Points";
    this.geometry = geometry;
    this.material = material;
    this.updateMorphTargets();
  }
  copy(source2) {
    super.copy(source2);
    this.material = source2.material;
    this.geometry = source2.geometry;
    return this;
  }
  raycast(raycaster, intersects2) {
    const geometry = this.geometry;
    const matrixWorld = this.matrixWorld;
    const threshold = raycaster.params.Points.threshold;
    const drawRange = geometry.drawRange;
    if (geometry.boundingSphere === null)
      geometry.computeBoundingSphere();
    _sphere.copy(geometry.boundingSphere);
    _sphere.applyMatrix4(matrixWorld);
    _sphere.radius += threshold;
    if (raycaster.ray.intersectsSphere(_sphere) === false)
      return;
    _inverseMatrix.copy(matrixWorld).invert();
    _ray.copy(raycaster.ray).applyMatrix4(_inverseMatrix);
    const localThreshold = threshold / ((this.scale.x + this.scale.y + this.scale.z) / 3);
    const localThresholdSq = localThreshold * localThreshold;
    if (geometry.isBufferGeometry) {
      const index2 = geometry.index;
      const attributes = geometry.attributes;
      const positionAttribute = attributes.position;
      if (index2 !== null) {
        const start2 = Math.max(0, drawRange.start);
        const end2 = Math.min(index2.count, drawRange.start + drawRange.count);
        for (let i = start2, il = end2; i < il; i++) {
          const a = index2.getX(i);
          _position$2.fromBufferAttribute(positionAttribute, a);
          testPoint(_position$2, a, localThresholdSq, matrixWorld, raycaster, intersects2, this);
        }
      } else {
        const start2 = Math.max(0, drawRange.start);
        const end2 = Math.min(positionAttribute.count, drawRange.start + drawRange.count);
        for (let i = start2, l = end2; i < l; i++) {
          _position$2.fromBufferAttribute(positionAttribute, i);
          testPoint(_position$2, i, localThresholdSq, matrixWorld, raycaster, intersects2, this);
        }
      }
    } else {
      console.error("THREE.Points.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
    }
  }
  updateMorphTargets() {
    const geometry = this.geometry;
    if (geometry.isBufferGeometry) {
      const morphAttributes = geometry.morphAttributes;
      const keys2 = Object.keys(morphAttributes);
      if (keys2.length > 0) {
        const morphAttribute = morphAttributes[keys2[0]];
        if (morphAttribute !== void 0) {
          this.morphTargetInfluences = [];
          this.morphTargetDictionary = {};
          for (let m = 0, ml = morphAttribute.length; m < ml; m++) {
            const name = morphAttribute[m].name || String(m);
            this.morphTargetInfluences.push(0);
            this.morphTargetDictionary[name] = m;
          }
        }
      }
    } else {
      const morphTargets = geometry.morphTargets;
      if (morphTargets !== void 0 && morphTargets.length > 0) {
        console.error("THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.");
      }
    }
  }
}
Points.prototype.isPoints = true;
function testPoint(point2, index2, localThresholdSq, matrixWorld, raycaster, intersects2, object) {
  const rayPointDistanceSq = _ray.distanceSqToPoint(point2);
  if (rayPointDistanceSq < localThresholdSq) {
    const intersectPoint = new Vector3();
    _ray.closestPointToPoint(point2, intersectPoint);
    intersectPoint.applyMatrix4(matrixWorld);
    const distance2 = raycaster.ray.origin.distanceTo(intersectPoint);
    if (distance2 < raycaster.near || distance2 > raycaster.far)
      return;
    intersects2.push({
      distance: distance2,
      distanceToRay: Math.sqrt(rayPointDistanceSq),
      point: intersectPoint,
      index: index2,
      face: null,
      object
    });
  }
}
class VideoTexture extends Texture {
  constructor(video2, mapping, wrapS, wrapT, magFilter, minFilter, format2, type, anisotropy) {
    super(video2, mapping, wrapS, wrapT, magFilter, minFilter, format2, type, anisotropy);
    this.minFilter = minFilter !== void 0 ? minFilter : LinearFilter;
    this.magFilter = magFilter !== void 0 ? magFilter : LinearFilter;
    this.generateMipmaps = false;
    const scope = this;
    function updateVideo2() {
      scope.needsUpdate = true;
      video2.requestVideoFrameCallback(updateVideo2);
    }
    if ("requestVideoFrameCallback" in video2) {
      video2.requestVideoFrameCallback(updateVideo2);
    }
  }
  clone() {
    return new this.constructor(this.image).copy(this);
  }
  update() {
    const video2 = this.image;
    const hasVideoFrameCallback = "requestVideoFrameCallback" in video2;
    if (hasVideoFrameCallback === false && video2.readyState >= video2.HAVE_CURRENT_DATA) {
      this.needsUpdate = true;
    }
  }
}
VideoTexture.prototype.isVideoTexture = true;
class FramebufferTexture extends Texture {
  constructor(width2, height2, format2) {
    super({ width: width2, height: height2 });
    this.format = format2;
    this.magFilter = NearestFilter;
    this.minFilter = NearestFilter;
    this.generateMipmaps = false;
    this.needsUpdate = true;
  }
}
FramebufferTexture.prototype.isFramebufferTexture = true;
class CompressedTexture extends Texture {
  constructor(mipmaps, width2, height2, format2, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding) {
    super(null, mapping, wrapS, wrapT, magFilter, minFilter, format2, type, anisotropy, encoding);
    this.image = { width: width2, height: height2 };
    this.mipmaps = mipmaps;
    this.flipY = false;
    this.generateMipmaps = false;
  }
}
CompressedTexture.prototype.isCompressedTexture = true;
class CanvasTexture extends Texture {
  constructor(canvas, mapping, wrapS, wrapT, magFilter, minFilter, format2, type, anisotropy) {
    super(canvas, mapping, wrapS, wrapT, magFilter, minFilter, format2, type, anisotropy);
    this.needsUpdate = true;
  }
}
CanvasTexture.prototype.isCanvasTexture = true;
class Curve {
  constructor() {
    this.type = "Curve";
    this.arcLengthDivisions = 200;
  }
  getPoint() {
    console.warn("THREE.Curve: .getPoint() not implemented.");
    return null;
  }
  getPointAt(u, optionalTarget) {
    const t = this.getUtoTmapping(u);
    return this.getPoint(t, optionalTarget);
  }
  getPoints(divisions = 5) {
    const points = [];
    for (let d = 0; d <= divisions; d++) {
      points.push(this.getPoint(d / divisions));
    }
    return points;
  }
  getSpacedPoints(divisions = 5) {
    const points = [];
    for (let d = 0; d <= divisions; d++) {
      points.push(this.getPointAt(d / divisions));
    }
    return points;
  }
  getLength() {
    const lengths = this.getLengths();
    return lengths[lengths.length - 1];
  }
  getLengths(divisions = this.arcLengthDivisions) {
    if (this.cacheArcLengths && this.cacheArcLengths.length === divisions + 1 && !this.needsUpdate) {
      return this.cacheArcLengths;
    }
    this.needsUpdate = false;
    const cache = [];
    let current, last = this.getPoint(0);
    let sum = 0;
    cache.push(0);
    for (let p = 1; p <= divisions; p++) {
      current = this.getPoint(p / divisions);
      sum += current.distanceTo(last);
      cache.push(sum);
      last = current;
    }
    this.cacheArcLengths = cache;
    return cache;
  }
  updateArcLengths() {
    this.needsUpdate = true;
    this.getLengths();
  }
  getUtoTmapping(u, distance2) {
    const arcLengths = this.getLengths();
    let i = 0;
    const il = arcLengths.length;
    let targetArcLength;
    if (distance2) {
      targetArcLength = distance2;
    } else {
      targetArcLength = u * arcLengths[il - 1];
    }
    let low = 0, high = il - 1, comparison;
    while (low <= high) {
      i = Math.floor(low + (high - low) / 2);
      comparison = arcLengths[i] - targetArcLength;
      if (comparison < 0) {
        low = i + 1;
      } else if (comparison > 0) {
        high = i - 1;
      } else {
        high = i;
        break;
      }
    }
    i = high;
    if (arcLengths[i] === targetArcLength) {
      return i / (il - 1);
    }
    const lengthBefore = arcLengths[i];
    const lengthAfter = arcLengths[i + 1];
    const segmentLength = lengthAfter - lengthBefore;
    const segmentFraction = (targetArcLength - lengthBefore) / segmentLength;
    const t = (i + segmentFraction) / (il - 1);
    return t;
  }
  getTangent(t, optionalTarget) {
    const delta = 1e-4;
    let t1 = t - delta;
    let t2 = t + delta;
    if (t1 < 0)
      t1 = 0;
    if (t2 > 1)
      t2 = 1;
    const pt1 = this.getPoint(t1);
    const pt2 = this.getPoint(t2);
    const tangent = optionalTarget || (pt1.isVector2 ? new Vector2() : new Vector3());
    tangent.copy(pt2).sub(pt1).normalize();
    return tangent;
  }
  getTangentAt(u, optionalTarget) {
    const t = this.getUtoTmapping(u);
    return this.getTangent(t, optionalTarget);
  }
  computeFrenetFrames(segments, closed) {
    const normal = new Vector3();
    const tangents = [];
    const normals = [];
    const binormals = [];
    const vec = new Vector3();
    const mat = new Matrix4();
    for (let i = 0; i <= segments; i++) {
      const u = i / segments;
      tangents[i] = this.getTangentAt(u, new Vector3());
    }
    normals[0] = new Vector3();
    binormals[0] = new Vector3();
    let min = Number.MAX_VALUE;
    const tx = Math.abs(tangents[0].x);
    const ty = Math.abs(tangents[0].y);
    const tz = Math.abs(tangents[0].z);
    if (tx <= min) {
      min = tx;
      normal.set(1, 0, 0);
    }
    if (ty <= min) {
      min = ty;
      normal.set(0, 1, 0);
    }
    if (tz <= min) {
      normal.set(0, 0, 1);
    }
    vec.crossVectors(tangents[0], normal).normalize();
    normals[0].crossVectors(tangents[0], vec);
    binormals[0].crossVectors(tangents[0], normals[0]);
    for (let i = 1; i <= segments; i++) {
      normals[i] = normals[i - 1].clone();
      binormals[i] = binormals[i - 1].clone();
      vec.crossVectors(tangents[i - 1], tangents[i]);
      if (vec.length() > Number.EPSILON) {
        vec.normalize();
        const theta = Math.acos(clamp(tangents[i - 1].dot(tangents[i]), -1, 1));
        normals[i].applyMatrix4(mat.makeRotationAxis(vec, theta));
      }
      binormals[i].crossVectors(tangents[i], normals[i]);
    }
    if (closed === true) {
      let theta = Math.acos(clamp(normals[0].dot(normals[segments]), -1, 1));
      theta /= segments;
      if (tangents[0].dot(vec.crossVectors(normals[0], normals[segments])) > 0) {
        theta = -theta;
      }
      for (let i = 1; i <= segments; i++) {
        normals[i].applyMatrix4(mat.makeRotationAxis(tangents[i], theta * i));
        binormals[i].crossVectors(tangents[i], normals[i]);
      }
    }
    return {
      tangents,
      normals,
      binormals
    };
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(source2) {
    this.arcLengthDivisions = source2.arcLengthDivisions;
    return this;
  }
  toJSON() {
    const data = {
      metadata: {
        version: 4.5,
        type: "Curve",
        generator: "Curve.toJSON"
      }
    };
    data.arcLengthDivisions = this.arcLengthDivisions;
    data.type = this.type;
    return data;
  }
  fromJSON(json) {
    this.arcLengthDivisions = json.arcLengthDivisions;
    return this;
  }
}
class EllipseCurve extends Curve {
  constructor(aX = 0, aY = 0, xRadius = 1, yRadius = 1, aStartAngle = 0, aEndAngle = Math.PI * 2, aClockwise = false, aRotation = 0) {
    super();
    this.type = "EllipseCurve";
    this.aX = aX;
    this.aY = aY;
    this.xRadius = xRadius;
    this.yRadius = yRadius;
    this.aStartAngle = aStartAngle;
    this.aEndAngle = aEndAngle;
    this.aClockwise = aClockwise;
    this.aRotation = aRotation;
  }
  getPoint(t, optionalTarget) {
    const point2 = optionalTarget || new Vector2();
    const twoPi = Math.PI * 2;
    let deltaAngle = this.aEndAngle - this.aStartAngle;
    const samePoints = Math.abs(deltaAngle) < Number.EPSILON;
    while (deltaAngle < 0)
      deltaAngle += twoPi;
    while (deltaAngle > twoPi)
      deltaAngle -= twoPi;
    if (deltaAngle < Number.EPSILON) {
      if (samePoints) {
        deltaAngle = 0;
      } else {
        deltaAngle = twoPi;
      }
    }
    if (this.aClockwise === true && !samePoints) {
      if (deltaAngle === twoPi) {
        deltaAngle = -twoPi;
      } else {
        deltaAngle = deltaAngle - twoPi;
      }
    }
    const angle = this.aStartAngle + t * deltaAngle;
    let x = this.aX + this.xRadius * Math.cos(angle);
    let y = this.aY + this.yRadius * Math.sin(angle);
    if (this.aRotation !== 0) {
      const cos = Math.cos(this.aRotation);
      const sin = Math.sin(this.aRotation);
      const tx = x - this.aX;
      const ty = y - this.aY;
      x = tx * cos - ty * sin + this.aX;
      y = tx * sin + ty * cos + this.aY;
    }
    return point2.set(x, y);
  }
  copy(source2) {
    super.copy(source2);
    this.aX = source2.aX;
    this.aY = source2.aY;
    this.xRadius = source2.xRadius;
    this.yRadius = source2.yRadius;
    this.aStartAngle = source2.aStartAngle;
    this.aEndAngle = source2.aEndAngle;
    this.aClockwise = source2.aClockwise;
    this.aRotation = source2.aRotation;
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    data.aX = this.aX;
    data.aY = this.aY;
    data.xRadius = this.xRadius;
    data.yRadius = this.yRadius;
    data.aStartAngle = this.aStartAngle;
    data.aEndAngle = this.aEndAngle;
    data.aClockwise = this.aClockwise;
    data.aRotation = this.aRotation;
    return data;
  }
  fromJSON(json) {
    super.fromJSON(json);
    this.aX = json.aX;
    this.aY = json.aY;
    this.xRadius = json.xRadius;
    this.yRadius = json.yRadius;
    this.aStartAngle = json.aStartAngle;
    this.aEndAngle = json.aEndAngle;
    this.aClockwise = json.aClockwise;
    this.aRotation = json.aRotation;
    return this;
  }
}
EllipseCurve.prototype.isEllipseCurve = true;
class ArcCurve extends EllipseCurve {
  constructor(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
    super(aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);
    this.type = "ArcCurve";
  }
}
ArcCurve.prototype.isArcCurve = true;
function CubicPoly() {
  let c0 = 0, c1 = 0, c2 = 0, c3 = 0;
  function init(x0, x1, t0, t1) {
    c0 = x0;
    c1 = t0;
    c2 = -3 * x0 + 3 * x1 - 2 * t0 - t1;
    c3 = 2 * x0 - 2 * x1 + t0 + t1;
  }
  return {
    initCatmullRom: function(x0, x1, x2, x3, tension) {
      init(x1, x2, tension * (x2 - x0), tension * (x3 - x1));
    },
    initNonuniformCatmullRom: function(x0, x1, x2, x3, dt0, dt1, dt2) {
      let t1 = (x1 - x0) / dt0 - (x2 - x0) / (dt0 + dt1) + (x2 - x1) / dt1;
      let t2 = (x2 - x1) / dt1 - (x3 - x1) / (dt1 + dt2) + (x3 - x2) / dt2;
      t1 *= dt1;
      t2 *= dt1;
      init(x1, x2, t1, t2);
    },
    calc: function(t) {
      const t2 = t * t;
      const t3 = t2 * t;
      return c0 + c1 * t + c2 * t2 + c3 * t3;
    }
  };
}
const tmp = new Vector3();
const px = new CubicPoly(), py = new CubicPoly(), pz = new CubicPoly();
class CatmullRomCurve3 extends Curve {
  constructor(points = [], closed = false, curveType = "centripetal", tension = 0.5) {
    super();
    this.type = "CatmullRomCurve3";
    this.points = points;
    this.closed = closed;
    this.curveType = curveType;
    this.tension = tension;
  }
  getPoint(t, optionalTarget = new Vector3()) {
    const point2 = optionalTarget;
    const points = this.points;
    const l = points.length;
    const p = (l - (this.closed ? 0 : 1)) * t;
    let intPoint = Math.floor(p);
    let weight = p - intPoint;
    if (this.closed) {
      intPoint += intPoint > 0 ? 0 : (Math.floor(Math.abs(intPoint) / l) + 1) * l;
    } else if (weight === 0 && intPoint === l - 1) {
      intPoint = l - 2;
      weight = 1;
    }
    let p0, p3;
    if (this.closed || intPoint > 0) {
      p0 = points[(intPoint - 1) % l];
    } else {
      tmp.subVectors(points[0], points[1]).add(points[0]);
      p0 = tmp;
    }
    const p1 = points[intPoint % l];
    const p2 = points[(intPoint + 1) % l];
    if (this.closed || intPoint + 2 < l) {
      p3 = points[(intPoint + 2) % l];
    } else {
      tmp.subVectors(points[l - 1], points[l - 2]).add(points[l - 1]);
      p3 = tmp;
    }
    if (this.curveType === "centripetal" || this.curveType === "chordal") {
      const pow = this.curveType === "chordal" ? 0.5 : 0.25;
      let dt0 = Math.pow(p0.distanceToSquared(p1), pow);
      let dt1 = Math.pow(p1.distanceToSquared(p2), pow);
      let dt2 = Math.pow(p2.distanceToSquared(p3), pow);
      if (dt1 < 1e-4)
        dt1 = 1;
      if (dt0 < 1e-4)
        dt0 = dt1;
      if (dt2 < 1e-4)
        dt2 = dt1;
      px.initNonuniformCatmullRom(p0.x, p1.x, p2.x, p3.x, dt0, dt1, dt2);
      py.initNonuniformCatmullRom(p0.y, p1.y, p2.y, p3.y, dt0, dt1, dt2);
      pz.initNonuniformCatmullRom(p0.z, p1.z, p2.z, p3.z, dt0, dt1, dt2);
    } else if (this.curveType === "catmullrom") {
      px.initCatmullRom(p0.x, p1.x, p2.x, p3.x, this.tension);
      py.initCatmullRom(p0.y, p1.y, p2.y, p3.y, this.tension);
      pz.initCatmullRom(p0.z, p1.z, p2.z, p3.z, this.tension);
    }
    point2.set(px.calc(weight), py.calc(weight), pz.calc(weight));
    return point2;
  }
  copy(source2) {
    super.copy(source2);
    this.points = [];
    for (let i = 0, l = source2.points.length; i < l; i++) {
      const point2 = source2.points[i];
      this.points.push(point2.clone());
    }
    this.closed = source2.closed;
    this.curveType = source2.curveType;
    this.tension = source2.tension;
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    data.points = [];
    for (let i = 0, l = this.points.length; i < l; i++) {
      const point2 = this.points[i];
      data.points.push(point2.toArray());
    }
    data.closed = this.closed;
    data.curveType = this.curveType;
    data.tension = this.tension;
    return data;
  }
  fromJSON(json) {
    super.fromJSON(json);
    this.points = [];
    for (let i = 0, l = json.points.length; i < l; i++) {
      const point2 = json.points[i];
      this.points.push(new Vector3().fromArray(point2));
    }
    this.closed = json.closed;
    this.curveType = json.curveType;
    this.tension = json.tension;
    return this;
  }
}
CatmullRomCurve3.prototype.isCatmullRomCurve3 = true;
function CatmullRom(t, p0, p1, p2, p3) {
  const v0 = (p2 - p0) * 0.5;
  const v1 = (p3 - p1) * 0.5;
  const t2 = t * t;
  const t3 = t * t2;
  return (2 * p1 - 2 * p2 + v0 + v1) * t3 + (-3 * p1 + 3 * p2 - 2 * v0 - v1) * t2 + v0 * t + p1;
}
function QuadraticBezierP0(t, p) {
  const k = 1 - t;
  return k * k * p;
}
function QuadraticBezierP1(t, p) {
  return 2 * (1 - t) * t * p;
}
function QuadraticBezierP2(t, p) {
  return t * t * p;
}
function QuadraticBezier(t, p0, p1, p2) {
  return QuadraticBezierP0(t, p0) + QuadraticBezierP1(t, p1) + QuadraticBezierP2(t, p2);
}
function CubicBezierP0(t, p) {
  const k = 1 - t;
  return k * k * k * p;
}
function CubicBezierP1(t, p) {
  const k = 1 - t;
  return 3 * k * k * t * p;
}
function CubicBezierP2(t, p) {
  return 3 * (1 - t) * t * t * p;
}
function CubicBezierP3(t, p) {
  return t * t * t * p;
}
function CubicBezier(t, p0, p1, p2, p3) {
  return CubicBezierP0(t, p0) + CubicBezierP1(t, p1) + CubicBezierP2(t, p2) + CubicBezierP3(t, p3);
}
class CubicBezierCurve extends Curve {
  constructor(v0 = new Vector2(), v1 = new Vector2(), v2 = new Vector2(), v3 = new Vector2()) {
    super();
    this.type = "CubicBezierCurve";
    this.v0 = v0;
    this.v1 = v1;
    this.v2 = v2;
    this.v3 = v3;
  }
  getPoint(t, optionalTarget = new Vector2()) {
    const point2 = optionalTarget;
    const v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;
    point2.set(CubicBezier(t, v0.x, v1.x, v2.x, v3.x), CubicBezier(t, v0.y, v1.y, v2.y, v3.y));
    return point2;
  }
  copy(source2) {
    super.copy(source2);
    this.v0.copy(source2.v0);
    this.v1.copy(source2.v1);
    this.v2.copy(source2.v2);
    this.v3.copy(source2.v3);
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    data.v0 = this.v0.toArray();
    data.v1 = this.v1.toArray();
    data.v2 = this.v2.toArray();
    data.v3 = this.v3.toArray();
    return data;
  }
  fromJSON(json) {
    super.fromJSON(json);
    this.v0.fromArray(json.v0);
    this.v1.fromArray(json.v1);
    this.v2.fromArray(json.v2);
    this.v3.fromArray(json.v3);
    return this;
  }
}
CubicBezierCurve.prototype.isCubicBezierCurve = true;
class CubicBezierCurve3 extends Curve {
  constructor(v0 = new Vector3(), v1 = new Vector3(), v2 = new Vector3(), v3 = new Vector3()) {
    super();
    this.type = "CubicBezierCurve3";
    this.v0 = v0;
    this.v1 = v1;
    this.v2 = v2;
    this.v3 = v3;
  }
  getPoint(t, optionalTarget = new Vector3()) {
    const point2 = optionalTarget;
    const v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;
    point2.set(CubicBezier(t, v0.x, v1.x, v2.x, v3.x), CubicBezier(t, v0.y, v1.y, v2.y, v3.y), CubicBezier(t, v0.z, v1.z, v2.z, v3.z));
    return point2;
  }
  copy(source2) {
    super.copy(source2);
    this.v0.copy(source2.v0);
    this.v1.copy(source2.v1);
    this.v2.copy(source2.v2);
    this.v3.copy(source2.v3);
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    data.v0 = this.v0.toArray();
    data.v1 = this.v1.toArray();
    data.v2 = this.v2.toArray();
    data.v3 = this.v3.toArray();
    return data;
  }
  fromJSON(json) {
    super.fromJSON(json);
    this.v0.fromArray(json.v0);
    this.v1.fromArray(json.v1);
    this.v2.fromArray(json.v2);
    this.v3.fromArray(json.v3);
    return this;
  }
}
CubicBezierCurve3.prototype.isCubicBezierCurve3 = true;
class LineCurve extends Curve {
  constructor(v1 = new Vector2(), v2 = new Vector2()) {
    super();
    this.type = "LineCurve";
    this.v1 = v1;
    this.v2 = v2;
  }
  getPoint(t, optionalTarget = new Vector2()) {
    const point2 = optionalTarget;
    if (t === 1) {
      point2.copy(this.v2);
    } else {
      point2.copy(this.v2).sub(this.v1);
      point2.multiplyScalar(t).add(this.v1);
    }
    return point2;
  }
  getPointAt(u, optionalTarget) {
    return this.getPoint(u, optionalTarget);
  }
  getTangent(t, optionalTarget) {
    const tangent = optionalTarget || new Vector2();
    tangent.copy(this.v2).sub(this.v1).normalize();
    return tangent;
  }
  copy(source2) {
    super.copy(source2);
    this.v1.copy(source2.v1);
    this.v2.copy(source2.v2);
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    data.v1 = this.v1.toArray();
    data.v2 = this.v2.toArray();
    return data;
  }
  fromJSON(json) {
    super.fromJSON(json);
    this.v1.fromArray(json.v1);
    this.v2.fromArray(json.v2);
    return this;
  }
}
LineCurve.prototype.isLineCurve = true;
class LineCurve3 extends Curve {
  constructor(v1 = new Vector3(), v2 = new Vector3()) {
    super();
    this.type = "LineCurve3";
    this.isLineCurve3 = true;
    this.v1 = v1;
    this.v2 = v2;
  }
  getPoint(t, optionalTarget = new Vector3()) {
    const point2 = optionalTarget;
    if (t === 1) {
      point2.copy(this.v2);
    } else {
      point2.copy(this.v2).sub(this.v1);
      point2.multiplyScalar(t).add(this.v1);
    }
    return point2;
  }
  getPointAt(u, optionalTarget) {
    return this.getPoint(u, optionalTarget);
  }
  copy(source2) {
    super.copy(source2);
    this.v1.copy(source2.v1);
    this.v2.copy(source2.v2);
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    data.v1 = this.v1.toArray();
    data.v2 = this.v2.toArray();
    return data;
  }
  fromJSON(json) {
    super.fromJSON(json);
    this.v1.fromArray(json.v1);
    this.v2.fromArray(json.v2);
    return this;
  }
}
class QuadraticBezierCurve extends Curve {
  constructor(v0 = new Vector2(), v1 = new Vector2(), v2 = new Vector2()) {
    super();
    this.type = "QuadraticBezierCurve";
    this.v0 = v0;
    this.v1 = v1;
    this.v2 = v2;
  }
  getPoint(t, optionalTarget = new Vector2()) {
    const point2 = optionalTarget;
    const v0 = this.v0, v1 = this.v1, v2 = this.v2;
    point2.set(QuadraticBezier(t, v0.x, v1.x, v2.x), QuadraticBezier(t, v0.y, v1.y, v2.y));
    return point2;
  }
  copy(source2) {
    super.copy(source2);
    this.v0.copy(source2.v0);
    this.v1.copy(source2.v1);
    this.v2.copy(source2.v2);
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    data.v0 = this.v0.toArray();
    data.v1 = this.v1.toArray();
    data.v2 = this.v2.toArray();
    return data;
  }
  fromJSON(json) {
    super.fromJSON(json);
    this.v0.fromArray(json.v0);
    this.v1.fromArray(json.v1);
    this.v2.fromArray(json.v2);
    return this;
  }
}
QuadraticBezierCurve.prototype.isQuadraticBezierCurve = true;
class QuadraticBezierCurve3 extends Curve {
  constructor(v0 = new Vector3(), v1 = new Vector3(), v2 = new Vector3()) {
    super();
    this.type = "QuadraticBezierCurve3";
    this.v0 = v0;
    this.v1 = v1;
    this.v2 = v2;
  }
  getPoint(t, optionalTarget = new Vector3()) {
    const point2 = optionalTarget;
    const v0 = this.v0, v1 = this.v1, v2 = this.v2;
    point2.set(QuadraticBezier(t, v0.x, v1.x, v2.x), QuadraticBezier(t, v0.y, v1.y, v2.y), QuadraticBezier(t, v0.z, v1.z, v2.z));
    return point2;
  }
  copy(source2) {
    super.copy(source2);
    this.v0.copy(source2.v0);
    this.v1.copy(source2.v1);
    this.v2.copy(source2.v2);
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    data.v0 = this.v0.toArray();
    data.v1 = this.v1.toArray();
    data.v2 = this.v2.toArray();
    return data;
  }
  fromJSON(json) {
    super.fromJSON(json);
    this.v0.fromArray(json.v0);
    this.v1.fromArray(json.v1);
    this.v2.fromArray(json.v2);
    return this;
  }
}
QuadraticBezierCurve3.prototype.isQuadraticBezierCurve3 = true;
class SplineCurve extends Curve {
  constructor(points = []) {
    super();
    this.type = "SplineCurve";
    this.points = points;
  }
  getPoint(t, optionalTarget = new Vector2()) {
    const point2 = optionalTarget;
    const points = this.points;
    const p = (points.length - 1) * t;
    const intPoint = Math.floor(p);
    const weight = p - intPoint;
    const p0 = points[intPoint === 0 ? intPoint : intPoint - 1];
    const p1 = points[intPoint];
    const p2 = points[intPoint > points.length - 2 ? points.length - 1 : intPoint + 1];
    const p3 = points[intPoint > points.length - 3 ? points.length - 1 : intPoint + 2];
    point2.set(CatmullRom(weight, p0.x, p1.x, p2.x, p3.x), CatmullRom(weight, p0.y, p1.y, p2.y, p3.y));
    return point2;
  }
  copy(source2) {
    super.copy(source2);
    this.points = [];
    for (let i = 0, l = source2.points.length; i < l; i++) {
      const point2 = source2.points[i];
      this.points.push(point2.clone());
    }
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    data.points = [];
    for (let i = 0, l = this.points.length; i < l; i++) {
      const point2 = this.points[i];
      data.points.push(point2.toArray());
    }
    return data;
  }
  fromJSON(json) {
    super.fromJSON(json);
    this.points = [];
    for (let i = 0, l = json.points.length; i < l; i++) {
      const point2 = json.points[i];
      this.points.push(new Vector2().fromArray(point2));
    }
    return this;
  }
}
SplineCurve.prototype.isSplineCurve = true;
var Curves = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  ArcCurve,
  CatmullRomCurve3,
  CubicBezierCurve,
  CubicBezierCurve3,
  EllipseCurve,
  LineCurve,
  LineCurve3,
  QuadraticBezierCurve,
  QuadraticBezierCurve3,
  SplineCurve
});
class CurvePath extends Curve {
  constructor() {
    super();
    this.type = "CurvePath";
    this.curves = [];
    this.autoClose = false;
  }
  add(curve) {
    this.curves.push(curve);
  }
  closePath() {
    const startPoint = this.curves[0].getPoint(0);
    const endPoint = this.curves[this.curves.length - 1].getPoint(1);
    if (!startPoint.equals(endPoint)) {
      this.curves.push(new LineCurve(endPoint, startPoint));
    }
  }
  getPoint(t, optionalTarget) {
    const d = t * this.getLength();
    const curveLengths = this.getCurveLengths();
    let i = 0;
    while (i < curveLengths.length) {
      if (curveLengths[i] >= d) {
        const diff = curveLengths[i] - d;
        const curve = this.curves[i];
        const segmentLength = curve.getLength();
        const u = segmentLength === 0 ? 0 : 1 - diff / segmentLength;
        return curve.getPointAt(u, optionalTarget);
      }
      i++;
    }
    return null;
  }
  getLength() {
    const lens2 = this.getCurveLengths();
    return lens2[lens2.length - 1];
  }
  updateArcLengths() {
    this.needsUpdate = true;
    this.cacheLengths = null;
    this.getCurveLengths();
  }
  getCurveLengths() {
    if (this.cacheLengths && this.cacheLengths.length === this.curves.length) {
      return this.cacheLengths;
    }
    const lengths = [];
    let sums = 0;
    for (let i = 0, l = this.curves.length; i < l; i++) {
      sums += this.curves[i].getLength();
      lengths.push(sums);
    }
    this.cacheLengths = lengths;
    return lengths;
  }
  getSpacedPoints(divisions = 40) {
    const points = [];
    for (let i = 0; i <= divisions; i++) {
      points.push(this.getPoint(i / divisions));
    }
    if (this.autoClose) {
      points.push(points[0]);
    }
    return points;
  }
  getPoints(divisions = 12) {
    const points = [];
    let last;
    for (let i = 0, curves = this.curves; i < curves.length; i++) {
      const curve = curves[i];
      const resolution = curve.isEllipseCurve ? divisions * 2 : curve.isLineCurve || curve.isLineCurve3 ? 1 : curve.isSplineCurve ? divisions * curve.points.length : divisions;
      const pts = curve.getPoints(resolution);
      for (let j = 0; j < pts.length; j++) {
        const point2 = pts[j];
        if (last && last.equals(point2))
          continue;
        points.push(point2);
        last = point2;
      }
    }
    if (this.autoClose && points.length > 1 && !points[points.length - 1].equals(points[0])) {
      points.push(points[0]);
    }
    return points;
  }
  copy(source2) {
    super.copy(source2);
    this.curves = [];
    for (let i = 0, l = source2.curves.length; i < l; i++) {
      const curve = source2.curves[i];
      this.curves.push(curve.clone());
    }
    this.autoClose = source2.autoClose;
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    data.autoClose = this.autoClose;
    data.curves = [];
    for (let i = 0, l = this.curves.length; i < l; i++) {
      const curve = this.curves[i];
      data.curves.push(curve.toJSON());
    }
    return data;
  }
  fromJSON(json) {
    super.fromJSON(json);
    this.autoClose = json.autoClose;
    this.curves = [];
    for (let i = 0, l = json.curves.length; i < l; i++) {
      const curve = json.curves[i];
      this.curves.push(new Curves[curve.type]().fromJSON(curve));
    }
    return this;
  }
}
class Path extends CurvePath {
  constructor(points) {
    super();
    this.type = "Path";
    this.currentPoint = new Vector2();
    if (points) {
      this.setFromPoints(points);
    }
  }
  setFromPoints(points) {
    this.moveTo(points[0].x, points[0].y);
    for (let i = 1, l = points.length; i < l; i++) {
      this.lineTo(points[i].x, points[i].y);
    }
    return this;
  }
  moveTo(x, y) {
    this.currentPoint.set(x, y);
    return this;
  }
  lineTo(x, y) {
    const curve = new LineCurve(this.currentPoint.clone(), new Vector2(x, y));
    this.curves.push(curve);
    this.currentPoint.set(x, y);
    return this;
  }
  quadraticCurveTo(aCPx, aCPy, aX, aY) {
    const curve = new QuadraticBezierCurve(this.currentPoint.clone(), new Vector2(aCPx, aCPy), new Vector2(aX, aY));
    this.curves.push(curve);
    this.currentPoint.set(aX, aY);
    return this;
  }
  bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {
    const curve = new CubicBezierCurve(this.currentPoint.clone(), new Vector2(aCP1x, aCP1y), new Vector2(aCP2x, aCP2y), new Vector2(aX, aY));
    this.curves.push(curve);
    this.currentPoint.set(aX, aY);
    return this;
  }
  splineThru(pts) {
    const npts = [this.currentPoint.clone()].concat(pts);
    const curve = new SplineCurve(npts);
    this.curves.push(curve);
    this.currentPoint.copy(pts[pts.length - 1]);
    return this;
  }
  arc(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
    const x0 = this.currentPoint.x;
    const y0 = this.currentPoint.y;
    this.absarc(aX + x0, aY + y0, aRadius, aStartAngle, aEndAngle, aClockwise);
    return this;
  }
  absarc(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
    this.absellipse(aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);
    return this;
  }
  ellipse(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
    const x0 = this.currentPoint.x;
    const y0 = this.currentPoint.y;
    this.absellipse(aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation);
    return this;
  }
  absellipse(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
    const curve = new EllipseCurve(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation);
    if (this.curves.length > 0) {
      const firstPoint = curve.getPoint(0);
      if (!firstPoint.equals(this.currentPoint)) {
        this.lineTo(firstPoint.x, firstPoint.y);
      }
    }
    this.curves.push(curve);
    const lastPoint = curve.getPoint(1);
    this.currentPoint.copy(lastPoint);
    return this;
  }
  copy(source2) {
    super.copy(source2);
    this.currentPoint.copy(source2.currentPoint);
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    data.currentPoint = this.currentPoint.toArray();
    return data;
  }
  fromJSON(json) {
    super.fromJSON(json);
    this.currentPoint.fromArray(json.currentPoint);
    return this;
  }
}
class LatheGeometry extends BufferGeometry {
  constructor(points = [new Vector2(0, 0.5), new Vector2(0.5, 0), new Vector2(0, -0.5)], segments = 12, phiStart = 0, phiLength = Math.PI * 2) {
    super();
    this.type = "LatheGeometry";
    this.parameters = {
      points,
      segments,
      phiStart,
      phiLength
    };
    segments = Math.floor(segments);
    phiLength = clamp(phiLength, 0, Math.PI * 2);
    const indices = [];
    const vertices = [];
    const uvs = [];
    const initNormals = [];
    const normals = [];
    const inverseSegments = 1 / segments;
    const vertex2 = new Vector3();
    const uv = new Vector2();
    const normal = new Vector3();
    const curNormal = new Vector3();
    const prevNormal = new Vector3();
    let dx = 0;
    let dy = 0;
    for (let j = 0; j <= points.length - 1; j++) {
      switch (j) {
        case 0:
          dx = points[j + 1].x - points[j].x;
          dy = points[j + 1].y - points[j].y;
          normal.x = dy * 1;
          normal.y = -dx;
          normal.z = dy * 0;
          prevNormal.copy(normal);
          normal.normalize();
          initNormals.push(normal.x, normal.y, normal.z);
          break;
        case points.length - 1:
          initNormals.push(prevNormal.x, prevNormal.y, prevNormal.z);
          break;
        default:
          dx = points[j + 1].x - points[j].x;
          dy = points[j + 1].y - points[j].y;
          normal.x = dy * 1;
          normal.y = -dx;
          normal.z = dy * 0;
          curNormal.copy(normal);
          normal.x += prevNormal.x;
          normal.y += prevNormal.y;
          normal.z += prevNormal.z;
          normal.normalize();
          initNormals.push(normal.x, normal.y, normal.z);
          prevNormal.copy(curNormal);
      }
    }
    for (let i = 0; i <= segments; i++) {
      const phi = phiStart + i * inverseSegments * phiLength;
      const sin = Math.sin(phi);
      const cos = Math.cos(phi);
      for (let j = 0; j <= points.length - 1; j++) {
        vertex2.x = points[j].x * sin;
        vertex2.y = points[j].y;
        vertex2.z = points[j].x * cos;
        vertices.push(vertex2.x, vertex2.y, vertex2.z);
        uv.x = i / segments;
        uv.y = j / (points.length - 1);
        uvs.push(uv.x, uv.y);
        const x = initNormals[3 * j + 0] * sin;
        const y = initNormals[3 * j + 1];
        const z = initNormals[3 * j + 0] * cos;
        normals.push(x, y, z);
      }
    }
    for (let i = 0; i < segments; i++) {
      for (let j = 0; j < points.length - 1; j++) {
        const base = j + i * points.length;
        const a = base;
        const b = base + points.length;
        const c2 = base + points.length + 1;
        const d = base + 1;
        indices.push(a, b, d);
        indices.push(c2, d, b);
      }
    }
    this.setIndex(indices);
    this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
    this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
  }
  static fromJSON(data) {
    return new LatheGeometry(data.points, data.segments, data.phiStart, data.phiLength);
  }
}
class CapsuleGeometry extends LatheGeometry {
  constructor(radius = 1, length2 = 1, capSegments = 4, radialSegments = 8) {
    const path = new Path();
    path.absarc(0, -length2 / 2, radius, Math.PI * 1.5, 0);
    path.absarc(0, length2 / 2, radius, 0, Math.PI * 0.5);
    super(path.getPoints(capSegments), radialSegments);
    this.type = "CapsuleGeometry";
    this.parameters = {
      radius,
      height: length2,
      capSegments,
      radialSegments
    };
  }
  static fromJSON(data) {
    return new CapsuleGeometry(data.radius, data.length, data.capSegments, data.radialSegments);
  }
}
class CircleGeometry extends BufferGeometry {
  constructor(radius = 1, segments = 8, thetaStart = 0, thetaLength = Math.PI * 2) {
    super();
    this.type = "CircleGeometry";
    this.parameters = {
      radius,
      segments,
      thetaStart,
      thetaLength
    };
    segments = Math.max(3, segments);
    const indices = [];
    const vertices = [];
    const normals = [];
    const uvs = [];
    const vertex2 = new Vector3();
    const uv = new Vector2();
    vertices.push(0, 0, 0);
    normals.push(0, 0, 1);
    uvs.push(0.5, 0.5);
    for (let s = 0, i = 3; s <= segments; s++, i += 3) {
      const segment = thetaStart + s / segments * thetaLength;
      vertex2.x = radius * Math.cos(segment);
      vertex2.y = radius * Math.sin(segment);
      vertices.push(vertex2.x, vertex2.y, vertex2.z);
      normals.push(0, 0, 1);
      uv.x = (vertices[i] / radius + 1) / 2;
      uv.y = (vertices[i + 1] / radius + 1) / 2;
      uvs.push(uv.x, uv.y);
    }
    for (let i = 1; i <= segments; i++) {
      indices.push(i, i + 1, 0);
    }
    this.setIndex(indices);
    this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
    this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
  }
  static fromJSON(data) {
    return new CircleGeometry(data.radius, data.segments, data.thetaStart, data.thetaLength);
  }
}
class CylinderGeometry extends BufferGeometry {
  constructor(radiusTop = 1, radiusBottom = 1, height2 = 1, radialSegments = 8, heightSegments = 1, openEnded = false, thetaStart = 0, thetaLength = Math.PI * 2) {
    super();
    this.type = "CylinderGeometry";
    this.parameters = {
      radiusTop,
      radiusBottom,
      height: height2,
      radialSegments,
      heightSegments,
      openEnded,
      thetaStart,
      thetaLength
    };
    const scope = this;
    radialSegments = Math.floor(radialSegments);
    heightSegments = Math.floor(heightSegments);
    const indices = [];
    const vertices = [];
    const normals = [];
    const uvs = [];
    let index2 = 0;
    const indexArray = [];
    const halfHeight = height2 / 2;
    let groupStart = 0;
    generateTorso();
    if (openEnded === false) {
      if (radiusTop > 0)
        generateCap(true);
      if (radiusBottom > 0)
        generateCap(false);
    }
    this.setIndex(indices);
    this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
    this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
    function generateTorso() {
      const normal = new Vector3();
      const vertex2 = new Vector3();
      let groupCount = 0;
      const slope = (radiusBottom - radiusTop) / height2;
      for (let y = 0; y <= heightSegments; y++) {
        const indexRow = [];
        const v = y / heightSegments;
        const radius = v * (radiusBottom - radiusTop) + radiusTop;
        for (let x = 0; x <= radialSegments; x++) {
          const u = x / radialSegments;
          const theta = u * thetaLength + thetaStart;
          const sinTheta = Math.sin(theta);
          const cosTheta = Math.cos(theta);
          vertex2.x = radius * sinTheta;
          vertex2.y = -v * height2 + halfHeight;
          vertex2.z = radius * cosTheta;
          vertices.push(vertex2.x, vertex2.y, vertex2.z);
          normal.set(sinTheta, slope, cosTheta).normalize();
          normals.push(normal.x, normal.y, normal.z);
          uvs.push(u, 1 - v);
          indexRow.push(index2++);
        }
        indexArray.push(indexRow);
      }
      for (let x = 0; x < radialSegments; x++) {
        for (let y = 0; y < heightSegments; y++) {
          const a = indexArray[y][x];
          const b = indexArray[y + 1][x];
          const c2 = indexArray[y + 1][x + 1];
          const d = indexArray[y][x + 1];
          indices.push(a, b, d);
          indices.push(b, c2, d);
          groupCount += 6;
        }
      }
      scope.addGroup(groupStart, groupCount, 0);
      groupStart += groupCount;
    }
    function generateCap(top2) {
      const centerIndexStart = index2;
      const uv = new Vector2();
      const vertex2 = new Vector3();
      let groupCount = 0;
      const radius = top2 === true ? radiusTop : radiusBottom;
      const sign2 = top2 === true ? 1 : -1;
      for (let x = 1; x <= radialSegments; x++) {
        vertices.push(0, halfHeight * sign2, 0);
        normals.push(0, sign2, 0);
        uvs.push(0.5, 0.5);
        index2++;
      }
      const centerIndexEnd = index2;
      for (let x = 0; x <= radialSegments; x++) {
        const u = x / radialSegments;
        const theta = u * thetaLength + thetaStart;
        const cosTheta = Math.cos(theta);
        const sinTheta = Math.sin(theta);
        vertex2.x = radius * sinTheta;
        vertex2.y = halfHeight * sign2;
        vertex2.z = radius * cosTheta;
        vertices.push(vertex2.x, vertex2.y, vertex2.z);
        normals.push(0, sign2, 0);
        uv.x = cosTheta * 0.5 + 0.5;
        uv.y = sinTheta * 0.5 * sign2 + 0.5;
        uvs.push(uv.x, uv.y);
        index2++;
      }
      for (let x = 0; x < radialSegments; x++) {
        const c2 = centerIndexStart + x;
        const i = centerIndexEnd + x;
        if (top2 === true) {
          indices.push(i, i + 1, c2);
        } else {
          indices.push(i + 1, i, c2);
        }
        groupCount += 3;
      }
      scope.addGroup(groupStart, groupCount, top2 === true ? 1 : 2);
      groupStart += groupCount;
    }
  }
  static fromJSON(data) {
    return new CylinderGeometry(data.radiusTop, data.radiusBottom, data.height, data.radialSegments, data.heightSegments, data.openEnded, data.thetaStart, data.thetaLength);
  }
}
class ConeGeometry extends CylinderGeometry {
  constructor(radius = 1, height2 = 1, radialSegments = 8, heightSegments = 1, openEnded = false, thetaStart = 0, thetaLength = Math.PI * 2) {
    super(0, radius, height2, radialSegments, heightSegments, openEnded, thetaStart, thetaLength);
    this.type = "ConeGeometry";
    this.parameters = {
      radius,
      height: height2,
      radialSegments,
      heightSegments,
      openEnded,
      thetaStart,
      thetaLength
    };
  }
  static fromJSON(data) {
    return new ConeGeometry(data.radius, data.height, data.radialSegments, data.heightSegments, data.openEnded, data.thetaStart, data.thetaLength);
  }
}
class PolyhedronGeometry extends BufferGeometry {
  constructor(vertices = [], indices = [], radius = 1, detail = 0) {
    super();
    this.type = "PolyhedronGeometry";
    this.parameters = {
      vertices,
      indices,
      radius,
      detail
    };
    const vertexBuffer = [];
    const uvBuffer = [];
    subdivide(detail);
    applyRadius(radius);
    generateUVs();
    this.setAttribute("position", new Float32BufferAttribute(vertexBuffer, 3));
    this.setAttribute("normal", new Float32BufferAttribute(vertexBuffer.slice(), 3));
    this.setAttribute("uv", new Float32BufferAttribute(uvBuffer, 2));
    if (detail === 0) {
      this.computeVertexNormals();
    } else {
      this.normalizeNormals();
    }
    function subdivide(detail2) {
      const a = new Vector3();
      const b = new Vector3();
      const c2 = new Vector3();
      for (let i = 0; i < indices.length; i += 3) {
        getVertexByIndex(indices[i + 0], a);
        getVertexByIndex(indices[i + 1], b);
        getVertexByIndex(indices[i + 2], c2);
        subdivideFace(a, b, c2, detail2);
      }
    }
    function subdivideFace(a, b, c2, detail2) {
      const cols = detail2 + 1;
      const v = [];
      for (let i = 0; i <= cols; i++) {
        v[i] = [];
        const aj = a.clone().lerp(c2, i / cols);
        const bj = b.clone().lerp(c2, i / cols);
        const rows = cols - i;
        for (let j = 0; j <= rows; j++) {
          if (j === 0 && i === cols) {
            v[i][j] = aj;
          } else {
            v[i][j] = aj.clone().lerp(bj, j / rows);
          }
        }
      }
      for (let i = 0; i < cols; i++) {
        for (let j = 0; j < 2 * (cols - i) - 1; j++) {
          const k = Math.floor(j / 2);
          if (j % 2 === 0) {
            pushVertex(v[i][k + 1]);
            pushVertex(v[i + 1][k]);
            pushVertex(v[i][k]);
          } else {
            pushVertex(v[i][k + 1]);
            pushVertex(v[i + 1][k + 1]);
            pushVertex(v[i + 1][k]);
          }
        }
      }
    }
    function applyRadius(radius2) {
      const vertex2 = new Vector3();
      for (let i = 0; i < vertexBuffer.length; i += 3) {
        vertex2.x = vertexBuffer[i + 0];
        vertex2.y = vertexBuffer[i + 1];
        vertex2.z = vertexBuffer[i + 2];
        vertex2.normalize().multiplyScalar(radius2);
        vertexBuffer[i + 0] = vertex2.x;
        vertexBuffer[i + 1] = vertex2.y;
        vertexBuffer[i + 2] = vertex2.z;
      }
    }
    function generateUVs() {
      const vertex2 = new Vector3();
      for (let i = 0; i < vertexBuffer.length; i += 3) {
        vertex2.x = vertexBuffer[i + 0];
        vertex2.y = vertexBuffer[i + 1];
        vertex2.z = vertexBuffer[i + 2];
        const u = azimuth(vertex2) / 2 / Math.PI + 0.5;
        const v = inclination(vertex2) / Math.PI + 0.5;
        uvBuffer.push(u, 1 - v);
      }
      correctUVs();
      correctSeam();
    }
    function correctSeam() {
      for (let i = 0; i < uvBuffer.length; i += 6) {
        const x0 = uvBuffer[i + 0];
        const x1 = uvBuffer[i + 2];
        const x2 = uvBuffer[i + 4];
        const max = Math.max(x0, x1, x2);
        const min = Math.min(x0, x1, x2);
        if (max > 0.9 && min < 0.1) {
          if (x0 < 0.2)
            uvBuffer[i + 0] += 1;
          if (x1 < 0.2)
            uvBuffer[i + 2] += 1;
          if (x2 < 0.2)
            uvBuffer[i + 4] += 1;
        }
      }
    }
    function pushVertex(vertex2) {
      vertexBuffer.push(vertex2.x, vertex2.y, vertex2.z);
    }
    function getVertexByIndex(index2, vertex2) {
      const stride = index2 * 3;
      vertex2.x = vertices[stride + 0];
      vertex2.y = vertices[stride + 1];
      vertex2.z = vertices[stride + 2];
    }
    function correctUVs() {
      const a = new Vector3();
      const b = new Vector3();
      const c2 = new Vector3();
      const centroid = new Vector3();
      const uvA = new Vector2();
      const uvB = new Vector2();
      const uvC = new Vector2();
      for (let i = 0, j = 0; i < vertexBuffer.length; i += 9, j += 6) {
        a.set(vertexBuffer[i + 0], vertexBuffer[i + 1], vertexBuffer[i + 2]);
        b.set(vertexBuffer[i + 3], vertexBuffer[i + 4], vertexBuffer[i + 5]);
        c2.set(vertexBuffer[i + 6], vertexBuffer[i + 7], vertexBuffer[i + 8]);
        uvA.set(uvBuffer[j + 0], uvBuffer[j + 1]);
        uvB.set(uvBuffer[j + 2], uvBuffer[j + 3]);
        uvC.set(uvBuffer[j + 4], uvBuffer[j + 5]);
        centroid.copy(a).add(b).add(c2).divideScalar(3);
        const azi = azimuth(centroid);
        correctUV(uvA, j + 0, a, azi);
        correctUV(uvB, j + 2, b, azi);
        correctUV(uvC, j + 4, c2, azi);
      }
    }
    function correctUV(uv, stride, vector, azimuth2) {
      if (azimuth2 < 0 && uv.x === 1) {
        uvBuffer[stride] = uv.x - 1;
      }
      if (vector.x === 0 && vector.z === 0) {
        uvBuffer[stride] = azimuth2 / 2 / Math.PI + 0.5;
      }
    }
    function azimuth(vector) {
      return Math.atan2(vector.z, -vector.x);
    }
    function inclination(vector) {
      return Math.atan2(-vector.y, Math.sqrt(vector.x * vector.x + vector.z * vector.z));
    }
  }
  static fromJSON(data) {
    return new PolyhedronGeometry(data.vertices, data.indices, data.radius, data.details);
  }
}
class DodecahedronGeometry extends PolyhedronGeometry {
  constructor(radius = 1, detail = 0) {
    const t = (1 + Math.sqrt(5)) / 2;
    const r = 1 / t;
    const vertices = [
      -1,
      -1,
      -1,
      -1,
      -1,
      1,
      -1,
      1,
      -1,
      -1,
      1,
      1,
      1,
      -1,
      -1,
      1,
      -1,
      1,
      1,
      1,
      -1,
      1,
      1,
      1,
      0,
      -r,
      -t,
      0,
      -r,
      t,
      0,
      r,
      -t,
      0,
      r,
      t,
      -r,
      -t,
      0,
      -r,
      t,
      0,
      r,
      -t,
      0,
      r,
      t,
      0,
      -t,
      0,
      -r,
      t,
      0,
      -r,
      -t,
      0,
      r,
      t,
      0,
      r
    ];
    const indices = [
      3,
      11,
      7,
      3,
      7,
      15,
      3,
      15,
      13,
      7,
      19,
      17,
      7,
      17,
      6,
      7,
      6,
      15,
      17,
      4,
      8,
      17,
      8,
      10,
      17,
      10,
      6,
      8,
      0,
      16,
      8,
      16,
      2,
      8,
      2,
      10,
      0,
      12,
      1,
      0,
      1,
      18,
      0,
      18,
      16,
      6,
      10,
      2,
      6,
      2,
      13,
      6,
      13,
      15,
      2,
      16,
      18,
      2,
      18,
      3,
      2,
      3,
      13,
      18,
      1,
      9,
      18,
      9,
      11,
      18,
      11,
      3,
      4,
      14,
      12,
      4,
      12,
      0,
      4,
      0,
      8,
      11,
      9,
      5,
      11,
      5,
      19,
      11,
      19,
      7,
      19,
      5,
      14,
      19,
      14,
      4,
      19,
      4,
      17,
      1,
      12,
      14,
      1,
      14,
      5,
      1,
      5,
      9
    ];
    super(vertices, indices, radius, detail);
    this.type = "DodecahedronGeometry";
    this.parameters = {
      radius,
      detail
    };
  }
  static fromJSON(data) {
    return new DodecahedronGeometry(data.radius, data.detail);
  }
}
const _v0 = new Vector3();
const _v1$1 = new Vector3();
const _normal = new Vector3();
const _triangle = new Triangle();
class EdgesGeometry extends BufferGeometry {
  constructor(geometry = null, thresholdAngle = 1) {
    super();
    this.type = "EdgesGeometry";
    this.parameters = {
      geometry,
      thresholdAngle
    };
    if (geometry !== null) {
      const precisionPoints = 4;
      const precision = Math.pow(10, precisionPoints);
      const thresholdDot = Math.cos(DEG2RAD * thresholdAngle);
      const indexAttr = geometry.getIndex();
      const positionAttr = geometry.getAttribute("position");
      const indexCount = indexAttr ? indexAttr.count : positionAttr.count;
      const indexArr = [0, 0, 0];
      const vertKeys = ["a", "b", "c"];
      const hashes = new Array(3);
      const edgeData = {};
      const vertices = [];
      for (let i = 0; i < indexCount; i += 3) {
        if (indexAttr) {
          indexArr[0] = indexAttr.getX(i);
          indexArr[1] = indexAttr.getX(i + 1);
          indexArr[2] = indexAttr.getX(i + 2);
        } else {
          indexArr[0] = i;
          indexArr[1] = i + 1;
          indexArr[2] = i + 2;
        }
        const { a, b, c: c2 } = _triangle;
        a.fromBufferAttribute(positionAttr, indexArr[0]);
        b.fromBufferAttribute(positionAttr, indexArr[1]);
        c2.fromBufferAttribute(positionAttr, indexArr[2]);
        _triangle.getNormal(_normal);
        hashes[0] = `${Math.round(a.x * precision)},${Math.round(a.y * precision)},${Math.round(a.z * precision)}`;
        hashes[1] = `${Math.round(b.x * precision)},${Math.round(b.y * precision)},${Math.round(b.z * precision)}`;
        hashes[2] = `${Math.round(c2.x * precision)},${Math.round(c2.y * precision)},${Math.round(c2.z * precision)}`;
        if (hashes[0] === hashes[1] || hashes[1] === hashes[2] || hashes[2] === hashes[0]) {
          continue;
        }
        for (let j = 0; j < 3; j++) {
          const jNext = (j + 1) % 3;
          const vecHash0 = hashes[j];
          const vecHash1 = hashes[jNext];
          const v0 = _triangle[vertKeys[j]];
          const v1 = _triangle[vertKeys[jNext]];
          const hash = `${vecHash0}_${vecHash1}`;
          const reverseHash = `${vecHash1}_${vecHash0}`;
          if (reverseHash in edgeData && edgeData[reverseHash]) {
            if (_normal.dot(edgeData[reverseHash].normal) <= thresholdDot) {
              vertices.push(v0.x, v0.y, v0.z);
              vertices.push(v1.x, v1.y, v1.z);
            }
            edgeData[reverseHash] = null;
          } else if (!(hash in edgeData)) {
            edgeData[hash] = {
              index0: indexArr[j],
              index1: indexArr[jNext],
              normal: _normal.clone()
            };
          }
        }
      }
      for (const key in edgeData) {
        if (edgeData[key]) {
          const { index0, index1 } = edgeData[key];
          _v0.fromBufferAttribute(positionAttr, index0);
          _v1$1.fromBufferAttribute(positionAttr, index1);
          vertices.push(_v0.x, _v0.y, _v0.z);
          vertices.push(_v1$1.x, _v1$1.y, _v1$1.z);
        }
      }
      this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    }
  }
}
class Shape extends Path {
  constructor(points) {
    super(points);
    this.uuid = generateUUID();
    this.type = "Shape";
    this.holes = [];
  }
  getPointsHoles(divisions) {
    const holesPts = [];
    for (let i = 0, l = this.holes.length; i < l; i++) {
      holesPts[i] = this.holes[i].getPoints(divisions);
    }
    return holesPts;
  }
  extractPoints(divisions) {
    return {
      shape: this.getPoints(divisions),
      holes: this.getPointsHoles(divisions)
    };
  }
  copy(source2) {
    super.copy(source2);
    this.holes = [];
    for (let i = 0, l = source2.holes.length; i < l; i++) {
      const hole = source2.holes[i];
      this.holes.push(hole.clone());
    }
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    data.uuid = this.uuid;
    data.holes = [];
    for (let i = 0, l = this.holes.length; i < l; i++) {
      const hole = this.holes[i];
      data.holes.push(hole.toJSON());
    }
    return data;
  }
  fromJSON(json) {
    super.fromJSON(json);
    this.uuid = json.uuid;
    this.holes = [];
    for (let i = 0, l = json.holes.length; i < l; i++) {
      const hole = json.holes[i];
      this.holes.push(new Path().fromJSON(hole));
    }
    return this;
  }
}
const Earcut = {
  triangulate: function(data, holeIndices, dim = 2) {
    const hasHoles = holeIndices && holeIndices.length;
    const outerLen = hasHoles ? holeIndices[0] * dim : data.length;
    let outerNode = linkedList(data, 0, outerLen, dim, true);
    const triangles = [];
    if (!outerNode || outerNode.next === outerNode.prev)
      return triangles;
    let minX, minY, maxX, maxY, x, y, invSize;
    if (hasHoles)
      outerNode = eliminateHoles(data, holeIndices, outerNode, dim);
    if (data.length > 80 * dim) {
      minX = maxX = data[0];
      minY = maxY = data[1];
      for (let i = dim; i < outerLen; i += dim) {
        x = data[i];
        y = data[i + 1];
        if (x < minX)
          minX = x;
        if (y < minY)
          minY = y;
        if (x > maxX)
          maxX = x;
        if (y > maxY)
          maxY = y;
      }
      invSize = Math.max(maxX - minX, maxY - minY);
      invSize = invSize !== 0 ? 1 / invSize : 0;
    }
    earcutLinked(outerNode, triangles, dim, minX, minY, invSize);
    return triangles;
  }
};
function linkedList(data, start2, end2, dim, clockwise) {
  let i, last;
  if (clockwise === signedArea(data, start2, end2, dim) > 0) {
    for (i = start2; i < end2; i += dim)
      last = insertNode(i, data[i], data[i + 1], last);
  } else {
    for (i = end2 - dim; i >= start2; i -= dim)
      last = insertNode(i, data[i], data[i + 1], last);
  }
  if (last && equals(last, last.next)) {
    removeNode(last);
    last = last.next;
  }
  return last;
}
function filterPoints(start2, end2) {
  if (!start2)
    return start2;
  if (!end2)
    end2 = start2;
  let p = start2, again;
  do {
    again = false;
    if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {
      removeNode(p);
      p = end2 = p.prev;
      if (p === p.next)
        break;
      again = true;
    } else {
      p = p.next;
    }
  } while (again || p !== end2);
  return end2;
}
function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {
  if (!ear)
    return;
  if (!pass && invSize)
    indexCurve(ear, minX, minY, invSize);
  let stop = ear, prev, next;
  while (ear.prev !== ear.next) {
    prev = ear.prev;
    next = ear.next;
    if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {
      triangles.push(prev.i / dim);
      triangles.push(ear.i / dim);
      triangles.push(next.i / dim);
      removeNode(ear);
      ear = next.next;
      stop = next.next;
      continue;
    }
    ear = next;
    if (ear === stop) {
      if (!pass) {
        earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);
      } else if (pass === 1) {
        ear = cureLocalIntersections(filterPoints(ear), triangles, dim);
        earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);
      } else if (pass === 2) {
        splitEarcut(ear, triangles, dim, minX, minY, invSize);
      }
      break;
    }
  }
}
function isEar(ear) {
  const a = ear.prev, b = ear, c2 = ear.next;
  if (area(a, b, c2) >= 0)
    return false;
  let p = ear.next.next;
  while (p !== ear.prev) {
    if (pointInTriangle(a.x, a.y, b.x, b.y, c2.x, c2.y, p.x, p.y) && area(p.prev, p, p.next) >= 0)
      return false;
    p = p.next;
  }
  return true;
}
function isEarHashed(ear, minX, minY, invSize) {
  const a = ear.prev, b = ear, c2 = ear.next;
  if (area(a, b, c2) >= 0)
    return false;
  const minTX = a.x < b.x ? a.x < c2.x ? a.x : c2.x : b.x < c2.x ? b.x : c2.x, minTY = a.y < b.y ? a.y < c2.y ? a.y : c2.y : b.y < c2.y ? b.y : c2.y, maxTX = a.x > b.x ? a.x > c2.x ? a.x : c2.x : b.x > c2.x ? b.x : c2.x, maxTY = a.y > b.y ? a.y > c2.y ? a.y : c2.y : b.y > c2.y ? b.y : c2.y;
  const minZ = zOrder(minTX, minTY, minX, minY, invSize), maxZ = zOrder(maxTX, maxTY, minX, minY, invSize);
  let p = ear.prevZ, n = ear.nextZ;
  while (p && p.z >= minZ && n && n.z <= maxZ) {
    if (p !== ear.prev && p !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c2.x, c2.y, p.x, p.y) && area(p.prev, p, p.next) >= 0)
      return false;
    p = p.prevZ;
    if (n !== ear.prev && n !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c2.x, c2.y, n.x, n.y) && area(n.prev, n, n.next) >= 0)
      return false;
    n = n.nextZ;
  }
  while (p && p.z >= minZ) {
    if (p !== ear.prev && p !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c2.x, c2.y, p.x, p.y) && area(p.prev, p, p.next) >= 0)
      return false;
    p = p.prevZ;
  }
  while (n && n.z <= maxZ) {
    if (n !== ear.prev && n !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c2.x, c2.y, n.x, n.y) && area(n.prev, n, n.next) >= 0)
      return false;
    n = n.nextZ;
  }
  return true;
}
function cureLocalIntersections(start2, triangles, dim) {
  let p = start2;
  do {
    const a = p.prev, b = p.next.next;
    if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {
      triangles.push(a.i / dim);
      triangles.push(p.i / dim);
      triangles.push(b.i / dim);
      removeNode(p);
      removeNode(p.next);
      p = start2 = b;
    }
    p = p.next;
  } while (p !== start2);
  return filterPoints(p);
}
function splitEarcut(start2, triangles, dim, minX, minY, invSize) {
  let a = start2;
  do {
    let b = a.next.next;
    while (b !== a.prev) {
      if (a.i !== b.i && isValidDiagonal(a, b)) {
        let c2 = splitPolygon(a, b);
        a = filterPoints(a, a.next);
        c2 = filterPoints(c2, c2.next);
        earcutLinked(a, triangles, dim, minX, minY, invSize);
        earcutLinked(c2, triangles, dim, minX, minY, invSize);
        return;
      }
      b = b.next;
    }
    a = a.next;
  } while (a !== start2);
}
function eliminateHoles(data, holeIndices, outerNode, dim) {
  const queue = [];
  let i, len2, start2, end2, list2;
  for (i = 0, len2 = holeIndices.length; i < len2; i++) {
    start2 = holeIndices[i] * dim;
    end2 = i < len2 - 1 ? holeIndices[i + 1] * dim : data.length;
    list2 = linkedList(data, start2, end2, dim, false);
    if (list2 === list2.next)
      list2.steiner = true;
    queue.push(getLeftmost(list2));
  }
  queue.sort(compareX);
  for (i = 0; i < queue.length; i++) {
    eliminateHole(queue[i], outerNode);
    outerNode = filterPoints(outerNode, outerNode.next);
  }
  return outerNode;
}
function compareX(a, b) {
  return a.x - b.x;
}
function eliminateHole(hole, outerNode) {
  outerNode = findHoleBridge(hole, outerNode);
  if (outerNode) {
    const b = splitPolygon(outerNode, hole);
    filterPoints(outerNode, outerNode.next);
    filterPoints(b, b.next);
  }
}
function findHoleBridge(hole, outerNode) {
  let p = outerNode;
  const hx = hole.x;
  const hy = hole.y;
  let qx = -Infinity, m;
  do {
    if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {
      const x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);
      if (x <= hx && x > qx) {
        qx = x;
        if (x === hx) {
          if (hy === p.y)
            return p;
          if (hy === p.next.y)
            return p.next;
        }
        m = p.x < p.next.x ? p : p.next;
      }
    }
    p = p.next;
  } while (p !== outerNode);
  if (!m)
    return null;
  if (hx === qx)
    return m;
  const stop = m, mx = m.x, my = m.y;
  let tanMin = Infinity, tan;
  p = m;
  do {
    if (hx >= p.x && p.x >= mx && hx !== p.x && pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {
      tan = Math.abs(hy - p.y) / (hx - p.x);
      if (locallyInside(p, hole) && (tan < tanMin || tan === tanMin && (p.x > m.x || p.x === m.x && sectorContainsSector(m, p)))) {
        m = p;
        tanMin = tan;
      }
    }
    p = p.next;
  } while (p !== stop);
  return m;
}
function sectorContainsSector(m, p) {
  return area(m.prev, m, p.prev) < 0 && area(p.next, m, m.next) < 0;
}
function indexCurve(start2, minX, minY, invSize) {
  let p = start2;
  do {
    if (p.z === null)
      p.z = zOrder(p.x, p.y, minX, minY, invSize);
    p.prevZ = p.prev;
    p.nextZ = p.next;
    p = p.next;
  } while (p !== start2);
  p.prevZ.nextZ = null;
  p.prevZ = null;
  sortLinked(p);
}
function sortLinked(list2) {
  let i, p, q, e, tail, numMerges, pSize, qSize, inSize = 1;
  do {
    p = list2;
    list2 = null;
    tail = null;
    numMerges = 0;
    while (p) {
      numMerges++;
      q = p;
      pSize = 0;
      for (i = 0; i < inSize; i++) {
        pSize++;
        q = q.nextZ;
        if (!q)
          break;
      }
      qSize = inSize;
      while (pSize > 0 || qSize > 0 && q) {
        if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {
          e = p;
          p = p.nextZ;
          pSize--;
        } else {
          e = q;
          q = q.nextZ;
          qSize--;
        }
        if (tail)
          tail.nextZ = e;
        else
          list2 = e;
        e.prevZ = tail;
        tail = e;
      }
      p = q;
    }
    tail.nextZ = null;
    inSize *= 2;
  } while (numMerges > 1);
  return list2;
}
function zOrder(x, y, minX, minY, invSize) {
  x = 32767 * (x - minX) * invSize;
  y = 32767 * (y - minY) * invSize;
  x = (x | x << 8) & 16711935;
  x = (x | x << 4) & 252645135;
  x = (x | x << 2) & 858993459;
  x = (x | x << 1) & 1431655765;
  y = (y | y << 8) & 16711935;
  y = (y | y << 4) & 252645135;
  y = (y | y << 2) & 858993459;
  y = (y | y << 1) & 1431655765;
  return x | y << 1;
}
function getLeftmost(start2) {
  let p = start2, leftmost = start2;
  do {
    if (p.x < leftmost.x || p.x === leftmost.x && p.y < leftmost.y)
      leftmost = p;
    p = p.next;
  } while (p !== start2);
  return leftmost;
}
function pointInTriangle(ax, ay, bx, by, cx, cy, px2, py2) {
  return (cx - px2) * (ay - py2) - (ax - px2) * (cy - py2) >= 0 && (ax - px2) * (by - py2) - (bx - px2) * (ay - py2) >= 0 && (bx - px2) * (cy - py2) - (cx - px2) * (by - py2) >= 0;
}
function isValidDiagonal(a, b) {
  return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) && (locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b) && (area(a.prev, a, b.prev) || area(a, b.prev, b)) || equals(a, b) && area(a.prev, a, a.next) > 0 && area(b.prev, b, b.next) > 0);
}
function area(p, q, r) {
  return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
}
function equals(p1, p2) {
  return p1.x === p2.x && p1.y === p2.y;
}
function intersects(p1, q1, p2, q2) {
  const o1 = sign(area(p1, q1, p2));
  const o2 = sign(area(p1, q1, q2));
  const o3 = sign(area(p2, q2, p1));
  const o4 = sign(area(p2, q2, q1));
  if (o1 !== o2 && o3 !== o4)
    return true;
  if (o1 === 0 && onSegment(p1, p2, q1))
    return true;
  if (o2 === 0 && onSegment(p1, q2, q1))
    return true;
  if (o3 === 0 && onSegment(p2, p1, q2))
    return true;
  if (o4 === 0 && onSegment(p2, q1, q2))
    return true;
  return false;
}
function onSegment(p, q, r) {
  return q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) && q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y);
}
function sign(num) {
  return num > 0 ? 1 : num < 0 ? -1 : 0;
}
function intersectsPolygon(a, b) {
  let p = a;
  do {
    if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i && intersects(p, p.next, a, b))
      return true;
    p = p.next;
  } while (p !== a);
  return false;
}
function locallyInside(a, b) {
  return area(a.prev, a, a.next) < 0 ? area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 : area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;
}
function middleInside(a, b) {
  let p = a, inside = false;
  const px2 = (a.x + b.x) / 2, py2 = (a.y + b.y) / 2;
  do {
    if (p.y > py2 !== p.next.y > py2 && p.next.y !== p.y && px2 < (p.next.x - p.x) * (py2 - p.y) / (p.next.y - p.y) + p.x)
      inside = !inside;
    p = p.next;
  } while (p !== a);
  return inside;
}
function splitPolygon(a, b) {
  const a2 = new Node(a.i, a.x, a.y), b2 = new Node(b.i, b.x, b.y), an = a.next, bp = b.prev;
  a.next = b;
  b.prev = a;
  a2.next = an;
  an.prev = a2;
  b2.next = a2;
  a2.prev = b2;
  bp.next = b2;
  b2.prev = bp;
  return b2;
}
function insertNode(i, x, y, last) {
  const p = new Node(i, x, y);
  if (!last) {
    p.prev = p;
    p.next = p;
  } else {
    p.next = last.next;
    p.prev = last;
    last.next.prev = p;
    last.next = p;
  }
  return p;
}
function removeNode(p) {
  p.next.prev = p.prev;
  p.prev.next = p.next;
  if (p.prevZ)
    p.prevZ.nextZ = p.nextZ;
  if (p.nextZ)
    p.nextZ.prevZ = p.prevZ;
}
function Node(i, x, y) {
  this.i = i;
  this.x = x;
  this.y = y;
  this.prev = null;
  this.next = null;
  this.z = null;
  this.prevZ = null;
  this.nextZ = null;
  this.steiner = false;
}
function signedArea(data, start2, end2, dim) {
  let sum = 0;
  for (let i = start2, j = end2 - dim; i < end2; i += dim) {
    sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);
    j = i;
  }
  return sum;
}
class ShapeUtils {
  static area(contour) {
    const n = contour.length;
    let a = 0;
    for (let p = n - 1, q = 0; q < n; p = q++) {
      a += contour[p].x * contour[q].y - contour[q].x * contour[p].y;
    }
    return a * 0.5;
  }
  static isClockWise(pts) {
    return ShapeUtils.area(pts) < 0;
  }
  static triangulateShape(contour, holes) {
    const vertices = [];
    const holeIndices = [];
    const faces = [];
    removeDupEndPts(contour);
    addContour(vertices, contour);
    let holeIndex = contour.length;
    holes.forEach(removeDupEndPts);
    for (let i = 0; i < holes.length; i++) {
      holeIndices.push(holeIndex);
      holeIndex += holes[i].length;
      addContour(vertices, holes[i]);
    }
    const triangles = Earcut.triangulate(vertices, holeIndices);
    for (let i = 0; i < triangles.length; i += 3) {
      faces.push(triangles.slice(i, i + 3));
    }
    return faces;
  }
}
function removeDupEndPts(points) {
  const l = points.length;
  if (l > 2 && points[l - 1].equals(points[0])) {
    points.pop();
  }
}
function addContour(vertices, contour) {
  for (let i = 0; i < contour.length; i++) {
    vertices.push(contour[i].x);
    vertices.push(contour[i].y);
  }
}
class ExtrudeGeometry extends BufferGeometry {
  constructor(shapes = new Shape([new Vector2(0.5, 0.5), new Vector2(-0.5, 0.5), new Vector2(-0.5, -0.5), new Vector2(0.5, -0.5)]), options2 = {}) {
    super();
    this.type = "ExtrudeGeometry";
    this.parameters = {
      shapes,
      options: options2
    };
    shapes = Array.isArray(shapes) ? shapes : [shapes];
    const scope = this;
    const verticesArray = [];
    const uvArray = [];
    for (let i = 0, l = shapes.length; i < l; i++) {
      const shape2 = shapes[i];
      addShape(shape2);
    }
    this.setAttribute("position", new Float32BufferAttribute(verticesArray, 3));
    this.setAttribute("uv", new Float32BufferAttribute(uvArray, 2));
    this.computeVertexNormals();
    function addShape(shape2) {
      const placeholder = [];
      const curveSegments = options2.curveSegments !== void 0 ? options2.curveSegments : 12;
      const steps = options2.steps !== void 0 ? options2.steps : 1;
      let depth = options2.depth !== void 0 ? options2.depth : 1;
      let bevelEnabled = options2.bevelEnabled !== void 0 ? options2.bevelEnabled : true;
      let bevelThickness = options2.bevelThickness !== void 0 ? options2.bevelThickness : 0.2;
      let bevelSize = options2.bevelSize !== void 0 ? options2.bevelSize : bevelThickness - 0.1;
      let bevelOffset = options2.bevelOffset !== void 0 ? options2.bevelOffset : 0;
      let bevelSegments = options2.bevelSegments !== void 0 ? options2.bevelSegments : 3;
      const extrudePath = options2.extrudePath;
      const uvgen = options2.UVGenerator !== void 0 ? options2.UVGenerator : WorldUVGenerator;
      if (options2.amount !== void 0) {
        console.warn("THREE.ExtrudeBufferGeometry: amount has been renamed to depth.");
        depth = options2.amount;
      }
      let extrudePts, extrudeByPath = false;
      let splineTube, binormal, normal, position2;
      if (extrudePath) {
        extrudePts = extrudePath.getSpacedPoints(steps);
        extrudeByPath = true;
        bevelEnabled = false;
        splineTube = extrudePath.computeFrenetFrames(steps, false);
        binormal = new Vector3();
        normal = new Vector3();
        position2 = new Vector3();
      }
      if (!bevelEnabled) {
        bevelSegments = 0;
        bevelThickness = 0;
        bevelSize = 0;
        bevelOffset = 0;
      }
      const shapePoints = shape2.extractPoints(curveSegments);
      let vertices = shapePoints.shape;
      const holes = shapePoints.holes;
      const reverse = !ShapeUtils.isClockWise(vertices);
      if (reverse) {
        vertices = vertices.reverse();
        for (let h = 0, hl = holes.length; h < hl; h++) {
          const ahole = holes[h];
          if (ShapeUtils.isClockWise(ahole)) {
            holes[h] = ahole.reverse();
          }
        }
      }
      const faces = ShapeUtils.triangulateShape(vertices, holes);
      const contour = vertices;
      for (let h = 0, hl = holes.length; h < hl; h++) {
        const ahole = holes[h];
        vertices = vertices.concat(ahole);
      }
      function scalePt2(pt, vec, size2) {
        if (!vec)
          console.error("THREE.ExtrudeGeometry: vec does not exist");
        return vec.clone().multiplyScalar(size2).add(pt);
      }
      const vlen = vertices.length, flen = faces.length;
      function getBevelVec(inPt, inPrev, inNext) {
        let v_trans_x, v_trans_y, shrink_by;
        const v_prev_x = inPt.x - inPrev.x, v_prev_y = inPt.y - inPrev.y;
        const v_next_x = inNext.x - inPt.x, v_next_y = inNext.y - inPt.y;
        const v_prev_lensq = v_prev_x * v_prev_x + v_prev_y * v_prev_y;
        const collinear0 = v_prev_x * v_next_y - v_prev_y * v_next_x;
        if (Math.abs(collinear0) > Number.EPSILON) {
          const v_prev_len = Math.sqrt(v_prev_lensq);
          const v_next_len = Math.sqrt(v_next_x * v_next_x + v_next_y * v_next_y);
          const ptPrevShift_x = inPrev.x - v_prev_y / v_prev_len;
          const ptPrevShift_y = inPrev.y + v_prev_x / v_prev_len;
          const ptNextShift_x = inNext.x - v_next_y / v_next_len;
          const ptNextShift_y = inNext.y + v_next_x / v_next_len;
          const sf = ((ptNextShift_x - ptPrevShift_x) * v_next_y - (ptNextShift_y - ptPrevShift_y) * v_next_x) / (v_prev_x * v_next_y - v_prev_y * v_next_x);
          v_trans_x = ptPrevShift_x + v_prev_x * sf - inPt.x;
          v_trans_y = ptPrevShift_y + v_prev_y * sf - inPt.y;
          const v_trans_lensq = v_trans_x * v_trans_x + v_trans_y * v_trans_y;
          if (v_trans_lensq <= 2) {
            return new Vector2(v_trans_x, v_trans_y);
          } else {
            shrink_by = Math.sqrt(v_trans_lensq / 2);
          }
        } else {
          let direction_eq = false;
          if (v_prev_x > Number.EPSILON) {
            if (v_next_x > Number.EPSILON) {
              direction_eq = true;
            }
          } else {
            if (v_prev_x < -Number.EPSILON) {
              if (v_next_x < -Number.EPSILON) {
                direction_eq = true;
              }
            } else {
              if (Math.sign(v_prev_y) === Math.sign(v_next_y)) {
                direction_eq = true;
              }
            }
          }
          if (direction_eq) {
            v_trans_x = -v_prev_y;
            v_trans_y = v_prev_x;
            shrink_by = Math.sqrt(v_prev_lensq);
          } else {
            v_trans_x = v_prev_x;
            v_trans_y = v_prev_y;
            shrink_by = Math.sqrt(v_prev_lensq / 2);
          }
        }
        return new Vector2(v_trans_x / shrink_by, v_trans_y / shrink_by);
      }
      const contourMovements = [];
      for (let i = 0, il = contour.length, j = il - 1, k = i + 1; i < il; i++, j++, k++) {
        if (j === il)
          j = 0;
        if (k === il)
          k = 0;
        contourMovements[i] = getBevelVec(contour[i], contour[j], contour[k]);
      }
      const holesMovements = [];
      let oneHoleMovements, verticesMovements = contourMovements.concat();
      for (let h = 0, hl = holes.length; h < hl; h++) {
        const ahole = holes[h];
        oneHoleMovements = [];
        for (let i = 0, il = ahole.length, j = il - 1, k = i + 1; i < il; i++, j++, k++) {
          if (j === il)
            j = 0;
          if (k === il)
            k = 0;
          oneHoleMovements[i] = getBevelVec(ahole[i], ahole[j], ahole[k]);
        }
        holesMovements.push(oneHoleMovements);
        verticesMovements = verticesMovements.concat(oneHoleMovements);
      }
      for (let b = 0; b < bevelSegments; b++) {
        const t = b / bevelSegments;
        const z = bevelThickness * Math.cos(t * Math.PI / 2);
        const bs2 = bevelSize * Math.sin(t * Math.PI / 2) + bevelOffset;
        for (let i = 0, il = contour.length; i < il; i++) {
          const vert = scalePt2(contour[i], contourMovements[i], bs2);
          v(vert.x, vert.y, -z);
        }
        for (let h = 0, hl = holes.length; h < hl; h++) {
          const ahole = holes[h];
          oneHoleMovements = holesMovements[h];
          for (let i = 0, il = ahole.length; i < il; i++) {
            const vert = scalePt2(ahole[i], oneHoleMovements[i], bs2);
            v(vert.x, vert.y, -z);
          }
        }
      }
      const bs = bevelSize + bevelOffset;
      for (let i = 0; i < vlen; i++) {
        const vert = bevelEnabled ? scalePt2(vertices[i], verticesMovements[i], bs) : vertices[i];
        if (!extrudeByPath) {
          v(vert.x, vert.y, 0);
        } else {
          normal.copy(splineTube.normals[0]).multiplyScalar(vert.x);
          binormal.copy(splineTube.binormals[0]).multiplyScalar(vert.y);
          position2.copy(extrudePts[0]).add(normal).add(binormal);
          v(position2.x, position2.y, position2.z);
        }
      }
      for (let s = 1; s <= steps; s++) {
        for (let i = 0; i < vlen; i++) {
          const vert = bevelEnabled ? scalePt2(vertices[i], verticesMovements[i], bs) : vertices[i];
          if (!extrudeByPath) {
            v(vert.x, vert.y, depth / steps * s);
          } else {
            normal.copy(splineTube.normals[s]).multiplyScalar(vert.x);
            binormal.copy(splineTube.binormals[s]).multiplyScalar(vert.y);
            position2.copy(extrudePts[s]).add(normal).add(binormal);
            v(position2.x, position2.y, position2.z);
          }
        }
      }
      for (let b = bevelSegments - 1; b >= 0; b--) {
        const t = b / bevelSegments;
        const z = bevelThickness * Math.cos(t * Math.PI / 2);
        const bs2 = bevelSize * Math.sin(t * Math.PI / 2) + bevelOffset;
        for (let i = 0, il = contour.length; i < il; i++) {
          const vert = scalePt2(contour[i], contourMovements[i], bs2);
          v(vert.x, vert.y, depth + z);
        }
        for (let h = 0, hl = holes.length; h < hl; h++) {
          const ahole = holes[h];
          oneHoleMovements = holesMovements[h];
          for (let i = 0, il = ahole.length; i < il; i++) {
            const vert = scalePt2(ahole[i], oneHoleMovements[i], bs2);
            if (!extrudeByPath) {
              v(vert.x, vert.y, depth + z);
            } else {
              v(vert.x, vert.y + extrudePts[steps - 1].y, extrudePts[steps - 1].x + z);
            }
          }
        }
      }
      buildLidFaces();
      buildSideFaces();
      function buildLidFaces() {
        const start2 = verticesArray.length / 3;
        if (bevelEnabled) {
          let layer = 0;
          let offset = vlen * layer;
          for (let i = 0; i < flen; i++) {
            const face2 = faces[i];
            f3(face2[2] + offset, face2[1] + offset, face2[0] + offset);
          }
          layer = steps + bevelSegments * 2;
          offset = vlen * layer;
          for (let i = 0; i < flen; i++) {
            const face2 = faces[i];
            f3(face2[0] + offset, face2[1] + offset, face2[2] + offset);
          }
        } else {
          for (let i = 0; i < flen; i++) {
            const face2 = faces[i];
            f3(face2[2], face2[1], face2[0]);
          }
          for (let i = 0; i < flen; i++) {
            const face2 = faces[i];
            f3(face2[0] + vlen * steps, face2[1] + vlen * steps, face2[2] + vlen * steps);
          }
        }
        scope.addGroup(start2, verticesArray.length / 3 - start2, 0);
      }
      function buildSideFaces() {
        const start2 = verticesArray.length / 3;
        let layeroffset = 0;
        sidewalls(contour, layeroffset);
        layeroffset += contour.length;
        for (let h = 0, hl = holes.length; h < hl; h++) {
          const ahole = holes[h];
          sidewalls(ahole, layeroffset);
          layeroffset += ahole.length;
        }
        scope.addGroup(start2, verticesArray.length / 3 - start2, 1);
      }
      function sidewalls(contour2, layeroffset) {
        let i = contour2.length;
        while (--i >= 0) {
          const j = i;
          let k = i - 1;
          if (k < 0)
            k = contour2.length - 1;
          for (let s = 0, sl = steps + bevelSegments * 2; s < sl; s++) {
            const slen1 = vlen * s;
            const slen2 = vlen * (s + 1);
            const a = layeroffset + j + slen1, b = layeroffset + k + slen1, c2 = layeroffset + k + slen2, d = layeroffset + j + slen2;
            f4(a, b, c2, d);
          }
        }
      }
      function v(x, y, z) {
        placeholder.push(x);
        placeholder.push(y);
        placeholder.push(z);
      }
      function f3(a, b, c2) {
        addVertex(a);
        addVertex(b);
        addVertex(c2);
        const nextIndex = verticesArray.length / 3;
        const uvs = uvgen.generateTopUV(scope, verticesArray, nextIndex - 3, nextIndex - 2, nextIndex - 1);
        addUV(uvs[0]);
        addUV(uvs[1]);
        addUV(uvs[2]);
      }
      function f4(a, b, c2, d) {
        addVertex(a);
        addVertex(b);
        addVertex(d);
        addVertex(b);
        addVertex(c2);
        addVertex(d);
        const nextIndex = verticesArray.length / 3;
        const uvs = uvgen.generateSideWallUV(scope, verticesArray, nextIndex - 6, nextIndex - 3, nextIndex - 2, nextIndex - 1);
        addUV(uvs[0]);
        addUV(uvs[1]);
        addUV(uvs[3]);
        addUV(uvs[1]);
        addUV(uvs[2]);
        addUV(uvs[3]);
      }
      function addVertex(index2) {
        verticesArray.push(placeholder[index2 * 3 + 0]);
        verticesArray.push(placeholder[index2 * 3 + 1]);
        verticesArray.push(placeholder[index2 * 3 + 2]);
      }
      function addUV(vector2) {
        uvArray.push(vector2.x);
        uvArray.push(vector2.y);
      }
    }
  }
  toJSON() {
    const data = super.toJSON();
    const shapes = this.parameters.shapes;
    const options2 = this.parameters.options;
    return toJSON$1(shapes, options2, data);
  }
  static fromJSON(data, shapes) {
    const geometryShapes = [];
    for (let j = 0, jl = data.shapes.length; j < jl; j++) {
      const shape2 = shapes[data.shapes[j]];
      geometryShapes.push(shape2);
    }
    const extrudePath = data.options.extrudePath;
    if (extrudePath !== void 0) {
      data.options.extrudePath = new Curves[extrudePath.type]().fromJSON(extrudePath);
    }
    return new ExtrudeGeometry(geometryShapes, data.options);
  }
}
const WorldUVGenerator = {
  generateTopUV: function(geometry, vertices, indexA, indexB, indexC) {
    const a_x = vertices[indexA * 3];
    const a_y = vertices[indexA * 3 + 1];
    const b_x = vertices[indexB * 3];
    const b_y = vertices[indexB * 3 + 1];
    const c_x = vertices[indexC * 3];
    const c_y = vertices[indexC * 3 + 1];
    return [
      new Vector2(a_x, a_y),
      new Vector2(b_x, b_y),
      new Vector2(c_x, c_y)
    ];
  },
  generateSideWallUV: function(geometry, vertices, indexA, indexB, indexC, indexD) {
    const a_x = vertices[indexA * 3];
    const a_y = vertices[indexA * 3 + 1];
    const a_z = vertices[indexA * 3 + 2];
    const b_x = vertices[indexB * 3];
    const b_y = vertices[indexB * 3 + 1];
    const b_z = vertices[indexB * 3 + 2];
    const c_x = vertices[indexC * 3];
    const c_y = vertices[indexC * 3 + 1];
    const c_z = vertices[indexC * 3 + 2];
    const d_x = vertices[indexD * 3];
    const d_y = vertices[indexD * 3 + 1];
    const d_z = vertices[indexD * 3 + 2];
    if (Math.abs(a_y - b_y) < Math.abs(a_x - b_x)) {
      return [
        new Vector2(a_x, 1 - a_z),
        new Vector2(b_x, 1 - b_z),
        new Vector2(c_x, 1 - c_z),
        new Vector2(d_x, 1 - d_z)
      ];
    } else {
      return [
        new Vector2(a_y, 1 - a_z),
        new Vector2(b_y, 1 - b_z),
        new Vector2(c_y, 1 - c_z),
        new Vector2(d_y, 1 - d_z)
      ];
    }
  }
};
function toJSON$1(shapes, options2, data) {
  data.shapes = [];
  if (Array.isArray(shapes)) {
    for (let i = 0, l = shapes.length; i < l; i++) {
      const shape2 = shapes[i];
      data.shapes.push(shape2.uuid);
    }
  } else {
    data.shapes.push(shapes.uuid);
  }
  if (options2.extrudePath !== void 0)
    data.options.extrudePath = options2.extrudePath.toJSON();
  return data;
}
class IcosahedronGeometry extends PolyhedronGeometry {
  constructor(radius = 1, detail = 0) {
    const t = (1 + Math.sqrt(5)) / 2;
    const vertices = [
      -1,
      t,
      0,
      1,
      t,
      0,
      -1,
      -t,
      0,
      1,
      -t,
      0,
      0,
      -1,
      t,
      0,
      1,
      t,
      0,
      -1,
      -t,
      0,
      1,
      -t,
      t,
      0,
      -1,
      t,
      0,
      1,
      -t,
      0,
      -1,
      -t,
      0,
      1
    ];
    const indices = [
      0,
      11,
      5,
      0,
      5,
      1,
      0,
      1,
      7,
      0,
      7,
      10,
      0,
      10,
      11,
      1,
      5,
      9,
      5,
      11,
      4,
      11,
      10,
      2,
      10,
      7,
      6,
      7,
      1,
      8,
      3,
      9,
      4,
      3,
      4,
      2,
      3,
      2,
      6,
      3,
      6,
      8,
      3,
      8,
      9,
      4,
      9,
      5,
      2,
      4,
      11,
      6,
      2,
      10,
      8,
      6,
      7,
      9,
      8,
      1
    ];
    super(vertices, indices, radius, detail);
    this.type = "IcosahedronGeometry";
    this.parameters = {
      radius,
      detail
    };
  }
  static fromJSON(data) {
    return new IcosahedronGeometry(data.radius, data.detail);
  }
}
class OctahedronGeometry extends PolyhedronGeometry {
  constructor(radius = 1, detail = 0) {
    const vertices = [
      1,
      0,
      0,
      -1,
      0,
      0,
      0,
      1,
      0,
      0,
      -1,
      0,
      0,
      0,
      1,
      0,
      0,
      -1
    ];
    const indices = [
      0,
      2,
      4,
      0,
      4,
      3,
      0,
      3,
      5,
      0,
      5,
      2,
      1,
      2,
      5,
      1,
      5,
      3,
      1,
      3,
      4,
      1,
      4,
      2
    ];
    super(vertices, indices, radius, detail);
    this.type = "OctahedronGeometry";
    this.parameters = {
      radius,
      detail
    };
  }
  static fromJSON(data) {
    return new OctahedronGeometry(data.radius, data.detail);
  }
}
class RingGeometry extends BufferGeometry {
  constructor(innerRadius = 0.5, outerRadius = 1, thetaSegments = 8, phiSegments = 1, thetaStart = 0, thetaLength = Math.PI * 2) {
    super();
    this.type = "RingGeometry";
    this.parameters = {
      innerRadius,
      outerRadius,
      thetaSegments,
      phiSegments,
      thetaStart,
      thetaLength
    };
    thetaSegments = Math.max(3, thetaSegments);
    phiSegments = Math.max(1, phiSegments);
    const indices = [];
    const vertices = [];
    const normals = [];
    const uvs = [];
    let radius = innerRadius;
    const radiusStep = (outerRadius - innerRadius) / phiSegments;
    const vertex2 = new Vector3();
    const uv = new Vector2();
    for (let j = 0; j <= phiSegments; j++) {
      for (let i = 0; i <= thetaSegments; i++) {
        const segment = thetaStart + i / thetaSegments * thetaLength;
        vertex2.x = radius * Math.cos(segment);
        vertex2.y = radius * Math.sin(segment);
        vertices.push(vertex2.x, vertex2.y, vertex2.z);
        normals.push(0, 0, 1);
        uv.x = (vertex2.x / outerRadius + 1) / 2;
        uv.y = (vertex2.y / outerRadius + 1) / 2;
        uvs.push(uv.x, uv.y);
      }
      radius += radiusStep;
    }
    for (let j = 0; j < phiSegments; j++) {
      const thetaSegmentLevel = j * (thetaSegments + 1);
      for (let i = 0; i < thetaSegments; i++) {
        const segment = i + thetaSegmentLevel;
        const a = segment;
        const b = segment + thetaSegments + 1;
        const c2 = segment + thetaSegments + 2;
        const d = segment + 1;
        indices.push(a, b, d);
        indices.push(b, c2, d);
      }
    }
    this.setIndex(indices);
    this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
    this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
  }
  static fromJSON(data) {
    return new RingGeometry(data.innerRadius, data.outerRadius, data.thetaSegments, data.phiSegments, data.thetaStart, data.thetaLength);
  }
}
class ShapeGeometry extends BufferGeometry {
  constructor(shapes = new Shape([new Vector2(0, 0.5), new Vector2(-0.5, -0.5), new Vector2(0.5, -0.5)]), curveSegments = 12) {
    super();
    this.type = "ShapeGeometry";
    this.parameters = {
      shapes,
      curveSegments
    };
    const indices = [];
    const vertices = [];
    const normals = [];
    const uvs = [];
    let groupStart = 0;
    let groupCount = 0;
    if (Array.isArray(shapes) === false) {
      addShape(shapes);
    } else {
      for (let i = 0; i < shapes.length; i++) {
        addShape(shapes[i]);
        this.addGroup(groupStart, groupCount, i);
        groupStart += groupCount;
        groupCount = 0;
      }
    }
    this.setIndex(indices);
    this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
    this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
    function addShape(shape2) {
      const indexOffset = vertices.length / 3;
      const points = shape2.extractPoints(curveSegments);
      let shapeVertices = points.shape;
      const shapeHoles = points.holes;
      if (ShapeUtils.isClockWise(shapeVertices) === false) {
        shapeVertices = shapeVertices.reverse();
      }
      for (let i = 0, l = shapeHoles.length; i < l; i++) {
        const shapeHole = shapeHoles[i];
        if (ShapeUtils.isClockWise(shapeHole) === true) {
          shapeHoles[i] = shapeHole.reverse();
        }
      }
      const faces = ShapeUtils.triangulateShape(shapeVertices, shapeHoles);
      for (let i = 0, l = shapeHoles.length; i < l; i++) {
        const shapeHole = shapeHoles[i];
        shapeVertices = shapeVertices.concat(shapeHole);
      }
      for (let i = 0, l = shapeVertices.length; i < l; i++) {
        const vertex2 = shapeVertices[i];
        vertices.push(vertex2.x, vertex2.y, 0);
        normals.push(0, 0, 1);
        uvs.push(vertex2.x, vertex2.y);
      }
      for (let i = 0, l = faces.length; i < l; i++) {
        const face2 = faces[i];
        const a = face2[0] + indexOffset;
        const b = face2[1] + indexOffset;
        const c2 = face2[2] + indexOffset;
        indices.push(a, b, c2);
        groupCount += 3;
      }
    }
  }
  toJSON() {
    const data = super.toJSON();
    const shapes = this.parameters.shapes;
    return toJSON(shapes, data);
  }
  static fromJSON(data, shapes) {
    const geometryShapes = [];
    for (let j = 0, jl = data.shapes.length; j < jl; j++) {
      const shape2 = shapes[data.shapes[j]];
      geometryShapes.push(shape2);
    }
    return new ShapeGeometry(geometryShapes, data.curveSegments);
  }
}
function toJSON(shapes, data) {
  data.shapes = [];
  if (Array.isArray(shapes)) {
    for (let i = 0, l = shapes.length; i < l; i++) {
      const shape2 = shapes[i];
      data.shapes.push(shape2.uuid);
    }
  } else {
    data.shapes.push(shapes.uuid);
  }
  return data;
}
class SphereGeometry extends BufferGeometry {
  constructor(radius = 1, widthSegments = 32, heightSegments = 16, phiStart = 0, phiLength = Math.PI * 2, thetaStart = 0, thetaLength = Math.PI) {
    super();
    this.type = "SphereGeometry";
    this.parameters = {
      radius,
      widthSegments,
      heightSegments,
      phiStart,
      phiLength,
      thetaStart,
      thetaLength
    };
    widthSegments = Math.max(3, Math.floor(widthSegments));
    heightSegments = Math.max(2, Math.floor(heightSegments));
    const thetaEnd = Math.min(thetaStart + thetaLength, Math.PI);
    let index2 = 0;
    const grid2 = [];
    const vertex2 = new Vector3();
    const normal = new Vector3();
    const indices = [];
    const vertices = [];
    const normals = [];
    const uvs = [];
    for (let iy = 0; iy <= heightSegments; iy++) {
      const verticesRow = [];
      const v = iy / heightSegments;
      let uOffset = 0;
      if (iy == 0 && thetaStart == 0) {
        uOffset = 0.5 / widthSegments;
      } else if (iy == heightSegments && thetaEnd == Math.PI) {
        uOffset = -0.5 / widthSegments;
      }
      for (let ix = 0; ix <= widthSegments; ix++) {
        const u = ix / widthSegments;
        vertex2.x = -radius * Math.cos(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);
        vertex2.y = radius * Math.cos(thetaStart + v * thetaLength);
        vertex2.z = radius * Math.sin(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);
        vertices.push(vertex2.x, vertex2.y, vertex2.z);
        normal.copy(vertex2).normalize();
        normals.push(normal.x, normal.y, normal.z);
        uvs.push(u + uOffset, 1 - v);
        verticesRow.push(index2++);
      }
      grid2.push(verticesRow);
    }
    for (let iy = 0; iy < heightSegments; iy++) {
      for (let ix = 0; ix < widthSegments; ix++) {
        const a = grid2[iy][ix + 1];
        const b = grid2[iy][ix];
        const c2 = grid2[iy + 1][ix];
        const d = grid2[iy + 1][ix + 1];
        if (iy !== 0 || thetaStart > 0)
          indices.push(a, b, d);
        if (iy !== heightSegments - 1 || thetaEnd < Math.PI)
          indices.push(b, c2, d);
      }
    }
    this.setIndex(indices);
    this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
    this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
  }
  static fromJSON(data) {
    return new SphereGeometry(data.radius, data.widthSegments, data.heightSegments, data.phiStart, data.phiLength, data.thetaStart, data.thetaLength);
  }
}
class TetrahedronGeometry extends PolyhedronGeometry {
  constructor(radius = 1, detail = 0) {
    const vertices = [
      1,
      1,
      1,
      -1,
      -1,
      1,
      -1,
      1,
      -1,
      1,
      -1,
      -1
    ];
    const indices = [
      2,
      1,
      0,
      0,
      3,
      2,
      1,
      3,
      0,
      2,
      3,
      1
    ];
    super(vertices, indices, radius, detail);
    this.type = "TetrahedronGeometry";
    this.parameters = {
      radius,
      detail
    };
  }
  static fromJSON(data) {
    return new TetrahedronGeometry(data.radius, data.detail);
  }
}
class TorusGeometry extends BufferGeometry {
  constructor(radius = 1, tube = 0.4, radialSegments = 8, tubularSegments = 6, arc = Math.PI * 2) {
    super();
    this.type = "TorusGeometry";
    this.parameters = {
      radius,
      tube,
      radialSegments,
      tubularSegments,
      arc
    };
    radialSegments = Math.floor(radialSegments);
    tubularSegments = Math.floor(tubularSegments);
    const indices = [];
    const vertices = [];
    const normals = [];
    const uvs = [];
    const center2 = new Vector3();
    const vertex2 = new Vector3();
    const normal = new Vector3();
    for (let j = 0; j <= radialSegments; j++) {
      for (let i = 0; i <= tubularSegments; i++) {
        const u = i / tubularSegments * arc;
        const v = j / radialSegments * Math.PI * 2;
        vertex2.x = (radius + tube * Math.cos(v)) * Math.cos(u);
        vertex2.y = (radius + tube * Math.cos(v)) * Math.sin(u);
        vertex2.z = tube * Math.sin(v);
        vertices.push(vertex2.x, vertex2.y, vertex2.z);
        center2.x = radius * Math.cos(u);
        center2.y = radius * Math.sin(u);
        normal.subVectors(vertex2, center2).normalize();
        normals.push(normal.x, normal.y, normal.z);
        uvs.push(i / tubularSegments);
        uvs.push(j / radialSegments);
      }
    }
    for (let j = 1; j <= radialSegments; j++) {
      for (let i = 1; i <= tubularSegments; i++) {
        const a = (tubularSegments + 1) * j + i - 1;
        const b = (tubularSegments + 1) * (j - 1) + i - 1;
        const c2 = (tubularSegments + 1) * (j - 1) + i;
        const d = (tubularSegments + 1) * j + i;
        indices.push(a, b, d);
        indices.push(b, c2, d);
      }
    }
    this.setIndex(indices);
    this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
    this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
  }
  static fromJSON(data) {
    return new TorusGeometry(data.radius, data.tube, data.radialSegments, data.tubularSegments, data.arc);
  }
}
class TorusKnotGeometry extends BufferGeometry {
  constructor(radius = 1, tube = 0.4, tubularSegments = 64, radialSegments = 8, p = 2, q = 3) {
    super();
    this.type = "TorusKnotGeometry";
    this.parameters = {
      radius,
      tube,
      tubularSegments,
      radialSegments,
      p,
      q
    };
    tubularSegments = Math.floor(tubularSegments);
    radialSegments = Math.floor(radialSegments);
    const indices = [];
    const vertices = [];
    const normals = [];
    const uvs = [];
    const vertex2 = new Vector3();
    const normal = new Vector3();
    const P1 = new Vector3();
    const P2 = new Vector3();
    const B = new Vector3();
    const T = new Vector3();
    const N = new Vector3();
    for (let i = 0; i <= tubularSegments; ++i) {
      const u = i / tubularSegments * p * Math.PI * 2;
      calculatePositionOnCurve(u, p, q, radius, P1);
      calculatePositionOnCurve(u + 0.01, p, q, radius, P2);
      T.subVectors(P2, P1);
      N.addVectors(P2, P1);
      B.crossVectors(T, N);
      N.crossVectors(B, T);
      B.normalize();
      N.normalize();
      for (let j = 0; j <= radialSegments; ++j) {
        const v = j / radialSegments * Math.PI * 2;
        const cx = -tube * Math.cos(v);
        const cy = tube * Math.sin(v);
        vertex2.x = P1.x + (cx * N.x + cy * B.x);
        vertex2.y = P1.y + (cx * N.y + cy * B.y);
        vertex2.z = P1.z + (cx * N.z + cy * B.z);
        vertices.push(vertex2.x, vertex2.y, vertex2.z);
        normal.subVectors(vertex2, P1).normalize();
        normals.push(normal.x, normal.y, normal.z);
        uvs.push(i / tubularSegments);
        uvs.push(j / radialSegments);
      }
    }
    for (let j = 1; j <= tubularSegments; j++) {
      for (let i = 1; i <= radialSegments; i++) {
        const a = (radialSegments + 1) * (j - 1) + (i - 1);
        const b = (radialSegments + 1) * j + (i - 1);
        const c2 = (radialSegments + 1) * j + i;
        const d = (radialSegments + 1) * (j - 1) + i;
        indices.push(a, b, d);
        indices.push(b, c2, d);
      }
    }
    this.setIndex(indices);
    this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
    this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
    function calculatePositionOnCurve(u, p2, q2, radius2, position2) {
      const cu = Math.cos(u);
      const su = Math.sin(u);
      const quOverP = q2 / p2 * u;
      const cs = Math.cos(quOverP);
      position2.x = radius2 * (2 + cs) * 0.5 * cu;
      position2.y = radius2 * (2 + cs) * su * 0.5;
      position2.z = radius2 * Math.sin(quOverP) * 0.5;
    }
  }
  static fromJSON(data) {
    return new TorusKnotGeometry(data.radius, data.tube, data.tubularSegments, data.radialSegments, data.p, data.q);
  }
}
class TubeGeometry extends BufferGeometry {
  constructor(path = new QuadraticBezierCurve3(new Vector3(-1, -1, 0), new Vector3(-1, 1, 0), new Vector3(1, 1, 0)), tubularSegments = 64, radius = 1, radialSegments = 8, closed = false) {
    super();
    this.type = "TubeGeometry";
    this.parameters = {
      path,
      tubularSegments,
      radius,
      radialSegments,
      closed
    };
    const frames = path.computeFrenetFrames(tubularSegments, closed);
    this.tangents = frames.tangents;
    this.normals = frames.normals;
    this.binormals = frames.binormals;
    const vertex2 = new Vector3();
    const normal = new Vector3();
    const uv = new Vector2();
    let P = new Vector3();
    const vertices = [];
    const normals = [];
    const uvs = [];
    const indices = [];
    generateBufferData();
    this.setIndex(indices);
    this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
    this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
    function generateBufferData() {
      for (let i = 0; i < tubularSegments; i++) {
        generateSegment(i);
      }
      generateSegment(closed === false ? tubularSegments : 0);
      generateUVs();
      generateIndices();
    }
    function generateSegment(i) {
      P = path.getPointAt(i / tubularSegments, P);
      const N = frames.normals[i];
      const B = frames.binormals[i];
      for (let j = 0; j <= radialSegments; j++) {
        const v = j / radialSegments * Math.PI * 2;
        const sin = Math.sin(v);
        const cos = -Math.cos(v);
        normal.x = cos * N.x + sin * B.x;
        normal.y = cos * N.y + sin * B.y;
        normal.z = cos * N.z + sin * B.z;
        normal.normalize();
        normals.push(normal.x, normal.y, normal.z);
        vertex2.x = P.x + radius * normal.x;
        vertex2.y = P.y + radius * normal.y;
        vertex2.z = P.z + radius * normal.z;
        vertices.push(vertex2.x, vertex2.y, vertex2.z);
      }
    }
    function generateIndices() {
      for (let j = 1; j <= tubularSegments; j++) {
        for (let i = 1; i <= radialSegments; i++) {
          const a = (radialSegments + 1) * (j - 1) + (i - 1);
          const b = (radialSegments + 1) * j + (i - 1);
          const c2 = (radialSegments + 1) * j + i;
          const d = (radialSegments + 1) * (j - 1) + i;
          indices.push(a, b, d);
          indices.push(b, c2, d);
        }
      }
    }
    function generateUVs() {
      for (let i = 0; i <= tubularSegments; i++) {
        for (let j = 0; j <= radialSegments; j++) {
          uv.x = i / tubularSegments;
          uv.y = j / radialSegments;
          uvs.push(uv.x, uv.y);
        }
      }
    }
  }
  toJSON() {
    const data = super.toJSON();
    data.path = this.parameters.path.toJSON();
    return data;
  }
  static fromJSON(data) {
    return new TubeGeometry(new Curves[data.path.type]().fromJSON(data.path), data.tubularSegments, data.radius, data.radialSegments, data.closed);
  }
}
class WireframeGeometry extends BufferGeometry {
  constructor(geometry = null) {
    super();
    this.type = "WireframeGeometry";
    this.parameters = {
      geometry
    };
    if (geometry !== null) {
      const vertices = [];
      const edges = /* @__PURE__ */ new Set();
      const start2 = new Vector3();
      const end2 = new Vector3();
      if (geometry.index !== null) {
        const position2 = geometry.attributes.position;
        const indices = geometry.index;
        let groups = geometry.groups;
        if (groups.length === 0) {
          groups = [{ start: 0, count: indices.count, materialIndex: 0 }];
        }
        for (let o = 0, ol = groups.length; o < ol; ++o) {
          const group2 = groups[o];
          const groupStart = group2.start;
          const groupCount = group2.count;
          for (let i = groupStart, l = groupStart + groupCount; i < l; i += 3) {
            for (let j = 0; j < 3; j++) {
              const index1 = indices.getX(i + j);
              const index2 = indices.getX(i + (j + 1) % 3);
              start2.fromBufferAttribute(position2, index1);
              end2.fromBufferAttribute(position2, index2);
              if (isUniqueEdge(start2, end2, edges) === true) {
                vertices.push(start2.x, start2.y, start2.z);
                vertices.push(end2.x, end2.y, end2.z);
              }
            }
          }
        }
      } else {
        const position2 = geometry.attributes.position;
        for (let i = 0, l = position2.count / 3; i < l; i++) {
          for (let j = 0; j < 3; j++) {
            const index1 = 3 * i + j;
            const index2 = 3 * i + (j + 1) % 3;
            start2.fromBufferAttribute(position2, index1);
            end2.fromBufferAttribute(position2, index2);
            if (isUniqueEdge(start2, end2, edges) === true) {
              vertices.push(start2.x, start2.y, start2.z);
              vertices.push(end2.x, end2.y, end2.z);
            }
          }
        }
      }
      this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    }
  }
}
function isUniqueEdge(start2, end2, edges) {
  const hash1 = `${start2.x},${start2.y},${start2.z}-${end2.x},${end2.y},${end2.z}`;
  const hash2 = `${end2.x},${end2.y},${end2.z}-${start2.x},${start2.y},${start2.z}`;
  if (edges.has(hash1) === true || edges.has(hash2) === true) {
    return false;
  } else {
    edges.add(hash1);
    edges.add(hash2);
    return true;
  }
}
var Geometries = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  BoxGeometry,
  BoxBufferGeometry: BoxGeometry,
  CapsuleGeometry,
  CapsuleBufferGeometry: CapsuleGeometry,
  CircleGeometry,
  CircleBufferGeometry: CircleGeometry,
  ConeGeometry,
  ConeBufferGeometry: ConeGeometry,
  CylinderGeometry,
  CylinderBufferGeometry: CylinderGeometry,
  DodecahedronGeometry,
  DodecahedronBufferGeometry: DodecahedronGeometry,
  EdgesGeometry,
  ExtrudeGeometry,
  ExtrudeBufferGeometry: ExtrudeGeometry,
  IcosahedronGeometry,
  IcosahedronBufferGeometry: IcosahedronGeometry,
  LatheGeometry,
  LatheBufferGeometry: LatheGeometry,
  OctahedronGeometry,
  OctahedronBufferGeometry: OctahedronGeometry,
  PlaneGeometry,
  PlaneBufferGeometry: PlaneGeometry,
  PolyhedronGeometry,
  PolyhedronBufferGeometry: PolyhedronGeometry,
  RingGeometry,
  RingBufferGeometry: RingGeometry,
  ShapeGeometry,
  ShapeBufferGeometry: ShapeGeometry,
  SphereGeometry,
  SphereBufferGeometry: SphereGeometry,
  TetrahedronGeometry,
  TetrahedronBufferGeometry: TetrahedronGeometry,
  TorusGeometry,
  TorusBufferGeometry: TorusGeometry,
  TorusKnotGeometry,
  TorusKnotBufferGeometry: TorusKnotGeometry,
  TubeGeometry,
  TubeBufferGeometry: TubeGeometry,
  WireframeGeometry
});
class ShadowMaterial extends Material {
  constructor(parameters) {
    super();
    this.type = "ShadowMaterial";
    this.color = new Color(0);
    this.transparent = true;
    this.setValues(parameters);
  }
  copy(source2) {
    super.copy(source2);
    this.color.copy(source2.color);
    return this;
  }
}
ShadowMaterial.prototype.isShadowMaterial = true;
class RawShaderMaterial extends ShaderMaterial {
  constructor(parameters) {
    super(parameters);
    this.type = "RawShaderMaterial";
  }
}
RawShaderMaterial.prototype.isRawShaderMaterial = true;
class MeshStandardMaterial extends Material {
  constructor(parameters) {
    super();
    this.defines = { "STANDARD": "" };
    this.type = "MeshStandardMaterial";
    this.color = new Color(16777215);
    this.roughness = 1;
    this.metalness = 0;
    this.map = null;
    this.lightMap = null;
    this.lightMapIntensity = 1;
    this.aoMap = null;
    this.aoMapIntensity = 1;
    this.emissive = new Color(0);
    this.emissiveIntensity = 1;
    this.emissiveMap = null;
    this.bumpMap = null;
    this.bumpScale = 1;
    this.normalMap = null;
    this.normalMapType = TangentSpaceNormalMap;
    this.normalScale = new Vector2(1, 1);
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.roughnessMap = null;
    this.metalnessMap = null;
    this.alphaMap = null;
    this.envMap = null;
    this.envMapIntensity = 1;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.wireframeLinecap = "round";
    this.wireframeLinejoin = "round";
    this.flatShading = false;
    this.setValues(parameters);
  }
  copy(source2) {
    super.copy(source2);
    this.defines = { "STANDARD": "" };
    this.color.copy(source2.color);
    this.roughness = source2.roughness;
    this.metalness = source2.metalness;
    this.map = source2.map;
    this.lightMap = source2.lightMap;
    this.lightMapIntensity = source2.lightMapIntensity;
    this.aoMap = source2.aoMap;
    this.aoMapIntensity = source2.aoMapIntensity;
    this.emissive.copy(source2.emissive);
    this.emissiveMap = source2.emissiveMap;
    this.emissiveIntensity = source2.emissiveIntensity;
    this.bumpMap = source2.bumpMap;
    this.bumpScale = source2.bumpScale;
    this.normalMap = source2.normalMap;
    this.normalMapType = source2.normalMapType;
    this.normalScale.copy(source2.normalScale);
    this.displacementMap = source2.displacementMap;
    this.displacementScale = source2.displacementScale;
    this.displacementBias = source2.displacementBias;
    this.roughnessMap = source2.roughnessMap;
    this.metalnessMap = source2.metalnessMap;
    this.alphaMap = source2.alphaMap;
    this.envMap = source2.envMap;
    this.envMapIntensity = source2.envMapIntensity;
    this.wireframe = source2.wireframe;
    this.wireframeLinewidth = source2.wireframeLinewidth;
    this.wireframeLinecap = source2.wireframeLinecap;
    this.wireframeLinejoin = source2.wireframeLinejoin;
    this.flatShading = source2.flatShading;
    return this;
  }
}
MeshStandardMaterial.prototype.isMeshStandardMaterial = true;
class MeshPhysicalMaterial extends MeshStandardMaterial {
  constructor(parameters) {
    super();
    this.defines = {
      "STANDARD": "",
      "PHYSICAL": ""
    };
    this.type = "MeshPhysicalMaterial";
    this.clearcoatMap = null;
    this.clearcoatRoughness = 0;
    this.clearcoatRoughnessMap = null;
    this.clearcoatNormalScale = new Vector2(1, 1);
    this.clearcoatNormalMap = null;
    this.ior = 1.5;
    Object.defineProperty(this, "reflectivity", {
      get: function() {
        return clamp(2.5 * (this.ior - 1) / (this.ior + 1), 0, 1);
      },
      set: function(reflectivity) {
        this.ior = (1 + 0.4 * reflectivity) / (1 - 0.4 * reflectivity);
      }
    });
    this.sheenColor = new Color(0);
    this.sheenColorMap = null;
    this.sheenRoughness = 1;
    this.sheenRoughnessMap = null;
    this.transmissionMap = null;
    this.thickness = 0;
    this.thicknessMap = null;
    this.attenuationDistance = 0;
    this.attenuationColor = new Color(1, 1, 1);
    this.specularIntensity = 1;
    this.specularIntensityMap = null;
    this.specularColor = new Color(1, 1, 1);
    this.specularColorMap = null;
    this._sheen = 0;
    this._clearcoat = 0;
    this._transmission = 0;
    this.setValues(parameters);
  }
  get sheen() {
    return this._sheen;
  }
  set sheen(value) {
    if (this._sheen > 0 !== value > 0) {
      this.version++;
    }
    this._sheen = value;
  }
  get clearcoat() {
    return this._clearcoat;
  }
  set clearcoat(value) {
    if (this._clearcoat > 0 !== value > 0) {
      this.version++;
    }
    this._clearcoat = value;
  }
  get transmission() {
    return this._transmission;
  }
  set transmission(value) {
    if (this._transmission > 0 !== value > 0) {
      this.version++;
    }
    this._transmission = value;
  }
  copy(source2) {
    super.copy(source2);
    this.defines = {
      "STANDARD": "",
      "PHYSICAL": ""
    };
    this.clearcoat = source2.clearcoat;
    this.clearcoatMap = source2.clearcoatMap;
    this.clearcoatRoughness = source2.clearcoatRoughness;
    this.clearcoatRoughnessMap = source2.clearcoatRoughnessMap;
    this.clearcoatNormalMap = source2.clearcoatNormalMap;
    this.clearcoatNormalScale.copy(source2.clearcoatNormalScale);
    this.ior = source2.ior;
    this.sheen = source2.sheen;
    this.sheenColor.copy(source2.sheenColor);
    this.sheenColorMap = source2.sheenColorMap;
    this.sheenRoughness = source2.sheenRoughness;
    this.sheenRoughnessMap = source2.sheenRoughnessMap;
    this.transmission = source2.transmission;
    this.transmissionMap = source2.transmissionMap;
    this.thickness = source2.thickness;
    this.thicknessMap = source2.thicknessMap;
    this.attenuationDistance = source2.attenuationDistance;
    this.attenuationColor.copy(source2.attenuationColor);
    this.specularIntensity = source2.specularIntensity;
    this.specularIntensityMap = source2.specularIntensityMap;
    this.specularColor.copy(source2.specularColor);
    this.specularColorMap = source2.specularColorMap;
    return this;
  }
}
MeshPhysicalMaterial.prototype.isMeshPhysicalMaterial = true;
class MeshPhongMaterial extends Material {
  constructor(parameters) {
    super();
    this.type = "MeshPhongMaterial";
    this.color = new Color(16777215);
    this.specular = new Color(1118481);
    this.shininess = 30;
    this.map = null;
    this.lightMap = null;
    this.lightMapIntensity = 1;
    this.aoMap = null;
    this.aoMapIntensity = 1;
    this.emissive = new Color(0);
    this.emissiveIntensity = 1;
    this.emissiveMap = null;
    this.bumpMap = null;
    this.bumpScale = 1;
    this.normalMap = null;
    this.normalMapType = TangentSpaceNormalMap;
    this.normalScale = new Vector2(1, 1);
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.specularMap = null;
    this.alphaMap = null;
    this.envMap = null;
    this.combine = MultiplyOperation;
    this.reflectivity = 1;
    this.refractionRatio = 0.98;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.wireframeLinecap = "round";
    this.wireframeLinejoin = "round";
    this.flatShading = false;
    this.setValues(parameters);
  }
  copy(source2) {
    super.copy(source2);
    this.color.copy(source2.color);
    this.specular.copy(source2.specular);
    this.shininess = source2.shininess;
    this.map = source2.map;
    this.lightMap = source2.lightMap;
    this.lightMapIntensity = source2.lightMapIntensity;
    this.aoMap = source2.aoMap;
    this.aoMapIntensity = source2.aoMapIntensity;
    this.emissive.copy(source2.emissive);
    this.emissiveMap = source2.emissiveMap;
    this.emissiveIntensity = source2.emissiveIntensity;
    this.bumpMap = source2.bumpMap;
    this.bumpScale = source2.bumpScale;
    this.normalMap = source2.normalMap;
    this.normalMapType = source2.normalMapType;
    this.normalScale.copy(source2.normalScale);
    this.displacementMap = source2.displacementMap;
    this.displacementScale = source2.displacementScale;
    this.displacementBias = source2.displacementBias;
    this.specularMap = source2.specularMap;
    this.alphaMap = source2.alphaMap;
    this.envMap = source2.envMap;
    this.combine = source2.combine;
    this.reflectivity = source2.reflectivity;
    this.refractionRatio = source2.refractionRatio;
    this.wireframe = source2.wireframe;
    this.wireframeLinewidth = source2.wireframeLinewidth;
    this.wireframeLinecap = source2.wireframeLinecap;
    this.wireframeLinejoin = source2.wireframeLinejoin;
    this.flatShading = source2.flatShading;
    return this;
  }
}
MeshPhongMaterial.prototype.isMeshPhongMaterial = true;
class MeshToonMaterial extends Material {
  constructor(parameters) {
    super();
    this.defines = { "TOON": "" };
    this.type = "MeshToonMaterial";
    this.color = new Color(16777215);
    this.map = null;
    this.gradientMap = null;
    this.lightMap = null;
    this.lightMapIntensity = 1;
    this.aoMap = null;
    this.aoMapIntensity = 1;
    this.emissive = new Color(0);
    this.emissiveIntensity = 1;
    this.emissiveMap = null;
    this.bumpMap = null;
    this.bumpScale = 1;
    this.normalMap = null;
    this.normalMapType = TangentSpaceNormalMap;
    this.normalScale = new Vector2(1, 1);
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.alphaMap = null;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.wireframeLinecap = "round";
    this.wireframeLinejoin = "round";
    this.setValues(parameters);
  }
  copy(source2) {
    super.copy(source2);
    this.color.copy(source2.color);
    this.map = source2.map;
    this.gradientMap = source2.gradientMap;
    this.lightMap = source2.lightMap;
    this.lightMapIntensity = source2.lightMapIntensity;
    this.aoMap = source2.aoMap;
    this.aoMapIntensity = source2.aoMapIntensity;
    this.emissive.copy(source2.emissive);
    this.emissiveMap = source2.emissiveMap;
    this.emissiveIntensity = source2.emissiveIntensity;
    this.bumpMap = source2.bumpMap;
    this.bumpScale = source2.bumpScale;
    this.normalMap = source2.normalMap;
    this.normalMapType = source2.normalMapType;
    this.normalScale.copy(source2.normalScale);
    this.displacementMap = source2.displacementMap;
    this.displacementScale = source2.displacementScale;
    this.displacementBias = source2.displacementBias;
    this.alphaMap = source2.alphaMap;
    this.wireframe = source2.wireframe;
    this.wireframeLinewidth = source2.wireframeLinewidth;
    this.wireframeLinecap = source2.wireframeLinecap;
    this.wireframeLinejoin = source2.wireframeLinejoin;
    return this;
  }
}
MeshToonMaterial.prototype.isMeshToonMaterial = true;
class MeshNormalMaterial extends Material {
  constructor(parameters) {
    super();
    this.type = "MeshNormalMaterial";
    this.bumpMap = null;
    this.bumpScale = 1;
    this.normalMap = null;
    this.normalMapType = TangentSpaceNormalMap;
    this.normalScale = new Vector2(1, 1);
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.fog = false;
    this.flatShading = false;
    this.setValues(parameters);
  }
  copy(source2) {
    super.copy(source2);
    this.bumpMap = source2.bumpMap;
    this.bumpScale = source2.bumpScale;
    this.normalMap = source2.normalMap;
    this.normalMapType = source2.normalMapType;
    this.normalScale.copy(source2.normalScale);
    this.displacementMap = source2.displacementMap;
    this.displacementScale = source2.displacementScale;
    this.displacementBias = source2.displacementBias;
    this.wireframe = source2.wireframe;
    this.wireframeLinewidth = source2.wireframeLinewidth;
    this.flatShading = source2.flatShading;
    return this;
  }
}
MeshNormalMaterial.prototype.isMeshNormalMaterial = true;
class MeshLambertMaterial extends Material {
  constructor(parameters) {
    super();
    this.type = "MeshLambertMaterial";
    this.color = new Color(16777215);
    this.map = null;
    this.lightMap = null;
    this.lightMapIntensity = 1;
    this.aoMap = null;
    this.aoMapIntensity = 1;
    this.emissive = new Color(0);
    this.emissiveIntensity = 1;
    this.emissiveMap = null;
    this.specularMap = null;
    this.alphaMap = null;
    this.envMap = null;
    this.combine = MultiplyOperation;
    this.reflectivity = 1;
    this.refractionRatio = 0.98;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.wireframeLinecap = "round";
    this.wireframeLinejoin = "round";
    this.setValues(parameters);
  }
  copy(source2) {
    super.copy(source2);
    this.color.copy(source2.color);
    this.map = source2.map;
    this.lightMap = source2.lightMap;
    this.lightMapIntensity = source2.lightMapIntensity;
    this.aoMap = source2.aoMap;
    this.aoMapIntensity = source2.aoMapIntensity;
    this.emissive.copy(source2.emissive);
    this.emissiveMap = source2.emissiveMap;
    this.emissiveIntensity = source2.emissiveIntensity;
    this.specularMap = source2.specularMap;
    this.alphaMap = source2.alphaMap;
    this.envMap = source2.envMap;
    this.combine = source2.combine;
    this.reflectivity = source2.reflectivity;
    this.refractionRatio = source2.refractionRatio;
    this.wireframe = source2.wireframe;
    this.wireframeLinewidth = source2.wireframeLinewidth;
    this.wireframeLinecap = source2.wireframeLinecap;
    this.wireframeLinejoin = source2.wireframeLinejoin;
    return this;
  }
}
MeshLambertMaterial.prototype.isMeshLambertMaterial = true;
class MeshMatcapMaterial extends Material {
  constructor(parameters) {
    super();
    this.defines = { "MATCAP": "" };
    this.type = "MeshMatcapMaterial";
    this.color = new Color(16777215);
    this.matcap = null;
    this.map = null;
    this.bumpMap = null;
    this.bumpScale = 1;
    this.normalMap = null;
    this.normalMapType = TangentSpaceNormalMap;
    this.normalScale = new Vector2(1, 1);
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.alphaMap = null;
    this.flatShading = false;
    this.setValues(parameters);
  }
  copy(source2) {
    super.copy(source2);
    this.defines = { "MATCAP": "" };
    this.color.copy(source2.color);
    this.matcap = source2.matcap;
    this.map = source2.map;
    this.bumpMap = source2.bumpMap;
    this.bumpScale = source2.bumpScale;
    this.normalMap = source2.normalMap;
    this.normalMapType = source2.normalMapType;
    this.normalScale.copy(source2.normalScale);
    this.displacementMap = source2.displacementMap;
    this.displacementScale = source2.displacementScale;
    this.displacementBias = source2.displacementBias;
    this.alphaMap = source2.alphaMap;
    this.flatShading = source2.flatShading;
    return this;
  }
}
MeshMatcapMaterial.prototype.isMeshMatcapMaterial = true;
class LineDashedMaterial extends LineBasicMaterial {
  constructor(parameters) {
    super();
    this.type = "LineDashedMaterial";
    this.scale = 1;
    this.dashSize = 3;
    this.gapSize = 1;
    this.setValues(parameters);
  }
  copy(source2) {
    super.copy(source2);
    this.scale = source2.scale;
    this.dashSize = source2.dashSize;
    this.gapSize = source2.gapSize;
    return this;
  }
}
LineDashedMaterial.prototype.isLineDashedMaterial = true;
const materialLib = {
  ShadowMaterial,
  SpriteMaterial,
  RawShaderMaterial,
  ShaderMaterial,
  PointsMaterial,
  MeshPhysicalMaterial,
  MeshStandardMaterial,
  MeshPhongMaterial,
  MeshToonMaterial,
  MeshNormalMaterial,
  MeshLambertMaterial,
  MeshDepthMaterial,
  MeshDistanceMaterial,
  MeshBasicMaterial,
  MeshMatcapMaterial,
  LineDashedMaterial,
  LineBasicMaterial,
  Material
};
Material.fromType = function(type) {
  return new materialLib[type]();
};
const AnimationUtils = {
  arraySlice: function(array, from, to) {
    if (AnimationUtils.isTypedArray(array)) {
      return new array.constructor(array.subarray(from, to !== void 0 ? to : array.length));
    }
    return array.slice(from, to);
  },
  convertArray: function(array, type, forceClone) {
    if (!array || !forceClone && array.constructor === type)
      return array;
    if (typeof type.BYTES_PER_ELEMENT === "number") {
      return new type(array);
    }
    return Array.prototype.slice.call(array);
  },
  isTypedArray: function(object) {
    return ArrayBuffer.isView(object) && !(object instanceof DataView);
  },
  getKeyframeOrder: function(times) {
    function compareTime(i, j) {
      return times[i] - times[j];
    }
    const n = times.length;
    const result = new Array(n);
    for (let i = 0; i !== n; ++i)
      result[i] = i;
    result.sort(compareTime);
    return result;
  },
  sortedArray: function(values, stride, order) {
    const nValues = values.length;
    const result = new values.constructor(nValues);
    for (let i = 0, dstOffset = 0; dstOffset !== nValues; ++i) {
      const srcOffset = order[i] * stride;
      for (let j = 0; j !== stride; ++j) {
        result[dstOffset++] = values[srcOffset + j];
      }
    }
    return result;
  },
  flattenJSON: function(jsonKeys, times, values, valuePropertyName) {
    let i = 1, key = jsonKeys[0];
    while (key !== void 0 && key[valuePropertyName] === void 0) {
      key = jsonKeys[i++];
    }
    if (key === void 0)
      return;
    let value = key[valuePropertyName];
    if (value === void 0)
      return;
    if (Array.isArray(value)) {
      do {
        value = key[valuePropertyName];
        if (value !== void 0) {
          times.push(key.time);
          values.push.apply(values, value);
        }
        key = jsonKeys[i++];
      } while (key !== void 0);
    } else if (value.toArray !== void 0) {
      do {
        value = key[valuePropertyName];
        if (value !== void 0) {
          times.push(key.time);
          value.toArray(values, values.length);
        }
        key = jsonKeys[i++];
      } while (key !== void 0);
    } else {
      do {
        value = key[valuePropertyName];
        if (value !== void 0) {
          times.push(key.time);
          values.push(value);
        }
        key = jsonKeys[i++];
      } while (key !== void 0);
    }
  },
  subclip: function(sourceClip, name, startFrame, endFrame, fps = 30) {
    const clip = sourceClip.clone();
    clip.name = name;
    const tracks = [];
    for (let i = 0; i < clip.tracks.length; ++i) {
      const track = clip.tracks[i];
      const valueSize = track.getValueSize();
      const times = [];
      const values = [];
      for (let j = 0; j < track.times.length; ++j) {
        const frame = track.times[j] * fps;
        if (frame < startFrame || frame >= endFrame)
          continue;
        times.push(track.times[j]);
        for (let k = 0; k < valueSize; ++k) {
          values.push(track.values[j * valueSize + k]);
        }
      }
      if (times.length === 0)
        continue;
      track.times = AnimationUtils.convertArray(times, track.times.constructor);
      track.values = AnimationUtils.convertArray(values, track.values.constructor);
      tracks.push(track);
    }
    clip.tracks = tracks;
    let minStartTime = Infinity;
    for (let i = 0; i < clip.tracks.length; ++i) {
      if (minStartTime > clip.tracks[i].times[0]) {
        minStartTime = clip.tracks[i].times[0];
      }
    }
    for (let i = 0; i < clip.tracks.length; ++i) {
      clip.tracks[i].shift(-1 * minStartTime);
    }
    clip.resetDuration();
    return clip;
  },
  makeClipAdditive: function(targetClip, referenceFrame = 0, referenceClip = targetClip, fps = 30) {
    if (fps <= 0)
      fps = 30;
    const numTracks = referenceClip.tracks.length;
    const referenceTime = referenceFrame / fps;
    for (let i = 0; i < numTracks; ++i) {
      const referenceTrack = referenceClip.tracks[i];
      const referenceTrackType = referenceTrack.ValueTypeName;
      if (referenceTrackType === "bool" || referenceTrackType === "string")
        continue;
      const targetTrack = targetClip.tracks.find(function(track) {
        return track.name === referenceTrack.name && track.ValueTypeName === referenceTrackType;
      });
      if (targetTrack === void 0)
        continue;
      let referenceOffset = 0;
      const referenceValueSize = referenceTrack.getValueSize();
      if (referenceTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline) {
        referenceOffset = referenceValueSize / 3;
      }
      let targetOffset = 0;
      const targetValueSize = targetTrack.getValueSize();
      if (targetTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline) {
        targetOffset = targetValueSize / 3;
      }
      const lastIndex = referenceTrack.times.length - 1;
      let referenceValue;
      if (referenceTime <= referenceTrack.times[0]) {
        const startIndex = referenceOffset;
        const endIndex = referenceValueSize - referenceOffset;
        referenceValue = AnimationUtils.arraySlice(referenceTrack.values, startIndex, endIndex);
      } else if (referenceTime >= referenceTrack.times[lastIndex]) {
        const startIndex = lastIndex * referenceValueSize + referenceOffset;
        const endIndex = startIndex + referenceValueSize - referenceOffset;
        referenceValue = AnimationUtils.arraySlice(referenceTrack.values, startIndex, endIndex);
      } else {
        const interpolant = referenceTrack.createInterpolant();
        const startIndex = referenceOffset;
        const endIndex = referenceValueSize - referenceOffset;
        interpolant.evaluate(referenceTime);
        referenceValue = AnimationUtils.arraySlice(interpolant.resultBuffer, startIndex, endIndex);
      }
      if (referenceTrackType === "quaternion") {
        const referenceQuat = new Quaternion().fromArray(referenceValue).normalize().conjugate();
        referenceQuat.toArray(referenceValue);
      }
      const numTimes = targetTrack.times.length;
      for (let j = 0; j < numTimes; ++j) {
        const valueStart = j * targetValueSize + targetOffset;
        if (referenceTrackType === "quaternion") {
          Quaternion.multiplyQuaternionsFlat(targetTrack.values, valueStart, referenceValue, 0, targetTrack.values, valueStart);
        } else {
          const valueEnd = targetValueSize - targetOffset * 2;
          for (let k = 0; k < valueEnd; ++k) {
            targetTrack.values[valueStart + k] -= referenceValue[k];
          }
        }
      }
    }
    targetClip.blendMode = AdditiveAnimationBlendMode;
    return targetClip;
  }
};
class Interpolant {
  constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
    this.parameterPositions = parameterPositions;
    this._cachedIndex = 0;
    this.resultBuffer = resultBuffer !== void 0 ? resultBuffer : new sampleValues.constructor(sampleSize);
    this.sampleValues = sampleValues;
    this.valueSize = sampleSize;
    this.settings = null;
    this.DefaultSettings_ = {};
  }
  evaluate(t) {
    const pp = this.parameterPositions;
    let i1 = this._cachedIndex, t1 = pp[i1], t0 = pp[i1 - 1];
    validate_interval: {
      seek: {
        let right2;
        linear_scan: {
          forward_scan:
            if (!(t < t1)) {
              for (let giveUpAt = i1 + 2; ; ) {
                if (t1 === void 0) {
                  if (t < t0)
                    break forward_scan;
                  i1 = pp.length;
                  this._cachedIndex = i1;
                  return this.afterEnd_(i1 - 1, t, t0);
                }
                if (i1 === giveUpAt)
                  break;
                t0 = t1;
                t1 = pp[++i1];
                if (t < t1) {
                  break seek;
                }
              }
              right2 = pp.length;
              break linear_scan;
            }
          if (!(t >= t0)) {
            const t1global = pp[1];
            if (t < t1global) {
              i1 = 2;
              t0 = t1global;
            }
            for (let giveUpAt = i1 - 2; ; ) {
              if (t0 === void 0) {
                this._cachedIndex = 0;
                return this.beforeStart_(0, t, t1);
              }
              if (i1 === giveUpAt)
                break;
              t1 = t0;
              t0 = pp[--i1 - 1];
              if (t >= t0) {
                break seek;
              }
            }
            right2 = i1;
            i1 = 0;
            break linear_scan;
          }
          break validate_interval;
        }
        while (i1 < right2) {
          const mid = i1 + right2 >>> 1;
          if (t < pp[mid]) {
            right2 = mid;
          } else {
            i1 = mid + 1;
          }
        }
        t1 = pp[i1];
        t0 = pp[i1 - 1];
        if (t0 === void 0) {
          this._cachedIndex = 0;
          return this.beforeStart_(0, t, t1);
        }
        if (t1 === void 0) {
          i1 = pp.length;
          this._cachedIndex = i1;
          return this.afterEnd_(i1 - 1, t0, t);
        }
      }
      this._cachedIndex = i1;
      this.intervalChanged_(i1, t0, t1);
    }
    return this.interpolate_(i1, t0, t, t1);
  }
  getSettings_() {
    return this.settings || this.DefaultSettings_;
  }
  copySampleValue_(index2) {
    const result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, offset = index2 * stride;
    for (let i = 0; i !== stride; ++i) {
      result[i] = values[offset + i];
    }
    return result;
  }
  interpolate_() {
    throw new Error("call to abstract method");
  }
  intervalChanged_() {
  }
}
Interpolant.prototype.beforeStart_ = Interpolant.prototype.copySampleValue_;
Interpolant.prototype.afterEnd_ = Interpolant.prototype.copySampleValue_;
class CubicInterpolant extends Interpolant {
  constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
    super(parameterPositions, sampleValues, sampleSize, resultBuffer);
    this._weightPrev = -0;
    this._offsetPrev = -0;
    this._weightNext = -0;
    this._offsetNext = -0;
    this.DefaultSettings_ = {
      endingStart: ZeroCurvatureEnding,
      endingEnd: ZeroCurvatureEnding
    };
  }
  intervalChanged_(i1, t0, t1) {
    const pp = this.parameterPositions;
    let iPrev = i1 - 2, iNext = i1 + 1, tPrev = pp[iPrev], tNext = pp[iNext];
    if (tPrev === void 0) {
      switch (this.getSettings_().endingStart) {
        case ZeroSlopeEnding:
          iPrev = i1;
          tPrev = 2 * t0 - t1;
          break;
        case WrapAroundEnding:
          iPrev = pp.length - 2;
          tPrev = t0 + pp[iPrev] - pp[iPrev + 1];
          break;
        default:
          iPrev = i1;
          tPrev = t1;
      }
    }
    if (tNext === void 0) {
      switch (this.getSettings_().endingEnd) {
        case ZeroSlopeEnding:
          iNext = i1;
          tNext = 2 * t1 - t0;
          break;
        case WrapAroundEnding:
          iNext = 1;
          tNext = t1 + pp[1] - pp[0];
          break;
        default:
          iNext = i1 - 1;
          tNext = t0;
      }
    }
    const halfDt = (t1 - t0) * 0.5, stride = this.valueSize;
    this._weightPrev = halfDt / (t0 - tPrev);
    this._weightNext = halfDt / (tNext - t1);
    this._offsetPrev = iPrev * stride;
    this._offsetNext = iNext * stride;
  }
  interpolate_(i1, t0, t, t1) {
    const result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, o1 = i1 * stride, o0 = o1 - stride, oP = this._offsetPrev, oN = this._offsetNext, wP = this._weightPrev, wN = this._weightNext, p = (t - t0) / (t1 - t0), pp = p * p, ppp = pp * p;
    const sP = -wP * ppp + 2 * wP * pp - wP * p;
    const s0 = (1 + wP) * ppp + (-1.5 - 2 * wP) * pp + (-0.5 + wP) * p + 1;
    const s1 = (-1 - wN) * ppp + (1.5 + wN) * pp + 0.5 * p;
    const sN = wN * ppp - wN * pp;
    for (let i = 0; i !== stride; ++i) {
      result[i] = sP * values[oP + i] + s0 * values[o0 + i] + s1 * values[o1 + i] + sN * values[oN + i];
    }
    return result;
  }
}
class LinearInterpolant extends Interpolant {
  constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
    super(parameterPositions, sampleValues, sampleSize, resultBuffer);
  }
  interpolate_(i1, t0, t, t1) {
    const result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, offset1 = i1 * stride, offset0 = offset1 - stride, weight1 = (t - t0) / (t1 - t0), weight0 = 1 - weight1;
    for (let i = 0; i !== stride; ++i) {
      result[i] = values[offset0 + i] * weight0 + values[offset1 + i] * weight1;
    }
    return result;
  }
}
class DiscreteInterpolant extends Interpolant {
  constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
    super(parameterPositions, sampleValues, sampleSize, resultBuffer);
  }
  interpolate_(i1) {
    return this.copySampleValue_(i1 - 1);
  }
}
class KeyframeTrack {
  constructor(name, times, values, interpolation) {
    if (name === void 0)
      throw new Error("THREE.KeyframeTrack: track name is undefined");
    if (times === void 0 || times.length === 0)
      throw new Error("THREE.KeyframeTrack: no keyframes in track named " + name);
    this.name = name;
    this.times = AnimationUtils.convertArray(times, this.TimeBufferType);
    this.values = AnimationUtils.convertArray(values, this.ValueBufferType);
    this.setInterpolation(interpolation || this.DefaultInterpolation);
  }
  static toJSON(track) {
    const trackType = track.constructor;
    let json;
    if (trackType.toJSON !== this.toJSON) {
      json = trackType.toJSON(track);
    } else {
      json = {
        "name": track.name,
        "times": AnimationUtils.convertArray(track.times, Array),
        "values": AnimationUtils.convertArray(track.values, Array)
      };
      const interpolation = track.getInterpolation();
      if (interpolation !== track.DefaultInterpolation) {
        json.interpolation = interpolation;
      }
    }
    json.type = track.ValueTypeName;
    return json;
  }
  InterpolantFactoryMethodDiscrete(result) {
    return new DiscreteInterpolant(this.times, this.values, this.getValueSize(), result);
  }
  InterpolantFactoryMethodLinear(result) {
    return new LinearInterpolant(this.times, this.values, this.getValueSize(), result);
  }
  InterpolantFactoryMethodSmooth(result) {
    return new CubicInterpolant(this.times, this.values, this.getValueSize(), result);
  }
  setInterpolation(interpolation) {
    let factoryMethod;
    switch (interpolation) {
      case InterpolateDiscrete:
        factoryMethod = this.InterpolantFactoryMethodDiscrete;
        break;
      case InterpolateLinear:
        factoryMethod = this.InterpolantFactoryMethodLinear;
        break;
      case InterpolateSmooth:
        factoryMethod = this.InterpolantFactoryMethodSmooth;
        break;
    }
    if (factoryMethod === void 0) {
      const message = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
      if (this.createInterpolant === void 0) {
        if (interpolation !== this.DefaultInterpolation) {
          this.setInterpolation(this.DefaultInterpolation);
        } else {
          throw new Error(message);
        }
      }
      console.warn("THREE.KeyframeTrack:", message);
      return this;
    }
    this.createInterpolant = factoryMethod;
    return this;
  }
  getInterpolation() {
    switch (this.createInterpolant) {
      case this.InterpolantFactoryMethodDiscrete:
        return InterpolateDiscrete;
      case this.InterpolantFactoryMethodLinear:
        return InterpolateLinear;
      case this.InterpolantFactoryMethodSmooth:
        return InterpolateSmooth;
    }
  }
  getValueSize() {
    return this.values.length / this.times.length;
  }
  shift(timeOffset) {
    if (timeOffset !== 0) {
      const times = this.times;
      for (let i = 0, n = times.length; i !== n; ++i) {
        times[i] += timeOffset;
      }
    }
    return this;
  }
  scale(timeScale) {
    if (timeScale !== 1) {
      const times = this.times;
      for (let i = 0, n = times.length; i !== n; ++i) {
        times[i] *= timeScale;
      }
    }
    return this;
  }
  trim(startTime, endTime) {
    const times = this.times, nKeys = times.length;
    let from = 0, to = nKeys - 1;
    while (from !== nKeys && times[from] < startTime) {
      ++from;
    }
    while (to !== -1 && times[to] > endTime) {
      --to;
    }
    ++to;
    if (from !== 0 || to !== nKeys) {
      if (from >= to) {
        to = Math.max(to, 1);
        from = to - 1;
      }
      const stride = this.getValueSize();
      this.times = AnimationUtils.arraySlice(times, from, to);
      this.values = AnimationUtils.arraySlice(this.values, from * stride, to * stride);
    }
    return this;
  }
  validate() {
    let valid = true;
    const valueSize = this.getValueSize();
    if (valueSize - Math.floor(valueSize) !== 0) {
      console.error("THREE.KeyframeTrack: Invalid value size in track.", this);
      valid = false;
    }
    const times = this.times, values = this.values, nKeys = times.length;
    if (nKeys === 0) {
      console.error("THREE.KeyframeTrack: Track is empty.", this);
      valid = false;
    }
    let prevTime = null;
    for (let i = 0; i !== nKeys; i++) {
      const currTime = times[i];
      if (typeof currTime === "number" && isNaN(currTime)) {
        console.error("THREE.KeyframeTrack: Time is not a valid number.", this, i, currTime);
        valid = false;
        break;
      }
      if (prevTime !== null && prevTime > currTime) {
        console.error("THREE.KeyframeTrack: Out of order keys.", this, i, currTime, prevTime);
        valid = false;
        break;
      }
      prevTime = currTime;
    }
    if (values !== void 0) {
      if (AnimationUtils.isTypedArray(values)) {
        for (let i = 0, n = values.length; i !== n; ++i) {
          const value = values[i];
          if (isNaN(value)) {
            console.error("THREE.KeyframeTrack: Value is not a valid number.", this, i, value);
            valid = false;
            break;
          }
        }
      }
    }
    return valid;
  }
  optimize() {
    const times = AnimationUtils.arraySlice(this.times), values = AnimationUtils.arraySlice(this.values), stride = this.getValueSize(), smoothInterpolation = this.getInterpolation() === InterpolateSmooth, lastIndex = times.length - 1;
    let writeIndex = 1;
    for (let i = 1; i < lastIndex; ++i) {
      let keep = false;
      const time = times[i];
      const timeNext = times[i + 1];
      if (time !== timeNext && (i !== 1 || time !== times[0])) {
        if (!smoothInterpolation) {
          const offset = i * stride, offsetP = offset - stride, offsetN = offset + stride;
          for (let j = 0; j !== stride; ++j) {
            const value = values[offset + j];
            if (value !== values[offsetP + j] || value !== values[offsetN + j]) {
              keep = true;
              break;
            }
          }
        } else {
          keep = true;
        }
      }
      if (keep) {
        if (i !== writeIndex) {
          times[writeIndex] = times[i];
          const readOffset = i * stride, writeOffset = writeIndex * stride;
          for (let j = 0; j !== stride; ++j) {
            values[writeOffset + j] = values[readOffset + j];
          }
        }
        ++writeIndex;
      }
    }
    if (lastIndex > 0) {
      times[writeIndex] = times[lastIndex];
      for (let readOffset = lastIndex * stride, writeOffset = writeIndex * stride, j = 0; j !== stride; ++j) {
        values[writeOffset + j] = values[readOffset + j];
      }
      ++writeIndex;
    }
    if (writeIndex !== times.length) {
      this.times = AnimationUtils.arraySlice(times, 0, writeIndex);
      this.values = AnimationUtils.arraySlice(values, 0, writeIndex * stride);
    } else {
      this.times = times;
      this.values = values;
    }
    return this;
  }
  clone() {
    const times = AnimationUtils.arraySlice(this.times, 0);
    const values = AnimationUtils.arraySlice(this.values, 0);
    const TypedKeyframeTrack = this.constructor;
    const track = new TypedKeyframeTrack(this.name, times, values);
    track.createInterpolant = this.createInterpolant;
    return track;
  }
}
KeyframeTrack.prototype.TimeBufferType = Float32Array;
KeyframeTrack.prototype.ValueBufferType = Float32Array;
KeyframeTrack.prototype.DefaultInterpolation = InterpolateLinear;
class BooleanKeyframeTrack extends KeyframeTrack {
}
BooleanKeyframeTrack.prototype.ValueTypeName = "bool";
BooleanKeyframeTrack.prototype.ValueBufferType = Array;
BooleanKeyframeTrack.prototype.DefaultInterpolation = InterpolateDiscrete;
BooleanKeyframeTrack.prototype.InterpolantFactoryMethodLinear = void 0;
BooleanKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = void 0;
class ColorKeyframeTrack extends KeyframeTrack {
}
ColorKeyframeTrack.prototype.ValueTypeName = "color";
class NumberKeyframeTrack extends KeyframeTrack {
}
NumberKeyframeTrack.prototype.ValueTypeName = "number";
class QuaternionLinearInterpolant extends Interpolant {
  constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
    super(parameterPositions, sampleValues, sampleSize, resultBuffer);
  }
  interpolate_(i1, t0, t, t1) {
    const result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, alpha2 = (t - t0) / (t1 - t0);
    let offset = i1 * stride;
    for (let end2 = offset + stride; offset !== end2; offset += 4) {
      Quaternion.slerpFlat(result, 0, values, offset - stride, values, offset, alpha2);
    }
    return result;
  }
}
class QuaternionKeyframeTrack extends KeyframeTrack {
  InterpolantFactoryMethodLinear(result) {
    return new QuaternionLinearInterpolant(this.times, this.values, this.getValueSize(), result);
  }
}
QuaternionKeyframeTrack.prototype.ValueTypeName = "quaternion";
QuaternionKeyframeTrack.prototype.DefaultInterpolation = InterpolateLinear;
QuaternionKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = void 0;
class StringKeyframeTrack extends KeyframeTrack {
}
StringKeyframeTrack.prototype.ValueTypeName = "string";
StringKeyframeTrack.prototype.ValueBufferType = Array;
StringKeyframeTrack.prototype.DefaultInterpolation = InterpolateDiscrete;
StringKeyframeTrack.prototype.InterpolantFactoryMethodLinear = void 0;
StringKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = void 0;
class VectorKeyframeTrack extends KeyframeTrack {
}
VectorKeyframeTrack.prototype.ValueTypeName = "vector";
class AnimationClip {
  constructor(name, duration = -1, tracks, blendMode = NormalAnimationBlendMode) {
    this.name = name;
    this.tracks = tracks;
    this.duration = duration;
    this.blendMode = blendMode;
    this.uuid = generateUUID();
    if (this.duration < 0) {
      this.resetDuration();
    }
  }
  static parse(json) {
    const tracks = [], jsonTracks = json.tracks, frameTime = 1 / (json.fps || 1);
    for (let i = 0, n = jsonTracks.length; i !== n; ++i) {
      tracks.push(parseKeyframeTrack(jsonTracks[i]).scale(frameTime));
    }
    const clip = new this(json.name, json.duration, tracks, json.blendMode);
    clip.uuid = json.uuid;
    return clip;
  }
  static toJSON(clip) {
    const tracks = [], clipTracks = clip.tracks;
    const json = {
      "name": clip.name,
      "duration": clip.duration,
      "tracks": tracks,
      "uuid": clip.uuid,
      "blendMode": clip.blendMode
    };
    for (let i = 0, n = clipTracks.length; i !== n; ++i) {
      tracks.push(KeyframeTrack.toJSON(clipTracks[i]));
    }
    return json;
  }
  static CreateFromMorphTargetSequence(name, morphTargetSequence, fps, noLoop) {
    const numMorphTargets = morphTargetSequence.length;
    const tracks = [];
    for (let i = 0; i < numMorphTargets; i++) {
      let times = [];
      let values = [];
      times.push((i + numMorphTargets - 1) % numMorphTargets, i, (i + 1) % numMorphTargets);
      values.push(0, 1, 0);
      const order = AnimationUtils.getKeyframeOrder(times);
      times = AnimationUtils.sortedArray(times, 1, order);
      values = AnimationUtils.sortedArray(values, 1, order);
      if (!noLoop && times[0] === 0) {
        times.push(numMorphTargets);
        values.push(values[0]);
      }
      tracks.push(new NumberKeyframeTrack(".morphTargetInfluences[" + morphTargetSequence[i].name + "]", times, values).scale(1 / fps));
    }
    return new this(name, -1, tracks);
  }
  static findByName(objectOrClipArray, name) {
    let clipArray = objectOrClipArray;
    if (!Array.isArray(objectOrClipArray)) {
      const o = objectOrClipArray;
      clipArray = o.geometry && o.geometry.animations || o.animations;
    }
    for (let i = 0; i < clipArray.length; i++) {
      if (clipArray[i].name === name) {
        return clipArray[i];
      }
    }
    return null;
  }
  static CreateClipsFromMorphTargetSequences(morphTargets, fps, noLoop) {
    const animationToMorphTargets = {};
    const pattern = /^([\w-]*?)([\d]+)$/;
    for (let i = 0, il = morphTargets.length; i < il; i++) {
      const morphTarget = morphTargets[i];
      const parts = morphTarget.name.match(pattern);
      if (parts && parts.length > 1) {
        const name = parts[1];
        let animationMorphTargets = animationToMorphTargets[name];
        if (!animationMorphTargets) {
          animationToMorphTargets[name] = animationMorphTargets = [];
        }
        animationMorphTargets.push(morphTarget);
      }
    }
    const clips = [];
    for (const name in animationToMorphTargets) {
      clips.push(this.CreateFromMorphTargetSequence(name, animationToMorphTargets[name], fps, noLoop));
    }
    return clips;
  }
  static parseAnimation(animation2, bones) {
    if (!animation2) {
      console.error("THREE.AnimationClip: No animation in JSONLoader data.");
      return null;
    }
    const addNonemptyTrack = function(trackType, trackName, animationKeys, propertyName, destTracks) {
      if (animationKeys.length !== 0) {
        const times = [];
        const values = [];
        AnimationUtils.flattenJSON(animationKeys, times, values, propertyName);
        if (times.length !== 0) {
          destTracks.push(new trackType(trackName, times, values));
        }
      }
    };
    const tracks = [];
    const clipName = animation2.name || "default";
    const fps = animation2.fps || 30;
    const blendMode = animation2.blendMode;
    let duration = animation2.length || -1;
    const hierarchyTracks = animation2.hierarchy || [];
    for (let h = 0; h < hierarchyTracks.length; h++) {
      const animationKeys = hierarchyTracks[h].keys;
      if (!animationKeys || animationKeys.length === 0)
        continue;
      if (animationKeys[0].morphTargets) {
        const morphTargetNames = {};
        let k;
        for (k = 0; k < animationKeys.length; k++) {
          if (animationKeys[k].morphTargets) {
            for (let m = 0; m < animationKeys[k].morphTargets.length; m++) {
              morphTargetNames[animationKeys[k].morphTargets[m]] = -1;
            }
          }
        }
        for (const morphTargetName in morphTargetNames) {
          const times = [];
          const values = [];
          for (let m = 0; m !== animationKeys[k].morphTargets.length; ++m) {
            const animationKey = animationKeys[k];
            times.push(animationKey.time);
            values.push(animationKey.morphTarget === morphTargetName ? 1 : 0);
          }
          tracks.push(new NumberKeyframeTrack(".morphTargetInfluence[" + morphTargetName + "]", times, values));
        }
        duration = morphTargetNames.length * fps;
      } else {
        const boneName = ".bones[" + bones[h].name + "]";
        addNonemptyTrack(VectorKeyframeTrack, boneName + ".position", animationKeys, "pos", tracks);
        addNonemptyTrack(QuaternionKeyframeTrack, boneName + ".quaternion", animationKeys, "rot", tracks);
        addNonemptyTrack(VectorKeyframeTrack, boneName + ".scale", animationKeys, "scl", tracks);
      }
    }
    if (tracks.length === 0) {
      return null;
    }
    const clip = new this(clipName, duration, tracks, blendMode);
    return clip;
  }
  resetDuration() {
    const tracks = this.tracks;
    let duration = 0;
    for (let i = 0, n = tracks.length; i !== n; ++i) {
      const track = this.tracks[i];
      duration = Math.max(duration, track.times[track.times.length - 1]);
    }
    this.duration = duration;
    return this;
  }
  trim() {
    for (let i = 0; i < this.tracks.length; i++) {
      this.tracks[i].trim(0, this.duration);
    }
    return this;
  }
  validate() {
    let valid = true;
    for (let i = 0; i < this.tracks.length; i++) {
      valid = valid && this.tracks[i].validate();
    }
    return valid;
  }
  optimize() {
    for (let i = 0; i < this.tracks.length; i++) {
      this.tracks[i].optimize();
    }
    return this;
  }
  clone() {
    const tracks = [];
    for (let i = 0; i < this.tracks.length; i++) {
      tracks.push(this.tracks[i].clone());
    }
    return new this.constructor(this.name, this.duration, tracks, this.blendMode);
  }
  toJSON() {
    return this.constructor.toJSON(this);
  }
}
function getTrackTypeForValueTypeName(typeName) {
  switch (typeName.toLowerCase()) {
    case "scalar":
    case "double":
    case "float":
    case "number":
    case "integer":
      return NumberKeyframeTrack;
    case "vector":
    case "vector2":
    case "vector3":
    case "vector4":
      return VectorKeyframeTrack;
    case "color":
      return ColorKeyframeTrack;
    case "quaternion":
      return QuaternionKeyframeTrack;
    case "bool":
    case "boolean":
      return BooleanKeyframeTrack;
    case "string":
      return StringKeyframeTrack;
  }
  throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + typeName);
}
function parseKeyframeTrack(json) {
  if (json.type === void 0) {
    throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
  }
  const trackType = getTrackTypeForValueTypeName(json.type);
  if (json.times === void 0) {
    const times = [], values = [];
    AnimationUtils.flattenJSON(json.keys, times, values, "value");
    json.times = times;
    json.values = values;
  }
  if (trackType.parse !== void 0) {
    return trackType.parse(json);
  } else {
    return new trackType(json.name, json.times, json.values, json.interpolation);
  }
}
const Cache = {
  enabled: false,
  files: {},
  add: function(key, file) {
    if (this.enabled === false)
      return;
    this.files[key] = file;
  },
  get: function(key) {
    if (this.enabled === false)
      return;
    return this.files[key];
  },
  remove: function(key) {
    delete this.files[key];
  },
  clear: function() {
    this.files = {};
  }
};
class LoadingManager {
  constructor(onLoad, onProgress, onError) {
    const scope = this;
    let isLoading = false;
    let itemsLoaded = 0;
    let itemsTotal = 0;
    let urlModifier = void 0;
    const handlers = [];
    this.onStart = void 0;
    this.onLoad = onLoad;
    this.onProgress = onProgress;
    this.onError = onError;
    this.itemStart = function(url) {
      itemsTotal++;
      if (isLoading === false) {
        if (scope.onStart !== void 0) {
          scope.onStart(url, itemsLoaded, itemsTotal);
        }
      }
      isLoading = true;
    };
    this.itemEnd = function(url) {
      itemsLoaded++;
      if (scope.onProgress !== void 0) {
        scope.onProgress(url, itemsLoaded, itemsTotal);
      }
      if (itemsLoaded === itemsTotal) {
        isLoading = false;
        if (scope.onLoad !== void 0) {
          scope.onLoad();
        }
      }
    };
    this.itemError = function(url) {
      if (scope.onError !== void 0) {
        scope.onError(url);
      }
    };
    this.resolveURL = function(url) {
      if (urlModifier) {
        return urlModifier(url);
      }
      return url;
    };
    this.setURLModifier = function(transform2) {
      urlModifier = transform2;
      return this;
    };
    this.addHandler = function(regex, loader) {
      handlers.push(regex, loader);
      return this;
    };
    this.removeHandler = function(regex) {
      const index2 = handlers.indexOf(regex);
      if (index2 !== -1) {
        handlers.splice(index2, 2);
      }
      return this;
    };
    this.getHandler = function(file) {
      for (let i = 0, l = handlers.length; i < l; i += 2) {
        const regex = handlers[i];
        const loader = handlers[i + 1];
        if (regex.global)
          regex.lastIndex = 0;
        if (regex.test(file)) {
          return loader;
        }
      }
      return null;
    };
  }
}
const DefaultLoadingManager = new LoadingManager();
class Loader {
  constructor(manager) {
    this.manager = manager !== void 0 ? manager : DefaultLoadingManager;
    this.crossOrigin = "anonymous";
    this.withCredentials = false;
    this.path = "";
    this.resourcePath = "";
    this.requestHeader = {};
  }
  load() {
  }
  loadAsync(url, onProgress) {
    const scope = this;
    return new Promise(function(resolve, reject) {
      scope.load(url, resolve, onProgress, reject);
    });
  }
  parse() {
  }
  setCrossOrigin(crossOrigin) {
    this.crossOrigin = crossOrigin;
    return this;
  }
  setWithCredentials(value) {
    this.withCredentials = value;
    return this;
  }
  setPath(path) {
    this.path = path;
    return this;
  }
  setResourcePath(resourcePath) {
    this.resourcePath = resourcePath;
    return this;
  }
  setRequestHeader(requestHeader) {
    this.requestHeader = requestHeader;
    return this;
  }
}
const loading = {};
class FileLoader extends Loader {
  constructor(manager) {
    super(manager);
  }
  load(url, onLoad, onProgress, onError) {
    if (url === void 0)
      url = "";
    if (this.path !== void 0)
      url = this.path + url;
    url = this.manager.resolveURL(url);
    const cached = Cache.get(url);
    if (cached !== void 0) {
      this.manager.itemStart(url);
      setTimeout(() => {
        if (onLoad)
          onLoad(cached);
        this.manager.itemEnd(url);
      }, 0);
      return cached;
    }
    if (loading[url] !== void 0) {
      loading[url].push({
        onLoad,
        onProgress,
        onError
      });
      return;
    }
    loading[url] = [];
    loading[url].push({
      onLoad,
      onProgress,
      onError
    });
    const req = new Request(url, {
      headers: new Headers(this.requestHeader),
      credentials: this.withCredentials ? "include" : "same-origin"
    });
    const mimeType = this.mimeType;
    const responseType = this.responseType;
    fetch(req).then((response) => {
      if (response.status === 200 || response.status === 0) {
        if (response.status === 0) {
          console.warn("THREE.FileLoader: HTTP Status 0 received.");
        }
        if (typeof ReadableStream === "undefined" || response.body === void 0 || response.body.getReader === void 0) {
          return response;
        }
        const callbacks = loading[url];
        const reader = response.body.getReader();
        const contentLength = response.headers.get("Content-Length");
        const total = contentLength ? parseInt(contentLength) : 0;
        const lengthComputable = total !== 0;
        let loaded = 0;
        const stream = new ReadableStream({
          start(controller) {
            readData();
            function readData() {
              reader.read().then(({ done, value }) => {
                if (done) {
                  controller.close();
                } else {
                  loaded += value.byteLength;
                  const event = new ProgressEvent("progress", { lengthComputable, loaded, total });
                  for (let i = 0, il = callbacks.length; i < il; i++) {
                    const callback = callbacks[i];
                    if (callback.onProgress)
                      callback.onProgress(event);
                  }
                  controller.enqueue(value);
                  readData();
                }
              });
            }
          }
        });
        return new Response(stream);
      } else {
        throw Error(`fetch for "${response.url}" responded with ${response.status}: ${response.statusText}`);
      }
    }).then((response) => {
      switch (responseType) {
        case "arraybuffer":
          return response.arrayBuffer();
        case "blob":
          return response.blob();
        case "document":
          return response.text().then((text2) => {
            const parser = new DOMParser();
            return parser.parseFromString(text2, mimeType);
          });
        case "json":
          return response.json();
        default:
          if (mimeType === void 0) {
            return response.text();
          } else {
            const re = /charset="?([^;"\s]*)"?/i;
            const exec = re.exec(mimeType);
            const label = exec && exec[1] ? exec[1].toLowerCase() : void 0;
            const decoder = new TextDecoder(label);
            return response.arrayBuffer().then((ab) => decoder.decode(ab));
          }
      }
    }).then((data) => {
      Cache.add(url, data);
      const callbacks = loading[url];
      delete loading[url];
      for (let i = 0, il = callbacks.length; i < il; i++) {
        const callback = callbacks[i];
        if (callback.onLoad)
          callback.onLoad(data);
      }
    }).catch((err) => {
      const callbacks = loading[url];
      if (callbacks === void 0) {
        this.manager.itemError(url);
        throw err;
      }
      delete loading[url];
      for (let i = 0, il = callbacks.length; i < il; i++) {
        const callback = callbacks[i];
        if (callback.onError)
          callback.onError(err);
      }
      this.manager.itemError(url);
    }).finally(() => {
      this.manager.itemEnd(url);
    });
    this.manager.itemStart(url);
  }
  setResponseType(value) {
    this.responseType = value;
    return this;
  }
  setMimeType(value) {
    this.mimeType = value;
    return this;
  }
}
class ImageLoader extends Loader {
  constructor(manager) {
    super(manager);
  }
  load(url, onLoad, onProgress, onError) {
    if (this.path !== void 0)
      url = this.path + url;
    url = this.manager.resolveURL(url);
    const scope = this;
    const cached = Cache.get(url);
    if (cached !== void 0) {
      scope.manager.itemStart(url);
      setTimeout(function() {
        if (onLoad)
          onLoad(cached);
        scope.manager.itemEnd(url);
      }, 0);
      return cached;
    }
    const image2 = createElementNS("img");
    function onImageLoad() {
      removeEventListeners();
      Cache.add(url, this);
      if (onLoad)
        onLoad(this);
      scope.manager.itemEnd(url);
    }
    function onImageError(event) {
      removeEventListeners();
      if (onError)
        onError(event);
      scope.manager.itemError(url);
      scope.manager.itemEnd(url);
    }
    function removeEventListeners() {
      image2.removeEventListener("load", onImageLoad, false);
      image2.removeEventListener("error", onImageError, false);
    }
    image2.addEventListener("load", onImageLoad, false);
    image2.addEventListener("error", onImageError, false);
    if (url.slice(0, 5) !== "data:") {
      if (this.crossOrigin !== void 0)
        image2.crossOrigin = this.crossOrigin;
    }
    scope.manager.itemStart(url);
    image2.src = url;
    return image2;
  }
}
class CubeTextureLoader extends Loader {
  constructor(manager) {
    super(manager);
  }
  load(urls, onLoad, onProgress, onError) {
    const texture2 = new CubeTexture();
    const loader = new ImageLoader(this.manager);
    loader.setCrossOrigin(this.crossOrigin);
    loader.setPath(this.path);
    let loaded = 0;
    function loadTexture(i) {
      loader.load(urls[i], function(image2) {
        texture2.images[i] = image2;
        loaded++;
        if (loaded === 6) {
          texture2.needsUpdate = true;
          if (onLoad)
            onLoad(texture2);
        }
      }, void 0, onError);
    }
    for (let i = 0; i < urls.length; ++i) {
      loadTexture(i);
    }
    return texture2;
  }
}
class TextureLoader extends Loader {
  constructor(manager) {
    super(manager);
  }
  load(url, onLoad, onProgress, onError) {
    const texture2 = new Texture();
    const loader = new ImageLoader(this.manager);
    loader.setCrossOrigin(this.crossOrigin);
    loader.setPath(this.path);
    loader.load(url, function(image2) {
      texture2.image = image2;
      texture2.needsUpdate = true;
      if (onLoad !== void 0) {
        onLoad(texture2);
      }
    }, onProgress, onError);
    return texture2;
  }
}
class Light extends Object3D {
  constructor(color2, intensity = 1) {
    super();
    this.type = "Light";
    this.color = new Color(color2);
    this.intensity = intensity;
  }
  dispose() {
  }
  copy(source2) {
    super.copy(source2);
    this.color.copy(source2.color);
    this.intensity = source2.intensity;
    return this;
  }
  toJSON(meta) {
    const data = super.toJSON(meta);
    data.object.color = this.color.getHex();
    data.object.intensity = this.intensity;
    if (this.groundColor !== void 0)
      data.object.groundColor = this.groundColor.getHex();
    if (this.distance !== void 0)
      data.object.distance = this.distance;
    if (this.angle !== void 0)
      data.object.angle = this.angle;
    if (this.decay !== void 0)
      data.object.decay = this.decay;
    if (this.penumbra !== void 0)
      data.object.penumbra = this.penumbra;
    if (this.shadow !== void 0)
      data.object.shadow = this.shadow.toJSON();
    return data;
  }
}
Light.prototype.isLight = true;
class HemisphereLight extends Light {
  constructor(skyColor, groundColor, intensity) {
    super(skyColor, intensity);
    this.type = "HemisphereLight";
    this.position.copy(Object3D.DefaultUp);
    this.updateMatrix();
    this.groundColor = new Color(groundColor);
  }
  copy(source2) {
    Light.prototype.copy.call(this, source2);
    this.groundColor.copy(source2.groundColor);
    return this;
  }
}
HemisphereLight.prototype.isHemisphereLight = true;
const _projScreenMatrix$1 = /* @__PURE__ */ new Matrix4();
const _lightPositionWorld$1 = /* @__PURE__ */ new Vector3();
const _lookTarget$1 = /* @__PURE__ */ new Vector3();
class LightShadow {
  constructor(camera) {
    this.camera = camera;
    this.bias = 0;
    this.normalBias = 0;
    this.radius = 1;
    this.blurSamples = 8;
    this.mapSize = new Vector2(512, 512);
    this.map = null;
    this.mapPass = null;
    this.matrix = new Matrix4();
    this.autoUpdate = true;
    this.needsUpdate = false;
    this._frustum = new Frustum();
    this._frameExtents = new Vector2(1, 1);
    this._viewportCount = 1;
    this._viewports = [
      new Vector4(0, 0, 1, 1)
    ];
  }
  getViewportCount() {
    return this._viewportCount;
  }
  getFrustum() {
    return this._frustum;
  }
  updateMatrices(light2) {
    const shadowCamera = this.camera;
    const shadowMatrix = this.matrix;
    _lightPositionWorld$1.setFromMatrixPosition(light2.matrixWorld);
    shadowCamera.position.copy(_lightPositionWorld$1);
    _lookTarget$1.setFromMatrixPosition(light2.target.matrixWorld);
    shadowCamera.lookAt(_lookTarget$1);
    shadowCamera.updateMatrixWorld();
    _projScreenMatrix$1.multiplyMatrices(shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse);
    this._frustum.setFromProjectionMatrix(_projScreenMatrix$1);
    shadowMatrix.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1);
    shadowMatrix.multiply(shadowCamera.projectionMatrix);
    shadowMatrix.multiply(shadowCamera.matrixWorldInverse);
  }
  getViewport(viewportIndex) {
    return this._viewports[viewportIndex];
  }
  getFrameExtents() {
    return this._frameExtents;
  }
  dispose() {
    if (this.map) {
      this.map.dispose();
    }
    if (this.mapPass) {
      this.mapPass.dispose();
    }
  }
  copy(source2) {
    this.camera = source2.camera.clone();
    this.bias = source2.bias;
    this.radius = source2.radius;
    this.mapSize.copy(source2.mapSize);
    return this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  toJSON() {
    const object = {};
    if (this.bias !== 0)
      object.bias = this.bias;
    if (this.normalBias !== 0)
      object.normalBias = this.normalBias;
    if (this.radius !== 1)
      object.radius = this.radius;
    if (this.mapSize.x !== 512 || this.mapSize.y !== 512)
      object.mapSize = this.mapSize.toArray();
    object.camera = this.camera.toJSON(false).object;
    delete object.camera.matrix;
    return object;
  }
}
class SpotLightShadow extends LightShadow {
  constructor() {
    super(new PerspectiveCamera(50, 1, 0.5, 500));
    this.focus = 1;
  }
  updateMatrices(light2) {
    const camera = this.camera;
    const fov2 = RAD2DEG * 2 * light2.angle * this.focus;
    const aspect2 = this.mapSize.width / this.mapSize.height;
    const far = light2.distance || camera.far;
    if (fov2 !== camera.fov || aspect2 !== camera.aspect || far !== camera.far) {
      camera.fov = fov2;
      camera.aspect = aspect2;
      camera.far = far;
      camera.updateProjectionMatrix();
    }
    super.updateMatrices(light2);
  }
  copy(source2) {
    super.copy(source2);
    this.focus = source2.focus;
    return this;
  }
}
SpotLightShadow.prototype.isSpotLightShadow = true;
class SpotLight extends Light {
  constructor(color2, intensity, distance2 = 0, angle = Math.PI / 3, penumbra = 0, decay = 1) {
    super(color2, intensity);
    this.type = "SpotLight";
    this.position.copy(Object3D.DefaultUp);
    this.updateMatrix();
    this.target = new Object3D();
    this.distance = distance2;
    this.angle = angle;
    this.penumbra = penumbra;
    this.decay = decay;
    this.shadow = new SpotLightShadow();
  }
  get power() {
    return this.intensity * Math.PI;
  }
  set power(power) {
    this.intensity = power / Math.PI;
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(source2) {
    super.copy(source2);
    this.distance = source2.distance;
    this.angle = source2.angle;
    this.penumbra = source2.penumbra;
    this.decay = source2.decay;
    this.target = source2.target.clone();
    this.shadow = source2.shadow.clone();
    return this;
  }
}
SpotLight.prototype.isSpotLight = true;
const _projScreenMatrix = /* @__PURE__ */ new Matrix4();
const _lightPositionWorld = /* @__PURE__ */ new Vector3();
const _lookTarget = /* @__PURE__ */ new Vector3();
class PointLightShadow extends LightShadow {
  constructor() {
    super(new PerspectiveCamera(90, 1, 0.5, 500));
    this._frameExtents = new Vector2(4, 2);
    this._viewportCount = 6;
    this._viewports = [
      new Vector4(2, 1, 1, 1),
      new Vector4(0, 1, 1, 1),
      new Vector4(3, 1, 1, 1),
      new Vector4(1, 1, 1, 1),
      new Vector4(3, 0, 1, 1),
      new Vector4(1, 0, 1, 1)
    ];
    this._cubeDirections = [
      new Vector3(1, 0, 0),
      new Vector3(-1, 0, 0),
      new Vector3(0, 0, 1),
      new Vector3(0, 0, -1),
      new Vector3(0, 1, 0),
      new Vector3(0, -1, 0)
    ];
    this._cubeUps = [
      new Vector3(0, 1, 0),
      new Vector3(0, 1, 0),
      new Vector3(0, 1, 0),
      new Vector3(0, 1, 0),
      new Vector3(0, 0, 1),
      new Vector3(0, 0, -1)
    ];
  }
  updateMatrices(light2, viewportIndex = 0) {
    const camera = this.camera;
    const shadowMatrix = this.matrix;
    const far = light2.distance || camera.far;
    if (far !== camera.far) {
      camera.far = far;
      camera.updateProjectionMatrix();
    }
    _lightPositionWorld.setFromMatrixPosition(light2.matrixWorld);
    camera.position.copy(_lightPositionWorld);
    _lookTarget.copy(camera.position);
    _lookTarget.add(this._cubeDirections[viewportIndex]);
    camera.up.copy(this._cubeUps[viewportIndex]);
    camera.lookAt(_lookTarget);
    camera.updateMatrixWorld();
    shadowMatrix.makeTranslation(-_lightPositionWorld.x, -_lightPositionWorld.y, -_lightPositionWorld.z);
    _projScreenMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
    this._frustum.setFromProjectionMatrix(_projScreenMatrix);
  }
}
PointLightShadow.prototype.isPointLightShadow = true;
class PointLight extends Light {
  constructor(color2, intensity, distance2 = 0, decay = 1) {
    super(color2, intensity);
    this.type = "PointLight";
    this.distance = distance2;
    this.decay = decay;
    this.shadow = new PointLightShadow();
  }
  get power() {
    return this.intensity * 4 * Math.PI;
  }
  set power(power) {
    this.intensity = power / (4 * Math.PI);
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(source2) {
    super.copy(source2);
    this.distance = source2.distance;
    this.decay = source2.decay;
    this.shadow = source2.shadow.clone();
    return this;
  }
}
PointLight.prototype.isPointLight = true;
class DirectionalLightShadow extends LightShadow {
  constructor() {
    super(new OrthographicCamera(-5, 5, 5, -5, 0.5, 500));
  }
}
DirectionalLightShadow.prototype.isDirectionalLightShadow = true;
class DirectionalLight extends Light {
  constructor(color2, intensity) {
    super(color2, intensity);
    this.type = "DirectionalLight";
    this.position.copy(Object3D.DefaultUp);
    this.updateMatrix();
    this.target = new Object3D();
    this.shadow = new DirectionalLightShadow();
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(source2) {
    super.copy(source2);
    this.target = source2.target.clone();
    this.shadow = source2.shadow.clone();
    return this;
  }
}
DirectionalLight.prototype.isDirectionalLight = true;
class AmbientLight extends Light {
  constructor(color2, intensity) {
    super(color2, intensity);
    this.type = "AmbientLight";
  }
}
AmbientLight.prototype.isAmbientLight = true;
class RectAreaLight extends Light {
  constructor(color2, intensity, width2 = 10, height2 = 10) {
    super(color2, intensity);
    this.type = "RectAreaLight";
    this.width = width2;
    this.height = height2;
  }
  get power() {
    return this.intensity * this.width * this.height * Math.PI;
  }
  set power(power) {
    this.intensity = power / (this.width * this.height * Math.PI);
  }
  copy(source2) {
    super.copy(source2);
    this.width = source2.width;
    this.height = source2.height;
    return this;
  }
  toJSON(meta) {
    const data = super.toJSON(meta);
    data.object.width = this.width;
    data.object.height = this.height;
    return data;
  }
}
RectAreaLight.prototype.isRectAreaLight = true;
class SphericalHarmonics3 {
  constructor() {
    this.coefficients = [];
    for (let i = 0; i < 9; i++) {
      this.coefficients.push(new Vector3());
    }
  }
  set(coefficients) {
    for (let i = 0; i < 9; i++) {
      this.coefficients[i].copy(coefficients[i]);
    }
    return this;
  }
  zero() {
    for (let i = 0; i < 9; i++) {
      this.coefficients[i].set(0, 0, 0);
    }
    return this;
  }
  getAt(normal, target) {
    const x = normal.x, y = normal.y, z = normal.z;
    const coeff = this.coefficients;
    target.copy(coeff[0]).multiplyScalar(0.282095);
    target.addScaledVector(coeff[1], 0.488603 * y);
    target.addScaledVector(coeff[2], 0.488603 * z);
    target.addScaledVector(coeff[3], 0.488603 * x);
    target.addScaledVector(coeff[4], 1.092548 * (x * y));
    target.addScaledVector(coeff[5], 1.092548 * (y * z));
    target.addScaledVector(coeff[6], 0.315392 * (3 * z * z - 1));
    target.addScaledVector(coeff[7], 1.092548 * (x * z));
    target.addScaledVector(coeff[8], 0.546274 * (x * x - y * y));
    return target;
  }
  getIrradianceAt(normal, target) {
    const x = normal.x, y = normal.y, z = normal.z;
    const coeff = this.coefficients;
    target.copy(coeff[0]).multiplyScalar(0.886227);
    target.addScaledVector(coeff[1], 2 * 0.511664 * y);
    target.addScaledVector(coeff[2], 2 * 0.511664 * z);
    target.addScaledVector(coeff[3], 2 * 0.511664 * x);
    target.addScaledVector(coeff[4], 2 * 0.429043 * x * y);
    target.addScaledVector(coeff[5], 2 * 0.429043 * y * z);
    target.addScaledVector(coeff[6], 0.743125 * z * z - 0.247708);
    target.addScaledVector(coeff[7], 2 * 0.429043 * x * z);
    target.addScaledVector(coeff[8], 0.429043 * (x * x - y * y));
    return target;
  }
  add(sh) {
    for (let i = 0; i < 9; i++) {
      this.coefficients[i].add(sh.coefficients[i]);
    }
    return this;
  }
  addScaledSH(sh, s) {
    for (let i = 0; i < 9; i++) {
      this.coefficients[i].addScaledVector(sh.coefficients[i], s);
    }
    return this;
  }
  scale(s) {
    for (let i = 0; i < 9; i++) {
      this.coefficients[i].multiplyScalar(s);
    }
    return this;
  }
  lerp(sh, alpha2) {
    for (let i = 0; i < 9; i++) {
      this.coefficients[i].lerp(sh.coefficients[i], alpha2);
    }
    return this;
  }
  equals(sh) {
    for (let i = 0; i < 9; i++) {
      if (!this.coefficients[i].equals(sh.coefficients[i])) {
        return false;
      }
    }
    return true;
  }
  copy(sh) {
    return this.set(sh.coefficients);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  fromArray(array, offset = 0) {
    const coefficients = this.coefficients;
    for (let i = 0; i < 9; i++) {
      coefficients[i].fromArray(array, offset + i * 3);
    }
    return this;
  }
  toArray(array = [], offset = 0) {
    const coefficients = this.coefficients;
    for (let i = 0; i < 9; i++) {
      coefficients[i].toArray(array, offset + i * 3);
    }
    return array;
  }
  static getBasisAt(normal, shBasis) {
    const x = normal.x, y = normal.y, z = normal.z;
    shBasis[0] = 0.282095;
    shBasis[1] = 0.488603 * y;
    shBasis[2] = 0.488603 * z;
    shBasis[3] = 0.488603 * x;
    shBasis[4] = 1.092548 * x * y;
    shBasis[5] = 1.092548 * y * z;
    shBasis[6] = 0.315392 * (3 * z * z - 1);
    shBasis[7] = 1.092548 * x * z;
    shBasis[8] = 0.546274 * (x * x - y * y);
  }
}
SphericalHarmonics3.prototype.isSphericalHarmonics3 = true;
class LightProbe extends Light {
  constructor(sh = new SphericalHarmonics3(), intensity = 1) {
    super(void 0, intensity);
    this.sh = sh;
  }
  copy(source2) {
    super.copy(source2);
    this.sh.copy(source2.sh);
    return this;
  }
  fromJSON(json) {
    this.intensity = json.intensity;
    this.sh.fromArray(json.sh);
    return this;
  }
  toJSON(meta) {
    const data = super.toJSON(meta);
    data.object.sh = this.sh.toArray();
    return data;
  }
}
LightProbe.prototype.isLightProbe = true;
class MaterialLoader extends Loader {
  constructor(manager) {
    super(manager);
    this.textures = {};
  }
  load(url, onLoad, onProgress, onError) {
    const scope = this;
    const loader = new FileLoader(scope.manager);
    loader.setPath(scope.path);
    loader.setRequestHeader(scope.requestHeader);
    loader.setWithCredentials(scope.withCredentials);
    loader.load(url, function(text2) {
      try {
        onLoad(scope.parse(JSON.parse(text2)));
      } catch (e) {
        if (onError) {
          onError(e);
        } else {
          console.error(e);
        }
        scope.manager.itemError(url);
      }
    }, onProgress, onError);
  }
  parse(json) {
    const textures = this.textures;
    function getTexture(name) {
      if (textures[name] === void 0) {
        console.warn("THREE.MaterialLoader: Undefined texture", name);
      }
      return textures[name];
    }
    const material = Material.fromType(json.type);
    if (json.uuid !== void 0)
      material.uuid = json.uuid;
    if (json.name !== void 0)
      material.name = json.name;
    if (json.color !== void 0 && material.color !== void 0)
      material.color.setHex(json.color);
    if (json.roughness !== void 0)
      material.roughness = json.roughness;
    if (json.metalness !== void 0)
      material.metalness = json.metalness;
    if (json.sheen !== void 0)
      material.sheen = json.sheen;
    if (json.sheenColor !== void 0)
      material.sheenColor = new Color().setHex(json.sheenColor);
    if (json.sheenRoughness !== void 0)
      material.sheenRoughness = json.sheenRoughness;
    if (json.emissive !== void 0 && material.emissive !== void 0)
      material.emissive.setHex(json.emissive);
    if (json.specular !== void 0 && material.specular !== void 0)
      material.specular.setHex(json.specular);
    if (json.specularIntensity !== void 0)
      material.specularIntensity = json.specularIntensity;
    if (json.specularColor !== void 0 && material.specularColor !== void 0)
      material.specularColor.setHex(json.specularColor);
    if (json.shininess !== void 0)
      material.shininess = json.shininess;
    if (json.clearcoat !== void 0)
      material.clearcoat = json.clearcoat;
    if (json.clearcoatRoughness !== void 0)
      material.clearcoatRoughness = json.clearcoatRoughness;
    if (json.transmission !== void 0)
      material.transmission = json.transmission;
    if (json.thickness !== void 0)
      material.thickness = json.thickness;
    if (json.attenuationDistance !== void 0)
      material.attenuationDistance = json.attenuationDistance;
    if (json.attenuationColor !== void 0 && material.attenuationColor !== void 0)
      material.attenuationColor.setHex(json.attenuationColor);
    if (json.fog !== void 0)
      material.fog = json.fog;
    if (json.flatShading !== void 0)
      material.flatShading = json.flatShading;
    if (json.blending !== void 0)
      material.blending = json.blending;
    if (json.combine !== void 0)
      material.combine = json.combine;
    if (json.side !== void 0)
      material.side = json.side;
    if (json.shadowSide !== void 0)
      material.shadowSide = json.shadowSide;
    if (json.opacity !== void 0)
      material.opacity = json.opacity;
    if (json.transparent !== void 0)
      material.transparent = json.transparent;
    if (json.alphaTest !== void 0)
      material.alphaTest = json.alphaTest;
    if (json.depthTest !== void 0)
      material.depthTest = json.depthTest;
    if (json.depthWrite !== void 0)
      material.depthWrite = json.depthWrite;
    if (json.colorWrite !== void 0)
      material.colorWrite = json.colorWrite;
    if (json.stencilWrite !== void 0)
      material.stencilWrite = json.stencilWrite;
    if (json.stencilWriteMask !== void 0)
      material.stencilWriteMask = json.stencilWriteMask;
    if (json.stencilFunc !== void 0)
      material.stencilFunc = json.stencilFunc;
    if (json.stencilRef !== void 0)
      material.stencilRef = json.stencilRef;
    if (json.stencilFuncMask !== void 0)
      material.stencilFuncMask = json.stencilFuncMask;
    if (json.stencilFail !== void 0)
      material.stencilFail = json.stencilFail;
    if (json.stencilZFail !== void 0)
      material.stencilZFail = json.stencilZFail;
    if (json.stencilZPass !== void 0)
      material.stencilZPass = json.stencilZPass;
    if (json.wireframe !== void 0)
      material.wireframe = json.wireframe;
    if (json.wireframeLinewidth !== void 0)
      material.wireframeLinewidth = json.wireframeLinewidth;
    if (json.wireframeLinecap !== void 0)
      material.wireframeLinecap = json.wireframeLinecap;
    if (json.wireframeLinejoin !== void 0)
      material.wireframeLinejoin = json.wireframeLinejoin;
    if (json.rotation !== void 0)
      material.rotation = json.rotation;
    if (json.linewidth !== 1)
      material.linewidth = json.linewidth;
    if (json.dashSize !== void 0)
      material.dashSize = json.dashSize;
    if (json.gapSize !== void 0)
      material.gapSize = json.gapSize;
    if (json.scale !== void 0)
      material.scale = json.scale;
    if (json.polygonOffset !== void 0)
      material.polygonOffset = json.polygonOffset;
    if (json.polygonOffsetFactor !== void 0)
      material.polygonOffsetFactor = json.polygonOffsetFactor;
    if (json.polygonOffsetUnits !== void 0)
      material.polygonOffsetUnits = json.polygonOffsetUnits;
    if (json.dithering !== void 0)
      material.dithering = json.dithering;
    if (json.alphaToCoverage !== void 0)
      material.alphaToCoverage = json.alphaToCoverage;
    if (json.premultipliedAlpha !== void 0)
      material.premultipliedAlpha = json.premultipliedAlpha;
    if (json.visible !== void 0)
      material.visible = json.visible;
    if (json.toneMapped !== void 0)
      material.toneMapped = json.toneMapped;
    if (json.userData !== void 0)
      material.userData = json.userData;
    if (json.vertexColors !== void 0) {
      if (typeof json.vertexColors === "number") {
        material.vertexColors = json.vertexColors > 0 ? true : false;
      } else {
        material.vertexColors = json.vertexColors;
      }
    }
    if (json.uniforms !== void 0) {
      for (const name in json.uniforms) {
        const uniform = json.uniforms[name];
        material.uniforms[name] = {};
        switch (uniform.type) {
          case "t":
            material.uniforms[name].value = getTexture(uniform.value);
            break;
          case "c":
            material.uniforms[name].value = new Color().setHex(uniform.value);
            break;
          case "v2":
            material.uniforms[name].value = new Vector2().fromArray(uniform.value);
            break;
          case "v3":
            material.uniforms[name].value = new Vector3().fromArray(uniform.value);
            break;
          case "v4":
            material.uniforms[name].value = new Vector4().fromArray(uniform.value);
            break;
          case "m3":
            material.uniforms[name].value = new Matrix3().fromArray(uniform.value);
            break;
          case "m4":
            material.uniforms[name].value = new Matrix4().fromArray(uniform.value);
            break;
          default:
            material.uniforms[name].value = uniform.value;
        }
      }
    }
    if (json.defines !== void 0)
      material.defines = json.defines;
    if (json.vertexShader !== void 0)
      material.vertexShader = json.vertexShader;
    if (json.fragmentShader !== void 0)
      material.fragmentShader = json.fragmentShader;
    if (json.extensions !== void 0) {
      for (const key in json.extensions) {
        material.extensions[key] = json.extensions[key];
      }
    }
    if (json.shading !== void 0)
      material.flatShading = json.shading === 1;
    if (json.size !== void 0)
      material.size = json.size;
    if (json.sizeAttenuation !== void 0)
      material.sizeAttenuation = json.sizeAttenuation;
    if (json.map !== void 0)
      material.map = getTexture(json.map);
    if (json.matcap !== void 0)
      material.matcap = getTexture(json.matcap);
    if (json.alphaMap !== void 0)
      material.alphaMap = getTexture(json.alphaMap);
    if (json.bumpMap !== void 0)
      material.bumpMap = getTexture(json.bumpMap);
    if (json.bumpScale !== void 0)
      material.bumpScale = json.bumpScale;
    if (json.normalMap !== void 0)
      material.normalMap = getTexture(json.normalMap);
    if (json.normalMapType !== void 0)
      material.normalMapType = json.normalMapType;
    if (json.normalScale !== void 0) {
      let normalScale = json.normalScale;
      if (Array.isArray(normalScale) === false) {
        normalScale = [normalScale, normalScale];
      }
      material.normalScale = new Vector2().fromArray(normalScale);
    }
    if (json.displacementMap !== void 0)
      material.displacementMap = getTexture(json.displacementMap);
    if (json.displacementScale !== void 0)
      material.displacementScale = json.displacementScale;
    if (json.displacementBias !== void 0)
      material.displacementBias = json.displacementBias;
    if (json.roughnessMap !== void 0)
      material.roughnessMap = getTexture(json.roughnessMap);
    if (json.metalnessMap !== void 0)
      material.metalnessMap = getTexture(json.metalnessMap);
    if (json.emissiveMap !== void 0)
      material.emissiveMap = getTexture(json.emissiveMap);
    if (json.emissiveIntensity !== void 0)
      material.emissiveIntensity = json.emissiveIntensity;
    if (json.specularMap !== void 0)
      material.specularMap = getTexture(json.specularMap);
    if (json.specularIntensityMap !== void 0)
      material.specularIntensityMap = getTexture(json.specularIntensityMap);
    if (json.specularColorMap !== void 0)
      material.specularColorMap = getTexture(json.specularColorMap);
    if (json.envMap !== void 0)
      material.envMap = getTexture(json.envMap);
    if (json.envMapIntensity !== void 0)
      material.envMapIntensity = json.envMapIntensity;
    if (json.reflectivity !== void 0)
      material.reflectivity = json.reflectivity;
    if (json.refractionRatio !== void 0)
      material.refractionRatio = json.refractionRatio;
    if (json.lightMap !== void 0)
      material.lightMap = getTexture(json.lightMap);
    if (json.lightMapIntensity !== void 0)
      material.lightMapIntensity = json.lightMapIntensity;
    if (json.aoMap !== void 0)
      material.aoMap = getTexture(json.aoMap);
    if (json.aoMapIntensity !== void 0)
      material.aoMapIntensity = json.aoMapIntensity;
    if (json.gradientMap !== void 0)
      material.gradientMap = getTexture(json.gradientMap);
    if (json.clearcoatMap !== void 0)
      material.clearcoatMap = getTexture(json.clearcoatMap);
    if (json.clearcoatRoughnessMap !== void 0)
      material.clearcoatRoughnessMap = getTexture(json.clearcoatRoughnessMap);
    if (json.clearcoatNormalMap !== void 0)
      material.clearcoatNormalMap = getTexture(json.clearcoatNormalMap);
    if (json.clearcoatNormalScale !== void 0)
      material.clearcoatNormalScale = new Vector2().fromArray(json.clearcoatNormalScale);
    if (json.transmissionMap !== void 0)
      material.transmissionMap = getTexture(json.transmissionMap);
    if (json.thicknessMap !== void 0)
      material.thicknessMap = getTexture(json.thicknessMap);
    if (json.sheenColorMap !== void 0)
      material.sheenColorMap = getTexture(json.sheenColorMap);
    if (json.sheenRoughnessMap !== void 0)
      material.sheenRoughnessMap = getTexture(json.sheenRoughnessMap);
    return material;
  }
  setTextures(value) {
    this.textures = value;
    return this;
  }
}
class LoaderUtils {
  static decodeText(array) {
    if (typeof TextDecoder !== "undefined") {
      return new TextDecoder().decode(array);
    }
    let s = "";
    for (let i = 0, il = array.length; i < il; i++) {
      s += String.fromCharCode(array[i]);
    }
    try {
      return decodeURIComponent(escape(s));
    } catch (e) {
      return s;
    }
  }
  static extractUrlBase(url) {
    const index2 = url.lastIndexOf("/");
    if (index2 === -1)
      return "./";
    return url.slice(0, index2 + 1);
  }
  static resolveURL(url, path) {
    if (typeof url !== "string" || url === "")
      return "";
    if (/^https?:\/\//i.test(path) && /^\//.test(url)) {
      path = path.replace(/(^https?:\/\/[^\/]+).*/i, "$1");
    }
    if (/^(https?:)?\/\//i.test(url))
      return url;
    if (/^data:.*,.*$/i.test(url))
      return url;
    if (/^blob:.*$/i.test(url))
      return url;
    return path + url;
  }
}
class InstancedBufferGeometry extends BufferGeometry {
  constructor() {
    super();
    this.type = "InstancedBufferGeometry";
    this.instanceCount = Infinity;
  }
  copy(source2) {
    super.copy(source2);
    this.instanceCount = source2.instanceCount;
    return this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  toJSON() {
    const data = super.toJSON(this);
    data.instanceCount = this.instanceCount;
    data.isInstancedBufferGeometry = true;
    return data;
  }
}
InstancedBufferGeometry.prototype.isInstancedBufferGeometry = true;
class BufferGeometryLoader extends Loader {
  constructor(manager) {
    super(manager);
  }
  load(url, onLoad, onProgress, onError) {
    const scope = this;
    const loader = new FileLoader(scope.manager);
    loader.setPath(scope.path);
    loader.setRequestHeader(scope.requestHeader);
    loader.setWithCredentials(scope.withCredentials);
    loader.load(url, function(text2) {
      try {
        onLoad(scope.parse(JSON.parse(text2)));
      } catch (e) {
        if (onError) {
          onError(e);
        } else {
          console.error(e);
        }
        scope.manager.itemError(url);
      }
    }, onProgress, onError);
  }
  parse(json) {
    const interleavedBufferMap = {};
    const arrayBufferMap = {};
    function getInterleavedBuffer(json2, uuid2) {
      if (interleavedBufferMap[uuid2] !== void 0)
        return interleavedBufferMap[uuid2];
      const interleavedBuffers = json2.interleavedBuffers;
      const interleavedBuffer = interleavedBuffers[uuid2];
      const buffer = getArrayBuffer(json2, interleavedBuffer.buffer);
      const array = getTypedArray(interleavedBuffer.type, buffer);
      const ib = new InterleavedBuffer(array, interleavedBuffer.stride);
      ib.uuid = interleavedBuffer.uuid;
      interleavedBufferMap[uuid2] = ib;
      return ib;
    }
    function getArrayBuffer(json2, uuid2) {
      if (arrayBufferMap[uuid2] !== void 0)
        return arrayBufferMap[uuid2];
      const arrayBuffers = json2.arrayBuffers;
      const arrayBuffer = arrayBuffers[uuid2];
      const ab = new Uint32Array(arrayBuffer).buffer;
      arrayBufferMap[uuid2] = ab;
      return ab;
    }
    const geometry = json.isInstancedBufferGeometry ? new InstancedBufferGeometry() : new BufferGeometry();
    const index2 = json.data.index;
    if (index2 !== void 0) {
      const typedArray = getTypedArray(index2.type, index2.array);
      geometry.setIndex(new BufferAttribute(typedArray, 1));
    }
    const attributes = json.data.attributes;
    for (const key in attributes) {
      const attribute = attributes[key];
      let bufferAttribute;
      if (attribute.isInterleavedBufferAttribute) {
        const interleavedBuffer = getInterleavedBuffer(json.data, attribute.data);
        bufferAttribute = new InterleavedBufferAttribute(interleavedBuffer, attribute.itemSize, attribute.offset, attribute.normalized);
      } else {
        const typedArray = getTypedArray(attribute.type, attribute.array);
        const bufferAttributeConstr = attribute.isInstancedBufferAttribute ? InstancedBufferAttribute : BufferAttribute;
        bufferAttribute = new bufferAttributeConstr(typedArray, attribute.itemSize, attribute.normalized);
      }
      if (attribute.name !== void 0)
        bufferAttribute.name = attribute.name;
      if (attribute.usage !== void 0)
        bufferAttribute.setUsage(attribute.usage);
      if (attribute.updateRange !== void 0) {
        bufferAttribute.updateRange.offset = attribute.updateRange.offset;
        bufferAttribute.updateRange.count = attribute.updateRange.count;
      }
      geometry.setAttribute(key, bufferAttribute);
    }
    const morphAttributes = json.data.morphAttributes;
    if (morphAttributes) {
      for (const key in morphAttributes) {
        const attributeArray = morphAttributes[key];
        const array = [];
        for (let i = 0, il = attributeArray.length; i < il; i++) {
          const attribute = attributeArray[i];
          let bufferAttribute;
          if (attribute.isInterleavedBufferAttribute) {
            const interleavedBuffer = getInterleavedBuffer(json.data, attribute.data);
            bufferAttribute = new InterleavedBufferAttribute(interleavedBuffer, attribute.itemSize, attribute.offset, attribute.normalized);
          } else {
            const typedArray = getTypedArray(attribute.type, attribute.array);
            bufferAttribute = new BufferAttribute(typedArray, attribute.itemSize, attribute.normalized);
          }
          if (attribute.name !== void 0)
            bufferAttribute.name = attribute.name;
          array.push(bufferAttribute);
        }
        geometry.morphAttributes[key] = array;
      }
    }
    const morphTargetsRelative = json.data.morphTargetsRelative;
    if (morphTargetsRelative) {
      geometry.morphTargetsRelative = true;
    }
    const groups = json.data.groups || json.data.drawcalls || json.data.offsets;
    if (groups !== void 0) {
      for (let i = 0, n = groups.length; i !== n; ++i) {
        const group2 = groups[i];
        geometry.addGroup(group2.start, group2.count, group2.materialIndex);
      }
    }
    const boundingSphere = json.data.boundingSphere;
    if (boundingSphere !== void 0) {
      const center2 = new Vector3();
      if (boundingSphere.center !== void 0) {
        center2.fromArray(boundingSphere.center);
      }
      geometry.boundingSphere = new Sphere(center2, boundingSphere.radius);
    }
    if (json.name)
      geometry.name = json.name;
    if (json.userData)
      geometry.userData = json.userData;
    return geometry;
  }
}
class ObjectLoader extends Loader {
  constructor(manager) {
    super(manager);
  }
  load(url, onLoad, onProgress, onError) {
    const scope = this;
    const path = this.path === "" ? LoaderUtils.extractUrlBase(url) : this.path;
    this.resourcePath = this.resourcePath || path;
    const loader = new FileLoader(this.manager);
    loader.setPath(this.path);
    loader.setRequestHeader(this.requestHeader);
    loader.setWithCredentials(this.withCredentials);
    loader.load(url, function(text2) {
      let json = null;
      try {
        json = JSON.parse(text2);
      } catch (error) {
        if (onError !== void 0)
          onError(error);
        console.error("THREE:ObjectLoader: Can't parse " + url + ".", error.message);
        return;
      }
      const metadata = json.metadata;
      if (metadata === void 0 || metadata.type === void 0 || metadata.type.toLowerCase() === "geometry") {
        console.error("THREE.ObjectLoader: Can't load " + url);
        return;
      }
      scope.parse(json, onLoad);
    }, onProgress, onError);
  }
  async loadAsync(url, onProgress) {
    const scope = this;
    const path = this.path === "" ? LoaderUtils.extractUrlBase(url) : this.path;
    this.resourcePath = this.resourcePath || path;
    const loader = new FileLoader(this.manager);
    loader.setPath(this.path);
    loader.setRequestHeader(this.requestHeader);
    loader.setWithCredentials(this.withCredentials);
    const text2 = await loader.loadAsync(url, onProgress);
    const json = JSON.parse(text2);
    const metadata = json.metadata;
    if (metadata === void 0 || metadata.type === void 0 || metadata.type.toLowerCase() === "geometry") {
      throw new Error("THREE.ObjectLoader: Can't load " + url);
    }
    return await scope.parseAsync(json);
  }
  parse(json, onLoad) {
    const animations = this.parseAnimations(json.animations);
    const shapes = this.parseShapes(json.shapes);
    const geometries = this.parseGeometries(json.geometries, shapes);
    const images = this.parseImages(json.images, function() {
      if (onLoad !== void 0)
        onLoad(object);
    });
    const textures = this.parseTextures(json.textures, images);
    const materials = this.parseMaterials(json.materials, textures);
    const object = this.parseObject(json.object, geometries, materials, textures, animations);
    const skeletons = this.parseSkeletons(json.skeletons, object);
    this.bindSkeletons(object, skeletons);
    if (onLoad !== void 0) {
      let hasImages = false;
      for (const uuid2 in images) {
        if (images[uuid2] instanceof HTMLImageElement) {
          hasImages = true;
          break;
        }
      }
      if (hasImages === false)
        onLoad(object);
    }
    return object;
  }
  async parseAsync(json) {
    const animations = this.parseAnimations(json.animations);
    const shapes = this.parseShapes(json.shapes);
    const geometries = this.parseGeometries(json.geometries, shapes);
    const images = await this.parseImagesAsync(json.images);
    const textures = this.parseTextures(json.textures, images);
    const materials = this.parseMaterials(json.materials, textures);
    const object = this.parseObject(json.object, geometries, materials, textures, animations);
    const skeletons = this.parseSkeletons(json.skeletons, object);
    this.bindSkeletons(object, skeletons);
    return object;
  }
  parseShapes(json) {
    const shapes = {};
    if (json !== void 0) {
      for (let i = 0, l = json.length; i < l; i++) {
        const shape2 = new Shape().fromJSON(json[i]);
        shapes[shape2.uuid] = shape2;
      }
    }
    return shapes;
  }
  parseSkeletons(json, object) {
    const skeletons = {};
    const bones = {};
    object.traverse(function(child) {
      if (child.isBone)
        bones[child.uuid] = child;
    });
    if (json !== void 0) {
      for (let i = 0, l = json.length; i < l; i++) {
        const skeleton = new Skeleton().fromJSON(json[i], bones);
        skeletons[skeleton.uuid] = skeleton;
      }
    }
    return skeletons;
  }
  parseGeometries(json, shapes) {
    const geometries = {};
    if (json !== void 0) {
      const bufferGeometryLoader = new BufferGeometryLoader();
      for (let i = 0, l = json.length; i < l; i++) {
        let geometry;
        const data = json[i];
        switch (data.type) {
          case "BufferGeometry":
          case "InstancedBufferGeometry":
            geometry = bufferGeometryLoader.parse(data);
            break;
          case "Geometry":
            console.error("THREE.ObjectLoader: The legacy Geometry type is no longer supported.");
            break;
          default:
            if (data.type in Geometries) {
              geometry = Geometries[data.type].fromJSON(data, shapes);
            } else {
              console.warn(`THREE.ObjectLoader: Unsupported geometry type "${data.type}"`);
            }
        }
        geometry.uuid = data.uuid;
        if (data.name !== void 0)
          geometry.name = data.name;
        if (geometry.isBufferGeometry === true && data.userData !== void 0)
          geometry.userData = data.userData;
        geometries[data.uuid] = geometry;
      }
    }
    return geometries;
  }
  parseMaterials(json, textures) {
    const cache = {};
    const materials = {};
    if (json !== void 0) {
      const loader = new MaterialLoader();
      loader.setTextures(textures);
      for (let i = 0, l = json.length; i < l; i++) {
        const data = json[i];
        if (data.type === "MultiMaterial") {
          const array = [];
          for (let j = 0; j < data.materials.length; j++) {
            const material = data.materials[j];
            if (cache[material.uuid] === void 0) {
              cache[material.uuid] = loader.parse(material);
            }
            array.push(cache[material.uuid]);
          }
          materials[data.uuid] = array;
        } else {
          if (cache[data.uuid] === void 0) {
            cache[data.uuid] = loader.parse(data);
          }
          materials[data.uuid] = cache[data.uuid];
        }
      }
    }
    return materials;
  }
  parseAnimations(json) {
    const animations = {};
    if (json !== void 0) {
      for (let i = 0; i < json.length; i++) {
        const data = json[i];
        const clip = AnimationClip.parse(data);
        animations[clip.uuid] = clip;
      }
    }
    return animations;
  }
  parseImages(json, onLoad) {
    const scope = this;
    const images = {};
    let loader;
    function loadImage(url) {
      scope.manager.itemStart(url);
      return loader.load(url, function() {
        scope.manager.itemEnd(url);
      }, void 0, function() {
        scope.manager.itemError(url);
        scope.manager.itemEnd(url);
      });
    }
    function deserializeImage(image2) {
      if (typeof image2 === "string") {
        const url = image2;
        const path = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(url) ? url : scope.resourcePath + url;
        return loadImage(path);
      } else {
        if (image2.data) {
          return {
            data: getTypedArray(image2.type, image2.data),
            width: image2.width,
            height: image2.height
          };
        } else {
          return null;
        }
      }
    }
    if (json !== void 0 && json.length > 0) {
      const manager = new LoadingManager(onLoad);
      loader = new ImageLoader(manager);
      loader.setCrossOrigin(this.crossOrigin);
      for (let i = 0, il = json.length; i < il; i++) {
        const image2 = json[i];
        const url = image2.url;
        if (Array.isArray(url)) {
          const imageArray = [];
          for (let j = 0, jl = url.length; j < jl; j++) {
            const currentUrl = url[j];
            const deserializedImage = deserializeImage(currentUrl);
            if (deserializedImage !== null) {
              if (deserializedImage instanceof HTMLImageElement) {
                imageArray.push(deserializedImage);
              } else {
                imageArray.push(new DataTexture(deserializedImage.data, deserializedImage.width, deserializedImage.height));
              }
            }
          }
          images[image2.uuid] = new Source(imageArray);
        } else {
          const deserializedImage = deserializeImage(image2.url);
          images[image2.uuid] = new Source(deserializedImage);
        }
      }
    }
    return images;
  }
  async parseImagesAsync(json) {
    const scope = this;
    const images = {};
    let loader;
    async function deserializeImage(image2) {
      if (typeof image2 === "string") {
        const url = image2;
        const path = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(url) ? url : scope.resourcePath + url;
        return await loader.loadAsync(path);
      } else {
        if (image2.data) {
          return {
            data: getTypedArray(image2.type, image2.data),
            width: image2.width,
            height: image2.height
          };
        } else {
          return null;
        }
      }
    }
    if (json !== void 0 && json.length > 0) {
      loader = new ImageLoader(this.manager);
      loader.setCrossOrigin(this.crossOrigin);
      for (let i = 0, il = json.length; i < il; i++) {
        const image2 = json[i];
        const url = image2.url;
        if (Array.isArray(url)) {
          const imageArray = [];
          for (let j = 0, jl = url.length; j < jl; j++) {
            const currentUrl = url[j];
            const deserializedImage = await deserializeImage(currentUrl);
            if (deserializedImage !== null) {
              if (deserializedImage instanceof HTMLImageElement) {
                imageArray.push(deserializedImage);
              } else {
                imageArray.push(new DataTexture(deserializedImage.data, deserializedImage.width, deserializedImage.height));
              }
            }
          }
          images[image2.uuid] = new Source(imageArray);
        } else {
          const deserializedImage = await deserializeImage(image2.url);
          images[image2.uuid] = new Source(deserializedImage);
        }
      }
    }
    return images;
  }
  parseTextures(json, images) {
    function parseConstant(value, type) {
      if (typeof value === "number")
        return value;
      console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.", value);
      return type[value];
    }
    const textures = {};
    if (json !== void 0) {
      for (let i = 0, l = json.length; i < l; i++) {
        const data = json[i];
        if (data.image === void 0) {
          console.warn('THREE.ObjectLoader: No "image" specified for', data.uuid);
        }
        if (images[data.image] === void 0) {
          console.warn("THREE.ObjectLoader: Undefined image", data.image);
        }
        const source2 = images[data.image];
        const image2 = source2.data;
        let texture2;
        if (Array.isArray(image2)) {
          texture2 = new CubeTexture();
          if (image2.length === 6)
            texture2.needsUpdate = true;
        } else {
          if (image2 && image2.data) {
            texture2 = new DataTexture();
          } else {
            texture2 = new Texture();
          }
          if (image2)
            texture2.needsUpdate = true;
        }
        texture2.source = source2;
        texture2.uuid = data.uuid;
        if (data.name !== void 0)
          texture2.name = data.name;
        if (data.mapping !== void 0)
          texture2.mapping = parseConstant(data.mapping, TEXTURE_MAPPING);
        if (data.offset !== void 0)
          texture2.offset.fromArray(data.offset);
        if (data.repeat !== void 0)
          texture2.repeat.fromArray(data.repeat);
        if (data.center !== void 0)
          texture2.center.fromArray(data.center);
        if (data.rotation !== void 0)
          texture2.rotation = data.rotation;
        if (data.wrap !== void 0) {
          texture2.wrapS = parseConstant(data.wrap[0], TEXTURE_WRAPPING);
          texture2.wrapT = parseConstant(data.wrap[1], TEXTURE_WRAPPING);
        }
        if (data.format !== void 0)
          texture2.format = data.format;
        if (data.type !== void 0)
          texture2.type = data.type;
        if (data.encoding !== void 0)
          texture2.encoding = data.encoding;
        if (data.minFilter !== void 0)
          texture2.minFilter = parseConstant(data.minFilter, TEXTURE_FILTER);
        if (data.magFilter !== void 0)
          texture2.magFilter = parseConstant(data.magFilter, TEXTURE_FILTER);
        if (data.anisotropy !== void 0)
          texture2.anisotropy = data.anisotropy;
        if (data.flipY !== void 0)
          texture2.flipY = data.flipY;
        if (data.premultiplyAlpha !== void 0)
          texture2.premultiplyAlpha = data.premultiplyAlpha;
        if (data.unpackAlignment !== void 0)
          texture2.unpackAlignment = data.unpackAlignment;
        if (data.userData !== void 0)
          texture2.userData = data.userData;
        textures[data.uuid] = texture2;
      }
    }
    return textures;
  }
  parseObject(data, geometries, materials, textures, animations) {
    let object;
    function getGeometry(name) {
      if (geometries[name] === void 0) {
        console.warn("THREE.ObjectLoader: Undefined geometry", name);
      }
      return geometries[name];
    }
    function getMaterial(name) {
      if (name === void 0)
        return void 0;
      if (Array.isArray(name)) {
        const array = [];
        for (let i = 0, l = name.length; i < l; i++) {
          const uuid2 = name[i];
          if (materials[uuid2] === void 0) {
            console.warn("THREE.ObjectLoader: Undefined material", uuid2);
          }
          array.push(materials[uuid2]);
        }
        return array;
      }
      if (materials[name] === void 0) {
        console.warn("THREE.ObjectLoader: Undefined material", name);
      }
      return materials[name];
    }
    function getTexture(uuid2) {
      if (textures[uuid2] === void 0) {
        console.warn("THREE.ObjectLoader: Undefined texture", uuid2);
      }
      return textures[uuid2];
    }
    let geometry, material;
    switch (data.type) {
      case "Scene":
        object = new Scene();
        if (data.background !== void 0) {
          if (Number.isInteger(data.background)) {
            object.background = new Color(data.background);
          } else {
            object.background = getTexture(data.background);
          }
        }
        if (data.environment !== void 0) {
          object.environment = getTexture(data.environment);
        }
        if (data.fog !== void 0) {
          if (data.fog.type === "Fog") {
            object.fog = new Fog(data.fog.color, data.fog.near, data.fog.far);
          } else if (data.fog.type === "FogExp2") {
            object.fog = new FogExp2(data.fog.color, data.fog.density);
          }
        }
        break;
      case "PerspectiveCamera":
        object = new PerspectiveCamera(data.fov, data.aspect, data.near, data.far);
        if (data.focus !== void 0)
          object.focus = data.focus;
        if (data.zoom !== void 0)
          object.zoom = data.zoom;
        if (data.filmGauge !== void 0)
          object.filmGauge = data.filmGauge;
        if (data.filmOffset !== void 0)
          object.filmOffset = data.filmOffset;
        if (data.view !== void 0)
          object.view = Object.assign({}, data.view);
        break;
      case "OrthographicCamera":
        object = new OrthographicCamera(data.left, data.right, data.top, data.bottom, data.near, data.far);
        if (data.zoom !== void 0)
          object.zoom = data.zoom;
        if (data.view !== void 0)
          object.view = Object.assign({}, data.view);
        break;
      case "AmbientLight":
        object = new AmbientLight(data.color, data.intensity);
        break;
      case "DirectionalLight":
        object = new DirectionalLight(data.color, data.intensity);
        break;
      case "PointLight":
        object = new PointLight(data.color, data.intensity, data.distance, data.decay);
        break;
      case "RectAreaLight":
        object = new RectAreaLight(data.color, data.intensity, data.width, data.height);
        break;
      case "SpotLight":
        object = new SpotLight(data.color, data.intensity, data.distance, data.angle, data.penumbra, data.decay);
        break;
      case "HemisphereLight":
        object = new HemisphereLight(data.color, data.groundColor, data.intensity);
        break;
      case "LightProbe":
        object = new LightProbe().fromJSON(data);
        break;
      case "SkinnedMesh":
        geometry = getGeometry(data.geometry);
        material = getMaterial(data.material);
        object = new SkinnedMesh(geometry, material);
        if (data.bindMode !== void 0)
          object.bindMode = data.bindMode;
        if (data.bindMatrix !== void 0)
          object.bindMatrix.fromArray(data.bindMatrix);
        if (data.skeleton !== void 0)
          object.skeleton = data.skeleton;
        break;
      case "Mesh":
        geometry = getGeometry(data.geometry);
        material = getMaterial(data.material);
        object = new Mesh(geometry, material);
        break;
      case "InstancedMesh":
        geometry = getGeometry(data.geometry);
        material = getMaterial(data.material);
        const count = data.count;
        const instanceMatrix = data.instanceMatrix;
        const instanceColor = data.instanceColor;
        object = new InstancedMesh(geometry, material, count);
        object.instanceMatrix = new InstancedBufferAttribute(new Float32Array(instanceMatrix.array), 16);
        if (instanceColor !== void 0)
          object.instanceColor = new InstancedBufferAttribute(new Float32Array(instanceColor.array), instanceColor.itemSize);
        break;
      case "LOD":
        object = new LOD();
        break;
      case "Line":
        object = new Line(getGeometry(data.geometry), getMaterial(data.material));
        break;
      case "LineLoop":
        object = new LineLoop(getGeometry(data.geometry), getMaterial(data.material));
        break;
      case "LineSegments":
        object = new LineSegments(getGeometry(data.geometry), getMaterial(data.material));
        break;
      case "PointCloud":
      case "Points":
        object = new Points(getGeometry(data.geometry), getMaterial(data.material));
        break;
      case "Sprite":
        object = new Sprite(getMaterial(data.material));
        break;
      case "Group":
        object = new Group();
        break;
      case "Bone":
        object = new Bone();
        break;
      default:
        object = new Object3D();
    }
    object.uuid = data.uuid;
    if (data.name !== void 0)
      object.name = data.name;
    if (data.matrix !== void 0) {
      object.matrix.fromArray(data.matrix);
      if (data.matrixAutoUpdate !== void 0)
        object.matrixAutoUpdate = data.matrixAutoUpdate;
      if (object.matrixAutoUpdate)
        object.matrix.decompose(object.position, object.quaternion, object.scale);
    } else {
      if (data.position !== void 0)
        object.position.fromArray(data.position);
      if (data.rotation !== void 0)
        object.rotation.fromArray(data.rotation);
      if (data.quaternion !== void 0)
        object.quaternion.fromArray(data.quaternion);
      if (data.scale !== void 0)
        object.scale.fromArray(data.scale);
    }
    if (data.castShadow !== void 0)
      object.castShadow = data.castShadow;
    if (data.receiveShadow !== void 0)
      object.receiveShadow = data.receiveShadow;
    if (data.shadow) {
      if (data.shadow.bias !== void 0)
        object.shadow.bias = data.shadow.bias;
      if (data.shadow.normalBias !== void 0)
        object.shadow.normalBias = data.shadow.normalBias;
      if (data.shadow.radius !== void 0)
        object.shadow.radius = data.shadow.radius;
      if (data.shadow.mapSize !== void 0)
        object.shadow.mapSize.fromArray(data.shadow.mapSize);
      if (data.shadow.camera !== void 0)
        object.shadow.camera = this.parseObject(data.shadow.camera);
    }
    if (data.visible !== void 0)
      object.visible = data.visible;
    if (data.frustumCulled !== void 0)
      object.frustumCulled = data.frustumCulled;
    if (data.renderOrder !== void 0)
      object.renderOrder = data.renderOrder;
    if (data.userData !== void 0)
      object.userData = data.userData;
    if (data.layers !== void 0)
      object.layers.mask = data.layers;
    if (data.children !== void 0) {
      const children2 = data.children;
      for (let i = 0; i < children2.length; i++) {
        object.add(this.parseObject(children2[i], geometries, materials, textures, animations));
      }
    }
    if (data.animations !== void 0) {
      const objectAnimations = data.animations;
      for (let i = 0; i < objectAnimations.length; i++) {
        const uuid2 = objectAnimations[i];
        object.animations.push(animations[uuid2]);
      }
    }
    if (data.type === "LOD") {
      if (data.autoUpdate !== void 0)
        object.autoUpdate = data.autoUpdate;
      const levels = data.levels;
      for (let l = 0; l < levels.length; l++) {
        const level = levels[l];
        const child = object.getObjectByProperty("uuid", level.object);
        if (child !== void 0) {
          object.addLevel(child, level.distance);
        }
      }
    }
    return object;
  }
  bindSkeletons(object, skeletons) {
    if (Object.keys(skeletons).length === 0)
      return;
    object.traverse(function(child) {
      if (child.isSkinnedMesh === true && child.skeleton !== void 0) {
        const skeleton = skeletons[child.skeleton];
        if (skeleton === void 0) {
          console.warn("THREE.ObjectLoader: No skeleton found with UUID:", child.skeleton);
        } else {
          child.bind(skeleton, child.bindMatrix);
        }
      }
    });
  }
  setTexturePath(value) {
    console.warn("THREE.ObjectLoader: .setTexturePath() has been renamed to .setResourcePath().");
    return this.setResourcePath(value);
  }
}
const TEXTURE_MAPPING = {
  UVMapping,
  CubeReflectionMapping,
  CubeRefractionMapping,
  EquirectangularReflectionMapping,
  EquirectangularRefractionMapping,
  CubeUVReflectionMapping
};
const TEXTURE_WRAPPING = {
  RepeatWrapping,
  ClampToEdgeWrapping,
  MirroredRepeatWrapping
};
const TEXTURE_FILTER = {
  NearestFilter,
  NearestMipmapNearestFilter,
  NearestMipmapLinearFilter,
  LinearFilter,
  LinearMipmapNearestFilter,
  LinearMipmapLinearFilter
};
class ImageBitmapLoader extends Loader {
  constructor(manager) {
    super(manager);
    if (typeof createImageBitmap === "undefined") {
      console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported.");
    }
    if (typeof fetch === "undefined") {
      console.warn("THREE.ImageBitmapLoader: fetch() not supported.");
    }
    this.options = { premultiplyAlpha: "none" };
  }
  setOptions(options2) {
    this.options = options2;
    return this;
  }
  load(url, onLoad, onProgress, onError) {
    if (url === void 0)
      url = "";
    if (this.path !== void 0)
      url = this.path + url;
    url = this.manager.resolveURL(url);
    const scope = this;
    const cached = Cache.get(url);
    if (cached !== void 0) {
      scope.manager.itemStart(url);
      setTimeout(function() {
        if (onLoad)
          onLoad(cached);
        scope.manager.itemEnd(url);
      }, 0);
      return cached;
    }
    const fetchOptions = {};
    fetchOptions.credentials = this.crossOrigin === "anonymous" ? "same-origin" : "include";
    fetchOptions.headers = this.requestHeader;
    fetch(url, fetchOptions).then(function(res) {
      return res.blob();
    }).then(function(blob) {
      return createImageBitmap(blob, Object.assign(scope.options, { colorSpaceConversion: "none" }));
    }).then(function(imageBitmap) {
      Cache.add(url, imageBitmap);
      if (onLoad)
        onLoad(imageBitmap);
      scope.manager.itemEnd(url);
    }).catch(function(e) {
      if (onError)
        onError(e);
      scope.manager.itemError(url);
      scope.manager.itemEnd(url);
    });
    scope.manager.itemStart(url);
  }
}
ImageBitmapLoader.prototype.isImageBitmapLoader = true;
let _context;
const AudioContext = {
  getContext: function() {
    if (_context === void 0) {
      _context = new (window.AudioContext || window.webkitAudioContext)();
    }
    return _context;
  },
  setContext: function(value) {
    _context = value;
  }
};
class AudioLoader extends Loader {
  constructor(manager) {
    super(manager);
  }
  load(url, onLoad, onProgress, onError) {
    const scope = this;
    const loader = new FileLoader(this.manager);
    loader.setResponseType("arraybuffer");
    loader.setPath(this.path);
    loader.setRequestHeader(this.requestHeader);
    loader.setWithCredentials(this.withCredentials);
    loader.load(url, function(buffer) {
      try {
        const bufferCopy = buffer.slice(0);
        const context = AudioContext.getContext();
        context.decodeAudioData(bufferCopy, function(audioBuffer) {
          onLoad(audioBuffer);
        });
      } catch (e) {
        if (onError) {
          onError(e);
        } else {
          console.error(e);
        }
        scope.manager.itemError(url);
      }
    }, onProgress, onError);
  }
}
class HemisphereLightProbe extends LightProbe {
  constructor(skyColor, groundColor, intensity = 1) {
    super(void 0, intensity);
    const color1 = new Color().set(skyColor);
    const color2 = new Color().set(groundColor);
    const sky = new Vector3(color1.r, color1.g, color1.b);
    const ground = new Vector3(color2.r, color2.g, color2.b);
    const c0 = Math.sqrt(Math.PI);
    const c1 = c0 * Math.sqrt(0.75);
    this.sh.coefficients[0].copy(sky).add(ground).multiplyScalar(c0);
    this.sh.coefficients[1].copy(sky).sub(ground).multiplyScalar(c1);
  }
}
HemisphereLightProbe.prototype.isHemisphereLightProbe = true;
class AmbientLightProbe extends LightProbe {
  constructor(color2, intensity = 1) {
    super(void 0, intensity);
    const color1 = new Color().set(color2);
    this.sh.coefficients[0].set(color1.r, color1.g, color1.b).multiplyScalar(2 * Math.sqrt(Math.PI));
  }
}
AmbientLightProbe.prototype.isAmbientLightProbe = true;
class Audio extends Object3D {
  constructor(listener) {
    super();
    this.type = "Audio";
    this.listener = listener;
    this.context = listener.context;
    this.gain = this.context.createGain();
    this.gain.connect(listener.getInput());
    this.autoplay = false;
    this.buffer = null;
    this.detune = 0;
    this.loop = false;
    this.loopStart = 0;
    this.loopEnd = 0;
    this.offset = 0;
    this.duration = void 0;
    this.playbackRate = 1;
    this.isPlaying = false;
    this.hasPlaybackControl = true;
    this.source = null;
    this.sourceType = "empty";
    this._startedAt = 0;
    this._progress = 0;
    this._connected = false;
    this.filters = [];
  }
  getOutput() {
    return this.gain;
  }
  setNodeSource(audioNode) {
    this.hasPlaybackControl = false;
    this.sourceType = "audioNode";
    this.source = audioNode;
    this.connect();
    return this;
  }
  setMediaElementSource(mediaElement) {
    this.hasPlaybackControl = false;
    this.sourceType = "mediaNode";
    this.source = this.context.createMediaElementSource(mediaElement);
    this.connect();
    return this;
  }
  setMediaStreamSource(mediaStream) {
    this.hasPlaybackControl = false;
    this.sourceType = "mediaStreamNode";
    this.source = this.context.createMediaStreamSource(mediaStream);
    this.connect();
    return this;
  }
  setBuffer(audioBuffer) {
    this.buffer = audioBuffer;
    this.sourceType = "buffer";
    if (this.autoplay)
      this.play();
    return this;
  }
  play(delay = 0) {
    if (this.isPlaying === true) {
      console.warn("THREE.Audio: Audio is already playing.");
      return;
    }
    if (this.hasPlaybackControl === false) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    this._startedAt = this.context.currentTime + delay;
    const source2 = this.context.createBufferSource();
    source2.buffer = this.buffer;
    source2.loop = this.loop;
    source2.loopStart = this.loopStart;
    source2.loopEnd = this.loopEnd;
    source2.onended = this.onEnded.bind(this);
    source2.start(this._startedAt, this._progress + this.offset, this.duration);
    this.isPlaying = true;
    this.source = source2;
    this.setDetune(this.detune);
    this.setPlaybackRate(this.playbackRate);
    return this.connect();
  }
  pause() {
    if (this.hasPlaybackControl === false) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    if (this.isPlaying === true) {
      this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate;
      if (this.loop === true) {
        this._progress = this._progress % (this.duration || this.buffer.duration);
      }
      this.source.stop();
      this.source.onended = null;
      this.isPlaying = false;
    }
    return this;
  }
  stop() {
    if (this.hasPlaybackControl === false) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    this._progress = 0;
    this.source.stop();
    this.source.onended = null;
    this.isPlaying = false;
    return this;
  }
  connect() {
    if (this.filters.length > 0) {
      this.source.connect(this.filters[0]);
      for (let i = 1, l = this.filters.length; i < l; i++) {
        this.filters[i - 1].connect(this.filters[i]);
      }
      this.filters[this.filters.length - 1].connect(this.getOutput());
    } else {
      this.source.connect(this.getOutput());
    }
    this._connected = true;
    return this;
  }
  disconnect() {
    if (this.filters.length > 0) {
      this.source.disconnect(this.filters[0]);
      for (let i = 1, l = this.filters.length; i < l; i++) {
        this.filters[i - 1].disconnect(this.filters[i]);
      }
      this.filters[this.filters.length - 1].disconnect(this.getOutput());
    } else {
      this.source.disconnect(this.getOutput());
    }
    this._connected = false;
    return this;
  }
  getFilters() {
    return this.filters;
  }
  setFilters(value) {
    if (!value)
      value = [];
    if (this._connected === true) {
      this.disconnect();
      this.filters = value.slice();
      this.connect();
    } else {
      this.filters = value.slice();
    }
    return this;
  }
  setDetune(value) {
    this.detune = value;
    if (this.source.detune === void 0)
      return;
    if (this.isPlaying === true) {
      this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, 0.01);
    }
    return this;
  }
  getDetune() {
    return this.detune;
  }
  getFilter() {
    return this.getFilters()[0];
  }
  setFilter(filter2) {
    return this.setFilters(filter2 ? [filter2] : []);
  }
  setPlaybackRate(value) {
    if (this.hasPlaybackControl === false) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    this.playbackRate = value;
    if (this.isPlaying === true) {
      this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, 0.01);
    }
    return this;
  }
  getPlaybackRate() {
    return this.playbackRate;
  }
  onEnded() {
    this.isPlaying = false;
  }
  getLoop() {
    if (this.hasPlaybackControl === false) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return false;
    }
    return this.loop;
  }
  setLoop(value) {
    if (this.hasPlaybackControl === false) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    this.loop = value;
    if (this.isPlaying === true) {
      this.source.loop = this.loop;
    }
    return this;
  }
  setLoopStart(value) {
    this.loopStart = value;
    return this;
  }
  setLoopEnd(value) {
    this.loopEnd = value;
    return this;
  }
  getVolume() {
    return this.gain.gain.value;
  }
  setVolume(value) {
    this.gain.gain.setTargetAtTime(value, this.context.currentTime, 0.01);
    return this;
  }
}
class PropertyMixer {
  constructor(binding, typeName, valueSize) {
    this.binding = binding;
    this.valueSize = valueSize;
    let mixFunction, mixFunctionAdditive, setIdentity;
    switch (typeName) {
      case "quaternion":
        mixFunction = this._slerp;
        mixFunctionAdditive = this._slerpAdditive;
        setIdentity = this._setAdditiveIdentityQuaternion;
        this.buffer = new Float64Array(valueSize * 6);
        this._workIndex = 5;
        break;
      case "string":
      case "bool":
        mixFunction = this._select;
        mixFunctionAdditive = this._select;
        setIdentity = this._setAdditiveIdentityOther;
        this.buffer = new Array(valueSize * 5);
        break;
      default:
        mixFunction = this._lerp;
        mixFunctionAdditive = this._lerpAdditive;
        setIdentity = this._setAdditiveIdentityNumeric;
        this.buffer = new Float64Array(valueSize * 5);
    }
    this._mixBufferRegion = mixFunction;
    this._mixBufferRegionAdditive = mixFunctionAdditive;
    this._setIdentity = setIdentity;
    this._origIndex = 3;
    this._addIndex = 4;
    this.cumulativeWeight = 0;
    this.cumulativeWeightAdditive = 0;
    this.useCount = 0;
    this.referenceCount = 0;
  }
  accumulate(accuIndex, weight) {
    const buffer = this.buffer, stride = this.valueSize, offset = accuIndex * stride + stride;
    let currentWeight = this.cumulativeWeight;
    if (currentWeight === 0) {
      for (let i = 0; i !== stride; ++i) {
        buffer[offset + i] = buffer[i];
      }
      currentWeight = weight;
    } else {
      currentWeight += weight;
      const mix2 = weight / currentWeight;
      this._mixBufferRegion(buffer, offset, 0, mix2, stride);
    }
    this.cumulativeWeight = currentWeight;
  }
  accumulateAdditive(weight) {
    const buffer = this.buffer, stride = this.valueSize, offset = stride * this._addIndex;
    if (this.cumulativeWeightAdditive === 0) {
      this._setIdentity();
    }
    this._mixBufferRegionAdditive(buffer, offset, 0, weight, stride);
    this.cumulativeWeightAdditive += weight;
  }
  apply(accuIndex) {
    const stride = this.valueSize, buffer = this.buffer, offset = accuIndex * stride + stride, weight = this.cumulativeWeight, weightAdditive = this.cumulativeWeightAdditive, binding = this.binding;
    this.cumulativeWeight = 0;
    this.cumulativeWeightAdditive = 0;
    if (weight < 1) {
      const originalValueOffset = stride * this._origIndex;
      this._mixBufferRegion(buffer, offset, originalValueOffset, 1 - weight, stride);
    }
    if (weightAdditive > 0) {
      this._mixBufferRegionAdditive(buffer, offset, this._addIndex * stride, 1, stride);
    }
    for (let i = stride, e = stride + stride; i !== e; ++i) {
      if (buffer[i] !== buffer[i + stride]) {
        binding.setValue(buffer, offset);
        break;
      }
    }
  }
  saveOriginalState() {
    const binding = this.binding;
    const buffer = this.buffer, stride = this.valueSize, originalValueOffset = stride * this._origIndex;
    binding.getValue(buffer, originalValueOffset);
    for (let i = stride, e = originalValueOffset; i !== e; ++i) {
      buffer[i] = buffer[originalValueOffset + i % stride];
    }
    this._setIdentity();
    this.cumulativeWeight = 0;
    this.cumulativeWeightAdditive = 0;
  }
  restoreOriginalState() {
    const originalValueOffset = this.valueSize * 3;
    this.binding.setValue(this.buffer, originalValueOffset);
  }
  _setAdditiveIdentityNumeric() {
    const startIndex = this._addIndex * this.valueSize;
    const endIndex = startIndex + this.valueSize;
    for (let i = startIndex; i < endIndex; i++) {
      this.buffer[i] = 0;
    }
  }
  _setAdditiveIdentityQuaternion() {
    this._setAdditiveIdentityNumeric();
    this.buffer[this._addIndex * this.valueSize + 3] = 1;
  }
  _setAdditiveIdentityOther() {
    const startIndex = this._origIndex * this.valueSize;
    const targetIndex = this._addIndex * this.valueSize;
    for (let i = 0; i < this.valueSize; i++) {
      this.buffer[targetIndex + i] = this.buffer[startIndex + i];
    }
  }
  _select(buffer, dstOffset, srcOffset, t, stride) {
    if (t >= 0.5) {
      for (let i = 0; i !== stride; ++i) {
        buffer[dstOffset + i] = buffer[srcOffset + i];
      }
    }
  }
  _slerp(buffer, dstOffset, srcOffset, t) {
    Quaternion.slerpFlat(buffer, dstOffset, buffer, dstOffset, buffer, srcOffset, t);
  }
  _slerpAdditive(buffer, dstOffset, srcOffset, t, stride) {
    const workOffset = this._workIndex * stride;
    Quaternion.multiplyQuaternionsFlat(buffer, workOffset, buffer, dstOffset, buffer, srcOffset);
    Quaternion.slerpFlat(buffer, dstOffset, buffer, dstOffset, buffer, workOffset, t);
  }
  _lerp(buffer, dstOffset, srcOffset, t, stride) {
    const s = 1 - t;
    for (let i = 0; i !== stride; ++i) {
      const j = dstOffset + i;
      buffer[j] = buffer[j] * s + buffer[srcOffset + i] * t;
    }
  }
  _lerpAdditive(buffer, dstOffset, srcOffset, t, stride) {
    for (let i = 0; i !== stride; ++i) {
      const j = dstOffset + i;
      buffer[j] = buffer[j] + buffer[srcOffset + i] * t;
    }
  }
}
const _RESERVED_CHARS_RE = "\\[\\]\\.:\\/";
const _reservedRe = new RegExp("[" + _RESERVED_CHARS_RE + "]", "g");
const _wordChar = "[^" + _RESERVED_CHARS_RE + "]";
const _wordCharOrDot = "[^" + _RESERVED_CHARS_RE.replace("\\.", "") + "]";
const _directoryRe = /((?:WC+[\/:])*)/.source.replace("WC", _wordChar);
const _nodeRe = /(WCOD+)?/.source.replace("WCOD", _wordCharOrDot);
const _objectRe = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", _wordChar);
const _propertyRe = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", _wordChar);
const _trackRe = new RegExp("^" + _directoryRe + _nodeRe + _objectRe + _propertyRe + "$");
const _supportedObjectNames = ["material", "materials", "bones"];
class Composite {
  constructor(targetGroup, path, optionalParsedPath) {
    const parsedPath = optionalParsedPath || PropertyBinding.parseTrackName(path);
    this._targetGroup = targetGroup;
    this._bindings = targetGroup.subscribe_(path, parsedPath);
  }
  getValue(array, offset) {
    this.bind();
    const firstValidIndex = this._targetGroup.nCachedObjects_, binding = this._bindings[firstValidIndex];
    if (binding !== void 0)
      binding.getValue(array, offset);
  }
  setValue(array, offset) {
    const bindings = this._bindings;
    for (let i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++i) {
      bindings[i].setValue(array, offset);
    }
  }
  bind() {
    const bindings = this._bindings;
    for (let i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++i) {
      bindings[i].bind();
    }
  }
  unbind() {
    const bindings = this._bindings;
    for (let i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++i) {
      bindings[i].unbind();
    }
  }
}
class PropertyBinding {
  constructor(rootNode, path, parsedPath) {
    this.path = path;
    this.parsedPath = parsedPath || PropertyBinding.parseTrackName(path);
    this.node = PropertyBinding.findNode(rootNode, this.parsedPath.nodeName) || rootNode;
    this.rootNode = rootNode;
    this.getValue = this._getValue_unbound;
    this.setValue = this._setValue_unbound;
  }
  static create(root, path, parsedPath) {
    if (!(root && root.isAnimationObjectGroup)) {
      return new PropertyBinding(root, path, parsedPath);
    } else {
      return new PropertyBinding.Composite(root, path, parsedPath);
    }
  }
  static sanitizeNodeName(name) {
    return name.replace(/\s/g, "_").replace(_reservedRe, "");
  }
  static parseTrackName(trackName) {
    const matches2 = _trackRe.exec(trackName);
    if (matches2 === null) {
      throw new Error("PropertyBinding: Cannot parse trackName: " + trackName);
    }
    const results = {
      nodeName: matches2[2],
      objectName: matches2[3],
      objectIndex: matches2[4],
      propertyName: matches2[5],
      propertyIndex: matches2[6]
    };
    const lastDot = results.nodeName && results.nodeName.lastIndexOf(".");
    if (lastDot !== void 0 && lastDot !== -1) {
      const objectName = results.nodeName.substring(lastDot + 1);
      if (_supportedObjectNames.indexOf(objectName) !== -1) {
        results.nodeName = results.nodeName.substring(0, lastDot);
        results.objectName = objectName;
      }
    }
    if (results.propertyName === null || results.propertyName.length === 0) {
      throw new Error("PropertyBinding: can not parse propertyName from trackName: " + trackName);
    }
    return results;
  }
  static findNode(root, nodeName) {
    if (nodeName === void 0 || nodeName === "" || nodeName === "." || nodeName === -1 || nodeName === root.name || nodeName === root.uuid) {
      return root;
    }
    if (root.skeleton) {
      const bone = root.skeleton.getBoneByName(nodeName);
      if (bone !== void 0) {
        return bone;
      }
    }
    if (root.children) {
      const searchNodeSubtree = function(children2) {
        for (let i = 0; i < children2.length; i++) {
          const childNode = children2[i];
          if (childNode.name === nodeName || childNode.uuid === nodeName) {
            return childNode;
          }
          const result = searchNodeSubtree(childNode.children);
          if (result)
            return result;
        }
        return null;
      };
      const subTreeNode = searchNodeSubtree(root.children);
      if (subTreeNode) {
        return subTreeNode;
      }
    }
    return null;
  }
  _getValue_unavailable() {
  }
  _setValue_unavailable() {
  }
  _getValue_direct(buffer, offset) {
    buffer[offset] = this.targetObject[this.propertyName];
  }
  _getValue_array(buffer, offset) {
    const source2 = this.resolvedProperty;
    for (let i = 0, n = source2.length; i !== n; ++i) {
      buffer[offset++] = source2[i];
    }
  }
  _getValue_arrayElement(buffer, offset) {
    buffer[offset] = this.resolvedProperty[this.propertyIndex];
  }
  _getValue_toArray(buffer, offset) {
    this.resolvedProperty.toArray(buffer, offset);
  }
  _setValue_direct(buffer, offset) {
    this.targetObject[this.propertyName] = buffer[offset];
  }
  _setValue_direct_setNeedsUpdate(buffer, offset) {
    this.targetObject[this.propertyName] = buffer[offset];
    this.targetObject.needsUpdate = true;
  }
  _setValue_direct_setMatrixWorldNeedsUpdate(buffer, offset) {
    this.targetObject[this.propertyName] = buffer[offset];
    this.targetObject.matrixWorldNeedsUpdate = true;
  }
  _setValue_array(buffer, offset) {
    const dest = this.resolvedProperty;
    for (let i = 0, n = dest.length; i !== n; ++i) {
      dest[i] = buffer[offset++];
    }
  }
  _setValue_array_setNeedsUpdate(buffer, offset) {
    const dest = this.resolvedProperty;
    for (let i = 0, n = dest.length; i !== n; ++i) {
      dest[i] = buffer[offset++];
    }
    this.targetObject.needsUpdate = true;
  }
  _setValue_array_setMatrixWorldNeedsUpdate(buffer, offset) {
    const dest = this.resolvedProperty;
    for (let i = 0, n = dest.length; i !== n; ++i) {
      dest[i] = buffer[offset++];
    }
    this.targetObject.matrixWorldNeedsUpdate = true;
  }
  _setValue_arrayElement(buffer, offset) {
    this.resolvedProperty[this.propertyIndex] = buffer[offset];
  }
  _setValue_arrayElement_setNeedsUpdate(buffer, offset) {
    this.resolvedProperty[this.propertyIndex] = buffer[offset];
    this.targetObject.needsUpdate = true;
  }
  _setValue_arrayElement_setMatrixWorldNeedsUpdate(buffer, offset) {
    this.resolvedProperty[this.propertyIndex] = buffer[offset];
    this.targetObject.matrixWorldNeedsUpdate = true;
  }
  _setValue_fromArray(buffer, offset) {
    this.resolvedProperty.fromArray(buffer, offset);
  }
  _setValue_fromArray_setNeedsUpdate(buffer, offset) {
    this.resolvedProperty.fromArray(buffer, offset);
    this.targetObject.needsUpdate = true;
  }
  _setValue_fromArray_setMatrixWorldNeedsUpdate(buffer, offset) {
    this.resolvedProperty.fromArray(buffer, offset);
    this.targetObject.matrixWorldNeedsUpdate = true;
  }
  _getValue_unbound(targetArray, offset) {
    this.bind();
    this.getValue(targetArray, offset);
  }
  _setValue_unbound(sourceArray, offset) {
    this.bind();
    this.setValue(sourceArray, offset);
  }
  bind() {
    let targetObject = this.node;
    const parsedPath = this.parsedPath;
    const objectName = parsedPath.objectName;
    const propertyName = parsedPath.propertyName;
    let propertyIndex = parsedPath.propertyIndex;
    if (!targetObject) {
      targetObject = PropertyBinding.findNode(this.rootNode, parsedPath.nodeName) || this.rootNode;
      this.node = targetObject;
    }
    this.getValue = this._getValue_unavailable;
    this.setValue = this._setValue_unavailable;
    if (!targetObject) {
      console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found.");
      return;
    }
    if (objectName) {
      let objectIndex = parsedPath.objectIndex;
      switch (objectName) {
        case "materials":
          if (!targetObject.material) {
            console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
            return;
          }
          if (!targetObject.material.materials) {
            console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
            return;
          }
          targetObject = targetObject.material.materials;
          break;
        case "bones":
          if (!targetObject.skeleton) {
            console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
            return;
          }
          targetObject = targetObject.skeleton.bones;
          for (let i = 0; i < targetObject.length; i++) {
            if (targetObject[i].name === objectIndex) {
              objectIndex = i;
              break;
            }
          }
          break;
        default:
          if (targetObject[objectName] === void 0) {
            console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
            return;
          }
          targetObject = targetObject[objectName];
      }
      if (objectIndex !== void 0) {
        if (targetObject[objectIndex] === void 0) {
          console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, targetObject);
          return;
        }
        targetObject = targetObject[objectIndex];
      }
    }
    const nodeProperty = targetObject[propertyName];
    if (nodeProperty === void 0) {
      const nodeName = parsedPath.nodeName;
      console.error("THREE.PropertyBinding: Trying to update property for track: " + nodeName + "." + propertyName + " but it wasn't found.", targetObject);
      return;
    }
    let versioning = this.Versioning.None;
    this.targetObject = targetObject;
    if (targetObject.needsUpdate !== void 0) {
      versioning = this.Versioning.NeedsUpdate;
    } else if (targetObject.matrixWorldNeedsUpdate !== void 0) {
      versioning = this.Versioning.MatrixWorldNeedsUpdate;
    }
    let bindingType = this.BindingType.Direct;
    if (propertyIndex !== void 0) {
      if (propertyName === "morphTargetInfluences") {
        if (!targetObject.geometry) {
          console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
          return;
        }
        if (targetObject.geometry.isBufferGeometry) {
          if (!targetObject.geometry.morphAttributes) {
            console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
            return;
          }
          if (targetObject.morphTargetDictionary[propertyIndex] !== void 0) {
            propertyIndex = targetObject.morphTargetDictionary[propertyIndex];
          }
        } else {
          console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.", this);
          return;
        }
      }
      bindingType = this.BindingType.ArrayElement;
      this.resolvedProperty = nodeProperty;
      this.propertyIndex = propertyIndex;
    } else if (nodeProperty.fromArray !== void 0 && nodeProperty.toArray !== void 0) {
      bindingType = this.BindingType.HasFromToArray;
      this.resolvedProperty = nodeProperty;
    } else if (Array.isArray(nodeProperty)) {
      bindingType = this.BindingType.EntireArray;
      this.resolvedProperty = nodeProperty;
    } else {
      this.propertyName = propertyName;
    }
    this.getValue = this.GetterByBindingType[bindingType];
    this.setValue = this.SetterByBindingTypeAndVersioning[bindingType][versioning];
  }
  unbind() {
    this.node = null;
    this.getValue = this._getValue_unbound;
    this.setValue = this._setValue_unbound;
  }
}
PropertyBinding.Composite = Composite;
PropertyBinding.prototype.BindingType = {
  Direct: 0,
  EntireArray: 1,
  ArrayElement: 2,
  HasFromToArray: 3
};
PropertyBinding.prototype.Versioning = {
  None: 0,
  NeedsUpdate: 1,
  MatrixWorldNeedsUpdate: 2
};
PropertyBinding.prototype.GetterByBindingType = [
  PropertyBinding.prototype._getValue_direct,
  PropertyBinding.prototype._getValue_array,
  PropertyBinding.prototype._getValue_arrayElement,
  PropertyBinding.prototype._getValue_toArray
];
PropertyBinding.prototype.SetterByBindingTypeAndVersioning = [
  [
    PropertyBinding.prototype._setValue_direct,
    PropertyBinding.prototype._setValue_direct_setNeedsUpdate,
    PropertyBinding.prototype._setValue_direct_setMatrixWorldNeedsUpdate
  ],
  [
    PropertyBinding.prototype._setValue_array,
    PropertyBinding.prototype._setValue_array_setNeedsUpdate,
    PropertyBinding.prototype._setValue_array_setMatrixWorldNeedsUpdate
  ],
  [
    PropertyBinding.prototype._setValue_arrayElement,
    PropertyBinding.prototype._setValue_arrayElement_setNeedsUpdate,
    PropertyBinding.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate
  ],
  [
    PropertyBinding.prototype._setValue_fromArray,
    PropertyBinding.prototype._setValue_fromArray_setNeedsUpdate,
    PropertyBinding.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate
  ]
];
class AnimationAction {
  constructor(mixer, clip, localRoot = null, blendMode = clip.blendMode) {
    this._mixer = mixer;
    this._clip = clip;
    this._localRoot = localRoot;
    this.blendMode = blendMode;
    const tracks = clip.tracks, nTracks = tracks.length, interpolants = new Array(nTracks);
    const interpolantSettings = {
      endingStart: ZeroCurvatureEnding,
      endingEnd: ZeroCurvatureEnding
    };
    for (let i = 0; i !== nTracks; ++i) {
      const interpolant = tracks[i].createInterpolant(null);
      interpolants[i] = interpolant;
      interpolant.settings = interpolantSettings;
    }
    this._interpolantSettings = interpolantSettings;
    this._interpolants = interpolants;
    this._propertyBindings = new Array(nTracks);
    this._cacheIndex = null;
    this._byClipCacheIndex = null;
    this._timeScaleInterpolant = null;
    this._weightInterpolant = null;
    this.loop = LoopRepeat;
    this._loopCount = -1;
    this._startTime = null;
    this.time = 0;
    this.timeScale = 1;
    this._effectiveTimeScale = 1;
    this.weight = 1;
    this._effectiveWeight = 1;
    this.repetitions = Infinity;
    this.paused = false;
    this.enabled = true;
    this.clampWhenFinished = false;
    this.zeroSlopeAtStart = true;
    this.zeroSlopeAtEnd = true;
  }
  play() {
    this._mixer._activateAction(this);
    return this;
  }
  stop() {
    this._mixer._deactivateAction(this);
    return this.reset();
  }
  reset() {
    this.paused = false;
    this.enabled = true;
    this.time = 0;
    this._loopCount = -1;
    this._startTime = null;
    return this.stopFading().stopWarping();
  }
  isRunning() {
    return this.enabled && !this.paused && this.timeScale !== 0 && this._startTime === null && this._mixer._isActiveAction(this);
  }
  isScheduled() {
    return this._mixer._isActiveAction(this);
  }
  startAt(time) {
    this._startTime = time;
    return this;
  }
  setLoop(mode, repetitions) {
    this.loop = mode;
    this.repetitions = repetitions;
    return this;
  }
  setEffectiveWeight(weight) {
    this.weight = weight;
    this._effectiveWeight = this.enabled ? weight : 0;
    return this.stopFading();
  }
  getEffectiveWeight() {
    return this._effectiveWeight;
  }
  fadeIn(duration) {
    return this._scheduleFading(duration, 0, 1);
  }
  fadeOut(duration) {
    return this._scheduleFading(duration, 1, 0);
  }
  crossFadeFrom(fadeOutAction, duration, warp) {
    fadeOutAction.fadeOut(duration);
    this.fadeIn(duration);
    if (warp) {
      const fadeInDuration = this._clip.duration, fadeOutDuration = fadeOutAction._clip.duration, startEndRatio = fadeOutDuration / fadeInDuration, endStartRatio = fadeInDuration / fadeOutDuration;
      fadeOutAction.warp(1, startEndRatio, duration);
      this.warp(endStartRatio, 1, duration);
    }
    return this;
  }
  crossFadeTo(fadeInAction, duration, warp) {
    return fadeInAction.crossFadeFrom(this, duration, warp);
  }
  stopFading() {
    const weightInterpolant = this._weightInterpolant;
    if (weightInterpolant !== null) {
      this._weightInterpolant = null;
      this._mixer._takeBackControlInterpolant(weightInterpolant);
    }
    return this;
  }
  setEffectiveTimeScale(timeScale) {
    this.timeScale = timeScale;
    this._effectiveTimeScale = this.paused ? 0 : timeScale;
    return this.stopWarping();
  }
  getEffectiveTimeScale() {
    return this._effectiveTimeScale;
  }
  setDuration(duration) {
    this.timeScale = this._clip.duration / duration;
    return this.stopWarping();
  }
  syncWith(action) {
    this.time = action.time;
    this.timeScale = action.timeScale;
    return this.stopWarping();
  }
  halt(duration) {
    return this.warp(this._effectiveTimeScale, 0, duration);
  }
  warp(startTimeScale, endTimeScale, duration) {
    const mixer = this._mixer, now = mixer.time, timeScale = this.timeScale;
    let interpolant = this._timeScaleInterpolant;
    if (interpolant === null) {
      interpolant = mixer._lendControlInterpolant();
      this._timeScaleInterpolant = interpolant;
    }
    const times = interpolant.parameterPositions, values = interpolant.sampleValues;
    times[0] = now;
    times[1] = now + duration;
    values[0] = startTimeScale / timeScale;
    values[1] = endTimeScale / timeScale;
    return this;
  }
  stopWarping() {
    const timeScaleInterpolant = this._timeScaleInterpolant;
    if (timeScaleInterpolant !== null) {
      this._timeScaleInterpolant = null;
      this._mixer._takeBackControlInterpolant(timeScaleInterpolant);
    }
    return this;
  }
  getMixer() {
    return this._mixer;
  }
  getClip() {
    return this._clip;
  }
  getRoot() {
    return this._localRoot || this._mixer._root;
  }
  _update(time, deltaTime, timeDirection, accuIndex) {
    if (!this.enabled) {
      this._updateWeight(time);
      return;
    }
    const startTime = this._startTime;
    if (startTime !== null) {
      const timeRunning = (time - startTime) * timeDirection;
      if (timeRunning < 0 || timeDirection === 0) {
        return;
      }
      this._startTime = null;
      deltaTime = timeDirection * timeRunning;
    }
    deltaTime *= this._updateTimeScale(time);
    const clipTime = this._updateTime(deltaTime);
    const weight = this._updateWeight(time);
    if (weight > 0) {
      const interpolants = this._interpolants;
      const propertyMixers = this._propertyBindings;
      switch (this.blendMode) {
        case AdditiveAnimationBlendMode:
          for (let j = 0, m = interpolants.length; j !== m; ++j) {
            interpolants[j].evaluate(clipTime);
            propertyMixers[j].accumulateAdditive(weight);
          }
          break;
        case NormalAnimationBlendMode:
        default:
          for (let j = 0, m = interpolants.length; j !== m; ++j) {
            interpolants[j].evaluate(clipTime);
            propertyMixers[j].accumulate(accuIndex, weight);
          }
      }
    }
  }
  _updateWeight(time) {
    let weight = 0;
    if (this.enabled) {
      weight = this.weight;
      const interpolant = this._weightInterpolant;
      if (interpolant !== null) {
        const interpolantValue = interpolant.evaluate(time)[0];
        weight *= interpolantValue;
        if (time > interpolant.parameterPositions[1]) {
          this.stopFading();
          if (interpolantValue === 0) {
            this.enabled = false;
          }
        }
      }
    }
    this._effectiveWeight = weight;
    return weight;
  }
  _updateTimeScale(time) {
    let timeScale = 0;
    if (!this.paused) {
      timeScale = this.timeScale;
      const interpolant = this._timeScaleInterpolant;
      if (interpolant !== null) {
        const interpolantValue = interpolant.evaluate(time)[0];
        timeScale *= interpolantValue;
        if (time > interpolant.parameterPositions[1]) {
          this.stopWarping();
          if (timeScale === 0) {
            this.paused = true;
          } else {
            this.timeScale = timeScale;
          }
        }
      }
    }
    this._effectiveTimeScale = timeScale;
    return timeScale;
  }
  _updateTime(deltaTime) {
    const duration = this._clip.duration;
    const loop = this.loop;
    let time = this.time + deltaTime;
    let loopCount = this._loopCount;
    const pingPong = loop === LoopPingPong;
    if (deltaTime === 0) {
      if (loopCount === -1)
        return time;
      return pingPong && (loopCount & 1) === 1 ? duration - time : time;
    }
    if (loop === LoopOnce) {
      if (loopCount === -1) {
        this._loopCount = 0;
        this._setEndings(true, true, false);
      }
      handle_stop: {
        if (time >= duration) {
          time = duration;
        } else if (time < 0) {
          time = 0;
        } else {
          this.time = time;
          break handle_stop;
        }
        if (this.clampWhenFinished)
          this.paused = true;
        else
          this.enabled = false;
        this.time = time;
        this._mixer.dispatchEvent({
          type: "finished",
          action: this,
          direction: deltaTime < 0 ? -1 : 1
        });
      }
    } else {
      if (loopCount === -1) {
        if (deltaTime >= 0) {
          loopCount = 0;
          this._setEndings(true, this.repetitions === 0, pingPong);
        } else {
          this._setEndings(this.repetitions === 0, true, pingPong);
        }
      }
      if (time >= duration || time < 0) {
        const loopDelta = Math.floor(time / duration);
        time -= duration * loopDelta;
        loopCount += Math.abs(loopDelta);
        const pending = this.repetitions - loopCount;
        if (pending <= 0) {
          if (this.clampWhenFinished)
            this.paused = true;
          else
            this.enabled = false;
          time = deltaTime > 0 ? duration : 0;
          this.time = time;
          this._mixer.dispatchEvent({
            type: "finished",
            action: this,
            direction: deltaTime > 0 ? 1 : -1
          });
        } else {
          if (pending === 1) {
            const atStart = deltaTime < 0;
            this._setEndings(atStart, !atStart, pingPong);
          } else {
            this._setEndings(false, false, pingPong);
          }
          this._loopCount = loopCount;
          this.time = time;
          this._mixer.dispatchEvent({
            type: "loop",
            action: this,
            loopDelta
          });
        }
      } else {
        this.time = time;
      }
      if (pingPong && (loopCount & 1) === 1) {
        return duration - time;
      }
    }
    return time;
  }
  _setEndings(atStart, atEnd, pingPong) {
    const settings = this._interpolantSettings;
    if (pingPong) {
      settings.endingStart = ZeroSlopeEnding;
      settings.endingEnd = ZeroSlopeEnding;
    } else {
      if (atStart) {
        settings.endingStart = this.zeroSlopeAtStart ? ZeroSlopeEnding : ZeroCurvatureEnding;
      } else {
        settings.endingStart = WrapAroundEnding;
      }
      if (atEnd) {
        settings.endingEnd = this.zeroSlopeAtEnd ? ZeroSlopeEnding : ZeroCurvatureEnding;
      } else {
        settings.endingEnd = WrapAroundEnding;
      }
    }
  }
  _scheduleFading(duration, weightNow, weightThen) {
    const mixer = this._mixer, now = mixer.time;
    let interpolant = this._weightInterpolant;
    if (interpolant === null) {
      interpolant = mixer._lendControlInterpolant();
      this._weightInterpolant = interpolant;
    }
    const times = interpolant.parameterPositions, values = interpolant.sampleValues;
    times[0] = now;
    values[0] = weightNow;
    times[1] = now + duration;
    values[1] = weightThen;
    return this;
  }
}
class AnimationMixer extends EventDispatcher {
  constructor(root) {
    super();
    this._root = root;
    this._initMemoryManager();
    this._accuIndex = 0;
    this.time = 0;
    this.timeScale = 1;
  }
  _bindAction(action, prototypeAction) {
    const root = action._localRoot || this._root, tracks = action._clip.tracks, nTracks = tracks.length, bindings = action._propertyBindings, interpolants = action._interpolants, rootUuid = root.uuid, bindingsByRoot = this._bindingsByRootAndName;
    let bindingsByName = bindingsByRoot[rootUuid];
    if (bindingsByName === void 0) {
      bindingsByName = {};
      bindingsByRoot[rootUuid] = bindingsByName;
    }
    for (let i = 0; i !== nTracks; ++i) {
      const track = tracks[i], trackName = track.name;
      let binding = bindingsByName[trackName];
      if (binding !== void 0) {
        ++binding.referenceCount;
        bindings[i] = binding;
      } else {
        binding = bindings[i];
        if (binding !== void 0) {
          if (binding._cacheIndex === null) {
            ++binding.referenceCount;
            this._addInactiveBinding(binding, rootUuid, trackName);
          }
          continue;
        }
        const path = prototypeAction && prototypeAction._propertyBindings[i].binding.parsedPath;
        binding = new PropertyMixer(PropertyBinding.create(root, trackName, path), track.ValueTypeName, track.getValueSize());
        ++binding.referenceCount;
        this._addInactiveBinding(binding, rootUuid, trackName);
        bindings[i] = binding;
      }
      interpolants[i].resultBuffer = binding.buffer;
    }
  }
  _activateAction(action) {
    if (!this._isActiveAction(action)) {
      if (action._cacheIndex === null) {
        const rootUuid = (action._localRoot || this._root).uuid, clipUuid = action._clip.uuid, actionsForClip = this._actionsByClip[clipUuid];
        this._bindAction(action, actionsForClip && actionsForClip.knownActions[0]);
        this._addInactiveAction(action, clipUuid, rootUuid);
      }
      const bindings = action._propertyBindings;
      for (let i = 0, n = bindings.length; i !== n; ++i) {
        const binding = bindings[i];
        if (binding.useCount++ === 0) {
          this._lendBinding(binding);
          binding.saveOriginalState();
        }
      }
      this._lendAction(action);
    }
  }
  _deactivateAction(action) {
    if (this._isActiveAction(action)) {
      const bindings = action._propertyBindings;
      for (let i = 0, n = bindings.length; i !== n; ++i) {
        const binding = bindings[i];
        if (--binding.useCount === 0) {
          binding.restoreOriginalState();
          this._takeBackBinding(binding);
        }
      }
      this._takeBackAction(action);
    }
  }
  _initMemoryManager() {
    this._actions = [];
    this._nActiveActions = 0;
    this._actionsByClip = {};
    this._bindings = [];
    this._nActiveBindings = 0;
    this._bindingsByRootAndName = {};
    this._controlInterpolants = [];
    this._nActiveControlInterpolants = 0;
    const scope = this;
    this.stats = {
      actions: {
        get total() {
          return scope._actions.length;
        },
        get inUse() {
          return scope._nActiveActions;
        }
      },
      bindings: {
        get total() {
          return scope._bindings.length;
        },
        get inUse() {
          return scope._nActiveBindings;
        }
      },
      controlInterpolants: {
        get total() {
          return scope._controlInterpolants.length;
        },
        get inUse() {
          return scope._nActiveControlInterpolants;
        }
      }
    };
  }
  _isActiveAction(action) {
    const index2 = action._cacheIndex;
    return index2 !== null && index2 < this._nActiveActions;
  }
  _addInactiveAction(action, clipUuid, rootUuid) {
    const actions = this._actions, actionsByClip = this._actionsByClip;
    let actionsForClip = actionsByClip[clipUuid];
    if (actionsForClip === void 0) {
      actionsForClip = {
        knownActions: [action],
        actionByRoot: {}
      };
      action._byClipCacheIndex = 0;
      actionsByClip[clipUuid] = actionsForClip;
    } else {
      const knownActions = actionsForClip.knownActions;
      action._byClipCacheIndex = knownActions.length;
      knownActions.push(action);
    }
    action._cacheIndex = actions.length;
    actions.push(action);
    actionsForClip.actionByRoot[rootUuid] = action;
  }
  _removeInactiveAction(action) {
    const actions = this._actions, lastInactiveAction = actions[actions.length - 1], cacheIndex = action._cacheIndex;
    lastInactiveAction._cacheIndex = cacheIndex;
    actions[cacheIndex] = lastInactiveAction;
    actions.pop();
    action._cacheIndex = null;
    const clipUuid = action._clip.uuid, actionsByClip = this._actionsByClip, actionsForClip = actionsByClip[clipUuid], knownActionsForClip = actionsForClip.knownActions, lastKnownAction = knownActionsForClip[knownActionsForClip.length - 1], byClipCacheIndex = action._byClipCacheIndex;
    lastKnownAction._byClipCacheIndex = byClipCacheIndex;
    knownActionsForClip[byClipCacheIndex] = lastKnownAction;
    knownActionsForClip.pop();
    action._byClipCacheIndex = null;
    const actionByRoot = actionsForClip.actionByRoot, rootUuid = (action._localRoot || this._root).uuid;
    delete actionByRoot[rootUuid];
    if (knownActionsForClip.length === 0) {
      delete actionsByClip[clipUuid];
    }
    this._removeInactiveBindingsForAction(action);
  }
  _removeInactiveBindingsForAction(action) {
    const bindings = action._propertyBindings;
    for (let i = 0, n = bindings.length; i !== n; ++i) {
      const binding = bindings[i];
      if (--binding.referenceCount === 0) {
        this._removeInactiveBinding(binding);
      }
    }
  }
  _lendAction(action) {
    const actions = this._actions, prevIndex = action._cacheIndex, lastActiveIndex = this._nActiveActions++, firstInactiveAction = actions[lastActiveIndex];
    action._cacheIndex = lastActiveIndex;
    actions[lastActiveIndex] = action;
    firstInactiveAction._cacheIndex = prevIndex;
    actions[prevIndex] = firstInactiveAction;
  }
  _takeBackAction(action) {
    const actions = this._actions, prevIndex = action._cacheIndex, firstInactiveIndex = --this._nActiveActions, lastActiveAction = actions[firstInactiveIndex];
    action._cacheIndex = firstInactiveIndex;
    actions[firstInactiveIndex] = action;
    lastActiveAction._cacheIndex = prevIndex;
    actions[prevIndex] = lastActiveAction;
  }
  _addInactiveBinding(binding, rootUuid, trackName) {
    const bindingsByRoot = this._bindingsByRootAndName, bindings = this._bindings;
    let bindingByName = bindingsByRoot[rootUuid];
    if (bindingByName === void 0) {
      bindingByName = {};
      bindingsByRoot[rootUuid] = bindingByName;
    }
    bindingByName[trackName] = binding;
    binding._cacheIndex = bindings.length;
    bindings.push(binding);
  }
  _removeInactiveBinding(binding) {
    const bindings = this._bindings, propBinding = binding.binding, rootUuid = propBinding.rootNode.uuid, trackName = propBinding.path, bindingsByRoot = this._bindingsByRootAndName, bindingByName = bindingsByRoot[rootUuid], lastInactiveBinding = bindings[bindings.length - 1], cacheIndex = binding._cacheIndex;
    lastInactiveBinding._cacheIndex = cacheIndex;
    bindings[cacheIndex] = lastInactiveBinding;
    bindings.pop();
    delete bindingByName[trackName];
    if (Object.keys(bindingByName).length === 0) {
      delete bindingsByRoot[rootUuid];
    }
  }
  _lendBinding(binding) {
    const bindings = this._bindings, prevIndex = binding._cacheIndex, lastActiveIndex = this._nActiveBindings++, firstInactiveBinding = bindings[lastActiveIndex];
    binding._cacheIndex = lastActiveIndex;
    bindings[lastActiveIndex] = binding;
    firstInactiveBinding._cacheIndex = prevIndex;
    bindings[prevIndex] = firstInactiveBinding;
  }
  _takeBackBinding(binding) {
    const bindings = this._bindings, prevIndex = binding._cacheIndex, firstInactiveIndex = --this._nActiveBindings, lastActiveBinding = bindings[firstInactiveIndex];
    binding._cacheIndex = firstInactiveIndex;
    bindings[firstInactiveIndex] = binding;
    lastActiveBinding._cacheIndex = prevIndex;
    bindings[prevIndex] = lastActiveBinding;
  }
  _lendControlInterpolant() {
    const interpolants = this._controlInterpolants, lastActiveIndex = this._nActiveControlInterpolants++;
    let interpolant = interpolants[lastActiveIndex];
    if (interpolant === void 0) {
      interpolant = new LinearInterpolant(new Float32Array(2), new Float32Array(2), 1, this._controlInterpolantsResultBuffer);
      interpolant.__cacheIndex = lastActiveIndex;
      interpolants[lastActiveIndex] = interpolant;
    }
    return interpolant;
  }
  _takeBackControlInterpolant(interpolant) {
    const interpolants = this._controlInterpolants, prevIndex = interpolant.__cacheIndex, firstInactiveIndex = --this._nActiveControlInterpolants, lastActiveInterpolant = interpolants[firstInactiveIndex];
    interpolant.__cacheIndex = firstInactiveIndex;
    interpolants[firstInactiveIndex] = interpolant;
    lastActiveInterpolant.__cacheIndex = prevIndex;
    interpolants[prevIndex] = lastActiveInterpolant;
  }
  clipAction(clip, optionalRoot, blendMode) {
    const root = optionalRoot || this._root, rootUuid = root.uuid;
    let clipObject = typeof clip === "string" ? AnimationClip.findByName(root, clip) : clip;
    const clipUuid = clipObject !== null ? clipObject.uuid : clip;
    const actionsForClip = this._actionsByClip[clipUuid];
    let prototypeAction = null;
    if (blendMode === void 0) {
      if (clipObject !== null) {
        blendMode = clipObject.blendMode;
      } else {
        blendMode = NormalAnimationBlendMode;
      }
    }
    if (actionsForClip !== void 0) {
      const existingAction = actionsForClip.actionByRoot[rootUuid];
      if (existingAction !== void 0 && existingAction.blendMode === blendMode) {
        return existingAction;
      }
      prototypeAction = actionsForClip.knownActions[0];
      if (clipObject === null)
        clipObject = prototypeAction._clip;
    }
    if (clipObject === null)
      return null;
    const newAction = new AnimationAction(this, clipObject, optionalRoot, blendMode);
    this._bindAction(newAction, prototypeAction);
    this._addInactiveAction(newAction, clipUuid, rootUuid);
    return newAction;
  }
  existingAction(clip, optionalRoot) {
    const root = optionalRoot || this._root, rootUuid = root.uuid, clipObject = typeof clip === "string" ? AnimationClip.findByName(root, clip) : clip, clipUuid = clipObject ? clipObject.uuid : clip, actionsForClip = this._actionsByClip[clipUuid];
    if (actionsForClip !== void 0) {
      return actionsForClip.actionByRoot[rootUuid] || null;
    }
    return null;
  }
  stopAllAction() {
    const actions = this._actions, nActions = this._nActiveActions;
    for (let i = nActions - 1; i >= 0; --i) {
      actions[i].stop();
    }
    return this;
  }
  update(deltaTime) {
    deltaTime *= this.timeScale;
    const actions = this._actions, nActions = this._nActiveActions, time = this.time += deltaTime, timeDirection = Math.sign(deltaTime), accuIndex = this._accuIndex ^= 1;
    for (let i = 0; i !== nActions; ++i) {
      const action = actions[i];
      action._update(time, deltaTime, timeDirection, accuIndex);
    }
    const bindings = this._bindings, nBindings = this._nActiveBindings;
    for (let i = 0; i !== nBindings; ++i) {
      bindings[i].apply(accuIndex);
    }
    return this;
  }
  setTime(timeInSeconds) {
    this.time = 0;
    for (let i = 0; i < this._actions.length; i++) {
      this._actions[i].time = 0;
    }
    return this.update(timeInSeconds);
  }
  getRoot() {
    return this._root;
  }
  uncacheClip(clip) {
    const actions = this._actions, clipUuid = clip.uuid, actionsByClip = this._actionsByClip, actionsForClip = actionsByClip[clipUuid];
    if (actionsForClip !== void 0) {
      const actionsToRemove = actionsForClip.knownActions;
      for (let i = 0, n = actionsToRemove.length; i !== n; ++i) {
        const action = actionsToRemove[i];
        this._deactivateAction(action);
        const cacheIndex = action._cacheIndex, lastInactiveAction = actions[actions.length - 1];
        action._cacheIndex = null;
        action._byClipCacheIndex = null;
        lastInactiveAction._cacheIndex = cacheIndex;
        actions[cacheIndex] = lastInactiveAction;
        actions.pop();
        this._removeInactiveBindingsForAction(action);
      }
      delete actionsByClip[clipUuid];
    }
  }
  uncacheRoot(root) {
    const rootUuid = root.uuid, actionsByClip = this._actionsByClip;
    for (const clipUuid in actionsByClip) {
      const actionByRoot = actionsByClip[clipUuid].actionByRoot, action = actionByRoot[rootUuid];
      if (action !== void 0) {
        this._deactivateAction(action);
        this._removeInactiveAction(action);
      }
    }
    const bindingsByRoot = this._bindingsByRootAndName, bindingByName = bindingsByRoot[rootUuid];
    if (bindingByName !== void 0) {
      for (const trackName in bindingByName) {
        const binding = bindingByName[trackName];
        binding.restoreOriginalState();
        this._removeInactiveBinding(binding);
      }
    }
  }
  uncacheAction(clip, optionalRoot) {
    const action = this.existingAction(clip, optionalRoot);
    if (action !== null) {
      this._deactivateAction(action);
      this._removeInactiveAction(action);
    }
  }
}
AnimationMixer.prototype._controlInterpolantsResultBuffer = new Float32Array(1);
class InstancedInterleavedBuffer extends InterleavedBuffer {
  constructor(array, stride, meshPerAttribute = 1) {
    super(array, stride);
    this.meshPerAttribute = meshPerAttribute;
  }
  copy(source2) {
    super.copy(source2);
    this.meshPerAttribute = source2.meshPerAttribute;
    return this;
  }
  clone(data) {
    const ib = super.clone(data);
    ib.meshPerAttribute = this.meshPerAttribute;
    return ib;
  }
  toJSON(data) {
    const json = super.toJSON(data);
    json.isInstancedInterleavedBuffer = true;
    json.meshPerAttribute = this.meshPerAttribute;
    return json;
  }
}
InstancedInterleavedBuffer.prototype.isInstancedInterleavedBuffer = true;
class Raycaster {
  constructor(origin, direction2, near = 0, far = Infinity) {
    this.ray = new Ray(origin, direction2);
    this.near = near;
    this.far = far;
    this.camera = null;
    this.layers = new Layers();
    this.params = {
      Mesh: {},
      Line: { threshold: 1 },
      LOD: {},
      Points: { threshold: 1 },
      Sprite: {}
    };
  }
  set(origin, direction2) {
    this.ray.set(origin, direction2);
  }
  setFromCamera(coords, camera) {
    if (camera.isPerspectiveCamera) {
      this.ray.origin.setFromMatrixPosition(camera.matrixWorld);
      this.ray.direction.set(coords.x, coords.y, 0.5).unproject(camera).sub(this.ray.origin).normalize();
      this.camera = camera;
    } else if (camera.isOrthographicCamera) {
      this.ray.origin.set(coords.x, coords.y, (camera.near + camera.far) / (camera.near - camera.far)).unproject(camera);
      this.ray.direction.set(0, 0, -1).transformDirection(camera.matrixWorld);
      this.camera = camera;
    } else {
      console.error("THREE.Raycaster: Unsupported camera type: " + camera.type);
    }
  }
  intersectObject(object, recursive = true, intersects2 = []) {
    intersectObject(object, this, intersects2, recursive);
    intersects2.sort(ascSort);
    return intersects2;
  }
  intersectObjects(objects, recursive = true, intersects2 = []) {
    for (let i = 0, l = objects.length; i < l; i++) {
      intersectObject(objects[i], this, intersects2, recursive);
    }
    intersects2.sort(ascSort);
    return intersects2;
  }
}
function ascSort(a, b) {
  return a.distance - b.distance;
}
function intersectObject(object, raycaster, intersects2, recursive) {
  if (object.layers.test(raycaster.layers)) {
    object.raycast(raycaster, intersects2);
  }
  if (recursive === true) {
    const children2 = object.children;
    for (let i = 0, l = children2.length; i < l; i++) {
      intersectObject(children2[i], raycaster, intersects2, true);
    }
  }
}
class Spherical {
  constructor(radius = 1, phi = 0, theta = 0) {
    this.radius = radius;
    this.phi = phi;
    this.theta = theta;
    return this;
  }
  set(radius, phi, theta) {
    this.radius = radius;
    this.phi = phi;
    this.theta = theta;
    return this;
  }
  copy(other) {
    this.radius = other.radius;
    this.phi = other.phi;
    this.theta = other.theta;
    return this;
  }
  makeSafe() {
    const EPS = 1e-6;
    this.phi = Math.max(EPS, Math.min(Math.PI - EPS, this.phi));
    return this;
  }
  setFromVector3(v) {
    return this.setFromCartesianCoords(v.x, v.y, v.z);
  }
  setFromCartesianCoords(x, y, z) {
    this.radius = Math.sqrt(x * x + y * y + z * z);
    if (this.radius === 0) {
      this.theta = 0;
      this.phi = 0;
    } else {
      this.theta = Math.atan2(x, z);
      this.phi = Math.acos(clamp(y / this.radius, -1, 1));
    }
    return this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const _vector$3 = /* @__PURE__ */ new Vector3();
class SpotLightHelper extends Object3D {
  constructor(light2, color2) {
    super();
    this.light = light2;
    this.light.updateMatrixWorld();
    this.matrix = light2.matrixWorld;
    this.matrixAutoUpdate = false;
    this.color = color2;
    const geometry = new BufferGeometry();
    const positions = [
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1,
      0,
      1,
      0,
      0,
      0,
      -1,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      1,
      0,
      0,
      0,
      0,
      -1,
      1
    ];
    for (let i = 0, j = 1, l = 32; i < l; i++, j++) {
      const p1 = i / l * Math.PI * 2;
      const p2 = j / l * Math.PI * 2;
      positions.push(Math.cos(p1), Math.sin(p1), 1, Math.cos(p2), Math.sin(p2), 1);
    }
    geometry.setAttribute("position", new Float32BufferAttribute(positions, 3));
    const material = new LineBasicMaterial({ fog: false, toneMapped: false });
    this.cone = new LineSegments(geometry, material);
    this.add(this.cone);
    this.update();
  }
  dispose() {
    this.cone.geometry.dispose();
    this.cone.material.dispose();
  }
  update() {
    this.light.updateMatrixWorld();
    const coneLength = this.light.distance ? this.light.distance : 1e3;
    const coneWidth = coneLength * Math.tan(this.light.angle);
    this.cone.scale.set(coneWidth, coneWidth, coneLength);
    _vector$3.setFromMatrixPosition(this.light.target.matrixWorld);
    this.cone.lookAt(_vector$3);
    if (this.color !== void 0) {
      this.cone.material.color.set(this.color);
    } else {
      this.cone.material.color.copy(this.light.color);
    }
  }
}
const _vector$2 = /* @__PURE__ */ new Vector3();
const _boneMatrix = /* @__PURE__ */ new Matrix4();
const _matrixWorldInv = /* @__PURE__ */ new Matrix4();
class SkeletonHelper extends LineSegments {
  constructor(object) {
    const bones = getBoneList(object);
    const geometry = new BufferGeometry();
    const vertices = [];
    const colors2 = [];
    const color1 = new Color(0, 0, 1);
    const color2 = new Color(0, 1, 0);
    for (let i = 0; i < bones.length; i++) {
      const bone = bones[i];
      if (bone.parent && bone.parent.isBone) {
        vertices.push(0, 0, 0);
        vertices.push(0, 0, 0);
        colors2.push(color1.r, color1.g, color1.b);
        colors2.push(color2.r, color2.g, color2.b);
      }
    }
    geometry.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    geometry.setAttribute("color", new Float32BufferAttribute(colors2, 3));
    const material = new LineBasicMaterial({ vertexColors: true, depthTest: false, depthWrite: false, toneMapped: false, transparent: true });
    super(geometry, material);
    this.type = "SkeletonHelper";
    this.isSkeletonHelper = true;
    this.root = object;
    this.bones = bones;
    this.matrix = object.matrixWorld;
    this.matrixAutoUpdate = false;
  }
  updateMatrixWorld(force) {
    const bones = this.bones;
    const geometry = this.geometry;
    const position2 = geometry.getAttribute("position");
    _matrixWorldInv.copy(this.root.matrixWorld).invert();
    for (let i = 0, j = 0; i < bones.length; i++) {
      const bone = bones[i];
      if (bone.parent && bone.parent.isBone) {
        _boneMatrix.multiplyMatrices(_matrixWorldInv, bone.matrixWorld);
        _vector$2.setFromMatrixPosition(_boneMatrix);
        position2.setXYZ(j, _vector$2.x, _vector$2.y, _vector$2.z);
        _boneMatrix.multiplyMatrices(_matrixWorldInv, bone.parent.matrixWorld);
        _vector$2.setFromMatrixPosition(_boneMatrix);
        position2.setXYZ(j + 1, _vector$2.x, _vector$2.y, _vector$2.z);
        j += 2;
      }
    }
    geometry.getAttribute("position").needsUpdate = true;
    super.updateMatrixWorld(force);
  }
}
function getBoneList(object) {
  const boneList = [];
  if (object.isBone === true) {
    boneList.push(object);
  }
  for (let i = 0; i < object.children.length; i++) {
    boneList.push.apply(boneList, getBoneList(object.children[i]));
  }
  return boneList;
}
class PointLightHelper extends Mesh {
  constructor(light2, sphereSize, color2) {
    const geometry = new SphereGeometry(sphereSize, 4, 2);
    const material = new MeshBasicMaterial({ wireframe: true, fog: false, toneMapped: false });
    super(geometry, material);
    this.light = light2;
    this.light.updateMatrixWorld();
    this.color = color2;
    this.type = "PointLightHelper";
    this.matrix = this.light.matrixWorld;
    this.matrixAutoUpdate = false;
    this.update();
  }
  dispose() {
    this.geometry.dispose();
    this.material.dispose();
  }
  update() {
    if (this.color !== void 0) {
      this.material.color.set(this.color);
    } else {
      this.material.color.copy(this.light.color);
    }
  }
}
const _vector$1 = /* @__PURE__ */ new Vector3();
const _color1 = /* @__PURE__ */ new Color();
const _color2 = /* @__PURE__ */ new Color();
class HemisphereLightHelper extends Object3D {
  constructor(light2, size2, color2) {
    super();
    this.light = light2;
    this.light.updateMatrixWorld();
    this.matrix = light2.matrixWorld;
    this.matrixAutoUpdate = false;
    this.color = color2;
    const geometry = new OctahedronGeometry(size2);
    geometry.rotateY(Math.PI * 0.5);
    this.material = new MeshBasicMaterial({ wireframe: true, fog: false, toneMapped: false });
    if (this.color === void 0)
      this.material.vertexColors = true;
    const position2 = geometry.getAttribute("position");
    const colors2 = new Float32Array(position2.count * 3);
    geometry.setAttribute("color", new BufferAttribute(colors2, 3));
    this.add(new Mesh(geometry, this.material));
    this.update();
  }
  dispose() {
    this.children[0].geometry.dispose();
    this.children[0].material.dispose();
  }
  update() {
    const mesh = this.children[0];
    if (this.color !== void 0) {
      this.material.color.set(this.color);
    } else {
      const colors2 = mesh.geometry.getAttribute("color");
      _color1.copy(this.light.color);
      _color2.copy(this.light.groundColor);
      for (let i = 0, l = colors2.count; i < l; i++) {
        const color2 = i < l / 2 ? _color1 : _color2;
        colors2.setXYZ(i, color2.r, color2.g, color2.b);
      }
      colors2.needsUpdate = true;
    }
    mesh.lookAt(_vector$1.setFromMatrixPosition(this.light.matrixWorld).negate());
  }
}
class GridHelper extends LineSegments {
  constructor(size2 = 10, divisions = 10, color1 = 4473924, color2 = 8947848) {
    color1 = new Color(color1);
    color2 = new Color(color2);
    const center2 = divisions / 2;
    const step2 = size2 / divisions;
    const halfSize = size2 / 2;
    const vertices = [], colors2 = [];
    for (let i = 0, j = 0, k = -halfSize; i <= divisions; i++, k += step2) {
      vertices.push(-halfSize, 0, k, halfSize, 0, k);
      vertices.push(k, 0, -halfSize, k, 0, halfSize);
      const color3 = i === center2 ? color1 : color2;
      color3.toArray(colors2, j);
      j += 3;
      color3.toArray(colors2, j);
      j += 3;
      color3.toArray(colors2, j);
      j += 3;
      color3.toArray(colors2, j);
      j += 3;
    }
    const geometry = new BufferGeometry();
    geometry.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    geometry.setAttribute("color", new Float32BufferAttribute(colors2, 3));
    const material = new LineBasicMaterial({ vertexColors: true, toneMapped: false });
    super(geometry, material);
    this.type = "GridHelper";
  }
}
const _v1$8 = /* @__PURE__ */ new Vector3();
const _v2$4 = /* @__PURE__ */ new Vector3();
const _v3$2 = /* @__PURE__ */ new Vector3();
class DirectionalLightHelper extends Object3D {
  constructor(light2, size2, color2) {
    super();
    this.light = light2;
    this.light.updateMatrixWorld();
    this.matrix = light2.matrixWorld;
    this.matrixAutoUpdate = false;
    this.color = color2;
    if (size2 === void 0)
      size2 = 1;
    let geometry = new BufferGeometry();
    geometry.setAttribute("position", new Float32BufferAttribute([
      -size2,
      size2,
      0,
      size2,
      size2,
      0,
      size2,
      -size2,
      0,
      -size2,
      -size2,
      0,
      -size2,
      size2,
      0
    ], 3));
    const material = new LineBasicMaterial({ fog: false, toneMapped: false });
    this.lightPlane = new Line(geometry, material);
    this.add(this.lightPlane);
    geometry = new BufferGeometry();
    geometry.setAttribute("position", new Float32BufferAttribute([0, 0, 0, 0, 0, 1], 3));
    this.targetLine = new Line(geometry, material);
    this.add(this.targetLine);
    this.update();
  }
  dispose() {
    this.lightPlane.geometry.dispose();
    this.lightPlane.material.dispose();
    this.targetLine.geometry.dispose();
    this.targetLine.material.dispose();
  }
  update() {
    _v1$8.setFromMatrixPosition(this.light.matrixWorld);
    _v2$4.setFromMatrixPosition(this.light.target.matrixWorld);
    _v3$2.subVectors(_v2$4, _v1$8);
    this.lightPlane.lookAt(_v2$4);
    if (this.color !== void 0) {
      this.lightPlane.material.color.set(this.color);
      this.targetLine.material.color.set(this.color);
    } else {
      this.lightPlane.material.color.copy(this.light.color);
      this.targetLine.material.color.copy(this.light.color);
    }
    this.targetLine.lookAt(_v2$4);
    this.targetLine.scale.z = _v3$2.length();
  }
}
const _vector = /* @__PURE__ */ new Vector3();
const _camera = /* @__PURE__ */ new Camera();
class CameraHelper extends LineSegments {
  constructor(camera) {
    const geometry = new BufferGeometry();
    const material = new LineBasicMaterial({ color: 16777215, vertexColors: true, toneMapped: false });
    const vertices = [];
    const colors2 = [];
    const pointMap = {};
    const colorFrustum = new Color(16755200);
    const colorCone = new Color(16711680);
    const colorUp = new Color(43775);
    const colorTarget = new Color(16777215);
    const colorCross = new Color(3355443);
    addLine("n1", "n2", colorFrustum);
    addLine("n2", "n4", colorFrustum);
    addLine("n4", "n3", colorFrustum);
    addLine("n3", "n1", colorFrustum);
    addLine("f1", "f2", colorFrustum);
    addLine("f2", "f4", colorFrustum);
    addLine("f4", "f3", colorFrustum);
    addLine("f3", "f1", colorFrustum);
    addLine("n1", "f1", colorFrustum);
    addLine("n2", "f2", colorFrustum);
    addLine("n3", "f3", colorFrustum);
    addLine("n4", "f4", colorFrustum);
    addLine("p", "n1", colorCone);
    addLine("p", "n2", colorCone);
    addLine("p", "n3", colorCone);
    addLine("p", "n4", colorCone);
    addLine("u1", "u2", colorUp);
    addLine("u2", "u3", colorUp);
    addLine("u3", "u1", colorUp);
    addLine("c", "t", colorTarget);
    addLine("p", "c", colorCross);
    addLine("cn1", "cn2", colorCross);
    addLine("cn3", "cn4", colorCross);
    addLine("cf1", "cf2", colorCross);
    addLine("cf3", "cf4", colorCross);
    function addLine(a, b, color2) {
      addPoint(a, color2);
      addPoint(b, color2);
    }
    function addPoint(id, color2) {
      vertices.push(0, 0, 0);
      colors2.push(color2.r, color2.g, color2.b);
      if (pointMap[id] === void 0) {
        pointMap[id] = [];
      }
      pointMap[id].push(vertices.length / 3 - 1);
    }
    geometry.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    geometry.setAttribute("color", new Float32BufferAttribute(colors2, 3));
    super(geometry, material);
    this.type = "CameraHelper";
    this.camera = camera;
    if (this.camera.updateProjectionMatrix)
      this.camera.updateProjectionMatrix();
    this.matrix = camera.matrixWorld;
    this.matrixAutoUpdate = false;
    this.pointMap = pointMap;
    this.update();
  }
  update() {
    const geometry = this.geometry;
    const pointMap = this.pointMap;
    const w = 1, h = 1;
    _camera.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse);
    setPoint("c", pointMap, geometry, _camera, 0, 0, -1);
    setPoint("t", pointMap, geometry, _camera, 0, 0, 1);
    setPoint("n1", pointMap, geometry, _camera, -w, -h, -1);
    setPoint("n2", pointMap, geometry, _camera, w, -h, -1);
    setPoint("n3", pointMap, geometry, _camera, -w, h, -1);
    setPoint("n4", pointMap, geometry, _camera, w, h, -1);
    setPoint("f1", pointMap, geometry, _camera, -w, -h, 1);
    setPoint("f2", pointMap, geometry, _camera, w, -h, 1);
    setPoint("f3", pointMap, geometry, _camera, -w, h, 1);
    setPoint("f4", pointMap, geometry, _camera, w, h, 1);
    setPoint("u1", pointMap, geometry, _camera, w * 0.7, h * 1.1, -1);
    setPoint("u2", pointMap, geometry, _camera, -w * 0.7, h * 1.1, -1);
    setPoint("u3", pointMap, geometry, _camera, 0, h * 2, -1);
    setPoint("cf1", pointMap, geometry, _camera, -w, 0, 1);
    setPoint("cf2", pointMap, geometry, _camera, w, 0, 1);
    setPoint("cf3", pointMap, geometry, _camera, 0, -h, 1);
    setPoint("cf4", pointMap, geometry, _camera, 0, h, 1);
    setPoint("cn1", pointMap, geometry, _camera, -w, 0, -1);
    setPoint("cn2", pointMap, geometry, _camera, w, 0, -1);
    setPoint("cn3", pointMap, geometry, _camera, 0, -h, -1);
    setPoint("cn4", pointMap, geometry, _camera, 0, h, -1);
    geometry.getAttribute("position").needsUpdate = true;
  }
  dispose() {
    this.geometry.dispose();
    this.material.dispose();
  }
}
function setPoint(point2, pointMap, geometry, camera, x, y, z) {
  _vector.set(x, y, z).unproject(camera);
  const points = pointMap[point2];
  if (points !== void 0) {
    const position2 = geometry.getAttribute("position");
    for (let i = 0, l = points.length; i < l; i++) {
      position2.setXYZ(points[i], _vector.x, _vector.y, _vector.z);
    }
  }
}
class Box3Helper extends LineSegments {
  constructor(box, color2 = 16776960) {
    const indices = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]);
    const positions = [1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1];
    const geometry = new BufferGeometry();
    geometry.setIndex(new BufferAttribute(indices, 1));
    geometry.setAttribute("position", new Float32BufferAttribute(positions, 3));
    super(geometry, new LineBasicMaterial({ color: color2, toneMapped: false }));
    this.box = box;
    this.type = "Box3Helper";
    this.geometry.computeBoundingSphere();
  }
  updateMatrixWorld(force) {
    const box = this.box;
    if (box.isEmpty())
      return;
    box.getCenter(this.position);
    box.getSize(this.scale);
    this.scale.multiplyScalar(0.5);
    super.updateMatrixWorld(force);
  }
}
const _baseTable = new Uint32Array(512);
const _shiftTable = new Uint32Array(512);
for (let i = 0; i < 256; ++i) {
  const e = i - 127;
  if (e < -27) {
    _baseTable[i] = 0;
    _baseTable[i | 256] = 32768;
    _shiftTable[i] = 24;
    _shiftTable[i | 256] = 24;
  } else if (e < -14) {
    _baseTable[i] = 1024 >> -e - 14;
    _baseTable[i | 256] = 1024 >> -e - 14 | 32768;
    _shiftTable[i] = -e - 1;
    _shiftTable[i | 256] = -e - 1;
  } else if (e <= 15) {
    _baseTable[i] = e + 15 << 10;
    _baseTable[i | 256] = e + 15 << 10 | 32768;
    _shiftTable[i] = 13;
    _shiftTable[i | 256] = 13;
  } else if (e < 128) {
    _baseTable[i] = 31744;
    _baseTable[i | 256] = 64512;
    _shiftTable[i] = 24;
    _shiftTable[i | 256] = 24;
  } else {
    _baseTable[i] = 31744;
    _baseTable[i | 256] = 64512;
    _shiftTable[i] = 13;
    _shiftTable[i | 256] = 13;
  }
}
const _mantissaTable = new Uint32Array(2048);
const _exponentTable = new Uint32Array(64);
const _offsetTable = new Uint32Array(64);
for (let i = 1; i < 1024; ++i) {
  let m = i << 13;
  let e = 0;
  while ((m & 8388608) === 0) {
    m <<= 1;
    e -= 8388608;
  }
  m &= ~8388608;
  e += 947912704;
  _mantissaTable[i] = m | e;
}
for (let i = 1024; i < 2048; ++i) {
  _mantissaTable[i] = 939524096 + (i - 1024 << 13);
}
for (let i = 1; i < 31; ++i) {
  _exponentTable[i] = i << 23;
}
_exponentTable[31] = 1199570944;
_exponentTable[32] = 2147483648;
for (let i = 33; i < 63; ++i) {
  _exponentTable[i] = 2147483648 + (i - 32 << 23);
}
_exponentTable[63] = 3347054592;
for (let i = 1; i < 64; ++i) {
  if (i !== 32) {
    _offsetTable[i] = 1024;
  }
}
Curve.create = function(construct, getPoint) {
  console.log("THREE.Curve.create() has been deprecated");
  construct.prototype = Object.create(Curve.prototype);
  construct.prototype.constructor = construct;
  construct.prototype.getPoint = getPoint;
  return construct;
};
Path.prototype.fromPoints = function(points) {
  console.warn("THREE.Path: .fromPoints() has been renamed to .setFromPoints().");
  return this.setFromPoints(points);
};
GridHelper.prototype.setColors = function() {
  console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.");
};
SkeletonHelper.prototype.update = function() {
  console.error("THREE.SkeletonHelper: update() no longer needs to be called.");
};
Loader.prototype.extractUrlBase = function(url) {
  console.warn("THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead.");
  return LoaderUtils.extractUrlBase(url);
};
Loader.Handlers = {
  add: function() {
    console.error("THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.");
  },
  get: function() {
    console.error("THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.");
  }
};
Box3.prototype.center = function(optionalTarget) {
  console.warn("THREE.Box3: .center() has been renamed to .getCenter().");
  return this.getCenter(optionalTarget);
};
Box3.prototype.empty = function() {
  console.warn("THREE.Box3: .empty() has been renamed to .isEmpty().");
  return this.isEmpty();
};
Box3.prototype.isIntersectionBox = function(box) {
  console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox().");
  return this.intersectsBox(box);
};
Box3.prototype.isIntersectionSphere = function(sphere) {
  console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere().");
  return this.intersectsSphere(sphere);
};
Box3.prototype.size = function(optionalTarget) {
  console.warn("THREE.Box3: .size() has been renamed to .getSize().");
  return this.getSize(optionalTarget);
};
Euler.prototype.toVector3 = function() {
  console.error("THREE.Euler: .toVector3() has been removed. Use Vector3.setFromEuler() instead");
};
Sphere.prototype.empty = function() {
  console.warn("THREE.Sphere: .empty() has been renamed to .isEmpty().");
  return this.isEmpty();
};
Frustum.prototype.setFromMatrix = function(m) {
  console.warn("THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix().");
  return this.setFromProjectionMatrix(m);
};
Matrix3.prototype.flattenToArrayOffset = function(array, offset) {
  console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.");
  return this.toArray(array, offset);
};
Matrix3.prototype.multiplyVector3 = function(vector) {
  console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.");
  return vector.applyMatrix3(this);
};
Matrix3.prototype.multiplyVector3Array = function() {
  console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.");
};
Matrix3.prototype.applyToBufferAttribute = function(attribute) {
  console.warn("THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead.");
  return attribute.applyMatrix3(this);
};
Matrix3.prototype.applyToVector3Array = function() {
  console.error("THREE.Matrix3: .applyToVector3Array() has been removed.");
};
Matrix3.prototype.getInverse = function(matrix) {
  console.warn("THREE.Matrix3: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead.");
  return this.copy(matrix).invert();
};
Matrix4.prototype.extractPosition = function(m) {
  console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().");
  return this.copyPosition(m);
};
Matrix4.prototype.flattenToArrayOffset = function(array, offset) {
  console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.");
  return this.toArray(array, offset);
};
Matrix4.prototype.getPosition = function() {
  console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.");
  return new Vector3().setFromMatrixColumn(this, 3);
};
Matrix4.prototype.setRotationFromQuaternion = function(q) {
  console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().");
  return this.makeRotationFromQuaternion(q);
};
Matrix4.prototype.multiplyToArray = function() {
  console.warn("THREE.Matrix4: .multiplyToArray() has been removed.");
};
Matrix4.prototype.multiplyVector3 = function(vector) {
  console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead.");
  return vector.applyMatrix4(this);
};
Matrix4.prototype.multiplyVector4 = function(vector) {
  console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.");
  return vector.applyMatrix4(this);
};
Matrix4.prototype.multiplyVector3Array = function() {
  console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.");
};
Matrix4.prototype.rotateAxis = function(v) {
  console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.");
  v.transformDirection(this);
};
Matrix4.prototype.crossVector = function(vector) {
  console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.");
  return vector.applyMatrix4(this);
};
Matrix4.prototype.translate = function() {
  console.error("THREE.Matrix4: .translate() has been removed.");
};
Matrix4.prototype.rotateX = function() {
  console.error("THREE.Matrix4: .rotateX() has been removed.");
};
Matrix4.prototype.rotateY = function() {
  console.error("THREE.Matrix4: .rotateY() has been removed.");
};
Matrix4.prototype.rotateZ = function() {
  console.error("THREE.Matrix4: .rotateZ() has been removed.");
};
Matrix4.prototype.rotateByAxis = function() {
  console.error("THREE.Matrix4: .rotateByAxis() has been removed.");
};
Matrix4.prototype.applyToBufferAttribute = function(attribute) {
  console.warn("THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead.");
  return attribute.applyMatrix4(this);
};
Matrix4.prototype.applyToVector3Array = function() {
  console.error("THREE.Matrix4: .applyToVector3Array() has been removed.");
};
Matrix4.prototype.makeFrustum = function(left2, right2, bottom2, top2, near, far) {
  console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead.");
  return this.makePerspective(left2, right2, top2, bottom2, near, far);
};
Matrix4.prototype.getInverse = function(matrix) {
  console.warn("THREE.Matrix4: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead.");
  return this.copy(matrix).invert();
};
Plane.prototype.isIntersectionLine = function(line2) {
  console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine().");
  return this.intersectsLine(line2);
};
Quaternion.prototype.multiplyVector3 = function(vector) {
  console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.");
  return vector.applyQuaternion(this);
};
Quaternion.prototype.inverse = function() {
  console.warn("THREE.Quaternion: .inverse() has been renamed to invert().");
  return this.invert();
};
Ray.prototype.isIntersectionBox = function(box) {
  console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox().");
  return this.intersectsBox(box);
};
Ray.prototype.isIntersectionPlane = function(plane) {
  console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane().");
  return this.intersectsPlane(plane);
};
Ray.prototype.isIntersectionSphere = function(sphere) {
  console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere().");
  return this.intersectsSphere(sphere);
};
Triangle.prototype.area = function() {
  console.warn("THREE.Triangle: .area() has been renamed to .getArea().");
  return this.getArea();
};
Triangle.prototype.barycoordFromPoint = function(point2, target) {
  console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().");
  return this.getBarycoord(point2, target);
};
Triangle.prototype.midpoint = function(target) {
  console.warn("THREE.Triangle: .midpoint() has been renamed to .getMidpoint().");
  return this.getMidpoint(target);
};
Triangle.prototypenormal = function(target) {
  console.warn("THREE.Triangle: .normal() has been renamed to .getNormal().");
  return this.getNormal(target);
};
Triangle.prototype.plane = function(target) {
  console.warn("THREE.Triangle: .plane() has been renamed to .getPlane().");
  return this.getPlane(target);
};
Triangle.barycoordFromPoint = function(point2, a, b, c2, target) {
  console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().");
  return Triangle.getBarycoord(point2, a, b, c2, target);
};
Triangle.normal = function(a, b, c2, target) {
  console.warn("THREE.Triangle: .normal() has been renamed to .getNormal().");
  return Triangle.getNormal(a, b, c2, target);
};
Shape.prototype.extractAllPoints = function(divisions) {
  console.warn("THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead.");
  return this.extractPoints(divisions);
};
Shape.prototype.extrude = function(options2) {
  console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead.");
  return new ExtrudeGeometry(this, options2);
};
Shape.prototype.makeGeometry = function(options2) {
  console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead.");
  return new ShapeGeometry(this, options2);
};
Vector2.prototype.fromAttribute = function(attribute, index2, offset) {
  console.warn("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute().");
  return this.fromBufferAttribute(attribute, index2, offset);
};
Vector2.prototype.distanceToManhattan = function(v) {
  console.warn("THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo().");
  return this.manhattanDistanceTo(v);
};
Vector2.prototype.lengthManhattan = function() {
  console.warn("THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength().");
  return this.manhattanLength();
};
Vector3.prototype.setEulerFromRotationMatrix = function() {
  console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.");
};
Vector3.prototype.setEulerFromQuaternion = function() {
  console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.");
};
Vector3.prototype.getPositionFromMatrix = function(m) {
  console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().");
  return this.setFromMatrixPosition(m);
};
Vector3.prototype.getScaleFromMatrix = function(m) {
  console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().");
  return this.setFromMatrixScale(m);
};
Vector3.prototype.getColumnFromMatrix = function(index2, matrix) {
  console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().");
  return this.setFromMatrixColumn(matrix, index2);
};
Vector3.prototype.applyProjection = function(m) {
  console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead.");
  return this.applyMatrix4(m);
};
Vector3.prototype.fromAttribute = function(attribute, index2, offset) {
  console.warn("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute().");
  return this.fromBufferAttribute(attribute, index2, offset);
};
Vector3.prototype.distanceToManhattan = function(v) {
  console.warn("THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo().");
  return this.manhattanDistanceTo(v);
};
Vector3.prototype.lengthManhattan = function() {
  console.warn("THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength().");
  return this.manhattanLength();
};
Vector4.prototype.fromAttribute = function(attribute, index2, offset) {
  console.warn("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute().");
  return this.fromBufferAttribute(attribute, index2, offset);
};
Vector4.prototype.lengthManhattan = function() {
  console.warn("THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength().");
  return this.manhattanLength();
};
Object3D.prototype.getChildByName = function(name) {
  console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().");
  return this.getObjectByName(name);
};
Object3D.prototype.renderDepth = function() {
  console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.");
};
Object3D.prototype.translate = function(distance2, axis) {
  console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.");
  return this.translateOnAxis(axis, distance2);
};
Object3D.prototype.getWorldRotation = function() {
  console.error("THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.");
};
Object3D.prototype.applyMatrix = function(matrix) {
  console.warn("THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4().");
  return this.applyMatrix4(matrix);
};
Object.defineProperties(Object3D.prototype, {
  eulerOrder: {
    get: function() {
      console.warn("THREE.Object3D: .eulerOrder is now .rotation.order.");
      return this.rotation.order;
    },
    set: function(value) {
      console.warn("THREE.Object3D: .eulerOrder is now .rotation.order.");
      this.rotation.order = value;
    }
  },
  useQuaternion: {
    get: function() {
      console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.");
    },
    set: function() {
      console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.");
    }
  }
});
Mesh.prototype.setDrawMode = function() {
  console.error("THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.");
};
Object.defineProperties(Mesh.prototype, {
  drawMode: {
    get: function() {
      console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode.");
      return TrianglesDrawMode;
    },
    set: function() {
      console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.");
    }
  }
});
SkinnedMesh.prototype.initBones = function() {
  console.error("THREE.SkinnedMesh: initBones() has been removed.");
};
PerspectiveCamera.prototype.setLens = function(focalLength, filmGauge) {
  console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup.");
  if (filmGauge !== void 0)
    this.filmGauge = filmGauge;
  this.setFocalLength(focalLength);
};
Object.defineProperties(Light.prototype, {
  onlyShadow: {
    set: function() {
      console.warn("THREE.Light: .onlyShadow has been removed.");
    }
  },
  shadowCameraFov: {
    set: function(value) {
      console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov.");
      this.shadow.camera.fov = value;
    }
  },
  shadowCameraLeft: {
    set: function(value) {
      console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left.");
      this.shadow.camera.left = value;
    }
  },
  shadowCameraRight: {
    set: function(value) {
      console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right.");
      this.shadow.camera.right = value;
    }
  },
  shadowCameraTop: {
    set: function(value) {
      console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top.");
      this.shadow.camera.top = value;
    }
  },
  shadowCameraBottom: {
    set: function(value) {
      console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom.");
      this.shadow.camera.bottom = value;
    }
  },
  shadowCameraNear: {
    set: function(value) {
      console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near.");
      this.shadow.camera.near = value;
    }
  },
  shadowCameraFar: {
    set: function(value) {
      console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far.");
      this.shadow.camera.far = value;
    }
  },
  shadowCameraVisible: {
    set: function() {
      console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.");
    }
  },
  shadowBias: {
    set: function(value) {
      console.warn("THREE.Light: .shadowBias is now .shadow.bias.");
      this.shadow.bias = value;
    }
  },
  shadowDarkness: {
    set: function() {
      console.warn("THREE.Light: .shadowDarkness has been removed.");
    }
  },
  shadowMapWidth: {
    set: function(value) {
      console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width.");
      this.shadow.mapSize.width = value;
    }
  },
  shadowMapHeight: {
    set: function(value) {
      console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height.");
      this.shadow.mapSize.height = value;
    }
  }
});
Object.defineProperties(BufferAttribute.prototype, {
  length: {
    get: function() {
      console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead.");
      return this.array.length;
    }
  },
  dynamic: {
    get: function() {
      console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead.");
      return this.usage === DynamicDrawUsage;
    },
    set: function() {
      console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead.");
      this.setUsage(DynamicDrawUsage);
    }
  }
});
BufferAttribute.prototype.setDynamic = function(value) {
  console.warn("THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead.");
  this.setUsage(value === true ? DynamicDrawUsage : StaticDrawUsage);
  return this;
};
BufferAttribute.prototype.copyIndicesArray = function() {
  console.error("THREE.BufferAttribute: .copyIndicesArray() has been removed.");
}, BufferAttribute.prototype.setArray = function() {
  console.error("THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers");
};
BufferGeometry.prototype.addIndex = function(index2) {
  console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex().");
  this.setIndex(index2);
};
BufferGeometry.prototype.addAttribute = function(name, attribute) {
  console.warn("THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute().");
  if (!(attribute && attribute.isBufferAttribute) && !(attribute && attribute.isInterleavedBufferAttribute)) {
    console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).");
    return this.setAttribute(name, new BufferAttribute(arguments[1], arguments[2]));
  }
  if (name === "index") {
    console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute.");
    this.setIndex(attribute);
    return this;
  }
  return this.setAttribute(name, attribute);
};
BufferGeometry.prototype.addDrawCall = function(start2, count, indexOffset) {
  if (indexOffset !== void 0) {
    console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset.");
  }
  console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup().");
  this.addGroup(start2, count);
};
BufferGeometry.prototype.clearDrawCalls = function() {
  console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups().");
  this.clearGroups();
};
BufferGeometry.prototype.computeOffsets = function() {
  console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.");
};
BufferGeometry.prototype.removeAttribute = function(name) {
  console.warn("THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute().");
  return this.deleteAttribute(name);
};
BufferGeometry.prototype.applyMatrix = function(matrix) {
  console.warn("THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4().");
  return this.applyMatrix4(matrix);
};
Object.defineProperties(BufferGeometry.prototype, {
  drawcalls: {
    get: function() {
      console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups.");
      return this.groups;
    }
  },
  offsets: {
    get: function() {
      console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups.");
      return this.groups;
    }
  }
});
InterleavedBuffer.prototype.setDynamic = function(value) {
  console.warn("THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead.");
  this.setUsage(value === true ? DynamicDrawUsage : StaticDrawUsage);
  return this;
};
InterleavedBuffer.prototype.setArray = function() {
  console.error("THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers");
};
ExtrudeGeometry.prototype.getArrays = function() {
  console.error("THREE.ExtrudeGeometry: .getArrays() has been removed.");
};
ExtrudeGeometry.prototype.addShapeList = function() {
  console.error("THREE.ExtrudeGeometry: .addShapeList() has been removed.");
};
ExtrudeGeometry.prototype.addShape = function() {
  console.error("THREE.ExtrudeGeometry: .addShape() has been removed.");
};
Scene.prototype.dispose = function() {
  console.error("THREE.Scene: .dispose() has been removed.");
};
Object.defineProperties(Material.prototype, {
  wrapAround: {
    get: function() {
      console.warn("THREE.Material: .wrapAround has been removed.");
    },
    set: function() {
      console.warn("THREE.Material: .wrapAround has been removed.");
    }
  },
  overdraw: {
    get: function() {
      console.warn("THREE.Material: .overdraw has been removed.");
    },
    set: function() {
      console.warn("THREE.Material: .overdraw has been removed.");
    }
  },
  wrapRGB: {
    get: function() {
      console.warn("THREE.Material: .wrapRGB has been removed.");
      return new Color();
    }
  },
  shading: {
    get: function() {
      console.error("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.");
    },
    set: function(value) {
      console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.");
      this.flatShading = value === FlatShading;
    }
  },
  stencilMask: {
    get: function() {
      console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead.");
      return this.stencilFuncMask;
    },
    set: function(value) {
      console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead.");
      this.stencilFuncMask = value;
    }
  },
  vertexTangents: {
    get: function() {
      console.warn("THREE." + this.type + ": .vertexTangents has been removed.");
    },
    set: function() {
      console.warn("THREE." + this.type + ": .vertexTangents has been removed.");
    }
  }
});
Object.defineProperties(ShaderMaterial.prototype, {
  derivatives: {
    get: function() {
      console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives.");
      return this.extensions.derivatives;
    },
    set: function(value) {
      console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives.");
      this.extensions.derivatives = value;
    }
  }
});
WebGLRenderer.prototype.clearTarget = function(renderTarget, color2, depth, stencil) {
  console.warn("THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead.");
  this.setRenderTarget(renderTarget);
  this.clear(color2, depth, stencil);
};
WebGLRenderer.prototype.animate = function(callback) {
  console.warn("THREE.WebGLRenderer: .animate() is now .setAnimationLoop().");
  this.setAnimationLoop(callback);
};
WebGLRenderer.prototype.getCurrentRenderTarget = function() {
  console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget().");
  return this.getRenderTarget();
};
WebGLRenderer.prototype.getMaxAnisotropy = function() {
  console.warn("THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy().");
  return this.capabilities.getMaxAnisotropy();
};
WebGLRenderer.prototype.getPrecision = function() {
  console.warn("THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision.");
  return this.capabilities.precision;
};
WebGLRenderer.prototype.resetGLState = function() {
  console.warn("THREE.WebGLRenderer: .resetGLState() is now .state.reset().");
  return this.state.reset();
};
WebGLRenderer.prototype.supportsFloatTextures = function() {
  console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' ).");
  return this.extensions.get("OES_texture_float");
};
WebGLRenderer.prototype.supportsHalfFloatTextures = function() {
  console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' ).");
  return this.extensions.get("OES_texture_half_float");
};
WebGLRenderer.prototype.supportsStandardDerivatives = function() {
  console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' ).");
  return this.extensions.get("OES_standard_derivatives");
};
WebGLRenderer.prototype.supportsCompressedTextureS3TC = function() {
  console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' ).");
  return this.extensions.get("WEBGL_compressed_texture_s3tc");
};
WebGLRenderer.prototype.supportsCompressedTexturePVRTC = function() {
  console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' ).");
  return this.extensions.get("WEBGL_compressed_texture_pvrtc");
};
WebGLRenderer.prototype.supportsBlendMinMax = function() {
  console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' ).");
  return this.extensions.get("EXT_blend_minmax");
};
WebGLRenderer.prototype.supportsVertexTextures = function() {
  console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures.");
  return this.capabilities.vertexTextures;
};
WebGLRenderer.prototype.supportsInstancedArrays = function() {
  console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' ).");
  return this.extensions.get("ANGLE_instanced_arrays");
};
WebGLRenderer.prototype.enableScissorTest = function(boolean) {
  console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest().");
  this.setScissorTest(boolean);
};
WebGLRenderer.prototype.initMaterial = function() {
  console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.");
};
WebGLRenderer.prototype.addPrePlugin = function() {
  console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.");
};
WebGLRenderer.prototype.addPostPlugin = function() {
  console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.");
};
WebGLRenderer.prototype.updateShadowMap = function() {
  console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.");
};
WebGLRenderer.prototype.setFaceCulling = function() {
  console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.");
};
WebGLRenderer.prototype.allocTextureUnit = function() {
  console.warn("THREE.WebGLRenderer: .allocTextureUnit() has been removed.");
};
WebGLRenderer.prototype.setTexture = function() {
  console.warn("THREE.WebGLRenderer: .setTexture() has been removed.");
};
WebGLRenderer.prototype.setTexture2D = function() {
  console.warn("THREE.WebGLRenderer: .setTexture2D() has been removed.");
};
WebGLRenderer.prototype.setTextureCube = function() {
  console.warn("THREE.WebGLRenderer: .setTextureCube() has been removed.");
};
WebGLRenderer.prototype.getActiveMipMapLevel = function() {
  console.warn("THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel().");
  return this.getActiveMipmapLevel();
};
Object.defineProperties(WebGLRenderer.prototype, {
  shadowMapEnabled: {
    get: function() {
      return this.shadowMap.enabled;
    },
    set: function(value) {
      console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled.");
      this.shadowMap.enabled = value;
    }
  },
  shadowMapType: {
    get: function() {
      return this.shadowMap.type;
    },
    set: function(value) {
      console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type.");
      this.shadowMap.type = value;
    }
  },
  shadowMapCullFace: {
    get: function() {
      console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.");
      return void 0;
    },
    set: function() {
      console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.");
    }
  },
  context: {
    get: function() {
      console.warn("THREE.WebGLRenderer: .context has been removed. Use .getContext() instead.");
      return this.getContext();
    }
  },
  vr: {
    get: function() {
      console.warn("THREE.WebGLRenderer: .vr has been renamed to .xr");
      return this.xr;
    }
  },
  gammaInput: {
    get: function() {
      console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.");
      return false;
    },
    set: function() {
      console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.");
    }
  },
  gammaOutput: {
    get: function() {
      console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead.");
      return false;
    },
    set: function(value) {
      console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead.");
      this.outputEncoding = value === true ? sRGBEncoding : LinearEncoding;
    }
  },
  toneMappingWhitePoint: {
    get: function() {
      console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.");
      return 1;
    },
    set: function() {
      console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.");
    }
  },
  gammaFactor: {
    get: function() {
      console.warn("THREE.WebGLRenderer: .gammaFactor has been removed.");
      return 2;
    },
    set: function() {
      console.warn("THREE.WebGLRenderer: .gammaFactor has been removed.");
    }
  }
});
Object.defineProperties(WebGLShadowMap.prototype, {
  cullFace: {
    get: function() {
      console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.");
      return void 0;
    },
    set: function() {
      console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.");
    }
  },
  renderReverseSided: {
    get: function() {
      console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.");
      return void 0;
    },
    set: function() {
      console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.");
    }
  },
  renderSingleSided: {
    get: function() {
      console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.");
      return void 0;
    },
    set: function() {
      console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.");
    }
  }
});
Object.defineProperties(WebGLRenderTarget.prototype, {
  wrapS: {
    get: function() {
      console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.");
      return this.texture.wrapS;
    },
    set: function(value) {
      console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.");
      this.texture.wrapS = value;
    }
  },
  wrapT: {
    get: function() {
      console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.");
      return this.texture.wrapT;
    },
    set: function(value) {
      console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.");
      this.texture.wrapT = value;
    }
  },
  magFilter: {
    get: function() {
      console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.");
      return this.texture.magFilter;
    },
    set: function(value) {
      console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.");
      this.texture.magFilter = value;
    }
  },
  minFilter: {
    get: function() {
      console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.");
      return this.texture.minFilter;
    },
    set: function(value) {
      console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.");
      this.texture.minFilter = value;
    }
  },
  anisotropy: {
    get: function() {
      console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.");
      return this.texture.anisotropy;
    },
    set: function(value) {
      console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.");
      this.texture.anisotropy = value;
    }
  },
  offset: {
    get: function() {
      console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset.");
      return this.texture.offset;
    },
    set: function(value) {
      console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset.");
      this.texture.offset = value;
    }
  },
  repeat: {
    get: function() {
      console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat.");
      return this.texture.repeat;
    },
    set: function(value) {
      console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat.");
      this.texture.repeat = value;
    }
  },
  format: {
    get: function() {
      console.warn("THREE.WebGLRenderTarget: .format is now .texture.format.");
      return this.texture.format;
    },
    set: function(value) {
      console.warn("THREE.WebGLRenderTarget: .format is now .texture.format.");
      this.texture.format = value;
    }
  },
  type: {
    get: function() {
      console.warn("THREE.WebGLRenderTarget: .type is now .texture.type.");
      return this.texture.type;
    },
    set: function(value) {
      console.warn("THREE.WebGLRenderTarget: .type is now .texture.type.");
      this.texture.type = value;
    }
  },
  generateMipmaps: {
    get: function() {
      console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.");
      return this.texture.generateMipmaps;
    },
    set: function(value) {
      console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.");
      this.texture.generateMipmaps = value;
    }
  }
});
Audio.prototype.load = function(file) {
  console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.");
  const scope = this;
  const audioLoader = new AudioLoader();
  audioLoader.load(file, function(buffer) {
    scope.setBuffer(buffer);
  });
  return this;
};
CubeCamera.prototype.updateCubeMap = function(renderer, scene) {
  console.warn("THREE.CubeCamera: .updateCubeMap() is now .update().");
  return this.update(renderer, scene);
};
CubeCamera.prototype.clear = function(renderer, color2, depth, stencil) {
  console.warn("THREE.CubeCamera: .clear() is now .renderTarget.clear().");
  return this.renderTarget.clear(renderer, color2, depth, stencil);
};
ImageUtils.crossOrigin = void 0;
ImageUtils.loadTexture = function(url, mapping, onLoad, onError) {
  console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");
  const loader = new TextureLoader();
  loader.setCrossOrigin(this.crossOrigin);
  const texture2 = loader.load(url, onLoad, void 0, onError);
  if (mapping)
    texture2.mapping = mapping;
  return texture2;
};
ImageUtils.loadTextureCube = function(urls, mapping, onLoad, onError) {
  console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");
  const loader = new CubeTextureLoader();
  loader.setCrossOrigin(this.crossOrigin);
  const texture2 = loader.load(urls, onLoad, void 0, onError);
  if (mapping)
    texture2.mapping = mapping;
  return texture2;
};
ImageUtils.loadCompressedTexture = function() {
  console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.");
};
ImageUtils.loadCompressedTextureCube = function() {
  console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.");
};
if (typeof __THREE_DEVTOOLS__ !== "undefined") {
  __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", { detail: {
    revision: REVISION
  } }));
}
if (typeof window !== "undefined") {
  if (window.__THREE__) {
    console.warn("WARNING: Multiple instances of Three.js being imported.");
  } else {
    window.__THREE__ = REVISION;
  }
}
const _changeEvent$1 = { type: "change" };
const _startEvent = { type: "start" };
const _endEvent = { type: "end" };
class OrbitControls extends EventDispatcher {
  constructor(object, domElement) {
    super();
    if (domElement === void 0)
      console.warn('THREE.OrbitControls: The second parameter "domElement" is now mandatory.');
    if (domElement === document)
      console.error('THREE.OrbitControls: "document" should not be used as the target "domElement". Please use "renderer.domElement" instead.');
    this.object = object;
    this.domElement = domElement;
    this.domElement.style.touchAction = "none";
    this.enabled = true;
    this.target = new Vector3();
    this.minDistance = 0;
    this.maxDistance = Infinity;
    this.minZoom = 0;
    this.maxZoom = Infinity;
    this.minPolarAngle = 0;
    this.maxPolarAngle = Math.PI;
    this.minAzimuthAngle = -Infinity;
    this.maxAzimuthAngle = Infinity;
    this.enableDamping = false;
    this.dampingFactor = 0.05;
    this.enableZoom = true;
    this.zoomSpeed = 1;
    this.enableRotate = true;
    this.rotateSpeed = 1;
    this.enablePan = true;
    this.panSpeed = 1;
    this.screenSpacePanning = true;
    this.keyPanSpeed = 7;
    this.autoRotate = false;
    this.autoRotateSpeed = 2;
    this.keys = { LEFT: "ArrowLeft", UP: "ArrowUp", RIGHT: "ArrowRight", BOTTOM: "ArrowDown" };
    this.mouseButtons = { LEFT: MOUSE.ROTATE, MIDDLE: MOUSE.DOLLY, RIGHT: MOUSE.PAN };
    this.touches = { ONE: TOUCH.ROTATE, TWO: TOUCH.DOLLY_PAN };
    this.target0 = this.target.clone();
    this.position0 = this.object.position.clone();
    this.zoom0 = this.object.zoom;
    this._domElementKeyEvents = null;
    this.getPolarAngle = function() {
      return spherical.phi;
    };
    this.getAzimuthalAngle = function() {
      return spherical.theta;
    };
    this.getDistance = function() {
      return this.object.position.distanceTo(this.target);
    };
    this.listenToKeyEvents = function(domElement2) {
      domElement2.addEventListener("keydown", onKeyDown);
      this._domElementKeyEvents = domElement2;
    };
    this.saveState = function() {
      scope.target0.copy(scope.target);
      scope.position0.copy(scope.object.position);
      scope.zoom0 = scope.object.zoom;
    };
    this.reset = function() {
      scope.target.copy(scope.target0);
      scope.object.position.copy(scope.position0);
      scope.object.zoom = scope.zoom0;
      scope.object.updateProjectionMatrix();
      scope.dispatchEvent(_changeEvent$1);
      scope.update();
      state = STATE.NONE;
    };
    this.update = function() {
      const offset = new Vector3();
      const quat = new Quaternion().setFromUnitVectors(object.up, new Vector3(0, 1, 0));
      const quatInverse = quat.clone().invert();
      const lastPosition = new Vector3();
      const lastQuaternion = new Quaternion();
      const twoPI = 2 * Math.PI;
      return function update2() {
        const position2 = scope.object.position;
        offset.copy(position2).sub(scope.target);
        offset.applyQuaternion(quat);
        spherical.setFromVector3(offset);
        if (scope.autoRotate && state === STATE.NONE) {
          rotateLeft(getAutoRotationAngle());
        }
        if (scope.enableDamping) {
          spherical.theta += sphericalDelta.theta * scope.dampingFactor;
          spherical.phi += sphericalDelta.phi * scope.dampingFactor;
        } else {
          spherical.theta += sphericalDelta.theta;
          spherical.phi += sphericalDelta.phi;
        }
        let min = scope.minAzimuthAngle;
        let max = scope.maxAzimuthAngle;
        if (isFinite(min) && isFinite(max)) {
          if (min < -Math.PI)
            min += twoPI;
          else if (min > Math.PI)
            min -= twoPI;
          if (max < -Math.PI)
            max += twoPI;
          else if (max > Math.PI)
            max -= twoPI;
          if (min <= max) {
            spherical.theta = Math.max(min, Math.min(max, spherical.theta));
          } else {
            spherical.theta = spherical.theta > (min + max) / 2 ? Math.max(min, spherical.theta) : Math.min(max, spherical.theta);
          }
        }
        spherical.phi = Math.max(scope.minPolarAngle, Math.min(scope.maxPolarAngle, spherical.phi));
        spherical.makeSafe();
        spherical.radius *= scale2;
        spherical.radius = Math.max(scope.minDistance, Math.min(scope.maxDistance, spherical.radius));
        if (scope.enableDamping === true) {
          scope.target.addScaledVector(panOffset, scope.dampingFactor);
        } else {
          scope.target.add(panOffset);
        }
        offset.setFromSpherical(spherical);
        offset.applyQuaternion(quatInverse);
        position2.copy(scope.target).add(offset);
        scope.object.lookAt(scope.target);
        if (scope.enableDamping === true) {
          sphericalDelta.theta *= 1 - scope.dampingFactor;
          sphericalDelta.phi *= 1 - scope.dampingFactor;
          panOffset.multiplyScalar(1 - scope.dampingFactor);
        } else {
          sphericalDelta.set(0, 0, 0);
          panOffset.set(0, 0, 0);
        }
        scale2 = 1;
        if (zoomChanged || lastPosition.distanceToSquared(scope.object.position) > EPS || 8 * (1 - lastQuaternion.dot(scope.object.quaternion)) > EPS) {
          scope.dispatchEvent(_changeEvent$1);
          lastPosition.copy(scope.object.position);
          lastQuaternion.copy(scope.object.quaternion);
          zoomChanged = false;
          return true;
        }
        return false;
      };
    }();
    this.dispose = function() {
      scope.domElement.removeEventListener("contextmenu", onContextMenu);
      scope.domElement.removeEventListener("pointerdown", onPointerDown2);
      scope.domElement.removeEventListener("pointercancel", onPointerCancel);
      scope.domElement.removeEventListener("wheel", onMouseWheel);
      scope.domElement.removeEventListener("pointermove", onPointerMove2);
      scope.domElement.removeEventListener("pointerup", onPointerUp2);
      if (scope._domElementKeyEvents !== null) {
        scope._domElementKeyEvents.removeEventListener("keydown", onKeyDown);
      }
    };
    const scope = this;
    const STATE = {
      NONE: -1,
      ROTATE: 0,
      DOLLY: 1,
      PAN: 2,
      TOUCH_ROTATE: 3,
      TOUCH_PAN: 4,
      TOUCH_DOLLY_PAN: 5,
      TOUCH_DOLLY_ROTATE: 6
    };
    let state = STATE.NONE;
    const EPS = 1e-6;
    const spherical = new Spherical();
    const sphericalDelta = new Spherical();
    let scale2 = 1;
    const panOffset = new Vector3();
    let zoomChanged = false;
    const rotateStart = new Vector2();
    const rotateEnd = new Vector2();
    const rotateDelta = new Vector2();
    const panStart = new Vector2();
    const panEnd = new Vector2();
    const panDelta = new Vector2();
    const dollyStart = new Vector2();
    const dollyEnd = new Vector2();
    const dollyDelta = new Vector2();
    const pointers = [];
    const pointerPositions = {};
    function getAutoRotationAngle() {
      return 2 * Math.PI / 60 / 60 * scope.autoRotateSpeed;
    }
    function getZoomScale() {
      return Math.pow(0.95, scope.zoomSpeed);
    }
    function rotateLeft(angle) {
      sphericalDelta.theta -= angle;
    }
    function rotateUp(angle) {
      sphericalDelta.phi -= angle;
    }
    const panLeft = function() {
      const v = new Vector3();
      return function panLeft2(distance2, objectMatrix) {
        v.setFromMatrixColumn(objectMatrix, 0);
        v.multiplyScalar(-distance2);
        panOffset.add(v);
      };
    }();
    const panUp = function() {
      const v = new Vector3();
      return function panUp2(distance2, objectMatrix) {
        if (scope.screenSpacePanning === true) {
          v.setFromMatrixColumn(objectMatrix, 1);
        } else {
          v.setFromMatrixColumn(objectMatrix, 0);
          v.crossVectors(scope.object.up, v);
        }
        v.multiplyScalar(distance2);
        panOffset.add(v);
      };
    }();
    const pan = function() {
      const offset = new Vector3();
      return function pan2(deltaX, deltaY) {
        const element = scope.domElement;
        if (scope.object.isPerspectiveCamera) {
          const position2 = scope.object.position;
          offset.copy(position2).sub(scope.target);
          let targetDistance = offset.length();
          targetDistance *= Math.tan(scope.object.fov / 2 * Math.PI / 180);
          panLeft(2 * deltaX * targetDistance / element.clientHeight, scope.object.matrix);
          panUp(2 * deltaY * targetDistance / element.clientHeight, scope.object.matrix);
        } else if (scope.object.isOrthographicCamera) {
          panLeft(deltaX * (scope.object.right - scope.object.left) / scope.object.zoom / element.clientWidth, scope.object.matrix);
          panUp(deltaY * (scope.object.top - scope.object.bottom) / scope.object.zoom / element.clientHeight, scope.object.matrix);
        } else {
          console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.");
          scope.enablePan = false;
        }
      };
    }();
    function dollyOut(dollyScale) {
      if (scope.object.isPerspectiveCamera) {
        scale2 /= dollyScale;
      } else if (scope.object.isOrthographicCamera) {
        scope.object.zoom = Math.max(scope.minZoom, Math.min(scope.maxZoom, scope.object.zoom * dollyScale));
        scope.object.updateProjectionMatrix();
        zoomChanged = true;
      } else {
        console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.");
        scope.enableZoom = false;
      }
    }
    function dollyIn(dollyScale) {
      if (scope.object.isPerspectiveCamera) {
        scale2 *= dollyScale;
      } else if (scope.object.isOrthographicCamera) {
        scope.object.zoom = Math.max(scope.minZoom, Math.min(scope.maxZoom, scope.object.zoom / dollyScale));
        scope.object.updateProjectionMatrix();
        zoomChanged = true;
      } else {
        console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.");
        scope.enableZoom = false;
      }
    }
    function handleMouseDownRotate(event) {
      rotateStart.set(event.clientX, event.clientY);
    }
    function handleMouseDownDolly(event) {
      dollyStart.set(event.clientX, event.clientY);
    }
    function handleMouseDownPan(event) {
      panStart.set(event.clientX, event.clientY);
    }
    function handleMouseMoveRotate(event) {
      rotateEnd.set(event.clientX, event.clientY);
      rotateDelta.subVectors(rotateEnd, rotateStart).multiplyScalar(scope.rotateSpeed);
      const element = scope.domElement;
      rotateLeft(2 * Math.PI * rotateDelta.x / element.clientHeight);
      rotateUp(2 * Math.PI * rotateDelta.y / element.clientHeight);
      rotateStart.copy(rotateEnd);
      scope.update();
    }
    function handleMouseMoveDolly(event) {
      dollyEnd.set(event.clientX, event.clientY);
      dollyDelta.subVectors(dollyEnd, dollyStart);
      if (dollyDelta.y > 0) {
        dollyOut(getZoomScale());
      } else if (dollyDelta.y < 0) {
        dollyIn(getZoomScale());
      }
      dollyStart.copy(dollyEnd);
      scope.update();
    }
    function handleMouseMovePan(event) {
      panEnd.set(event.clientX, event.clientY);
      panDelta.subVectors(panEnd, panStart).multiplyScalar(scope.panSpeed);
      pan(panDelta.x, panDelta.y);
      panStart.copy(panEnd);
      scope.update();
    }
    function handleMouseWheel(event) {
      if (event.deltaY < 0) {
        dollyIn(getZoomScale());
      } else if (event.deltaY > 0) {
        dollyOut(getZoomScale());
      }
      scope.update();
    }
    function handleKeyDown(event) {
      let needsUpdate = false;
      switch (event.code) {
        case scope.keys.UP:
          pan(0, scope.keyPanSpeed);
          needsUpdate = true;
          break;
        case scope.keys.BOTTOM:
          pan(0, -scope.keyPanSpeed);
          needsUpdate = true;
          break;
        case scope.keys.LEFT:
          pan(scope.keyPanSpeed, 0);
          needsUpdate = true;
          break;
        case scope.keys.RIGHT:
          pan(-scope.keyPanSpeed, 0);
          needsUpdate = true;
          break;
      }
      if (needsUpdate) {
        event.preventDefault();
        scope.update();
      }
    }
    function handleTouchStartRotate() {
      if (pointers.length === 1) {
        rotateStart.set(pointers[0].pageX, pointers[0].pageY);
      } else {
        const x = 0.5 * (pointers[0].pageX + pointers[1].pageX);
        const y = 0.5 * (pointers[0].pageY + pointers[1].pageY);
        rotateStart.set(x, y);
      }
    }
    function handleTouchStartPan() {
      if (pointers.length === 1) {
        panStart.set(pointers[0].pageX, pointers[0].pageY);
      } else {
        const x = 0.5 * (pointers[0].pageX + pointers[1].pageX);
        const y = 0.5 * (pointers[0].pageY + pointers[1].pageY);
        panStart.set(x, y);
      }
    }
    function handleTouchStartDolly() {
      const dx = pointers[0].pageX - pointers[1].pageX;
      const dy = pointers[0].pageY - pointers[1].pageY;
      const distance2 = Math.sqrt(dx * dx + dy * dy);
      dollyStart.set(0, distance2);
    }
    function handleTouchStartDollyPan() {
      if (scope.enableZoom)
        handleTouchStartDolly();
      if (scope.enablePan)
        handleTouchStartPan();
    }
    function handleTouchStartDollyRotate() {
      if (scope.enableZoom)
        handleTouchStartDolly();
      if (scope.enableRotate)
        handleTouchStartRotate();
    }
    function handleTouchMoveRotate(event) {
      if (pointers.length == 1) {
        rotateEnd.set(event.pageX, event.pageY);
      } else {
        const position2 = getSecondPointerPosition(event);
        const x = 0.5 * (event.pageX + position2.x);
        const y = 0.5 * (event.pageY + position2.y);
        rotateEnd.set(x, y);
      }
      rotateDelta.subVectors(rotateEnd, rotateStart).multiplyScalar(scope.rotateSpeed);
      const element = scope.domElement;
      rotateLeft(2 * Math.PI * rotateDelta.x / element.clientHeight);
      rotateUp(2 * Math.PI * rotateDelta.y / element.clientHeight);
      rotateStart.copy(rotateEnd);
    }
    function handleTouchMovePan(event) {
      if (pointers.length === 1) {
        panEnd.set(event.pageX, event.pageY);
      } else {
        const position2 = getSecondPointerPosition(event);
        const x = 0.5 * (event.pageX + position2.x);
        const y = 0.5 * (event.pageY + position2.y);
        panEnd.set(x, y);
      }
      panDelta.subVectors(panEnd, panStart).multiplyScalar(scope.panSpeed);
      pan(panDelta.x, panDelta.y);
      panStart.copy(panEnd);
    }
    function handleTouchMoveDolly(event) {
      const position2 = getSecondPointerPosition(event);
      const dx = event.pageX - position2.x;
      const dy = event.pageY - position2.y;
      const distance2 = Math.sqrt(dx * dx + dy * dy);
      dollyEnd.set(0, distance2);
      dollyDelta.set(0, Math.pow(dollyEnd.y / dollyStart.y, scope.zoomSpeed));
      dollyOut(dollyDelta.y);
      dollyStart.copy(dollyEnd);
    }
    function handleTouchMoveDollyPan(event) {
      if (scope.enableZoom)
        handleTouchMoveDolly(event);
      if (scope.enablePan)
        handleTouchMovePan(event);
    }
    function handleTouchMoveDollyRotate(event) {
      if (scope.enableZoom)
        handleTouchMoveDolly(event);
      if (scope.enableRotate)
        handleTouchMoveRotate(event);
    }
    function onPointerDown2(event) {
      if (scope.enabled === false)
        return;
      if (pointers.length === 0) {
        scope.domElement.setPointerCapture(event.pointerId);
        scope.domElement.addEventListener("pointermove", onPointerMove2);
        scope.domElement.addEventListener("pointerup", onPointerUp2);
      }
      addPointer(event);
      if (event.pointerType === "touch") {
        onTouchStart(event);
      } else {
        onMouseDown(event);
      }
    }
    function onPointerMove2(event) {
      if (scope.enabled === false)
        return;
      if (event.pointerType === "touch") {
        onTouchMove(event);
      } else {
        onMouseMove(event);
      }
    }
    function onPointerUp2(event) {
      removePointer(event);
      if (pointers.length === 0) {
        scope.domElement.releasePointerCapture(event.pointerId);
        scope.domElement.removeEventListener("pointermove", onPointerMove2);
        scope.domElement.removeEventListener("pointerup", onPointerUp2);
      }
      scope.dispatchEvent(_endEvent);
      state = STATE.NONE;
    }
    function onPointerCancel(event) {
      removePointer(event);
    }
    function onMouseDown(event) {
      let mouseAction;
      switch (event.button) {
        case 0:
          mouseAction = scope.mouseButtons.LEFT;
          break;
        case 1:
          mouseAction = scope.mouseButtons.MIDDLE;
          break;
        case 2:
          mouseAction = scope.mouseButtons.RIGHT;
          break;
        default:
          mouseAction = -1;
      }
      switch (mouseAction) {
        case MOUSE.DOLLY:
          if (scope.enableZoom === false)
            return;
          handleMouseDownDolly(event);
          state = STATE.DOLLY;
          break;
        case MOUSE.ROTATE:
          if (event.ctrlKey || event.metaKey || event.shiftKey) {
            if (scope.enablePan === false)
              return;
            handleMouseDownPan(event);
            state = STATE.PAN;
          } else {
            if (scope.enableRotate === false)
              return;
            handleMouseDownRotate(event);
            state = STATE.ROTATE;
          }
          break;
        case MOUSE.PAN:
          if (event.ctrlKey || event.metaKey || event.shiftKey) {
            if (scope.enableRotate === false)
              return;
            handleMouseDownRotate(event);
            state = STATE.ROTATE;
          } else {
            if (scope.enablePan === false)
              return;
            handleMouseDownPan(event);
            state = STATE.PAN;
          }
          break;
        default:
          state = STATE.NONE;
      }
      if (state !== STATE.NONE) {
        scope.dispatchEvent(_startEvent);
      }
    }
    function onMouseMove(event) {
      if (scope.enabled === false)
        return;
      switch (state) {
        case STATE.ROTATE:
          if (scope.enableRotate === false)
            return;
          handleMouseMoveRotate(event);
          break;
        case STATE.DOLLY:
          if (scope.enableZoom === false)
            return;
          handleMouseMoveDolly(event);
          break;
        case STATE.PAN:
          if (scope.enablePan === false)
            return;
          handleMouseMovePan(event);
          break;
      }
    }
    function onMouseWheel(event) {
      if (scope.enabled === false || scope.enableZoom === false || state !== STATE.NONE)
        return;
      event.preventDefault();
      scope.dispatchEvent(_startEvent);
      handleMouseWheel(event);
      scope.dispatchEvent(_endEvent);
    }
    function onKeyDown(event) {
      if (scope.enabled === false || scope.enablePan === false)
        return;
      handleKeyDown(event);
    }
    function onTouchStart(event) {
      trackPointer(event);
      switch (pointers.length) {
        case 1:
          switch (scope.touches.ONE) {
            case TOUCH.ROTATE:
              if (scope.enableRotate === false)
                return;
              handleTouchStartRotate();
              state = STATE.TOUCH_ROTATE;
              break;
            case TOUCH.PAN:
              if (scope.enablePan === false)
                return;
              handleTouchStartPan();
              state = STATE.TOUCH_PAN;
              break;
            default:
              state = STATE.NONE;
          }
          break;
        case 2:
          switch (scope.touches.TWO) {
            case TOUCH.DOLLY_PAN:
              if (scope.enableZoom === false && scope.enablePan === false)
                return;
              handleTouchStartDollyPan();
              state = STATE.TOUCH_DOLLY_PAN;
              break;
            case TOUCH.DOLLY_ROTATE:
              if (scope.enableZoom === false && scope.enableRotate === false)
                return;
              handleTouchStartDollyRotate();
              state = STATE.TOUCH_DOLLY_ROTATE;
              break;
            default:
              state = STATE.NONE;
          }
          break;
        default:
          state = STATE.NONE;
      }
      if (state !== STATE.NONE) {
        scope.dispatchEvent(_startEvent);
      }
    }
    function onTouchMove(event) {
      trackPointer(event);
      switch (state) {
        case STATE.TOUCH_ROTATE:
          if (scope.enableRotate === false)
            return;
          handleTouchMoveRotate(event);
          scope.update();
          break;
        case STATE.TOUCH_PAN:
          if (scope.enablePan === false)
            return;
          handleTouchMovePan(event);
          scope.update();
          break;
        case STATE.TOUCH_DOLLY_PAN:
          if (scope.enableZoom === false && scope.enablePan === false)
            return;
          handleTouchMoveDollyPan(event);
          scope.update();
          break;
        case STATE.TOUCH_DOLLY_ROTATE:
          if (scope.enableZoom === false && scope.enableRotate === false)
            return;
          handleTouchMoveDollyRotate(event);
          scope.update();
          break;
        default:
          state = STATE.NONE;
      }
    }
    function onContextMenu(event) {
      if (scope.enabled === false)
        return;
      event.preventDefault();
    }
    function addPointer(event) {
      pointers.push(event);
    }
    function removePointer(event) {
      delete pointerPositions[event.pointerId];
      for (let i = 0; i < pointers.length; i++) {
        if (pointers[i].pointerId == event.pointerId) {
          pointers.splice(i, 1);
          return;
        }
      }
    }
    function trackPointer(event) {
      let position2 = pointerPositions[event.pointerId];
      if (position2 === void 0) {
        position2 = new Vector2();
        pointerPositions[event.pointerId] = position2;
      }
      position2.set(event.pageX, event.pageY);
    }
    function getSecondPointerPosition(event) {
      const pointer = event.pointerId === pointers[0].pointerId ? pointers[1] : pointers[0];
      return pointerPositions[pointer.pointerId];
    }
    scope.domElement.addEventListener("contextmenu", onContextMenu);
    scope.domElement.addEventListener("pointerdown", onPointerDown2);
    scope.domElement.addEventListener("pointercancel", onPointerCancel);
    scope.domElement.addEventListener("wheel", onMouseWheel, { passive: false });
    this.update();
  }
}
const _raycaster = new Raycaster();
const _tempVector = new Vector3();
const _tempVector2 = new Vector3();
const _tempQuaternion = new Quaternion();
const _unit = {
  X: new Vector3(1, 0, 0),
  Y: new Vector3(0, 1, 0),
  Z: new Vector3(0, 0, 1)
};
const _changeEvent = { type: "change" };
const _mouseDownEvent = { type: "mouseDown" };
const _mouseUpEvent = { type: "mouseUp", mode: null };
const _objectChangeEvent = { type: "objectChange" };
class TransformControls extends Object3D {
  constructor(camera, domElement) {
    super();
    if (domElement === void 0) {
      console.warn('THREE.TransformControls: The second parameter "domElement" is now mandatory.');
      domElement = document;
    }
    this.visible = false;
    this.domElement = domElement;
    this.domElement.style.touchAction = "none";
    const _gizmo = new TransformControlsGizmo();
    this._gizmo = _gizmo;
    this.add(_gizmo);
    const _plane = new TransformControlsPlane();
    this._plane = _plane;
    this.add(_plane);
    const scope = this;
    function defineProperty(propName, defaultValue2) {
      let propValue = defaultValue2;
      Object.defineProperty(scope, propName, {
        get: function() {
          return propValue !== void 0 ? propValue : defaultValue2;
        },
        set: function(value) {
          if (propValue !== value) {
            propValue = value;
            _plane[propName] = value;
            _gizmo[propName] = value;
            scope.dispatchEvent({ type: propName + "-changed", value });
            scope.dispatchEvent(_changeEvent);
          }
        }
      });
      scope[propName] = defaultValue2;
      _plane[propName] = defaultValue2;
      _gizmo[propName] = defaultValue2;
    }
    defineProperty("camera", camera);
    defineProperty("object", void 0);
    defineProperty("enabled", true);
    defineProperty("axis", null);
    defineProperty("mode", "translate");
    defineProperty("translationSnap", null);
    defineProperty("rotationSnap", null);
    defineProperty("scaleSnap", null);
    defineProperty("space", "world");
    defineProperty("size", 1);
    defineProperty("dragging", false);
    defineProperty("showX", true);
    defineProperty("showY", true);
    defineProperty("showZ", true);
    const worldPosition = new Vector3();
    const worldPositionStart = new Vector3();
    const worldQuaternion = new Quaternion();
    const worldQuaternionStart = new Quaternion();
    const cameraPosition = new Vector3();
    const cameraQuaternion = new Quaternion();
    const pointStart = new Vector3();
    const pointEnd = new Vector3();
    const rotationAxis = new Vector3();
    const rotationAngle = 0;
    const eye = new Vector3();
    defineProperty("worldPosition", worldPosition);
    defineProperty("worldPositionStart", worldPositionStart);
    defineProperty("worldQuaternion", worldQuaternion);
    defineProperty("worldQuaternionStart", worldQuaternionStart);
    defineProperty("cameraPosition", cameraPosition);
    defineProperty("cameraQuaternion", cameraQuaternion);
    defineProperty("pointStart", pointStart);
    defineProperty("pointEnd", pointEnd);
    defineProperty("rotationAxis", rotationAxis);
    defineProperty("rotationAngle", rotationAngle);
    defineProperty("eye", eye);
    this._offset = new Vector3();
    this._startNorm = new Vector3();
    this._endNorm = new Vector3();
    this._cameraScale = new Vector3();
    this._parentPosition = new Vector3();
    this._parentQuaternion = new Quaternion();
    this._parentQuaternionInv = new Quaternion();
    this._parentScale = new Vector3();
    this._worldScaleStart = new Vector3();
    this._worldQuaternionInv = new Quaternion();
    this._worldScale = new Vector3();
    this._positionStart = new Vector3();
    this._quaternionStart = new Quaternion();
    this._scaleStart = new Vector3();
    this._getPointer = getPointer.bind(this);
    this._onPointerDown = onPointerDown.bind(this);
    this._onPointerHover = onPointerHover.bind(this);
    this._onPointerMove = onPointerMove.bind(this);
    this._onPointerUp = onPointerUp.bind(this);
    this.domElement.addEventListener("pointerdown", this._onPointerDown);
    this.domElement.addEventListener("pointermove", this._onPointerHover);
    this.domElement.addEventListener("pointerup", this._onPointerUp);
  }
  updateMatrixWorld() {
    if (this.object !== void 0) {
      this.object.updateMatrixWorld();
      if (this.object.parent === null) {
        console.error("TransformControls: The attached 3D object must be a part of the scene graph.");
      } else {
        this.object.parent.matrixWorld.decompose(this._parentPosition, this._parentQuaternion, this._parentScale);
      }
      this.object.matrixWorld.decompose(this.worldPosition, this.worldQuaternion, this._worldScale);
      this._parentQuaternionInv.copy(this._parentQuaternion).invert();
      this._worldQuaternionInv.copy(this.worldQuaternion).invert();
    }
    this.camera.updateMatrixWorld();
    this.camera.matrixWorld.decompose(this.cameraPosition, this.cameraQuaternion, this._cameraScale);
    this.eye.copy(this.cameraPosition).sub(this.worldPosition).normalize();
    super.updateMatrixWorld(this);
  }
  pointerHover(pointer) {
    if (this.object === void 0 || this.dragging === true)
      return;
    _raycaster.setFromCamera(pointer, this.camera);
    const intersect = intersectObjectWithRay(this._gizmo.picker[this.mode], _raycaster);
    if (intersect) {
      this.axis = intersect.object.name;
    } else {
      this.axis = null;
    }
  }
  pointerDown(pointer) {
    if (this.object === void 0 || this.dragging === true || pointer.button !== 0)
      return;
    if (this.axis !== null) {
      _raycaster.setFromCamera(pointer, this.camera);
      const planeIntersect = intersectObjectWithRay(this._plane, _raycaster, true);
      if (planeIntersect) {
        this.object.updateMatrixWorld();
        this.object.parent.updateMatrixWorld();
        this._positionStart.copy(this.object.position);
        this._quaternionStart.copy(this.object.quaternion);
        this._scaleStart.copy(this.object.scale);
        this.object.matrixWorld.decompose(this.worldPositionStart, this.worldQuaternionStart, this._worldScaleStart);
        this.pointStart.copy(planeIntersect.point).sub(this.worldPositionStart);
      }
      this.dragging = true;
      _mouseDownEvent.mode = this.mode;
      this.dispatchEvent(_mouseDownEvent);
    }
  }
  pointerMove(pointer) {
    const axis = this.axis;
    const mode = this.mode;
    const object = this.object;
    let space2 = this.space;
    if (mode === "scale") {
      space2 = "local";
    } else if (axis === "E" || axis === "XYZE" || axis === "XYZ") {
      space2 = "world";
    }
    if (object === void 0 || axis === null || this.dragging === false || pointer.button !== -1)
      return;
    _raycaster.setFromCamera(pointer, this.camera);
    const planeIntersect = intersectObjectWithRay(this._plane, _raycaster, true);
    if (!planeIntersect)
      return;
    this.pointEnd.copy(planeIntersect.point).sub(this.worldPositionStart);
    if (mode === "translate") {
      this._offset.copy(this.pointEnd).sub(this.pointStart);
      if (space2 === "local" && axis !== "XYZ") {
        this._offset.applyQuaternion(this._worldQuaternionInv);
      }
      if (axis.indexOf("X") === -1)
        this._offset.x = 0;
      if (axis.indexOf("Y") === -1)
        this._offset.y = 0;
      if (axis.indexOf("Z") === -1)
        this._offset.z = 0;
      if (space2 === "local" && axis !== "XYZ") {
        this._offset.applyQuaternion(this._quaternionStart).divide(this._parentScale);
      } else {
        this._offset.applyQuaternion(this._parentQuaternionInv).divide(this._parentScale);
      }
      object.position.copy(this._offset).add(this._positionStart);
      if (this.translationSnap) {
        if (space2 === "local") {
          object.position.applyQuaternion(_tempQuaternion.copy(this._quaternionStart).invert());
          if (axis.search("X") !== -1) {
            object.position.x = Math.round(object.position.x / this.translationSnap) * this.translationSnap;
          }
          if (axis.search("Y") !== -1) {
            object.position.y = Math.round(object.position.y / this.translationSnap) * this.translationSnap;
          }
          if (axis.search("Z") !== -1) {
            object.position.z = Math.round(object.position.z / this.translationSnap) * this.translationSnap;
          }
          object.position.applyQuaternion(this._quaternionStart);
        }
        if (space2 === "world") {
          if (object.parent) {
            object.position.add(_tempVector.setFromMatrixPosition(object.parent.matrixWorld));
          }
          if (axis.search("X") !== -1) {
            object.position.x = Math.round(object.position.x / this.translationSnap) * this.translationSnap;
          }
          if (axis.search("Y") !== -1) {
            object.position.y = Math.round(object.position.y / this.translationSnap) * this.translationSnap;
          }
          if (axis.search("Z") !== -1) {
            object.position.z = Math.round(object.position.z / this.translationSnap) * this.translationSnap;
          }
          if (object.parent) {
            object.position.sub(_tempVector.setFromMatrixPosition(object.parent.matrixWorld));
          }
        }
      }
    } else if (mode === "scale") {
      if (axis.search("XYZ") !== -1) {
        let d = this.pointEnd.length() / this.pointStart.length();
        if (this.pointEnd.dot(this.pointStart) < 0)
          d *= -1;
        _tempVector2.set(d, d, d);
      } else {
        _tempVector.copy(this.pointStart);
        _tempVector2.copy(this.pointEnd);
        _tempVector.applyQuaternion(this._worldQuaternionInv);
        _tempVector2.applyQuaternion(this._worldQuaternionInv);
        _tempVector2.divide(_tempVector);
        if (axis.search("X") === -1) {
          _tempVector2.x = 1;
        }
        if (axis.search("Y") === -1) {
          _tempVector2.y = 1;
        }
        if (axis.search("Z") === -1) {
          _tempVector2.z = 1;
        }
      }
      object.scale.copy(this._scaleStart).multiply(_tempVector2);
      if (this.scaleSnap) {
        if (axis.search("X") !== -1) {
          object.scale.x = Math.round(object.scale.x / this.scaleSnap) * this.scaleSnap || this.scaleSnap;
        }
        if (axis.search("Y") !== -1) {
          object.scale.y = Math.round(object.scale.y / this.scaleSnap) * this.scaleSnap || this.scaleSnap;
        }
        if (axis.search("Z") !== -1) {
          object.scale.z = Math.round(object.scale.z / this.scaleSnap) * this.scaleSnap || this.scaleSnap;
        }
      }
    } else if (mode === "rotate") {
      this._offset.copy(this.pointEnd).sub(this.pointStart);
      const ROTATION_SPEED = 20 / this.worldPosition.distanceTo(_tempVector.setFromMatrixPosition(this.camera.matrixWorld));
      if (axis === "E") {
        this.rotationAxis.copy(this.eye);
        this.rotationAngle = this.pointEnd.angleTo(this.pointStart);
        this._startNorm.copy(this.pointStart).normalize();
        this._endNorm.copy(this.pointEnd).normalize();
        this.rotationAngle *= this._endNorm.cross(this._startNorm).dot(this.eye) < 0 ? 1 : -1;
      } else if (axis === "XYZE") {
        this.rotationAxis.copy(this._offset).cross(this.eye).normalize();
        this.rotationAngle = this._offset.dot(_tempVector.copy(this.rotationAxis).cross(this.eye)) * ROTATION_SPEED;
      } else if (axis === "X" || axis === "Y" || axis === "Z") {
        this.rotationAxis.copy(_unit[axis]);
        _tempVector.copy(_unit[axis]);
        if (space2 === "local") {
          _tempVector.applyQuaternion(this.worldQuaternion);
        }
        this.rotationAngle = this._offset.dot(_tempVector.cross(this.eye).normalize()) * ROTATION_SPEED;
      }
      if (this.rotationSnap)
        this.rotationAngle = Math.round(this.rotationAngle / this.rotationSnap) * this.rotationSnap;
      if (space2 === "local" && axis !== "E" && axis !== "XYZE") {
        object.quaternion.copy(this._quaternionStart);
        object.quaternion.multiply(_tempQuaternion.setFromAxisAngle(this.rotationAxis, this.rotationAngle)).normalize();
      } else {
        this.rotationAxis.applyQuaternion(this._parentQuaternionInv);
        object.quaternion.copy(_tempQuaternion.setFromAxisAngle(this.rotationAxis, this.rotationAngle));
        object.quaternion.multiply(this._quaternionStart).normalize();
      }
    }
    this.dispatchEvent(_changeEvent);
    this.dispatchEvent(_objectChangeEvent);
  }
  pointerUp(pointer) {
    if (pointer.button !== 0)
      return;
    if (this.dragging && this.axis !== null) {
      _mouseUpEvent.mode = this.mode;
      this.dispatchEvent(_mouseUpEvent);
    }
    this.dragging = false;
    this.axis = null;
  }
  dispose() {
    this.domElement.removeEventListener("pointerdown", this._onPointerDown);
    this.domElement.removeEventListener("pointermove", this._onPointerHover);
    this.domElement.removeEventListener("pointermove", this._onPointerMove);
    this.domElement.removeEventListener("pointerup", this._onPointerUp);
    this.traverse(function(child) {
      if (child.geometry)
        child.geometry.dispose();
      if (child.material)
        child.material.dispose();
    });
  }
  attach(object) {
    this.object = object;
    this.visible = true;
    return this;
  }
  detach() {
    this.object = void 0;
    this.visible = false;
    this.axis = null;
    return this;
  }
  reset() {
    if (!this.enabled)
      return;
    if (this.dragging) {
      this.object.position.copy(this._positionStart);
      this.object.quaternion.copy(this._quaternionStart);
      this.object.scale.copy(this._scaleStart);
      this.dispatchEvent(_changeEvent);
      this.dispatchEvent(_objectChangeEvent);
      this.pointStart.copy(this.pointEnd);
    }
  }
  getRaycaster() {
    return _raycaster;
  }
  getMode() {
    return this.mode;
  }
  setMode(mode) {
    this.mode = mode;
  }
  setTranslationSnap(translationSnap) {
    this.translationSnap = translationSnap;
  }
  setRotationSnap(rotationSnap) {
    this.rotationSnap = rotationSnap;
  }
  setScaleSnap(scaleSnap) {
    this.scaleSnap = scaleSnap;
  }
  setSize(size2) {
    this.size = size2;
  }
  setSpace(space2) {
    this.space = space2;
  }
  update() {
    console.warn("THREE.TransformControls: update function has no more functionality and therefore has been deprecated.");
  }
}
TransformControls.prototype.isTransformControls = true;
function getPointer(event) {
  if (this.domElement.ownerDocument.pointerLockElement) {
    return {
      x: 0,
      y: 0,
      button: event.button
    };
  } else {
    const rect2 = this.domElement.getBoundingClientRect();
    return {
      x: (event.clientX - rect2.left) / rect2.width * 2 - 1,
      y: -(event.clientY - rect2.top) / rect2.height * 2 + 1,
      button: event.button
    };
  }
}
function onPointerHover(event) {
  if (!this.enabled)
    return;
  switch (event.pointerType) {
    case "mouse":
    case "pen":
      this.pointerHover(this._getPointer(event));
      break;
  }
}
function onPointerDown(event) {
  if (!this.enabled)
    return;
  if (!document.pointerLockElement) {
    this.domElement.setPointerCapture(event.pointerId);
  }
  this.domElement.addEventListener("pointermove", this._onPointerMove);
  this.pointerHover(this._getPointer(event));
  this.pointerDown(this._getPointer(event));
}
function onPointerMove(event) {
  if (!this.enabled)
    return;
  this.pointerMove(this._getPointer(event));
}
function onPointerUp(event) {
  if (!this.enabled)
    return;
  this.domElement.releasePointerCapture(event.pointerId);
  this.domElement.removeEventListener("pointermove", this._onPointerMove);
  this.pointerUp(this._getPointer(event));
}
function intersectObjectWithRay(object, raycaster, includeInvisible) {
  const allIntersections = raycaster.intersectObject(object, true);
  for (let i = 0; i < allIntersections.length; i++) {
    if (allIntersections[i].object.visible || includeInvisible) {
      return allIntersections[i];
    }
  }
  return false;
}
const _tempEuler = new Euler();
const _alignVector = new Vector3(0, 1, 0);
const _zeroVector = new Vector3(0, 0, 0);
const _lookAtMatrix = new Matrix4();
const _tempQuaternion2 = new Quaternion();
const _identityQuaternion = new Quaternion();
const _dirVector = new Vector3();
const _tempMatrix = new Matrix4();
const _unitX = new Vector3(1, 0, 0);
const _unitY = new Vector3(0, 1, 0);
const _unitZ = new Vector3(0, 0, 1);
const _v1 = new Vector3();
const _v2 = new Vector3();
const _v3 = new Vector3();
class TransformControlsGizmo extends Object3D {
  constructor() {
    super();
    this.type = "TransformControlsGizmo";
    const gizmoMaterial = new MeshBasicMaterial({
      depthTest: false,
      depthWrite: false,
      fog: false,
      toneMapped: false,
      transparent: true
    });
    const gizmoLineMaterial = new LineBasicMaterial({
      depthTest: false,
      depthWrite: false,
      fog: false,
      toneMapped: false,
      transparent: true
    });
    const matInvisible = gizmoMaterial.clone();
    matInvisible.opacity = 0.15;
    const matHelper = gizmoLineMaterial.clone();
    matHelper.opacity = 0.5;
    const matRed = gizmoMaterial.clone();
    matRed.color.setHex(16711680);
    const matGreen = gizmoMaterial.clone();
    matGreen.color.setHex(65280);
    const matBlue = gizmoMaterial.clone();
    matBlue.color.setHex(255);
    const matRedTransparent = gizmoMaterial.clone();
    matRedTransparent.color.setHex(16711680);
    matRedTransparent.opacity = 0.5;
    const matGreenTransparent = gizmoMaterial.clone();
    matGreenTransparent.color.setHex(65280);
    matGreenTransparent.opacity = 0.5;
    const matBlueTransparent = gizmoMaterial.clone();
    matBlueTransparent.color.setHex(255);
    matBlueTransparent.opacity = 0.5;
    const matWhiteTransparent = gizmoMaterial.clone();
    matWhiteTransparent.opacity = 0.25;
    const matYellowTransparent = gizmoMaterial.clone();
    matYellowTransparent.color.setHex(16776960);
    matYellowTransparent.opacity = 0.25;
    const matYellow = gizmoMaterial.clone();
    matYellow.color.setHex(16776960);
    const matGray = gizmoMaterial.clone();
    matGray.color.setHex(7895160);
    const arrowGeometry = new CylinderGeometry(0, 0.04, 0.1, 12);
    arrowGeometry.translate(0, 0.05, 0);
    const scaleHandleGeometry = new BoxGeometry(0.08, 0.08, 0.08);
    scaleHandleGeometry.translate(0, 0.04, 0);
    const lineGeometry = new BufferGeometry();
    lineGeometry.setAttribute("position", new Float32BufferAttribute([0, 0, 0, 1, 0, 0], 3));
    const lineGeometry2 = new CylinderGeometry(75e-4, 75e-4, 0.5, 3);
    lineGeometry2.translate(0, 0.25, 0);
    function CircleGeometry2(radius, arc) {
      const geometry = new TorusGeometry(radius, 75e-4, 3, 64, arc * Math.PI * 2);
      geometry.rotateY(Math.PI / 2);
      geometry.rotateX(Math.PI / 2);
      return geometry;
    }
    function TranslateHelperGeometry() {
      const geometry = new BufferGeometry();
      geometry.setAttribute("position", new Float32BufferAttribute([0, 0, 0, 1, 1, 1], 3));
      return geometry;
    }
    const gizmoTranslate = {
      X: [
        [new Mesh(arrowGeometry, matRed), [0.5, 0, 0], [0, 0, -Math.PI / 2]],
        [new Mesh(arrowGeometry, matRed), [-0.5, 0, 0], [0, 0, Math.PI / 2]],
        [new Mesh(lineGeometry2, matRed), [0, 0, 0], [0, 0, -Math.PI / 2]]
      ],
      Y: [
        [new Mesh(arrowGeometry, matGreen), [0, 0.5, 0]],
        [new Mesh(arrowGeometry, matGreen), [0, -0.5, 0], [Math.PI, 0, 0]],
        [new Mesh(lineGeometry2, matGreen)]
      ],
      Z: [
        [new Mesh(arrowGeometry, matBlue), [0, 0, 0.5], [Math.PI / 2, 0, 0]],
        [new Mesh(arrowGeometry, matBlue), [0, 0, -0.5], [-Math.PI / 2, 0, 0]],
        [new Mesh(lineGeometry2, matBlue), null, [Math.PI / 2, 0, 0]]
      ],
      XYZ: [
        [new Mesh(new OctahedronGeometry(0.1, 0), matWhiteTransparent.clone()), [0, 0, 0]]
      ],
      XY: [
        [new Mesh(new BoxGeometry(0.15, 0.15, 0.01), matBlueTransparent.clone()), [0.15, 0.15, 0]]
      ],
      YZ: [
        [new Mesh(new BoxGeometry(0.15, 0.15, 0.01), matRedTransparent.clone()), [0, 0.15, 0.15], [0, Math.PI / 2, 0]]
      ],
      XZ: [
        [new Mesh(new BoxGeometry(0.15, 0.15, 0.01), matGreenTransparent.clone()), [0.15, 0, 0.15], [-Math.PI / 2, 0, 0]]
      ]
    };
    const pickerTranslate = {
      X: [
        [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), matInvisible), [0.3, 0, 0], [0, 0, -Math.PI / 2]],
        [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), matInvisible), [-0.3, 0, 0], [0, 0, Math.PI / 2]]
      ],
      Y: [
        [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), matInvisible), [0, 0.3, 0]],
        [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), matInvisible), [0, -0.3, 0], [0, 0, Math.PI]]
      ],
      Z: [
        [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), matInvisible), [0, 0, 0.3], [Math.PI / 2, 0, 0]],
        [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), matInvisible), [0, 0, -0.3], [-Math.PI / 2, 0, 0]]
      ],
      XYZ: [
        [new Mesh(new OctahedronGeometry(0.2, 0), matInvisible)]
      ],
      XY: [
        [new Mesh(new BoxGeometry(0.2, 0.2, 0.01), matInvisible), [0.15, 0.15, 0]]
      ],
      YZ: [
        [new Mesh(new BoxGeometry(0.2, 0.2, 0.01), matInvisible), [0, 0.15, 0.15], [0, Math.PI / 2, 0]]
      ],
      XZ: [
        [new Mesh(new BoxGeometry(0.2, 0.2, 0.01), matInvisible), [0.15, 0, 0.15], [-Math.PI / 2, 0, 0]]
      ]
    };
    const helperTranslate = {
      START: [
        [new Mesh(new OctahedronGeometry(0.01, 2), matHelper), null, null, null, "helper"]
      ],
      END: [
        [new Mesh(new OctahedronGeometry(0.01, 2), matHelper), null, null, null, "helper"]
      ],
      DELTA: [
        [new Line(TranslateHelperGeometry(), matHelper), null, null, null, "helper"]
      ],
      X: [
        [new Line(lineGeometry, matHelper.clone()), [-1e3, 0, 0], null, [1e6, 1, 1], "helper"]
      ],
      Y: [
        [new Line(lineGeometry, matHelper.clone()), [0, -1e3, 0], [0, 0, Math.PI / 2], [1e6, 1, 1], "helper"]
      ],
      Z: [
        [new Line(lineGeometry, matHelper.clone()), [0, 0, -1e3], [0, -Math.PI / 2, 0], [1e6, 1, 1], "helper"]
      ]
    };
    const gizmoRotate = {
      XYZE: [
        [new Mesh(CircleGeometry2(0.5, 1), matGray), null, [0, Math.PI / 2, 0]]
      ],
      X: [
        [new Mesh(CircleGeometry2(0.5, 0.5), matRed)]
      ],
      Y: [
        [new Mesh(CircleGeometry2(0.5, 0.5), matGreen), null, [0, 0, -Math.PI / 2]]
      ],
      Z: [
        [new Mesh(CircleGeometry2(0.5, 0.5), matBlue), null, [0, Math.PI / 2, 0]]
      ],
      E: [
        [new Mesh(CircleGeometry2(0.75, 1), matYellowTransparent), null, [0, Math.PI / 2, 0]]
      ]
    };
    const helperRotate = {
      AXIS: [
        [new Line(lineGeometry, matHelper.clone()), [-1e3, 0, 0], null, [1e6, 1, 1], "helper"]
      ]
    };
    const pickerRotate = {
      XYZE: [
        [new Mesh(new SphereGeometry(0.25, 10, 8), matInvisible)]
      ],
      X: [
        [new Mesh(new TorusGeometry(0.5, 0.1, 4, 24), matInvisible), [0, 0, 0], [0, -Math.PI / 2, -Math.PI / 2]]
      ],
      Y: [
        [new Mesh(new TorusGeometry(0.5, 0.1, 4, 24), matInvisible), [0, 0, 0], [Math.PI / 2, 0, 0]]
      ],
      Z: [
        [new Mesh(new TorusGeometry(0.5, 0.1, 4, 24), matInvisible), [0, 0, 0], [0, 0, -Math.PI / 2]]
      ],
      E: [
        [new Mesh(new TorusGeometry(0.75, 0.1, 2, 24), matInvisible)]
      ]
    };
    const gizmoScale = {
      X: [
        [new Mesh(scaleHandleGeometry, matRed), [0.5, 0, 0], [0, 0, -Math.PI / 2]],
        [new Mesh(lineGeometry2, matRed), [0, 0, 0], [0, 0, -Math.PI / 2]],
        [new Mesh(scaleHandleGeometry, matRed), [-0.5, 0, 0], [0, 0, Math.PI / 2]]
      ],
      Y: [
        [new Mesh(scaleHandleGeometry, matGreen), [0, 0.5, 0]],
        [new Mesh(lineGeometry2, matGreen)],
        [new Mesh(scaleHandleGeometry, matGreen), [0, -0.5, 0], [0, 0, Math.PI]]
      ],
      Z: [
        [new Mesh(scaleHandleGeometry, matBlue), [0, 0, 0.5], [Math.PI / 2, 0, 0]],
        [new Mesh(lineGeometry2, matBlue), [0, 0, 0], [Math.PI / 2, 0, 0]],
        [new Mesh(scaleHandleGeometry, matBlue), [0, 0, -0.5], [-Math.PI / 2, 0, 0]]
      ],
      XY: [
        [new Mesh(new BoxGeometry(0.15, 0.15, 0.01), matBlueTransparent), [0.15, 0.15, 0]]
      ],
      YZ: [
        [new Mesh(new BoxGeometry(0.15, 0.15, 0.01), matRedTransparent), [0, 0.15, 0.15], [0, Math.PI / 2, 0]]
      ],
      XZ: [
        [new Mesh(new BoxGeometry(0.15, 0.15, 0.01), matGreenTransparent), [0.15, 0, 0.15], [-Math.PI / 2, 0, 0]]
      ],
      XYZ: [
        [new Mesh(new BoxGeometry(0.1, 0.1, 0.1), matWhiteTransparent.clone())]
      ]
    };
    const pickerScale = {
      X: [
        [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), matInvisible), [0.3, 0, 0], [0, 0, -Math.PI / 2]],
        [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), matInvisible), [-0.3, 0, 0], [0, 0, Math.PI / 2]]
      ],
      Y: [
        [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), matInvisible), [0, 0.3, 0]],
        [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), matInvisible), [0, -0.3, 0], [0, 0, Math.PI]]
      ],
      Z: [
        [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), matInvisible), [0, 0, 0.3], [Math.PI / 2, 0, 0]],
        [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), matInvisible), [0, 0, -0.3], [-Math.PI / 2, 0, 0]]
      ],
      XY: [
        [new Mesh(new BoxGeometry(0.2, 0.2, 0.01), matInvisible), [0.15, 0.15, 0]]
      ],
      YZ: [
        [new Mesh(new BoxGeometry(0.2, 0.2, 0.01), matInvisible), [0, 0.15, 0.15], [0, Math.PI / 2, 0]]
      ],
      XZ: [
        [new Mesh(new BoxGeometry(0.2, 0.2, 0.01), matInvisible), [0.15, 0, 0.15], [-Math.PI / 2, 0, 0]]
      ],
      XYZ: [
        [new Mesh(new BoxGeometry(0.2, 0.2, 0.2), matInvisible), [0, 0, 0]]
      ]
    };
    const helperScale = {
      X: [
        [new Line(lineGeometry, matHelper.clone()), [-1e3, 0, 0], null, [1e6, 1, 1], "helper"]
      ],
      Y: [
        [new Line(lineGeometry, matHelper.clone()), [0, -1e3, 0], [0, 0, Math.PI / 2], [1e6, 1, 1], "helper"]
      ],
      Z: [
        [new Line(lineGeometry, matHelper.clone()), [0, 0, -1e3], [0, -Math.PI / 2, 0], [1e6, 1, 1], "helper"]
      ]
    };
    function setupGizmo(gizmoMap) {
      const gizmo = new Object3D();
      for (const name in gizmoMap) {
        for (let i = gizmoMap[name].length; i--; ) {
          const object = gizmoMap[name][i][0].clone();
          const position2 = gizmoMap[name][i][1];
          const rotation = gizmoMap[name][i][2];
          const scale2 = gizmoMap[name][i][3];
          const tag = gizmoMap[name][i][4];
          object.name = name;
          object.tag = tag;
          if (position2) {
            object.position.set(position2[0], position2[1], position2[2]);
          }
          if (rotation) {
            object.rotation.set(rotation[0], rotation[1], rotation[2]);
          }
          if (scale2) {
            object.scale.set(scale2[0], scale2[1], scale2[2]);
          }
          object.updateMatrix();
          const tempGeometry = object.geometry.clone();
          tempGeometry.applyMatrix4(object.matrix);
          object.geometry = tempGeometry;
          object.renderOrder = Infinity;
          object.position.set(0, 0, 0);
          object.rotation.set(0, 0, 0);
          object.scale.set(1, 1, 1);
          gizmo.add(object);
        }
      }
      return gizmo;
    }
    this.gizmo = {};
    this.picker = {};
    this.helper = {};
    this.add(this.gizmo["translate"] = setupGizmo(gizmoTranslate));
    this.add(this.gizmo["rotate"] = setupGizmo(gizmoRotate));
    this.add(this.gizmo["scale"] = setupGizmo(gizmoScale));
    this.add(this.picker["translate"] = setupGizmo(pickerTranslate));
    this.add(this.picker["rotate"] = setupGizmo(pickerRotate));
    this.add(this.picker["scale"] = setupGizmo(pickerScale));
    this.add(this.helper["translate"] = setupGizmo(helperTranslate));
    this.add(this.helper["rotate"] = setupGizmo(helperRotate));
    this.add(this.helper["scale"] = setupGizmo(helperScale));
    this.picker["translate"].visible = false;
    this.picker["rotate"].visible = false;
    this.picker["scale"].visible = false;
  }
  updateMatrixWorld(force) {
    const space2 = this.mode === "scale" ? "local" : this.space;
    const quaternion = space2 === "local" ? this.worldQuaternion : _identityQuaternion;
    this.gizmo["translate"].visible = this.mode === "translate";
    this.gizmo["rotate"].visible = this.mode === "rotate";
    this.gizmo["scale"].visible = this.mode === "scale";
    this.helper["translate"].visible = this.mode === "translate";
    this.helper["rotate"].visible = this.mode === "rotate";
    this.helper["scale"].visible = this.mode === "scale";
    let handles = [];
    handles = handles.concat(this.picker[this.mode].children);
    handles = handles.concat(this.gizmo[this.mode].children);
    handles = handles.concat(this.helper[this.mode].children);
    for (let i = 0; i < handles.length; i++) {
      const handle = handles[i];
      handle.visible = true;
      handle.rotation.set(0, 0, 0);
      handle.position.copy(this.worldPosition);
      let factor;
      if (this.camera.isOrthographicCamera) {
        factor = (this.camera.top - this.camera.bottom) / this.camera.zoom;
      } else {
        factor = this.worldPosition.distanceTo(this.cameraPosition) * Math.min(1.9 * Math.tan(Math.PI * this.camera.fov / 360) / this.camera.zoom, 7);
      }
      handle.scale.set(1, 1, 1).multiplyScalar(factor * this.size / 4);
      if (handle.tag === "helper") {
        handle.visible = false;
        if (handle.name === "AXIS") {
          handle.position.copy(this.worldPositionStart);
          handle.visible = !!this.axis;
          if (this.axis === "X") {
            _tempQuaternion.setFromEuler(_tempEuler.set(0, 0, 0));
            handle.quaternion.copy(quaternion).multiply(_tempQuaternion);
            if (Math.abs(_alignVector.copy(_unitX).applyQuaternion(quaternion).dot(this.eye)) > 0.9) {
              handle.visible = false;
            }
          }
          if (this.axis === "Y") {
            _tempQuaternion.setFromEuler(_tempEuler.set(0, 0, Math.PI / 2));
            handle.quaternion.copy(quaternion).multiply(_tempQuaternion);
            if (Math.abs(_alignVector.copy(_unitY).applyQuaternion(quaternion).dot(this.eye)) > 0.9) {
              handle.visible = false;
            }
          }
          if (this.axis === "Z") {
            _tempQuaternion.setFromEuler(_tempEuler.set(0, Math.PI / 2, 0));
            handle.quaternion.copy(quaternion).multiply(_tempQuaternion);
            if (Math.abs(_alignVector.copy(_unitZ).applyQuaternion(quaternion).dot(this.eye)) > 0.9) {
              handle.visible = false;
            }
          }
          if (this.axis === "XYZE") {
            _tempQuaternion.setFromEuler(_tempEuler.set(0, Math.PI / 2, 0));
            _alignVector.copy(this.rotationAxis);
            handle.quaternion.setFromRotationMatrix(_lookAtMatrix.lookAt(_zeroVector, _alignVector, _unitY));
            handle.quaternion.multiply(_tempQuaternion);
            handle.visible = this.dragging;
          }
          if (this.axis === "E") {
            handle.visible = false;
          }
        } else if (handle.name === "START") {
          handle.position.copy(this.worldPositionStart);
          handle.visible = this.dragging;
        } else if (handle.name === "END") {
          handle.position.copy(this.worldPosition);
          handle.visible = this.dragging;
        } else if (handle.name === "DELTA") {
          handle.position.copy(this.worldPositionStart);
          handle.quaternion.copy(this.worldQuaternionStart);
          _tempVector.set(1e-10, 1e-10, 1e-10).add(this.worldPositionStart).sub(this.worldPosition).multiplyScalar(-1);
          _tempVector.applyQuaternion(this.worldQuaternionStart.clone().invert());
          handle.scale.copy(_tempVector);
          handle.visible = this.dragging;
        } else {
          handle.quaternion.copy(quaternion);
          if (this.dragging) {
            handle.position.copy(this.worldPositionStart);
          } else {
            handle.position.copy(this.worldPosition);
          }
          if (this.axis) {
            handle.visible = this.axis.search(handle.name) !== -1;
          }
        }
        continue;
      }
      handle.quaternion.copy(quaternion);
      if (this.mode === "translate" || this.mode === "scale") {
        const AXIS_HIDE_TRESHOLD = 0.99;
        const PLANE_HIDE_TRESHOLD = 0.2;
        if (handle.name === "X") {
          if (Math.abs(_alignVector.copy(_unitX).applyQuaternion(quaternion).dot(this.eye)) > AXIS_HIDE_TRESHOLD) {
            handle.scale.set(1e-10, 1e-10, 1e-10);
            handle.visible = false;
          }
        }
        if (handle.name === "Y") {
          if (Math.abs(_alignVector.copy(_unitY).applyQuaternion(quaternion).dot(this.eye)) > AXIS_HIDE_TRESHOLD) {
            handle.scale.set(1e-10, 1e-10, 1e-10);
            handle.visible = false;
          }
        }
        if (handle.name === "Z") {
          if (Math.abs(_alignVector.copy(_unitZ).applyQuaternion(quaternion).dot(this.eye)) > AXIS_HIDE_TRESHOLD) {
            handle.scale.set(1e-10, 1e-10, 1e-10);
            handle.visible = false;
          }
        }
        if (handle.name === "XY") {
          if (Math.abs(_alignVector.copy(_unitZ).applyQuaternion(quaternion).dot(this.eye)) < PLANE_HIDE_TRESHOLD) {
            handle.scale.set(1e-10, 1e-10, 1e-10);
            handle.visible = false;
          }
        }
        if (handle.name === "YZ") {
          if (Math.abs(_alignVector.copy(_unitX).applyQuaternion(quaternion).dot(this.eye)) < PLANE_HIDE_TRESHOLD) {
            handle.scale.set(1e-10, 1e-10, 1e-10);
            handle.visible = false;
          }
        }
        if (handle.name === "XZ") {
          if (Math.abs(_alignVector.copy(_unitY).applyQuaternion(quaternion).dot(this.eye)) < PLANE_HIDE_TRESHOLD) {
            handle.scale.set(1e-10, 1e-10, 1e-10);
            handle.visible = false;
          }
        }
      } else if (this.mode === "rotate") {
        _tempQuaternion2.copy(quaternion);
        _alignVector.copy(this.eye).applyQuaternion(_tempQuaternion.copy(quaternion).invert());
        if (handle.name.search("E") !== -1) {
          handle.quaternion.setFromRotationMatrix(_lookAtMatrix.lookAt(this.eye, _zeroVector, _unitY));
        }
        if (handle.name === "X") {
          _tempQuaternion.setFromAxisAngle(_unitX, Math.atan2(-_alignVector.y, _alignVector.z));
          _tempQuaternion.multiplyQuaternions(_tempQuaternion2, _tempQuaternion);
          handle.quaternion.copy(_tempQuaternion);
        }
        if (handle.name === "Y") {
          _tempQuaternion.setFromAxisAngle(_unitY, Math.atan2(_alignVector.x, _alignVector.z));
          _tempQuaternion.multiplyQuaternions(_tempQuaternion2, _tempQuaternion);
          handle.quaternion.copy(_tempQuaternion);
        }
        if (handle.name === "Z") {
          _tempQuaternion.setFromAxisAngle(_unitZ, Math.atan2(_alignVector.y, _alignVector.x));
          _tempQuaternion.multiplyQuaternions(_tempQuaternion2, _tempQuaternion);
          handle.quaternion.copy(_tempQuaternion);
        }
      }
      handle.visible = handle.visible && (handle.name.indexOf("X") === -1 || this.showX);
      handle.visible = handle.visible && (handle.name.indexOf("Y") === -1 || this.showY);
      handle.visible = handle.visible && (handle.name.indexOf("Z") === -1 || this.showZ);
      handle.visible = handle.visible && (handle.name.indexOf("E") === -1 || this.showX && this.showY && this.showZ);
      handle.material._color = handle.material._color || handle.material.color.clone();
      handle.material._opacity = handle.material._opacity || handle.material.opacity;
      handle.material.color.copy(handle.material._color);
      handle.material.opacity = handle.material._opacity;
      if (this.enabled && this.axis) {
        if (handle.name === this.axis) {
          handle.material.color.setHex(16776960);
          handle.material.opacity = 1;
        } else if (this.axis.split("").some(function(a) {
          return handle.name === a;
        })) {
          handle.material.color.setHex(16776960);
          handle.material.opacity = 1;
        }
      }
    }
    super.updateMatrixWorld(force);
  }
}
TransformControlsGizmo.prototype.isTransformControlsGizmo = true;
class TransformControlsPlane extends Mesh {
  constructor() {
    super(new PlaneGeometry(1e5, 1e5, 2, 2), new MeshBasicMaterial({ visible: false, wireframe: true, side: DoubleSide, transparent: true, opacity: 0.1, toneMapped: false }));
    this.type = "TransformControlsPlane";
  }
  updateMatrixWorld(force) {
    let space2 = this.space;
    this.position.copy(this.worldPosition);
    if (this.mode === "scale")
      space2 = "local";
    _v1.copy(_unitX).applyQuaternion(space2 === "local" ? this.worldQuaternion : _identityQuaternion);
    _v2.copy(_unitY).applyQuaternion(space2 === "local" ? this.worldQuaternion : _identityQuaternion);
    _v3.copy(_unitZ).applyQuaternion(space2 === "local" ? this.worldQuaternion : _identityQuaternion);
    _alignVector.copy(_v2);
    switch (this.mode) {
      case "translate":
      case "scale":
        switch (this.axis) {
          case "X":
            _alignVector.copy(this.eye).cross(_v1);
            _dirVector.copy(_v1).cross(_alignVector);
            break;
          case "Y":
            _alignVector.copy(this.eye).cross(_v2);
            _dirVector.copy(_v2).cross(_alignVector);
            break;
          case "Z":
            _alignVector.copy(this.eye).cross(_v3);
            _dirVector.copy(_v3).cross(_alignVector);
            break;
          case "XY":
            _dirVector.copy(_v3);
            break;
          case "YZ":
            _dirVector.copy(_v1);
            break;
          case "XZ":
            _alignVector.copy(_v3);
            _dirVector.copy(_v2);
            break;
          case "XYZ":
          case "E":
            _dirVector.set(0, 0, 0);
            break;
        }
        break;
      case "rotate":
      default:
        _dirVector.set(0, 0, 0);
    }
    if (_dirVector.length() === 0) {
      this.quaternion.copy(this.cameraQuaternion);
    } else {
      _tempMatrix.lookAt(_tempVector.set(0, 0, 0), _dirVector, _alignVector);
      this.quaternion.setFromRotationMatrix(_tempMatrix);
    }
    super.updateMatrixWorld(force);
  }
}
TransformControlsPlane.prototype.isTransformControlsPlane = true;
var ThreeRenderView$1 = "";
class ThreeRenderView extends EditorElement {
  afterRender() {
    window.setTimeout(() => {
      this.refresh();
    }, 100);
  }
  renderCanvas() {
    this.renderer.render(this.$context.sceneManager.scene, this.$context.sceneManager.viewportCamera);
  }
  initializeCamera(rect2) {
    const camera = new PerspectiveCamera(75, rect2.width / rect2.height, 0.1, 1e3);
    camera.position.x = 1;
    camera.position.y = 3;
    camera.position.z = 1;
    camera.lookAt(0, 0, 0);
    this.$context.sceneManager.camera = camera;
    this.$context.sceneManager.addCamera(camera);
    this.$context.sceneManager.setViewportCamera(camera.uuid);
  }
  initializeRenderer() {
    const rect2 = this.refs.$view.offsetRect();
    this.state.rect = rect2;
    this.initializeCamera(rect2);
    console.log(this.$context.sceneManager.viewportCamera);
    const renderer = new WebGLRenderer({
      canvas: this.refs.$view.el,
      antialias: true
    });
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize(rect2.width, rect2.height);
    const controls = new OrbitControls(this.$context.sceneManager.viewportCamera, this.refs.$body.el);
    controls.addEventListener("change", () => {
      this.renderCanvas();
    });
    const grid2 = new Group();
    const grid1 = new GridHelper(30, 30, 8947848, "yellow");
    grid1.material.color.setHex(8947848);
    grid1.material.vertexColors = false;
    grid2.add(grid1);
    const grid22 = new GridHelper(30, 6, 2236962, "white");
    grid22.material.color.setHex(2236962);
    grid22.material.depthFunc = AlwaysDepth;
    grid22.material.vertexColors = false;
    grid2.add(grid22);
    this.grid = grid2;
    this.$context.sceneManager.addObject(this.grid, void 0, void 0, false);
    const light2 = new DirectionalLight(16777215, 2);
    light2.position.set(1, 1, 1);
    this.$context.sceneManager.scene.add(light2);
    const box = new Box3();
    const selectionBox = new Box3Helper(box);
    selectionBox.material.depthTest = false;
    selectionBox.material.transparent = true;
    selectionBox.visible = false;
    this.$context.sceneManager.sceneHelpers.add(selectionBox);
    let objectPositionOnDown = null;
    let objectRotationOnDown = null;
    let objectScaleOnDown = null;
    const transformControls = new TransformControls(this.$context.sceneManager.viewportCamera, this.refs.$view.el);
    this.transformControls = transformControls;
    transformControls.addEventListener("change", () => {
      this.renderCanvas();
    });
    transformControls.addEventListener("mouseDown", () => {
      const object = transformControls.object;
      objectPositionOnDown = object.position.clone();
      objectRotationOnDown = object.rotation.clone();
      objectScaleOnDown = object.scale.clone();
      controls.enabled = false;
    });
    transformControls.addEventListener("mouseUp", () => {
      const object = transformControls.object;
      if (object !== void 0) {
        switch (transformControls.getMode()) {
          case "translate":
            if (!objectPositionOnDown.equals(object.position)) {
              this.emit("SetPosition", object, object.position, objectPositionOnDown);
            }
            break;
          case "rotate":
            if (!objectRotationOnDown.equals(object.rotation)) {
              this.emit("SetRotation", object, object.rotation, objectRotationOnDown);
            }
            break;
          case "scale":
            if (!objectScaleOnDown.equals(object.scale)) {
              this.emit("SetScale", object, object.scale, objectScaleOnDown);
            }
            break;
        }
      }
      controls.enabled = true;
    });
    this.$context.sceneManager.scene.add(transformControls);
    return renderer;
  }
  refresh() {
    if (!this.renderer) {
      const renderer = this.initializeRenderer();
      console.log(renderer);
      this.renderer = renderer;
    }
    const self2 = this;
    function animate(time) {
      self2.renderCanvas(time);
    }
    animate(0);
  }
  refreshCanvasSize() {
    const rect2 = this.refs.$view.offsetRect();
    this.state.rect = rect2;
    this.$context.sceneManager.viewportCamera.aspect = rect2.width / rect2.height;
    this.$context.sceneManager.viewportCamera.updateProjectionMatrix();
    this.renderer.setSize(rect2.width, rect2.height);
    this.renderCanvas(0);
  }
  [SUBSCRIBE("objectSelected")]() {
    this.transformControls.attach(this.$context.sceneManager.selected);
  }
  [SUBSCRIBE("objectAdded")]() {
    this.renderCanvas(0);
  }
  [SUBSCRIBE(RESIZE_WINDOW, RESIZE_CANVAS)]() {
    console.log("resize");
    this.refreshCanvasSize();
  }
  template() {
    return `
            <div class='elf--element-three-view' ref='$body'>
                <canvas class='canvas-view' ref='$view'></canvas>
                ${this.$injectManager.generate("render.view")}
            </div>
        `;
  }
}
class Canvas3DView extends EditorElement {
  template() {
    return /* @__PURE__ */ createElementJsx("div", {
      class: "elf--page-three-container",
      tabIndex: "-1",
      ref: "$container"
    }, /* @__PURE__ */ createElementJsx("div", {
      class: "page-view",
      ref: "$pageView"
    }, /* @__PURE__ */ createElementJsx("div", {
      class: "page-lock scrollbar",
      ref: "$lock"
    }, /* @__PURE__ */ createElementJsx(ThreeRenderView, {
      ref: "$threeRenderView"
    }), this.$injectManager.generate("canvas.view"))));
  }
}
var Body3DPanel$1 = "";
class Body3DPanel extends EditorElement {
  components() {
    return {
      Canvas3DView
    };
  }
  template() {
    return `
      <div class="elf--body-three-panel">
        <div class='editing-area'>
          <div class="canvas-layout">
            ${createComponent("Canvas3DView")}
          </div>
        </div>
      </div>
    `;
  }
  [SUBSCRIBE("bodypanel.toggle.fullscreen")]() {
    this.refs.$el.toggleFullscreen();
  }
}
class ThreeInspector extends EditorElement {
  afterRender() {
    this.$el.toggle(this.$config.is("editor.design.mode", DesignMode.DESIGN));
  }
  [BIND("$el")]() {
    return {
      style: {
        display: this.$config.is("editor.design.mode", DesignMode.DESIGN) ? "block" : "none"
      }
    };
  }
  template() {
    return /* @__PURE__ */ createElementJsx("div", {
      class: "feature-control inspector"
    }, /* @__PURE__ */ createElementJsx("div", null, /* @__PURE__ */ createElementJsx(Tabs, {
      ref: "$tab",
      selectedValue: "style",
      onchange: (value) => {
        this.$config.set("inspector.selectedValue", value);
      }
    }, /* @__PURE__ */ createElementJsx(TabPanel, {
      value: "style",
      title: this.$i18n("inspector.tab.title.design")
    }, /* @__PURE__ */ createElementJsx("div", {
      style: "display: flex; flex-direction: column;"
    }, this.$injectManager.generate("inspector.tab.style"), /* @__PURE__ */ createElementJsx("div", {
      class: "empty",
      style: "order: 1000000;"
    }))), this.$injectManager.getTargetUI("inspector.tab").map((it) => {
      const { value, title: title2, loadElements } = it.class;
      return /* @__PURE__ */ createElementJsx(TabPanel, {
        value,
        title: title2,
        icon: it.icon
      }, /* @__PURE__ */ createElementJsx("div", {
        style: "display: flex: flex-direction: column;"
      }, loadElements.map((element) => createElement(element)), this.$injectManager.generate("inspector.tab." + it.value), /* @__PURE__ */ createElementJsx("div", {
        class: "empty",
        style: "order: 1000000;"
      })));
    }))));
  }
}
var ThreeToolBar$1 = "";
var ToolbarMenuItem$1 = "";
class ToolbarMenuItem extends EditorElement {
  initialize() {
    super.initialize();
    const events = this.props.events || [];
    if (events.length) {
      events.forEach((event) => {
        this.on(event, () => this.refresh());
      });
    }
  }
  template() {
    return `
        <button type="button"  class='elf--toolbar-menu-item' >
            <span class="icon" ref="$icon"></span>
        </button>
        `;
  }
  [CLICK("$el")]() {
    if (this.props.command) {
      this.emit(this.props.command, ...this.props.args);
    } else if (this.props.action) {
      this.props.action(this.$editor);
    }
  }
  [LOAD("$icon") + DOMDIFF]() {
    return iconUse(this.props.icon);
  }
  [BIND("$el")]() {
    const selected = isFunction(this.props.selected) ? this.props.selected(this.$editor) : false;
    return {
      "data-selected": selected
    };
  }
}
class ToolBarRenderer extends EditorElement {
  components() {
    return {
      DropdownMenu,
      ToolbarMenuItem
    };
  }
  template() {
    return `<div class="toolbar-renderer"></div>`;
  }
  [LOAD("$el")]() {
    return this.props.items.map((item, index2) => {
      return this.renderMenuItem(item, index2);
    });
  }
  renderMenuItem(item, index2) {
    switch (item.type) {
      case MenuItemType.LINK:
        return this.renderLink(item, index2);
      case MenuItemType.DROPDOWN:
        return this.renderDropdown(item, index2);
      default:
        return this.renderButton(item, index2);
    }
  }
  renderButton(item, index2) {
    return createComponent("ToolbarMenuItem", {
      ref: "$button-" + index2,
      title: item.title,
      icon: item.icon,
      command: item.command,
      shortcut: item.shortcut,
      args: item.args,
      nextTick: item.nextTick,
      disabled: item.disabled,
      selected: item.selected,
      selectedKey: item.selectedKey,
      action: item.action,
      events: item.events
    });
  }
  renderDropdown(item, index2) {
    return createComponent("DropdownMenu", {
      ref: "$dropdown-" + index2,
      items: item.items,
      icon: item.icon,
      events: item.events,
      selected: item.selected,
      selectedKey: item.selectedKey,
      action: item.action,
      style: item.style,
      dy: 6
    }, [item.content]);
  }
}
class ThreeToolBar extends EditorElement {
  initState() {
    return {
      items: [
        {
          title: "menu.item.fullscreen.title",
          command: "toggle.fullscreen",
          shortcut: "ALT+/"
        },
        { title: "menu.item.shortcuts.title", command: "showShortcutWindow" },
        "-",
        { title: "menu.item.export.title", command: "showExportView" },
        { title: "menu.item.export.title", command: "showEmbedEditorWindow" },
        { title: "menu.item.download.title", command: "downloadJSON" },
        {
          title: "menu.item.save.title",
          command: "saveJSON",
          nextTick: () => {
            this.emit("notify", "alert", "Save", "Save the content on localStorage", 2e3);
          }
        },
        {
          title: "menu.item.language.title",
          items: [
            {
              title: "English",
              command: "setLocale",
              args: [Language.EN],
              checked: () => this.$editor.locale === Language.EN
            },
            {
              title: "Fran\xE7ais",
              command: "setLocale",
              args: [Language.FR],
              checked: () => this.$editor.locale === Language.FR
            },
            {
              title: "Korean",
              command: "setLocale",
              args: [Language.KO],
              checked: () => this.$editor.locale === Language.KO
            }
          ]
        },
        "-",
        {
          title: "EasyLogic Studio",
          items: [
            {
              type: "link",
              title: "Github",
              href: "https://github.com/easylogic/editor"
            },
            {
              type: "link",
              title: "Learn",
              href: "https://www.easylogic.studio"
            }
          ]
        }
      ]
    };
  }
  components() {
    return {
      ToolBarRenderer,
      ThemeChanger,
      Outline,
      ExportView,
      Download,
      Save,
      Undo,
      Redo,
      DropdownMenu
    };
  }
  template() {
    return `
            <div class='elf--tool-bar'>
                ${createComponent("ToolBarRenderer", {
      items: ToolbarMenu.left(this.$editor)
    })}
                ${createComponent("ToolBarRenderer", {
      items: ToolbarMenu.center(this.$editor)
    })}
                <div class='right'>
                    ${this.$injectManager.generate("toolbar.right")}
                    ${createComponent("ThemeChanger")}
                </div>
            </div>
        `;
  }
  [LOAD("$logo")]() {
    return `
            <div class="logo-item">           
                ${createComponent("DropdownMenu", {
      ref: "$menu",
      items: this.state.items,
      dy: 6
    }, [createElement("label", { class: "logo" })])}
            </div>                                
        `;
  }
  [CONFIG("language.locale")]() {
    this.refresh();
  }
}
var layout$1 = "";
var _DEFAULT_CAMERA = new PerspectiveCamera(3, 1, 0.01, 1e3);
_DEFAULT_CAMERA.name = "Camera";
_DEFAULT_CAMERA.position.set(0, 5, 10);
_DEFAULT_CAMERA.lookAt(new Vector3());
class SceneManager {
  constructor(editor) {
    this.editor = editor;
    this.camera = _DEFAULT_CAMERA.clone();
    this.scene = new Scene();
    this.scene.name = "Scene";
    this.sceneHelpers = new Scene();
    this.object = {};
    this.geometries = {};
    this.materials = {};
    this.textures = {};
    this.scripts = {};
    this.materialsRefCounter = /* @__PURE__ */ new Map();
    this.mixer = new AnimationMixer(this.scene);
    this.selected = null;
    this.helpers = {};
    this.cameras = {};
    this.viewportCamera = this.camera;
    this.addCamera(this.camera);
  }
  emit(event, ...args2) {
    this.editor.emit(event, ...args2);
  }
  setScene(scene) {
    this.scene.uuid = scene.uuid;
    this.scene.name = scene.name;
    this.scene.background = scene.background;
    this.scene.environment = scene.environment;
    this.scene.fog = scene.fog;
    this.scene.userData = JSON.parse(JSON.stringify(scene.userData));
    while (scene.children.length > 0) {
      this.addObject(scene.children[0], void 0, void 0, false);
    }
    this.emit("sceneChanged", this.scene);
  }
  addObject(object, parent, index2, hasEmit = true) {
    object.traverse((child) => {
      if (child.geometry !== void 0)
        this.addGeometry(child.geometry);
      if (child.material !== void 0)
        this.addMaterial(child.material);
      this.addCamera(child);
      this.addHelper(child);
    });
    if (parent === void 0) {
      this.scene.add(object);
    } else {
      parent.children.splice(index2, 0, object);
      object.parent = parent;
    }
    this.emit("objectAdded", object);
    this.emit("sceneGraphChanged");
  }
  moveObject(object, parent, before) {
    if (parent === void 0) {
      parent = this.scene;
    }
    parent.add(object);
    if (before !== void 0) {
      var index2 = parent.children.indexOf(before);
      parent.children.splice(index2, 0, object);
      parent.children.pop();
    }
    this.emit("sceneGraphChanged");
  }
  nameObject(object, name) {
    object.name = name;
    this.emit("sceneGraphChanged");
  }
  removeObject(object) {
    if (object.parent === null)
      return;
    object.traverse((child) => {
      this.removeCamera(child);
      this.removeHelper(child);
      if (child.material !== void 0)
        this.removeMaterial(child.material);
    });
    object.parent.remove(object);
    this.emit("objectRemoved", object);
    this.emit("sceneGraphChanged");
  }
  addGeometry(geometry) {
    this.geometries[geometry.uuid] = geometry;
  }
  setGeometryName(geometry, name) {
    geometry.name = name;
    this.emit("sceneGraphChanged");
  }
  addMaterial(material) {
    if (isArray(material)) {
      for (var i = 0, l = material.length; i < l; i++) {
        this.addMaterialToRefCounter(material[i]);
      }
    } else {
      this.addMaterialToRefCounter(material);
    }
    this.emit("materialAdded");
  }
  addMaterialToRefCounter(material) {
    var materialsRefCounter = this.materialsRefCounter;
    var count = materialsRefCounter.get(material);
    if (count === void 0) {
      materialsRefCounter.set(material, 1);
      this.materials[material.uuid] = material;
    } else {
      count++;
      materialsRefCounter.set(material, count);
    }
  }
  removeMaterial(material) {
    if (isArray(material)) {
      for (var i = 0, l = material.length; i < l; i++) {
        this.removeMaterialFromRefCounter(material[i]);
      }
    } else {
      this.removeMaterialFromRefCounter(material);
    }
    this.emit("materialRemoved");
  }
  removeMaterialFromRefCounter(material) {
    var materialsRefCounter = this.materialsRefCounter;
    var count = materialsRefCounter.get(material);
    count--;
    if (count === 0) {
      materialsRefCounter.delete(material);
      delete this.materials[material.uuid];
    } else {
      materialsRefCounter.set(material, count);
    }
  }
  getMaterialById(id) {
    return Object.values(this.materials).find((m) => m.id === id);
  }
  setMaterialName(material, name) {
    material.name = name;
    this.emit("sceneGraphChanged");
  }
  addTexture(texture2) {
    this.textures[texture2.uuid] = texture2;
  }
  addCamera(camera) {
    if (camera.isCamera) {
      this.cameras[camera.uuid] = camera;
      this.emit("cameraAdded", camera);
    }
  }
  removeCamera(camera) {
    if (this.cameras[camera.uuid] !== void 0) {
      delete this.cameras[camera.uuid];
      this.emit("cameraRemoved", camera);
    }
  }
  addHelper(object, helper) {
    var _a;
    var geometry = new SphereGeometry(2, 4, 2);
    var material = new MeshBasicMaterial({
      color: 16711680,
      visible: false
    });
    if (helper === void 0) {
      if (object.isCamera) {
        helper = new CameraHelper(object);
      } else if (object.isPointLight) {
        helper = new PointLightHelper(object, 1);
      } else if (object.isDirectionalLight) {
        helper = new DirectionalLightHelper(object, 1);
      } else if (object.isSpotLight) {
        helper = new SpotLightHelper(object);
      } else if (object.isHemisphereLight) {
        helper = new HemisphereLightHelper(object, 1);
      } else if (object.isSkinnedMesh) {
        helper = new SkeletonHelper(object.skeleton.bones[0]);
      } else if (object.isBone === true && ((_a = object.parent) == null ? void 0 : _a.isBone) !== true) {
        helper = new SkeletonHelper(object);
      } else {
        return;
      }
      const picker = new Mesh(geometry, material);
      picker.name = "picker";
      picker.userData.object = object;
      helper.add(picker);
    }
    this.sceneHelpers.add(helper);
    this.helpers[object.id] = helper;
    this.emit("helperAdded", helper);
  }
  removeHelper(object) {
    if (this.helpers[object.id] !== void 0) {
      var helper = this.helpers[object.id];
      helper.parent.remove(helper);
      delete this.helpers[object.id];
      this.emit("helperRemoved", helper);
    }
  }
  addScript(object, script) {
    if (this.scripts[object.uuid] === void 0) {
      this.scripts[object.uuid] = [];
    }
    this.scripts[object.uuid].push(script);
    this.emit("scriptAdded", script);
  }
  removeScript(object, script) {
    if (this.scripts[object.uuid] === void 0)
      return;
    var index2 = this.scripts[object.uuid].indexOf(script);
    if (index2 !== -1) {
      this.scripts[object.uuid].splice(index2, 1);
    }
    this.emit("scriptRemoved", script);
  }
  getObjectMaterial(object, slot) {
    var material = object.material;
    if (isArray(material) && slot !== void 0) {
      material = material[slot];
    }
    return material;
  }
  setObjectMaterial(object, slot, newMaterial) {
    if (isArray(object.material) && slot !== void 0) {
      object.material[slot] = newMaterial;
    } else {
      object.material = newMaterial;
    }
  }
  setViewportCamera(uuid2) {
    this.viewportCamera = this.cameras[uuid2];
    this.emit("viewportCameraChanged");
  }
  select(object) {
    if (this.selected === object)
      return;
    var uuid2 = null;
    if (object !== null) {
      uuid2 = object.uuid;
    }
    this.selected = object;
    this.editor.context.config.set("selected", uuid2);
    this.emit("objectSelected", object);
  }
  selectById(id) {
    if (id === this.camera.id) {
      this.select(this.camera);
      return;
    }
    this.select(this.scene.getObjectById(id));
  }
  selectByUuid(uuid2) {
    this.scene.traverse((child) => {
      if (child.uuid === uuid2) {
        this.select(child);
      }
    });
  }
  deselect() {
    this.select(null);
  }
  focus(object) {
    if (object !== void 0) {
      this.emit("objectFocused", object);
    }
  }
  focusById(id) {
    this.focus(this.scene.getObjectById(id));
  }
  clear() {
    this.camera.copy(_DEFAULT_CAMERA);
    this.emit("cameraChanged");
    this.scene.name = "Scene";
    this.scene.userData = {};
    this.scene.background = null;
    this.scene.environment = null;
    this.scene.fog = null;
    var objects = this.scene.children;
    while (objects.length > 0) {
      this.removeObject(objects[0]);
    }
    this.geometries = {};
    this.materials = {};
    this.textures = {};
    this.scripts = {};
    this.materialsRefCounter.clear();
    this.animations = {};
    this.mixer.stopAllAction();
    this.deselect();
    this.emit("editorCleared");
  }
  async fromJSON(json) {
    var loader = new ObjectLoader();
    var camera = await loader.parseAsync(json.camera);
    this.camera.copy(camera);
    this.emit("cameraResetted");
    this.scripts = json.scripts;
    this.setScene(await loader.parseAsync(json.scene));
  }
  toJSON() {
    var scene = this.scene;
    var scripts = this.scripts;
    for (var key in scripts) {
      var script = scripts[key];
      if (script.length === 0 || scene.getObjectByProperty("uuid", key) === void 0) {
        delete scripts[key];
      }
    }
    return {
      metadata: {},
      project: {
        shadows: this.editor.context.config.get("project/renderer/shadows"),
        shadowType: this.editor.context.config.get("project/renderer/shadowType"),
        vr: this.editor.context.config.get("project/vr"),
        physicallyCorrectLights: this.editor.context.config.get("project/renderer/physicallyCorrectLights"),
        toneMapping: this.editor.context.config.get("project/renderer/toneMapping"),
        toneMappingExposure: this.editor.context.config.get("project/renderer/toneMappingExposure")
      },
      camera: this.camera.toJSON(),
      scene: this.scene.toJSON(),
      scripts: this.scripts
    };
  }
  objectByUuid(uuid2) {
    return this.scene.getObjectByProperty("uuid", uuid2, true);
  }
}
const addCubeBox = {
  command: "addCubeBox",
  execute: (editor) => {
    const geometry = new BoxGeometry(1, 1, 1, 1, 1, 1);
    const material = new MeshBasicMaterial({ color: 15794160 });
    const mesh = new Mesh(geometry, material);
    mesh.name = "Box";
    mesh.position.y = 0.5;
    editor.context.sceneManager.addObject(mesh);
    editor.context.sceneManager.select(mesh);
  }
};
var __glob_0_0 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  addCubeBox
}, Symbol.toStringTag, { value: "Module" }));
var editor_config_body_event = {
  command: "change.bodyEvent",
  description: "fire when bodyEvent was set",
  execute: function(editor) {
    const $target = Dom.create(editor.context.config.get("bodyEvent").target);
    editor.context.config.init("onMouseMovepageContainer", $target);
  }
};
var __glob_0_1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": editor_config_body_event
}, Symbol.toStringTag, { value: "Module" }));
const modules = { "./command_list/addCubeBox.js": __glob_0_0, "./command_list/editor.config.body.event.js": __glob_0_1 };
const obj = {};
Object.entries(modules).forEach(([key, value]) => {
  key = key.replace("./command_list/", "").replace(".js", "");
  obj[key] = value.default;
});
var commands = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": obj
}, Symbol.toStringTag, { value: "Module" }));
function threeHelpers(editor) {
  editor.registerUI("render.view", {});
}
var threeEditorPlugins = [
  defaultConfigs,
  defaultIcons,
  defaultMessages,
  baseEditor,
  propertyEditor,
  component,
  project,
  threeHelpers,
  function(editor) {
    editor.loadCommands(commands);
  }
];
class ThreeEditor extends BaseLayout {
  getManagers() {
    return {
      sceneManager: SceneManager
    };
  }
  afterRender() {
    super.afterRender();
    this.$config.init("editor.layout.elements", this.refs);
    if (this.opt.data) {
      this.$editor.sceneManager.fromJSON(this.opt.data);
    }
  }
  components() {
    return {
      LayerTab,
      ThreeToolBar,
      ThreeInspector,
      Body3DPanel,
      PopupManager,
      KeyboardManager,
      IconManager
    };
  }
  getPlugins() {
    return threeEditorPlugins;
  }
  initState() {
    return {
      leftSize: 340,
      rightSize: 280,
      bottomSize: 0,
      lastBottomSize: 150
    };
  }
  template() {
    return `
      <div class="elf-studio three-editor">
        <div class="layout-main">
          <div class='layout-top' ref='$top'>
            ${createComponent("ThreeToolBar")}
          </div>
          <div class="layout-middle" ref='$middle'>      
            <div class="layout-body" ref='$bodyPanel'>
              ${createComponent("Body3DPanel")}
            </div>                           
            <div class='layout-left' ref='$leftPanel'>
              ${createComponent("LayerTab")}
            </div>
            <div class="layout-right" ref='$rightPanel'>
              ${createComponent("ThreeInspector")}
            </div>
            <div class='splitter' ref='$splitter'></div>            
          </div>
          ${createComponent("KeyboardManager")}
        </div>
        ${createComponent("PopupManager")}
        ${createComponent("IconManager")}
      </div>
    `;
  }
  [BIND("$el")]() {
    return {
      "data-design-mode": this.$config.get("editor.design.mode")
    };
  }
  [BIND("$splitter")]() {
    let left2 = this.state.leftSize;
    if (this.$config.false("show.left.panel")) {
      left2 = 0;
    }
    return {
      style: {
        left: left2
      }
    };
  }
  [BIND("$leftArrow")]() {
    let left2 = this.state.leftSize;
    if (this.$config.false("show.left.panel")) {
      left2 = 0;
    }
    return {
      style: {
        left: left2
      }
    };
  }
  [BIND("$leftPanel")]() {
    let left2 = `0px`;
    let width2 = this.state.leftSize;
    let bottom2 = this.state.bottomSize;
    if (this.$config.false("show.left.panel")) {
      left2 = `-${this.state.leftSize}px`;
    }
    return {
      style: { left: left2, width: width2, bottom: bottom2 }
    };
  }
  [BIND("$rightPanel")]() {
    let right2 = 0;
    let bottom2 = this.state.bottomSize;
    if (this.$config.false("show.right.panel")) {
      right2 = -this.state.rightSize;
    }
    return {
      style: {
        right: right2,
        bottom: bottom2
      }
    };
  }
  [BIND("$rightArrow")]() {
    let right2 = 6;
    let bottom2 = this.state.bottomSize;
    if (this.$config.true("show.right.panel")) {
      right2 = this.state.rightSize + 6;
    }
    return {
      style: {
        right: right2,
        bottom: bottom2
      }
    };
  }
  [BIND("$bodyPanel")]() {
    let left2 = this.state.leftSize;
    let right2 = this.state.rightSize;
    let bottom2 = this.state.bottomSize;
    if (this.$config.false("show.left.panel")) {
      left2 = 0;
    }
    if (this.$config.false("show.right.panel")) {
      right2 = 0;
    }
    return {
      style: {
        left: left2,
        right: right2,
        bottom: bottom2
      }
    };
  }
  [POINTERSTART("$splitter") + MOVE("moveSplitter") + END("moveEndSplitter")]() {
    this.minSize = this.$theme("left_size");
    this.maxSize = this.$theme("left_max_size");
    this.leftSize = Length.parse(this.refs.$splitter.css("left")).value;
    this.refs.$splitter.addClass("selected");
  }
  moveSplitter(dx) {
    this.setState({
      leftSize: Math.max(Math.min(this.leftSize + dx, this.maxSize), this.minSize)
    });
  }
  moveEndSplitter() {
    this.refs.$splitter.removeClass("selected");
  }
  refresh() {
    this.bindData("$el");
    this.bindData("$splitter");
    this.bindData("$headerPanel");
    this.bindData("$leftPanel");
    this.bindData("$rightPanel");
    this.bindData("$toggleRightButton");
    this.bindData("$toggleLeftButton");
    this.bindData("$bodyPanel");
    this.bindData("$footerPanel");
    this.emit("resizeEditor");
  }
  [CONFIG("show.left.panel")]() {
    this.refresh();
    this.nextTick(() => {
      this.emit(RESIZE_CANVAS);
    });
  }
  [CONFIG("show.right.panel")]() {
    this.refresh();
    this.nextTick(() => {
      this.emit(RESIZE_CANVAS);
    });
  }
  [CONFIG("editor.design.mode")]() {
    this.bindData("$el");
  }
  [DRAGOVER("$middle") + PREVENT]() {
  }
  [DROP("$middle") + PREVENT]() {
  }
  [SUBSCRIBE("toggle.fullscreen")]() {
    this.$el.toggleFullscreen();
  }
  [SUBSCRIBE("getLayoutElement")](callback) {
    if (isFunction(callback)) {
      callback(this.refs);
    }
  }
}
var layout = "";
var whiteboardPlugins = [
  commands$1,
  defaultConfigs,
  defaultIcons,
  defaultMessages,
  defaultItems,
  rendererHtml,
  rendererJson,
  rendererSvg,
  baseEditor,
  propertyEditor,
  color,
  gradient,
  history,
  selectionInfoView,
  selectionToolView,
  guideLineView,
  layerAppendView,
  hoverView,
  pathDrawView,
  pathEditorView,
  gradientEditorView,
  fillEditorView
];
class WhiteBoard extends BaseLayout {
  initialize() {
    super.initialize();
    this.$context.pathkit.load();
  }
  getManagers() {
    return {
      snapManager: SnapManager,
      selection: SelectionManager,
      segmentSelection: SegmentSelectionManager,
      history: HistoryManager,
      modelManager: ModelManager,
      lockManager: LockManager,
      visibleManager: VisibleManager,
      clipboard: ClipboardManager,
      pathkit: PathKitManager
    };
  }
  components() {
    return {
      BodyPanel,
      PopupManager,
      KeyboardManager,
      IconManager
    };
  }
  getPlugins() {
    return whiteboardPlugins;
  }
  template() {
    return `
      <div class="elf-studio whiteboard">
        <div class="layout-main">
          <div class="layout-middle" ref='$middle'>      
            <div class="layout-body">
              ${createComponent("BodyPanel")}
            </div>                           
          </div>
          ${createComponent("KeyboardManager")}
        </div>
        ${createComponent("PopupManager")}
        ${createComponent("IconManager")}
      </div>
    `;
  }
  afterRender() {
    super.afterRender();
    this.$config.init("editor.layout.elements", this.refs);
    this.$commands.emit("load.json", this.opt.data);
  }
  [DRAGOVER("$middle") + PREVENT]() {
  }
  [DROP("$middle") + PREVENT]() {
  }
  [SUBSCRIBE("toggle.fullscreen")]() {
    this.$el.toggleFullscreen();
  }
  [SUBSCRIBE("getLayoutElement")](callback) {
    if (isFunction(callback)) {
      callback(this.refs);
    }
  }
}
function createDesignEditor(opts) {
  return start$1(DesignEditor, opts);
}
function createThreeEditor(opts) {
  return start$1(ThreeEditor, opts);
}
function createBlankEditor(opts) {
  return start$1(BlankEditor, opts);
}
function createDataEditor(opts) {
  return start$1(DataEditor, opts);
}
function createWhiteBoard(opts) {
  return start$1(WhiteBoard, opts);
}
export { ADD_BODY_FIRST_MOUSEMOVE, ADD_BODY_MOUSEMOVE, ADD_BODY_MOUSEUP, AFTER, ALL_TRIGGER, ALT, ANIMATIONEND, ANIMATIONITERATION, ANIMATIONSTART, ARROW_DOWN, ARROW_LEFT, ARROW_RIGHT, ARROW_UP, AlignContent, AlignItems, AssetParser, BACKSPACE, BEFORE, BIND, BIND_CHECK_DEFAULT_FUNCTION, BIND_CHECK_FUNCTION, BLUR, BRACKET_LEFT, BRACKET_RIGHT, BaseProperty, BaseStore, BlendMode, BooleanOperation, BorderStyle, BoxShadowStyle, CALLBACK, CAPTURE, CHANGE, CHANGEINPUT, CHECKER, CLICK, CMYKtoRGB, COMMAND, CONFIG, CONTEXTMENU, CONTROL, CUSTOM, CanvasViewToolLevel, ClipPathType, ClipboardActionType, ClipboardType, Component, Constraints, ConstraintsDirection, D1000, DEBOUNCE, DELAY, DELETE, DOMDIFF, DOUBLECLICK, DOUBLETAB, DRAG, DRAGEND, DRAGENTER, DRAGEXIT, DRAGLEAVE, DRAGOUT, DRAGOVER, DRAGSTART, DROP, DesignMode, DirectionNumberType, DirectionType, Dom, DomDiff, END, END_GUESTURE, ENTER, EQUAL, ESCAPE, EVENT, EditingMode, Editor, EditorElement, FIRSTMOVE, FIT, FOCUS, FOCUSIN, FOCUSOUT, FRAME, FUNC_END_CHARACTER, FUNC_REGEXP, FUNC_START_CHARACTER, FlexDirection, FlexWrap, FragmentInstance, FuncType, GradientType, HSLtoHSV, HSLtoRGB, HSVtoHSL, HSVtoRGB, HUEtoRGB, IF, INPUT, IntersectEpsilonNumberType, JustifyContent, KEY, KEYDOWN, KEYMAP_KEYDOWN, KEYMAP_KEYUP, KEYPRESS, KEYUP, KEY_CODE, KeyStringMaker, LABtoRGB, LABtoXYZ, LEFT_BUTTON, LOAD, Language, Layout, Length, MAGIC_METHOD, MAGIC_METHOD_REG, META, MINUS, MOUSE$1 as MOUSE, MOUSEDOWN, MOUSEENTER, MOUSELEAVE, MOUSEMOVE, MOUSEOUT, MOUSEOVER, MOUSEUP, MOVE, MagicMethod, MenuItemType, NAME_SAPARATOR, NotifyType, OBSERVER, ON, OPEN_CONTEXT_MENU, ObjectProperty, Overflow, PARAMS, PASSIVE, PASTE, PEN, PIPE, POINTEREND, POINTERENTER, POINTERMOVE, POINTEROUT, POINTEROVER, POINTERSTART, POP_MODE_VIEW, PREVENT, PUSH_MODE_VIEW, PathGenerator, PathParser, PathSegmentType, PathStringManager, PivotRGB, PivotXyz, Point, PolygonParser, Position, RAF, REFRESH_CONTENT, REFRESH_SELECTION, REFRESH_SELECTION_TOOL, RESIZE, RESIZE_CANVAS, RESIZE_WINDOW, RGBtoCMYK, RGBtoGray, RGBtoHSL, RGBtoHSV, RGBtoLAB, RGBtoSimpleGray, RGBtoXYZ, RGBtoYCrCb, RIGHT_BUTTON, RadialGradientSizeType, RadialGradientType, ResizingMode, ReverseRGB, ReverseXyz, SAPARATOR, SCROLL, SELF, SELF_TRIGGER, SET_LOCALE, SHIFT, SHOW_COMPONENT_POPUP, SHOW_NOTIFY, SPACE, SPLITTER, START_GUESTURE, STOP, SUBMIT, SUBSCRIBE, SUBSCRIBE_ALL, SUBSCRIBE_SELF, SegmentManager, SpreadMethodType, StrokeLineCap, StrokeLineJoin, THROTTLE, TOGGLE_FULLSCREEN, TOUCH$1 as TOUCH, TOUCHEND, TOUCHMOVE, TOUCHSTART, TRANSITIONCANCEL, TRANSITIONEND, TRANSITIONRUN, TRANSITIONSTART, TargetActionType, TextAlign, TextClip, TextDecoration, TextTransform, TimingFunction, TransformValue, UIElement, UPDATE_CANVAS, UPDATE_VIEWPORT, VARIABLE_SAPARATOR, ViewModeType, VisibilityType, WHEEL, XYZtoLAB, XYZtoRGB, YCrCbtoRGB, blend, brightness, c, checkHueColor, classnames, clone$1 as clone, collectProps, combineKeyArray, contrast, contrastColor, convertMatches, convertMatchesArray, createBlankEditor, createComponent, createComponentList, createDataEditor, createDesignEditor, createElement, createElementJsx, createThreeEditor, createWhiteBoard, debounce, defaultValue, format, formatWithoutAlpha, get, getColorIndexString, getRef, getRootElementInstanceList, getVariable, gradient$1 as gradient, gray, hasVariable, hex, hsl, hue_color, ifCheck, initializeGroupVariables, interpolateRGB, interpolateRGBObject, isArray, isBoolean, isColor, isFunction, isNotString, isNotUndefined, isNotZero, isNumber, isObject, isString, isUndefined, isZero, keyEach, keyMap, keyMapJoin, makeEventChecker, makeRequestAnimationFrame, matches, mix, normalizeWheelEvent, parse, parseGradient, random$1 as random, randomByCount, randomNumber, randomRGBA, recoverVariable, registAlias, registElement, registRootElementInstance, renderRootElementInstance, renderToString, replaceElement, retriveAlias, retriveElement, reverseMatches, rgb, scale, scaleH, scaleHSV, scaleS, scaleV, spreadVariable, start$1 as start, throttle, trim, uuid$1 as uuid, uuidShort$1 as uuidShort, variable$4 as variable };
