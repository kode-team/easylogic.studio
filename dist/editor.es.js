var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj2, key, value) => key in obj2 ? __defProp(obj2, key, { enumerable: true, configurable: true, writable: true, value }) : obj2[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __accessCheck = (obj2, member, msg) => {
  if (!member.has(obj2))
    throw TypeError("Cannot " + msg);
};
var __privateGet = (obj2, member, getter) => {
  __accessCheck(obj2, member, "read from private field");
  return getter ? getter.call(obj2) : member.get(obj2);
};
var __privateAdd = (obj2, member, value) => {
  if (member.has(obj2))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj2) : member.set(obj2, value);
};
var __privateSet = (obj2, member, value, setter) => {
  __accessCheck(obj2, member, "write to private field");
  setter ? setter.call(obj2, value) : member.set(obj2, value);
  return value;
};
var __privateWrapper = (obj2, member, setter, getter) => {
  return {
    set _(value) {
      __privateSet(obj2, member, value, setter);
    },
    get _() {
      return __privateGet(obj2, member, getter);
    }
  };
};
var __privateMethod = (obj2, member, method) => {
  __accessCheck(obj2, member, "access private method");
  return method;
};
var _state, _prevState, _localTimestamp, _loadMethods, _timestamp, _cachedMethodList, _props, _propsKeys, _isServer, _propsKeyList, _refreshTimestamp, refreshTimestamp_fn, _setProps, setProps_fn, _getProp, getProp_fn, _storeInstance, _modelManager, _json, _cachedValue, _timestamp2, _lastChangedField, _collapsed, _id, _renderers;
function collectProps(root, filterFunction = () => true) {
  let p = root;
  let results = [];
  do {
    const isObject2 = p instanceof Object;
    if (isObject2 === false) {
      break;
    }
    const names2 = Object.getOwnPropertyNames(p).filter(filterFunction);
    results.push.apply(results, names2);
  } while (p = Object.getPrototypeOf(p));
  return results;
}
function debounce(callback, delay = 0) {
  if (delay === 0) {
    return callback;
  }
  var t = void 0;
  return function($1, $2, $3, $4, $5) {
    if (t) {
      window.clearTimeout(t);
    }
    t = window.setTimeout(function() {
      callback($1, $2, $3, $4, $5);
    }, delay || 300);
  };
}
function throttle(callback, delay) {
  var t = void 0;
  return function($1, $2, $3, $4, $5) {
    if (!t) {
      t = window.setTimeout(function() {
        callback($1, $2, $3, $4, $5);
        t = null;
      }, delay || 300);
    }
  };
}
function ifCheck(callback, context, checkMethods) {
  return (...args2) => {
    const ifResult = checkMethods.every((check2) => {
      return context[check2].apply(context, args2);
    });
    if (ifResult) {
      callback.apply(context, args2);
    }
  };
}
function makeRequestAnimationFrame(callback, context) {
  return (...args2) => {
    window.requestAnimationFrame(() => {
      callback.apply(context, args2);
    });
  };
}
function keyEach(obj2, callback) {
  Object.keys(obj2).forEach((key, index2) => {
    callback(key, obj2[key], index2);
  });
}
function keyMap(obj2, callback) {
  return Object.keys(obj2).map((key, index2) => {
    return callback(key, obj2[key], index2);
  });
}
function keyMapJoin(obj2, callback, joinString = "") {
  return keyMap(obj2, callback).join(joinString);
}
function get(obj2, key, callback) {
  var returnValue = defaultValue(obj2[key], key);
  if (isFunction(callback)) {
    return callback(returnValue);
  }
  return returnValue;
}
function defaultValue(value, defaultValue2) {
  return typeof value == "undefined" ? defaultValue2 : value;
}
function isUndefined(value) {
  return typeof value == "undefined";
}
function isNotUndefined(value) {
  return !isUndefined(value);
}
function isBoolean(value) {
  return typeof value == "boolean";
}
function isString(value) {
  return typeof value == "string";
}
function isNotString(value) {
  return !isString(value);
}
function isArray(value) {
  return Array.isArray(value);
}
function isObject(value) {
  return typeof value == "object" && !Array.isArray(value) && !isNumber(value) && !isString(value) && value !== null;
}
function isFunction(value) {
  return typeof value == "function";
}
function isNumber(value) {
  return typeof value == "number";
}
function isZero(num) {
  return num === 0;
}
function isNotZero(num) {
  return !isZero(num);
}
const CLONE_FUNCTION = (obj2) => JSON.parse(JSON.stringify(obj2));
function clone$1(obj2) {
  if (isUndefined(obj2))
    return void 0;
  return CLONE_FUNCTION(obj2);
}
function combineKeyArray(obj2) {
  Object.keys(obj2).forEach((key) => {
    if (Array.isArray(obj2[key])) {
      obj2[key] = obj2[key].join(", ");
    }
  });
  return obj2;
}
function classnames(...args2) {
  const result = [];
  args2.filter(Boolean).forEach((it) => {
    if (isArray(it)) {
      result.push(classnames(...it));
    } else if (isObject(it)) {
      Object.keys(it).filter((k) => Boolean(it[k])).forEach((key) => {
        result.push(key);
      });
    } else if (isString(it)) {
      result.push(it);
    }
  });
  return result.join(" ");
}
const setBooleanProp = (el, name, value) => {
  if (value) {
    el.setAttribute(name, name);
    el[name] = value;
  } else {
    el.removeAttribute(name);
    el[name] = value;
  }
};
const setProp = (el, name, value) => {
  if (typeof value === "boolean") {
    setBooleanProp(el, name, value);
  } else {
    el.setAttribute(name, value);
  }
};
const removeBooleanProp = (node, name) => {
  node.removeAttribute(name);
  node[name] = false;
};
const removeUndefinedProp = (node, name) => {
  node.removeAttribute(name);
};
const removeProp = (node, name, value) => {
  if (typeof value === "boolean") {
    removeBooleanProp(node, name);
  } else if (name) {
    removeUndefinedProp(node, name);
  }
};
const updateProp = (node, name, newValue, oldValue) => {
  if (!newValue) {
    removeProp(node, name, oldValue);
  } else if (!oldValue || newValue !== oldValue) {
    setProp(node, name, newValue);
  } else
    ;
};
const updateProps = (node, newProps = {}, oldProps = {}) => {
  const keyList2 = [];
  keyList2.push.apply(keyList2, Object.keys(newProps));
  keyList2.push.apply(keyList2, Object.keys(oldProps));
  const props = new Set(keyList2);
  props.forEach((key) => {
    updateProp(node, key, newProps[key], oldProps[key]);
  });
};
function changed(node1, node2) {
  return node1.nodeType === window.Node.TEXT_NODE && node1.textContent !== node2.textContent || node1.nodeName !== node2.nodeName;
}
function hasPassed(node1) {
  if ((node1 == null ? void 0 : node1.nodeType) === 8) {
    return true;
  }
  return node1.nodeType !== window.Node.TEXT_NODE && node1.getAttribute("data-domdiff-pass") === "true";
}
function hasRefClass(node1) {
  return node1.nodeType !== window.Node.TEXT_NODE && node1.getAttribute("refClass");
}
function getProps(attributes) {
  var results = {};
  const len2 = attributes.length;
  for (let i = 0; i < len2; i++) {
    const t = attributes[i];
    results[t.name] = t.value;
  }
  return results;
}
function checkAllHTML(newEl, oldEl) {
  return newEl.outerHTML == oldEl.outerHTML;
}
function updateElement(parentElement, oldEl, newEl, i, options2 = {}) {
  if (!oldEl) {
    parentElement.appendChild(newEl.cloneNode(true));
  } else if (!newEl) {
    parentElement.removeChild(oldEl);
  } else if (hasPassed(oldEl) || hasPassed(newEl))
    ;
  else if (checkAllHTML(newEl, oldEl)) {
    return;
  } else if (changed(newEl, oldEl) || hasRefClass(newEl)) {
    parentElement.replaceChild(newEl.cloneNode(true), oldEl);
  } else if (newEl.nodeType !== window.Node.TEXT_NODE && newEl.nodeType !== window.Node.COMMENT_NODE && newEl.toString() !== "[object HTMLUnknownElement]") {
    if (options2.checkPassed && options2.checkPassed(oldEl, newEl))
      ;
    else {
      updateProps(oldEl, getProps(newEl.attributes), getProps(oldEl.attributes));
    }
    var oldChildren = children(oldEl);
    var newChildren = children(newEl);
    var max = Math.max(oldChildren.length, newChildren.length);
    for (var index2 = 0; index2 < max; index2++) {
      updateElement(oldEl, oldChildren[index2], newChildren[index2], index2, options2);
    }
  }
}
const children = (el) => {
  var element = el.firstChild;
  if (!element) {
    return [];
  }
  var results = [];
  do {
    results.push(element);
    element = element.nextSibling;
  } while (element);
  return results;
};
function DomDiff(A, B, options2 = {}) {
  options2.checkPassed = isFunction(options2.checkPassed) ? options2.checkPassed : void 0;
  options2.removedElements = [];
  A = A.el || A;
  B = B.el || B;
  var childrenA = children(A);
  var childrenB = children(B);
  var len2 = Math.max(childrenA.length, childrenB.length);
  if (len2 === 0) {
    return;
  }
  if (childrenA.length === 0 && childrenB.length > 0) {
    A.append(...childrenB);
  } else if (childrenA.length > 0 && childrenB.length === 0) {
    A.textContent = "";
  } else {
    for (var i = 0; i < len2; i++) {
      updateElement(A, childrenA[i], childrenB[i], i, options2);
    }
  }
}
const UUID_REG$1 = /[xy]/g;
function uuid$1() {
  var dt = new Date().getTime();
  var uuid2 = "xxx12-xx-34xx".replace(UUID_REG$1, function(c2) {
    var r = (dt + Math.random() * 16) % 16 | 0;
    dt = Math.floor(dt / 16);
    return (c2 == "x" ? r : r & 3 | 8).toString(16);
  });
  return uuid2;
}
function uuidShort$1() {
  var dt = new Date().getTime();
  var uuid2 = "idxxxxxxx".replace(UUID_REG$1, function(c2) {
    var r = (dt + Math.random() * 16) % 16 | 0;
    dt = Math.floor(dt / 16);
    return (c2 == "x" ? r : r & 3 | 8).toString(16);
  });
  return uuid2;
}
const map = {};
const handlerMap = {};
const aliasMap = {};
const __rootInstance = /* @__PURE__ */ new Set();
const __tempVariables = /* @__PURE__ */ new Map();
const __tempVariablesGroup = /* @__PURE__ */ new Map();
const VARIABLE_SAPARATOR = "v:";
function variable$4(value, groupId = "") {
  const id = `${VARIABLE_SAPARATOR}${uuidShort$1()}`;
  __tempVariables.set(id, value);
  if (groupId) {
    __tempVariablesGroup.has(groupId) || __tempVariablesGroup.set(groupId, /* @__PURE__ */ new Set());
    __tempVariablesGroup.get(groupId).add(id);
  }
  return id;
}
function initializeGroupVariables(groupId) {
  if (__tempVariablesGroup.has(groupId)) {
    __tempVariablesGroup.get(groupId).forEach((id) => {
      __tempVariables.delete(id);
    });
    __tempVariablesGroup.delete(groupId);
  }
}
function recoverVariable(id, removeVariable = true) {
  if (isString(id) === false) {
    return id;
  }
  let value = id;
  if (__tempVariables.has(id)) {
    value = __tempVariables.get(id);
    if (removeVariable) {
      __tempVariables.delete(id);
    }
  }
  return value;
}
function getVariable(idOrValue) {
  if (__tempVariables.has(idOrValue)) {
    return __tempVariables.get(idOrValue);
  }
  return idOrValue;
}
function hasVariable(id) {
  return __tempVariables.has(id);
}
function spreadVariable(obj2) {
  return Object.entries(obj2).map(([key, value]) => {
    return `${key}=${variable$4(value)}`;
  }).join(" ");
}
function registElement(classes = {}) {
  Object.keys(classes).forEach((key) => {
    map[key] = classes[key];
  });
}
function replaceElement(module) {
  if (map[module.name]) {
    map[module.name] = module;
  }
}
function registAlias(a, b) {
  aliasMap[a] = b;
}
function retriveAlias(key) {
  return aliasMap[key];
}
function retriveElement(className) {
  return map[retriveAlias(className) || className];
}
function registRootElementInstance(instance) {
  __rootInstance.add(instance);
}
function getRootElementInstanceList() {
  return [...__rootInstance];
}
function renderRootElementInstance(module) {
  replaceElement(module);
  getRootElementInstanceList().forEach((instance) => {
    instance.hmr();
  });
}
function registHandler(handlers) {
  Object.keys(handlers).forEach((key) => {
    handlerMap[key] = handlers[key];
  });
}
function retriveHandler(className) {
  return handlerMap[className];
}
function createHandlerInstance(context) {
  return Object.keys(handlerMap).filter((key) => Boolean(handlerMap[key])).map((key) => {
    const HandlerClass = handlerMap[key];
    return new HandlerClass(context);
  });
}
class Dom {
  constructor(tag, className, attr) {
    if (typeof tag !== "string") {
      if (tag instanceof Dom) {
        this.el = tag.el;
      } else {
        this.el = tag;
      }
    } else {
      var el = document.createElement(tag);
      if (className) {
        el.className = className;
      }
      attr = attr || {};
      Object.assign(el, attr);
      this.el = el;
    }
  }
  static create(tag, className, attr) {
    return new Dom(tag, className, attr);
  }
  static createByHTML(htmlString) {
    var div2 = Dom.create("div");
    return div2.html(htmlString).firstChild;
  }
  static makeElementList(html) {
    const TEMP_DIV2 = Dom.create("div");
    let list2 = [];
    if (!isArray(html)) {
      html = [html];
    }
    html = html.filter(Boolean);
    for (let i = 0, len2 = html.length; i < len2; i++) {
      const item = html[i];
      if (isString(item)) {
        list2.push(...TEMP_DIV2.html(item == null ? void 0 : item.trim()).childNodes || []);
      } else if (item) {
        list2.push(Dom.create(item));
      } else
        ;
    }
    return list2;
  }
  static getScrollTop() {
    return Math.max(window.pageYOffset, document.documentElement.scrollTop, document.body.scrollTop);
  }
  static getScrollLeft() {
    return Math.max(window.pageXOffset, document.documentElement.scrollLeft, document.body.scrollLeft);
  }
  static parse(html) {
    var parser = window.DOMParser();
    return parser.parseFromString(html, "text/htmll");
  }
  static body() {
    return Dom.create(document.body);
  }
  get exists() {
    return Boolean(this.el);
  }
  setAttr(obj2) {
    Object.keys(obj2).forEach((key) => {
      this.attr(key, obj2[key]);
    });
    return this;
  }
  setAttrNS(obj2, namespace = "http://www.w3.org/2000/svg") {
    Object.keys(obj2).forEach((key) => {
      this.attr(key, obj2[key], namespace);
    });
    return this;
  }
  setProp(obj2) {
    Object.keys(obj2).forEach((key) => {
      if (this.el[key] != obj2[key]) {
        this.el[key] = obj2[key];
      }
    });
    return this;
  }
  data(key, value) {
    if (arguments.length === 1) {
      const value2 = this.attr("data-" + key);
      return recoverVariable(value2, false);
    } else if (arguments.length === 2) {
      return this.attr("data-" + key, value);
    }
    return this;
  }
  attr(...args2) {
    if (args2.length == 1) {
      return isFunction(this.el.getAttribute) && this.el.getAttribute(args2[0]);
    }
    if (this.el.getAttribute(args2[0]) != args2[1]) {
      this.el.setAttribute(args2[0], args2[1]);
    }
    return this;
  }
  attrNS(key, value, namespace = "http://www.w3.org/2000/svg") {
    if (arguments.length == 1) {
      return this.el.getAttributeNS(namespace, key);
    }
    if (this.el.getAttributeNS(namespace, key) != value) {
      this.el.setAttributeNS(namespace, key, value);
    }
    return this;
  }
  attrKeyValue(keyField) {
    return {
      [this.el.getAttribute(keyField)]: this.val()
    };
  }
  get attributes() {
    try {
      [...this.el.attributes];
      return this.el.attributes;
    } catch (e) {
      const length2 = this.el.attributes.length;
      const attributes = [];
      for (var i = 0; i < length2; i++) {
        attributes.push(this.el.attributes[`${i}`]);
      }
      return attributes;
    }
  }
  attrs(...args2) {
    return args2.map((key) => {
      return this.el.getAttribute(key);
    });
  }
  styles(...args2) {
    return args2.map((key) => {
      return this.el.style[key];
    });
  }
  removeAttr(key) {
    this.el.removeAttribute(key);
    return this;
  }
  removeStyle(key) {
    this.el.style.removeProperty(key);
    return this;
  }
  is(checkElement) {
    if (checkElement instanceof Dom) {
      return this.el === checkElement.el;
    }
    return this.el === checkElement;
  }
  isTag(tag) {
    return this.el.tagName.toLowerCase() === tag.toLowerCase();
  }
  closest(cls) {
    var temp = this;
    var checkCls = false;
    while (!(checkCls = temp.hasClass(cls))) {
      if (temp.el.parentNode) {
        temp = Dom.create(temp.el.parentNode);
      } else {
        return null;
      }
    }
    if (checkCls) {
      return temp;
    }
    return null;
  }
  path() {
    if (!this.el)
      return [];
    let pathList = [this];
    let $parentNode = this.parent();
    if (!$parentNode.el)
      return pathList;
    while ($parentNode) {
      pathList.unshift($parentNode);
      $parentNode = $parentNode.parent();
      if (!$parentNode.el)
        break;
    }
    return pathList;
  }
  get $parent() {
    return this.parent();
  }
  parent() {
    return Dom.create(this.el.parentNode);
  }
  hasParent() {
    return !!this.el.parentNode;
  }
  removeClass(...args2) {
    this.el.classList.remove(...args2);
    return this;
  }
  updateClass(className) {
    this.el.className = className;
    return this;
  }
  replaceClass(oldClass, newClass) {
    this.el.classList.replace(oldClass, newClass);
    return this;
  }
  hasClass(cls) {
    if (!this.el.classList)
      return false;
    return this.el.classList.contains(cls);
  }
  addClass(...args2) {
    this.el.classList.add(...args2);
    return this;
  }
  onlyOneClass(cls) {
    var parent = this.parent();
    parent.children().forEach((it) => {
      it.removeClass(cls);
    });
    this.addClass(cls);
  }
  toggleClass(cls, isForce) {
    this.el.classList.toggle(cls, isForce);
    return this;
  }
  outerHTML() {
    if (this.isTextNode) {
      return this.text();
    }
    return this.el.outerHTML;
  }
  html(html) {
    try {
      if (typeof html === "undefined") {
        return this.el.innerHTML;
      }
      if (typeof html === "string") {
        Object.assign(this.el, { innerHTML: html });
      } else {
        this.empty().append(html);
      }
      return this;
    } catch (e) {
      console.log(e, html);
      return this;
    }
  }
  htmlDiff(fragment) {
    DomDiff(this, fragment);
  }
  updateDiff(html, rootElement = "div", options2 = {}) {
    DomDiff(this, Dom.create(rootElement).html(html), options2);
  }
  updateSVGDiff(html, rootElement = "div") {
    DomDiff(this, Dom.create(rootElement).html(`<svg>${html}</svg>`).firstChild.firstChild);
  }
  getById(id) {
    return this.el.getElementById(id);
  }
  find(selector2) {
    if (this.isTextNode)
      return void 0;
    return this.el.querySelector(selector2);
  }
  $(selector2) {
    var node = this.find(selector2);
    return node ? Dom.create(node) : null;
  }
  findAll(selector2) {
    if (this.isTextNode)
      return [];
    return Array.from(this.el.querySelectorAll(selector2));
  }
  $$(selector2) {
    var arr = this.findAll(selector2);
    return arr.map((node) => Dom.create(node));
  }
  empty() {
    while (this.el.firstChild)
      this.el.removeChild(this.el.firstChild);
    return this;
  }
  append(el) {
    if (!el)
      return this;
    if (isArray(el)) {
      this.el.append(...el.map((it) => it.el || it));
    } else if (typeof el === "string") {
      this.el.appendChild(document.createTextNode(el));
    } else {
      this.el.appendChild(el.el || el);
    }
    return this;
  }
  prepend(el) {
    if (typeof el === "string") {
      this.el.prepend(document.createTextNode(el));
    } else {
      this.el.prepend(el.el || el);
    }
    return this;
  }
  prependHTML(html) {
    var $dom = Dom.create("div").html(html);
    this.prepend($dom.createChildrenFragment());
    return $dom;
  }
  appendHTML(html) {
    var $dom = Dom.create("div").html(html);
    this.append($dom.createChildrenFragment());
    return $dom;
  }
  createChildrenFragment() {
    const list2 = this.childNodes;
    var fragment = document.createDocumentFragment();
    list2.forEach(($el) => fragment.appendChild($el.el));
    return fragment;
  }
  appendTo(target) {
    var t = target.el ? target.el : target;
    t.appendChild(this.el);
    return this;
  }
  remove() {
    if (this.el.parentNode) {
      this.el.parentNode.removeChild(this.el);
    }
    return this;
  }
  removeChild(el) {
    this.el.removeChild(el.el || el);
    return this;
  }
  text(value) {
    if (typeof value === "undefined") {
      return this.el.textContent;
    } else {
      var tempText = value;
      if (value instanceof Dom) {
        tempText = value.text();
      }
      if (this.el.textContent !== tempText) {
        this.el.textContent = tempText;
      }
      return this;
    }
  }
  css(key, value) {
    if (typeof key !== "undefined" && typeof value !== "undefined") {
      if (key.indexOf("--") === 0 && typeof value !== "undefined") {
        this.el.style.setProperty(key, value);
      } else {
        this.el.style[key] = value;
      }
    } else if (typeof key !== "undefined") {
      if (typeof key === "string") {
        return window.getComputedStyle(this.el)[key];
      } else {
        Object.entries(key).forEach(([localKey, value2]) => {
          if (localKey.indexOf("--") === 0 && typeof value2 !== "undefined") {
            this.el.style.setProperty(localKey, value2);
          } else {
            this.el.style[localKey] = value2;
          }
        });
      }
    }
    return this;
  }
  getComputedStyle(...list2) {
    var css = window.getComputedStyle(this.el);
    var obj2 = {};
    list2.forEach((it) => {
      obj2[it] = css[it];
    });
    return obj2;
  }
  getStyleList(...list2) {
    var style = {};
    var len2 = this.el.style.length;
    for (var i = 0; i < len2; i++) {
      var key = this.el.style[i];
      style[key] = this.el.style[key];
    }
    list2.forEach((key2) => {
      style[key2] = this.css(key2);
    });
    return style;
  }
  cssText(value) {
    if (typeof value === "undefined") {
      return this.el.style.cssText;
    }
    if (value != this.el.tempCssText) {
      this.el.style.cssText = value;
      this.el.tempCssText = value;
    }
    return this;
  }
  cssArray(arr) {
    if (arr[0])
      this.el.style[arr[0]] = arr[1];
    if (arr[2])
      this.el.style[arr[2]] = arr[3];
    if (arr[4])
      this.el.style[arr[4]] = arr[5];
    if (arr[6])
      this.el.style[arr[6]] = arr[7];
    if (arr[8])
      this.el.style[arr[8]] = arr[9];
    return this;
  }
  cssFloat(key) {
    return parseFloat(this.css(key));
  }
  cssInt(key) {
    return parseInt(this.css(key));
  }
  px(key, value) {
    return this.css(key, `${value}px`);
  }
  rect() {
    return this.el.getBoundingClientRect();
  }
  bbox() {
    return this.el.getBBox();
  }
  isSVG() {
    if (!this.el._cachedIsSVG) {
      this.el._cachedIsSVG = { value: this.el.tagName.toLowerCase() === "svg" };
    }
    return this.el._cachedIsSVG.value;
  }
  offsetRect() {
    if (this.isSVG()) {
      const parentBox = this.parent().rect();
      const box = this.rect();
      return {
        x: box.x - parentBox.x,
        y: box.y - parentBox.y,
        width: box.width,
        height: box.height
      };
    }
    const el = this.el;
    return {
      x: el.offsetLeft,
      y: el.offsetTop,
      width: el.offsetWidth,
      height: el.offsetHeight
    };
  }
  offsetClientRect() {
    if (this.isSVG()) {
      const parentBox2 = this.parent().rect();
      const box2 = this.rect();
      return {
        x: box2.x - parentBox2.x,
        y: box2.y - parentBox2.y,
        width: box2.width,
        height: box2.height
      };
    }
    const parentBox = this.parent().rect();
    const box = this.rect();
    return {
      x: box.x - parentBox.x,
      y: box.y - parentBox.y,
      width: box.width,
      height: box.height
    };
  }
  offset() {
    var rect2 = this.rect();
    var scrollTop = Dom.getScrollTop();
    var scrollLeft = Dom.getScrollLeft();
    return {
      top: rect2.top + scrollTop,
      left: rect2.left + scrollLeft
    };
  }
  offsetLeft() {
    return this.offset().left;
  }
  offsetTop() {
    return this.offset().top;
  }
  position() {
    if (this.el.style.top) {
      return {
        top: parseFloat(this.css("top")),
        left: parseFloat(this.css("left"))
      };
    } else {
      return this.rect();
    }
  }
  size() {
    return [this.width(), this.height()];
  }
  width() {
    return this.el.offsetWidth || this.rect().width;
  }
  contentWidth() {
    return this.width() - this.cssFloat("padding-left") - this.cssFloat("padding-right");
  }
  height() {
    return this.el.offsetHeight || this.rect().height;
  }
  contentHeight() {
    return this.height() - this.cssFloat("padding-top") - this.cssFloat("padding-bottom");
  }
  val(value) {
    if (typeof value === "undefined") {
      return this.el.value;
    } else if (typeof value !== "undefined") {
      var tempValue = value;
      if (value instanceof Dom) {
        tempValue = value.val();
      }
      this.el.value = tempValue;
    }
    return this;
  }
  matches(selector2) {
    if (this.el) {
      if (!this.el.matches)
        return null;
      if (this.el.matches(selector2)) {
        return this;
      }
      return this.parent().matches(selector2);
    }
    return null;
  }
  get value() {
    return this.el.value;
  }
  get naturalWidth() {
    return this.el.naturalWidth;
  }
  get naturalHeight() {
    return this.el.naturalHeight;
  }
  get files() {
    return this.el.files ? [...this.el.files] : [];
  }
  get isTextNode() {
    return this.el.nodeType === 3;
  }
  realVal() {
    switch (this.el.nodeType) {
      case "INPUT":
        var type = this.attr("type");
        if (type == "checkbox" || type == "radio") {
          return this.checked();
        }
        return this.el.value;
      case "SELECT":
      case "TEXTAREA":
        return this.el.value;
    }
    return "";
  }
  int() {
    return parseInt(this.val(), 10);
  }
  float() {
    return parseFloat(this.val());
  }
  show(displayType = "block") {
    this.el.style.display = displayType != "none" ? displayType : "block";
    return this;
  }
  hide() {
    this.el.style.display = "none";
    return this;
  }
  isHide() {
    return this.el.style.display === "none";
  }
  isShow() {
    return !this.isHide();
  }
  toggle(isForce) {
    var currentHide = this.isHide();
    if (arguments.length == 1) {
      if (isForce) {
        return this.show();
      } else {
        return this.hide();
      }
    } else {
      if (currentHide) {
        return this.show();
      } else {
        return this.hide();
      }
    }
  }
  get totalLength() {
    return this.el.getTotalLength();
  }
  scrollIntoView() {
    this.el.scrollIntoView();
  }
  addScrollLeft(dt) {
    this.el.scrollLeft += dt;
    return this;
  }
  addScrollTop(dt) {
    this.el.scrollTop += dt;
    return this;
  }
  setScrollTop(scrollTop) {
    this.el.scrollTop = scrollTop;
    return this;
  }
  setScrollLeft(scrollLeft) {
    this.el.scrollLeft = scrollLeft;
    return this;
  }
  scrollTop() {
    if (this.el === document.body) {
      return Dom.getScrollTop();
    }
    return this.el.scrollTop;
  }
  scrollLeft() {
    if (this.el === document.body) {
      return Dom.getScrollLeft();
    }
    return this.el.scrollLeft;
  }
  scrollHeight() {
    return this.el.scrollHeight;
  }
  scrollWidth() {
    return this.el.scrollWidth;
  }
  on(eventName, callback, opt1, opt2) {
    this.el.addEventListener(eventName, callback, opt1, opt2);
    return this;
  }
  off(eventName, callback) {
    this.el.removeEventListener(eventName, callback);
    return this;
  }
  getElement() {
    return this.el;
  }
  createChild(tag, className = "", attrs = {}, css = {}) {
    let $element = Dom.create(tag, className, attrs);
    $element.css(css);
    this.append($element);
    return $element;
  }
  get firstChild() {
    return Dom.create(this.el.firstElementChild);
  }
  get first() {
    return Dom.create(this.el.firstChild);
  }
  children() {
    var element = this.el.firstElementChild;
    if (!element) {
      return [];
    }
    var results = [];
    do {
      results.push(Dom.create(element));
      element = element.nextElementSibling;
    } while (element);
    return results;
  }
  get childNodes() {
    const result = [];
    if (this.el.hasChildNodes()) {
      const childNodes = this.el.childNodes;
      for (let i = 0; i < childNodes.length; i++) {
        result.push(Dom.create(childNodes[i]));
      }
    }
    return result;
  }
  childLength() {
    return this.el.children.length;
  }
  replace(newElement) {
    if (this.el.parentNode) {
      this.el.parentNode.replaceChild(newElement.el || newElement, this.el);
    }
    return this;
  }
  replaceChild(oldElement, newElement) {
    this.el.replaceChild(newElement.el || newElement, oldElement.el || oldElement);
    return this;
  }
  checked(isChecked = false) {
    if (arguments.length == 0) {
      return !!this.el.checked;
    }
    this.el.checked = !!isChecked;
    return this;
  }
  click() {
    this.el.click();
    return this;
  }
  focus() {
    this.el.focus();
    return this;
  }
  select() {
    if (this.attr("contenteditable") === "true") {
      var range = document.createRange();
      range.selectNodeContents(this.el);
      var sel = window.getSelection();
      sel.removeAllRanges();
      sel.addRange(range);
    } else {
      this.el.select();
    }
    return this;
  }
  blur() {
    this.el.blur();
    return this;
  }
  context(contextType = "2d") {
    if (!this._initContext) {
      this._initContext = this.el.getContext(contextType);
    }
    return this._initContext;
  }
  resize({ width: width2, height: height2 }) {
    this._initContext = null;
    var ctx = this.context();
    var scale2 = window.devicePixelRatio || 1;
    this.px("width", +width2);
    this.px("height", +height2);
    this.el.width = width2 * scale2;
    this.el.height = height2 * scale2;
    ctx.scale(scale2, scale2);
  }
  toDataURL(type = "image/png", quality = 1) {
    return this.el.toDataURL(type, quality);
  }
  clear() {
    this.context().clearRect(0, 0, this.el.width, this.el.height);
  }
  update(callback) {
    this.clear();
    callback.call(this, this);
  }
  drawImage(img, dx = 0, dy = 0) {
    var ctx = this.context();
    var scale2 = window.devicePixelRatio || 1;
    ctx.drawImage(img, dx, dy, img.width, img.height, 0, 0, this.el.width / scale2, this.el.height / scale2);
  }
  drawOption(option = {}) {
    var ctx = this.context();
    Object.assign(ctx, option);
  }
  drawLine(x1, y1, x2, y2) {
    var ctx = this.context();
    ctx.beginPath();
    ctx.moveTo(x1, y1);
    ctx.lineTo(x2, y2);
    ctx.stroke();
    ctx.closePath();
  }
  drawPath(...path) {
    var ctx = this.context();
    ctx.beginPath();
    path.forEach((p, index2) => {
      if (index2 == 0) {
        ctx.moveTo(p[0], p[1]);
      } else {
        ctx.lineTo(p[0], p[1]);
      }
    });
    ctx.stroke();
    ctx.fill();
    ctx.closePath();
  }
  drawCircle(cx, cy, r) {
    var ctx = this.context();
    ctx.beginPath();
    ctx.arc(cx, cy, r, 0, 2 * Math.PI);
    ctx.stroke();
    ctx.fill();
  }
  drawText(x, y, text2) {
    this.context().fillText(text2, x, y);
  }
  fullscreen() {
    var element = this.el;
    if (element.requestFullscreen) {
      element.requestFullscreen();
    } else if (element.wekitRequestFullscreen) {
      element.wekitRequestFullscreen();
    }
  }
  toggleFullscreen() {
    if (this.el === document.fullscreenElement) {
      document.exitFullscreen();
    } else {
      this.fullscreen();
    }
  }
}
class BaseStore {
  constructor(editor) {
    this.id = uuidShort$1();
    this.cachedCallback = {};
    this.callbacks = {};
    this.editor = editor;
  }
  getCallbacks(event) {
    if (!this.callbacks[event]) {
      this.callbacks[event] = [];
    }
    return this.callbacks[event];
  }
  setCallbacks(event, list2 = []) {
    this.callbacks[event] = list2;
  }
  debug(...args2) {
    if (this.editor && this.editor.context.config.get("debug.mode")) {
      console.debug(...args2);
    }
  }
  on(event, originalCallback, context, debounceDelay = 0, throttleDelay = 0, enableAllTrigger = false, enableSelfTrigger = false, beforeMethods = [], frame = false) {
    var callback = originalCallback;
    if (debounceDelay > 0)
      callback = debounce(originalCallback, debounceDelay);
    else if (throttleDelay > 0)
      callback = throttle(originalCallback, throttleDelay);
    if (beforeMethods.length) {
      callback = ifCheck(callback, context, beforeMethods);
    }
    if (frame) {
      callback = makeRequestAnimationFrame(callback, context);
    }
    this.getCallbacks(event).push({
      event,
      callback,
      context,
      originalCallback,
      enableAllTrigger,
      enableSelfTrigger
    });
    return () => {
      this.off(event, originalCallback);
    };
  }
  off(event, originalCallback) {
    this.debug("off message event", event);
    if (arguments.length == 1) {
      this.setCallbacks(event);
    } else if (arguments.length == 2) {
      this.setCallbacks(event, this.getCallbacks(event).filter((f) => {
        return f.originalCallback !== originalCallback;
      }));
    }
  }
  offAll(context) {
    Object.keys(this.callbacks).forEach((event) => {
      this.setCallbacks(event, this.getCallbacks(event).filter((f) => {
        return f.context !== context;
      }));
    });
    this.debug("off all message", context.sourceName);
  }
  getCachedCallbacks(event) {
    return this.getCallbacks(event);
  }
  sendMessage(source2, event, ...args2) {
    this.sendMessageList(source2, [[event, ...args2]]);
  }
  runMessage(runnableFunction, args2) {
    const result = runnableFunction.callback.apply(runnableFunction.context, args2);
    if (isNotUndefined(result)) {
      if (result === false) {
        return;
      } else if (isFunction(result)) {
        result();
        return;
      }
    }
  }
  sendMessageList(source2, messages = []) {
    window.Promise.resolve().then(() => {
      messages.forEach(([event, ...args2]) => {
        var list2 = this.getCachedCallbacks(event);
        if (list2 && list2.length) {
          const runnableFunctions = list2.filter((f) => !f.enableSelfTrigger).filter((f) => f.enableAllTrigger || f.originalCallback.source !== source2);
          let i = runnableFunctions.length;
          while (i--) {
            const f = runnableFunctions[i];
            this.runMessage(f, args2);
          }
        } else {
          this.debug(`message event ${event} is not exist.`);
        }
      });
    });
  }
  nextSendMessage(source2, callback, ...args2) {
    window.Promise.resolve().then(() => {
      callback(...args2);
    });
  }
  triggerMessage(source2, event, ...args2) {
    window.Promise.resolve().then(() => {
      var list2 = this.getCachedCallbacks(event);
      if (list2) {
        const runnableFunctions = list2.filter((f) => f.originalCallback.source === source2);
        runnableFunctions.forEach((f) => {
          f.callback.apply(f.context, args2);
        });
      } else {
        this.debug(event, " is not valid event");
      }
    });
  }
  emit(event, ...args2) {
    if (isFunction(event)) {
      event(...args2);
    } else if (isArray(event)) {
      this.sendMessageList(this.source, event);
    } else {
      this.sendMessage(this.source, event, ...args2);
    }
  }
  nextTick(callback) {
    this.nextSendMessage(this.source, callback);
  }
  trigger(event, ...args2) {
    if (isFunction(event)) {
      event(...args2);
    } else {
      this.triggerMessage(this.source, event, ...args2);
    }
  }
}
const MAGIC_METHOD_REG = /^@magic:([a-zA-Z][a-zA-Z0-9]*)[\W]{1}(.*)*$/g;
const MAGIC_METHOD = "@magic:";
const SPLITTER = "|";
const FUNC_REGEXP = /(([\$a-z_\-]+)\([^\(\)]*\)|([a-z_\-]+))/gi;
const FUNC_START_CHARACTER = "(";
const FUNC_END_CHARACTER = ")";
const MAGICMETHOD_EXTRA = {
  KEYWORD: "keyword",
  FUNCTION: "function",
  VALUE: "value"
};
class MagicMethod {
  constructor(obj2) {
    this.context = obj2.context;
    this.originalMethod = obj2.originalMethod;
    this.method = obj2.method;
    this.args = obj2.args;
    this.pipes = obj2.pipes;
    this.keys = obj2.keys;
    this.__cache = /* @__PURE__ */ new Map();
  }
  setCache(key, value) {
    this.__cache.set(key, value);
  }
  hasCache(key) {
    return this.__cache.has(key);
  }
  getCache(key) {
    return this.__cache.get(key);
  }
  hasKeyword(keyword) {
    if (this.hasCache(keyword)) {
      return this.getCache(keyword);
    }
    let exists = false;
    this.pipes.forEach((pipe) => {
      switch (pipe.type) {
        case MAGICMETHOD_EXTRA.KEYWORD:
          if (pipe.value === keyword) {
            exists = true;
          }
          break;
      }
    });
    this.setCache(keyword, exists);
    return exists;
  }
  hasFunction(funcName) {
    if (this.hasCache(funcName)) {
      return this.getCache(funcName);
    }
    let exists = !!this.getFunction(funcName);
    this.setCache(funcName, exists);
    return exists;
  }
  getFunction(funcName) {
    return this.functions.find((pipe) => pipe.func === funcName);
  }
  getFunctionList(funcName) {
    return this.functions.filter((pipe) => pipe.func === funcName);
  }
  get originalCallback() {
    return this.context[this.originalMethod];
  }
  get keywords() {
    return this.keys[MAGICMETHOD_EXTRA.KEYWORD].map((pipe) => pipe.value);
  }
  get functions() {
    return this.keys[MAGICMETHOD_EXTRA.FUNCTION];
  }
  get values() {
    return this.keys[MAGICMETHOD_EXTRA.VALUE].map((pipe) => pipe.value);
  }
  execute(...args2) {
    return this.originalCallback.call(this.context, ...args2);
  }
  executeWithContext(context, ...args2) {
    return this.originalCallback.call(context, ...args2);
  }
  static make(str, ...args2) {
    return `${MAGIC_METHOD}${str} ${args2.join(SPLITTER)}`;
  }
  static check(str) {
    return str.match(MAGIC_METHOD_REG) !== null;
  }
  static parse(str, context = {}) {
    const matches2 = str.match(MAGIC_METHOD_REG);
    if (!matches2) {
      return void 0;
    }
    const result = matches2[0].split(MAGIC_METHOD)[1].split(SPLITTER).map((item) => item.trim());
    let [initializer, ...pipes] = result;
    const [method, ...args2] = initializer.split(" ");
    const pipeList = pipes.map((it) => {
      return this.parsePipe(it);
    }).filter((it) => it.value);
    const pipeObjects = {
      function: [],
      keyword: [],
      value: []
    };
    pipeList.forEach((pipe) => {
      if (pipe.type === "function") {
        pipeObjects.function.push(pipe);
      } else if (pipe.type === "keyword") {
        pipeObjects.keyword.push(pipe);
      } else {
        pipeObjects.value.push(pipe);
      }
    });
    return new MagicMethod({
      context,
      originalMethod: str,
      method,
      args: args2,
      pipes: pipeList,
      keys: pipeObjects
    });
  }
  static parsePipe(it) {
    const result = it.match(FUNC_REGEXP);
    if (!result) {
      return {
        type: "value",
        value: it
      };
    }
    const [value] = result;
    if (value.includes(FUNC_START_CHARACTER)) {
      const [func, rest] = value.split(FUNC_START_CHARACTER);
      const [args2] = rest.split(FUNC_END_CHARACTER);
      return {
        type: "function",
        value,
        func,
        args: args2.split(",").map((it2) => it2.trim()).filter(Boolean)
      };
    }
    return {
      type: "keyword",
      value: result[0]
    };
  }
}
const makeEventChecker = (value, split = SPLITTER) => {
  return ` ${split} ${value}`;
};
const MULTI_PREFIX = "ME@";
const PIPE = (...args2) => {
  return args2.join(SPLITTER);
};
const EVENT = (...args2) => {
  return MULTI_PREFIX + PIPE(...args2);
};
const COMMAND = EVENT;
const ON = EVENT;
const NAME_SAPARATOR = ":";
const SAPARATOR = " ";
const refManager = {};
const DOM_EVENT_MAKE = (...keys2) => {
  var key = keys2.join(NAME_SAPARATOR);
  return (...args2) => {
    const [selector2, ...result] = args2;
    return MagicMethod.make("domevent", [key, selector2].join(" "), ...result);
  };
};
const SUBSCRIBE_EVENT_MAKE = (...args2) => {
  return MagicMethod.make("subscribe", ...args2);
};
const CALLBACK_EVENT_MAKE = (...args2) => {
  return MagicMethod.make("callback", ...args2);
};
const OBSERVER_EVENT_MAKE = (...args2) => {
  return MagicMethod.make("observer", ...args2);
};
const CHECKER = (value, split = SPLITTER) => {
  return makeEventChecker(value, split);
};
const AFTER = (value, split = SPLITTER) => {
  return CHECKER(`after(${value})`, split);
};
const BEFORE = (value, split = SPLITTER) => {
  return CHECKER(`before(${value})`, split);
};
const IF = CHECKER;
const KEY = CHECKER;
const ARROW_UP = CHECKER("ArrowUp");
const ARROW_DOWN = CHECKER("ArrowDown");
const ARROW_LEFT = CHECKER("ArrowLeft");
const ARROW_RIGHT = CHECKER("ArrowRight");
const ENTER = CHECKER("Enter");
const SPACE = CHECKER("Space");
const ESCAPE = CHECKER("Escape");
const BACKSPACE = CHECKER("Backspace");
const DELETE = CHECKER("Delete");
const EQUAL = CHECKER("Equal");
const MINUS = CHECKER("Minus");
const BRACKET_RIGHT = CHECKER("BracketRight");
const BRACKET_LEFT = CHECKER("BracketLeft");
const ALT = CHECKER("isAltKey");
const SHIFT = CHECKER("isShiftKey");
const META = CHECKER("isMetaKey");
const CONTROL = CHECKER("isCtrlKey");
const MOUSE = CHECKER("hasMouse");
const TOUCH = CHECKER("hasTouch");
const PEN = CHECKER("hasPen");
const SELF = CHECKER("self");
const LEFT_BUTTON = CHECKER("isMouseLeftButton");
const RIGHT_BUTTON = CHECKER("isMouseRightButton");
const FIT = CHECKER("fit");
const PASSIVE = CHECKER("passive");
const DOMDIFF = CHECKER("domdiff");
const DEBOUNCE = (t = 100) => {
  return CHECKER(`debounce(${t})`);
};
const DELAY = (t = 300) => {
  return CHECKER(`delay(${t})`);
};
const D1000 = DEBOUNCE(1e3);
const THROTTLE = (t = 100) => {
  return CHECKER(`throttle(${t})`);
};
const ALL_TRIGGER = CHECKER("allTrigger()");
const SELF_TRIGGER = CHECKER("selfTrigger()");
const FRAME = CHECKER("frame()");
const PARAMS = (obj2) => {
  return CHECKER(`params(${variable$4(obj2)})`);
};
const CAPTURE = CHECKER("capture()");
const PREVENT = AFTER(`preventDefault`);
const STOP = AFTER(`stopPropagation`);
const SUBSCRIBE = SUBSCRIBE_EVENT_MAKE;
const SUBSCRIBE_ALL = (...args2) => SUBSCRIBE_EVENT_MAKE(...args2, ALL_TRIGGER);
const SUBSCRIBE_SELF = (...args2) => SUBSCRIBE_EVENT_MAKE(...args2, SELF_TRIGGER);
const CONFIG = (config, ...args2) => SUBSCRIBE_EVENT_MAKE(`config:${config}`, ...args2);
const CALLBACK = CALLBACK_EVENT_MAKE;
const RAF = CALLBACK("requestAnimationFrame");
const OBSERVER = OBSERVER_EVENT_MAKE;
const CUSTOM = DOM_EVENT_MAKE;
const CLICK = DOM_EVENT_MAKE("click");
const DOUBLECLICK = DOM_EVENT_MAKE("dblclick");
const MOUSEDOWN = DOM_EVENT_MAKE("mousedown");
const MOUSEUP = DOM_EVENT_MAKE("mouseup");
const MOUSEMOVE = DOM_EVENT_MAKE("mousemove");
const MOUSEOVER = DOM_EVENT_MAKE("mouseover");
const MOUSEOUT = DOM_EVENT_MAKE("mouseout");
const MOUSEENTER = DOM_EVENT_MAKE("mouseenter");
const MOUSELEAVE = DOM_EVENT_MAKE("mouseleave");
const TOUCHSTART = DOM_EVENT_MAKE("touchstart");
const TOUCHMOVE = DOM_EVENT_MAKE("touchmove");
const TOUCHEND = DOM_EVENT_MAKE("touchend");
const KEYDOWN = DOM_EVENT_MAKE("keydown");
const KEYUP = DOM_EVENT_MAKE("keyup");
const KEYPRESS = DOM_EVENT_MAKE("keypress");
const DRAG = DOM_EVENT_MAKE("drag");
const DRAGSTART = DOM_EVENT_MAKE("dragstart");
const DROP = DOM_EVENT_MAKE("drop");
const DRAGOVER = DOM_EVENT_MAKE("dragover");
const DRAGENTER = DOM_EVENT_MAKE("dragenter");
const DRAGLEAVE = DOM_EVENT_MAKE("dragleave");
const DRAGEXIT = DOM_EVENT_MAKE("dragexit");
const DRAGOUT = DOM_EVENT_MAKE("dragout");
const DRAGEND = DOM_EVENT_MAKE("dragend");
const CONTEXTMENU = DOM_EVENT_MAKE("contextmenu");
const CHANGE = DOM_EVENT_MAKE("change");
const INPUT = DOM_EVENT_MAKE("input");
const FOCUS = DOM_EVENT_MAKE("focus");
const FOCUSIN = DOM_EVENT_MAKE("focusin");
const FOCUSOUT = DOM_EVENT_MAKE("focusout");
const BLUR = DOM_EVENT_MAKE("blur");
const PASTE = DOM_EVENT_MAKE("paste");
const RESIZE = DOM_EVENT_MAKE("resize");
const SCROLL = DOM_EVENT_MAKE("scroll");
const SUBMIT = DOM_EVENT_MAKE("submit");
const POINTERSTART = (...args2) => {
  return CUSTOM("pointerdown")(...args2) + LEFT_BUTTON;
};
const POINTEROVER = CUSTOM("pointerover");
const POINTERENTER = CUSTOM("pointerenter");
const POINTEROUT = CUSTOM("pointerout");
const POINTERMOVE = CUSTOM("pointermove");
const POINTEREND = CUSTOM("pointerup");
const CHANGEINPUT = CUSTOM("change", "input");
const WHEEL = CUSTOM("wheel", "mousewheel", "DOMMouseScroll");
const ANIMATIONSTART = DOM_EVENT_MAKE("animationstart");
const ANIMATIONEND = DOM_EVENT_MAKE("animationend");
const ANIMATIONITERATION = DOM_EVENT_MAKE("animationiteration");
const TRANSITIONSTART = DOM_EVENT_MAKE("transitionstart");
const TRANSITIONEND = DOM_EVENT_MAKE("transitionend");
const TRANSITIONRUN = DOM_EVENT_MAKE("transitionrun");
const TRANSITIONCANCEL = DOM_EVENT_MAKE("transitioncancel");
const DOUBLETAB = CUSTOM("doubletab");
const LOAD = (value = "$el") => {
  return MagicMethod.make("load", value);
};
const getRef = (id) => {
  return refManager[id] || "";
};
const BIND_CHECK_FUNCTION = (field) => {
  return function() {
    return this.prevState[field] != this.state[field];
  };
};
const BIND_CHECK_DEFAULT_FUNCTION = () => {
  return true;
};
const BIND = (value = "$el") => {
  return MagicMethod.make("bind", value);
};
function normalizeWheelEvent(e) {
  let dx = e.deltaX;
  let dy = e.deltaY;
  if (dx === 0 && e.shiftKey) {
    [dy, dx] = [dx, dy];
  }
  if (e.deltaMode === window.WheelEvent.DOM_DELTA_LINE) {
    dy *= 8;
  } else if (e.deltaMode === window.WheelEvent.DOM_DELTA_PAGE) {
    dy *= 24;
  }
  return [limit(dx, 24), limit(dy, 24), 0];
}
function limit(delta, maxDelta) {
  return Math.sign(delta) * Math.min(maxDelta, Math.abs(delta));
}
var Event = {
  addDomEvent(dom, eventName, callback, useCapture = false) {
    if (dom) {
      dom.addEventListener(eventName, callback, useCapture);
    }
  },
  removeDomEvent(dom, eventName, callback) {
    if (dom) {
      dom.removeEventListener(eventName, callback);
    }
  },
  pos(e) {
    if (e.touches && e.touches[0]) {
      return e.touches[0];
    }
    return e;
  },
  posXY(e) {
    var pos = this.pos(e);
    return {
      x: pos.pageX,
      y: pos.pageY
    };
  }
};
class BaseHandler {
  constructor(context, options2 = {}) {
    this.context = context;
    this.options = options2;
  }
  initialize() {
  }
  load() {
  }
  refresh() {
  }
  render() {
  }
  getRef(id) {
    return this.context.getRef(id);
  }
  run() {
  }
  destroy() {
  }
}
const convertToPx = (key, value) => {
  if (isNumber(value)) {
    switch (key) {
      case "width":
      case "height":
      case "top":
      case "left":
      case "right":
      case "bottom":
        return value + "px";
    }
  }
  return value;
};
const applyElementAttribute = ($element, key, value, hasStyleAttribute = false) => {
  if (key === "cssText") {
    $element.cssText(value);
    return;
  } else if (key === "style") {
    if (typeof value !== "string") {
      const css = {};
      Object.entries(value).forEach(([key2, value2]) => {
        css[key2] = convertToPx(key2, value2);
      });
      if (hasStyleAttribute) {
        const styleText = Object.keys(css).map((key2) => {
          return `${key2}:${css[key2]};`;
        }).join("");
        $element.attr("style", styleText);
      } else {
        $element.css(css);
      }
    }
    return;
  } else if (key === "class") {
    if (Array.isArray(value)) {
      $element.updateClass(classnames(...value));
    } else {
      $element.updateClass(classnames(value));
    }
    return;
  } else if (key === "callback") {
    if (typeof value === "function") {
      value();
      return;
    }
  }
  if (typeof value === "undefined") {
    $element.removeAttr(key);
  } else {
    if ($element.el.nodeName === "TEXTAREA" && key === "value") {
      $element.text(value);
    } else if (key === "text" || key === "textContent") {
      $element.text(value);
    } else if (key === "innerHTML" || key === "html") {
      $element.html(value);
    } else if (key === "htmlDiff") {
      $element.updateDiff(value);
    } else if (key === "svgDiff") {
      $element.updateSVGDiff(value);
    } else if (key === "value") {
      $element.val(value);
    } else {
      $element.attr(key, value);
    }
  }
};
const FunctionMap = {};
class BindHandler extends BaseHandler {
  async initialize() {
    if (!FunctionMap[this.context.sourceName]) {
      FunctionMap[this.context.sourceName] = this.context.filterMethodes("bind");
    }
  }
  getBindMethods() {
    return FunctionMap[this.context.sourceName] || [];
  }
  async bindData(...args2) {
    const list2 = this.getBindMethods();
    if (!(list2 == null ? void 0 : list2.length))
      return;
    const bindList = list2 == null ? void 0 : list2.filter((it) => {
      if (!args2.length)
        return true;
      return args2.indexOf(it.args[0]) > -1;
    });
    await Promise.all(bindList == null ? void 0 : bindList.map(async (magicMethod) => {
      let refObject = this.getRef(`${magicMethod.keywords[0]}`);
      let refCallback = BIND_CHECK_DEFAULT_FUNCTION;
      if (typeof refObject === "string" && refObject !== "") {
        refCallback = BIND_CHECK_FUNCTION(refObject);
      } else if (typeof refObject === "function") {
        refCallback = refObject;
      }
      const elName = magicMethod.args[0];
      let $element = this.context.refs[elName];
      const isBindCheck = typeof refCallback === "function" && refCallback.call(this.context);
      if ($element && isBindCheck) {
        const results = await magicMethod.executeWithContext(this.context, ...args2);
        if (!results)
          return;
        const keys2 = Object.keys(results);
        for (var elementKeyIndex = 0, len2 = keys2.length; elementKeyIndex < len2; elementKeyIndex++) {
          const key = keys2[elementKeyIndex];
          const value = results[key];
          applyElementAttribute($element, key, value, this.context.isServer);
        }
      }
    }));
  }
  destroy() {
    this._bindMethods = void 0;
  }
}
class CallbackHandler extends BaseHandler {
  initialize() {
    var _a, _b;
    this.destroy();
    if (!this._callbacks) {
      this._callbacks = this.context.filterMethodes("callback");
    }
    if (!((_a = this._bindings) == null ? void 0 : _a.length) && ((_b = this._callbacks) == null ? void 0 : _b.length)) {
      this._callbacks.forEach((key) => this.parseCallback(key));
    }
  }
  destroy() {
    if (this.context.notEventRedefine)
      ;
    else {
      this.removeCallbackAll();
    }
  }
  getCallback(field) {
    return this.context[field];
  }
  removeCallbackAll() {
    this.getBindings().forEach((obj2) => {
      this.removeCallback(obj2);
    });
    this.initBindings();
  }
  removeCallback({ requestId }) {
    window.cancelAnimationFrame(requestId);
  }
  getBindings() {
    if (!this._bindings) {
      this.initBindings();
    }
    return this._bindings;
  }
  addBinding(obj2) {
    this.getBindings().push(obj2);
  }
  initBindings() {
    this._bindings = [];
  }
  makeCallback(callbackObject) {
    const callback = callbackObject.callback;
    const run = (time) => {
      callback(time);
      callbackObject.requestId = window.requestAnimationFrame(run);
    };
    return () => {
      callbackObject.requestId = window.requestAnimationFrame(run);
    };
  }
  addCallback(callbackObject, magicMethod) {
    const callback = this.makeCallback(callbackObject, magicMethod);
    this.addBinding(callbackObject);
    callback();
  }
  bindingCallback(magicMethod, callback) {
    var _a, _b;
    const obj2 = {
      eventName: magicMethod.args[0],
      callback
    };
    obj2.codes = [];
    obj2.checkMethodList = [];
    const debounceFunction = magicMethod.getFunction("debounce");
    const throttleFunction = magicMethod.getFunction("throttle");
    if (debounceFunction) {
      var debounceTime = +(((_a = debounceFunction.args) == null ? void 0 : _a[0]) || 0);
      obj2.callback = debounce(callback, debounceTime);
    } else if (throttleFunction) {
      var throttleTime = +(((_b = throttleFunction.args) == null ? void 0 : _b[0]) || 0);
      obj2.callback = throttle(callback, throttleTime);
    }
    magicMethod.keywords.forEach((keyword) => {
      const method = keyword;
      if (this.getCallback(method)) {
        obj2.checkMethodList.push(method);
      } else {
        obj2.codes.push(method.toLowerCase());
      }
    });
    this.addCallback(obj2, magicMethod);
  }
  parseCallback(it) {
    const context = this.context;
    var arr = it.args;
    if (arr) {
      var originalCallback = context[it.originalMethod].bind(context);
      this.bindingCallback(it, originalCallback);
    }
  }
}
const scrollBlockingEvents = {
  touchstart: true,
  touchmove: true,
  mousedown: true,
  mouseup: true,
  mousemove: true
};
const eventConverts = {
  doubletab: "touchend"
};
const customEventNames = {
  doubletab: true
};
const selfCheckMethods = {
  self(e) {
    return e && e.$dt && e.$dt.is(e.target);
  },
  isAltKey(e) {
    return e.altKey;
  },
  isCtrlKey(e) {
    return e.ctrlKey;
  },
  isShiftKey(e) {
    return e.shiftKey;
  },
  isMetaKey(e) {
    return e.metaKey || e.key == "Meta" || e.code.indexOf("Meta") > -1;
  },
  isMouseLeftButton(e) {
    return e.buttons === 1;
  },
  isMouseRightButton(e) {
    return e.buttons === 2;
  },
  hasMouse(e) {
    return e.pointerType === "mouse";
  },
  hasTouch(e) {
    return e.pointerType === "touch";
  },
  hasPen(e) {
    return e.pointerType === "pen";
  },
  preventDefault(e) {
    e.preventDefault();
    return true;
  },
  stopPropagation(e) {
    e.stopPropagation();
    return true;
  }
};
class DomEventHandler extends BaseHandler {
  initialize() {
    var _a, _b;
    this.destroy();
    if (this._domEvents && this.context.notEventRedefine) {
      return;
    }
    if (!this._domEvents || this._domEvents.length === 0 || this._bindings.length === 0) {
      this._domEvents = this.context.filterMethodes("domevent");
    }
    if (!((_a = this._bindings) == null ? void 0 : _a.length) && ((_b = this._domEvents) == null ? void 0 : _b.length)) {
      this._domEvents.forEach((it) => this.parseDomEvent(it));
    }
  }
  destroy() {
    if (this.context.notEventRedefine)
      ;
    else {
      this.removeEventAll();
    }
  }
  getCallback(field) {
    return this.context[field] || selfCheckMethods[field];
  }
  removeEventAll() {
    this.getBindings().forEach((obj2) => {
      this.removeDomEvent(obj2);
    });
    this.initBindings();
  }
  removeDomEvent({ eventName, dom, callback }) {
    Event.removeDomEvent(dom, eventName, callback);
  }
  getBindings() {
    if (!this._bindings) {
      this.initBindings();
    }
    return this._bindings;
  }
  addBinding(obj2) {
    this.getBindings().push(obj2);
  }
  initBindings() {
    this._bindings = [];
  }
  matchPath(el, selector2) {
    if (el) {
      if (el.matches(selector2)) {
        return el;
      }
      return this.matchPath(el.parentElement, selector2);
    }
    return null;
  }
  hasDelegate(e, eventObject) {
    return this.matchPath(e.target || e.srcElement, eventObject.delegate);
  }
  makeCallback(eventObject, magicMethod, callback) {
    if (eventObject.delegate) {
      return this.makeDelegateCallback(eventObject, magicMethod, callback);
    } else {
      return this.makeDefaultCallback(eventObject, magicMethod, callback);
    }
  }
  makeDefaultCallback(eventObject, magicMethod, callback) {
    return (e) => {
      var returnValue = this.runEventCallback(e, eventObject, magicMethod, callback);
      if (isNotUndefined(returnValue)) {
        return returnValue;
      }
    };
  }
  makeDelegateCallback(eventObject, magicMethod, callback) {
    return (e) => {
      const delegateTarget = this.hasDelegate(e, eventObject);
      if (delegateTarget) {
        e.$dt = Dom.create(delegateTarget);
        var returnValue = this.runEventCallback(e, eventObject, magicMethod, callback);
        if (isNotUndefined(returnValue)) {
          return returnValue;
        }
      }
    };
  }
  runEventCallback(e, eventObject, magicMethod, callback) {
    const context = this.context;
    e.xy = Event.posXY(e);
    if (eventObject.beforeMethods.length) {
      eventObject.beforeMethods.every((before) => {
        return this.getCallback(before.target).call(context, e, before.param);
      });
    }
    if (this.checkEventType(e, eventObject)) {
      var returnValue = callback(e, e.$dt, e.xy);
      if (returnValue !== false && eventObject.afterMethods.length) {
        eventObject.afterMethods.forEach((after) => {
          return this.getCallback(after.target).call(context, e, after.param);
        });
      }
      return returnValue;
    }
  }
  checkEventType(e, eventObject) {
    const context = this.context;
    var hasKeyCode = true;
    if (eventObject.codes.length) {
      hasKeyCode = (e.code ? eventObject.codes.indexOf(e.code.toLowerCase()) > -1 : false) || (e.key ? eventObject.codes.indexOf(e.key.toLowerCase()) > -1 : false);
    }
    var isAllCheck = true;
    if (eventObject.checkMethodList.length) {
      isAllCheck = eventObject.checkMethodList.every((field) => {
        var fieldValue = this.getCallback(field);
        if (isFunction(fieldValue) && fieldValue) {
          return fieldValue.call(context, e);
        } else if (isNotUndefined(fieldValue)) {
          return !!fieldValue;
        }
        return true;
      });
    }
    return hasKeyCode && isAllCheck;
  }
  getDefaultDomElement(dom) {
    const context = this.context;
    let el;
    if (dom) {
      el = context.refs[dom] || context[dom] || window[dom];
    } else {
      el = context.el || context.$el || context.$root;
    }
    if (el instanceof Dom) {
      return el.getElement();
    }
    return el;
  }
  getRealEventName(eventName) {
    return eventConverts[eventName] || eventName;
  }
  getCustomEventName(eventName) {
    return customEventNames[eventName] ? eventName : "";
  }
  getDefaultEventObject(eventName, dom, delegate, magicMethod, callback) {
    var _a, _b;
    const obj2 = {
      eventName: this.getRealEventName(eventName),
      customEventName: this.getCustomEventName(eventName),
      callback
    };
    const [, , ...delegates] = magicMethod.args;
    obj2.dom = this.getDefaultDomElement(dom);
    obj2.delegate = delegates.join(SAPARATOR);
    obj2.beforeMethods = [];
    obj2.afterMethods = [];
    obj2.codes = [];
    obj2.checkMethodList = [];
    const debounceFunction = magicMethod.getFunction("debounce");
    const throttleFunction = magicMethod.getFunction("throttle");
    if (debounceFunction) {
      var debounceTime = +(((_a = debounceFunction.args) == null ? void 0 : _a[0]) || 0);
      obj2.callback = debounce(callback, debounceTime);
    } else if (throttleFunction) {
      var throttleTime = +(((_b = throttleFunction.args) == null ? void 0 : _b[0]) || 0);
      obj2.callback = throttle(callback, throttleTime);
    }
    const afterFunctionList = magicMethod.getFunctionList("after");
    const beforeFunctionList = magicMethod.getFunctionList("before");
    if (afterFunctionList.length) {
      afterFunctionList.forEach((afterFunction) => {
        var r = afterFunction.args[0].split(" ");
        var [target, param] = r;
        obj2.afterMethods.push({
          target,
          param
        });
      });
    }
    if (beforeFunctionList.length) {
      beforeFunctionList.forEach((beforeFunction) => {
        var r = beforeFunction.args[0].split(" ");
        var [target, param] = r;
        obj2.beforeMethods.push({
          target,
          param
        });
      });
    }
    magicMethod.keywords.forEach((keyword) => {
      const method = keyword;
      if (this.getCallback(method)) {
        obj2.checkMethodList.push(method);
      } else {
        obj2.codes.push(method.toLowerCase());
      }
    });
    return obj2;
  }
  addDomEvent(eventObject, magicMethod, callback) {
    eventObject.callback = this.makeCallback(eventObject, magicMethod, callback);
    this.addBinding(eventObject);
    var options2 = false;
    if (magicMethod.hasKeyword("capture")) {
      options2 = true;
    }
    if (scrollBlockingEvents[eventObject.eventName]) {
      options2 = {
        passive: true,
        capture: options2
      };
    }
    if (eventObject.dom) {
      Event.addDomEvent(eventObject.dom, eventObject.eventName, eventObject.callback, options2);
    }
  }
  makeCustomEventCallback(eventObject, magicMethod, callback) {
    var _a;
    if (eventObject.customEventName === "doubletab") {
      var delay = 300;
      var delayFunction = magicMethod.getFunction("delay");
      if (delayFunction) {
        delay = +(((_a = delayFunction.args) == null ? void 0 : _a[0]) || 0);
      }
      return (...args2) => {
        if (!this.doubleTab) {
          this.doubleTab = {
            time: window.performance.now()
          };
        } else {
          if (window.performance.now() - this.doubleTab.time < delay) {
            callback(...args2);
          }
          this.doubleTab = null;
        }
      };
    }
    return callback;
  }
  bindingDomEvent([eventName, dom, ...delegate], magicMethod, callback) {
    let eventObject = this.getDefaultEventObject(eventName, dom, delegate, magicMethod, callback);
    eventObject.callback = this.makeCustomEventCallback(eventObject, magicMethod, eventObject.callback);
    this.addDomEvent(eventObject, magicMethod, eventObject.callback);
  }
  getEventNames(eventName) {
    let results = [];
    eventName.split(NAME_SAPARATOR).forEach((e) => {
      var arr = e.split(NAME_SAPARATOR);
      results.push.apply(results, arr);
    });
    return results;
  }
  parseDomEvent(it) {
    const context = this.context;
    var arr = it.args;
    if (arr) {
      var eventNames = this.getEventNames(arr[0]);
      var callback = context[it.originalMethod].bind(context);
      for (let i = 0, len2 = eventNames.length; i < len2; i++) {
        arr[0] = eventNames[i];
        this.bindingDomEvent(arr, it, callback);
      }
    }
  }
}
class ObserverHandler extends BaseHandler {
  initialize() {
    var _a, _b;
    this.destroy();
    if (this._observers && this.context.notEventRedefine) {
      return;
    }
    if (!this._observers || this._observers.length === 0) {
      this._observers = this.context.filterMethodes("observer");
    }
    if (!((_a = this._bindings) == null ? void 0 : _a.length) && ((_b = this._observers) == null ? void 0 : _b.length)) {
      this._observers.forEach((it) => this.parseObserver(it));
    }
  }
  destroy() {
    if (this.context.notEventRedefine)
      ;
    else {
      this.removeEventAll();
    }
  }
  removeEventAll() {
    this.getBindings().forEach((observer) => {
      this.removeDomEvent(observer);
    });
    this.initBindings();
  }
  disconnectObserver(observer) {
    observer == null ? void 0 : observer.disconnect();
  }
  getBindings() {
    if (!this._bindings) {
      this.initBindings();
    }
    return this._bindings;
  }
  addBinding(obj2) {
    this.getBindings().push(obj2);
  }
  initBindings() {
    this._bindings = [];
  }
  addObserver(observer) {
    this.addBinding(observer);
  }
  getDefaultDomElement(dom) {
    const context = this.context;
    let el;
    if (dom) {
      el = context.refs[dom] || context[dom] || window[dom];
    } else {
      el = context.el || context.$el || context.$root;
    }
    if (el instanceof Dom) {
      return el.getElement();
    }
    return el;
  }
  createObserver(magicMethod, callback) {
    var _a;
    const [observerType, observerTarget] = magicMethod.args || ["intersection"];
    const $target = this.getDefaultDomElement(observerTarget);
    const params = magicMethod.getFunction("params");
    const options2 = getVariable((_a = params == null ? void 0 : params.args) == null ? void 0 : _a[0]);
    let observer;
    switch (observerType) {
      case "intersection":
        if (options2.root) {
          options2.root = this.getDefaultDomElement(options2.root);
        }
        observer = new window.IntersectionObserver(callback, options2 || {});
        observer.observe($target);
        break;
      case "mutation":
        observer = new window.MutationObserver(callback);
        observer.observe($target, options2 || {
          attributes: true,
          characterData: true,
          childList: true
        });
        break;
      case "performance":
        observer = new window.PerformanceObserver(callback);
        observer.observe(options2 || {
          entryTypes: ["paint"]
        });
        break;
    }
    return observer;
  }
  bindingObserver(magicMethod, callback) {
    this.addObserver(this.createObserver(magicMethod, callback));
  }
  parseObserver(it) {
    const context = this.context;
    var originalCallback = context[it.originalMethod].bind(context);
    this.bindingObserver(it, originalCallback);
  }
}
class StoreHandler extends BaseHandler {
  initialize() {
    var _a, _b;
    this.destroy();
    if (!this._callbacks) {
      this._callbacks = this.context.filterMethodes("subscribe");
    }
    if (!((_a = this._bindings) == null ? void 0 : _a.length) && ((_b = this._callbacks) == null ? void 0 : _b.length)) {
      this._callbacks.forEach((key) => this.parseSubscribe(key));
    }
  }
  destroy() {
    if (this.context.notEventRedefine)
      ;
    else {
      this.context.$store.offAll(this.context);
    }
  }
  getCallback(field) {
    return this.context[field];
  }
  getBindings() {
    if (!this._bindings) {
      this.initBindings();
    }
    return this._bindings;
  }
  addBinding(obj2) {
    this.getBindings().push(obj2);
  }
  initBindings() {
    this._bindings = [];
  }
  createLocalCallback(event, callback) {
    var newCallback = callback.bind(this.context);
    newCallback.displayName = `${this.context.sourceName}.${event}`;
    newCallback.source = this.context.source;
    return newCallback;
  }
  parseSubscribe(magicMethod) {
    var _a, _b;
    const events = magicMethod.args.join(" ");
    const checkMethodList = [];
    const eventList = [];
    let debounce2 = 0;
    let throttle2 = 0;
    let isAllTrigger = false;
    let isSelfTrigger = false;
    let isFrameTrigger = false;
    const debounceFunction = magicMethod.getFunction("debounce");
    const throttleFunction = magicMethod.getFunction("throttle");
    const allTriggerFunction = magicMethod.getFunction("allTrigger");
    const selfTriggerFunction = magicMethod.getFunction("selfTrigger");
    const frameFunction = magicMethod.getFunction("frame");
    if (debounceFunction) {
      debounce2 = +(((_a = debounceFunction.args) == null ? void 0 : _a[0]) || 0);
    }
    if (throttleFunction) {
      throttle2 = +(((_b = throttleFunction.args) == null ? void 0 : _b[0]) || 0);
    }
    if (allTriggerFunction) {
      isAllTrigger = true;
    }
    if (selfTriggerFunction) {
      isSelfTrigger = true;
    }
    if (frameFunction) {
      isFrameTrigger = true;
    }
    magicMethod.keywords.forEach((keyword) => {
      const method = keyword;
      if (this.context[method]) {
        checkMethodList.push(method);
      } else {
        eventList.push(method);
      }
    });
    const originalCallback = this.context[magicMethod.originalMethod];
    [...eventList, events].filter(Boolean).forEach((e) => {
      var callback = this.createLocalCallback(e, originalCallback);
      this.context.$store.on(e, callback, this.context, debounce2, throttle2, isAllTrigger, isSelfTrigger, checkMethodList, isFrameTrigger);
    });
    this.addBinding(magicMethod);
  }
}
registHandler({
  BindHandler,
  CallbackHandler,
  DomEventHandler,
  ObserverHandler,
  StoreHandler
});
const REFERENCE_PROPERTY = "ref";
const TEMP_DIV = Dom.create("div");
const QUERY_PROPERTY = `[${REFERENCE_PROPERTY}]`;
const REF_CLASS = "refclass";
const REF_CLASS_PROPERTY = `[${REF_CLASS}]`;
const EMPTY_ARRAY = [];
const _EventMachine = class {
  constructor(opt, props) {
    __privateAdd(this, _refreshTimestamp);
    __privateAdd(this, _setProps);
    __privateAdd(this, _getProp);
    __privateAdd(this, _state, {});
    __privateAdd(this, _prevState, {});
    __privateAdd(this, _localTimestamp, 0);
    __privateAdd(this, _loadMethods, void 0);
    __privateAdd(this, _timestamp, void 0);
    __privateAdd(this, _cachedMethodList, void 0);
    __privateAdd(this, _props, {});
    __privateAdd(this, _propsKeys, {});
    __privateAdd(this, _isServer, false);
    __privateAdd(this, _propsKeyList, []);
    this.refs = {};
    this.children = {};
    this.id = uuid$1();
    this.initializeProperty(opt, props);
    this.handlers = this.initializeHandler();
    this.initComponents();
  }
  get __timestamp() {
    return __privateGet(this, _localTimestamp);
  }
  get timestamp() {
    return __privateGet(this, _timestamp);
  }
  set timestamp(value) {
    __privateSet(this, _timestamp, value);
  }
  get target() {
    return this.$el.el;
  }
  checkProps(props = {}) {
    return props;
  }
  initializeProperty(opt, props = {}) {
    this.opt = opt || {};
    this.parent = this.opt;
    this.source = uuid$1();
    this.sourceName = this.constructor.name;
    this.props = new Proxy(__privateGet(this, _props), {
      get: (target, key) => {
        return __privateMethod(this, _getProp, getProp_fn).call(this, key);
      },
      set: (target, key) => {
        throw new Error(`${key} is readonly`);
      }
    });
    __privateMethod(this, _setProps, setProps_fn).call(this, props);
  }
  hasProp(key) {
    return __privateGet(this, _propsKeyList).includes(key == null ? void 0 : key.toUpperCase());
  }
  setServer(isServer = true) {
    __privateSet(this, _isServer, isServer);
  }
  get isServer() {
    var _a;
    return ((_a = this.parent) == null ? void 0 : _a.isServer) || __privateGet(this, _isServer);
  }
  initComponents() {
    this.childComponents = this.components();
  }
  initializeHandler() {
    return createHandlerInstance(this);
  }
  initState() {
    return {};
  }
  setState(state = {}, isLoad = true) {
    __privateSet(this, _prevState, __privateGet(this, _state));
    __privateSet(this, _state, Object.assign({}, __privateGet(this, _state), state));
    if (isLoad) {
      this.load();
    }
  }
  toggleState(key, isLoad = true) {
    this.setState({
      [key]: !__privateGet(this, _state)[key]
    }, isLoad);
  }
  apply(obj2) {
    return spreadVariable(obj2);
  }
  _reload(props, $container = null) {
    if ($container) {
      this.render($container);
    }
    __privateMethod(this, _setProps, setProps_fn).call(this, props);
    __privateSet(this, _state, {});
    this.setState(this.initState(), false);
    this.refresh(true);
  }
  checkLoad($container) {
    window.requestAnimationFrame(() => {
      this.render($container);
    });
  }
  get state() {
    return __privateGet(this, _state);
  }
  get propKeys() {
    return __privateGet(this, _propsKeys);
  }
  get ref() {
    return this.props.ref;
  }
  get isPreLoaded() {
    return true;
  }
  async render($container) {
    if (!this.isPreLoaded) {
      this.checkLoad($container);
      return;
    }
    const template = this.template();
    const newDomElement = this.parseTemplate(template);
    if (this.$el) {
      this.$el.htmlDiff(newDomElement);
    } else {
      this.$el = newDomElement;
      this.refs.$el = this.$el;
      if ($container) {
        $container.append(this.$el);
      }
    }
    await this.load();
    this.afterRender();
    return this;
  }
  get html() {
    return this.$el.outerHTML();
  }
  initialize() {
    __privateSet(this, _state, this.initState());
  }
  afterRender() {
  }
  components() {
    return __spreadValues({}, this.parent.childComponents);
  }
  getRef(...args2) {
    const key = args2.join("");
    return this.refs[key];
  }
  refreshElementReference(targetRef, refName) {
    var refs = targetRef.$$(QUERY_PROPERTY);
    for (var refsIndex = 0, refsLen = refs.length; refsIndex < refsLen; refsIndex++) {
      const $dom = refs[refsIndex];
      const name = $dom.attr(REFERENCE_PROPERTY);
      if (this.refs[name]) {
        if (this.refs[name].is($dom) === false) {
          this.refs[name] = $dom;
        }
      } else {
        this.refs[name] = $dom;
      }
    }
    this.afterLoadRendering(targetRef, refName);
  }
  afterLoadRendering() {
  }
  afterComponentRendering() {
  }
  parseTemplate(html, isLoad) {
    let list2 = Dom.makeElementList(html);
    for (var i = 0, len2 = list2.length; i < len2; i++) {
      const $el = list2[i];
      var ref = $el.attr(REFERENCE_PROPERTY);
      if (ref) {
        if (!isLoad) {
          this.refs[ref] = $el;
        }
      }
      var refs = $el.$$(QUERY_PROPERTY);
      var temp = {};
      for (var refsIndex = 0, refsLen = refs.length; refsIndex < refsLen; refsIndex++) {
        const $dom = refs[refsIndex];
        const name = $dom.attr(REFERENCE_PROPERTY);
        if (temp[name]) {
          console.warn(`${ref} is duplicated. - ${this.sourceName}`, this);
        } else {
          temp[name] = true;
        }
        if (!isLoad) {
          this.refs[name] = $dom;
        }
      }
    }
    if (!isLoad) {
      return list2[0];
    }
    TEMP_DIV.append(list2);
    return TEMP_DIV.createChildrenFragment();
  }
  parsePropertyInfo($dom) {
    let props = {};
    for (var t of $dom.attributes) {
      const name = t.name || t.nodeName;
      const value = t.value || t.nodeValue;
      if (hasVariable(name)) {
        const recoveredValue = getVariable(name);
        if (isObject(recoveredValue)) {
          props = Object.assign(props, recoveredValue);
        } else {
          props[name] = getVariable(value);
        }
      } else {
        props[name] = getVariable(value);
      }
    }
    const content2 = $dom.html();
    if (content2) {
      props.content = content2;
      props.contentChildren = this.parseContent(props.content);
    }
    return props;
  }
  parseSourceName(obj2) {
    if (obj2.parent) {
      return [obj2.sourceName, ...this.parseSourceName(obj2.parent)];
    }
    return [obj2.sourceName];
  }
  getEventMachineComponent(refClassName) {
    var EventMachineComponent = retriveElement(refClassName) || this.childComponents[refClassName];
    return EventMachineComponent;
  }
  createFunctionComponent(EventMachineComponent, props, BaseClass = _EventMachine) {
    class FunctionElement extends BaseClass {
      template() {
        return EventMachineComponent.call(this, this.props);
      }
    }
    return new FunctionElement(this, props);
  }
  createInstanceForComponent(EventMachineComponent, targetElement, props) {
    if (EventMachineComponent.__proto__.name === "ProxyComponent") {
      return new EventMachineComponent({ target: targetElement, props });
    }
    if (EventMachineComponent.__proto__.name === "" && isFunction(EventMachineComponent)) {
      return this.createFunctionComponent(EventMachineComponent, props);
    }
    return new EventMachineComponent(this, props);
  }
  async renderComponent({ $dom, refName, component: component2, props }) {
    var _a;
    var instance = null;
    if (this.children[refName]) {
      instance = this.children[refName];
      instance.timestamp = this.__timestamp;
      instance._reload(props);
    } else {
      instance = this.createInstanceForComponent(component2, $dom.$parent.el, props);
      instance.timestamp = this.__timestamp;
      this.children[refName || instance.id] = instance;
      if (isFunction(instance.render)) {
        await instance.render();
      }
    }
    this.afterComponentRendering($dom, refName, instance, props);
    if (instance.renderTarget) {
      (_a = instance.$el) == null ? void 0 : _a.appendTo(instance.renderTarget);
      $dom.remove();
    } else if (instance.$el) {
      $dom.replace(instance.$el);
    } else {
      $dom.remove();
    }
  }
  parseContent(html, filteredRefClass = []) {
    return Dom.create("div").html(html).children().map(($dom) => {
      return this._getComponentInfo($dom);
    }).filter((it) => filteredRefClass.length === 0 ? true : filteredRefClass.includes(it.refClass));
  }
  _getComponentInfo($dom) {
    const refClass = $dom.attr(REF_CLASS);
    const EventMachineComponent = this.getEventMachineComponent(refClass);
    if (EventMachineComponent) {
      let props = this.parsePropertyInfo($dom);
      let refName = $dom.attr(REFERENCE_PROPERTY);
      return {
        $dom,
        refClass,
        props,
        refName: refName || props.ref,
        component: EventMachineComponent
      };
    } else {
      return {
        refClass,
        notUsed: true,
        $dom
      };
    }
  }
  getComponentInfoList($el) {
    if (!$el)
      return EMPTY_ARRAY;
    let targets = $el.$$(REF_CLASS_PROPERTY).filter((it) => {
      return it.path().filter((a) => {
        return a.attr(REF_CLASS);
      }).length === 1;
    });
    if (!targets.length) {
      return EMPTY_ARRAY;
    }
    return targets.map(($dom) => this._getComponentInfo($dom));
  }
  async parseComponent() {
    const $el = this.$el;
    const componentList = this.getComponentInfoList($el);
    if (!componentList.length)
      return;
    await Promise.all(componentList.map(async (comp) => {
      if (comp.notUsed) {
        comp.$dom.remove();
        console.warn(`${comp.refClass} is not used.`);
      } else {
        await this.renderComponent(comp);
      }
    }));
    keyEach(this.children, (key, child) => {
      if (child.timestamp !== this.__timestamp) {
        child.clean();
      }
    });
  }
  clean() {
    if (this.$el && !this.$el.hasParent()) {
      keyEach(this.children, (key, child) => {
        if (isFunction(child == null ? void 0 : child.clean)) {
          child.clean();
        }
      });
      this.destroy();
      return true;
    }
  }
  refresh() {
    this.load();
  }
  async _afterLoad() {
    __privateMethod(this, _refreshTimestamp, refreshTimestamp_fn).call(this);
    this.runHandlers("initialize");
    await this.bindData();
    await this.parseComponent();
  }
  async makeLoadAction(magicMethod) {
    const [elName, ...args2] = magicMethod.args;
    let isDomDiff = magicMethod.hasKeyword("domdiff");
    const refTarget = this.refs[elName];
    if (refTarget) {
      const newTemplate = await magicMethod.execute(...args2);
      const fragment = this.parseTemplate(newTemplate, true);
      if (isDomDiff) {
        refTarget.htmlDiff(fragment);
      } else {
        refTarget.html(fragment);
      }
      this.refreshElementReference(refTarget, elName);
    }
  }
  async load(...args2) {
    if (!__privateGet(this, _loadMethods)) {
      __privateSet(this, _loadMethods, this.filterMethodes("load"));
    }
    const filtedLoadMethodList = __privateGet(this, _loadMethods).filter((it) => args2.length === 0 ? true : it.args[0] === args2[0]);
    await Promise.all(filtedLoadMethodList.map(async (magicMethod) => {
      await this.makeLoadAction(magicMethod);
    }));
    await this._afterLoad();
  }
  async runHandlers(func = "run", ...args2) {
    await Promise.all(this.handlers.filter((h) => h[func]).map(async (h) => {
      await h[func](...args2);
    }));
  }
  async bindData(...args2) {
    await this.runHandlers("bindData", ...args2);
  }
  template() {
    return null;
  }
  eachChildren(callback) {
    if (!isFunction(callback))
      return;
    Object.keys(this.children).forEach((key) => {
      callback(this.children[key]);
    });
  }
  hmr() {
    this.created();
    this.initialize();
    this.rerender();
    this.eachChildren((child) => {
      child.hmr();
    });
  }
  rerender() {
    var $parent = this.$el.parent();
    this.destroy();
    this.render($parent);
  }
  destroy() {
    this.eachChildren((childComponent) => {
      childComponent.destroy();
    });
    this.runHandlers("destroy");
    if (this.$el) {
      this.$el.remove();
    }
    this.$el = null;
    this.refs = {};
    this.children = {};
  }
  collectMethodes(refreshCache = false) {
    if (!__privateGet(this, _cachedMethodList) || refreshCache) {
      __privateSet(this, _cachedMethodList, collectProps(this, (name) => MagicMethod.check(name)).map((it) => {
        return MagicMethod.parse(it, this);
      }));
    }
    return __privateGet(this, _cachedMethodList);
  }
  filterMethodes(methodKey, refreshCache = false) {
    return this.collectMethodes(refreshCache).filter((it) => {
      return it.method === methodKey;
    });
  }
  findChildren(BaseComponent) {
    return this.props.contentChildren.filter((it) => it.component === BaseComponent);
  }
  findChildByRef(ref) {
    const result = [];
    Object.keys(this.children).forEach((key) => {
      const child = this.children[key];
      if (child.ref === ref) {
        result.push(child);
      }
      if (Object.keys(child.children).length) {
        result.push(...child.findChildByRef(ref));
      }
    });
    return result;
  }
  findRef(callback) {
    const result = [];
    Object.keys(this.children).forEach((key) => {
      const child = this.children[key];
      if (callback(child)) {
        result.push(child);
      }
      if (result.length)
        return result;
      if (child.children) {
        result.push(...child.findNestedChildren(callback));
      }
      if (result.length)
        return result;
    });
    return result;
  }
  getChildContent(filterCallback, defaultValue2 = "") {
    var _a;
    return ((_a = this.getChild(filterCallback)) == null ? void 0 : _a.props.content) || defaultValue2;
  }
  getChild(filterCallback) {
    return this.props.contentChildren.find(filterCallback);
  }
};
let EventMachine = _EventMachine;
_state = new WeakMap();
_prevState = new WeakMap();
_localTimestamp = new WeakMap();
_loadMethods = new WeakMap();
_timestamp = new WeakMap();
_cachedMethodList = new WeakMap();
_props = new WeakMap();
_propsKeys = new WeakMap();
_isServer = new WeakMap();
_propsKeyList = new WeakMap();
_refreshTimestamp = new WeakSet();
refreshTimestamp_fn = function() {
  __privateWrapper(this, _localTimestamp)._++;
};
_setProps = new WeakSet();
setProps_fn = function(props) {
  __privateSet(this, _props, this.checkProps(props));
  __privateSet(this, _propsKeys, {});
  Object.keys(props).forEach((key) => {
    __privateGet(this, _propsKeys)[key.toUpperCase()] = key;
  });
  __privateSet(this, _propsKeyList, Object.keys(__privateGet(this, _propsKeys)));
};
_getProp = new WeakSet();
getProp_fn = function(key) {
  return __privateGet(this, _props)[__privateGet(this, _propsKeys)[key.toUpperCase()]];
};
const _UIElement = class extends EventMachine {
  constructor(opt, props = {}) {
    super(opt, props);
    __privateAdd(this, _storeInstance, void 0);
    if (props.store) {
      __privateSet(this, _storeInstance, props.store);
    } else {
      __privateSet(this, _storeInstance, new BaseStore());
    }
    this.created();
    this.initialize();
  }
  currentContext() {
    return this.contexts[this.contexts.length - 1];
  }
  setStore(storeInstance) {
    __privateSet(this, _storeInstance, storeInstance);
  }
  get $store() {
    return __privateGet(this, _storeInstance) || this.parent.$store;
  }
  async created() {
  }
  createLocalCallback(event, callback) {
    var newCallback = callback.bind(this);
    newCallback.displayName = `${this.sourceName}.${event}`;
    newCallback.source = this.source;
    return newCallback;
  }
  emit(messageName, ...args2) {
    this.$store.source = this.source;
    this.$store.sourceContext = this;
    this.$store.emit(messageName, ...args2);
  }
  nextTick(callback, delay = 0) {
    window.setTimeout(() => {
      this.$store.nextTick(callback);
    }, delay);
  }
  trigger(messageName, ...args2) {
    this.$store.source = this.source;
    this.$store.trigger(messageName, ...args2);
  }
  broadcast(messageName, ...args2) {
    Object.keys(this.children).forEach((key) => {
      this.children[key].trigger(messageName, ...args2);
      this.children[key].broadcast(messageName, ...args2);
    });
  }
  on(message, callback, debounceDelay = 0, throttleDelay = 0, enableAllTrigger = false, enableSelfTrigger = false, frame = false) {
    this.$store.on(message, callback, this.source, debounceDelay, throttleDelay, enableAllTrigger, enableSelfTrigger, [], frame);
  }
  off(message, callback) {
    this.$store.off(message, callback, this.source);
  }
  subscribe(callback, debounceSecond = 0, throttleSecond = 0) {
    const id = `subscribe.${uuidShort$1()}`;
    const newCallback = this.createLocalCallback(id, callback);
    this.$store.on(id, newCallback, this, debounceSecond, throttleSecond, false, true);
    return id;
  }
  createFunctionComponent(EventMachineComponent, props, baseClass = _UIElement) {
    return super.createFunctionComponent(EventMachineComponent, props, baseClass);
  }
  static createElementInstance(ElementClass, props) {
    if (ElementClass.__proto__.name === "") {
      class FunctionElement extends _UIElement {
        template() {
          return ElementClass.call(this, this.props);
        }
      }
      return new FunctionElement(props, props);
    } else {
      return new ElementClass(props, props);
    }
  }
};
let UIElement = _UIElement;
_storeInstance = new WeakMap();
const start$1 = (ElementClass, opt) => {
  const $container = Dom.create(opt.container || document.body);
  const app = UIElement.createElementInstance(ElementClass, opt);
  app.render($container);
  registRootElementInstance(app);
  return app;
};
async function renderToString(ElementClass, opt) {
  const app = UIElement.createElementInstance(ElementClass, opt);
  app.setServer(true);
  const instance = await app.render();
  return instance.html;
}
function CSS_TO_STRING$1(style, postfix = "") {
  var newStyle = style || {};
  return Object.keys(newStyle).filter((key) => isNotUndefined(newStyle[key])).map((key) => `${key}: ${newStyle[key]}`).join(";" + postfix);
}
function OBJECT_TO_PROPERTY$1(obj2) {
  const target = obj2 || {};
  return Object.keys(target).map((key) => {
    if (key === "class") {
      if (isObject(obj2[key])) {
        return `${key}="${classnames(obj2[key])}"`;
      }
    }
    if (key === "style") {
      if (isObject(obj2[key])) {
        return `${key}="${CSS_TO_STRING$1(obj2[key])}"`;
      }
    }
    if (isBoolean(obj2[key]) || isUndefined(obj2[key]) || obj2[key] === "undefined") {
      if (obj2[key]) {
        return key;
      } else {
        return "";
      }
    }
    return `${key}="${obj2[key]}"`;
  }).join(" ");
}
function createComponent(ComponentName, props = {}, children2 = []) {
  children2 = children2.flat(Infinity).join("");
  let targetVariable;
  targetVariable = Object.keys(props).length ? variable$4(props) : "";
  const ref = props.ref ? `ref="${props.ref}"` : "";
  return `<object refClass="${ComponentName}" ${ref} ${targetVariable}>${children2}</object>`;
}
function createComponentList(...args2) {
  return args2.map((it) => {
    let ComponentName;
    let props = {};
    let children2 = [];
    if (isString(it)) {
      ComponentName = it;
    } else if (isArray(it)) {
      [ComponentName, props = {}, children2 = []] = it;
    }
    if (children2.length) {
      return createComponent(ComponentName, props, createComponentList(children2));
    }
    return createComponent(ComponentName, props);
  }).join("\n");
}
function createElement(Component2, props, children2 = []) {
  children2 = children2.flat(Infinity);
  return `<${Component2} ${OBJECT_TO_PROPERTY$1(props)}>${children2.join(" ")}</${Component2}>`;
}
function createElementJsx(Component2, props = {}, ...children2) {
  children2 = children2.flat(Infinity);
  if (Component2 === FragmentInstance) {
    return children2;
  }
  props = props || {};
  if (typeof Component2 !== "string") {
    const ComponentName = Component2.name;
    registElement({
      [ComponentName]: Component2
    });
    return createComponent(ComponentName, props, children2);
  } else {
    return createElement(Component2, props, children2);
  }
}
const FragmentInstance = new Object();
var index = "";
var BlankBodyPanel$1 = "";
var EPSILON = 1e-6;
var ARRAY_TYPE = typeof Float32Array !== "undefined" ? Float32Array : Array;
if (!Math.hypot)
  Math.hypot = function() {
    var y = 0, i = arguments.length;
    while (i--) {
      y += arguments[i] * arguments[i];
    }
    return Math.sqrt(y);
  };
function create$5() {
  var out = new ARRAY_TYPE(9);
  if (ARRAY_TYPE != Float32Array) {
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
  }
  out[0] = 1;
  out[4] = 1;
  out[8] = 1;
  return out;
}
function multiply$2(out, a, b) {
  var a00 = a[0], a01 = a[1], a02 = a[2];
  var a10 = a[3], a11 = a[4], a12 = a[5];
  var a20 = a[6], a21 = a[7], a22 = a[8];
  var b00 = b[0], b01 = b[1], b02 = b[2];
  var b10 = b[3], b11 = b[4], b12 = b[5];
  var b20 = b[6], b21 = b[7], b22 = b[8];
  out[0] = b00 * a00 + b01 * a10 + b02 * a20;
  out[1] = b00 * a01 + b01 * a11 + b02 * a21;
  out[2] = b00 * a02 + b01 * a12 + b02 * a22;
  out[3] = b10 * a00 + b11 * a10 + b12 * a20;
  out[4] = b10 * a01 + b11 * a11 + b12 * a21;
  out[5] = b10 * a02 + b11 * a12 + b12 * a22;
  out[6] = b20 * a00 + b21 * a10 + b22 * a20;
  out[7] = b20 * a01 + b21 * a11 + b22 * a21;
  out[8] = b20 * a02 + b21 * a12 + b22 * a22;
  return out;
}
function fromTranslation$1(out, v) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 1;
  out[5] = 0;
  out[6] = v[0];
  out[7] = v[1];
  out[8] = 1;
  return out;
}
function fromRotation$1(out, rad) {
  var s = Math.sin(rad), c2 = Math.cos(rad);
  out[0] = c2;
  out[1] = s;
  out[2] = 0;
  out[3] = -s;
  out[4] = c2;
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  out[8] = 1;
  return out;
}
function fromScaling$1(out, v) {
  out[0] = v[0];
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = v[1];
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  out[8] = 1;
  return out;
}
function create$4() {
  var out = new ARRAY_TYPE(16);
  if (ARRAY_TYPE != Float32Array) {
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
  }
  out[0] = 1;
  out[5] = 1;
  out[10] = 1;
  out[15] = 1;
  return out;
}
function fromValues$1(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
  var out = new ARRAY_TYPE(16);
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m03;
  out[4] = m10;
  out[5] = m11;
  out[6] = m12;
  out[7] = m13;
  out[8] = m20;
  out[9] = m21;
  out[10] = m22;
  out[11] = m23;
  out[12] = m30;
  out[13] = m31;
  out[14] = m32;
  out[15] = m33;
  return out;
}
function identity$3(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
function transpose(out, a) {
  if (out === a) {
    var a01 = a[1], a02 = a[2], a03 = a[3];
    var a12 = a[6], a13 = a[7];
    var a23 = a[11];
    out[1] = a[4];
    out[2] = a[8];
    out[3] = a[12];
    out[4] = a01;
    out[6] = a[9];
    out[7] = a[13];
    out[8] = a02;
    out[9] = a12;
    out[11] = a[14];
    out[12] = a03;
    out[13] = a13;
    out[14] = a23;
  } else {
    out[0] = a[0];
    out[1] = a[4];
    out[2] = a[8];
    out[3] = a[12];
    out[4] = a[1];
    out[5] = a[5];
    out[6] = a[9];
    out[7] = a[13];
    out[8] = a[2];
    out[9] = a[6];
    out[10] = a[10];
    out[11] = a[14];
    out[12] = a[3];
    out[13] = a[7];
    out[14] = a[11];
    out[15] = a[15];
  }
  return out;
}
function invert(out, a) {
  var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
  var a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
  var a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
  var a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];
  var b00 = a00 * a11 - a01 * a10;
  var b01 = a00 * a12 - a02 * a10;
  var b02 = a00 * a13 - a03 * a10;
  var b03 = a01 * a12 - a02 * a11;
  var b04 = a01 * a13 - a03 * a11;
  var b05 = a02 * a13 - a03 * a12;
  var b06 = a20 * a31 - a21 * a30;
  var b07 = a20 * a32 - a22 * a30;
  var b08 = a20 * a33 - a23 * a30;
  var b09 = a21 * a32 - a22 * a31;
  var b10 = a21 * a33 - a23 * a31;
  var b11 = a22 * a33 - a23 * a32;
  var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
  if (!det) {
    return null;
  }
  det = 1 / det;
  out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
  out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
  out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
  out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
  out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
  out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
  out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
  out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
  out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
  out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
  out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
  out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
  out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
  out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
  out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
  out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;
  return out;
}
function multiply$1(out, a, b) {
  var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
  var a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
  var a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
  var a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];
  var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
  out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  b0 = b[4];
  b1 = b[5];
  b2 = b[6];
  b3 = b[7];
  out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  b0 = b[8];
  b1 = b[9];
  b2 = b[10];
  b3 = b[11];
  out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  b0 = b[12];
  b1 = b[13];
  b2 = b[14];
  b3 = b[15];
  out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  return out;
}
function translate(out, a, v) {
  var x = v[0], y = v[1], z = v[2];
  var a00, a01, a02, a03;
  var a10, a11, a12, a13;
  var a20, a21, a22, a23;
  if (a === out) {
    out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
    out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
    out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
    out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
  } else {
    a00 = a[0];
    a01 = a[1];
    a02 = a[2];
    a03 = a[3];
    a10 = a[4];
    a11 = a[5];
    a12 = a[6];
    a13 = a[7];
    a20 = a[8];
    a21 = a[9];
    a22 = a[10];
    a23 = a[11];
    out[0] = a00;
    out[1] = a01;
    out[2] = a02;
    out[3] = a03;
    out[4] = a10;
    out[5] = a11;
    out[6] = a12;
    out[7] = a13;
    out[8] = a20;
    out[9] = a21;
    out[10] = a22;
    out[11] = a23;
    out[12] = a00 * x + a10 * y + a20 * z + a[12];
    out[13] = a01 * x + a11 * y + a21 * z + a[13];
    out[14] = a02 * x + a12 * y + a22 * z + a[14];
    out[15] = a03 * x + a13 * y + a23 * z + a[15];
  }
  return out;
}
function scale$1(out, a, v) {
  var x = v[0], y = v[1], z = v[2];
  out[0] = a[0] * x;
  out[1] = a[1] * x;
  out[2] = a[2] * x;
  out[3] = a[3] * x;
  out[4] = a[4] * y;
  out[5] = a[5] * y;
  out[6] = a[6] * y;
  out[7] = a[7] * y;
  out[8] = a[8] * z;
  out[9] = a[9] * z;
  out[10] = a[10] * z;
  out[11] = a[11] * z;
  out[12] = a[12];
  out[13] = a[13];
  out[14] = a[14];
  out[15] = a[15];
  return out;
}
function rotate$1(out, a, rad, axis) {
  var x = axis[0], y = axis[1], z = axis[2];
  var len2 = Math.hypot(x, y, z);
  var s, c2, t;
  var a00, a01, a02, a03;
  var a10, a11, a12, a13;
  var a20, a21, a22, a23;
  var b00, b01, b02;
  var b10, b11, b12;
  var b20, b21, b22;
  if (len2 < EPSILON) {
    return null;
  }
  len2 = 1 / len2;
  x *= len2;
  y *= len2;
  z *= len2;
  s = Math.sin(rad);
  c2 = Math.cos(rad);
  t = 1 - c2;
  a00 = a[0];
  a01 = a[1];
  a02 = a[2];
  a03 = a[3];
  a10 = a[4];
  a11 = a[5];
  a12 = a[6];
  a13 = a[7];
  a20 = a[8];
  a21 = a[9];
  a22 = a[10];
  a23 = a[11];
  b00 = x * x * t + c2;
  b01 = y * x * t + z * s;
  b02 = z * x * t - y * s;
  b10 = x * y * t - z * s;
  b11 = y * y * t + c2;
  b12 = z * y * t + x * s;
  b20 = x * z * t + y * s;
  b21 = y * z * t - x * s;
  b22 = z * z * t + c2;
  out[0] = a00 * b00 + a10 * b01 + a20 * b02;
  out[1] = a01 * b00 + a11 * b01 + a21 * b02;
  out[2] = a02 * b00 + a12 * b01 + a22 * b02;
  out[3] = a03 * b00 + a13 * b01 + a23 * b02;
  out[4] = a00 * b10 + a10 * b11 + a20 * b12;
  out[5] = a01 * b10 + a11 * b11 + a21 * b12;
  out[6] = a02 * b10 + a12 * b11 + a22 * b12;
  out[7] = a03 * b10 + a13 * b11 + a23 * b12;
  out[8] = a00 * b20 + a10 * b21 + a20 * b22;
  out[9] = a01 * b20 + a11 * b21 + a21 * b22;
  out[10] = a02 * b20 + a12 * b21 + a22 * b22;
  out[11] = a03 * b20 + a13 * b21 + a23 * b22;
  if (a !== out) {
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  }
  return out;
}
function rotateX(out, a, rad) {
  var s = Math.sin(rad);
  var c2 = Math.cos(rad);
  var a10 = a[4];
  var a11 = a[5];
  var a12 = a[6];
  var a13 = a[7];
  var a20 = a[8];
  var a21 = a[9];
  var a22 = a[10];
  var a23 = a[11];
  if (a !== out) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  }
  out[4] = a10 * c2 + a20 * s;
  out[5] = a11 * c2 + a21 * s;
  out[6] = a12 * c2 + a22 * s;
  out[7] = a13 * c2 + a23 * s;
  out[8] = a20 * c2 - a10 * s;
  out[9] = a21 * c2 - a11 * s;
  out[10] = a22 * c2 - a12 * s;
  out[11] = a23 * c2 - a13 * s;
  return out;
}
function rotateY(out, a, rad) {
  var s = Math.sin(rad);
  var c2 = Math.cos(rad);
  var a00 = a[0];
  var a01 = a[1];
  var a02 = a[2];
  var a03 = a[3];
  var a20 = a[8];
  var a21 = a[9];
  var a22 = a[10];
  var a23 = a[11];
  if (a !== out) {
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  }
  out[0] = a00 * c2 - a20 * s;
  out[1] = a01 * c2 - a21 * s;
  out[2] = a02 * c2 - a22 * s;
  out[3] = a03 * c2 - a23 * s;
  out[8] = a00 * s + a20 * c2;
  out[9] = a01 * s + a21 * c2;
  out[10] = a02 * s + a22 * c2;
  out[11] = a03 * s + a23 * c2;
  return out;
}
function rotateZ(out, a, rad) {
  var s = Math.sin(rad);
  var c2 = Math.cos(rad);
  var a00 = a[0];
  var a01 = a[1];
  var a02 = a[2];
  var a03 = a[3];
  var a10 = a[4];
  var a11 = a[5];
  var a12 = a[6];
  var a13 = a[7];
  if (a !== out) {
    out[8] = a[8];
    out[9] = a[9];
    out[10] = a[10];
    out[11] = a[11];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  }
  out[0] = a00 * c2 + a10 * s;
  out[1] = a01 * c2 + a11 * s;
  out[2] = a02 * c2 + a12 * s;
  out[3] = a03 * c2 + a13 * s;
  out[4] = a10 * c2 - a00 * s;
  out[5] = a11 * c2 - a01 * s;
  out[6] = a12 * c2 - a02 * s;
  out[7] = a13 * c2 - a03 * s;
  return out;
}
function fromTranslation(out, v) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = v[0];
  out[13] = v[1];
  out[14] = v[2];
  out[15] = 1;
  return out;
}
function fromScaling(out, v) {
  out[0] = v[0];
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = v[1];
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = v[2];
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
function fromRotation(out, rad, axis) {
  var x = axis[0], y = axis[1], z = axis[2];
  var len2 = Math.hypot(x, y, z);
  var s, c2, t;
  if (len2 < EPSILON) {
    return null;
  }
  len2 = 1 / len2;
  x *= len2;
  y *= len2;
  z *= len2;
  s = Math.sin(rad);
  c2 = Math.cos(rad);
  t = 1 - c2;
  out[0] = x * x * t + c2;
  out[1] = y * x * t + z * s;
  out[2] = z * x * t - y * s;
  out[3] = 0;
  out[4] = x * y * t - z * s;
  out[5] = y * y * t + c2;
  out[6] = z * y * t + x * s;
  out[7] = 0;
  out[8] = x * z * t + y * s;
  out[9] = y * z * t - x * s;
  out[10] = z * z * t + c2;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
function fromZRotation(out, rad) {
  var s = Math.sin(rad);
  var c2 = Math.cos(rad);
  out[0] = c2;
  out[1] = s;
  out[2] = 0;
  out[3] = 0;
  out[4] = -s;
  out[5] = c2;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
function getTranslation(out, mat) {
  out[0] = mat[12];
  out[1] = mat[13];
  out[2] = mat[14];
  return out;
}
function getScaling(out, mat) {
  var m11 = mat[0];
  var m12 = mat[1];
  var m13 = mat[2];
  var m21 = mat[4];
  var m22 = mat[5];
  var m23 = mat[6];
  var m31 = mat[8];
  var m32 = mat[9];
  var m33 = mat[10];
  out[0] = Math.hypot(m11, m12, m13);
  out[1] = Math.hypot(m21, m22, m23);
  out[2] = Math.hypot(m31, m32, m33);
  return out;
}
function getRotation(out, mat) {
  var scaling = new ARRAY_TYPE(3);
  getScaling(scaling, mat);
  var is1 = 1 / scaling[0];
  var is2 = 1 / scaling[1];
  var is3 = 1 / scaling[2];
  var sm11 = mat[0] * is1;
  var sm12 = mat[1] * is2;
  var sm13 = mat[2] * is3;
  var sm21 = mat[4] * is1;
  var sm22 = mat[5] * is2;
  var sm23 = mat[6] * is3;
  var sm31 = mat[8] * is1;
  var sm32 = mat[9] * is2;
  var sm33 = mat[10] * is3;
  var trace = sm11 + sm22 + sm33;
  var S = 0;
  if (trace > 0) {
    S = Math.sqrt(trace + 1) * 2;
    out[3] = 0.25 * S;
    out[0] = (sm23 - sm32) / S;
    out[1] = (sm31 - sm13) / S;
    out[2] = (sm12 - sm21) / S;
  } else if (sm11 > sm22 && sm11 > sm33) {
    S = Math.sqrt(1 + sm11 - sm22 - sm33) * 2;
    out[3] = (sm23 - sm32) / S;
    out[0] = 0.25 * S;
    out[1] = (sm12 + sm21) / S;
    out[2] = (sm31 + sm13) / S;
  } else if (sm22 > sm33) {
    S = Math.sqrt(1 + sm22 - sm11 - sm33) * 2;
    out[3] = (sm31 - sm13) / S;
    out[0] = (sm12 + sm21) / S;
    out[1] = 0.25 * S;
    out[2] = (sm23 + sm32) / S;
  } else {
    S = Math.sqrt(1 + sm33 - sm11 - sm22) * 2;
    out[3] = (sm12 - sm21) / S;
    out[0] = (sm31 + sm13) / S;
    out[1] = (sm23 + sm32) / S;
    out[2] = 0.25 * S;
  }
  return out;
}
function perspectiveNO(out, fovy, aspect, near, far) {
  var f = 1 / Math.tan(fovy / 2), nf;
  out[0] = f / aspect;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = f;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[15] = 0;
  if (far != null && far !== Infinity) {
    nf = 1 / (near - far);
    out[10] = (far + near) * nf;
    out[14] = 2 * far * near * nf;
  } else {
    out[10] = -1;
    out[14] = -2 * near;
  }
  return out;
}
var perspective = perspectiveNO;
function create$3() {
  var out = new ARRAY_TYPE(3);
  if (ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
  }
  return out;
}
function clone(a) {
  var out = new ARRAY_TYPE(3);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  return out;
}
function length(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  return Math.hypot(x, y, z);
}
function fromValues(x, y, z) {
  var out = new ARRAY_TYPE(3);
  out[0] = x;
  out[1] = y;
  out[2] = z;
  return out;
}
function add$1(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  return out;
}
function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  return out;
}
function multiply(out, a, b) {
  out[0] = a[0] * b[0];
  out[1] = a[1] * b[1];
  out[2] = a[2] * b[2];
  return out;
}
function divide(out, a, b) {
  out[0] = a[0] / b[0];
  out[1] = a[1] / b[1];
  out[2] = a[2] / b[2];
  return out;
}
function floor(out, a) {
  out[0] = Math.floor(a[0]);
  out[1] = Math.floor(a[1]);
  out[2] = Math.floor(a[2]);
  return out;
}
function round$2(out, a) {
  out[0] = Math.round(a[0]);
  out[1] = Math.round(a[1]);
  out[2] = Math.round(a[2]);
  return out;
}
function distance$1(a, b) {
  var x = b[0] - a[0];
  var y = b[1] - a[1];
  var z = b[2] - a[2];
  return Math.hypot(x, y, z);
}
function negate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  out[2] = -a[2];
  return out;
}
function normalize$3(out, a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  var len2 = x * x + y * y + z * z;
  if (len2 > 0) {
    len2 = 1 / Math.sqrt(len2);
  }
  out[0] = a[0] * len2;
  out[1] = a[1] * len2;
  out[2] = a[2] * len2;
  return out;
}
function dot$1(a, b) {
  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
}
function cross(out, a, b) {
  var ax = a[0], ay = a[1], az = a[2];
  var bx = b[0], by = b[1], bz = b[2];
  out[0] = ay * bz - az * by;
  out[1] = az * bx - ax * bz;
  out[2] = ax * by - ay * bx;
  return out;
}
function lerp(out, a, b, t) {
  var ax = a[0];
  var ay = a[1];
  var az = a[2];
  out[0] = ax + t * (b[0] - ax);
  out[1] = ay + t * (b[1] - ay);
  out[2] = az + t * (b[2] - az);
  return out;
}
function transformMat4(out, a, m) {
  var x = a[0], y = a[1], z = a[2];
  var w = m[3] * x + m[7] * y + m[11] * z + m[15];
  w = w || 1;
  out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;
  out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;
  out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;
  return out;
}
function equals$1(a, b) {
  var a0 = a[0], a1 = a[1], a2 = a[2];
  var b0 = b[0], b1 = b[1], b2 = b[2];
  return Math.abs(a0 - b0) <= EPSILON * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= EPSILON * Math.max(1, Math.abs(a2), Math.abs(b2));
}
var div$1 = divide;
var dist = distance$1;
var len = length;
(function() {
  var vec = create$3();
  return function(a, stride, offset, count, fn, arg) {
    var i, l;
    if (!stride) {
      stride = 3;
    }
    if (!offset) {
      offset = 0;
    }
    if (count) {
      l = Math.min(count * stride + offset, a.length);
    } else {
      l = a.length;
    }
    for (i = offset; i < l; i += stride) {
      vec[0] = a[i];
      vec[1] = a[i + 1];
      vec[2] = a[i + 2];
      fn(vec, vec, arg);
      a[i] = vec[0];
      a[i + 1] = vec[1];
      a[i + 2] = vec[2];
    }
    return a;
  };
})();
function create$2() {
  var out = new ARRAY_TYPE(4);
  if (ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
  }
  return out;
}
function normalize$2(out, a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  var w = a[3];
  var len2 = x * x + y * y + z * z + w * w;
  if (len2 > 0) {
    len2 = 1 / Math.sqrt(len2);
  }
  out[0] = x * len2;
  out[1] = y * len2;
  out[2] = z * len2;
  out[3] = w * len2;
  return out;
}
(function() {
  var vec = create$2();
  return function(a, stride, offset, count, fn, arg) {
    var i, l;
    if (!stride) {
      stride = 4;
    }
    if (!offset) {
      offset = 0;
    }
    if (count) {
      l = Math.min(count * stride + offset, a.length);
    } else {
      l = a.length;
    }
    for (i = offset; i < l; i += stride) {
      vec[0] = a[i];
      vec[1] = a[i + 1];
      vec[2] = a[i + 2];
      vec[3] = a[i + 3];
      fn(vec, vec, arg);
      a[i] = vec[0];
      a[i + 1] = vec[1];
      a[i + 2] = vec[2];
      a[i + 3] = vec[3];
    }
    return a;
  };
})();
function create$1() {
  var out = new ARRAY_TYPE(4);
  if (ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
  }
  out[3] = 1;
  return out;
}
function setAxisAngle(out, axis, rad) {
  rad = rad * 0.5;
  var s = Math.sin(rad);
  out[0] = s * axis[0];
  out[1] = s * axis[1];
  out[2] = s * axis[2];
  out[3] = Math.cos(rad);
  return out;
}
function getAxisAngle(out_axis, q) {
  var rad = Math.acos(q[3]) * 2;
  var s = Math.sin(rad / 2);
  if (s > EPSILON) {
    out_axis[0] = q[0] / s;
    out_axis[1] = q[1] / s;
    out_axis[2] = q[2] / s;
  } else {
    out_axis[0] = 1;
    out_axis[1] = 0;
    out_axis[2] = 0;
  }
  return rad;
}
function slerp(out, a, b, t) {
  var ax = a[0], ay = a[1], az = a[2], aw = a[3];
  var bx = b[0], by = b[1], bz = b[2], bw = b[3];
  var omega, cosom, sinom, scale0, scale1;
  cosom = ax * bx + ay * by + az * bz + aw * bw;
  if (cosom < 0) {
    cosom = -cosom;
    bx = -bx;
    by = -by;
    bz = -bz;
    bw = -bw;
  }
  if (1 - cosom > EPSILON) {
    omega = Math.acos(cosom);
    sinom = Math.sin(omega);
    scale0 = Math.sin((1 - t) * omega) / sinom;
    scale1 = Math.sin(t * omega) / sinom;
  } else {
    scale0 = 1 - t;
    scale1 = t;
  }
  out[0] = scale0 * ax + scale1 * bx;
  out[1] = scale0 * ay + scale1 * by;
  out[2] = scale0 * az + scale1 * bz;
  out[3] = scale0 * aw + scale1 * bw;
  return out;
}
function fromMat3(out, m) {
  var fTrace = m[0] + m[4] + m[8];
  var fRoot;
  if (fTrace > 0) {
    fRoot = Math.sqrt(fTrace + 1);
    out[3] = 0.5 * fRoot;
    fRoot = 0.5 / fRoot;
    out[0] = (m[5] - m[7]) * fRoot;
    out[1] = (m[6] - m[2]) * fRoot;
    out[2] = (m[1] - m[3]) * fRoot;
  } else {
    var i = 0;
    if (m[4] > m[0])
      i = 1;
    if (m[8] > m[i * 3 + i])
      i = 2;
    var j = (i + 1) % 3;
    var k = (i + 2) % 3;
    fRoot = Math.sqrt(m[i * 3 + i] - m[j * 3 + j] - m[k * 3 + k] + 1);
    out[i] = 0.5 * fRoot;
    fRoot = 0.5 / fRoot;
    out[3] = (m[j * 3 + k] - m[k * 3 + j]) * fRoot;
    out[j] = (m[j * 3 + i] + m[i * 3 + j]) * fRoot;
    out[k] = (m[k * 3 + i] + m[i * 3 + k]) * fRoot;
  }
  return out;
}
function fromEuler(out, x, y, z) {
  var halfToRad = 0.5 * Math.PI / 180;
  x *= halfToRad;
  y *= halfToRad;
  z *= halfToRad;
  var sx = Math.sin(x);
  var cx = Math.cos(x);
  var sy = Math.sin(y);
  var cy = Math.cos(y);
  var sz = Math.sin(z);
  var cz = Math.cos(z);
  out[0] = sx * cy * cz - cx * sy * sz;
  out[1] = cx * sy * cz + sx * cy * sz;
  out[2] = cx * cy * sz - sx * sy * cz;
  out[3] = cx * cy * cz + sx * sy * sz;
  return out;
}
var normalize$1 = normalize$2;
(function() {
  var tmpvec3 = create$3();
  var xUnitVec3 = fromValues(1, 0, 0);
  var yUnitVec3 = fromValues(0, 1, 0);
  return function(out, a, b) {
    var dot2 = dot$1(a, b);
    if (dot2 < -0.999999) {
      cross(tmpvec3, xUnitVec3, a);
      if (len(tmpvec3) < 1e-6)
        cross(tmpvec3, yUnitVec3, a);
      normalize$3(tmpvec3, tmpvec3);
      setAxisAngle(out, tmpvec3, Math.PI);
      return out;
    } else if (dot2 > 0.999999) {
      out[0] = 0;
      out[1] = 0;
      out[2] = 0;
      out[3] = 1;
      return out;
    } else {
      cross(tmpvec3, a, b);
      out[0] = tmpvec3[0];
      out[1] = tmpvec3[1];
      out[2] = tmpvec3[2];
      out[3] = 1 + dot2;
      return normalize$1(out, out);
    }
  };
})();
(function() {
  var temp1 = create$1();
  var temp2 = create$1();
  return function(out, a, b, c2, d, t) {
    slerp(temp1, a, d, t);
    slerp(temp2, b, c2, t);
    slerp(out, temp1, temp2, 2 * t * (1 - t));
    return out;
  };
})();
(function() {
  var matr = create$5();
  return function(out, view, right2, up) {
    matr[0] = right2[0];
    matr[3] = right2[1];
    matr[6] = right2[2];
    matr[1] = up[0];
    matr[4] = up[1];
    matr[7] = up[2];
    matr[2] = -view[0];
    matr[5] = -view[1];
    matr[8] = -view[2];
    return normalize$1(out, fromMat3(out, matr));
  };
})();
function create() {
  var out = new ARRAY_TYPE(2);
  if (ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
  }
  return out;
}
function distance(a, b) {
  var x = b[0] - a[0], y = b[1] - a[1];
  return Math.hypot(x, y);
}
function equals(a, b) {
  var a0 = a[0], a1 = a[1];
  var b0 = b[0], b1 = b[1];
  return Math.abs(a0 - b0) <= EPSILON * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1, Math.abs(a1), Math.abs(b1));
}
(function() {
  var vec = create();
  return function(a, stride, offset, count, fn, arg) {
    var i, l;
    if (!stride) {
      stride = 2;
    }
    if (!offset) {
      offset = 0;
    }
    if (count) {
      l = Math.min(count * stride + offset, a.length);
    } else {
      l = a.length;
    }
    for (i = offset; i < l; i += stride) {
      vec[0] = a[i];
      vec[1] = a[i + 1];
      fn(vec, vec, arg);
      a[i] = vec[0];
      a[i + 1] = vec[1];
    }
    return a;
  };
})();
var CanvasView$2 = "";
const Language = {
  EN: "en_US",
  FR: "fr_FR",
  KO: "ko_KR"
};
const EditingMode = {
  SELECT: "select",
  APPEND: "append",
  DRAW: "draw",
  PATH: "path",
  HAND: "hand"
};
const DesignMode = {
  EDIT: "edit",
  PREVIEW: "preview",
  DESIGN: "design",
  ITEM: "item"
};
const CanvasViewToolLevel = {
  DRAG_AREA: 0,
  RENDERING_AREA: 256,
  SELECTION_TOOL: 512,
  LAYOUT_TOOL: 768
};
const NotifyType = {
  ERROR: "error",
  INFO: "info",
  SUCCESS: "success",
  WARNING: "warning",
  ALERT: "alert"
};
const IntersectEpsilonNumberType = {
  RECT: 30
};
const ClipboardType = {
  TEXT: "text",
  IMAGE: "image",
  SVG: "svg",
  HTML: "html",
  JSON: "json"
};
const ClipboardActionType = {
  COPY: "copy",
  CUT: "cut"
};
const MenuItemType = {
  BUTTON: "button",
  LINK: "link",
  SEPARATOR: "separator",
  CHECKBOX: "checkbox",
  RADIO: "radio",
  SUBMENU: "submenu",
  DROPDOWN: "dropdown",
  CUSTOM: "custom"
};
const ViewModeType = {
  CanvasView: "CanvasView",
  PathEditorView: "PathEditorView"
};
const ADD_BODY_FIRST_MOUSEMOVE = "add/body/first/mousemove";
const ADD_BODY_MOUSEMOVE = "add/body/mousemove";
const ADD_BODY_MOUSEUP = "add/body/mouseup";
const FIRSTMOVE = (method = "move") => {
  return AFTER(`bodyMouseFirstMove ${method}`);
};
const MOVE = (method = "move") => {
  return AFTER(`bodyMouseMove ${method}`);
};
const END = (method = "end") => {
  return AFTER(`bodyMouseUp ${method}`);
};
const UPDATE_VIEWPORT = "updateViewport";
const TOGGLE_FULLSCREEN = "toggle.fullscreen";
const REFRESH_SELECTION = "refreshSelection";
const REFRESH_SELECTION_TOOL = "refreshSelectionTool";
const REFRESH_CONTENT = "refreshContent";
const SHOW_COMPONENT_POPUP = "showComponentPopup";
const SHOW_NOTIFY = "showNotify";
const RESIZE_WINDOW = "resize.window";
const RESIZE_CANVAS = "resizeCanvas";
const UPDATE_CANVAS = "updateCanvas";
const OPEN_CONTEXT_MENU = "openContextMenu";
const START_GUESTURE = "startGuesture";
const END_GUESTURE = "endGuesture";
const KEYMAP_KEYDOWN = "keymapKeydown";
const KEYMAP_KEYUP = "keymapKeyup";
const SET_LOCALE = "setLocale";
const PUSH_MODE_VIEW = "pushModeView";
const POP_MODE_VIEW = "popModeView";
let osInfo = {
  name: void 0
};
function os() {
  if (osInfo.name === void 0) {
    if (window.navigator.appVersion.indexOf("Win") != -1)
      osInfo.name = "win";
    else if (window.navigator.appVersion.indexOf("Mac") != -1)
      osInfo.name = "mac";
    else if (window.navigator.appVersion.indexOf("X11") != -1)
      osInfo.name = "linux";
    else
      osInfo.name = "";
  }
  return osInfo.name;
}
const KEY_CODE = {
  backspace: 8,
  tab: 9,
  enter: 13,
  escape: 27,
  space: 32,
  pageup: 33,
  pagedown: 34,
  end: 35,
  home: 36,
  left: 37,
  up: 38,
  right: 39,
  down: 40,
  insert: 45,
  delete: 46,
  0: 48,
  1: 49,
  2: 50,
  3: 51,
  4: 52,
  5: 53,
  6: 54,
  7: 55,
  8: 56,
  9: 57,
  semicolon: 59,
  equals: 61,
  a: 65,
  b: 66,
  c: 67,
  d: 68,
  e: 69,
  f: 70,
  g: 71,
  h: 72,
  i: 73,
  j: 74,
  k: 75,
  l: 76,
  m: 77,
  n: 78,
  o: 79,
  p: 80,
  q: 81,
  r: 82,
  s: 83,
  t: 84,
  u: 85,
  v: 86,
  w: 87,
  x: 88,
  y: 89,
  z: 90,
  multiply: 106,
  add: 107,
  subtract: 109,
  divide: 111,
  f1: 112,
  f2: 113,
  f3: 114,
  f4: 115,
  f5: 116,
  f6: 117,
  f7: 118,
  f8: 119,
  f9: 120,
  f10: 121,
  f11: 122,
  f12: 123,
  f13: 124,
  f14: 125,
  f15: 126,
  f16: 127,
  f17: 128,
  f18: 129,
  f19: 130,
  comma: 188,
  ",": 188,
  period: 190,
  ".": 190,
  slash: 191,
  "/": 191,
  backquote: 192,
  "`": 192,
  openbracket: 219,
  "[": 219,
  backslash: 220,
  "\\": 220,
  closebracket: 221,
  "]": 221,
  quote: 222,
  "'": 222,
  altgr: 225
};
const keyAlias$1 = {
  ARROWRIGHT: "\u2192",
  ARROWLEFT: "\u2190",
  ARROWUP: "\u2191",
  ARROWDOWN: "\u2192",
  BACKSPACE: "\u232B",
  CMD: "\u2318",
  SHIFT: "\u21E7",
  CTRL: "\u2303",
  ALT: "\u2325",
  ENTER: "\u21B5",
  ESC: "\u238B",
  TAB: "\u21E5",
  SPACE: "\u2423",
  CAPSLOCK: "\u21EA",
  DELETE: "\u2326",
  INSERT: "\u2324",
  HOME: "\u21F1",
  END: "\u21F2",
  PAGEUP: "\u21DE",
  PAGEDOWN: "\u21DF",
  PRINTSCREEN: "\u2399",
  SCROLLLOCK: "\u21DE",
  PAUSE: "\u23CF",
  NUMLOCK: "\u21EA",
  META: "\u2318",
  WINDOWS: "\u2318",
  CONTEXTMENU: "\u2325",
  COMMAND: "\u2318"
};
const OSName$1 = os();
const KeyStringMaker = (item, os2 = OSName$1) => {
  return (item[os2] || item.key).split("+").map((it) => it.trim()).map((it) => {
    const keyString = it.toUpperCase();
    return keyAlias$1[keyString] || keyString;
  }).join(" ");
};
class EditorElement extends UIElement {
  get notEventRedefine() {
    return true;
  }
  get $editor() {
    if (!this.__cacheParentEditor) {
      let parentElement = this.parent;
      while (parentElement) {
        if (parentElement.$editor) {
          this.__cacheParentEditor = parentElement.$editor;
          break;
        }
        parentElement = parentElement.parent;
      }
    }
    return this.__cacheParentEditor;
  }
  get $context() {
    return this.$editor.context;
  }
  get $store() {
    return this.$context.store || this.parent.$store;
  }
  get localeKey() {
    return "";
  }
  getMessageKey(key) {
    if (this.localeKey) {
      return `${this.localeKey}.${key}`;
    }
    return key;
  }
  $i18n(key, params = {}, locale) {
    return this.$editor.getI18nMessage(this.getMessageKey(key), params, locale);
  }
  $initI18n(key) {
    return this.$editor.initI18nMessage(this.getMessageKey(key));
  }
  get $config() {
    return this.$context.config;
  }
  get $selection() {
    return this.$context.selection;
  }
  get $segmentSelection() {
    return this.$context.segmentSelection;
  }
  get $commands() {
    return this.$context.commands;
  }
  get $viewport() {
    return this.$context.viewport;
  }
  get $snapManager() {
    return this.$context.snapManager;
  }
  get $timeline() {
    return this.$context.timeline;
  }
  get $history() {
    return this.$context.history;
  }
  get $shortcuts() {
    return this.$context.shortcuts;
  }
  get $keyboardManager() {
    return this.$context.keyboardManager;
  }
  get $storageManager() {
    return this.$context.storageManager;
  }
  get $injectManager() {
    return this.$context.injectManager;
  }
  get $model() {
    return this.$context.modelManager;
  }
  get $lockManager() {
    return this.$context.lockManager;
  }
  get $visibleManager() {
    return this.$context.visibleManager;
  }
  get $modeView() {
    return this.$context.modeViewManager;
  }
  get $icon() {
    return this.$context.icon;
  }
  get $stateManager() {
    return this.$context.stateManager;
  }
  get $menu() {
    return this.$context.menuManager;
  }
  notify(type, title2, description, duration = 1e3) {
    this.emit(SHOW_NOTIFY, type, title2, description, duration);
  }
  alert(title2, description, duration = 1e3) {
    this.notify(NotifyType.ALERT, title2, description, duration);
  }
  $theme(key) {
    return this.$editor.themeValue(key);
  }
  bodyMouseFirstMove(e, methodName) {
    if (this[methodName]) {
      this.emit(ADD_BODY_FIRST_MOUSEMOVE, this[methodName], this, e.xy);
    }
  }
  bodyMouseMove(e, methodName) {
    if (this[methodName]) {
      this.emit(ADD_BODY_MOUSEMOVE, this[methodName], this, e.xy);
    }
  }
  bodyMouseUp(e, methodName) {
    if (this[methodName]) {
      this.emit(ADD_BODY_MOUSEUP, this[methodName], this, e.xy);
    }
  }
  createFunctionComponent(EventMachineComponent, props, baseClass = EditorElement) {
    return super.createFunctionComponent(EventMachineComponent, props, baseClass);
  }
}
class BlankCanvasView extends EditorElement {
  initState() {
    return {
      cursor: "auto",
      cursorArgs: []
    };
  }
  afterRender() {
    this.nextTick(() => {
      this.refreshCanvasSize();
      this.refreshCursor();
    });
  }
  template() {
    return /* @__PURE__ */ createElementJsx("div", {
      class: "elf--page-container",
      tabIndex: "-1",
      ref: "$container"
    }, /* @__PURE__ */ createElementJsx("div", {
      class: "page-view",
      ref: "$pageView"
    }, /* @__PURE__ */ createElementJsx("div", {
      class: "page-lock scrollbar",
      ref: "$lock"
    }, this.$injectManager.generate("canvas.view"))));
  }
  [BIND("$pageView")]() {
    return {
      style: {
        "--elf--canvas-background-color": this.$config.get("style.canvas.background.color")
      }
    };
  }
  checkSpace() {
    if (this.$context.config.is("editing.mode", EditingMode.HAND)) {
      return true;
    }
    return this.$context.keyboardManager.check(this.$context.shortcuts.getGeneratedKeyCode(KEY_CODE.space));
  }
  [POINTERSTART("$lock") + IF("checkSpace") + MOVE("movePan") + END("moveEndPan")]() {
    this.startMovePan();
  }
  [CONFIG("editing.mode")]() {
    if (this.$config.is("editing.mode", EditingMode.HAND)) {
      this.startMovePan();
      this.$commands.emit("refreshCursor", "grab");
    } else {
      this.$commands.emit("recoverCursor", "auto");
    }
  }
  startMovePan() {
    this.lastDist = create$3();
  }
  movePan(dx, dy) {
    this.$commands.emit("refreshCursor", "grabbing");
    const currentDist = fromValues(dx, dy, 0);
    this.$context.viewport.pan(...transformMat4([], subtract([], this.lastDist, currentDist), this.$context.viewport.scaleMatrixInverse));
    this.lastDist = currentDist;
  }
  refreshCursor() {
    if (this.$context.config.is("editing.mode", EditingMode.HAND)) {
      this.$commands.emit("refreshCursor", "grab");
    } else {
      this.$commands.emit("refreshCursor", "auto");
    }
  }
  moveEndPan() {
    this.refreshCursor();
  }
  async [BIND("$container")]() {
    const cursor = await this.$context.cursorManager.load(this.state.cursor, ...this.state.cursorArgs || []);
    return {
      style: {
        cursor
      }
    };
  }
  [DRAGOVER("$lock") + PREVENT]() {
  }
  [DROP("$lock") + PREVENT](e) {
    const newCenter = this.$context.viewport.getWorldPosition(e);
    if (e.dataTransfer.getData("text/asset")) {
      this.$command.emit("drop.asset", {
        asset: { id: e.dataTransfer.getData("text/asset"), center: newCenter }
      });
    } else {
      const id = Dom.create(e.target).attr("data-id");
      if (id) {
        this.$command.emit("drop.asset", {
          gradient: e.dataTransfer.getData("text/gradient"),
          pattern: e.dataTransfer.getData("text/pattern"),
          color: e.dataTransfer.getData("text/color"),
          imageUrl: e.dataTransfer.getData("image/info")
        }, id);
      } else {
        const imageUrl = e.dataTransfer.getData("image/info");
        this.$command.emit("dropImageUrl", imageUrl);
      }
    }
  }
  [WHEEL("$lock") + PREVENT](e) {
    const [dx, dy] = normalizeWheelEvent(e);
    if (!this.state.gesture) {
      if (e.ctrlKey) {
        this.$context.viewport.setMousePoint(e.clientX, e.clientY);
      }
      this.emit("startGesture");
      this.state.gesture = true;
    } else {
      if (e.ctrlKey) {
        const zoomFactor = 1 - 2.5 * dy / 100;
        this.$context.viewport.zoom(zoomFactor);
      } else {
        const newDx = -2.5 * dx;
        const newDy = -2.5 * dy;
        this.$context.viewport.pan(-newDx / this.$viewport.scale, -newDy / this.$viewport.scale, 0);
      }
    }
    window.clearTimeout(this.state.timer);
    this.state.timer = window.setTimeout(() => {
      this.state.gesture = void 0;
      this.emit("endGesture");
    }, 200);
  }
  refreshCanvasSize() {
    this.$context.viewport.refreshCanvasSize(this.refs.$lock.rect());
  }
  [SUBSCRIBE(RESIZE_WINDOW, RESIZE_CANVAS)]() {
    this.refreshCanvasSize();
  }
  [CONFIG("editor.cursor")]() {
    this.state.cursor = this.$config.get("editor.cursor");
    this.state.cursorArgs = this.$config.get("editor.cursor.args");
    this.bindData("$container");
  }
  [CONFIG("editor.cursor.args")]() {
    this.state.cursor = this.$config.get("editor.cursor");
    this.state.cursorArgs = this.$config.get("editor.cursor.args");
    this.bindData("$container");
  }
  [SUBSCRIBE(UPDATE_VIEWPORT)]() {
    this.$commands.emit("refreshCursor", "auto");
  }
}
var PageSubEditor$1 = "";
class PageSubEditor extends EditorElement {
  template() {
    return `
      <div class='elf--page-subeditor'>
        ${this.$injectManager.generate("page.subeditor.view")}         
      </div>
    `;
  }
}
class BlankBodyPanel extends EditorElement {
  components() {
    return {
      BlankCanvasView,
      PageSubEditor
    };
  }
  template() {
    return `
      <div class="elf--body-panel">
        <div class="submenu-area">
          ${createComponent("PageSubEditor")}
        </div>
        <div class='editing-area'>
          <div class="canvas-layout">
            ${createComponent("BlankCanvasView")}
          </div>

        </div>
      </div>
    `;
  }
  [SUBSCRIBE(TOGGLE_FULLSCREEN)]() {
    this.refs.$el.toggleFullscreen();
  }
}
class BaseUI extends UIElement {
  get notEventRedefine() {
    return true;
  }
  getValue() {
    return this.props.defaultValue;
  }
  sendEvent() {
    const key = this.props.key;
    const value = this.getValue();
    const params = this.props.params;
    if (isFunction(this.props.onClick)) {
      this.props.onClick(key, value, params);
    } else if (this.props.command) {
      this.$commands.emit(this.props.command, ...this.props.args || []);
    } else if (isString(this.props.action) || isFunction(this.props.action)) {
      this.emit(this.props.action, key, value, params);
    } else if (isArray(this.props.action)) {
      this.emit(this.props.action.map((action) => [action, key, value, params]));
    } else {
      if (this.props.onChange) {
        this.parent.trigger(this.props.onChange, key, value, params);
      }
    }
  }
}
var Button$1 = "";
class Button extends BaseUI {
  initState() {
    return {
      label: this.props.label || "",
      text: this.props.text || "",
      params: this.props.params || ""
    };
  }
  template() {
    return `<div class='small-editor button' ref='$body'></div>`;
  }
  [LOAD("$body") + DOMDIFF]() {
    var { label, text: text2 } = this.state;
    var hasLabel = label ? "has-label" : "";
    return `
        <div class='elf--button ${hasLabel}'>
            ${label ? `<label title="${label}">${label}</label>` : ""}
            <div class='area'>
                <button type="button" >${text2 || label}</button>
            </div>
        </div>
    `;
  }
  getValue() {
    return this.props.defaultValue;
  }
  [CLICK("$el button")]() {
    this.sendEvent();
  }
}
var ToggleButton$1 = "";
const DEFAULT_LABELS$1 = ["True", "False"];
class ToggleButton extends BaseUI {
  initState() {
    return {
      checkedValue: this.props.checkedValue || this.props.value,
      checked: this.props.value || "false",
      size: this.props.size,
      toggleLabels: this.props.toggleLabels || DEFAULT_LABELS$1,
      toggleTitles: this.props.toggleTitles || [],
      toggleValues: this.props.toggleValues || ["true", "false"]
    };
  }
  template() {
    return /* @__PURE__ */ createElementJsx("div", {
      class: "small-editor button",
      ref: "$body"
    });
  }
  [LOAD("$body") + DOMDIFF]() {
    var { checked, checkedValue } = this.state;
    return `
        <div class='elf--toggle-button'>
            <div class='area' ref="$area">
                ${this.state.toggleValues.map((it, index2) => {
      let label = this.state.toggleLabels[index2];
      let title2 = this.state.toggleTitles[index2];
      return createElementJsx("div", {
        class: `${it === checked ? "visible" : ""} ${it === checkedValue ? "checked" : ""}`
      }, createElementJsx("button", {
        type: "button",
        "data-index": index2,
        class: it === checkedValue ? "checked" : "",
        value: it,
        title: title2,
        style: "--elf--toggle-checkbox-tooltip-top: -20%;"
      }, label));
    }).join("")}
            </div>
        </div>
    `;
  }
  [BIND("$area")]() {
    const selectedIndex = this.state.toggleValues.findIndex((v) => v === this.state.checked);
    return {
      "data-selected-index": selectedIndex
    };
  }
  setValue(checked) {
    this.setState({
      checked
    });
  }
  getValue() {
    return this.state.checked;
  }
  [CLICK("$el button") + PREVENT + STOP](e) {
    const value = e.$dt.value;
    const selectedIndex = this.state.toggleValues.findIndex((v) => v === value);
    const nextValue = this.state.toggleValues[(selectedIndex + 1) % this.state.toggleValues.length];
    this.setValue(nextValue);
    this.trigger("change");
  }
  [SUBSCRIBE_SELF("change")]() {
    this.sendEvent();
  }
}
var ToggleCheckBox$1 = "";
const DEFAULT_LABELS = ["True", "False"];
class ToggleCheckBox extends BaseUI {
  initState() {
    return {
      label: this.props.label || "",
      checked: this.props.value || false,
      toggleLabels: this.props.toggleLabels || DEFAULT_LABELS,
      toggleTitles: this.props.toggleTitles || [],
      toggleValues: this.props.toggleValues || [true, false]
    };
  }
  template() {
    return /* @__PURE__ */ createElementJsx("div", {
      class: "small-editor button",
      ref: "$body"
    });
  }
  [LOAD("$body")]() {
    var { label, checked } = this.state;
    var hasLabel = label ? "has-label" : "";
    return `
        <div class='elf--toggle-checkbox ${hasLabel}'>
            ${label ? `<label title="${label}">${label}</label>` : ""}
            <div class='area' ref="$area">
                ${this.state.toggleValues.map((it, index2) => {
      let label2 = this.state.toggleLabels[index2];
      let title2 = this.state.toggleTitles[index2];
      return createElementJsx("div", null, createElementJsx("button", {
        type: "button",
        class: `${it === checked ? "checked" : ""}`,
        "data-index": index2,
        title: title2,
        style: "--elf--toggle-checkbox-tooltip-top: -20%;"
      }, label2));
    }).join("")}
            </div>
        </div>
    `;
  }
  [BIND("$area")]() {
    const selectedIndex = this.state.toggleValues.findIndex((v) => v === this.state.checked);
    const unit = 100 / this.state.toggleValues.length;
    return {
      "data-selected-index": selectedIndex,
      cssText: `
                --unit-count: ${this.state.toggleValues.length};
                --button-font-size: ${13 - this.state.toggleValues.length}px ;
                --selected-button-size: ${1 / this.state.toggleValues.length * 100}%;
                --selected-button-position: ${selectedIndex * unit}%;
            `
    };
  }
  setValue(checked) {
    this.setState({
      checked
    });
  }
  getValue() {
    return this.state.checked;
  }
  [CLICK("$el button")](e) {
    const index2 = +e.$dt.data("index");
    this.setValue(this.state.toggleValues[index2]);
    this.trigger("change");
  }
  [SUBSCRIBE_SELF("change")]() {
    this.sendEvent();
  }
}
class TabPanel extends UIElement {
  initState() {
    return {
      value: this.props.value || ""
    };
  }
  template() {
    const { content: content2 } = this.props;
    const { value } = this.state;
    return /* @__PURE__ */ createElementJsx("div", {
      class: "tab-content scrollbar",
      "data-value": value
    }, content2);
  }
}
var Tabs$1 = "";
class Tabs extends UIElement {
  afterRender() {
    window.setTimeout(() => {
      this.setValue(this.state.selectedValue);
    }, 0);
  }
  initState() {
    return {
      type: this.props.type || "number",
      direction: this.props.direction || "",
      selectedValue: this.props.selectedValue || ""
    };
  }
  template() {
    return `
        <div class="tab number ${this.state.type === "side" ? `number-tab side-tab` : ""} side-tab-${this.state.direction}" ref="$tab"></div>
      `;
  }
  [LOAD("$tab")]() {
    const { content: content2, contentChildren = [] } = this.props;
    const children2 = contentChildren.filter((it) => it.component === TabPanel);
    return [
      /* @__PURE__ */ createElementJsx("div", {
        class: "tab-header",
        ref: "$header"
      }, children2.map((it) => /* @__PURE__ */ createElementJsx("div", {
        class: "tab-item",
        "data-value": it.props.value,
        title: it.props.title
      }, /* @__PURE__ */ createElementJsx("label", {
        class: "title"
      }, it.props.icon || it.props.title)))),
      /* @__PURE__ */ createElementJsx("div", {
        class: "tab-body",
        ref: "$body"
      }, content2)
    ];
  }
  [CLICK("$header .tab-item:not(.empty-item)")](e) {
    var selectedValue = e.$dt.attr("data-value");
    this.setValue(selectedValue);
  }
  updateData(data) {
    this.setState(data, false);
    this.parent.trigger(this.props.onchange, this.getValue());
  }
  getValue() {
    return this.state.selectedValue;
  }
  setValue(selectedValue) {
    var _a, _b;
    (_a = this.$el.$(`* > .tab-item[data-value="${selectedValue}"]`)) == null ? void 0 : _a.onlyOneClass("selected");
    (_b = this.$el.$(`* > .tab-content[data-value="${selectedValue}"]`)) == null ? void 0 : _b.onlyOneClass("selected");
    this.updateData({ selectedValue });
  }
}
class BlankInspector extends EditorElement {
  template() {
    return /* @__PURE__ */ createElementJsx("div", {
      class: "feature-control inspector"
    }, /* @__PURE__ */ createElementJsx("div", null, /* @__PURE__ */ createElementJsx(Tabs, {
      ref: "$tab",
      selectedValue: this.$config.get("inspector.selectedValue"),
      onchange: (value) => {
        this.$config.set("inspector.selectedValue", value);
      }
    }, this.$injectManager.getTargetUI("inspector.tab").map((it) => {
      const { value, title: title2, icon, loadElements = [] } = it.class;
      return /* @__PURE__ */ createElementJsx(TabPanel, {
        value,
        title: title2,
        icon
      }, /* @__PURE__ */ createElementJsx("div", {
        style: "display: flex: flex-direction: column;"
      }, loadElements == null ? void 0 : loadElements.map((element) => createElement(element)), this.$injectManager.generate("inspector.tab." + value), /* @__PURE__ */ createElementJsx("div", {
        class: "empty",
        style: "order: 1000000;"
      })));
    }))));
  }
}
class BlankLayerTab extends EditorElement {
  template() {
    return /* @__PURE__ */ createElementJsx("div", {
      class: "layer-tab"
    }, /* @__PURE__ */ createElementJsx(Tabs, {
      ref: "$tab",
      type: "side",
      direction: "left",
      selectedValue: this.$config.get("layertab.selectedValue"),
      onchange: (value) => {
        this.$config.set("layertab.selectedValue", value);
      }
    }, this.$injectManager.getTargetUI("layertab.tab").map((it) => {
      const { value, title: title2, icon, loadElements = [] } = it.class;
      return /* @__PURE__ */ createElementJsx(TabPanel, {
        value,
        title: title2,
        icon
      }, /* @__PURE__ */ createElementJsx("div", {
        style: "display: flex: flex-direction: column;"
      }, loadElements == null ? void 0 : loadElements.map((element) => createElement(element)), this.$injectManager.generate("layertab.tab." + value), /* @__PURE__ */ createElementJsx("div", {
        class: "empty",
        style: "order: 1000000;"
      })));
    })));
  }
}
var BlankToolBar$1 = "";
var ToolbarMenuItem = "";
function _icon_template(tpl, opt) {
  const defaultOpts = Object.assign({
    width: 24,
    height: 24
  }, opt);
  return `
        <svg 
            xmlns="http://www.w3.org/2000/svg" 
            width="${defaultOpts.width}" 
            height="${defaultOpts.height}" 
            viewBox="0 0 ${defaultOpts.viewBoxWidth || defaultOpts.width} ${defaultOpts.viewBoxHeight || defaultOpts.height}">${tpl}</svg>`;
}
var __glob_0_0$7 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": _icon_template
}, Symbol.toStringTag, { value: "Module" }));
var account_tree = _icon_template(`<path d="M22 11V3h-7v3H9V3H2v8h7V8h2v10h4v3h7v-8h-7v3h-2V8h2v3z"/>`);
var __glob_0_1$7 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": account_tree
}, Symbol.toStringTag, { value: "Module" }));
var add = _icon_template(`<path d="M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6v2z"/>`);
var __glob_0_2$6 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": add
}, Symbol.toStringTag, { value: "Module" }));
var add_box = _icon_template(`<path d="M19 3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-2 10h-4v4h-2v-4H7v-2h4V7h2v4h4v2z"/>`);
var __glob_0_3$6 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": add_box
}, Symbol.toStringTag, { value: "Module" }));
var add_circle$1 = _icon_template(`<path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm5 11h-4v4h-2v-4H7v-2h4V7h2v4h4v2z"/>`);
var __glob_0_4$6 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": add_circle$1
}, Symbol.toStringTag, { value: "Module" }));
var add_note = _icon_template(`<path d="M14 2H6c-1.1 0-1.99.9-1.99 2L4 20c0 1.1.89 2 1.99 2H18c1.1 0 2-.9 2-2V8l-6-6zm2 14h-3v3h-2v-3H8v-2h3v-3h2v3h3v2zm-3-7V3.5L18.5 9H13z"/>`);
var __glob_0_5$6 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": add_note
}, Symbol.toStringTag, { value: "Module" }));
var align_center = _icon_template(`<path d="M7 15v2h10v-2H7zm-4 6h18v-2H3v2zm0-8h18v-2H3v2zm4-6v2h10V7H7zM3 3v2h18V3H3z"/>`);
var __glob_0_6$6 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": align_center
}, Symbol.toStringTag, { value: "Module" }));
var align_horizontal_center = _icon_template(`<polygon points="11,2 13,2 13,7 21,7 21,10 13,10 13,14 18,14 18,17 13,17 13,22 11,22 11,17 6,17 6,14 11,14 11,10 3,10 3,7 11,7"/>`);
var __glob_0_7$6 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": align_horizontal_center
}, Symbol.toStringTag, { value: "Module" }));
var align_horizontal_left = _icon_template(`<path d="M4,22H2V2h2V22z M22,7H6v3h16V7z M16,14H6v3h10V14z"/>`);
var __glob_0_8$5 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": align_horizontal_left
}, Symbol.toStringTag, { value: "Module" }));
var align_horizontal_right = _icon_template(`<path d="M20,2h2v20h-2V2z M2,10h16V7H2V10z M8,17h10v-3H8V17z"/>`);
var __glob_0_9$5 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": align_horizontal_right
}, Symbol.toStringTag, { value: "Module" }));
var align_justify = _icon_template(`<path d="M3 21h18v-2H3v2zm0-4h18v-2H3v2zm0-4h18v-2H3v2zm0-4h18V7H3v2zm0-6v2h18V3H3z"/>`);
var __glob_0_10$5 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": align_justify
}, Symbol.toStringTag, { value: "Module" }));
var align_left = _icon_template(`<path d="M15 15H3v2h12v-2zm0-8H3v2h12V7zM3 13h18v-2H3v2zm0 8h18v-2H3v2zM3 3v2h18V3H3z"/>`);
var __glob_0_11$5 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": align_left
}, Symbol.toStringTag, { value: "Module" }));
var align_right = _icon_template(`<path d="M3 21h18v-2H3v2zm6-4h12v-2H9v2zm-6-4h18v-2H3v2zm6-4h12V7H9v2zM3 3v2h18V3H3z"/>`);
var __glob_0_12$5 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": align_right
}, Symbol.toStringTag, { value: "Module" }));
var align_vertical_bottom = _icon_template(`<path d="M22,22H2v-2h20V22z M10,2H7v16h3V2z M17,8h-3v10h3V8z"/>`);
var __glob_0_13$5 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": align_vertical_bottom
}, Symbol.toStringTag, { value: "Module" }));
var align_vertical_center = _icon_template(`<polygon points="22,11 17,11 17,6 14,6 14,11 10,11 10,3 7,3 7,11 1.84,11 1.84,13 7,13 7,21 10,21 10,13 14,13 14,18 17,18 17,13 22,13"/>`);
var __glob_0_14$5 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": align_vertical_center
}, Symbol.toStringTag, { value: "Module" }));
var align_vertical_top = _icon_template(`<path d="M22,2v2H2V2H22z M7,22h3V6H7V22z M14,16h3V6h-3V16z"/>`);
var __glob_0_15$4 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": align_vertical_top
}, Symbol.toStringTag, { value: "Module" }));
var alternate = _icon_template(`<path d="M7 7h10v3l4-4-4-4v3H5v6h2V7zm10 10H7v-3l-4 4 4 4v-3h12v-6h-2v4z"/>`);
var __glob_0_16$4 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": alternate
}, Symbol.toStringTag, { value: "Module" }));
var alternate_reverse = _icon_template(`<path d="M7 7h10v3l4-4-4-4v3H5v6h2V7zm10 10H7v-3l-4 4 4 4v-3h12v-6h-2v4z" />`);
var __glob_0_17$4 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": alternate_reverse
}, Symbol.toStringTag, { value: "Module" }));
var apps = _icon_template(`<path d="M4 8h4V4H4v4zm6 12h4v-4h-4v4zm-6 0h4v-4H4v4zm0-6h4v-4H4v4zm6 0h4v-4h-4v4zm6-10v4h4V4h-4zm-6 4h4V4h-4v4zm6 6h4v-4h-4v4zm0 6h4v-4h-4v4z"/>`);
var __glob_0_18$4 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": apps
}, Symbol.toStringTag, { value: "Module" }));
var archive = _icon_template(`<path d="M20.54 5.23l-1.39-1.68C18.88 3.21 18.47 3 18 3H6c-.47 0-.88.21-1.16.55L3.46 5.23C3.17 5.57 3 6.02 3 6.5V19c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V6.5c0-.48-.17-.93-.46-1.27zM12 17.5L6.5 12H10v-2h4v2h3.5L12 17.5zM5.12 5l.81-1h12l.94 1H5.12z"/>`);
var __glob_0_19$4 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": archive
}, Symbol.toStringTag, { value: "Module" }));
var arrowLeft = _icon_template(`<path d="M14 7l-5 5 5 5V7z"/>`);
var __glob_0_20$4 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": arrowLeft
}, Symbol.toStringTag, { value: "Module" }));
var arrowRight = _icon_template(`<path d="M10 17l5-5-5-5v10z"/>`);
var __glob_0_21$3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": arrowRight
}, Symbol.toStringTag, { value: "Module" }));
var arrow_right = _icon_template(`<path d="M10 17l5-5-5-5v10z"/>`);
var __glob_0_22$3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": arrow_right
}, Symbol.toStringTag, { value: "Module" }));
var artboard$1 = _icon_template(`<path d="M13.85 34.05H27.6V31.05H13.85ZM13.85 25.5H34.15V22.5H13.85ZM13.85 16.95H34.15V13.95H13.85ZM9 42Q7.8 42 6.9 41.1Q6 40.2 6 39V9Q6 7.8 6.9 6.9Q7.8 6 9 6H39Q40.2 6 41.1 6.9Q42 7.8 42 9V39Q42 40.2 41.1 41.1Q40.2 42 39 42ZM9 39H39Q39 39 39 39Q39 39 39 39V9Q39 9 39 9Q39 9 39 9H9Q9 9 9 9Q9 9 9 9V39Q9 39 9 39Q9 39 9 39ZM9 39Q9 39 9 39Q9 39 9 39V9Q9 9 9 9Q9 9 9 9Q9 9 9 9Q9 9 9 9V39Q9 39 9 39Q9 39 9 39Z"/>`, {
  width: 48,
  height: 48
});
var __glob_0_23$3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": artboard$1
}, Symbol.toStringTag, { value: "Module" }));
var auto_awesome = _icon_template(`<path d="M19 9l1.25-2.75L23 5l-2.75-1.25L19 1l-1.25 2.75L15 5l2.75 1.25L19 9zm-7.5.5L9 4 6.5 9.5 1 12l5.5 2.5L9 20l2.5-5.5L17 12l-5.5-2.5zM19 15l-1.25 2.75L15 19l2.75 1.25L19 23l1.25-2.75L23 19l-2.75-1.25L19 15z"/>`);
var __glob_0_24$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": auto_awesome
}, Symbol.toStringTag, { value: "Module" }));
var autorenew = _icon_template(`<path d="M12 6v3l4-4-4-4v3c-4.42 0-8 3.58-8 8 0 1.57.46 3.03 1.24 4.26L6.7 14.8c-.45-.83-.7-1.79-.7-2.8 0-3.31 2.69-6 6-6zm6.76 1.74L17.3 9.2c.44.84.7 1.79.7 2.8 0 3.31-2.69 6-6 6v-3l-4 4 4 4v-3c4.42 0 8-3.58 8-8 0-1.57-.46-3.03-1.24-4.26z"/>`);
var __glob_0_25$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": autorenew
}, Symbol.toStringTag, { value: "Module" }));
var ballot = _icon_template(`<clipPath><use xlink:href="#a" overflow="visible"/></clipPath><path fill-rule="evenodd" clip-rule="evenodd" d="M13 9.5h5v-2h-5v2zm0 7h5v-2h-5v2zm6 4.5H5c-1.1 0-2-.9-2-2V5c0-1.1.9-2 2-2h14c1.1 0 2 .9 2 2v14c0 1.1-.9 2-2 2zM6 11h5V6H6v5zm1-4h3v3H7V7zM6 18h5v-5H6v5zm1-4h3v3H7v-3z"/>`);
var __glob_0_26$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": ballot
}, Symbol.toStringTag, { value: "Module" }));
var bar_chart = _icon_template(`<path d="M5 9.2h3V19H5zM10.6 5h2.8v14h-2.8zm5.6 8H19v6h-2.8z"/>`);
var __glob_0_27$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": bar_chart
}, Symbol.toStringTag, { value: "Module" }));
var blur = _icon_template(`<path d="M6 13c-.55 0-1 .45-1 1s.45 1 1 1 1-.45 1-1-.45-1-1-1zm0 4c-.55 0-1 .45-1 1s.45 1 1 1 1-.45 1-1-.45-1-1-1zm0-8c-.55 0-1 .45-1 1s.45 1 1 1 1-.45 1-1-.45-1-1-1zm-3 .5c-.28 0-.5.22-.5.5s.22.5.5.5.5-.22.5-.5-.22-.5-.5-.5zM6 5c-.55 0-1 .45-1 1s.45 1 1 1 1-.45 1-1-.45-1-1-1zm15 5.5c.28 0 .5-.22.5-.5s-.22-.5-.5-.5-.5.22-.5.5.22.5.5.5zM14 7c.55 0 1-.45 1-1s-.45-1-1-1-1 .45-1 1 .45 1 1 1zm0-3.5c.28 0 .5-.22.5-.5s-.22-.5-.5-.5-.5.22-.5.5.22.5.5.5zm-11 10c-.28 0-.5.22-.5.5s.22.5.5.5.5-.22.5-.5-.22-.5-.5-.5zm7 7c-.28 0-.5.22-.5.5s.22.5.5.5.5-.22.5-.5-.22-.5-.5-.5zm0-17c.28 0 .5-.22.5-.5s-.22-.5-.5-.5-.5.22-.5.5.22.5.5.5zM10 7c.55 0 1-.45 1-1s-.45-1-1-1-1 .45-1 1 .45 1 1 1zm0 5.5c-.83 0-1.5.67-1.5 1.5s.67 1.5 1.5 1.5 1.5-.67 1.5-1.5-.67-1.5-1.5-1.5zm8 .5c-.55 0-1 .45-1 1s.45 1 1 1 1-.45 1-1-.45-1-1-1zm0 4c-.55 0-1 .45-1 1s.45 1 1 1 1-.45 1-1-.45-1-1-1zm0-8c-.55 0-1 .45-1 1s.45 1 1 1 1-.45 1-1-.45-1-1-1zm0-4c-.55 0-1 .45-1 1s.45 1 1 1 1-.45 1-1-.45-1-1-1zm3 8.5c-.28 0-.5.22-.5.5s.22.5.5.5.5-.22.5-.5-.22-.5-.5-.5zM14 17c-.55 0-1 .45-1 1s.45 1 1 1 1-.45 1-1-.45-1-1-1zm0 3.5c-.28 0-.5.22-.5.5s.22.5.5.5.5-.22.5-.5-.22-.5-.5-.5zm-4-12c-.83 0-1.5.67-1.5 1.5s.67 1.5 1.5 1.5 1.5-.67 1.5-1.5-.67-1.5-1.5-1.5zm0 8.5c-.55 0-1 .45-1 1s.45 1 1 1 1-.45 1-1-.45-1-1-1zm4-4.5c-.83 0-1.5.67-1.5 1.5s.67 1.5 1.5 1.5 1.5-.67 1.5-1.5-.67-1.5-1.5-1.5zm0-4c-.83 0-1.5.67-1.5 1.5s.67 1.5 1.5 1.5 1.5-.67 1.5-1.5-.67-1.5-1.5-1.5z"/>`);
var __glob_0_28$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": blur
}, Symbol.toStringTag, { value: "Module" }));
var blur_linear = _icon_template(`<path d="M5 17.5c.83 0 1.5-.67 1.5-1.5s-.67-1.5-1.5-1.5-1.5.67-1.5 1.5.67 1.5 1.5 1.5zM9 13c.55 0 1-.45 1-1s-.45-1-1-1-1 .45-1 1 .45 1 1 1zm0-4c.55 0 1-.45 1-1s-.45-1-1-1-1 .45-1 1 .45 1 1 1zM3 21h18v-2H3v2zM5 9.5c.83 0 1.5-.67 1.5-1.5S5.83 6.5 5 6.5 3.5 7.17 3.5 8 4.17 9.5 5 9.5zm0 4c.83 0 1.5-.67 1.5-1.5s-.67-1.5-1.5-1.5-1.5.67-1.5 1.5.67 1.5 1.5 1.5zM9 17c.55 0 1-.45 1-1s-.45-1-1-1-1 .45-1 1 .45 1 1 1zm8-.5c.28 0 .5-.22.5-.5s-.22-.5-.5-.5-.5.22-.5.5.22.5.5.5zM3 3v2h18V3H3zm14 5.5c.28 0 .5-.22.5-.5s-.22-.5-.5-.5-.5.22-.5.5.22.5.5.5zm0 4c.28 0 .5-.22.5-.5s-.22-.5-.5-.5-.5.22-.5.5.22.5.5.5zM13 9c.55 0 1-.45 1-1s-.45-1-1-1-1 .45-1 1 .45 1 1 1zm0 4c.55 0 1-.45 1-1s-.45-1-1-1-1 .45-1 1 .45 1 1 1zm0 4c.55 0 1-.45 1-1s-.45-1-1-1-1 .45-1 1 .45 1 1 1z"/>`);
var __glob_0_29$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": blur_linear
}, Symbol.toStringTag, { value: "Module" }));
var boolean_difference = _icon_template(`<path d="M 20 10L 30 10L 30 30L 10 30L 10 20L 20 20L 20 10Z M 0 0L 20 0L 20 20L 0 20L 0 0Z  M 2 2L 2 18L 18 18L 18 2L 2 2Z" />`, { width: 30, height: 30 });
var __glob_0_30$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": boolean_difference
}, Symbol.toStringTag, { value: "Module" }));
var boolean_intersection = _icon_template(`<path d="
    M 10 10L 30 10L 30 30L 10 30L 10 10Z 
    M 20 12L 18 18L 12 18L 12 28L 28 28L 28 12L 12 12Z 
    M 0 0L 20 0L 20 20L 0 20L 0 0Z  
    M 2 2L 2 18L 18 18L 18 2L 2 2Z
" />`, { width: 30, height: 30 });
var __glob_0_31$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": boolean_intersection
}, Symbol.toStringTag, { value: "Module" }));
var boolean_union = _icon_template(`<path d="M 0 0L 20 0L 20 20L 0 20L 0 0Z M 10 10L 30 10L 30 30L 10 30L 10 10Z"/>`, { width: 30, height: 30 });
var __glob_0_32$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": boolean_union
}, Symbol.toStringTag, { value: "Module" }));
var boolean_xor = _icon_template(`<path d="
    M 10 10L 30 10L 30 30L 10 30L 10 10Z
    M 0 0L 20 0L 20 20L 0 20L 0 0Z 
" fill-rule="evenodd"/>`, { width: 30, height: 30 });
var __glob_0_33$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": boolean_xor
}, Symbol.toStringTag, { value: "Module" }));
var border_all = _icon_template(`<path d="M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-1 16H6c-.55 0-1-.45-1-1V6c0-.55.45-1 1-1h12c.55 0 1 .45 1 1v12c0 .55-.45 1-1 1z"/>`);
var __glob_0_34$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": border_all
}, Symbol.toStringTag, { value: "Module" }));
var border_inner = _icon_template(`<path d="M3 5v3c0 .55.45 1 1 1s1-.45 1-1V6c0-.55.45-1 1-1h2c.55 0 1-.45 1-1s-.45-1-1-1H5c-1.1 0-2 .9-2 2zm1 10c-.55 0-1 .45-1 1v3c0 1.1.9 2 2 2h3c.55 0 1-.45 1-1s-.45-1-1-1H6c-.55 0-1-.45-1-1v-2c0-.55-.45-1-1-1zm15 3c0 .55-.45 1-1 1h-2c-.55 0-1 .45-1 1s.45 1 1 1h3c1.1 0 2-.9 2-2v-3c0-.55-.45-1-1-1s-1 .45-1 1v2zm0-15h-3c-.55 0-1 .45-1 1s.45 1 1 1h2c.55 0 1 .45 1 1v2c0 .55.45 1 1 1s1-.45 1-1V5c0-1.1-.9-2-2-2z"/>`);
var __glob_0_35$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": border_inner
}, Symbol.toStringTag, { value: "Module" }));
var border_style = _icon_template(`<path d="M15 21h2v-2h-2v2zm4 0h2v-2h-2v2zM7 21h2v-2H7v2zm4 0h2v-2h-2v2zm8-4h2v-2h-2v2zm0-4h2v-2h-2v2zM3 3v18h2V5h16V3H3zm16 6h2V7h-2v2z"/>`);
var __glob_0_36$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": border_style
}, Symbol.toStringTag, { value: "Module" }));
var bottom = _icon_template(`<path d="M4,20 L20,20Z M10,8 L10,16 L14,16 L14,8Z" stroke-width="1" />`);
var __glob_0_37$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": bottom
}, Symbol.toStringTag, { value: "Module" }));
var broken_image = _icon_template(`<path d="M21 5v6.59l-3-3.01-4 4.01-4-4-4 4-3-3.01V5c0-1.1.9-2 2-2h14c1.1 0 2 .9 2 2zm-3 6.42l3 3.01V19c0 1.1-.9 2-2 2H5c-1.1 0-2-.9-2-2v-6.58l3 2.99 4-4 4 4 4-3.99z"/>`);
var __glob_0_38$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": broken_image
}, Symbol.toStringTag, { value: "Module" }));
var brush = _icon_template(`<path d="M7 14c-1.66 0-3 1.34-3 3 0 1.31-1.16 2-2 2 .92 1.22 2.49 2 4 2 2.21 0 4-1.79 4-4 0-1.66-1.34-3-3-3zm13.71-9.37l-1.34-1.34c-.39-.39-1.02-.39-1.41 0L9 12.25 11.75 15l8.96-8.96c.39-.39.39-1.02 0-1.41z"/>`);
var __glob_0_39$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": brush
}, Symbol.toStringTag, { value: "Module" }));
var build = _icon_template(`<path d="M22.7 19l-9.1-9.1c.9-2.3.4-5-1.5-6.9-2-2-5-2.4-7.4-1.3L9 6 6 9 1.6 4.7C.4 7.1.9 10.1 2.9 12.1c1.9 1.9 4.6 2.4 6.9 1.5l9.1 9.1c.4.4 1 .4 1.4 0l2.3-2.3c.5-.4.5-1.1.1-1.4z"/>`);
var __glob_0_40$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": build
}, Symbol.toStringTag, { value: "Module" }));
var camera_roll = _icon_template(`<path d="M14 5c0-1.1-.9-2-2-2h-1V2c0-.55-.45-1-1-1H6c-.55 0-1 .45-1 1v1H4c-1.1 0-2 .9-2 2v15c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2h8V5h-8zm-2 13h-2v-2h2v2zm0-9h-2V7h2v2zm4 9h-2v-2h2v2zm0-9h-2V7h2v2zm4 9h-2v-2h2v2zm0-9h-2V7h2v2z"/>`);
var __glob_0_41$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": camera_roll
}, Symbol.toStringTag, { value: "Module" }));
var cat = _icon_template(`
<path d="M712.4846,631.2673c-8.3777-59.9758-44.6997-121.2822-117.7703-198.7816
	c-51.7295-54.8649-72.0865-105.7791-55.8514-139.6883c12.4393-25.9817,42.587-35.8935,65.343-34.1103
	c26.3435,2.0661,37.3148,18.5905,41.88,32.0888c6.5847,19.471,2.7829,43.5175-8.4753,53.6029
	c-2.4382,2.1843-19.5444,15.6083-31.617,2.486c-16.0995-17.4994,1.3123-34.1181,1.3123-34.1181s25.7198-19.4211,11.5477-34.6431
	c-14.1721-15.2219-81.6211,4.7241-73.1766,62.9098c2.102,14.4833,9.8525,35.0453,41.7667,49.9105
	c31.3411,14.5985,62.0806,11.5356,84.3365-8.4017c26.8387-24.0431,36.221-68.5172,22.8163-108.1526
	c-13.0433-38.5685-45.3375-63.5167-86.387-66.7359c-22.4584-1.7602-45.9053,2.9182-66.0231,13.1776
	c-22.1882,11.3155-39.3094,28.5606-49.5124,49.8713c-15.207,31.7608-27.0118,99.5788,64.7797,196.9337
	c64.4428,68.3486,97.5892,122.6011,104.3126,170.7358c6.1263,43.8577-32.9753,141.2908-59.1734,141.8642
	c-18.2653,0.3997-13.0681-28.0174-11.1219-46.1832c3.4623-32.3166,9.02-64.4668,7.8147-96.946
	c-1.7692-47.6774-16.0649-83.7216-38.2463-125.1911c-20.1995-37.7643-37.8974-60.6029-92.5699-111.4463
	c-13.4884-12.5438-27.4699-22.5866-44.7675-38.1754c-17.5431-15.8101-21.9685-33.5474-24.195-48.6835
	c-4.6472-31.5926,5.266-35.0392,22.933-61.1816c7.51,6.1134,15.132,13.1576,22.5878,21.2593
	c0.8908,0.9678,2.1063,1.4586,3.3257,1.4586c1.0938,0,2.1906-0.3947,3.059-1.1939c1.8362-1.6895,1.9548-4.548,0.2647-6.3846
	c-8.043-8.7399-16.2394-16.2892-24.29-22.8068c1.0196-1.6815,1.9806-3.3693,2.913-5.06
	c11.2809,3.873,22.4781,8.5857,32.8744,14.3263c0.6923,0.3824,1.4415,0.5638,2.1804,0.5638c1.592,0,3.1354-0.8433,3.9596-2.3353
	c1.2061-2.1848,0.4133-4.9333-1.7714-6.14c-10.5501-5.8255-21.7927-10.625-33.0861-14.5846
	c1.7051-3.6655,3.2152-7.3481,4.5178-11.0449c9.9095,1.0547,20.2559,2.6507,30.8756,4.9542
	c2.4407,0.5281,4.8451-1.0193,5.3736-3.4585c0.5285-2.4387-1.0193-4.8446-3.4586-5.3736
	c-10.3543-2.2456-20.4231-3.8448-30.0823-4.9431c6.761-25.5357,4.0583-51.5754-8.0207-76.8648
	C448.2098,115.8869,474.731,76.8288,466.0513,18c-68.8775,17.9071-87.2624,54.1776-94.1043,50.875
	c-7.9472-3.8361-40.5018-11.036-62.952-10.6586c-37.278,0.6267-61.382,7.0395-61.382,7.0395
	c-11.2537-14.6686-35.9431-36.6889-90.105-41.2683c2.9433,47.1602,13.4346,82.2557,28.5291,102.9373l-0.7433,2.377
	c-11.7879,32.4393-13.5817,62.8858-3.8016,89.6451c-9.0883,1.1019-18.5685,2.7173-28.321,4.9987
	c-2.4299,0.5687-3.939,2.9991-3.3708,5.429c0.5687,2.4294,2.9972,3.939,5.429,3.3708c10.3087-2.4115,20.3424-4.0428,29.9266-5.0891
	c1.4184,2.9763,2.9836,5.904,4.7147,8.7755c-11.2262,4.119-22.4456,9.1879-32.9296,15.4312
	c-2.1445,1.2767-2.8476,4.0498-1.5704,6.1939c0.8453,1.4199,2.3461,2.2073,3.8866,2.2073c0.7859,0,1.5827-0.2054,2.3073-0.6369
	c10.5541-6.2849,22.0078-11.3381,33.4798-15.4008c3.3157,4.5403,7.0729,8.9251,11.2576,13.1527
	c-5.6694,5.3088-11.3757,11.2216-17,17.8125c-1.6199,1.8979-1.3944,4.7505,0.504,6.3699c0.8507,0.7266,1.8935,1.0816,2.931,1.0816
	c1.2767,0,2.5456-0.5383,3.4389-1.5856c5.5062-6.4525,11.1144-12.2327,16.692-17.4078c5.7832,5.4212,11.3758,11.1287,15.514,17.8627
	c7.8208,12.7265,8.3216,25.8196,6.7598,40.6753c-3.119,29.6671-13.4278,58.0414-20.0391,87.1301
	c-16.8163,73.989-9.0635,132.7513,20.7169,202.5388c8.0053,18.7598,17.5698,36.9144,23.7843,56.341
	c10.5081,32.8488,7.8436,88.3559,8.2697,122.8419v2.9318c0,0-19.9931,0.1384-28.4717,6.0748
	c-8.2555,5.7802-10.3883,21.931-4.3929,28.6906c6.6872,7.5395,21.6739,10.6397,31.6837,11.8093
	c119.664,13.9824,293.6021-2.6707,341.7446-8.3345C701.2023,821.2982,721.1432,693.2562,712.4846,631.2673z M437.2106,66.5267
	c-0.1946,33.6617-23.5064,50.7886-23.5064,50.7886c-6.2684-17.19-21.1558-25.3943-21.1558-25.3943
	C408.2194,68.8708,437.2106,66.5267,437.2106,66.5267z M201.6607,103.3024c0,0-19.8527-14.6264-20.0184-43.3732
	c0,0,24.6894,2.0019,38.035,21.6866C219.6773,81.6158,206.999,88.6223,201.6607,103.3024z M215.969,158.6876
	c15.0275-4.1452,27.2506-3.8264,37.1033-1.1182c-15.9193,16.5729-7.4137,31.0502-3.2583,36.286
	C221.2402,186.9178,215.969,158.6876,215.969,158.6876z M252.8369,194.4974c13.6546-17.1619,7.1357-30.6827,3.4758-35.9226
	c24.8589,8.5877,33.2057,32.5095,33.2057,32.5095C274.4792,195.6167,262.4471,196.221,252.8369,194.4974z M308.1766,232.8661
	c-4.1644,0.2111-22.0216-7.8084-21.8634-21.8635c0.1244-11.0539,40.2451-7.8568,42.1652,0
	C330.8523,220.7164,312.3411,232.655,308.1766,232.8661z M327.2252,191.0843c0,0,8.7972-25.2037,35.2186-33.1565
	c-12.424,19.1432-1.5466,31.7233,3.55,36.1478C356.055,196.2867,343.3752,195.9514,327.2252,191.0843z M369.7458,193.0825
	c10.0879-20.4091-1.0878-32.4358-4.9794-35.7968c9.66-2.4378,21.5306-2.5917,36.0081,1.4018
	C400.7746,158.6876,395.8536,185.0439,369.7458,193.0825z"/>
`);
var __glob_0_42$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": cat
}, Symbol.toStringTag, { value: "Module" }));
var center = _icon_template(`
    <path d="M12,4 L12,20Z M6,10 L18,10 L18,14 L6,14Z" stroke-width="1" />
`);
var __glob_0_43$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": center
}, Symbol.toStringTag, { value: "Module" }));
var chart = _icon_template(`<path d="M9 17H7v-7h2v7zm4 0h-2V7h2v10zm4 0h-2v-4h2v4zm2.5 2.1h-15V5h15v14.1zm0-16.1h-15c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h15c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2z"/>`);
var __glob_0_44$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": chart
}, Symbol.toStringTag, { value: "Module" }));
var check$1 = _icon_template(`<path d="M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41z"/>`);
var __glob_0_45$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": check$1
}, Symbol.toStringTag, { value: "Module" }));
var chevron_left = _icon_template(`<path d="M15.41 7.41L14 6l-6 6 6 6 1.41-1.41L10.83 12z"/>`);
var __glob_0_46$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": chevron_left
}, Symbol.toStringTag, { value: "Module" }));
var chevron_right = _icon_template(`
    <path d="M10 6L8.59 7.41 13.17 12l-4.58 4.59L10 18l6-6-6-6z"/>
`);
var __glob_0_47$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": chevron_right
}, Symbol.toStringTag, { value: "Module" }));
var circle = _icon_template(`<path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8z"/>`);
var __glob_0_48$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": circle
}, Symbol.toStringTag, { value: "Module" }));
var close = _icon_template(`<path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/>`);
var __glob_0_49$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": close
}, Symbol.toStringTag, { value: "Module" }));
var code = _icon_template(`<path d="M9.4 16.6L4.8 12l4.6-4.6L8 6l-6 6 6 6 1.4-1.4zm5.2 0l4.6-4.6-4.6-4.6L16 6l6 6-6 6-1.4-1.4z"/>`);
var __glob_0_50$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": code
}, Symbol.toStringTag, { value: "Module" }));
var color$1 = _icon_template(`<path d="M12 3c-4.97 0-9 4.03-9 9s4.03 9 9 9c.83 0 1.5-.67 1.5-1.5 0-.39-.15-.74-.39-1.01-.23-.26-.38-.61-.38-.99 0-.83.67-1.5 1.5-1.5H16c2.76 0 5-2.24 5-5 0-4.42-4.03-8-9-8zm-5.5 9c-.83 0-1.5-.67-1.5-1.5S5.67 9 6.5 9 8 9.67 8 10.5 7.33 12 6.5 12zm3-4C8.67 8 8 7.33 8 6.5S8.67 5 9.5 5s1.5.67 1.5 1.5S10.33 8 9.5 8zm5 0c-.83 0-1.5-.67-1.5-1.5S13.67 5 14.5 5s1.5.67 1.5 1.5S15.33 8 14.5 8zm3 4c-.83 0-1.5-.67-1.5-1.5S16.67 9 17.5 9s1.5.67 1.5 1.5-.67 1.5-1.5 1.5z"/>`);
var __glob_0_51$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": color$1
}, Symbol.toStringTag, { value: "Module" }));
var color_lens = _icon_template(`<path d="M12 3c-4.97 0-9 4.03-9 9s4.03 9 9 9c.83 0 1.5-.67 1.5-1.5 0-.39-.15-.74-.39-1.01-.23-.26-.38-.61-.38-.99 0-.83.67-1.5 1.5-1.5H16c2.76 0 5-2.24 5-5 0-4.42-4.03-8-9-8zm-5.5 9c-.83 0-1.5-.67-1.5-1.5S5.67 9 6.5 9 8 9.67 8 10.5 7.33 12 6.5 12zm3-4C8.67 8 8 7.33 8 6.5S8.67 5 9.5 5s1.5.67 1.5 1.5S10.33 8 9.5 8zm5 0c-.83 0-1.5-.67-1.5-1.5S13.67 5 14.5 5s1.5.67 1.5 1.5S15.33 8 14.5 8zm3 4c-.83 0-1.5-.67-1.5-1.5S16.67 9 17.5 9s1.5.67 1.5 1.5-.67 1.5-1.5 1.5z"/>`);
var __glob_0_52$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": color_lens
}, Symbol.toStringTag, { value: "Module" }));
var control_point = _icon_template(`<path d="M13 7h-2v4H7v2h4v4h2v-4h4v-2h-4V7zm-1-5C6.49 2 2 6.49 2 12s4.49 10 10 10 10-4.49 10-10S17.51 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8z"/>`);
var __glob_0_53$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": control_point
}, Symbol.toStringTag, { value: "Module" }));
var copy = _icon_template(`<path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12V1zm-1 4l6 6v10c0 1.1-.9 2-2 2H7.99C6.89 23 6 22.1 6 21l.01-14c0-1.1.89-2 1.99-2h7zm-1 7h5.5L14 6.5V12z"/>`);
var __glob_0_54$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": copy
}, Symbol.toStringTag, { value: "Module" }));
var create_folder = _icon_template(`
    <path d="M22 6H12l-2-2H2v16h20V6zm-3 8h-3v3h-2v-3h-3v-2h3V9h2v3h3v2z"/>
`);
var __glob_0_55$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": create_folder
}, Symbol.toStringTag, { value: "Module" }));
var cube = _icon_template(`<path d="M21 16.5a1 1 0 0 1-.527.881l-7.907 4.443a.996.996 0 0 1-1.132 0l-7.907-4.443A1 1 0 0 1 3 16.5v-9a1 1 0 0 1 .527-.881l7.907-4.443a.995.995 0 0 1 1.132 0l7.907 4.443A1 1 0 0 1 21 7.5v9zM12 4.15L6.042 7.5l5.96 3.35 5.958-3.35-5.958-3.35zM5 15.916l6 3.372V12.58L5 9.209v6.706zm14 0V9.209l-6 3.372v6.707l6-3.373z" />`);
var __glob_0_56$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": cube
}, Symbol.toStringTag, { value: "Module" }));
var cylinder = _icon_template(`
<g class="cylinder">
<path d="M 12 0 C 7.636719 0 3 1.226562 3 3.5 L 3 20.5 C 3 22.773438 7.636719 24 12 24 C 16.363281 24 21 22.773438 21 20.5 L 21 3.5 C 21 1.226562 16.363281 0 12 0 Z M 20 19.121094 C 19.921875 19.140625 19.84375 19.171875 19.78125 19.230469 C 19.574219 19.414062 19.554688 19.726562 19.738281 19.933594 C 19.914062 20.128906 20 20.320312 20 20.5 C 20 21.542969 16.957031 23 12 23 C 7.042969 23 4 21.542969 4 20.5 C 4 20.320312 4.085938 20.128906 4.261719 19.933594 C 4.445312 19.726562 4.425781 19.410156 4.21875 19.226562 C 4.15625 19.171875 4.078125 19.140625 4 19.121094 L 4 5.160156 C 5.59375 6.363281 8.863281 7 12 7 C 15.136719 7 18.40625 6.363281 20 5.160156 Z M 12 6 C 7.042969 6 4 4.542969 4 3.5 C 4 2.457031 7.042969 1 12 1 C 16.957031 1 20 2.457031 20 3.5 C 20 4.542969 16.957031 6 12 6 Z M 12 6 "/>
</g>
`);
var __glob_0_57$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": cylinder
}, Symbol.toStringTag, { value: "Module" }));
var dahaze = _icon_template(`<path d="M2 15.5v2h20v-2H2zm0-5v2h20v-2H2zm0-5v2h20v-2H2z"/>`);
var __glob_0_58$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": dahaze
}, Symbol.toStringTag, { value: "Module" }));
var dark$1 = _icon_template(`<path d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"/>`);
var __glob_0_59$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": dark$1
}, Symbol.toStringTag, { value: "Module" }));
var delete_forever = _icon_template(`<path d="M6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7H6v12zm2.46-7.12l1.41-1.41L12 12.59l2.12-2.12 1.41 1.41L13.41 14l2.12 2.12-1.41 1.41L12 15.41l-2.12 2.12-1.41-1.41L10.59 14l-2.13-2.12zM15.5 4l-1-1h-5l-1 1H5v2h14V4z"/>`);
var __glob_0_60$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": delete_forever
}, Symbol.toStringTag, { value: "Module" }));
var device_hub = _icon_template(`<path d="M17 16l-4-4V8.82C14.16 8.4 15 7.3 15 6c0-1.66-1.34-3-3-3S9 4.34 9 6c0 1.3.84 2.4 2 2.82V12l-4 4H3v5h5v-3.05l4-4.2 4 4.2V21h5v-5h-4z"/>`);
var __glob_0_61$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": device_hub
}, Symbol.toStringTag, { value: "Module" }));
var diffuse = _icon_template(`<path d="M5 14.5h14v-6H5v6zM11 .55V3.5h2V.55h-2zm8.04 2.5l-1.79 1.79 1.41 1.41 1.8-1.79-1.42-1.41zM13 22.45V19.5h-2v2.95h2zm7.45-3.91l-1.8-1.79-1.41 1.41 1.79 1.8 1.42-1.42zM3.55 4.46l1.79 1.79 1.41-1.41-1.79-1.79-1.41 1.41zm1.41 15.49l1.79-1.8-1.41-1.41-1.79 1.79 1.41 1.42z"/>`);
var __glob_0_62$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": diffuse
}, Symbol.toStringTag, { value: "Module" }));
function direction(transform2 = "") {
  return _icon_template(`
        <g transform='${transform2}'><path fill='#fff' d='M2.6 5.6L0 8.3 2.6 11l1.2-1.2-.5-.5h9.4l-.5.5 1.2 1.2L16 8.3l-2.6-2.7-1.2 1.2.5.5H3.3l.5-.5-1.2-1.2z'/><path fill='#231f20' d='M5.1 279h-4v1h5v-5h-1zm5 0v5h-5v1h5v5h1v-5h5v-1h-5v-5z'/><path fill='#fff' d='M.6 278.5h4v-4h2v6h-6zm4.5.5h-4v1h5v-5h-1zm4.5-.5h2v5h5v2h-5v5h-2v-5h-5v-2h5zm.5 5.5h-5v1h5v5h1v-5h5v-1h-5v-5h-1z'/><path fill='#000' d='M2.6 6.3l-2 2 2 2 .6-.5-1-1H14l-1 1 .5.5 2-2-2-2-.5.5 1 1H2.1l1-1-.5-.5z'/></g>
    `, { width: 24, height: 24, viewBoxWidth: 16, viewBoxHeight: 16 });
}
var __glob_0_63$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": direction
}, Symbol.toStringTag, { value: "Module" }));
var doc = _icon_template(`<path d="M6 2c-1.1 0-1.99.9-1.99 2L4 20c0 1.1.89 2 1.99 2H18c1.1 0 2-.9 2-2V8l-6-6H6zm7 7V3.5L18.5 9H13z"/>`);
var __glob_0_64$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": doc
}, Symbol.toStringTag, { value: "Module" }));
var drag_handle = _icon_template(`<path d="M20 9H4v2h16V9zM4 15h16v-2H4v2z"/>`);
var __glob_0_65$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": drag_handle
}, Symbol.toStringTag, { value: "Module" }));
var drag_indicator = _icon_template(`<path d="M11 18c0 1.1-.9 2-2 2s-2-.9-2-2 .9-2 2-2 2 .9 2 2zm-2-8c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm0-6c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm6 4c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2zm0 2c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm0 6c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2z"/>`);
var __glob_0_66$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": drag_indicator
}, Symbol.toStringTag, { value: "Module" }));
var draw = _icon_template(`<path d="M18.85,10.39l1.06-1.06c0.78-0.78,0.78-2.05,0-2.83L18.5,5.09c-0.78-0.78-2.05-0.78-2.83,0l-1.06,1.06L18.85,10.39z M14.61,11.81L7.41,19H6v-1.41l7.19-7.19L14.61,11.81z M13.19,7.56L4,16.76V21h4.24l9.19-9.19L13.19,7.56L13.19,7.56z M19,17.5 c0,2.19-2.54,3.5-5,3.5c-0.55,0-1-0.45-1-1s0.45-1,1-1c1.54,0,3-0.73,3-1.5c0-0.47-0.48-0.87-1.23-1.2l1.48-1.48 C18.32,15.45,19,16.29,19,17.5z M4.58,13.35C3.61,12.79,3,12.06,3,11c0-1.8,1.89-2.63,3.56-3.36C7.59,7.18,9,6.56,9,6 c0-0.41-0.78-1-2-1C5.74,5,5.2,5.61,5.17,5.64C4.82,6.05,4.19,6.1,3.77,5.76C3.36,5.42,3.28,4.81,3.62,4.38C3.73,4.24,4.76,3,7,3 c2.24,0,4,1.32,4,3c0,1.87-1.93,2.72-3.64,3.47C6.42,9.88,5,10.5,5,11c0,0.31,0.43,0.6,1.07,0.86L4.58,13.35z" />`);
var __glob_0_67$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": draw
}, Symbol.toStringTag, { value: "Module" }));
var east = _icon_template(`<path d="M15,5l-1.41,1.41L18.17,11H2V13h16.17l-4.59,4.59L15,19l7-7L15,5z"/>`);
var __glob_0_68$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": east
}, Symbol.toStringTag, { value: "Module" }));
var edit = _icon_template(`<path d="M3 17.46v3.04c0 .28.22.5.5.5h3.04c.13 0 .26-.05.35-.15L17.81 9.94l-3.75-3.75L3.15 17.1c-.1.1-.15.22-.15.36zM20.71 7.04c.39-.39.39-1.02 0-1.41l-2.34-2.34c-.39-.39-1.02-.39-1.41 0l-1.83 1.83 3.75 3.75 1.83-1.83z"/>`);
var __glob_0_69$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": edit
}, Symbol.toStringTag, { value: "Module" }));
var end = _icon_template(`<path transform="translate(24,0) scale(-1, 1)" d="M14.59,7.41L18.17,11H6v2h12.17l-3.59,3.59L16,18l6-6l-6-6L14.59,7.41z M2,6v12h2V6H2z"/>`);
var __glob_0_70$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": end
}, Symbol.toStringTag, { value: "Module" }));
var exit_to_app = _icon_template(`<path d="M10.09 15.59L11.5 17l5-5-5-5-1.41 1.41L12.67 11H3v2h9.67l-2.58 2.59zM19 3H5c-1.11 0-2 .9-2 2v4h2V5h14v14H5v-4H3v4c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2z"/>`);
var __glob_0_71$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": exit_to_app
}, Symbol.toStringTag, { value: "Module" }));
var expand = _icon_template(`<path d="M16.59 8.59L12 13.17 7.41 8.59 6 10l6 6 6-6z"/>`);
var __glob_0_72$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": expand
}, Symbol.toStringTag, { value: "Module" }));
var expand_more = _icon_template(`<path d="M16.59 8.59L12 13.17 7.41 8.59 6 10l6 6 6-6-1.41-1.41z"/>`);
var __glob_0_73$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": expand_more
}, Symbol.toStringTag, { value: "Module" }));
var _export = _icon_template(`<path d="M9 3L5 6.99h3V14h2V6.99h3L9 3zm7 14.01V10h-2v7.01h-3L15 21l4-3.99h-3z"/>`);
var __glob_0_74$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": _export
}, Symbol.toStringTag, { value: "Module" }));
var face = _icon_template(`<path d="M9 11.75c-.69 0-1.25.56-1.25 1.25s.56 1.25 1.25 1.25 1.25-.56 1.25-1.25-.56-1.25-1.25-1.25zm6 0c-.69 0-1.25.56-1.25 1.25s.56 1.25 1.25 1.25 1.25-.56 1.25-1.25-.56-1.25-1.25-1.25zM12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8 0-.29.02-.58.05-.86 2.36-1.05 4.23-2.98 5.21-5.37C11.07 8.33 14.05 10 17.42 10c.78 0 1.53-.09 2.25-.26.21.71.33 1.47.33 2.26 0 4.41-3.59 8-8 8z"/>`);
var __glob_0_75$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": face
}, Symbol.toStringTag, { value: "Module" }));
var fast_forward = _icon_template(`<path d="M4 18l8.5-6L4 6v12zm9-12v12l8.5-6L13 6z"/>`);
var __glob_0_76$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": fast_forward
}, Symbol.toStringTag, { value: "Module" }));
var fast_rewind = _icon_template(`<path d="M11 18V6l-8.5 6 8.5 6zm.5-6l8.5 6V6l-8.5 6z"/>`);
var __glob_0_77$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": fast_rewind
}, Symbol.toStringTag, { value: "Module" }));
var file_copy = _icon_template(`<path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12V1zm-1 4l6 6v10c0 1.1-.9 2-2 2H7.99C6.89 23 6 22.1 6 21l.01-14c0-1.1.89-2 1.99-2h7zm-1 7h5.5L14 6.5V12z"/>`);
var __glob_0_78$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": file_copy
}, Symbol.toStringTag, { value: "Module" }));
var filter$1 = _icon_template(`<path d="M18.7 12.4c-.28-.16-.57-.29-.86-.4.29-.11.58-.24.86-.4 1.92-1.11 2.99-3.12 3-5.19-1.79-1.03-4.07-1.11-6 0-.28.16-.54.35-.78.54.05-.31.08-.63.08-.95 0-2.22-1.21-4.15-3-5.19C10.21 1.85 9 3.78 9 6c0 .32.03.64.08.95-.24-.2-.5-.39-.78-.55-1.92-1.11-4.2-1.03-6 0 0 2.07 1.07 4.08 3 5.19.28.16.57.29.86.4-.29.11-.58.24-.86.4-1.92 1.11-2.99 3.12-3 5.19 1.79 1.03 4.07 1.11 6 0 .28-.16.54-.35.78-.54-.05.32-.08.64-.08.96 0 2.22 1.21 4.15 3 5.19 1.79-1.04 3-2.97 3-5.19 0-.32-.03-.64-.08-.95.24.2.5.38.78.54 1.92 1.11 4.2 1.03 6 0-.01-2.07-1.08-4.08-3-5.19zM12 16c-2.21 0-4-1.79-4-4s1.79-4 4-4 4 1.79 4 4-1.79 4-4 4z"/>`);
var __glob_0_79$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": filter$1
}, Symbol.toStringTag, { value: "Module" }));
var flag = _icon_template(`<path d="M14.4 6L14 4H5v17h2v-7h5.6l.4 2h7V6z"/>`);
var __glob_0_80$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": flag
}, Symbol.toStringTag, { value: "Module" }));
var flash_on = _icon_template(`<path d="M7 2v11h3v9l7-12h-4l4-8z"/>`);
var __glob_0_81$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": flash_on
}, Symbol.toStringTag, { value: "Module" }));
var flatten = _icon_template(`<path d="M4,9v2h16V9H4z M16,4l-1.41-1.41L13,4.17V1h-2v3.19L9.39,2.61L8,4l4,4L16,4z M4,14h16v-2H4V14z M8,19l1.39,1.39L11,18.81 V22h2v-3.17l1.59,1.59L16,19l-4-4L8,19z"/>`);
var __glob_0_82$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": flatten
}, Symbol.toStringTag, { value: "Module" }));
var flex = _icon_template(`<path d="M3,5v14h18V5H3z M8.33,17H5V7h3.33V17z M13.67,17h-3.33V7h3.33V17z M19,17h-3.33V7H19V17z"/>`);
var __glob_0_83$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": flex
}, Symbol.toStringTag, { value: "Module" }));
var flip = _icon_template(`<path d="M15 21h2v-2h-2v2zm4-12h2V7h-2v2zM3 5v14c0 1.1.9 2 2 2h4v-2H5V5h4V3H5c-1.1 0-2 .9-2 2zm16-2v2h2c0-1.1-.9-2-2-2zm-8 20h2V1h-2v22zm8-6h2v-2h-2v2zM15 5h2V3h-2v2zm4 8h2v-2h-2v2zm0 8c1.1 0 2-.9 2-2h-2v2z"/>`);
var __glob_0_84$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": flip
}, Symbol.toStringTag, { value: "Module" }));
var flipY = _icon_template(`<path d="M15 21h2v-2h-2v2zm4-12h2V7h-2v2zM3 5v14c0 1.1.9 2 2 2h4v-2H5V5h4V3H5c-1.1 0-2 .9-2 2zm16-2v2h2c0-1.1-.9-2-2-2zm-8 20h2V1h-2v22zm8-6h2v-2h-2v2zM15 5h2V3h-2v2zm4 8h2v-2h-2v2zm0 8c1.1 0 2-.9 2-2h-2v2z"/>`);
var __glob_0_85$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": flipY
}, Symbol.toStringTag, { value: "Module" }));
var flip_camera = _icon_template(`
    <path d="M9,12c0,1.66,1.34,3,3,3s3-1.34,3-3s-1.34-3-3-3S9,10.34,9,12z"/>
    <path d="M8,10V8H5.09C6.47,5.61,9.05,4,12,4c3.72,0,6.85,2.56,7.74,6h2.06c-0.93-4.56-4.96-8-9.8-8C8.73,2,5.82,3.58,4,6.01V4H2v6
        H8z"/>
    <path d="M16,14v2h2.91c-1.38,2.39-3.96,4-6.91,4c-3.72,0-6.85-2.56-7.74-6H2.2c0.93,4.56,4.96,8,9.8,8c3.27,0,6.18-1.58,8-4.01V20
        h2v-6H16z"/>
`);
var __glob_0_86$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": flip_camera
}, Symbol.toStringTag, { value: "Module" }));
var folder = _icon_template(`<path d="M10 4H4c-1.1 0-1.99.9-1.99 2L2 18c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V8c0-1.1-.9-2-2-2h-8l-2-2z"/>`);
var __glob_0_87$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": folder
}, Symbol.toStringTag, { value: "Module" }));
var font_download = _icon_template(`<path d="M9.93 13.5h4.14L12 7.98zM20 2H4c-1.1 0-2 .9-2 2v16c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zm-4.05 16.5l-1.14-3H9.17l-1.12 3H5.96l5.11-13h1.86l5.11 13h-2.09z"/>`);
var __glob_0_88$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": font_download
}, Symbol.toStringTag, { value: "Module" }));
var format_bold = _icon_template(`<path d="M15.6 10.79c.97-.67 1.65-1.77 1.65-2.79 0-2.26-1.75-4-4-4H7v14h7.04c2.09 0 3.71-1.7 3.71-3.79 0-1.52-.86-2.82-2.15-3.42zM10 6.5h3c.83 0 1.5.67 1.5 1.5s-.67 1.5-1.5 1.5h-3v-3zm3.5 9H10v-3h3.5c.83 0 1.5.67 1.5 1.5s-.67 1.5-1.5 1.5z"/>`);
var __glob_0_89$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": format_bold
}, Symbol.toStringTag, { value: "Module" }));
var format_indent = _icon_template(`<path d="M3 21h18v-2H3v2zM3 8v8l4-4-4-4zm8 9h10v-2H11v2zM3 3v2h18V3H3zm8 6h10V7H11v2zm0 4h10v-2H11v2z"/>`);
var __glob_0_90$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": format_indent
}, Symbol.toStringTag, { value: "Module" }));
var format_line_spacing = _icon_template(`<path d="M6 7h2.5L5 3.5 1.5 7H4v10H1.5L5 20.5 8.5 17H6V7zm4-2v2h12V5H10zm0 14h12v-2H10v2zm0-6h12v-2H10v2z"/>`);
var __glob_0_91$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": format_line_spacing
}, Symbol.toStringTag, { value: "Module" }));
var format_shapes = _icon_template(`<path d="M23 7V1h-6v2H7V1H1v6h2v10H1v6h6v-2h10v2h6v-6h-2V7h2zM3 3h2v2H3V3zm2 18H3v-2h2v2zm12-2H7v-2H5V7h2V5h10v2h2v10h-2v2zm4 2h-2v-2h2v2zM19 5V3h2v2h-2zm-5.27 9h-3.49l-.73 2H7.89l3.4-9h1.4l3.41 9h-1.63l-.74-2zm-3.04-1.26h2.61L12 8.91l-1.31 3.83z"/>`);
var __glob_0_92$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": format_shapes
}, Symbol.toStringTag, { value: "Module" }));
var format_size = _icon_template(`<path d="M9 4v3h5v12h3V7h5V4H9zm-6 8h3v7h3v-7h3V9H3v3z"/>`);
var __glob_0_93$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": format_size
}, Symbol.toStringTag, { value: "Module" }));
var fullscreen = _icon_template(`<path d="M7 14H5v5h5v-2H7v-3zm-2-4h2V7h3V5H5v5zm12 7h-3v2h5v-5h-2v3zM14 5v2h3v3h2V5h-5z"/>`);
var __glob_0_94$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": fullscreen
}, Symbol.toStringTag, { value: "Module" }));
var gps_fixed = _icon_template(`<path d="M12 8c-2.21 0-4 1.79-4 4s1.79 4 4 4 4-1.79 4-4-1.79-4-4-4zm8.94 3c-.46-4.17-3.77-7.48-7.94-7.94V1h-2v2.06C6.83 3.52 3.52 6.83 3.06 11H1v2h2.06c.46 4.17 3.77 7.48 7.94 7.94V23h2v-2.06c4.17-.46 7.48-3.77 7.94-7.94H23v-2h-2.06zM12 19c-3.87 0-7-3.13-7-7s3.13-7 7-7 7 3.13 7 7-3.13 7-7 7z"/>`);
var __glob_0_95$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": gps_fixed
}, Symbol.toStringTag, { value: "Module" }));
var gradient$2 = _icon_template('<path d="M11 9h2v2h-2zm-2 2h2v2H9zm4 0h2v2h-2zm2-2h2v2h-2zM7 9h2v2H7zm12-6H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zM9 18H7v-2h2v2zm4 0h-2v-2h2v2zm4 0h-2v-2h2v2zm2-7h-2v2h2v2h-2v-2h-2v2h-2v-2h-2v2H9v-2H7v2H5v-2h2v-2H5V5h14v6z"/>');
var __glob_0_96$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": gradient$2
}, Symbol.toStringTag, { value: "Module" }));
var grid$1 = _icon_template(`<path d="M3,3v8h8V3H3z M9,9H5V5h4V9z M3,13v8h8v-8H3z M9,19H5v-4h4V19z M13,3v8h8V3H13z M19,9h-4V5h4V9z M13,13v8h8v-8H13z M19,19h-4v-4h4V19z"/>`);
var __glob_0_97$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": grid$1
}, Symbol.toStringTag, { value: "Module" }));
var grid3x3 = _icon_template(`<path d="M20,10V8h-4V4h-2v4h-4V4H8v4H4v2h4v4H4v2h4v4h2v-4h4v4h2v-4h4v-2h-4v-4H20z M14,14h-4v-4h4V14z"/>`);
var __glob_0_98$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": grid3x3
}, Symbol.toStringTag, { value: "Module" }));
var group = _icon_template(`
        <path d="M3 5h2V3c-1.1 0-2 .9-2 2zm0 8h2v-2H3v2zm4 8h2v-2H7v2zM3 9h2V7H3v2zm10-6h-2v2h2V3zm6 0v2h2c0-1.1-.9-2-2-2zM5 21v-2H3c0 1.1.9 2 2 2zm-2-4h2v-2H3v2zM9 3H7v2h2V3zm2 18h2v-2h-2v2zm8-8h2v-2h-2v2zm0 8c1.1 0 2-.9 2-2h-2v2zm0-12h2V7h-2v2zm0 8h2v-2h-2v2zm-4 4h2v-2h-2v2zm0-16h2V3h-2v2zM7 17h10V7H7v10zm2-8h6v6H9V9z"/>
    `);
var __glob_0_99$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": group
}, Symbol.toStringTag, { value: "Module" }));
var height = _icon_template(`<polygon points="13,6.99 16,6.99 12,3 8,6.99 11,6.99 11,17.01 8,17.01 12,21 16,17.01 13,17.01"/>`);
var __glob_0_100$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": height
}, Symbol.toStringTag, { value: "Module" }));
var highlight_at = _icon_template(`<path d="M17,5h-2V3h2V5z M15,15v6l2.29-2.29L19.59,21L21,19.59l-2.29-2.29L21,15H15z M19,9h2V7h-2V9z M19,13h2v-2h-2V13z M11,21h2 v-2h-2V21z M7,5h2V3H7V5z M3,17h2v-2H3V17z M5,21v-2H3C3,20.1,3.9,21,5,21z M19,3v2h2C21,3.9,20.1,3,19,3z M11,5h2V3h-2V5z M3,9h2 V7H3V9z M7,21h2v-2H7V21z M3,13h2v-2H3V13z M3,5h2V3C3.9,3,3,3.9,3,5z"/>`);
var __glob_0_101$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": highlight_at
}, Symbol.toStringTag, { value: "Module" }));
var horizontal_align_center = _icon_template(`<path d="M8 19h3v4h2v-4h3l-4-4-4 4zm8-14h-3V1h-2v4H8l4 4 4-4zM4 11v2h16v-2H4z" transform="rotate(-90 12 12)" />`);
var __glob_0_102$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": horizontal_align_center
}, Symbol.toStringTag, { value: "Module" }));
var horizontal_distribute = _icon_template(`<path d="M4,22H2V2h2V22z M22,2h-2v20h2V2z M13.5,7h-3v10h3V7z"/>`);
var __glob_0_103$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": horizontal_distribute
}, Symbol.toStringTag, { value: "Module" }));
var horizontal_rule = _icon_template(`<rect fill-rule="evenodd" height="2" width="16" x="4" y="11"/>`);
var __glob_0_104$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": horizontal_rule
}, Symbol.toStringTag, { value: "Module" }));
var image$1 = _icon_template(`<path d="M21 19V5c0-1.1-.9-2-2-2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2zM8.5 13.5l2.5 3.01L14.5 12l4.5 6H5l3.5-4.5z"/>`);
var __glob_0_105$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": image$1
}, Symbol.toStringTag, { value: "Module" }));
var input = _icon_template(`<path d="M21 3.01H3c-1.1 0-2 .9-2 2V9h2V4.99h18v14.03H3V15H1v4.01c0 1.1.9 1.98 2 1.98h18c1.1 0 2-.88 2-1.98v-14c0-1.11-.9-2-2-2zM11 16l4-4-4-4v3H1v2h10v3z"/>`);
var __glob_0_106$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": input
}, Symbol.toStringTag, { value: "Module" }));
var italic = _icon_template(`<path d="M10 4v3h2.21l-3.42 8H6v3h8v-3h-2.21l3.42-8H18V4z"/>`);
var __glob_0_107$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": italic
}, Symbol.toStringTag, { value: "Module" }));
var join_full = _icon_template(`
<g>
    <g>
        <ellipse cx="12" cy="12" rx="3" ry="5.74"/>
        <path d="M7.5,12c0-0.97,0.23-4.16,3.03-6.5C9.75,5.19,8.9,5,8,5c-3.86,0-7,3.14-7,7s3.14,7,7,7c0.9,0,1.75-0.19,2.53-0.5 C7.73,16.16,7.5,12.97,7.5,12z"/><path d="M16,5c-0.9,0-1.75,0.19-2.53,0.5c2.8,2.34,3.03,5.53,3.03,6.5c0,0.97-0.23,4.16-3.03,6.5C14.25,18.81,15.1,19,16,19 c3.86,0,7-3.14,7-7S19.86,5,16,5z"/>
    </g>
</g>
`);
var __glob_0_108$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": join_full
}, Symbol.toStringTag, { value: "Module" }));
var join_right = _icon_template(`
<ellipse cx="12" cy="12" rx="3" ry="5.74"/>
<path d="M16.5,12c0,0.97-0.23,4.16-3.03,6.5C14.25,18.81,15.1,19,16,19c3.86,0,7-3.14,7-7s-3.14-7-7-7c-0.9,0-1.75,0.19-2.53,0.5 C16.27,7.84,16.5,11.03,16.5,12z"/></g><g><path d="M8,19c0.9,0,1.75-0.19,2.53-0.5c-0.61-0.51-1.1-1.07-1.49-1.63C8.71,16.95,8.36,17,8,17c-2.76,0-5-2.24-5-5s2.24-5,5-5 c0.36,0,0.71,0.05,1.04,0.13c0.39-0.56,0.88-1.12,1.49-1.63C9.75,5.19,8.9,5,8,5c-3.86,0-7,3.14-7,7S4.14,19,8,19z"/>
`);
var __glob_0_109$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": join_right
}, Symbol.toStringTag, { value: "Module" }));
var justify_content_space_around = _icon_template(`<path d="M15,7v10H9V7H15z M21,5h-3v14h3V5z M17,5H7v14h10V5z M6,5H3v14h3V5z"/>`);
var __glob_0_110$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": justify_content_space_around
}, Symbol.toStringTag, { value: "Module" }));
var keyboard = _icon_template(`<path d="M20 5H4c-1.1 0-1.99.9-1.99 2L2 17c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm-9 3h2v2h-2V8zm0 3h2v2h-2v-2zM8 8h2v2H8V8zm0 3h2v2H8v-2zm-1 2H5v-2h2v2zm0-3H5V8h2v2zm9 7H8v-2h8v2zm0-4h-2v-2h2v2zm0-3h-2V8h2v2zm3 3h-2v-2h2v2zm0-3h-2V8h2v2z"/>`);
var __glob_0_111$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": keyboard
}, Symbol.toStringTag, { value: "Module" }));
var keyboard_arrow_down = _icon_template(`<path d="M7.41 8.59L12 13.17l4.59-4.58L18 10l-6 6-6-6 1.41-1.41z"/>`);
var __glob_0_112$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": keyboard_arrow_down
}, Symbol.toStringTag, { value: "Module" }));
var keyboard_arrow_left = _icon_template(`<path d="M15.41 16.59L10.83 12l4.58-4.59L14 6l-6 6 6 6 1.41-1.41z"/>`);
var __glob_0_113$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": keyboard_arrow_left
}, Symbol.toStringTag, { value: "Module" }));
var keyboard_arrow_right = _icon_template(`<path d="M8.59 16.59L13.17 12 8.59 7.41 10 6l6 6-6 6-1.41-1.41z"/>`);
var __glob_0_114$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": keyboard_arrow_right
}, Symbol.toStringTag, { value: "Module" }));
var keyboard_arrow_up = _icon_template(`<path d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6 1.41 1.41z"/>`);
var __glob_0_115$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": keyboard_arrow_up
}, Symbol.toStringTag, { value: "Module" }));
var landscape = _icon_template(`<path d="M14 6l-3.75 5 2.85 3.8-1.6 1.2C9.81 13.75 7 10 7 10l-6 8h22L14 6z"/>`);
var __glob_0_116$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": landscape
}, Symbol.toStringTag, { value: "Module" }));
var launch = _icon_template(`
        <path d="M19 19H5V5h7V3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2v-7h-2v7zM14 3v2h3.59l-9.83 9.83 1.41 1.41L19 6.41V10h2V3h-7z"/>
    `);
var __glob_0_117$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": launch
}, Symbol.toStringTag, { value: "Module" }));
var layers = _icon_template(`<path d="M11.99 18.54l-7.37-5.73L3 14.07l9 7 9-7-1.63-1.27-7.38 5.74zM12 16l7.36-5.73L21 9l-9-7-9 7 1.63 1.27L12 16z"/>`);
var __glob_0_118$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": layers
}, Symbol.toStringTag, { value: "Module" }));
var layout_default = _icon_template(`<path d="M19 7h-8v6h8V7zm-2 4h-4V9h4v2zm4-8H3c-1.1 0-2 .9-2 2v14c0 1.1.9 1.98 2 1.98h18c1.1 0 2-.88 2-1.98V5c0-1.1-.9-2-2-2zm0 16.01H3V4.98h18v14.03z"/>`);
var __glob_0_119$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": layout_default
}, Symbol.toStringTag, { value: "Module" }));
var layout_flex = _icon_template(`<path d="M20,4H4C2.9,4,2,4.9,2,6v12c0,1.1,0.9,2,2,2h16c1.1,0,2-0.9,2-2V6C22,4.9,21.1,4,20,4z M8,18H4V6h4V18z M14,18h-4V6h4V18z M20,18h-4V6h4V18z"/>`);
var __glob_0_120$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": layout_flex
}, Symbol.toStringTag, { value: "Module" }));
var layout_grid = _icon_template(`<path d="M3,3v8h8V3H3z M9,9H5V5h4V9z M3,13v8h8v-8H3z M9,19H5v-4h4V19z M13,3v8h8V3H13z M19,9h-4V5h4V9z M13,13v8h8v-8H13z M19,19h-4v-4h4V19z"/>`);
var __glob_0_121 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": layout_grid
}, Symbol.toStringTag, { value: "Module" }));
var left = _icon_template(`<path d="M2,4 L2,20Z M6,10 L16,10 L16,14 L6,14Z" stroke-width="1" />`);
var __glob_0_122 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": left
}, Symbol.toStringTag, { value: "Module" }));
var left_hide = _icon_template(`<path d="M18.41 16.59L13.82 12l4.59-4.59L17 6l-6 6 6 6zM6 6h2v12H6z"/>`);
var __glob_0_123 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": left_hide
}, Symbol.toStringTag, { value: "Module" }));
var lens = _icon_template(`<path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2z"/>`);
var __glob_0_124 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": lens
}, Symbol.toStringTag, { value: "Module" }));
var light$1 = _icon_template(`<path d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"/>`);
var __glob_0_125 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": light$1
}, Symbol.toStringTag, { value: "Module" }));
var line_cap_butt = _icon_template(`
        <rect class="base" width="13" height="12" x="3" y="2" fill="transparent" fill-rule="nonzero"></rect>
        <path fill="currentColor" fill-rule="nonzero" d="M3.5,6.06300874 C4.20280365,6.2438979 4.7561021,6.79719635 4.93699126,7.5 L16,7.5 L16,8.5 L4.93699126,8.5 C4.7561021,9.20280365 4.20280365,9.7561021 3.5,9.93699126 L3.5,13.5 L16,13.5 L16,14.5 L2.5,14.5 L2.5,9.93699126 C1.63738639,9.71496986 1,8.93191971 1,8 C1,7.06808029 1.63738639,6.28503014 2.5,6.06300874 L2.5,1.5 L16,1.5 L16,2.5 L3.5,2.5 L3.5,6.06300874 Z"></path>
    `, { width: 18, height: 16 });
var __glob_0_126 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": line_cap_butt
}, Symbol.toStringTag, { value: "Module" }));
var line_cap_round = _icon_template(`
        <path class="base" fill="transparent" fill-rule="nonzero" d="M8,2 L16,2 L16,14 L8,14 C4.6862915,14 2,11.3137085 2,8 L2,8 C2,4.6862915 4.6862915,2 8,2 Z"></path>
        <path fill="currentColor" fill-rule="nonzero" d="M9.93699126,8.5 C9.71496986,9.36261361 8.93191971,10 8,10 C6.8954305,10 6,9.1045695 6,8 C6,6.8954305 6.8954305,6 8,6 C8.93191971,6 9.71496986,6.63738639 9.93699126,7.5 L16,7.5 L16,8.5 L9.93699126,8.5 Z M16,13.5 L16,14.5 L8,14.5 C4.41014913,14.5 1.5,11.5898509 1.5,8 C1.5,4.41014913 4.41014913,1.5 8,1.5 L16,1.5 L16,2.5 L8,2.5 C4.96243388,2.5 2.5,4.96243388 2.5,8 C2.5,11.0375661 4.96243388,13.5 8,13.5 L16,13.5 Z"></path>
    `, { width: 18, height: 16 });
var __glob_0_127 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": line_cap_round
}, Symbol.toStringTag, { value: "Module" }));
var line_cap_square = _icon_template(`
        <rect class="base" width="14" height="12" x="2" y="2" fill="transparent" fill-rule="nonzero"></rect>
        <path fill="currentColor" fill-rule="nonzero" d="M9.93699126,8.5 C9.71496986,9.36261361 8.93191971,10 8,10 C6.8954305,10 6,9.1045695 6,8 C6,6.8954305 6.8954305,6 8,6 C8.93191971,6 9.71496986,6.63738639 9.93699126,7.5 L16,7.5 L16,8.5 L9.93699126,8.5 Z M2.5,13.5 L16,13.5 L16,14.5 L1.5,14.5 L1.5,1.5 L16,1.5 L16,2.5 L2.5,2.5 L2.5,13.5 Z"></path>
    `, { width: 18, height: 16 });
var __glob_0_128 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": line_cap_square
}, Symbol.toStringTag, { value: "Module" }));
var line_chart = _icon_template(`<path d="M3.5 18.49l6-6.01 4 4L22 6.92l-1.41-1.41-7.09 7.97-4-4L2 16.99z"/>`);
var __glob_0_129 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": line_chart
}, Symbol.toStringTag, { value: "Module" }));
var line_join_bevel = _icon_template(`<g fill="none" fill-rule="evenodd"><polygon class="base" fill="transparent" fill-rule="nonzero" points="2 14.5 2 7.538 7.382 1.5 16 1.5 16 14.5"></polygon><path fill="currentColor" fill-rule="nonzero" d="M2.96551724,7.95245414 L2.96551724,14.5 L2,14.5 L2,7.53775146 L7.38172454,1.5 L16,1.5 L16,2.46 L7.76471206,2.46 L2.96551724,7.95245414 Z M10.9369913,9 C10.7561021,9.70280365 10.2028036,10.2561021 9.5,10.4369913 L9.5,14.5 L8.5,14.5 L8.5,10.4369913 C7.63738639,10.2149699 7,9.43191971 7,8.5 C7,7.3954305 7.8954305,6.5 9,6.5 C9.93191971,6.5 10.7149699,7.13738639 10.9369913,8 L16,8 L16,9 L10.9369913,9 Z"></path></g>`, { width: 18, height: 16 });
var __glob_0_130 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": line_join_bevel
}, Symbol.toStringTag, { value: "Module" }));
var line_join_miter = _icon_template(`<g fill="none" fill-rule="evenodd"><rect class="base" width="14" height="13" x="2" y="1.5" fill="transparent" fill-rule="nonzero"></rect><path fill="currentColor" fill-rule="nonzero" d="M10.9369913,9 C10.7561021,9.70280365 10.2028036,10.2561021 9.5,10.4369913 L9.5,14.5 L8.5,14.5 L8.5,10.4369913 C7.63738639,10.2149699 7,9.43191971 7,8.5 C7,7.3954305 7.8954305,6.5 9,6.5 C9.93191971,6.5 10.7149699,7.13738639 10.9369913,8 L16,8 L16,9 L10.9369913,9 Z M3,2.5 L3,14.5 L2,14.5 L2,1.5 L16,1.5 L16,2.5 L3,2.5 Z"></path></g>`, { width: 18, height: 16 });
var __glob_0_131 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": line_join_miter
}, Symbol.toStringTag, { value: "Module" }));
var line_join_round = _icon_template(`<g fill="none" fill-rule="evenodd"><path class="base" fill="transparent" fill-rule="nonzero" d="M9,1.5 L16,1.5 L16,14.5 L2,14.5 L2,8.5 C2,4.63400675 5.13400675,1.5 9,1.5 Z"></path><path fill="currentColor" fill-rule="nonzero" d="M2.96551724,14.5 L2,14.5 L2,7.74 C2,4.29374316 4.80979916,1.5 8.27586207,1.5 L16,1.5 L16,2.46 L8.27586207,2.46 C5.3430396,2.46 2.96551724,4.82393652 2.96551724,7.74 L2.96551724,14.5 Z M10.9369913,9 C10.7561021,9.70280365 10.2028036,10.2561021 9.5,10.4369913 L9.5,14.5 L8.5,14.5 L8.5,10.4369913 C7.63738639,10.2149699 7,9.43191971 7,8.5 C7,7.3954305 7.8954305,6.5 9,6.5 C9.93191971,6.5 10.7149699,7.13738639 10.9369913,8 L16,8 L16,9 L10.9369913,9 Z"></path></g>`, { width: 18, height: 16 });
var __glob_0_132 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": line_join_round
}, Symbol.toStringTag, { value: "Module" }));
var line_style = _icon_template(`<path d="M3 16h5v-2H3v2zm6.5 0h5v-2h-5v2zm6.5 0h5v-2h-5v2zM3 20h2v-2H3v2zm4 0h2v-2H7v2zm4 0h2v-2h-2v2zm4 0h2v-2h-2v2zm4 0h2v-2h-2v2zM3 12h8v-2H3v2zm10 0h8v-2h-8v2zM3 4v4h18V4H3z"/>`);
var __glob_0_133 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": line_style
}, Symbol.toStringTag, { value: "Module" }));
var line_weight = _icon_template(`<path d="M3 17h18v-2H3v2zm0 3h18v-1H3v1zm0-7h18v-3H3v3zm0-9v4h18V4H3z"/>`);
var __glob_0_134 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": line_weight
}, Symbol.toStringTag, { value: "Module" }));
var list = _icon_template(`<path d="M4 14h4v-4H4v4zm0 5h4v-4H4v4zM4 9h4V5H4v4zm5 5h12v-4H9v4zm0 5h12v-4H9v4zM9 5v4h12V5H9z"/>`);
var __glob_0_135 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": list
}, Symbol.toStringTag, { value: "Module" }));
var local_library = _icon_template(`<path d="M12 11.55C9.64 9.35 6.48 8 3 8v11c3.48 0 6.64 1.35 9 3.55 2.36-2.19 5.52-3.55 9-3.55V8c-3.48 0-6.64 1.35-9 3.55zM12 8c1.66 0 3-1.34 3-3s-1.34-3-3-3-3 1.34-3 3 1.34 3 3 3z"/>`);
var __glob_0_136 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": local_library
}, Symbol.toStringTag, { value: "Module" }));
var local_movie = _icon_template(`<path d="M18 3v2h-2V3H8v2H6V3H4v18h2v-2h2v2h8v-2h2v2h2V3h-2zM8 17H6v-2h2v2zm0-4H6v-2h2v2zm0-4H6V7h2v2zm10 8h-2v-2h2v2zm0-4h-2v-2h2v2zm0-4h-2V7h2v2z"/>`);
var __glob_0_137 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": local_movie
}, Symbol.toStringTag, { value: "Module" }));
var lock = _icon_template(`<path d="M18 8h-1V6c0-2.76-2.24-5-5-5S7 3.24 7 6v2H6c-1.1 0-2 .9-2 2v10c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V10c0-1.1-.9-2-2-2zm-6 9c-1.1 0-2-.9-2-2s.9-2 2-2 2 .9 2 2-.9 2-2 2zm3.1-9H8.9V6c0-1.71 1.39-3.1 3.1-3.1 1.71 0 3.1 1.39 3.1 3.1v2z"/>`);
var __glob_0_138 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": lock
}, Symbol.toStringTag, { value: "Module" }));
var lock_open = _icon_template(`<path d="M12 17c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2zm6-9h-1V6c0-2.76-2.24-5-5-5S7 3.24 7 6h1.9c0-1.71 1.39-3.1 3.1-3.1 1.71 0 3.1 1.39 3.1 3.1v2H6c-1.1 0-2 .9-2 2v10c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V10c0-1.1-.9-2-2-2zm0 12H6V10h12v10z"/>`);
var __glob_0_139 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": lock_open
}, Symbol.toStringTag, { value: "Module" }));
var looks = _icon_template(`<path d="M12 10c-3.86 0-7 3.14-7 7h2c0-2.76 2.24-5 5-5s5 2.24 5 5h2c0-3.86-3.14-7-7-7zm0-4C5.93 6 1 10.93 1 17h2c0-4.96 4.04-9 9-9s9 4.04 9 9h2c0-6.07-4.93-11-11-11z"/>`);
var __glob_0_140 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": looks
}, Symbol.toStringTag, { value: "Module" }));
var margin = _icon_template(`<path d="M3,3v18h18V3H3z M19,19H5V5h14V19z M11,7h2v2h-2V7z M7,7h2v2H7V7z M15,7h2v2h-2V7z M7,11h2v2H7V11z M11,11h2v2h-2V11z M15,11h2v2h-2V11z"/>`);
var __glob_0_141 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": margin
}, Symbol.toStringTag, { value: "Module" }));
var merge = _icon_template(`<path d="M17 20.41L18.41 19 15 15.59 13.59 17 17 20.41zM7.5 8H11v5.59L5.59 19 7 20.41l6-6V8h3.5L12 3.5 7.5 8z"/>`);
var __glob_0_142 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": merge
}, Symbol.toStringTag, { value: "Module" }));
var middle = _icon_template(`<path d="M4,12 L20,12Z M10,8 L10,16 L14,16 L14,8Z" stroke-width="1" />`);
var __glob_0_143 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": middle
}, Symbol.toStringTag, { value: "Module" }));
var navigation = _icon_template(`<path d="M12 2L4.5 20.29l.71.71L12 18l6.79 3 .71-.71z" transform="rotate(-30 12 12)" stroke-width="1" fill="transparent"/>`);
var __glob_0_144 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": navigation
}, Symbol.toStringTag, { value: "Module" }));
var near_me = _icon_template(`<path d="M21 3L3 10.53v.98l6.84 2.65L12.48 21h.98L21 3z"/>`);
var __glob_0_145 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": near_me
}, Symbol.toStringTag, { value: "Module" }));
var north = _icon_template(`<path d="M5,9l1.41,1.41L11,5.83V22H13V5.83l4.59,4.59L19,9l-7-7L5,9z"/>`);
var __glob_0_146 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": north
}, Symbol.toStringTag, { value: "Module" }));
var note = _icon_template(`<path d="M17 10H7v2h10v-2zm2-7h-1V1h-2v2H8V1H6v2H5c-1.11 0-1.99.9-1.99 2L3 19c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm0 16H5V8h14v11zm-5-5H7v2h7v-2z"/>`);
var __glob_0_147 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": note
}, Symbol.toStringTag, { value: "Module" }));
var nowrap = _icon_template(`<path d="M14 17H4v2h10v-2zm6-8H4v2h16V9zM4 15h16v-2H4v2zM4 5v2h16V5H4z"/>`);
var __glob_0_148 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": nowrap
}, Symbol.toStringTag, { value: "Module" }));
var opacity = _icon_template(`<path d="M17.66 8L12 2.35 6.34 8C4.78 9.56 4 11.64 4 13.64s.78 4.11 2.34 5.67 3.61 2.35 5.66 2.35 4.1-.79 5.66-2.35S20 15.64 20 13.64 19.22 9.56 17.66 8zM6 14c.01-2 .62-3.27 1.76-4.4L12 5.27l4.24 4.38C17.38 10.77 17.99 12 18 14H6z"/>`);
var __glob_0_149 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": opacity
}, Symbol.toStringTag, { value: "Module" }));
var outline = _icon_template(`
    <path d="M19.77 4.93l1.4 1.4L8.43 19.07l-5.6-5.6 1.4-1.4 4.2 4.2L19.77 4.93m0-2.83L8.43 13.44l-4.2-4.2L0 13.47l8.43 8.43L24 6.33 19.77 2.1z"/>
`);
var __glob_0_150 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": outline
}, Symbol.toStringTag, { value: "Module" }));
var outline_circle = _icon_template(`<path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8z"/>`);
var __glob_0_151 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": outline_circle
}, Symbol.toStringTag, { value: "Module" }));
var outline_image = _icon_template(`<path d="M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm0 16H5V5h14v14zm-5.04-6.71l-2.75 3.54-1.96-2.36L6.5 17h11l-3.54-4.71z"/>`);
var __glob_0_152 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": outline_image
}, Symbol.toStringTag, { value: "Module" }));
var outline_rect = _icon_template(`<path d="M19 5v14H5V5h14m0-2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2z"/>`);
var __glob_0_153 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": outline_rect
}, Symbol.toStringTag, { value: "Module" }));
var outline_shape = _icon_template(`<path d="M2 12C2 6.48 6.48 2 12 2s10 4.48 10 10-4.48 10-10 10S2 17.52 2 12zm10 6c3.31 0 6-2.69 6-6s-2.69-6-6-6-6 2.69-6 6 2.69 6 6 6z"/>`);
var __glob_0_154 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": outline_shape
}, Symbol.toStringTag, { value: "Module" }));
var padding = _icon_template(`<path d="M3 5h2V3c-1.1 0-2 .9-2 2zm0 8h2v-2H3v2zm4 8h2v-2H7v2zM3 9h2V7H3v2zm10-6h-2v2h2V3zm6 0v2h2c0-1.1-.9-2-2-2zM5 21v-2H3c0 1.1.9 2 2 2zm-2-4h2v-2H3v2zM9 3H7v2h2V3zm2 18h2v-2h-2v2zm8-8h2v-2h-2v2zm0 8c1.1 0 2-.9 2-2h-2v2zm0-12h2V7h-2v2zm0 8h2v-2h-2v2zm-4 4h2v-2h-2v2zm0-16h2V3h-2v2zM7 17h10V7H7v10zm2-8h6v6H9V9z"/>`);
var __glob_0_155 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": padding
}, Symbol.toStringTag, { value: "Module" }));
var paint = _icon_template(`<path d="M18 4V3c0-.55-.45-1-1-1H5c-.55 0-1 .45-1 1v4c0 .55.45 1 1 1h12c.55 0 1-.45 1-1V6h1v4H9v11c0 .55.45 1 1 1h2c.55 0 1-.45 1-1v-9h8V4h-3z"/>`);
var __glob_0_156 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": paint
}, Symbol.toStringTag, { value: "Module" }));
var palette = _icon_template(`<path d="M12 3c-4.97 0-9 4.03-9 9s4.03 9 9 9c.83 0 1.5-.67 1.5-1.5 0-.39-.15-.74-.39-1.01-.23-.26-.38-.61-.38-.99 0-.83.67-1.5 1.5-1.5H16c2.76 0 5-2.24 5-5 0-4.42-4.03-8-9-8zm-5.5 9c-.83 0-1.5-.67-1.5-1.5S5.67 9 6.5 9 8 9.67 8 10.5 7.33 12 6.5 12zm3-4C8.67 8 8 7.33 8 6.5S8.67 5 9.5 5s1.5.67 1.5 1.5S10.33 8 9.5 8zm5 0c-.83 0-1.5-.67-1.5-1.5S13.67 5 14.5 5s1.5.67 1.5 1.5S15.33 8 14.5 8zm3 4c-.83 0-1.5-.67-1.5-1.5S16.67 9 17.5 9s1.5.67 1.5 1.5-.67 1.5-1.5 1.5z"/>`);
var __glob_0_157 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": palette
}, Symbol.toStringTag, { value: "Module" }));
var pantool = _icon_template(`<path d="M23,5.5V20c0,2.2-1.8,4-4,4h-7.3c-1.08,0-2.1-0.43-2.85-1.19L1,14.83c0,0,1.26-1.23,1.3-1.25 c0.22-0.19,0.49-0.29,0.79-0.29c0.22,0,0.42,0.06,0.6,0.16C3.73,13.46,8,15.91,8,15.91V4c0-0.83,0.67-1.5,1.5-1.5S11,3.17,11,4v7 h1V1.5C12,0.67,12.67,0,13.5,0S15,0.67,15,1.5V11h1V2.5C16,1.67,16.67,1,17.5,1S19,1.67,19,2.5V11h1V5.5C20,4.67,20.67,4,21.5,4 S23,4.67,23,5.5z"/>`);
var __glob_0_158 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": pantool
}, Symbol.toStringTag, { value: "Module" }));
var pattern_check = _icon_template(`<path d="M4 8h4V4H4v4zm6 12h4v-4h-4v4zm-6 0h4v-4H4v4zm0-6h4v-4H4v4zm6 0h4v-4h-4v4zm6-10v4h4V4h-4zm-6 4h4V4h-4v4zm6 6h4v-4h-4v4zm0 6h4v-4h-4v4z"/>`);
var __glob_0_159 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": pattern_check
}, Symbol.toStringTag, { value: "Module" }));
var pattern_cross_dot = _icon_template(`<path d="M6,13c-0.55,0-1,0.45-1,1s0.45,1,1,1s1-0.45,1-1S6.55,13,6,13z M6,17c-0.55,0-1,0.45-1,1s0.45,1,1,1s1-0.45,1-1 S6.55,17,6,17z M6,9c-0.55,0-1,0.45-1,1s0.45,1,1,1s1-0.45,1-1S6.55,9,6,9z M3,9.5c-0.28,0-0.5,0.22-0.5,0.5s0.22,0.5,0.5,0.5 s0.5-0.22,0.5-0.5S3.28,9.5,3,9.5z M6,5C5.45,5,5,5.45,5,6s0.45,1,1,1s1-0.45,1-1S6.55,5,6,5z M21,10.5c0.28,0,0.5-0.22,0.5-0.5 S21.28,9.5,21,9.5s-0.5,0.22-0.5,0.5S20.72,10.5,21,10.5z M14,7c0.55,0,1-0.45,1-1s-0.45-1-1-1s-1,0.45-1,1S13.45,7,14,7z M14,3.5 c0.28,0,0.5-0.22,0.5-0.5S14.28,2.5,14,2.5S13.5,2.72,13.5,3S13.72,3.5,14,3.5z M3,13.5c-0.28,0-0.5,0.22-0.5,0.5 s0.22,0.5,0.5,0.5s0.5-0.22,0.5-0.5S3.28,13.5,3,13.5z M10,20.5c-0.28,0-0.5,0.22-0.5,0.5s0.22,0.5,0.5,0.5s0.5-0.22,0.5-0.5 S10.28,20.5,10,20.5z M10,3.5c0.28,0,0.5-0.22,0.5-0.5S10.28,2.5,10,2.5S9.5,2.72,9.5,3S9.72,3.5,10,3.5z M10,7c0.55,0,1-0.45,1-1 s-0.45-1-1-1S9,5.45,9,6S9.45,7,10,7z M10,12.5c-0.83,0-1.5,0.67-1.5,1.5s0.67,1.5,1.5,1.5s1.5-0.67,1.5-1.5S10.83,12.5,10,12.5z M18,13c-0.55,0-1,0.45-1,1s0.45,1,1,1s1-0.45,1-1S18.55,13,18,13z M18,17c-0.55,0-1,0.45-1,1s0.45,1,1,1s1-0.45,1-1 S18.55,17,18,17z M18,9c-0.55,0-1,0.45-1,1s0.45,1,1,1s1-0.45,1-1S18.55,9,18,9z M18,5c-0.55,0-1,0.45-1,1s0.45,1,1,1s1-0.45,1-1 S18.55,5,18,5z M21,13.5c-0.28,0-0.5,0.22-0.5,0.5s0.22,0.5,0.5,0.5s0.5-0.22,0.5-0.5S21.28,13.5,21,13.5z M14,17 c-0.55,0-1,0.45-1,1s0.45,1,1,1s1-0.45,1-1S14.55,17,14,17z M14,20.5c-0.28,0-0.5,0.22-0.5,0.5s0.22,0.5,0.5,0.5s0.5-0.22,0.5-0.5 S14.28,20.5,14,20.5z M10,8.5c-0.83,0-1.5,0.67-1.5,1.5s0.67,1.5,1.5,1.5s1.5-0.67,1.5-1.5S10.83,8.5,10,8.5z M10,17 c-0.55,0-1,0.45-1,1s0.45,1,1,1s1-0.45,1-1S10.55,17,10,17z M14,12.5c-0.83,0-1.5,0.67-1.5,1.5s0.67,1.5,1.5,1.5s1.5-0.67,1.5-1.5 S14.83,12.5,14,12.5z M14,8.5c-0.83,0-1.5,0.67-1.5,1.5s0.67,1.5,1.5,1.5s1.5-0.67,1.5-1.5S14.83,8.5,14,8.5z"/>`);
var __glob_0_160 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": pattern_cross_dot
}, Symbol.toStringTag, { value: "Module" }));
var pattern_dot = _icon_template(`<path d="M6,13c-0.55,0-1,0.45-1,1s0.45,1,1,1s1-0.45,1-1S6.55,13,6,13z M6,17c-0.55,0-1,0.45-1,1s0.45,1,1,1s1-0.45,1-1 S6.55,17,6,17z M6,9c-0.55,0-1,0.45-1,1s0.45,1,1,1s1-0.45,1-1S6.55,9,6,9z M3,9.5c-0.28,0-0.5,0.22-0.5,0.5s0.22,0.5,0.5,0.5 s0.5-0.22,0.5-0.5S3.28,9.5,3,9.5z M6,5C5.45,5,5,5.45,5,6s0.45,1,1,1s1-0.45,1-1S6.55,5,6,5z M21,10.5c0.28,0,0.5-0.22,0.5-0.5 S21.28,9.5,21,9.5s-0.5,0.22-0.5,0.5S20.72,10.5,21,10.5z M14,7c0.55,0,1-0.45,1-1s-0.45-1-1-1s-1,0.45-1,1S13.45,7,14,7z M14,3.5 c0.28,0,0.5-0.22,0.5-0.5S14.28,2.5,14,2.5S13.5,2.72,13.5,3S13.72,3.5,14,3.5z M3,13.5c-0.28,0-0.5,0.22-0.5,0.5 s0.22,0.5,0.5,0.5s0.5-0.22,0.5-0.5S3.28,13.5,3,13.5z M10,20.5c-0.28,0-0.5,0.22-0.5,0.5s0.22,0.5,0.5,0.5s0.5-0.22,0.5-0.5 S10.28,20.5,10,20.5z M10,3.5c0.28,0,0.5-0.22,0.5-0.5S10.28,2.5,10,2.5S9.5,2.72,9.5,3S9.72,3.5,10,3.5z M10,7c0.55,0,1-0.45,1-1 s-0.45-1-1-1S9,5.45,9,6S9.45,7,10,7z M10,12.5c-0.83,0-1.5,0.67-1.5,1.5s0.67,1.5,1.5,1.5s1.5-0.67,1.5-1.5S10.83,12.5,10,12.5z M18,13c-0.55,0-1,0.45-1,1s0.45,1,1,1s1-0.45,1-1S18.55,13,18,13z M18,17c-0.55,0-1,0.45-1,1s0.45,1,1,1s1-0.45,1-1 S18.55,17,18,17z M18,9c-0.55,0-1,0.45-1,1s0.45,1,1,1s1-0.45,1-1S18.55,9,18,9z M18,5c-0.55,0-1,0.45-1,1s0.45,1,1,1s1-0.45,1-1 S18.55,5,18,5z M21,13.5c-0.28,0-0.5,0.22-0.5,0.5s0.22,0.5,0.5,0.5s0.5-0.22,0.5-0.5S21.28,13.5,21,13.5z M14,17 c-0.55,0-1,0.45-1,1s0.45,1,1,1s1-0.45,1-1S14.55,17,14,17z M14,20.5c-0.28,0-0.5,0.22-0.5,0.5s0.22,0.5,0.5,0.5s0.5-0.22,0.5-0.5 S14.28,20.5,14,20.5z M10,8.5c-0.83,0-1.5,0.67-1.5,1.5s0.67,1.5,1.5,1.5s1.5-0.67,1.5-1.5S10.83,8.5,10,8.5z M10,17 c-0.55,0-1,0.45-1,1s0.45,1,1,1s1-0.45,1-1S10.55,17,10,17z M14,12.5c-0.83,0-1.5,0.67-1.5,1.5s0.67,1.5,1.5,1.5s1.5-0.67,1.5-1.5 S14.83,12.5,14,12.5z M14,8.5c-0.83,0-1.5,0.67-1.5,1.5s0.67,1.5,1.5,1.5s1.5-0.67,1.5-1.5S14.83,8.5,14,8.5z"/>`);
var __glob_0_161 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": pattern_dot
}, Symbol.toStringTag, { value: "Module" }));
var pattern_grid = _icon_template(`<path d="M22,7V5h-3V2h-2v3h-4V2h-2v3H7V2H5v3H2v2h3v4H2v2h3v4H2v2h3v3h2v-3h4v3h2v-3h4v3h2v-3h3v-2h-3v-4h3v-2h-3V7H22z M7,7h4v4 H7V7z M7,17v-4h4v4H7z M17,17h-4v-4h4V17z M17,11h-4V7h4V11z"/>`);
var __glob_0_162 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": pattern_grid
}, Symbol.toStringTag, { value: "Module" }));
var pattern_horizontal_line = _icon_template(`<path d="M3 15h18v-2H3v2zm0 4h18v-2H3v2zm0-8h18V9H3v2zm0-6v2h18V5H3z"/>`);
var __glob_0_163 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": pattern_horizontal_line
}, Symbol.toStringTag, { value: "Module" }));
var pause = _icon_template(`<path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"/>`);
var __glob_0_164 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": pause
}, Symbol.toStringTag, { value: "Module" }));
var pentool = _icon_template(`
    <g transform="translate(4.000003875248012, 4.000001937624006)">
        <path stroke="currentColor" d="M 7.501491970838878 -0.0000015572448855733659Q 14.336036333057622 7.389304433496911 15.674208571053226 11.025537025755131Q 17.012380809048864 14.661769618013372 12.854180922821438 14.544928811787997L 12.854180922821438 16.99999278410904L 3.2146550430021494 16.99999278410904L 3.2146550430021494 14.544928811787997Q -0.8480130988910353 14.661769618013372 0.22369613306813782 11.025537025755131Q 1.295405365027311 7.389304433496911 7.501491970838878 -0.0000015572448855733659Z M 7.501491970838878 -0.0000015572448855733659M 7.043097362212707 10.615180199186797L 7.043097362212707 2.029497238417552Q 2.4235653311211847 7.389304433496911 1.2143202542326725 11.099378313047254Q 0.22369613306813782 14.380813978493594 4.269842778971384 13.709709450113499L 4.269842778971384 16.233605781316655L 11.751764459057853 16.233605781316655L 11.751764459057853 13.709709450113499Q 15.84146041516868 14.140123940309786 14.670231046646997 10.775846698306177Q 14.195747591990225 9.593976493057127 8.077664264490855 2.029497238417552L 8.077664264490855 10.615180199186797L 7.043097362212707 10.615180199186797Z"/>
    </g>
`);
var __glob_0_165 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": pentool
}, Symbol.toStringTag, { value: "Module" }));
var photo = _icon_template(`<path d="M21 19V5c0-1.1-.9-2-2-2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2zM8.5 13.5l2.5 3.01L14.5 12l4.5 6H5l3.5-4.5z"/>`);
var __glob_0_166 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": photo
}, Symbol.toStringTag, { value: "Module" }));
var play = _icon_template(`<path d="M8 5v14l11-7z"/>`);
var __glob_0_167 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": play
}, Symbol.toStringTag, { value: "Module" }));
var plugin = _icon_template(`<path d="M3 3h8v8H3zm10 0h8v8h-8zM3 13h8v8H3zm15 0h-2v3h-3v2h3v3h2v-3h3v-2h-3z"/>`);
var __glob_0_168 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": plugin
}, Symbol.toStringTag, { value: "Module" }));
var polygon$1 = _icon_template(`<path d="M17.2,3H6.8l-5.2,9l5.2,9h10.4l5.2-9L17.2,3z M16.05,19H7.95l-4.04-7l4.04-7h8.09l4.04,7L16.05,19z"/>`);
var __glob_0_169 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": polygon$1
}, Symbol.toStringTag, { value: "Module" }));
var power_input = _icon_template(`<path d="M2 9v2h19V9H2zm0 6h5v-2H2v2zm7 0h5v-2H9v2zm7 0h5v-2h-5v2z"/>`);
var __glob_0_170 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": power_input
}, Symbol.toStringTag, { value: "Module" }));
var publish = _icon_template(`<path d="M5 4v2h14V4H5zm0 10h4v6h6v-6h4l-7-7-7 7z"/>`);
var __glob_0_171 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": publish
}, Symbol.toStringTag, { value: "Module" }));
var rect$1 = _icon_template(`<path d="M19 3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2z"/>`);
var __glob_0_172 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": rect$1
}, Symbol.toStringTag, { value: "Module" }));
var redo = _icon_template(`<path d="M18.4 10.6C16.55 8.99 14.15 8 11.5 8c-4.65 0-8.58 3.03-9.96 7.22L3.9 16c1.05-3.19 4.05-5.5 7.6-5.5 1.95 0 3.73.72 5.12 1.88L13 16h9V7l-3.6 3.6z"/>`);
var __glob_0_173 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": redo
}, Symbol.toStringTag, { value: "Module" }));
var refresh = _icon_template(`<path d="M17.65 6.35C16.2 4.9 14.21 4 12 4c-4.42 0-7.99 3.58-7.99 8s3.57 8 7.99 8c3.73 0 6.84-2.55 7.73-6h-2.08c-.82 2.33-3.04 4-5.65 4-3.31 0-6-2.69-6-6s2.69-6 6-6c1.66 0 3.14.69 4.22 1.78L13 11h7V4l-2.35 2.35z"/>`);
var __glob_0_174 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": refresh
}, Symbol.toStringTag, { value: "Module" }));
var remove = _icon_template(`<path d="M6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7H6v12zM19 4h-3.5l-1-1h-5l-1 1H5v2h14V4z"/>`);
var __glob_0_175 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": remove
}, Symbol.toStringTag, { value: "Module" }));
var remove2 = _icon_template(`<path d="M19 13H5v-2h14v2z"/>`);
var __glob_0_176 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": remove2
}, Symbol.toStringTag, { value: "Module" }));
var repeat$1 = _icon_template(`<path d="M7 7h10v3l4-4-4-4v3H5v6h2V7zm10 10H7v-3l-4 4 4 4v-3h12v-6h-2v4z"/>`);
var __glob_0_177 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": repeat$1
}, Symbol.toStringTag, { value: "Module" }));
var replay = _icon_template(`<defs><path id="a" d="M0 0h24v24H0V0z"/></defs><clipPath id="b"><use xlink:href="#a" overflow="visible"/></clipPath><path d="M12 5V1L7 6l5 5V7c3.3 0 6 2.7 6 6s-2.7 6-6 6-6-2.7-6-6H4c0 4.4 3.6 8 8 8s8-3.6 8-8-3.6-8-8-8zm-1.1 11H10v-3.3L9 13v-.7l1.8-.6h.1V16zm4.3-1.8c0 .3 0 .6-.1.8l-.3.6s-.3.3-.5.3-.4.1-.6.1-.4 0-.6-.1-.3-.2-.5-.3-.2-.3-.3-.6-.1-.5-.1-.8v-.7c0-.3 0-.6.1-.8l.3-.6s.3-.3.5-.3.4-.1.6-.1.4 0 .6.1c.2.1.3.2.5.3s.2.3.3.6.1.5.1.8v.7zm-.9-.8v-.5s-.1-.2-.1-.3-.1-.1-.2-.2-.2-.1-.3-.1-.2 0-.3.1l-.2.2s-.1.2-.1.3v2s.1.2.1.3.1.1.2.2.2.1.3.1.2 0 .3-.1l.2-.2s.1-.2.1-.3v-1.5z" clip-path="url(#b)"/>`);
var __glob_0_178 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": replay
}, Symbol.toStringTag, { value: "Module" }));
var right = _icon_template(`<path d="M20,4 L20,20Z M6,10 L16,10 L16,14 L6,14Z" stroke-width="1" />`);
var __glob_0_179 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": right
}, Symbol.toStringTag, { value: "Module" }));
var right_hide = _icon_template(`<path d="M5.59 7.41L10.18 12l-4.59 4.59L7 18l6-6-6-6zM16 6h2v12h-2z"/>`);
var __glob_0_180 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": right_hide
}, Symbol.toStringTag, { value: "Module" }));
var rotate = _icon_template(`
        <path d="M7.11 8.53L5.7 7.11C4.8 8.27 4.24 9.61 4.07 11h2.02c.14-.87.49-1.72 1.02-2.47zM6.09 13H4.07c.17 1.39.72 2.73 1.62 3.89l1.41-1.42c-.52-.75-.87-1.59-1.01-2.47zm1.01 5.32c1.16.9 2.51 1.44 3.9 1.61V17.9c-.87-.15-1.71-.49-2.46-1.03L7.1 18.32zM13 4.07V1L8.45 5.55 13 10V6.09c2.84.48 5 2.94 5 5.91s-2.16 5.43-5 5.91v2.02c3.95-.49 7-3.85 7-7.93s-3.05-7.44-7-7.93z" stroke='white' stroke-width="0.5" />
    `);
var __glob_0_181 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": rotate
}, Symbol.toStringTag, { value: "Module" }));
var rotate_left = _icon_template(`<path d="M7.11 8.53L5.7 7.11C4.8 8.27 4.24 9.61 4.07 11h2.02c.14-.87.49-1.72 1.02-2.47zM6.09 13H4.07c.17 1.39.72 2.73 1.62 3.89l1.41-1.42c-.52-.75-.87-1.59-1.01-2.47zm1.01 5.32c1.16.9 2.51 1.44 3.9 1.61V17.9c-.87-.15-1.71-.49-2.46-1.03L7.1 18.32zM13 4.07V1L8.45 5.55 13 10V6.09c2.84.48 5 2.94 5 5.91s-2.16 5.43-5 5.91v2.02c3.95-.49 7-3.85 7-7.93s-3.05-7.44-7-7.93z"/>`);
var __glob_0_182 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": rotate_left
}, Symbol.toStringTag, { value: "Module" }));
var round$1 = _icon_template(`<path d="M19 19h2v2h-2v-2zm0-2h2v-2h-2v2zM3 13h2v-2H3v2zm0 4h2v-2H3v2zm0-8h2V7H3v2zm0-4h2V3H3v2zm4 0h2V3H7v2zm8 16h2v-2h-2v2zm-4 0h2v-2h-2v2zm4 0h2v-2h-2v2zm-8 0h2v-2H7v2zm-4 0h2v-2H3v2zM21 8c0-2.76-2.24-5-5-5h-5v2h5c1.65 0 3 1.35 3 3v5h2V8z"/>`);
var __glob_0_183 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": round$1
}, Symbol.toStringTag, { value: "Module" }));
var same_height$1 = _icon_template(`
    <path d="M4,4 L20,4Z M4,20 L20,20Z M10,8 L10,16 L14,16 L14,8Z" stroke-width="1" />
`);
var __glob_0_184 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": same_height$1
}, Symbol.toStringTag, { value: "Module" }));
var same_width$1 = _icon_template(`
    <path d="M20,4 L20,20Z M2,4 L2,20Z M6,10 L16,10 L16,14 L6,14Z" stroke-width="1" />
`);
var __glob_0_185 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": same_width$1
}, Symbol.toStringTag, { value: "Module" }));
var save = _icon_template(`<path d="M19 12v7H5v-7H3v7c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2v-7h-2zm-6 .67l2.59-2.58L17 11.5l-5 5-5-5 1.41-1.41L11 12.67V3h2z"/><path fill="none" d="M0 0h24v24H0z"/>`);
var __glob_0_186 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": save
}, Symbol.toStringTag, { value: "Module" }));
var scatter = _icon_template(`<g fill="#010101"><circle cx="7" cy="14" r="3"/><circle cx="11" cy="6" r="3"/><circle cx="16.6" cy="17.6" r="3"/></g>`);
var __glob_0_187 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": scatter
}, Symbol.toStringTag, { value: "Module" }));
var screen = _icon_template(`<path d="M7 14H5v5h5v-2H7v-3zm-2-4h2V7h3V5H5v5zm12 7h-3v2h5v-5h-2v3zM14 5v2h3v3h2V5h-5z"/>`);
var __glob_0_188 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": screen
}, Symbol.toStringTag, { value: "Module" }));
var setting = _icon_template(`<path d="M15.95 10.78c.03-.25.05-.51.05-.78s-.02-.53-.06-.78l1.69-1.32c.15-.12.19-.34.1-.51l-1.6-2.77c-.1-.18-.31-.24-.49-.18l-1.99.8c-.42-.32-.86-.58-1.35-.78L12 2.34c-.03-.2-.2-.34-.4-.34H8.4c-.2 0-.36.14-.39.34l-.3 2.12c-.49.2-.94.47-1.35.78l-1.99-.8c-.18-.07-.39 0-.49.18l-1.6 2.77c-.1.18-.06.39.1.51l1.69 1.32c-.04.25-.07.52-.07.78s.02.53.06.78L2.37 12.1c-.15.12-.19.34-.1.51l1.6 2.77c.1.18.31.24.49.18l1.99-.8c.42.32.86.58 1.35.78l.3 2.12c.04.2.2.34.4.34h3.2c.2 0 .37-.14.39-.34l.3-2.12c.49-.2.94-.47 1.35-.78l1.99.8c.18.07.39 0 .49-.18l1.6-2.77c.1-.18.06-.39-.1-.51l-1.67-1.32zM10 13c-1.65 0-3-1.35-3-3s1.35-3 3-3 3 1.35 3 3-1.35 3-3 3z"/>`);
var __glob_0_189 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": setting
}, Symbol.toStringTag, { value: "Module" }));
var settings_input_component = _icon_template(`<path d="M5 2c0-.55-.45-1-1-1s-1 .45-1 1v4H1v6h6V6H5V2zm4 14c0 1.3.84 2.4 2 2.82V23h2v-4.18c1.16-.41 2-1.51 2-2.82v-2H9v2zm-8 0c0 1.3.84 2.4 2 2.82V23h2v-4.18C6.16 18.4 7 17.3 7 16v-2H1v2zM21 6V2c0-.55-.45-1-1-1s-1 .45-1 1v4h-2v6h6V6h-2zm-8-4c0-.55-.45-1-1-1s-1 .45-1 1v4H9v6h6V6h-2V2zm4 14c0 1.3.84 2.4 2 2.82V23h2v-4.18c1.16-.41 2-1.51 2-2.82v-2h-6v2z"/>`);
var __glob_0_190 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": settings_input_component
}, Symbol.toStringTag, { value: "Module" }));
var shadow$1 = _icon_template(`<path d="M15.96 10.29l-2.75 3.54-1.96-2.36L8.5 15h11l-3.54-4.71zM3 5H1v16c0 1.1.9 2 2 2h16v-2H3V5zm18-4H7c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V3c0-1.1-.9-2-2-2zm0 16H7V3h14v14z"/>`);
var __glob_0_191 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": shadow$1
}, Symbol.toStringTag, { value: "Module" }));
var shape = _icon_template(`<path d="M23 7V1h-6v2H7V1H1v6h2v10H1v6h6v-2h10v2h6v-6h-2V7h2zM3 3h2v2H3V3zm2 18H3v-2h2v2zm12-2H7v-2H5V7h2V5h10v2h2v10h-2v2zm4 2h-2v-2h2v2zM19 5V3h2v2h-2z"/>`);
var __glob_0_192 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": shape
}, Symbol.toStringTag, { value: "Module" }));
var shuffle = _icon_template(`<path d="M10.59 9.17L5.41 4 4 5.41l5.17 5.17 1.42-1.41zM14.5 4l2.04 2.04L4 18.59 5.41 20 17.96 7.46 20 9.5V4h-5.5zm.33 9.41l-1.41 1.41 3.13 3.13L14.5 20H20v-5.5l-2.04 2.04-3.13-3.13z"/>`);
var __glob_0_193 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": shuffle
}, Symbol.toStringTag, { value: "Module" }));
var size = _icon_template(`<path d="M21 15h2v2h-2v-2zm0-4h2v2h-2v-2zm2 8h-2v2c1 0 2-1 2-2zM13 3h2v2h-2V3zm8 4h2v2h-2V7zm0-4v2h2c0-1-1-2-2-2zM1 7h2v2H1V7zm16-4h2v2h-2V3zm0 16h2v2h-2v-2zM3 3C2 3 1 4 1 5h2V3zm6 0h2v2H9V3zM5 3h2v2H5V3zm-4 8v8c0 1.1.9 2 2 2h12V11H1zm2 8l2.5-3.21 1.79 2.15 2.5-3.22L13 19H3z"/>`);
var __glob_0_194 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": size
}, Symbol.toStringTag, { value: "Module" }));
var skip_next = _icon_template(`<path d="M6 18l8.5-6L6 6v12zM16 6v12h2V6h-2z"/>`);
var __glob_0_195 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": skip_next
}, Symbol.toStringTag, { value: "Module" }));
var skip_prev = _icon_template(`<path d="M6 6h2v12H6zm3.5 6l8.5 6V6z"/>`);
var __glob_0_196 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": skip_prev
}, Symbol.toStringTag, { value: "Module" }));
var smooth = _icon_template(`<path d="M4.59 6.89c.7-.71 1.4-1.35 1.71-1.22.5.2 0 1.03-.3 1.52-.25.42-2.86 3.89-2.86 6.31 0 1.28.48 2.34 1.34 2.98.75.56 1.74.73 2.64.46 1.07-.31 1.95-1.4 3.06-2.77 1.21-1.49 2.83-3.44 4.08-3.44 1.63 0 1.65 1.01 1.76 1.79-3.78.64-5.38 3.67-5.38 5.37 0 1.7 1.44 3.09 3.21 3.09 1.63 0 4.29-1.33 4.69-6.1H21v-2.5h-2.47c-.15-1.65-1.09-4.2-4.03-4.2-2.25 0-4.18 1.91-4.94 2.84-.58.73-2.06 2.48-2.29 2.72-.25.3-.68.84-1.11.84-.45 0-.72-.83-.36-1.92.35-1.09 1.4-2.86 1.85-3.52.78-1.14 1.3-1.92 1.3-3.28C8.95 3.69 7.31 3 6.44 3 5.12 3 3.97 4 3.72 4.25c-.36.36-.66.66-.88.93l1.75 1.71zm9.29 11.66c-.31 0-.74-.26-.74-.72 0-.6.73-2.2 2.87-2.76-.3 2.69-1.43 3.48-2.13 3.48z"/>`);
var __glob_0_197 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": smooth
}, Symbol.toStringTag, { value: "Module" }));
var source = _icon_template(`<path d="M20,6h-8l-2-2H4C2.9,4,2.01,4.9,2.01,6L2,18c0,1.1,0.9,2,2,2h16c1.1,0,2-0.9,2-2V8C22,6.9,21.1,6,20,6z M20,18L4,18V6h5.17 l2,2H20V18z M18,12H6v-2h12V12z M14,16H6v-2h8V16z"/>`);
var __glob_0_198 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": source
}, Symbol.toStringTag, { value: "Module" }));
var south = _icon_template(`<path d="M19,15l-1.41-1.41L13,18.17V2H11v16.17l-4.59-4.59L5,15l7,7L19,15z"/>`);
var __glob_0_199 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": south
}, Symbol.toStringTag, { value: "Module" }));
var space = _icon_template(`<path d="M18 9v4H6V9H4v6h16V9h-2z"/>`);
var __glob_0_200 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": space
}, Symbol.toStringTag, { value: "Module" }));
var specular = _icon_template(`<path d="M3.55 18.54l1.41 1.41 1.79-1.8-1.41-1.41-1.79 1.8zM11 22.45h2V19.5h-2v2.95zM4 10.5H1v2h3v-2zm11-4.19V1.5H9v4.81C7.21 7.35 6 9.28 6 11.5c0 3.31 2.69 6 6 6s6-2.69 6-6c0-2.22-1.21-4.15-3-5.19zm5 4.19v2h3v-2h-3zm-2.76 7.66l1.79 1.8 1.41-1.41-1.8-1.79-1.4 1.4z"/>`);
var __glob_0_201 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": specular
}, Symbol.toStringTag, { value: "Module" }));
var speed = _icon_template(`<path d="M20.38 8.57l-1.23 1.85a8 8 0 0 1-.22 7.58H5.07A8 8 0 0 1 15.58 6.85l1.85-1.23A10 10 0 0 0 3.35 19a2 2 0 0 0 1.72 1h13.85a2 2 0 0 0 1.74-1 10 10 0 0 0-.27-10.44zm-9.79 6.84a2 2 0 0 0 2.83 0l5.66-8.49-8.49 5.66a2 2 0 0 0 0 2.83z"/>`);
var __glob_0_202 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": speed
}, Symbol.toStringTag, { value: "Module" }));
var star = _icon_template(`<path d="M22 9.24l-7.19-.62L12 2 9.19 8.63 2 9.24l5.46 4.73L5.82 21 12 17.27 18.18 21l-1.63-7.03L22 9.24zM12 15.4l-3.76 2.27 1-4.28-3.32-2.88 4.38-.38L12 6.1l1.71 4.04 4.38.38-3.32 2.88 1 4.28L12 15.4z"/>`);
var __glob_0_203 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": star
}, Symbol.toStringTag, { value: "Module" }));
var start = _icon_template(`<path d="M14.59,7.41L18.17,11H6v2h12.17l-3.59,3.59L16,18l6-6l-6-6L14.59,7.41z M2,6v12h2V6H2z"/>`);
var __glob_0_204 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": start
}, Symbol.toStringTag, { value: "Module" }));
var storage = _icon_template(`<path d="M2 20h20v-4H2v4zm2-3h2v2H4v-2zM2 4v4h20V4H2zm4 3H4V5h2v2zm-4 7h20v-4H2v4zm2-3h2v2H4v-2z"/>`);
var __glob_0_205 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": storage
}, Symbol.toStringTag, { value: "Module" }));
var straighten = _icon_template(`<path d="M21 6H3c-1.1 0-2 .9-2 2v8c0 1.1.9 2 2 2h18c1.1 0 2-.9 2-2V8c0-1.1-.9-2-2-2zm0 10H3V8h2v4h2V8h2v4h2V8h2v4h2V8h2v4h2V8h2v8z"/>`);
var __glob_0_206 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": straighten
}, Symbol.toStringTag, { value: "Module" }));
var strikethrough = _icon_template(`<defs><path id="a" d="M0 0h24v24H0V0z"/></defs><clipPath id="b"><use xlink:href="#a" overflow="visible"/></clipPath><path clip-path="url(#b)" d="M7.24 8.75c-.26-.48-.39-1.03-.39-1.67 0-.61.13-1.16.4-1.67.26-.5.63-.93 1.11-1.29.48-.35 1.05-.63 1.7-.83.66-.19 1.39-.29 2.18-.29.81 0 1.54.11 2.21.34.66.22 1.23.54 1.69.94.47.4.83.88 1.08 1.43.25.55.38 1.15.38 1.81h-3.01c0-.31-.05-.59-.15-.85-.09-.27-.24-.49-.44-.68-.2-.19-.45-.33-.75-.44-.3-.1-.66-.16-1.06-.16-.39 0-.74.04-1.03.13-.29.09-.53.21-.72.36-.19.16-.34.34-.44.55-.1.21-.15.43-.15.66 0 .48.25.88.74 1.21.38.25.77.48 1.41.7H7.39c-.05-.08-.11-.17-.15-.25zM21 12v-2H3v2h9.62c.18.07.4.14.55.2.37.17.66.34.87.51.21.17.35.36.43.57.07.2.11.43.11.69 0 .23-.05.45-.14.66-.09.2-.23.38-.42.53-.19.15-.42.26-.71.35-.29.08-.63.13-1.01.13-.43 0-.83-.04-1.18-.13s-.66-.23-.91-.42c-.25-.19-.45-.44-.59-.75-.14-.31-.25-.76-.25-1.21H6.4c0 .55.08 1.13.24 1.58.16.45.37.85.65 1.21.28.35.6.66.98.92.37.26.78.48 1.22.65.44.17.9.3 1.38.39.48.08.96.13 1.44.13.8 0 1.53-.09 2.18-.28s1.21-.45 1.67-.79c.46-.34.82-.77 1.07-1.27s.38-1.07.38-1.71c0-.6-.1-1.14-.31-1.61-.05-.11-.11-.23-.17-.33H21z"/>`);
var __glob_0_207 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": strikethrough
}, Symbol.toStringTag, { value: "Module" }));
var stroke_to_path = _icon_template(`<path d="M20 4h-4l-4-4-4 4H4c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2zm0 16H4V6h4.52l3.52-3.5L15.52 6H20v14zM6 18h12V8H6v10zm2-8h8v6H8v-6z"/>`);
var __glob_0_208 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": stroke_to_path
}, Symbol.toStringTag, { value: "Module" }));
var swap_horiz = _icon_template(`<path d="M6.99 11L3 15l3.99 4v-3H14v-2H6.99v-3zM21 9l-3.99-4v3H10v2h7.01v3L21 9z"/>`);
var __glob_0_209 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": swap_horiz
}, Symbol.toStringTag, { value: "Module" }));
var switch_left = _icon_template(`<path d="M8.5,8.62v6.76L5.12,12L8.5,8.62 M10,5l-7,7l7,7V5L10,5z M14,5v14l7-7L14,5z"/>`);
var __glob_0_210 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": switch_left
}, Symbol.toStringTag, { value: "Module" }));
var switch_right = _icon_template(`<path d="M15.5,15.38V8.62L18.88,12L15.5,15.38 M14,19l7-7l-7-7V19L14,19z M10,19V5l-7,7L10,19z"/>`);
var __glob_0_211 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": switch_right
}, Symbol.toStringTag, { value: "Module" }));
var sync = _icon_template(`<path d="M12 4V1L8 5l4 4V6c3.31 0 6 2.69 6 6 0 1.01-.25 1.97-.7 2.8l1.46 1.46C19.54 15.03 20 13.57 20 12c0-4.42-3.58-8-8-8zm0 14c-3.31 0-6-2.69-6-6 0-1.01.25-1.97.7-2.8L5.24 7.74C4.46 8.97 4 10.43 4 12c0 4.42 3.58 8 8 8v3l4-4-4-4v3z"/>`);
var __glob_0_212 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": sync
}, Symbol.toStringTag, { value: "Module" }));
var table_rows = _icon_template(`<path d="M19,3H5C3.9,3,3,3.9,3,5v14c0,1.1,0.9,2,2,2h14c1.1,0,2-0.9,2-2V5C21,3.9,20.1,3,19,3z M19,5v3H5V5H19z M19,10v4H5v-4H19z M5,19v-3h14v3H5z"/>`);
var __glob_0_213 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": table_rows
}, Symbol.toStringTag, { value: "Module" }));
var text_rotate = _icon_template(`<path d="M12.75 3h-1.5L6.5 14h2.1l.9-2.2h5l.9 2.2h2.1L12.75 3zm-2.62 7L12 4.98 13.87 10h-3.74zm10.37 8l-3-3v2H5v2h12.5v2l3-3z"/>`);
var __glob_0_214 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": text_rotate
}, Symbol.toStringTag, { value: "Module" }));
var texture$1 = _icon_template(`<path d="M19.51 3.08L3.08 19.51c.09.34.27.65.51.9.25.24.56.42.9.51L20.93 4.49c-.19-.69-.73-1.23-1.42-1.41zM11.88 3L3 11.88v2.83L14.71 3h-2.83zM5 3c-1.1 0-2 .9-2 2v2l4-4H5zm14 18c.55 0 1.05-.22 1.41-.59.37-.36.59-.86.59-1.41v-2l-4 4h2zm-9.71 0h2.83L21 12.12V9.29L9.29 21z"/>`);
var __glob_0_215 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": texture$1
}, Symbol.toStringTag, { value: "Module" }));
var timer = _icon_template(`<path d="M15 1H9v2h6V1zm-4 13h2V8h-2v6zm8.03-6.61l1.42-1.42c-.43-.51-.9-.99-1.41-1.41l-1.42 1.42C16.07 4.74 14.12 4 12 4c-4.97 0-9 4.03-9 9s4.02 9 9 9 9-4.03 9-9c0-2.12-.74-4.07-1.97-5.61zM12 20c-3.87 0-7-3.13-7-7s3.13-7 7-7 7 3.13 7 7-3.13 7-7 7z"/>`);
var __glob_0_216 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": timer
}, Symbol.toStringTag, { value: "Module" }));
var title = _icon_template(`<path d="M22.25 39.1V12.4H10.9V8.9H37.1V12.4H25.75V39.1Z"/>`, {
  width: 48,
  height: 48
});
var __glob_0_217 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": title
}, Symbol.toStringTag, { value: "Module" }));
var to_back = _icon_template(`<path d="M 7 7L 22 7L 22 22L 7 22L 7 7Z" class="target" /><path d="M 0 0L 14 0L 14 14L 0 14L 0 0Z M 16 16L 30 16L 30 30L 16 30L 16 16Z"/>`, { width: 30, height: 30 });
var __glob_0_218 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": to_back
}, Symbol.toStringTag, { value: "Module" }));
var to_front = _icon_template(`<path d="M 0 0L 14 0L 14 14L 0 14L 0 0Z M 16 16L 30 16L 30 30L 16 30L 16 16Z"/><path class="target" d="M 7 7L 22 7L 22 22L 7 22L 7 7Z"/>`, { width: 30, height: 30 });
var __glob_0_219 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": to_front
}, Symbol.toStringTag, { value: "Module" }));
var tonality = _icon_template(`<path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-1 17.93c-3.94-.49-7-3.85-7-7.93s3.05-7.44 7-7.93v15.86zm2-15.86c1.03.13 2 .45 2.87.93H13v-.93zM13 7h5.24c.25.31.48.65.68 1H13V7zm0 3h6.74c.08.33.15.66.19 1H13v-1zm0 9.93V19h2.87c-.87.48-1.84.8-2.87.93zM18.24 17H13v-1h5.92c-.2.35-.43.69-.68 1zm1.5-3H13v-1h6.93c-.04.34-.11.67-.19 1z"/>`);
var __glob_0_220 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": tonality
}, Symbol.toStringTag, { value: "Module" }));
var top = _icon_template(`<path d="M4,4 L20,4Z M10,8 L10,16 L14,16 L14,8Z" stroke-width="1" />`);
var __glob_0_221 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": top
}, Symbol.toStringTag, { value: "Module" }));
var transform$1 = _icon_template(`<path d="M22 18v-2H8V4h2L7 1 4 4h2v2H2v2h4v8c0 1.1.9 2 2 2h8v2h-2l3 3 3-3h-2v-2h4zM10 8h6v6h2V8c0-1.1-.9-2-2-2h-6v2z"/>`);
var __glob_0_222 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": transform$1
}, Symbol.toStringTag, { value: "Module" }));
var underline = _icon_template(`<path d="M12 17c3.31 0 6-2.69 6-6V3h-2.5v8c0 1.93-1.57 3.5-3.5 3.5S8.5 12.93 8.5 11V3H6v8c0 3.31 2.69 6 6 6zm-7 2v2h14v-2H5z"/>`);
var __glob_0_223 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": underline
}, Symbol.toStringTag, { value: "Module" }));
var undo = _icon_template(`<path d="M12.5 8c-2.65 0-5.05.99-6.9 2.6L2 7v9h9l-3.62-3.62c1.39-1.16 3.16-1.88 5.12-1.88 3.54 0 6.55 2.31 7.6 5.5l2.37-.78C21.08 11.03 17.15 8 12.5 8z"/>`);
var __glob_0_224 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": undo
}, Symbol.toStringTag, { value: "Module" }));
var unfold = _icon_template(`<path d="M12 5.83L15.17 9l1.41-1.41L12 3 7.41 7.59 8.83 9 12 5.83zm0 12.34L8.83 15l-1.41 1.41L12 21l4.59-4.59L15.17 15 12 18.17z"/>`);
var __glob_0_225 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": unfold
}, Symbol.toStringTag, { value: "Module" }));
var vertical_align_baseline = _icon_template(`<path d="M16,18v2H8v-2H16z M11,7.99V16h2V7.99h3L12,4L8,7.99H11z"/>`);
var __glob_0_226 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": vertical_align_baseline
}, Symbol.toStringTag, { value: "Module" }));
var vertical_align_bottom = _icon_template(`<path d="M16 13h-3V3h-2v10H8l4 4 4-4zM4 19v2h16v-2H4z"/>`);
var __glob_0_227 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": vertical_align_bottom
}, Symbol.toStringTag, { value: "Module" }));
var vertical_align_center = _icon_template(`<path d="M8 19h3v4h2v-4h3l-4-4-4 4zm8-14h-3V1h-2v4H8l4 4 4-4zM4 11v2h16v-2H4z"/>`);
var __glob_0_228 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": vertical_align_center
}, Symbol.toStringTag, { value: "Module" }));
var vertical_align_stretch = _icon_template(`
    <path d="M19,13H5c-1.1,0-2,0.9-2,2v4c0,1.1,0.9,2,2,2h14c1.1,0,2-0.9,2-2v-4C21,13.9,20.1,13,19,13z M19,19H5v-4h14V19z"/>
    <path d="M19,3H5C3.9,3,3,3.9,3,5v4c0,1.1,0.9,2,2,2h14c1.1,0,2-0.9,2-2V5C21,3.9,20.1,3,19,3z M19,9H5V5h14V9z"/>
`);
var __glob_0_229 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": vertical_align_stretch
}, Symbol.toStringTag, { value: "Module" }));
var vertical_align_top = _icon_template(`<path d="M8 11h3v10h2V11h3l-4-4-4 4zM4 3v2h16V3H4z"/>`);
var __glob_0_230 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": vertical_align_top
}, Symbol.toStringTag, { value: "Module" }));
var vertical_distribute = _icon_template(`<path d="M22,2v2H2V2H22z M7,10.5v3h10v-3H7z M2,20v2h20v-2H2z"/>`);
var __glob_0_231 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": vertical_distribute
}, Symbol.toStringTag, { value: "Module" }));
var video$1 = _icon_template(`
        <path d="M17 10.5V7c0-.55-.45-1-1-1H4c-.55 0-1 .45-1 1v10c0 .55.45 1 1 1h12c.55 0 1-.45 1-1v-3.5l4 4v-11l-4 4z"/>
    `);
var __glob_0_232 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": video$1
}, Symbol.toStringTag, { value: "Module" }));
var view_comfy = _icon_template(`<path d="M3 9h4V5H3v4zm0 5h4v-4H3v4zm5 0h4v-4H8v4zm5 0h4v-4h-4v4zM8 9h4V5H8v4zm5-4v4h4V5h-4zm5 9h4v-4h-4v4zM3 19h4v-4H3v4zm5 0h4v-4H8v4zm5 0h4v-4h-4v4zm5 0h4v-4h-4v4zm0-14v4h4V5h-4z"/>`);
var __glob_0_233 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": view_comfy
}, Symbol.toStringTag, { value: "Module" }));
var view_list = _icon_template(`<path d="M4 14h4v-4H4v4zm0 5h4v-4H4v4zM4 9h4V5H4v4zm5 5h12v-4H9v4zm0 5h12v-4H9v4zM9 5v4h12V5H9z"/>`);
var __glob_0_234 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": view_list
}, Symbol.toStringTag, { value: "Module" }));
var view_week = _icon_template(`<path d="M20,4H4C2.9,4,2,4.9,2,6v12c0,1.1,0.9,2,2,2h16c1.1,0,2-0.9,2-2V6C22,4.9,21.1,4,20,4z M8,18H4V6h4V18z M14,18h-4V6h4V18z M20,18h-4V6h4V18z"/>`);
var __glob_0_235 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": view_week
}, Symbol.toStringTag, { value: "Module" }));
var view_week_reverse = _icon_template(`<path d="M20,4H4C2.9,4,2,4.9,2,6v12c0,1.1,0.9,2,2,2h16c1.1,0,2-0.9,2-2V6C22,4.9,21.1,4,20,4z M8,18H4V6h4V18z M14,18h-4V6h4V18z M20,18h-4V6h4V18z M0,12 L24,12"/>`);
var __glob_0_236 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": view_week_reverse
}, Symbol.toStringTag, { value: "Module" }));
var vignette = _icon_template(`<path d="M21 3H3c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h18c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-9 15c-4.42 0-8-2.69-8-6s3.58-6 8-6 8 2.69 8 6-3.58 6-8 6z"/>`);
var __glob_0_237 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": vignette
}, Symbol.toStringTag, { value: "Module" }));
var vintage = _icon_template(`<path d="M18.7 12.4c-.28-.16-.57-.29-.86-.4.29-.11.58-.24.86-.4 1.92-1.11 2.99-3.12 3-5.19-1.79-1.03-4.07-1.11-6 0-.28.16-.54.35-.78.54.05-.31.08-.63.08-.95 0-2.22-1.21-4.15-3-5.19C10.21 1.85 9 3.78 9 6c0 .32.03.64.08.95-.24-.2-.5-.39-.78-.55-1.92-1.11-4.2-1.03-6 0 0 2.07 1.07 4.08 3 5.19.28.16.57.29.86.4-.29.11-.58.24-.86.4-1.92 1.11-2.99 3.12-3 5.19 1.79 1.03 4.07 1.11 6 0 .28-.16.54-.35.78-.54-.05.32-.08.64-.08.96 0 2.22 1.21 4.15 3 5.19 1.79-1.04 3-2.97 3-5.19 0-.32-.03-.64-.08-.95.24.2.5.38.78.54 1.92 1.11 4.2 1.03 6 0-.01-2.07-1.08-4.08-3-5.19zM12 16c-2.21 0-4-1.79-4-4s1.79-4 4-4 4 1.79 4 4-1.79 4-4 4z"/>`);
var __glob_0_238 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": vintage
}, Symbol.toStringTag, { value: "Module" }));
var visible = _icon_template(`<path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>`);
var __glob_0_239 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": visible
}, Symbol.toStringTag, { value: "Module" }));
var visible_off = _icon_template(`<path d="M12 6c3.79 0 7.17 2.13 8.82 5.5-.59 1.22-1.42 2.27-2.41 3.12l1.41 1.41c1.39-1.23 2.49-2.77 3.18-4.53C21.27 7.11 17 4 12 4c-1.27 0-2.49.2-3.64.57l1.65 1.65C10.66 6.09 11.32 6 12 6zm-1.07 1.14L13 9.21c.57.25 1.03.71 1.28 1.28l2.07 2.07c.08-.34.14-.7.14-1.07C16.5 9.01 14.48 7 12 7c-.37 0-.72.05-1.07.14zM2.01 3.87l2.68 2.68C3.06 7.83 1.77 9.53 1 11.5 2.73 15.89 7 19 12 19c1.52 0 2.98-.29 4.32-.82l3.42 3.42 1.41-1.41L3.42 2.45 2.01 3.87zm7.5 7.5l2.61 2.61c-.04.01-.08.02-.12.02-1.38 0-2.5-1.12-2.5-2.5 0-.05.01-.08.01-.13zm-3.4-3.4l1.75 1.75c-.23.55-.36 1.15-.36 1.78 0 2.48 2.02 4.5 4.5 4.5.63 0 1.23-.13 1.77-.36l.98.98c-.88.24-1.8.38-2.75.38-3.79 0-7.17-2.13-8.82-5.5.7-1.43 1.72-2.61 2.93-3.53z"/>`);
var __glob_0_240 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": visible_off
}, Symbol.toStringTag, { value: "Module" }));
var volume_down = _icon_template(`
        <path d="M18.5 12c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02zM5 9v6h4l5 5V4L9 9H5z"/>
    `);
var __glob_0_241 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": volume_down
}, Symbol.toStringTag, { value: "Module" }));
var volume_off = _icon_template(`
    <path d="M16.5 12c0-1.77-1.02-3.29-2.5-4.03v2.21l2.45 2.45c.03-.2.05-.41.05-.63zm2.5 0c0 .94-.2 1.82-.54 2.64l1.51 1.51C20.63 14.91 21 13.5 21 12c0-4.28-2.99-7.86-7-8.77v2.06c2.89.86 5 3.54 5 6.71zM4.27 3L3 4.27 7.73 9H3v6h4l5 5v-6.73l4.25 4.25c-.67.52-1.42.93-2.25 1.18v2.06c1.38-.31 2.63-.95 3.69-1.81L19.73 21 21 19.73l-9-9L4.27 3zM12 4L9.91 6.09 12 8.18V4z"/>
`);
var __glob_0_242 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": volume_off
}, Symbol.toStringTag, { value: "Module" }));
var volume_up = _icon_template(`
    <path d="M3 9v6h4l5 5V4L7 9H3zm13.5 3c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02zM14 3.23v2.06c2.89.86 5 3.54 5 6.71s-2.11 5.85-5 6.71v2.06c4.01-.91 7-4.49 7-8.77s-2.99-7.86-7-8.77z"/>
`);
var __glob_0_243 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": volume_up
}, Symbol.toStringTag, { value: "Module" }));
var wave = _icon_template(`<path d="M17 16.99c-1.35 0-2.2.42-2.95.8-.65.33-1.18.6-2.05.6-.9 0-1.4-.25-2.05-.6-.75-.38-1.57-.8-2.95-.8s-2.2.42-2.95.8c-.65.33-1.17.6-2.05.6v1.95c1.35 0 2.2-.42 2.95-.8.65-.33 1.17-.6 2.05-.6s1.4.25 2.05.6c.75.38 1.57.8 2.95.8s2.2-.42 2.95-.8c.65-.33 1.18-.6 2.05-.6.9 0 1.4.25 2.05.6.75.38 1.58.8 2.95.8v-1.95c-.9 0-1.4-.25-2.05-.6-.75-.38-1.6-.8-2.95-.8zm0-4.45c-1.35 0-2.2.43-2.95.8-.65.32-1.18.6-2.05.6-.9 0-1.4-.25-2.05-.6-.75-.38-1.57-.8-2.95-.8s-2.2.43-2.95.8c-.65.32-1.17.6-2.05.6v1.95c1.35 0 2.2-.43 2.95-.8.65-.35 1.15-.6 2.05-.6s1.4.25 2.05.6c.75.38 1.57.8 2.95.8s2.2-.43 2.95-.8c.65-.35 1.15-.6 2.05-.6s1.4.25 2.05.6c.75.38 1.58.8 2.95.8v-1.95c-.9 0-1.4-.25-2.05-.6-.75-.38-1.6-.8-2.95-.8zm2.95-8.08c-.75-.38-1.58-.8-2.95-.8s-2.2.42-2.95.8c-.65.32-1.18.6-2.05.6-.9 0-1.4-.25-2.05-.6-.75-.37-1.57-.8-2.95-.8s-2.2.42-2.95.8c-.65.33-1.17.6-2.05.6v1.93c1.35 0 2.2-.43 2.95-.8.65-.33 1.17-.6 2.05-.6s1.4.25 2.05.6c.75.38 1.57.8 2.95.8s2.2-.43 2.95-.8c.65-.32 1.18-.6 2.05-.6.9 0 1.4.25 2.05.6.75.38 1.58.8 2.95.8V5.04c-.9 0-1.4-.25-2.05-.58zM17 8.09c-1.35 0-2.2.43-2.95.8-.65.35-1.15.6-2.05.6s-1.4-.25-2.05-.6c-.75-.38-1.57-.8-2.95-.8s-2.2.43-2.95.8c-.65.35-1.15.6-2.05.6v1.95c1.35 0 2.2-.43 2.95-.8.65-.32 1.18-.6 2.05-.6s1.4.25 2.05.6c.75.38 1.57.8 2.95.8s2.2-.43 2.95-.8c.65-.32 1.18-.6 2.05-.6.9 0 1.4.25 2.05.6.75.38 1.58.8 2.95.8V9.49c-.9 0-1.4-.25-2.05-.6-.75-.38-1.6-.8-2.95-.8z"/>`);
var __glob_0_244 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": wave
}, Symbol.toStringTag, { value: "Module" }));
var waves = _icon_template(`<path d="M17 16.99c-1.35 0-2.2.42-2.95.8-.65.33-1.18.6-2.05.6-.9 0-1.4-.25-2.05-.6-.75-.38-1.57-.8-2.95-.8s-2.2.42-2.95.8c-.65.33-1.17.6-2.05.6v1.95c1.35 0 2.2-.42 2.95-.8.65-.33 1.17-.6 2.05-.6s1.4.25 2.05.6c.75.38 1.57.8 2.95.8s2.2-.42 2.95-.8c.65-.33 1.18-.6 2.05-.6.9 0 1.4.25 2.05.6.75.38 1.58.8 2.95.8v-1.95c-.9 0-1.4-.25-2.05-.6-.75-.38-1.6-.8-2.95-.8zm0-4.45c-1.35 0-2.2.43-2.95.8-.65.32-1.18.6-2.05.6-.9 0-1.4-.25-2.05-.6-.75-.38-1.57-.8-2.95-.8s-2.2.43-2.95.8c-.65.32-1.17.6-2.05.6v1.95c1.35 0 2.2-.43 2.95-.8.65-.35 1.15-.6 2.05-.6s1.4.25 2.05.6c.75.38 1.57.8 2.95.8s2.2-.43 2.95-.8c.65-.35 1.15-.6 2.05-.6s1.4.25 2.05.6c.75.38 1.58.8 2.95.8v-1.95c-.9 0-1.4-.25-2.05-.6-.75-.38-1.6-.8-2.95-.8zm2.95-8.08c-.75-.38-1.58-.8-2.95-.8s-2.2.42-2.95.8c-.65.32-1.18.6-2.05.6-.9 0-1.4-.25-2.05-.6-.75-.37-1.57-.8-2.95-.8s-2.2.42-2.95.8c-.65.33-1.17.6-2.05.6v1.93c1.35 0 2.2-.43 2.95-.8.65-.33 1.17-.6 2.05-.6s1.4.25 2.05.6c.75.38 1.57.8 2.95.8s2.2-.43 2.95-.8c.65-.32 1.18-.6 2.05-.6.9 0 1.4.25 2.05.6.75.38 1.58.8 2.95.8V5.04c-.9 0-1.4-.25-2.05-.58zM17 8.09c-1.35 0-2.2.43-2.95.8-.65.35-1.15.6-2.05.6s-1.4-.25-2.05-.6c-.75-.38-1.57-.8-2.95-.8s-2.2.43-2.95.8c-.65.35-1.15.6-2.05.6v1.95c1.35 0 2.2-.43 2.95-.8.65-.32 1.18-.6 2.05-.6s1.4.25 2.05.6c.75.38 1.57.8 2.95.8s2.2-.43 2.95-.8c.65-.32 1.18-.6 2.05-.6.9 0 1.4.25 2.05.6.75.38 1.58.8 2.95.8V9.49c-.9 0-1.4-.25-2.05-.6-.75-.38-1.6-.8-2.95-.8z"/>`);
var __glob_0_245 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": waves
}, Symbol.toStringTag, { value: "Module" }));
var web = _icon_template(`<path d="M20 4H4c-1.1 0-1.99.9-1.99 2L2 18c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2zm-5 14H4v-4h11v4zm0-5H4V9h11v4zm5 5h-4V9h4v9z"/>`);
var __glob_0_246 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": web
}, Symbol.toStringTag, { value: "Module" }));
var west = _icon_template(`<path d="M9,19l1.41-1.41L5.83,13H22V11H5.83l4.59-4.59L9,5l-7,7L9,19z"/>`);
var __glob_0_247 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": west
}, Symbol.toStringTag, { value: "Module" }));
var width$1 = _icon_template(`<polygon transform="rotate(90 12 12)" points="13,6.99 16,6.99 12,3 8,6.99 11,6.99 11,17.01 8,17.01 12,21 16,17.01 13,17.01"/>`);
var __glob_0_248 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": width$1
}, Symbol.toStringTag, { value: "Module" }));
var wrap = _icon_template(`<path d="M11 9l1.42 1.42L8.83 14H18V4h2v12H8.83l3.59 3.58L11 21l-6-6 6-6z"/>`);
var __glob_0_249 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": wrap
}, Symbol.toStringTag, { value: "Module" }));
var wrap_text = _icon_template(`<path d="M4 19h6v-2H4v2zM20 5H4v2h16V5zm-3 6H4v2h13.25c1.1 0 2 .9 2 2s-.9 2-2 2H15v-2l-3 3 3 3v-2h2c2.21 0 4-1.79 4-4s-1.79-4-4-4z"/>`);
var __glob_0_250 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": wrap_text
}, Symbol.toStringTag, { value: "Module" }));
const modules$7 = { "./icon_list/_icon_template.js": __glob_0_0$7, "./icon_list/account_tree.js": __glob_0_1$7, "./icon_list/add.js": __glob_0_2$6, "./icon_list/add_box.js": __glob_0_3$6, "./icon_list/add_circle.js": __glob_0_4$6, "./icon_list/add_note.js": __glob_0_5$6, "./icon_list/align_center.js": __glob_0_6$6, "./icon_list/align_horizontal_center.js": __glob_0_7$6, "./icon_list/align_horizontal_left.js": __glob_0_8$5, "./icon_list/align_horizontal_right.js": __glob_0_9$5, "./icon_list/align_justify.js": __glob_0_10$5, "./icon_list/align_left.js": __glob_0_11$5, "./icon_list/align_right.js": __glob_0_12$5, "./icon_list/align_vertical_bottom.js": __glob_0_13$5, "./icon_list/align_vertical_center.js": __glob_0_14$5, "./icon_list/align_vertical_top.js": __glob_0_15$4, "./icon_list/alternate.js": __glob_0_16$4, "./icon_list/alternate_reverse.js": __glob_0_17$4, "./icon_list/apps.js": __glob_0_18$4, "./icon_list/archive.js": __glob_0_19$4, "./icon_list/arrowLeft.js": __glob_0_20$4, "./icon_list/arrowRight.js": __glob_0_21$3, "./icon_list/arrow_right.js": __glob_0_22$3, "./icon_list/artboard.js": __glob_0_23$3, "./icon_list/auto_awesome.js": __glob_0_24$2, "./icon_list/autorenew.js": __glob_0_25$2, "./icon_list/ballot.js": __glob_0_26$2, "./icon_list/bar_chart.js": __glob_0_27$2, "./icon_list/blur.js": __glob_0_28$2, "./icon_list/blur_linear.js": __glob_0_29$2, "./icon_list/boolean_difference.js": __glob_0_30$2, "./icon_list/boolean_intersection.js": __glob_0_31$2, "./icon_list/boolean_union.js": __glob_0_32$2, "./icon_list/boolean_xor.js": __glob_0_33$2, "./icon_list/border_all.js": __glob_0_34$2, "./icon_list/border_inner.js": __glob_0_35$2, "./icon_list/border_style.js": __glob_0_36$2, "./icon_list/bottom.js": __glob_0_37$2, "./icon_list/broken_image.js": __glob_0_38$2, "./icon_list/brush.js": __glob_0_39$2, "./icon_list/build.js": __glob_0_40$2, "./icon_list/camera_roll.js": __glob_0_41$2, "./icon_list/cat.js": __glob_0_42$2, "./icon_list/center.js": __glob_0_43$2, "./icon_list/chart.js": __glob_0_44$2, "./icon_list/check.js": __glob_0_45$2, "./icon_list/chevron_left.js": __glob_0_46$2, "./icon_list/chevron_right.js": __glob_0_47$2, "./icon_list/circle.js": __glob_0_48$2, "./icon_list/close.js": __glob_0_49$2, "./icon_list/code.js": __glob_0_50$2, "./icon_list/color.js": __glob_0_51$2, "./icon_list/color_lens.js": __glob_0_52$2, "./icon_list/control_point.js": __glob_0_53$2, "./icon_list/copy.js": __glob_0_54$2, "./icon_list/create_folder.js": __glob_0_55$2, "./icon_list/cube.js": __glob_0_56$1, "./icon_list/cylinder.js": __glob_0_57$1, "./icon_list/dahaze.js": __glob_0_58$1, "./icon_list/dark.js": __glob_0_59$1, "./icon_list/delete_forever.js": __glob_0_60$1, "./icon_list/device_hub.js": __glob_0_61$1, "./icon_list/diffuse.js": __glob_0_62$1, "./icon_list/direction.js": __glob_0_63$1, "./icon_list/doc.js": __glob_0_64$1, "./icon_list/drag_handle.js": __glob_0_65$1, "./icon_list/drag_indicator.js": __glob_0_66$1, "./icon_list/draw.js": __glob_0_67$1, "./icon_list/east.js": __glob_0_68$1, "./icon_list/edit.js": __glob_0_69$1, "./icon_list/end.js": __glob_0_70$1, "./icon_list/exit_to_app.js": __glob_0_71$1, "./icon_list/expand.js": __glob_0_72$1, "./icon_list/expand_more.js": __glob_0_73$1, "./icon_list/export.js": __glob_0_74$1, "./icon_list/face.js": __glob_0_75$1, "./icon_list/fast_forward.js": __glob_0_76$1, "./icon_list/fast_rewind.js": __glob_0_77$1, "./icon_list/file_copy.js": __glob_0_78$1, "./icon_list/filter.js": __glob_0_79$1, "./icon_list/flag.js": __glob_0_80$1, "./icon_list/flash_on.js": __glob_0_81$1, "./icon_list/flatten.js": __glob_0_82$1, "./icon_list/flex.js": __glob_0_83$1, "./icon_list/flip.js": __glob_0_84$1, "./icon_list/flipY.js": __glob_0_85$1, "./icon_list/flip_camera.js": __glob_0_86$1, "./icon_list/folder.js": __glob_0_87$1, "./icon_list/font_download.js": __glob_0_88$1, "./icon_list/format_bold.js": __glob_0_89$1, "./icon_list/format_indent.js": __glob_0_90$1, "./icon_list/format_line_spacing.js": __glob_0_91$1, "./icon_list/format_shapes.js": __glob_0_92$1, "./icon_list/format_size.js": __glob_0_93$1, "./icon_list/fullscreen.js": __glob_0_94$1, "./icon_list/gps_fixed.js": __glob_0_95$1, "./icon_list/gradient.js": __glob_0_96$1, "./icon_list/grid.js": __glob_0_97$1, "./icon_list/grid3x3.js": __glob_0_98$1, "./icon_list/group.js": __glob_0_99$1, "./icon_list/height.js": __glob_0_100$1, "./icon_list/highlight_at.js": __glob_0_101$1, "./icon_list/horizontal_align_center.js": __glob_0_102$1, "./icon_list/horizontal_distribute.js": __glob_0_103$1, "./icon_list/horizontal_rule.js": __glob_0_104$1, "./icon_list/image.js": __glob_0_105$1, "./icon_list/input.js": __glob_0_106$1, "./icon_list/italic.js": __glob_0_107$1, "./icon_list/join_full.js": __glob_0_108$1, "./icon_list/join_right.js": __glob_0_109$1, "./icon_list/justify_content_space_around.js": __glob_0_110$1, "./icon_list/keyboard.js": __glob_0_111$1, "./icon_list/keyboard_arrow_down.js": __glob_0_112$1, "./icon_list/keyboard_arrow_left.js": __glob_0_113$1, "./icon_list/keyboard_arrow_right.js": __glob_0_114$1, "./icon_list/keyboard_arrow_up.js": __glob_0_115$1, "./icon_list/landscape.js": __glob_0_116$1, "./icon_list/launch.js": __glob_0_117$1, "./icon_list/layers.js": __glob_0_118$1, "./icon_list/layout_default.js": __glob_0_119$1, "./icon_list/layout_flex.js": __glob_0_120$1, "./icon_list/layout_grid.js": __glob_0_121, "./icon_list/left.js": __glob_0_122, "./icon_list/left_hide.js": __glob_0_123, "./icon_list/lens.js": __glob_0_124, "./icon_list/light.js": __glob_0_125, "./icon_list/line_cap_butt.js": __glob_0_126, "./icon_list/line_cap_round.js": __glob_0_127, "./icon_list/line_cap_square.js": __glob_0_128, "./icon_list/line_chart.js": __glob_0_129, "./icon_list/line_join_bevel.js": __glob_0_130, "./icon_list/line_join_miter.js": __glob_0_131, "./icon_list/line_join_round.js": __glob_0_132, "./icon_list/line_style.js": __glob_0_133, "./icon_list/line_weight.js": __glob_0_134, "./icon_list/list.js": __glob_0_135, "./icon_list/local_library.js": __glob_0_136, "./icon_list/local_movie.js": __glob_0_137, "./icon_list/lock.js": __glob_0_138, "./icon_list/lock_open.js": __glob_0_139, "./icon_list/looks.js": __glob_0_140, "./icon_list/margin.js": __glob_0_141, "./icon_list/merge.js": __glob_0_142, "./icon_list/middle.js": __glob_0_143, "./icon_list/navigation.js": __glob_0_144, "./icon_list/near_me.js": __glob_0_145, "./icon_list/north.js": __glob_0_146, "./icon_list/note.js": __glob_0_147, "./icon_list/nowrap.js": __glob_0_148, "./icon_list/opacity.js": __glob_0_149, "./icon_list/outline.js": __glob_0_150, "./icon_list/outline_circle.js": __glob_0_151, "./icon_list/outline_image.js": __glob_0_152, "./icon_list/outline_rect.js": __glob_0_153, "./icon_list/outline_shape.js": __glob_0_154, "./icon_list/padding.js": __glob_0_155, "./icon_list/paint.js": __glob_0_156, "./icon_list/palette.js": __glob_0_157, "./icon_list/pantool.js": __glob_0_158, "./icon_list/pattern_check.js": __glob_0_159, "./icon_list/pattern_cross_dot.js": __glob_0_160, "./icon_list/pattern_dot.js": __glob_0_161, "./icon_list/pattern_grid.js": __glob_0_162, "./icon_list/pattern_horizontal_line.js": __glob_0_163, "./icon_list/pause.js": __glob_0_164, "./icon_list/pentool.js": __glob_0_165, "./icon_list/photo.js": __glob_0_166, "./icon_list/play.js": __glob_0_167, "./icon_list/plugin.js": __glob_0_168, "./icon_list/polygon.js": __glob_0_169, "./icon_list/power_input.js": __glob_0_170, "./icon_list/publish.js": __glob_0_171, "./icon_list/rect.js": __glob_0_172, "./icon_list/redo.js": __glob_0_173, "./icon_list/refresh.js": __glob_0_174, "./icon_list/remove.js": __glob_0_175, "./icon_list/remove2.js": __glob_0_176, "./icon_list/repeat.js": __glob_0_177, "./icon_list/replay.js": __glob_0_178, "./icon_list/right.js": __glob_0_179, "./icon_list/right_hide.js": __glob_0_180, "./icon_list/rotate.js": __glob_0_181, "./icon_list/rotate_left.js": __glob_0_182, "./icon_list/round.js": __glob_0_183, "./icon_list/same_height.js": __glob_0_184, "./icon_list/same_width.js": __glob_0_185, "./icon_list/save.js": __glob_0_186, "./icon_list/scatter.js": __glob_0_187, "./icon_list/screen.js": __glob_0_188, "./icon_list/setting.js": __glob_0_189, "./icon_list/settings_input_component.js": __glob_0_190, "./icon_list/shadow.js": __glob_0_191, "./icon_list/shape.js": __glob_0_192, "./icon_list/shuffle.js": __glob_0_193, "./icon_list/size.js": __glob_0_194, "./icon_list/skip_next.js": __glob_0_195, "./icon_list/skip_prev.js": __glob_0_196, "./icon_list/smooth.js": __glob_0_197, "./icon_list/source.js": __glob_0_198, "./icon_list/south.js": __glob_0_199, "./icon_list/space.js": __glob_0_200, "./icon_list/specular.js": __glob_0_201, "./icon_list/speed.js": __glob_0_202, "./icon_list/star.js": __glob_0_203, "./icon_list/start.js": __glob_0_204, "./icon_list/storage.js": __glob_0_205, "./icon_list/straighten.js": __glob_0_206, "./icon_list/strikethrough.js": __glob_0_207, "./icon_list/stroke_to_path.js": __glob_0_208, "./icon_list/swap_horiz.js": __glob_0_209, "./icon_list/switch_left.js": __glob_0_210, "./icon_list/switch_right.js": __glob_0_211, "./icon_list/sync.js": __glob_0_212, "./icon_list/table_rows.js": __glob_0_213, "./icon_list/text_rotate.js": __glob_0_214, "./icon_list/texture.js": __glob_0_215, "./icon_list/timer.js": __glob_0_216, "./icon_list/title.js": __glob_0_217, "./icon_list/to_back.js": __glob_0_218, "./icon_list/to_front.js": __glob_0_219, "./icon_list/tonality.js": __glob_0_220, "./icon_list/top.js": __glob_0_221, "./icon_list/transform.js": __glob_0_222, "./icon_list/underline.js": __glob_0_223, "./icon_list/undo.js": __glob_0_224, "./icon_list/unfold.js": __glob_0_225, "./icon_list/vertical_align_baseline.js": __glob_0_226, "./icon_list/vertical_align_bottom.js": __glob_0_227, "./icon_list/vertical_align_center.js": __glob_0_228, "./icon_list/vertical_align_stretch.js": __glob_0_229, "./icon_list/vertical_align_top.js": __glob_0_230, "./icon_list/vertical_distribute.js": __glob_0_231, "./icon_list/video.js": __glob_0_232, "./icon_list/view_comfy.js": __glob_0_233, "./icon_list/view_list.js": __glob_0_234, "./icon_list/view_week.js": __glob_0_235, "./icon_list/view_week_reverse.js": __glob_0_236, "./icon_list/vignette.js": __glob_0_237, "./icon_list/vintage.js": __glob_0_238, "./icon_list/visible.js": __glob_0_239, "./icon_list/visible_off.js": __glob_0_240, "./icon_list/volume_down.js": __glob_0_241, "./icon_list/volume_off.js": __glob_0_242, "./icon_list/volume_up.js": __glob_0_243, "./icon_list/wave.js": __glob_0_244, "./icon_list/waves.js": __glob_0_245, "./icon_list/web.js": __glob_0_246, "./icon_list/west.js": __glob_0_247, "./icon_list/width.js": __glob_0_248, "./icon_list/wrap.js": __glob_0_249, "./icon_list/wrap_text.js": __glob_0_250 };
const obj$2 = {};
Object.entries(modules$7).forEach(([key, value]) => {
  key = key.replace("./icon_list/", "").replace(".js", "");
  obj$2[key] = value.default;
});
function iconUse(name, transform2 = "", opt = { width: 24, height: 24 }) {
  if (!name)
    return "";
  return `<svg viewBox="0 0 ${opt.width} ${opt.height}" xmlns="http://www.w3.org/2000/svg">
  <use href="#icon-${name}" transform="${transform2 || ""}" width="${opt.width}" height="${opt.height}" /> 
</svg>`;
}
function iconUseForPath(pathString2, opt = { width: 24, height: 24 }) {
  return `
    <svg viewBox="0 0 ${opt.width} ${opt.height}" xmlns="http://www.w3.org/2000/svg">
      <path d="${pathString2}" style="fill:${opt.fill || "transparent"};stroke:${opt.stroke || "white"}" stroke-width="1" />
    </svg>
  `;
}
function iconMake(svgString, opt = { width: 24, height: 24 }) {
  return `
    <svg viewBox="0 0 ${opt.width} ${opt.height}" xmlns="http://www.w3.org/2000/svg">
      ${svgString}
    </svg>
  `;
}
function iconBlank() {
  return iconMake(`<path d="M0 0h24v24H0z" fill="none" fill-opacity="0"/>`);
}
class ToolbarButtonMenuItem extends EditorElement {
  initialize() {
    super.initialize();
    const events = this.props.events || [];
    if (events.length) {
      events.forEach((event) => {
        this.on(event, () => this.refresh());
      });
    }
  }
  template() {
    let tooltip = this.props.tooltip ? `data-tooltip="${this.props.tooltip}"` : "";
    return `<button type="button"  class='elf--toolbar-menu-item' ${tooltip}></button>`;
  }
  [CLICK("$el")]() {
    if (this.props.command) {
      this.$commands.emit(this.props.command, ...this.props.args || []);
    } else if (isFunction(this.props.action)) {
      this.props.action(this.$editor, this);
    } else if (isFunction(this.props.onClick)) {
      this.props.onClick(this.$editor, this);
    }
    if (isFunction(this.props.nextTick)) {
      this.props.nextTick(this.$editor);
    }
  }
  [LOAD("$el") + DOMDIFF]() {
    let result = "";
    if (this.props.icon) {
      const iconName = isFunction(this.props.icon) ? this.props.icon(this.$editor) : this.props.icon;
      result += `<span class="icon">${iconUse(iconName)}</span>`;
    }
    if (this.props.title) {
      result += `<span class="title">${this.props.title}</span>`;
    }
    return result;
  }
  [BIND("$el")]() {
    const selected = isFunction(this.props.selected) ? this.props.selected(this.$editor) : false;
    const disabled = isFunction(this.props.disabled) ? this.props.disabled(this.$editor) : this.props.disabled;
    return {
      style: __spreadValues({}, this.props.style),
      "data-selected": selected,
      disabled
    };
  }
}
var ToolBarRenderer$1 = "";
function Divider() {
  return Dom.createByHTML(`<li class="dropdown-divider"></li>`);
}
class DropdownMenuItem extends EditorElement {
  initialize() {
    super.initialize();
    const events = this.props.events || [];
    if (events.length) {
      events.forEach((event) => {
        this.on(event, () => this.refresh());
      });
    }
  }
  template() {
    var _a;
    const it = this.props;
    const checked = isFunction(it.checked) ? it.checked(this.$editor) : it.checked;
    return `
          <li data-has-children="${Boolean((_a = it.items) == null ? void 0 : _a.length)}"
            ${it.disabled ? "disabled" : ""} 
            ${it.shortcut ? "shortcut" : ""}
            ${checked ? `checked` : ""}
          >
              <span class="icon">${checked ? iconUse("check") : it.icon || ""}</span>
              <div class='menu-item-text'>
                <label>${this.$i18n(it.title)}</label>
                <kbd class="shortcut">${it.shortcut || ""}</kbd>
              </div>
          </li>
        `;
  }
  [CLICK("$el") + PREVENT + STOP]() {
    console.log("click", this.props.command, this.props.args);
    if (this.props.command) {
      this.$commands.emit(this.props.command, ...this.props.args || []);
    } else if (isFunction(this.props.action)) {
      this.props.action(this.$editor, this);
    } else if (isFunction(this.props.onClick)) {
      this.props.action(this.$editor, this);
    }
    if (isFunction(this.props.nextTick)) {
      this.nextTick(() => {
        this.props.nextTick(this.$editor, this);
      });
    }
    if (this.props.closable) {
      this.parent.close();
    }
  }
}
class DropdownCheckboxMenuItem extends DropdownMenuItem {
  template() {
    return `<li class='checkbox'></li>`;
  }
  get checked() {
    if (isFunction(this.props.checked)) {
      return this.props.checked(this.$editor, this);
    }
    return this.props.checked;
  }
  [LOAD("$el") + DOMDIFF]() {
    return `
        <label>
          <input type="checkbox" ${this.checked ? 'checked="checked"' : ""} value="${this.props.value}" /> 
          ${this.$i18n(this.props.title)}
        </label>
      `;
  }
}
class DropdownCustomMenuItem extends DropdownMenuItem {
  template() {
    return `<li class='custom'></li>`;
  }
  getTemplateString() {
    if (isFunction(this.props.template)) {
      return this.props.template(this.$editor, this);
    }
    return this.$i18n(this.props.template);
  }
  [LOAD("$el") + DOMDIFF]() {
    return this.getTemplateString();
  }
}
function DropdownDividerMenuItem() {
  return `<li class="dropdown-divider"></li>`;
}
function DropdownLinkMenuItem() {
  return `<li>
        <a href="${this.props.href}" target="${this.props.target || "_blank"}">${this.$i18n(this.props.title)}</a>
      </li>`;
}
function DropdownTextMenuItem() {
  return `<li class='text'><label>${this.$i18n(this.props.text)}</label></li>`;
}
function makeMenuItem(it, id) {
  if (it === "-") {
    return createComponent("Divider", {
      ref: `${id}-divider`
    });
  }
  if (it === "-" || it.type === "divider") {
    return createComponent("DropdownDividerMenuItem", {
      ref: `${id}-divider`
    });
  }
  if (isString(it)) {
    return createComponent("DropdownTextMenuItem", {
      text: it,
      ref: `${id}-text`
    });
  }
  if (it.type === "link") {
    return createComponent("DropdownLinkMenuItem", {
      href: it.href,
      target: it.target,
      title: it.title,
      closable: it.closable,
      ref: `${id}-link`
    });
  }
  if (it.type === "custom") {
    return createComponent("DropdownCustomMenuItem", {
      action: it.action,
      command: it.command,
      args: it.args,
      icon: it.icon,
      text: it.text,
      events: it.events,
      template: it.template,
      closable: it.closable,
      ref: `${id}-custom`
    });
  }
  if (it.type === "checkbox") {
    return createComponent("DropdownCheckboxMenuItem", {
      checked: it.checked,
      command: it.command,
      args: it.args || [],
      disabled: it.disabled,
      direction: it.direction,
      icon: it.icon,
      nextTick: it.nextTick,
      onClick: it.onClick,
      action: it.action,
      shortcut: it.shortcut,
      title: it.title,
      key: it.key,
      events: it.events,
      closable: it.closable,
      items: it.items || [],
      ref: `${id}-checkbox`
    });
  }
  if (isArray(it.items)) {
    return createComponent("DropdownMenuList", {
      title: it.title,
      items: it.items,
      ref: `${id}-list`
    });
  }
  return createComponent("DropdownMenuItem", {
    checked: it.checked,
    command: it.command,
    args: it.args || [],
    disabled: it.disabled,
    direction: it.direction,
    icon: it.icon,
    nextTick: it.nextTick,
    onClick: it.onClick,
    action: it.action,
    shortcut: it.shortcut,
    title: it.title,
    key: it.key,
    events: it.events,
    closable: it.closable,
    items: it.items || [],
    ref: `${id}-menu-item`
  });
}
class DropdownMenuList extends EditorElement {
  components() {
    return {
      Divider,
      DropdownDividerMenuItem,
      DropdownLinkMenuItem,
      DropdownTextMenuItem,
      DropdownCustomMenuItem,
      DropdownCheckboxMenuItem,
      DropdownMenuList,
      DropdownMenuItem
    };
  }
  get groupId() {
    return `${this.props.id}-groupId`;
  }
  template() {
    return `
        <li class="dropdown-menu-list">
            <label>${this.$i18n(this.props.title)}</label> 
            <span>${iconUse("arrowRight")}</span>              
            <ul>
                ${this.props.items.map((child, index2) => makeMenuItem(child, `${this.groupId}-${index2}`)).join("")}
            </ul>
        </li>
      `;
  }
}
var DropdownMenu$1 = "";
function round(n, k) {
  k = typeof k === "undefined" ? 1 : k;
  return Math.round(n * k) / k;
}
function area(x, y, areaWidth = 100) {
  const column = x < 0 ? Math.floor(x / areaWidth) : Math.ceil(x / areaWidth);
  const row = y < 0 ? Math.floor(y / areaWidth) : Math.ceil(y / areaWidth);
  return [row, column];
}
function degreeToRadian(degrees) {
  return degrees * (Math.PI / 180);
}
function div(num, divNum = 1) {
  return num === 0 ? 0 : num / divNum;
}
function radianToDegree(radian) {
  var angle = radian * (180 / Math.PI);
  if (angle < 0) {
    angle = 360 + angle;
  }
  return angle;
}
function getXInCircle(angle, radius, centerX = 0) {
  return centerX + radius * Math.cos(degreeToRadian(angle));
}
function getYInCircle(angle, radius, centerY = 0) {
  return centerY + radius * Math.sin(degreeToRadian(angle));
}
function getXYInCircle(angle, radius, centerX = 0, centerY = 0) {
  return {
    x: getXInCircle(angle, radius, centerX),
    y: getYInCircle(angle, radius, centerY)
  };
}
function getDist(x, y, centerX = 0, centerY = 0) {
  return distance([x, y], [centerX, centerY]);
}
function getPointBetweenVerties(start2, end2, pointDist = 0) {
  return lerp([], start2, end2, 1 + pointDist / dist(start2, end2));
}
function vertiesMap(verties, transformView) {
  if (verties.length === 1) {
    return [transformMat4([], verties[0], transformView)];
  } else if (verties.length === 2) {
    return [
      transformMat4([], verties[0], transformView),
      transformMat4([], verties[1], transformView)
    ];
  } else if (verties.length === 3) {
    return [
      transformMat4([], verties[0], transformView),
      transformMat4([], verties[1], transformView),
      transformMat4([], verties[2], transformView)
    ];
  } else if (verties.length === 4) {
    return [
      transformMat4([], verties[0], transformView),
      transformMat4([], verties[1], transformView),
      transformMat4([], verties[2], transformView),
      transformMat4([], verties[3], transformView)
    ];
  } else if (verties.length === 5) {
    return [
      transformMat4([], verties[0], transformView),
      transformMat4([], verties[1], transformView),
      transformMat4([], verties[2], transformView),
      transformMat4([], verties[3], transformView),
      transformMat4([], verties[4], transformView)
    ];
  }
  return verties.map((v) => {
    return transformMat4([], v, transformView);
  });
}
function getTargetPointX(source2, target, axis, nextTarget) {
  return [
    source2,
    [target[0], source2[1], target[2]],
    axis,
    Math.abs(source2[0] - target[0]),
    nextTarget
  ];
}
function getTargetPointY(source2, target, axis, nextTarget) {
  return [
    [target[0], source2[1], source2[2]],
    target,
    axis,
    Math.abs(source2[1] - target[1]),
    nextTarget
  ];
}
function invertTargetPoint(arr, isInvert = false) {
  if (isInvert === false)
    return arr;
  const [source2, target, axis, dist2, newTarget, sourceVerties, targetVerties] = arr;
  if (newTarget) {
    return [
      [target[0], newTarget[1], target[2]],
      [source2[0], newTarget[1], source2[2]],
      axis,
      dist2,
      [source2[0], source2[1], newTarget[2]],
      sourceVerties,
      targetVerties,
      isInvert
    ];
  } else {
    return [
      target,
      source2,
      axis,
      dist2,
      newTarget,
      sourceVerties,
      targetVerties,
      isInvert
    ];
  }
}
function makeGuidePoint(sourceVerties, targetVerties) {
  let leftVerties = sourceVerties;
  let rightVerties = targetVerties;
  let hasInvert = false;
  if (sourceVerties[4][0] - targetVerties[4][0] > 0) {
    leftVerties = targetVerties;
    rightVerties = sourceVerties;
    hasInvert = true;
  }
  const leftCenter = lerp([], leftVerties[1], leftVerties[2], 0.5);
  const rightCenter = lerp([], rightVerties[0], rightVerties[3], 0.5);
  let pointList = [];
  if (rightVerties[0][1] <= leftCenter[1] && leftCenter[1] <= rightVerties[3][1]) {
    pointList.push(getTargetPointX(leftCenter, rightCenter, "x", null));
  } else if (rightVerties[0][1] <= leftVerties[1][1]) {
    if (rightVerties[3][0] <= leftVerties[1][0] && leftVerties[1][0] <= rightVerties[2][0]) {
      pointList.push(getTargetPointY(rightVerties[3], [rightVerties[3][0], leftVerties[1][1], leftVerties[1][2]], "y", null));
    } else {
      pointList.push(getTargetPointX(leftVerties[1], rightCenter, "x", rightVerties[3]));
    }
  } else if (leftVerties[3][0] <= rightVerties[0][0] && rightVerties[0][0] <= leftVerties[2][0]) {
    pointList.push(getTargetPointY(leftVerties[3], rightVerties[0], "y"));
  } else if (rightVerties[3][0] <= leftVerties[0][0] && leftVerties[0][0] <= rightVerties[2][0]) {
    pointList.push(getTargetPointY([rightVerties[0][0], leftVerties[3][1], leftVerties[3][2]], rightVerties[0], "y"));
  } else if (rightVerties[3][0] <= leftVerties[1][0] && leftVerties[1][0] <= rightVerties[2][0]) {
    pointList.push(getTargetPointY(rightVerties[3], [rightVerties[3][0], leftVerties[1][1], leftVerties[1][2]], "y"));
  } else {
    pointList.push(getTargetPointX(leftVerties[2], rightCenter, "x", rightVerties[0]));
  }
  pointList.sort((a, b) => {
    return a[3] - b[3];
  });
  return invertTargetPoint([...pointList[0], sourceVerties, targetVerties], hasInvert);
}
function getVertiesMaxX(verties) {
  let maxValue = Number.MIN_SAFE_INTEGER;
  verties.forEach((v) => {
    maxValue = Math.max(v[0], maxValue);
  });
  return maxValue;
}
function getVertiesMaxY(verties) {
  let maxValue = Number.MIN_SAFE_INTEGER;
  verties.forEach((v) => {
    maxValue = Math.max(v[1], maxValue);
  });
  return maxValue;
}
function getVertiesMinX(verties) {
  let maxValue = Number.MAX_SAFE_INTEGER;
  verties.forEach((v) => {
    maxValue = Math.min(v[0], maxValue);
  });
  return maxValue;
}
function getVertiesCenterX(verties) {
  let minX = Number.MAX_SAFE_INTEGER;
  let maxX = Number.MIN_SAFE_INTEGER;
  verties.forEach((v) => {
    minX = Math.min(v[0], minX);
    maxX = Math.max(v[0], maxX);
  });
  return Math.round((minX + maxX) / 2);
}
function getVertiesMinY(verties) {
  let maxValue = Number.MAX_SAFE_INTEGER;
  verties.forEach((v) => {
    maxValue = Math.min(v[1], maxValue);
  });
  return maxValue;
}
function getVertiesCenterY(verties) {
  let minY = Number.MAX_SAFE_INTEGER;
  let maxY = Number.MIN_SAFE_INTEGER;
  verties.forEach((v) => {
    minY = Math.min(v[1], minY);
    maxY = Math.max(v[1], maxY);
  });
  return Math.round((minY + maxY) / 2);
}
function calculateAngle(rx, ry) {
  return radianToDegree(Math.atan2(ry, rx));
}
function calculateAngleForVec3(point2, center2, dist2) {
  return calculateAnglePointDistance({ x: point2[0], y: point2[1] }, { x: center2[0], y: center2[1] }, { dx: dist2[0], dy: dist2[1] });
}
function calculateRotationOriginMat4(angle, origin) {
  const view = create$4();
  translate(view, view, origin);
  rotateZ(view, view, degreeToRadian(angle));
  translate(view, view, negate([], origin));
  return view;
}
function calculateMatrix(...args2) {
  const view = create$4();
  args2.forEach((v) => {
    multiply$1(view, view, v);
  });
  return view;
}
function calculateMatrixInverse(...args2) {
  return invert([], calculateMatrix(...args2));
}
function calculateAnglePointDistance(point2, center2, dist2) {
  var x = point2.x - center2.x;
  var y = point2.y - center2.y;
  var angle1 = calculateAngle(x, y);
  var x2 = point2.x + dist2.dx - center2.x;
  var y2 = point2.y + dist2.dy - center2.y;
  var angle = calculateAngle(x2, y2) - angle1;
  return angle;
}
function calculateAngle360(rx, ry) {
  return (calculateAngle(rx, ry) + 180) % 360;
}
const UUID_REG = /[xy]/g;
function uuid() {
  var dt = new Date().getTime();
  var uuid2 = "xxx12-xx-34xx".replace(UUID_REG, function(c2) {
    var r = (dt + Math.random() * 16) % 16 | 0;
    dt = Math.floor(dt / 16);
    return (c2 == "x" ? r : r & 3 | 8).toString(16);
  });
  return uuid2;
}
function uuidShort() {
  var dt = new Date().getTime();
  var uuid2 = "idxxxxxxx".replace(UUID_REG, function(c2) {
    var r = (dt + Math.random() * 16) % 16 | 0;
    dt = Math.floor(dt / 16);
    return (c2 == "x" ? r : r & 3 | 8).toString(16);
  });
  return uuid2;
}
const splitReg$1 = /[\b\t ,\n]/g;
function normalize(str) {
  return str.trim().split(splitReg$1).filter((it) => it).map((it) => +it);
}
const stringToPercent = {
  center: 50,
  top: 0,
  left: 0,
  right: 100,
  bottom: 100
};
class Position {
}
Position.CENTER = "center";
Position.TOP = "top";
Position.RIGHT = "right";
Position.LEFT = "left";
Position.BOTTOM = "bottom";
const REG_CSS_UNIT$1 = /([\d.]+)(px|pt|fr|r?em|deg|vh|vw|m?s|%|g?rad|turn)/gi;
class Length {
  constructor(value = "", unit = "") {
    this.value = value;
    if (isNumber(this.value) && isNaN(this.value)) {
      this.value = 0;
    }
    this.unit = unit;
  }
  [Symbol.toPrimitive](hint) {
    if (hint == "number") {
      return this.value;
    }
    return this.toString();
  }
  static min(...args2) {
    var min = args2.shift();
    for (var i = 0, len2 = args2.length; i < len2; i++) {
      if (min.value > args2[i].value) {
        min = args2[i];
      }
    }
    return min;
  }
  static max(...args2) {
    var max = args2.shift();
    for (var i = 0, len2 = args2.length; i < len2; i++) {
      if (max.value < args2[i].value) {
        max = args2[i];
      }
    }
    return max;
  }
  static string(value) {
    return new Length(value + "", "");
  }
  static number(value) {
    return new Length(+value, "number");
  }
  static px(value) {
    return new Length(+value, "px");
  }
  static em(value) {
    return new Length(+value, "em");
  }
  static percent(value) {
    return new Length(+value, "%");
  }
  static makePercent(value, maxValue) {
    return Length.percent(value / maxValue * 100);
  }
  static deg(value) {
    return new Length(+value, "deg");
  }
  static rad(value) {
    return new Length(+value, "rad");
  }
  static turn(value) {
    return new Length(+value, "turn");
  }
  static fr(value) {
    return new Length(+value, "fr");
  }
  static second(value) {
    return new Length(+value, "s");
  }
  static ms(value) {
    return new Length(+value, "ms");
  }
  static var(value) {
    return new Length(value + "", "--");
  }
  static z() {
    return 0;
  }
  static calc(str) {
    return new Length(str, "calc");
  }
  static parse(obj2) {
    obj2 = obj2 || Length.number(0);
    if (isString(obj2)) {
      obj2 = obj2.trim();
      var arr = obj2.replace(REG_CSS_UNIT$1, "$1 $2").split(" ");
      var isNumberString = +arr[0] == arr[0];
      if (isNumberString) {
        return new Length(+arr[0], arr[1]);
      } else {
        return new Length(arr[0]);
      }
    }
    if (obj2 instanceof Length) {
      return obj2;
    } else if (obj2.unit) {
      if (obj2.unit == "%" || obj2.unit == "percent") {
        var value = 0;
        if (isNotUndefined(obj2.percent)) {
          value = obj2.percent;
        } else if (isNotUndefined(obj2.value)) {
          value = obj2.value;
        }
        return Length.percent(value);
      } else if (obj2.unit == "px") {
        var value = 0;
        if (isNotUndefined(obj2.px)) {
          value = obj2.px;
        } else if (isNotUndefined(obj2.value)) {
          value = obj2.value;
        }
        return value;
      } else if (obj2.unit == "em") {
        var value = 0;
        if (isNotUndefined(obj2.em)) {
          value = obj2.em;
        } else if (isNotUndefined(obj2.value)) {
          value = obj2.value;
        }
        return Length.em(value);
      } else if (obj2.unit == "deg") {
        var value = 0;
        if (isNotUndefined(obj2.deg)) {
          value = obj2.deg;
        } else if (isNotUndefined(obj2.value)) {
          value = obj2.value;
        }
        return Length.deg(value);
      } else if (obj2.unit == "turn") {
        var value = 0;
        if (isNotUndefined(obj2.deg)) {
          value = obj2.turn;
        } else if (isNotUndefined(obj2.value)) {
          value = obj2.value;
        }
        return Length.turn(value);
      } else if (obj2.unit == "s") {
        var value = 0;
        if (isNotUndefined(obj2.second)) {
          value = obj2.second;
        } else if (isNotUndefined(obj2.value)) {
          value = obj2.value;
        }
        return Length.second(value);
      } else if (obj2.unit == "ms") {
        var value = 0;
        if (isNotUndefined(obj2.ms)) {
          value = obj2.ms;
        } else if (isNotUndefined(obj2.value)) {
          value = obj2.value;
        }
        return Length.ms(value);
      } else if (obj2.unit == "number") {
        var value = 0;
        if (isNotUndefined(obj2.value)) {
          value = obj2.value;
        }
        return Length.number(value);
      } else if (obj2.unit == "--") {
        var value = 0;
        if (isNotUndefined(obj2.value)) {
          value = obj2.value;
        }
        return Length.var(value);
      } else if (obj2.unit === "" || obj2.unit === "string") {
        var value = "";
        if (isNotUndefined(obj2.str)) {
          value = obj2.str;
        } else if (isNotUndefined(obj2.value)) {
          value = obj2.value;
        }
        return Length.string(value);
      }
    }
    return Length.string(obj2);
  }
  toString() {
    return this.getUnitText();
  }
  getUnitText() {
    switch (this.unit) {
      case "string":
      case "number":
        return this.value + "";
      case "var":
        return `var(--${this.value})`;
      case "calc":
        return `calc(${this.value})`;
      default:
        return this.value + this.unit;
    }
  }
  isUnitType(unit) {
    return this.unit === unit;
  }
  isCalc() {
    return this.isUnitType("calc");
  }
  isFr() {
    return this.isUnitType("fr");
  }
  isPercent() {
    return this.isUnitType("%");
  }
  isPx() {
    return this.isUnitType("px");
  }
  isEm() {
    return this.isUnitType("em");
  }
  isDeg() {
    return this.isUnitType("deg");
  }
  isRad() {
    return this.isUnitType("rad");
  }
  isTurn() {
    return this.isUnitType("turn");
  }
  isSecond() {
    return this.isUnitType("s");
  }
  isMs() {
    return this.isUnitType("ms");
  }
  isNumber() {
    return this.isUnitType("number") || this.isUnitType("");
  }
  isString() {
    return this.isUnitType("");
  }
  isVar() {
    return this.isUnitType("--");
  }
  isNaN() {
    return isNumber(this.value) && isNaN(this.value);
  }
  set(value) {
    this.value = value;
    return this;
  }
  add(obj2) {
    this.value += +obj2;
    return this;
  }
  sub(obj2) {
    return this.add(-1 * obj2);
  }
  mul(obj2) {
    this.value *= +obj2;
    return this;
  }
  div(obj2) {
    this.value /= +obj2;
    return this;
  }
  mod(obj2) {
    this.value %= +obj2;
    return this;
  }
  clone() {
    return new Length(this.value, this.unit);
  }
  getUnitName() {
    return this.unit === "%" ? "percent" : this.unit;
  }
  get isAuto() {
    return this.value === "auto" || this.unit === "auto";
  }
  get isNotAuto() {
    return !this.isAuto;
  }
  toJSON() {
    return this.toString();
  }
  rate(maxValue = 100) {
    return this.value / maxValue;
  }
  stringToPercent() {
    if (isNotUndefined(stringToPercent[this.value])) {
      return Length.percent(stringToPercent[this.value]);
    }
    return Length.percent(0);
  }
  stringToEm(maxValue) {
    return this.stringToPercent().toEm(maxValue);
  }
  stringToPx(maxValue) {
    return this.stringToPercent().toPx(maxValue);
  }
  toPercent(maxValue, fontSize = 16) {
    if (this.isPercent()) {
      return this.clone();
    } else if (this.isPx()) {
      return Length.percent(this.value * 100 / maxValue);
    } else if (this.isEm()) {
      return Length.percent(this.value * fontSize * 100 / maxValue);
    } else if (this.isString()) {
      return this.stringToPercent(maxValue);
    } else if (this.isDeg()) {
      return Length.percent(this.value / 360 * 100);
    }
  }
  toEm(maxValue, fontSize = 16) {
    if (this.isPercent()) {
      return Length.em(this.value / 100 * maxValue / fontSize);
    } else if (this.isPx()) {
      return Length.em(this.value / fontSize);
    } else if (this.isEm()) {
      return this.clone();
    } else if (this.isString()) {
      return this.stringToEm(maxValue);
    }
  }
  toPx(maxValue, fontSize = 16) {
    if (this.isPercent()) {
      if (isUndefined(maxValue)) {
        return this;
      }
      return Length.px(this.value / 100 * maxValue);
    } else if (this.isPx()) {
      return this.clone();
    } else if (this.isEm()) {
      return Length.px(this.value / 100 * maxValue / fontSize);
    } else if (this.isString()) {
      return this.stringToPx(maxValue);
    } else if (this.isNumber()) {
      return Length.px(this.value).toPx(maxValue);
    }
  }
  toDeg() {
    if (this.isDeg()) {
      return this.clone();
    } else if (this.isTurn()) {
      return Length.deg(this.value * 360);
    } else if (this.isRad()) {
      return Length.deg(radianToDegree(this.value));
    }
  }
  toRad() {
    if (this.isRad()) {
      return this.clone();
    } else if (this.isTurn()) {
      const deg = this.toDeg();
      return Length.rad(degreeToRadian(deg.value));
    } else if (this.isDeg()) {
      return Length.rad(degreeToRadian(this.value));
    }
  }
  toTurn() {
    if (this.isTurn()) {
      return this.clone();
    } else if (this.isDeg()) {
      return Length.turn(this.value / 360);
    }
  }
  toSecond() {
    if (this.isSecond()) {
      return this;
    } else if (this.isMs()) {
      return Length.second(this.value / 1e3);
    }
  }
  toMs() {
    if (this.isSecond()) {
      return Length.ms(this.value * 1e3);
    } else if (this.isMs()) {
      return this;
    }
  }
  to(unit, maxValue, fontSize = 16) {
    if (unit === "px") {
      return this.toPx(maxValue, fontSize);
    } else if (unit === "%" || unit === "percent") {
      return this.toPercent(maxValue, fontSize);
    } else if (unit === "em") {
      return this.toEm(maxValue, fontSize);
    } else if (unit === "deg") {
      return this.toDeg();
    } else if (unit === "turn") {
      return this.toTurn();
    }
  }
  toUnit(unit) {
    return new Length(this.value, unit);
  }
  calculate(type, dist2) {
    var func = this[type];
    if (func) {
      return func.call(this, dist2);
    }
    return this;
  }
  includes(...arr) {
    return arr.includes(this.value);
  }
  round(k) {
    return new Length(round(this.value, k), this.unit);
  }
  floor() {
    return new Length(Math.floor(this.value), this.unit);
  }
  equals(t) {
    return this.is(t.value) && this.isUnitType(t.unit);
  }
  is(value) {
    return this.value === value;
  }
  clamp(min, max) {
    return new Length(Math.max(min, Math.min(max, this.value)), this.unit);
  }
  isZero() {
    return this.value === 0;
  }
  changeUnitValue(px, maxValue) {
    const unit = this.unit;
    return Length.px(px).to(unit, maxValue);
  }
  toObject() {
    return { value: this.value, unit: this.unit };
  }
}
Length.auto = Length.string("auto");
class DropdownMenu extends EditorElement {
  components() {
    return {
      Divider,
      DropdownDividerMenuItem,
      DropdownLinkMenuItem,
      DropdownTextMenuItem,
      DropdownCustomMenuItem,
      DropdownCheckboxMenuItem,
      DropdownMenuList,
      DropdownMenuItem
    };
  }
  initialize() {
    super.initialize();
    const events = this.props.events || [];
    if (events.length) {
      events.forEach((event) => {
        this.on(event, () => this.refresh());
      });
    }
  }
  initState() {
    return {
      direction: this.props.direction || "left",
      opened: this.props.opened || false,
      items: this.props.items || [],
      dy: this.props.dy || 0
    };
  }
  findItem(searchKey) {
    return this.state.items.find((it) => it.key && it.key === searchKey);
  }
  template() {
    const { direction: direction2 } = this.state;
    return `
        <div class="${classnames("dropdown-menu", {
      opened: false
    })}" data-direction="${direction2}">
          <span class='icon' ref="$icon"></span>
          <span class='label' ref='$label'></span>
          <span class='dropdown-arrow' ref="$arrow">${iconUse("keyboard_arrow_down")}</span>
          <ul class="dropdown-menu-item-list" ref="$list"></ul>
          <div class="dropdown-menu-arrow">
              <svg viewBox="0 0 12 6" width="12" height="6">
                <path d="M0,6 L6,0 L12,6 "></path>
              </svg>
          </div>
      </div>
      `;
  }
  [LOAD("$icon")]() {
    return isFunction(this.props.icon) ? this.props.icon(this.$editor, this) : this.props.icon;
  }
  [BIND("$label")]() {
    return {
      innerHTML: this.props.title
    };
  }
  [BIND("$el")]() {
    const selected = isFunction(this.props.selected) ? this.props.selected(this.$editor, this) : false;
    return {
      "data-selected": !!selected,
      style: __spreadProps(__spreadValues({}, this.props.style || {}), {
        "--elf--dropdown-menu-width": this.props.width,
        "--elf--dropdown-menu-dy": isNotUndefined(this.props.dy) ? Length.px(this.props.dy) : 0
      })
    };
  }
  close() {
    this.setState({
      opened: false
    }, false);
    this.$el.removeClass("opened");
  }
  toggle() {
    this.setState({
      opened: !this.state.opened
    }, false);
    this.$el.toggleClass("opened", this.state.opened);
    if (this.state.opened) {
      this.emit("hideDropdownMenu");
    }
  }
  get groupId() {
    return this.id + "$list";
  }
  [LOAD("$list") + DOMDIFF]() {
    return this.state.items.map((it, index2) => makeMenuItem(it, `${this.groupId}-${index2}`));
  }
  checkDropdownOpen(e) {
    const ul = Dom.create(e.target).closest("dropdown-menu-item-list");
    if (!ul)
      return true;
    return false;
  }
  [CLICK("$arrow") + IF("checkDropdownOpen")]() {
    this.toggle();
  }
  [CLICK("$label") + IF("checkDropdownOpen")]() {
    this.toggle();
  }
  [CLICK("$icon")]() {
    const selectedKey = isFunction(this.props.selectedKey) ? this.props.selectedKey(this.$editor, this) : this.props.selectedKey;
    const menuItem = this.findItem(selectedKey);
    if (!menuItem) {
      if (isFunction(this.props.action)) {
        this.props.action(this.$editor, this);
      }
      return;
    }
    const command = menuItem.command;
    const args2 = menuItem.args;
    const action = menuItem.action;
    const nextTick = menuItem.nextTick;
    if (command) {
      this.$commands.emit(command, ...args2);
    } else if (action && isFunction(action)) {
      this.emit(action);
    }
    if (nextTick && isFunction(nextTick)) {
      this.nextTick(() => {
        nextTick(this.$editor);
      });
    }
    this.close();
  }
  [SUBSCRIBE_SELF("updateMenuItems")](items) {
    this.setState({ items });
  }
  [SUBSCRIBE("hideDropdownMenu")]() {
    this.close();
  }
  [POINTERSTART("document")](e) {
    const $target = Dom.create(e.target);
    const $dropdown = $target.closest("dropdown-menu");
    if (!$dropdown) {
      this.close();
    } else if ($dropdown.el !== this.$el.el) {
      this.close();
    }
  }
}
class ToolBarRenderer extends EditorElement {
  checkProps(props = {}) {
    return props;
  }
  components() {
    return {
      DropdownMenu,
      ToolbarButtonMenuItem
    };
  }
  template() {
    return `<div class="elf--toolbar-renderer"></div>`;
  }
  [LOAD("$el")]() {
    return this.props.items.map((item, index2) => {
      return this.renderMenuItem(item, index2);
    });
  }
  renderMenuItem(item, index2) {
    switch (item.type) {
      case MenuItemType.LINK:
        return this.renderLink(item, index2);
      case MenuItemType.SUBMENU:
        return this.renderMenu(item, index2);
      case MenuItemType.BUTTON:
        return this.renderButton(item, index2);
      case MenuItemType.DROPDOWN:
        return this.renderDropdown(item, index2);
      default:
        return this.renderButton(item, index2);
    }
  }
  renderButton(item, index2) {
    return createComponent("ToolbarButtonMenuItem", {
      ref: "$button-" + index2,
      title: item.title,
      tooltip: item.tooltip,
      icon: item.icon,
      command: item.command,
      shortcut: item.shortcut,
      args: item.args,
      nextTick: item.nextTick,
      disabled: item.disabled,
      selected: item.selected,
      selectedKey: item.selectedKey,
      action: item.action,
      events: item.events,
      style: item.style
    });
  }
  renderDropdown(item, index2) {
    return createComponent("DropdownMenu", __spreadProps(__spreadValues({
      ref: "$dropdown-" + index2
    }, item), {
      items: item.items,
      icon: item.icon,
      title: item.title,
      tooltip: item.tooltip,
      direction: item.direction,
      events: item.events || [],
      selected: item.selected,
      selectedKey: item.selectedKey,
      action: item.action,
      style: item.style,
      dy: 6
    }), [item.content]);
  }
}
class BlankToolBar extends EditorElement {
  components() {
    return {
      ToolBarRenderer
    };
  }
  template() {
    return `
            <div class='elf--blank-tool-bar'>
              <div class="logo-area">
                ${createComponent("ToolBarRenderer", {
      items: this.$menu.getTargetMenu("toolbar.logo")
    })}
              </div>            
              <div class="toolbar-area">
                <div class='left'>
                    ${createComponent("ToolBarRenderer", {
      items: this.$menu.getTargetMenu("toolbar.left")
    })}
                    ${this.$injectManager.generate("toolbar.left")}                                        
                </div>
                <div class='center'>
                    ${createComponent("ToolBarRenderer", {
      items: this.$menu.getTargetMenu("toolbar.center")
    })}
                    ${this.$injectManager.generate("toolbar.center")}                                        
                </div>
                <div class='right'>
                    ${createComponent("ToolBarRenderer", {
      items: this.$menu.getTargetMenu("toolbar.right", "desc")
    })}                
                    ${this.$injectManager.generate("toolbar.right")}                    
                </div>
              </div>
            </div>
        `;
  }
  [SUBSCRIBE("updateMenu")](target) {
    if (target === "toolbar.left" || target === "toolbar.center" || target === "toolbar.right") {
      this.refresh();
    }
  }
}
var layout$2 = "";
var show_left_panel$1 = {
  key: "show.left.panel",
  defaultValue: true,
  title: "Show left panel",
  description: "Set left panel visibility to on",
  type: "boolean"
};
var __glob_0_0$6 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": show_left_panel$1
}, Symbol.toStringTag, { value: "Module" }));
var show_right_panel$1 = {
  key: "show.right.panel",
  defaultValue: true,
  title: "Show right panel",
  description: "Set right panel visibility to on",
  type: "boolean"
};
var __glob_0_1$6 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": show_right_panel$1
}, Symbol.toStringTag, { value: "Module" }));
const modules$6 = { "./config_list/show.left.panel.js": __glob_0_0$6, "./config_list/show.right.panel.js": __glob_0_1$6 };
var configs$4 = Object.values(modules$6).map((it) => it.default);
function configs$3(editor) {
  configs$4.forEach((config) => {
    editor.registerConfig(config);
  });
}
function baseEditor(editor) {
  editor.registerElement({
    Button,
    ToggleButton,
    ToggleCheckBox
  });
  editor.registerAlias({
    "toggle-checkbox": "ToggleCheckBox",
    "toggle-button": "ToggleButton",
    button: "Button"
  });
}
var body_move_ms = {
  key: "body.move.ms",
  defaultValue: 30,
  title: "pointer move delay millisecond",
  description: "Set delay millisecond to moving pointer in body  ",
  type: "number"
};
var __glob_0_0$5 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": body_move_ms
}, Symbol.toStringTag, { value: "Module" }));
var debug_mode$1 = {
  key: "debug.mode",
  defaultValue: false,
  title: "debug mode",
  description: "Set debug mode to on ",
  type: "boolean"
};
var __glob_0_1$5 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": debug_mode$1
}, Symbol.toStringTag, { value: "Module" }));
var editor_cursor = {
  key: "editor.cursor",
  defaultValue: "auto",
  title: "Editor Cursor ",
  description: "Set editor's cursor",
  type: "string"
};
var __glob_0_2$5 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": editor_cursor
}, Symbol.toStringTag, { value: "Module" }));
var editor_theme = {
  key: "editor.theme",
  defaultValue: "light",
  title: "Editor Theme ",
  description: "Set editor's theme",
  type: "string"
};
var __glob_0_3$5 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": editor_theme
}, Symbol.toStringTag, { value: "Module" }));
var event_doubleclick_timing = {
  key: "event.doubleclick.timing",
  defaultValue: 500,
  title: "doubleclick timing",
  description: "whether doubleclick timing is in some seconds",
  type: "number"
};
var __glob_0_4$5 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": event_doubleclick_timing
}, Symbol.toStringTag, { value: "Module" }));
var language_locale = {
  key: "language.locale",
  defaultValue: Language.EN,
  title: "set locale for editor",
  description: "set locale for editor",
  type: "string"
};
var __glob_0_5$5 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": language_locale
}, Symbol.toStringTag, { value: "Module" }));
var store_key = {
  key: "store.key",
  defaultValue: "easylogic.studio",
  title: "Store Key",
  description: "Set localStorage key",
  type: "string"
};
var __glob_0_6$5 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": store_key
}, Symbol.toStringTag, { value: "Module" }));
var style_canvas_background_color = {
  key: "style.canvas.background.color",
  defaultValue: "#ececec",
  title: "Canvas Background Color",
  description: "Set canvas background color",
  type: "color"
};
var __glob_0_7$5 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": style_canvas_background_color
}, Symbol.toStringTag, { value: "Module" }));
const modules$5 = { "./config_list/body.move.ms.js": __glob_0_0$5, "./config_list/debug.mode.js": __glob_0_1$5, "./config_list/editor.cursor.js": __glob_0_2$5, "./config_list/editor.theme.js": __glob_0_3$5, "./config_list/event.doubleclick.timing.js": __glob_0_4$5, "./config_list/language.locale.js": __glob_0_5$5, "./config_list/store.key.js": __glob_0_6$5, "./config_list/style.canvas.background.color.js": __glob_0_7$5 };
var configs$2 = Object.values(modules$5).map((it) => it.default);
function defaultConfigs(editor) {
  configs$2.forEach((config) => {
    editor.registerConfig(config);
  });
}
function defaultIcons(editor) {
  editor.registerIcon("artboard", "artboard");
  editor.registerIcon("circle", "lens");
  editor.registerIcon("image", "image");
  editor.registerIcon("text", "title");
  editor.registerIcon("svg-text", "title");
  editor.registerIcon("boolean-path", "pentool");
  editor.registerIcon("svg-path", "pentool");
  editor.registerIcon("polygon", "polygon");
  editor.registerIcon("star", "star");
  editor.registerIcon("spline", "smooth");
  editor.registerIcon("rect", "rect");
}
var en_US = {
  "app.title": "elf",
  "app.sample": (a, b, c2) => {
    return `${a}-${b}-${c2}`;
  },
  "app.lang.en_US": "English",
  "app.lang.ko_KR": "\uD55C\uAD6D\uC5B4",
  "app.lang.fr_FR": "Fran\xE7ais",
  "app.label.lang": "Language",
  "app.layout.all": "Layout",
  "app.layout.css": "CSS Mode",
  "app.layout.svg": "SVG Mode",
  "app.label.layout": "Menu Layout",
  "app.theme.dark": "Dark",
  "app.theme.light": "Light",
  "app.theme.toon": "Toon",
  "app.theme.gray": "Gray",
  "app.label.theme": "Theme",
  "app.tab.title.projects": "Projects",
  "app.tab.title.layers": "Layers",
  "app.tab.title.libraries": "Library",
  "app.tab.title.components": "Component",
  "app.tab.title.artboards": "Artboard",
  "app.tab.title.assets": "Assets",
  "app.tab.title.keyMap": "KeyMap",
  "app.confirm.message.artboard.items.removeArtboard": "Do you remove an artboard preview really?",
  "app.confirm.message.custom-component.items.removeCustomComponent": "Do you remove a custom component preview really?",
  "menu.item.download.title": "Source",
  "menu.item.save.title": "Save",
  "menu.item.export.title": "Export",
  "menu.item.codepen.title": "CodePen",
  "menu.item.fullscreen.title": "Full Screen",
  "menu.item.shortcuts.title": "ShortCuts",
  "menu.item.github.title": "Github",
  "menu.item.learn.title": "Learn",
  "menu.item.projects.title": "Projects",
  "menu.item.language.title": "Language",
  "project.property.title": "Project",
  "project.information.property.title": "Project information",
  "project.information.property.name": "Name",
  "project.information.property.description": "Description",
  "artboard.property.title": "ArtBoards",
  "artboard.property.layout.title.flex": "Flex",
  "artboard.property.layout.title.grid": "Grid",
  "layer.tree.property.title": "Layers",
  "layer.tree.property.layout.title.flex": "Flex",
  "layer.tree.property.layout.title.grid": "Grid",
  "alignment.property.title": "Alignment",
  "position.property.title": "Position",
  "position.property.X": "X",
  "position.property.Y": "Y",
  "size.property.title": "Size",
  "position.property.width": "W",
  "position.property.height": "H",
  "position.property.opacity": "Opacity",
  "position.property.rotate": "Rotate",
  "background.color.property.title": "Appearance",
  "background.color.property.color": "Color",
  "background.color.property.zindex": "z-index",
  "background.color.property.blend": "Blend",
  "background.color.property.overflow": "Overflow",
  "background.color.property.overflow.visible": "Visible",
  "background.color.property.overflow.hidden": "Hidden",
  "background.color.property.overflow.scroll": "Scroll",
  "background.color.property.overflow.auto": "Auto",
  "blend.normal": "normal",
  "blend.multiply": "multiply",
  "blend.screen": "screen",
  "blend.overlay": "overlay",
  "blend.darken": "darken",
  "blend.lighten": "lighten",
  "blend.color-dodge": "color-dodge",
  "blend.color-burn": "color-burn",
  "blend.hard-light": "hard-light",
  "blend.soft-light": "soft-light",
  "blend.difference": "difference",
  "blend.exclusion": "exclusion",
  "blend.hue": "hue",
  "blend.saturation": "saturation",
  "blend.color": "color",
  "blend.luminosity": "luminosity",
  "background.image.property.title": "Fill",
  "border.property.title": "Border",
  "border.radius.property.title": "Border Radius",
  "boxshadow.property.title": "Box Shadows",
  "filter.property.title": "Filter",
  "filter.property.blur": "Blur",
  "filter.property.grayscale": "GrayScale",
  "filter.property.hue-rotate": "Hue Rotate",
  "filter.property.invert": "Invert",
  "filter.property.brightness": "Brightness",
  "filter.property.contrast": "Contrast",
  "filter.property.drop-shadow": "Drop Shadow",
  "filter.property.drop-shadow.color": "Color",
  "filter.property.drop-shadow.offsetX": "Offset X",
  "filter.property.drop-shadow.offsetY": "Offset Y",
  "filter.property.drop-shadow.blurRadius": "Blur",
  "filter.property.opacity": "Opacity",
  "filter.property.saturate": "Saturate",
  "filter.property.sepia": "Sepia",
  "filter.property.svg": "SVG",
  "font.property.title": "Font",
  "font.property.color": "Color",
  "font.property.size": "Size",
  "font.property.stretch": "Stretch",
  "font.property.weight": "Weight",
  "font.property.style": "Style",
  "font.property.family": "Family",
  "font.spacing.property.title": "Font spacing",
  "font.spacing.property.lineHeight": "Line height",
  "font.spacing.property.letterSpacing": "Letter spacing",
  "font.spacing.property.wordSpacing": "Word spacing",
  "font.spacing.property.indent": "Indent",
  "backdrop.filter.property.title": "Backdrop Filter",
  "clippath.property.title": "Clip Path",
  "export.property.title": "Export",
  "export.property.download": "Download",
  "iframe.property.title": "IFrame",
  "image.property.title": "Image",
  "image.property.origin": "Origin",
  "image.property.size": "Size",
  "image.property.width": "Width",
  "image.property.height": "height",
  "video.property.title": "Video",
  "video.property.play": "Play",
  "video.property.pause": "Pause",
  "video.property.volume": "Volume",
  "video.property.playbackRate": "Playback Rate",
  "video.property.currentTime": "Current Time",
  "video.property.playTime": "Play Time Distance",
  "motion.property.title": "Motion",
  "text.property.title": "Text Style",
  "text.property.align": "Align",
  "text.property.transform": "Transform",
  "text.property.decoration": "Decoration",
  "text.clip.property.title": "Text Clip",
  "text.shadow.property.title": "Text Shadows",
  "text.fill.property.title": "Text Fill",
  "text.fill.property.fill": "Fill",
  "text.fill.property.stroke": "Stroke",
  "text.fill.property.strokeWidth": "Width",
  "transform.property.title": "Transform",
  "transform.origin.property.title": "Transform Origin",
  "transition.property.title": "CSS Transition",
  "keyframe.property.title": "CSS Keyframe",
  "selector.property.title": "Selector",
  "selector.property.none": "None selector",
  "path.data.property.title": "Path Information",
  "polygon.data.property.title": "Polygon Information",
  "perspective.property.title": "Perspective",
  "perspective.origin.property.title": "Perspective Origin",
  "svg.item.property.title": "Appearance",
  "svg.item.property.isMotionPath": "Motion Path",
  "svg.item.property.fill": "Fill",
  "svg.item.property.fillOpacity": "Opacity",
  "svg.item.property.path": "Path",
  "svg.item.property.polygon": "Polygon",
  "svg.item.property.totalLength": "Total Length",
  "svg.item.property.fillRule": "Fill Rule",
  "svg.item.property.stroke": "Stroke",
  "svg.item.property.strokeWidth": "Width",
  "svg.item.property.dashArray": "Dash Array",
  "svg.item.property.dashOffset": "Dash Offset",
  "svg.item.property.lineCap": "Line Cap",
  "svg.item.property.lineJoin": "Line Join",
  "svg.item.property.filter": "Filter",
  "svg.item.property.blend": "Blend Mode",
  "border.editor.all": "All",
  "border.editor.width": "Width",
  "border.editor.style": "Style",
  "border.editor.color": "C",
  "border.editor.top": "Top",
  "border.editor.left": "Left",
  "border.editor.right": "Right",
  "border.editor.bottom": "Bottom",
  "border.radius.editor.topLeft": "Top Left",
  "border.radius.editor.topRight": "Top Right",
  "border.radius.editor.bottomLeft": "Bottom Left",
  "border.radius.editor.bottomRight": "Bottom Right",
  "boxshadow.editor.blur": "Blur",
  "boxshadow.editor.spread": "Spread",
  "css.property.editor.properties": "Properties",
  "offset.path.list.editor.path": "Path",
  "offset.path.list.editor.totalLength": "Total Length",
  "offset.path.list.editor.distance": "Distance",
  "offset.path.list.editor.direction": "Direction",
  "offset.path.list.editor.rotate": "Rotate",
  "svgfilter.select.editor.message.create": "Create new svg filter",
  "svgfilter.select.editor.message.select": "Select a filter",
  "fill.editor.message.click.image": "Click the preview area if you want to select a image",
  "fill.editor.message.drag.position": "Drag if you want to move center position",
  "fill.editor.x1": "Start X",
  "fill.editor.x2": "End X",
  "fill.editor.y1": "Start Y",
  "fill.editor.y2": "End Y",
  "fill.editor.spread": "Spread",
  "fill.editor.offset": "Offset",
  "fill.editor.cx": "Center X",
  "fill.editor.cy": "Center Y",
  "fill.editor.r": "End radius",
  "fill.editor.fx": "Start X",
  "fill.editor.fy": "Start Y",
  "fill.editor.fr": "Start radius",
  "perspective.origin.editor.originX": "Origin X",
  "perspective.origin.editor.originY": "Origin Y",
  "path.manager.msg": "Keydown ESC or Enter key to close editing",
  "path.manager.mode.done": "Done",
  "path.manager.mode.modify": "Modify",
  "path.manager.mode.path": "Path",
  "path.manager.mode.warp": "Warp",
  "path.manager.mode.transform": "Transform",
  "path.manager.mode.reverse": "Reverse",
  "path.manager.mode.flipX": "Flip X",
  "path.manager.mode.flipY": "Flip Y",
  "path.manager.mode.flipOrigin": "Flip Origin",
  "colorpicker.popup.title": "ColorPicker",
  "selector.popup.title": "Selector Property",
  "selector.popup.selector": "Selector",
  "background.image.position.popup.title": "Background Pattern",
  "background.image.position.popup.size": "Size",
  "background.image.position.popup.width": "Width",
  "background.image.position.popup.height": "Height",
  "background.image.position.popup.repeat": "Repeat",
  "background.image.position.popup.blend": "Blend",
  "background.image.position.popup.type.repeat": "repeat",
  "background.image.position.popup.type.no-repeat": "no repeat",
  "background.image.position.popup.type.repeat-x": "repeat-x",
  "background.image.position.popup.type.repeat-y": "repeat-y",
  "background.image.position.popup.type.space": "space",
  "background.image.position.popup.type.round": "round",
  "gradient.picker.popup.title": "Gradient & Image Picker",
  "gradient.picker.popup.static-gradient": "Static",
  "gradient.picker.popup.linear-gradient": "Linear",
  "gradient.picker.popup.repeating-linear-gradient": "Repeating Linear",
  "gradient.picker.popup.radial-gradient": "Radial",
  "gradient.picker.popup.repeating-radial-gradient": "Repeating Radial",
  "gradient.picker.popup.conic-gradient": "Linear",
  "gradient.picker.popup.repeating-conic-gradient": "Repeating Conic",
  "image.asset.property.title": "Image",
  "video.asset.property.title": "Video",
  "color.asset.property.title": "Color",
  "gradient.asset.property.title": "Gradient",
  "pattern.asset.property.title": "Pattern",
  "svgfilter.asset.property.title": "SVG Filter",
  "inspector.tab.title.design": "Design",
  "inspector.tab.title.component": "Component",
  "inspector.tab.title.transition": "Animation",
  "inspector.tab.title.asset": "Assets",
  "inspector.tab.title.text": "Text",
  "inspector.tab.title.code": "Code",
  "inspector.tab.title.history": "History",
  "timeline.property.title": "Timeline",
  "timeline.property.resize": "Drag if you want to resize timeline height.",
  "timeline.animation.property.title": "Animations",
  "timeline.play.control.play": "Play",
  "timeline.play.control.pause": "Pause",
  "timeline.play.control.first": "First",
  "timeline.play.control.prev": "Previous",
  "timeline.play.control.next": "Next",
  "timeline.play.control.last": "Last",
  "timeline.play.control.direction": "Direction",
  "timeline.play.control.speed": "Speed",
  "timeline.play.control.repeat": "Repeat",
  "timeline.play.control.infinite": "Infinite",
  "timeline.play.control.normal": "normal",
  "timeline.play.control.alternate": "alternate",
  "timeline.play.control.reverse": "reverse",
  "timeline.play.control.alternate.reverse": "alternate reverse",
  "timeline.value.editor.value": "Value",
  "timeline.value.editor.time": "Time",
  "timeline.value.editor.timing": "Timing",
  "timeline.value.editor.offset.message": "Please input enter key to change time offset.",
  "svgfilter.popup.title": "SVG Filter",
  "css.item.rotate": "Rotate",
  "css.item.rotateX": "Rotate X",
  "css.item.rotateY": "Rotate Y",
  "css.item.rotateZ": "Rotate Z",
  "css.item.rotate3d": "3D Rotate",
  "css.item.skewX": "Skew X",
  "css.item.skewY": "Skew Y",
  "css.item.translate": "Translate",
  "css.item.translateX": "Translate X",
  "css.item.translateY": "Translate Y",
  "css.item.translateZ": "Translate Z",
  "css.item.translate3d": "3D Translate",
  "css.item.perspective": "Perspective",
  "css.item.scale": "Scale",
  "css.item.scaleX": "Scale X",
  "css.item.scaleY": "Scale Y",
  "css.item.scaleZ": "Scale Z",
  "css.item.scale3d": "3D Scale",
  "css.item.matrix": "Matrix",
  "css.item.matrix3d": "3D Matrix",
  "animation.property.title": "CSS Animation",
  "animation.property.direction": "Direction",
  "animation.property.play.state": "Play State",
  "animation.property.fill.mode": "Fill Mode",
  "animation.property.delay": "Delay",
  "animation.property.duration": "Duration",
  "animation.property.iteration.count": "Iteration Count",
  "animation.property.Select a keyframe": "Select a keyframe",
  "animation.property.popup.title": "Animation",
  "animation.property.popup.timing.function": "Timing Function",
  "animation.property.popup.keyframe": "Keyframe",
  "animation.property.popup.direction": "Direction",
  "animation.property.popup.play.state": "Play State",
  "animation.property.popup.fill.mode": "Fill Mode",
  "animation.property.popup.delay": "Delay",
  "animation.property.popup.duration": "Duration",
  "animation.property.popup.iteration": "Iteration",
  "animation.property.popup.normal": "normal",
  "animation.property.popup.reverse": "reverse",
  "animation.property.popup.alternate": "alternate",
  "animation.property.popup.alternate-reverse": "alternate-reverse",
  "animation.property.popup.none": "none",
  "animation.property.popup.forwards": "forwards",
  "animation.property.popup.backwards": "backwards",
  "animation.property.popup.both": "both",
  "animation.property.popup.Select a keyframe": "Select a keyframe",
  "keyframe.popup.title": "Keyframe",
  "code.view.property.title": "CodeView",
  "svg.filter.editor.tab.filter": "Filter",
  "svg.filter.editor.tab.preset": "Preset",
  "svg.filter.editor.tab.asset": "Assets",
  "svg.filter.editor.GRAPHIC REFERENCES": "GRAPHIC REFERENCES",
  "svg.filter.editor.SOURCES": "SOURCES",
  "svg.filter.editor.MODIFIER": "MODIFIER",
  "svg.filter.editor.LIGHTING": "LIGHTING",
  "svg.filter.editor.COMBINERS": "COMBINERS",
  "svg.filter.editor.Template": "Template",
  "layout.property.title": "Layout",
  "layout.property.flex": "Flex Box",
  "layout.property.grid": "Grid",
  "layout.property.default": "Default",
  "layout.property.resizing.title": "Resizing",
  "layout.property.resizing.self.title": "Self Resizing",
  "default.layout.item.property.title.constraints": "Constraints",
  "flex.layout.editor.row": "Row",
  "flex.layout.editor.column": "column",
  "flex.layout.editor.row-reverse": "Row Reverse",
  "flex.layout.editor.column-reverse": "Column Reverse",
  "flex.layout.editor.nowrap": "Nowrap",
  "flex.layout.editor.wrap": "Wrap",
  "flex.layout.editor.wrap-reverse": "Wrap Reverse",
  "flex.layout.editor.flex-start": "Start",
  "flex.layout.editor.flex-end": "End",
  "flex.layout.editor.center": "Center",
  "flex.layout.editor.space-between": "Between",
  "flex.layout.editor.space-around": "Around",
  "flex.layout.editor.baseline": "BaseLine",
  "flex.layout.editor.stretch": "Stretch",
  "flex.layout.editor.direction": "Direction",
  "flex.layout.editor.justify-content": "Justify Content",
  "flex.layout.editor.align-items": "Align Items",
  "flex.layout.editor.align-content": "Align Content",
  "flex.layout.item.property.title": "Flex Item Detail",
  "flex.layout.item.property.grow": "Flex Grow",
  "flex.layout.item.property.shrink": "Flex Shrink",
  "flex.layout.item.property.basis": "Flex Basis",
  "flex.layout.item.property.none": "none",
  "flex.layout.item.property.auto": "auto",
  "flex.layout.item.property.value": "value",
  "grid.layout.editor.template.columns": "Columns",
  "grid.layout.editor.column.gap": "Column Gap",
  "grid.layout.editor.template.rows": "Rows",
  "grid.layout.editor.row.gap": "Row Gap",
  "grid.box.editor.box.title": "Box",
  "grid.box.editor.type": "Type",
  "grid.box.editor.repeat": "Repeat",
  "grid.box.editor.length": "Length",
  "grid.box.editor.none": "None",
  "grid.box.editor.auto": "Auto",
  "grid.box.editor.count": "Count",
  "grid.box.editor.value": "Size",
  "grid.layout.item.property.title": "Layout Item Detail",
  "grid.layout.item.property.column": "Column",
  "grid.layout.item.property.row": "Row",
  "grid.layout.item.property.start": "Start",
  "grid.layout.item.property.end": "End",
  "grid.layout.item.property.none": "none",
  "grid.layout.item.property.value": "value",
  "box.model.property.title": "Box Model",
  "box.model.property.margin": "Margin",
  "box.model.property.padding": "Padding",
  "component.items.canvas": "Canvas",
  "component.items.layer": "Layer",
  "component.items.3dlayer": "3D Layer",
  "component.items.drawing": "Drawing",
  "component.items.custom": "Custom Component",
  "component.items.chart": "Chart",
  "component.items.plugin": "Plugin",
  "svg.text.property.title": "SVG Text Style",
  "svg.text.property.textarea": "Text Area",
  "svg.text.property.size": "Font Size",
  "svg.text.property.weight": "Font Weight",
  "svg.text.property.style": "Font Style",
  "svg.text.property.anchor": "Text Anchor",
  "svg.text.property.family": "Font Family",
  "svg.text.property.length.adjust": "Length Adjust",
  "svg.text.property.text.length": "Text Length",
  "svg.text.property.start.offset": "Start Offset",
  "fill.picker.popup.title": "SVG Fragment picker",
  "gradient.editor.drag.message": "Drag if you want to move center pointer.",
  "draw.manager.tolerance": "Tolerance",
  "pattern.property.title": "Pattern",
  "pattern.info.popup.title": "Pattern Info",
  "pattern.info.popup.width": "Width",
  "pattern.info.popup.height": "Height",
  "pattern.info.popup.lineWidth": "Line Width",
  "pattern.info.popup.lineHeight": "Line Height",
  "pattern.info.popup.rotate": "Rotate",
  "pattern.info.popup.blend": "Blend Mode",
  "pattern.info.popup.foreColor": "Fore",
  "pattern.info.popup.backColor": "Back",
  "stroke.dasharray.editor.add": "Add Dash",
  "viewport.panning.enable": "You can move the area by holding down space key and dragging the screen.",
  "image.select.editor.button": "Select Image"
};
var fr_FR = {
  "app.title": "elf",
  "app.sample": (a, b, c2) => {
    return `${a}-${b}-${c2}`;
  },
  "app.lang.en_US": "English",
  "app.lang.ko_KR": "\uD55C\uAD6D\uC5B4",
  "app.lang.fr_FR": "Fran\xE7ais",
  "app.label.lang": "Langue",
  "app.layout.all": "Layout",
  "app.layout.css": "CSS Mode",
  "app.layout.svg": "SVG Mode",
  "app.label.layout": "Menu Layout",
  "app.theme.dark": "Sombre",
  "app.theme.light": "Clair",
  "app.theme.gray": "Gris",
  "app.label.theme": "Th\xE8me",
  "app.tab.title.projects": "Projets",
  "app.tab.title.layers": "Objets",
  "app.tab.title.libraries": "Librarie",
  "app.tab.title.components": "Objet",
  "app.tab.title.artboards": "Artboard",
  "app.tab.title.assets": "Elements",
  "app.tab.title.keyMap": "Clavier",
  "app.confirm.message.artboard.items.removeArtboard": "Do you remove an artboard preview really?",
  "app.confirm.message.custom-component.items.removeCustomComponent": "Do you remove a custom component preview really?",
  "menu.item.download.title": "T\xE9l\xE9charger",
  "menu.item.save.title": "Enregistrer",
  "menu.item.export.title": "Exporter",
  "menu.item.codepen.title": "CodePen",
  "menu.item.fullscreen.title": "Ecran",
  "menu.item.shortcuts.title": "ShortCuts",
  "menu.item.github.title": "Github",
  "menu.item.learn.title": "Docs",
  "menu.item.projects.title": "Projects",
  "project.property.title": "Projet",
  "project.information.property.title": "Information",
  "project.information.property.name": "Nom",
  "project.information.property.description": "Description",
  "artboard.property.title": "Planche",
  "artboard.property.layout.title.flex": "Flex",
  "artboard.property.layout.title.grid": "Grille",
  "layer.tree.property.title": "Objets",
  "layer.tree.property.layout.title.flex": "Flex",
  "layer.tree.property.layout.title.grid": "Grille",
  "alignment.property.title": "Alignment",
  "position.property.title": "Position",
  "position.property.X": "X",
  "position.property.Y": "Y",
  "size.property.title": "Taille",
  "position.property.width": "Largeur",
  "position.property.height": "Hauteur",
  "position.property.opacity": "Opacity",
  "position.property.rotate": "Rotate",
  "background.color.property.title": "Apparance",
  "background.color.property.color": "Couleur",
  "background.color.property.zindex": "z-index",
  "background.color.property.opacity": "Opacit\xE9",
  "background.color.property.blend": "M\xE9lange",
  "background.color.property.overflow": "D\xE9bordement",
  "background.color.property.overflow.visible": "Visible",
  "background.color.property.overflow.hidden": "Cach\xE9",
  "background.color.property.overflow.scroll": "Scroll",
  "background.color.property.overflow.auto": "Auto",
  "blend.normal": "normal",
  "blend.multiply": "multiplie",
  "blend.screen": "\xE9cran",
  "blend.overlay": "couche",
  "blend.darken": "sombre",
  "blend.lighten": "clair",
  "blend.color-dodge": "dodge",
  "blend.color-burn": "brul\xE9",
  "blend.hard-light": "dur",
  "blend.soft-light": "doux",
  "blend.difference": 'diff"rence',
  "blend.exclusion": "exclusion",
  "blend.hue": "teinte",
  "blend.saturation": "saturation",
  "blend.color": "couleur",
  "blend.luminosity": "luminosit\xE9",
  "background.image.property.title": "Remplissage",
  "border.property.title": "Bordure",
  "border.radius.property.title": "Rayon de bordure",
  "boxshadow.property.title": "Ombres",
  "filter.property.title": "Filtre",
  "filter.property.blur": "Flou",
  "filter.property.grayscale": "Echelle de gris",
  "filter.property.hue-rotate": "Rotation teinte",
  "filter.property.invert": "Invertir",
  "filter.property.brightness": "Luminosit\xE9",
  "filter.property.contrast": "Contraste",
  "filter.property.drop-shadow": "Ombre port\xE9e",
  "filter.property.drop-shadow.color": "Couleur",
  "filter.property.drop-shadow.offsetX": "D\xE9calage X",
  "filter.property.drop-shadow.offsetY": "D\xE9calage Y",
  "filter.property.drop-shadow.blurRadius": "Flou",
  "filter.property.opacity": "Opacit\xE9",
  "filter.property.saturate": "Saturation",
  "filter.property.sepia": "S\xE9pia",
  "filter.property.svg": "SVG",
  "font.property.title": "Police",
  "font.property.color": "Couleur",
  "font.property.size": "Taille",
  "font.property.stretch": "Etirement",
  "font.property.weight": "Poids",
  "font.property.style": "Style",
  "font.property.family": "Famille",
  "font.spacing.property.title": "Espaces du texte",
  "font.spacing.property.lineHeight": "Hauteur de ligne",
  "font.spacing.property.letterSpacing": "Espace inter-caract\xE8res",
  "font.spacing.property.wordSpacing": "Espace inter-mots",
  "font.spacing.property.indent": "Identation",
  "backdrop.filter.property.title": "Filtre Backdrop",
  "clippath.property.title": "Chemin du Clip",
  "export.property.title": "Exporter",
  "export.property.download": "T\xE9l\xE9charger",
  "iframe.property.title": "IFrame",
  "image.property.title": "Image",
  "image.property.origin": "Origine",
  "image.property.size": "Taille",
  "image.property.width": "Largeur",
  "image.property.height": "Hauteur",
  "video.property.title": "Video",
  "video.property.play": "Jouer",
  "video.property.pause": "Pause",
  "video.property.volume": "Volume",
  "video.property.playbackRate": "Vitesse de lecture",
  "video.property.currentTime": "Temps actuel",
  "video.property.playTime": "Temps de lecture",
  "motion.property.title": "Mouvement",
  "text.property.title": "Style Texte",
  "text.property.align": "Alignement",
  "text.property.transform": "Transformation",
  "text.property.decoration": "D\xE9coration",
  "text.clip.property.title": "Clip Texte",
  "text.shadow.property.title": "Ombres Texte",
  "text.fill.property.title": "Remplissage Texte",
  "text.fill.property.fill": "Remplissage",
  "text.fill.property.stroke": "Trait",
  "text.fill.property.strokeWidth": "Largeur",
  "transform.property.title": "Transformation",
  "transform.origin.property.title": "Origine Transformation",
  "transition.property.title": "Transition CSS",
  "keyframe.property.title": "Image cl\xE9 CSS",
  "selector.property.title": "S\xE9l\xE9cteur",
  "selector.property.none": "Aucun s\xE9l\xE9cteur",
  "path.data.property.title": "Information Chemin",
  "polygon.data.property.title": "Information Polygone",
  "perspective.property.title": "Perspective",
  "perspective.origin.property.title": "Origine Perspective",
  "svg.item.property.title": "Appearance",
  "svg.item.property.isMotionPath": "Chemin de mouvement",
  "svg.item.property.fill": "Remplissage",
  "svg.item.property.fillOpacity": "Opacit\xE9",
  "svg.item.property.path": "Chemin",
  "svg.item.property.polygon": "Polygone",
  "svg.item.property.totalLength": "Longueur totale",
  "svg.item.property.fillRule": "R\xE8gle remplissage",
  "svg.item.property.stroke": "Trait",
  "svg.item.property.strokeWidth": "Largeur de trait",
  "svg.item.property.dashArray": "Suite tiret",
  "svg.item.property.dashOffset": "D\xE9calage tiret",
  "svg.item.property.lineCap": "Chapeau Ligne",
  "svg.item.property.lineJoin": "Jonction ligne",
  "svg.item.property.filter": "Filtre",
  "svg.item.property.blend": "Blend Mode",
  "border.editor.all": "Tout",
  "border.editor.width": "Largeur",
  "border.editor.style": "Style",
  "border.editor.color": "Couleur",
  "border.editor.top": "Haut",
  "border.editor.left": "Gauche",
  "border.editor.right": "Droite",
  "border.editor.bottom": "Bas",
  "border.radius.editor.topLeft": "Haut gauche",
  "border.radius.editor.topRight": "Haut droite",
  "border.radius.editor.bottomLeft": "Bas gauche",
  "border.radius.editor.bottomRight": "Bas droite",
  "boxshadow.editor.blur": "Flou",
  "boxshadow.editor.spread": "Etalement",
  "css.property.editor.properties": "Propri\xE9t\xE9s",
  "offset.path.list.editor.path": "Chemin",
  "offset.path.list.editor.totalLength": "Longueur totale",
  "offset.path.list.editor.distance": "Distance",
  "offset.path.list.editor.direction": "Direction",
  "offset.path.list.editor.rotate": "Rotation",
  "svgfilter.select.editor.message.create": "Cr\xE9er un filtre svg",
  "svgfilter.select.editor.message.select": "S\xE9lection filtre",
  "fill.editor.message.click.image": "Cliquez sur aper\xE7u si vous souhaitez s\xE9lectionner une image",
  "fill.editor.message.drag.position": "Prendre pour changer la position centrale",
  "fill.editor.x1": "D\xE9but X",
  "fill.editor.x2": "Fin X",
  "fill.editor.y1": "D\xE9but Y",
  "fill.editor.y2": "Fin Y",
  "fill.editor.spread": "Etalement",
  "fill.editor.offset": "D\xE9calage",
  "fill.editor.cx": "Centre X",
  "fill.editor.cy": "Centre Y",
  "fill.editor.r": "Rayon de fin",
  "fill.editor.fx": "D\xE9part X",
  "fill.editor.fy": "D\xE9part Y",
  "fill.editor.fr": "Rayon de d\xE9part",
  "perspective.origin.editor.originX": "Origine X",
  "perspective.origin.editor.originY": "Origine Y",
  "path.manager.msg": "Appuyer ESC ou Entr\xE9z keypour fermer Edition",
  "path.manager.mode.done": "Done",
  "path.manager.mode.modify": "Modifier",
  "path.manager.mode.path": "Chemin",
  "path.manager.mode.warp": "Warp",
  "path.manager.mode.transform": "Transformer",
  "path.manager.mode.reverse": "Reverse",
  "path.manager.mode.flipX": "Retouner X",
  "path.manager.mode.flipY": "Retouner Y",
  "path.manager.mode.flipOrigin": "Retouner Origine",
  "colorpicker.popup.title": "Pipette",
  "selector.popup.title": "Propi\xE9t\xE9 de S\xE9lecteur",
  "selector.popup.selector": "S\xE9lecteur",
  "background.image.position.popup.title": "Motif de fond",
  "background.image.position.popup.size": "Taille",
  "background.image.position.popup.width": "Largeur",
  "background.image.position.popup.height": "Hauteur",
  "background.image.position.popup.repeat": "Rep\xE8te",
  "background.image.position.popup.blend": "M\xE9lange",
  "background.image.position.popup.type.repeat": "rep\xE8te",
  "background.image.position.popup.type.no-repeat": "sans rep\xE9tition",
  "background.image.position.popup.type.repeat-x": "rep\xE8te-x",
  "background.image.position.popup.type.repeat-y": "rep\xE8te-y",
  "background.image.position.popup.type.space": "espace",
  "background.image.position.popup.type.round": "rond",
  "gradient.picker.popup.title": "S\xE9lection Gradient & Image",
  "image.asset.property.title": "Image",
  "video.asset.property.title": "Vid\xE9o",
  "color.asset.property.title": "Couleur",
  "gradient.asset.property.title": "Gradient",
  "pattern.asset.property.title": "Motif",
  "svgfilter.asset.property.title": "Filtre SVG",
  "inspector.tab.title.design": "Design",
  "inspector.tab.title.component": "Composant",
  "inspector.tab.title.transition": "Animation",
  "inspector.tab.title.asset": "El\xE9ments",
  "inspector.tab.title.text": "Texte",
  "inspector.tab.title.code": "Code",
  "inspector.tab.title.history": "History",
  "timeline.property.title": "Chronologie",
  "timeline.property.resize": "Drag if you want to resize timeline height.",
  "timeline.animation.property.title": "Animations",
  "timeline.play.control.play": "Jouer",
  "timeline.play.control.pause": "Pause",
  "timeline.play.control.first": "Premier",
  "timeline.play.control.prev": "Pr\xE9c\xE9dent",
  "timeline.play.control.next": "Suivant",
  "timeline.play.control.last": "Dernier",
  "timeline.play.control.direction": "Direction",
  "timeline.play.control.speed": "Vitesse",
  "timeline.play.control.repeat": "R\xE9p\xE9ter",
  "timeline.play.control.infinite": "Infini",
  "timeline.play.control.normal": "normal",
  "timeline.play.control.alternate": "alternatif",
  "timeline.play.control.reverse": "inverse",
  "timeline.play.control.alternate.reverse": "inverse alternatif",
  "timeline.value.editor.value": "Valeur",
  "timeline.value.editor.time": "Temps",
  "timeline.value.editor.timing": "Calage temps",
  "timeline.value.editor.offset.message": "Please input enter key to change time offset.",
  "svgfilter.popup.title": "Filtre SVG",
  "css.item.rotate": "Rotation",
  "css.item.rotateX": "Rotation X",
  "css.item.rotateY": "Rotation Y",
  "css.item.rotateZ": "Rotation Z",
  "css.item.rotate3d": "Rotation 3D",
  "css.item.skewX": "Oblique X",
  "css.item.skewY": "Oblique Y",
  "css.item.translate": "Translation",
  "css.item.translateX": "Translation X",
  "css.item.translateY": "Translation Y",
  "css.item.translateZ": "Translation Z",
  "css.item.translate3d": "Translation 3D",
  "css.item.perspective": "Persp\xE9ctive",
  "css.item.scale": "Echelle",
  "css.item.scaleX": "Echelle X",
  "css.item.scaleY": "Echelle Y",
  "css.item.scaleZ": "Echelle Z",
  "css.item.scale3d": "Echelle 3D",
  "css.item.matrix": "Matrice",
  "css.item.matrix3d": "Matrice 3D",
  "animation.property.title": "Animation CSS",
  "animation.property.direction": "Direction",
  "animation.property.play.state": "Etat lecture",
  "animation.property.fill.mode": "Mode remplissage",
  "animation.property.delay": "D\xE9lais",
  "animation.property.duration": "Dur\xE9e",
  "animation.property.iteration.count": "Nombre It\xE9rations",
  "animation.property.Select a keyframe": "Selectionner une image cl\xE9",
  "animation.property.popup.title": "Animation",
  "animation.property.popup.timing.function": "Fonction temps",
  "animation.property.popup.keyframe": "image cl\xE9",
  "animation.property.popup.direction": "Direction",
  "animation.property.popup.play.state": "Etat lecture",
  "animation.property.popup.fill.mode": "Mode remplissage",
  "animation.property.popup.delay": "D\xE9lais",
  "animation.property.popup.duration": "Dur\xE9\xE9",
  "animation.property.popup.iteration": "It\xE9ration",
  "animation.property.popup.normal": "normal",
  "animation.property.popup.reverse": "inverse",
  "animation.property.popup.alternate": "alternatif",
  "animation.property.popup.alternate-reverse": "inverse alternatif",
  "animation.property.popup.none": "Aucun",
  "animation.property.popup.forwards": "en avant",
  "animation.property.popup.backwards": "en arri\xE8re",
  "animation.property.popup.both": "les deux",
  "animation.property.popup.Select a keyframe": "Selectionner une image cl\xE9",
  "keyframe.popup.title": "image cl\xE9",
  "code.view.property.title": "Vue code",
  "svg.filter.editor.tab.filter": "Filtrer",
  "svg.filter.editor.tab.preset": "Pre-rempli",
  "svg.filter.editor.tab.asset": "El\xE9ments",
  "svg.filter.editor.GRAPHIC REFERENCES": "REFERENCES GRAPHIQUES",
  "svg.filter.editor.SOURCES": "SOURCES",
  "svg.filter.editor.MODIFIER": "MODIFIER",
  "svg.filter.editor.LIGHTING": "ECLAIRAGE",
  "svg.filter.editor.COMBINERS": "COMBINER",
  "svg.filter.editor.Template": "Mod\xE8le",
  "layout.property.title": "Disposition",
  "layout.property.flex": "Bo\xEEte Flex",
  "layout.property.grid": "Grille",
  "layout.property.default": "D\xE9faut",
  "layout.property.resizing.title": "Resizing",
  "layout.property.resizing.self.title": "Self Resizing",
  "default.layout.item.property.title.constraints": "Constraints",
  "flex.layout.editor.row": "Ligne",
  "flex.layout.editor.column": "Colonne",
  "flex.layout.editor.row-reverse": "Inverse ligne",
  "flex.layout.editor.column-reverse": "Inverse Colonne",
  "flex.layout.editor.nowrap": "Non-emball\xE9",
  "flex.layout.editor.wrap": "Emball\xE9 (wrap)",
  "flex.layout.editor.wrap-reverse": "Inverse emball\xE9",
  "flex.layout.editor.flex-start": "D\xE9but",
  "flex.layout.editor.flex-end": "Fin",
  "flex.layout.editor.center": "Centrer",
  "flex.layout.editor.space-between": "Entre",
  "flex.layout.editor.space-around": "Autour",
  "flex.layout.editor.baseline": "Base",
  "flex.layout.editor.stretch": "Etirement",
  "flex.layout.editor.direction": "Direction",
  "flex.layout.editor.justify-content": "Justifier",
  "flex.layout.editor.align-items": "Aligner objets",
  "flex.layout.editor.align-content": "Aligner contenu",
  "flex.layout.item.property.title": "D\xE9tail Disposition objet",
  "flex.layout.item.property.grow": "Augmenter Flex",
  "flex.layout.item.property.shrink": "R\xE9duire Flex",
  "flex.layout.item.property.basis": "Base Flex",
  "flex.layout.item.property.none": "Aucun",
  "flex.layout.item.property.auto": "auto",
  "flex.layout.item.property.value": "valeur",
  "grid.layout.editor.template.columns": "Colonne",
  "grid.layout.editor.column.gap": "Espace Colonne",
  "grid.layout.editor.template.rows": "Lignes",
  "grid.layout.editor.row.gap": "Espace lignes",
  "grid.box.editor.box.title": "Bo\xEEte",
  "grid.box.editor.type": "Type",
  "grid.box.editor.repeat": "R\xE9p\xE9ter",
  "grid.box.editor.length": "Longueur",
  "grid.box.editor.none": "Aucun",
  "grid.box.editor.auto": "Auto",
  "grid.box.editor.count": "Compte",
  "grid.box.editor.value": "Taille",
  "grid.layout.item.property.title": "D\xE9tail disposition objets",
  "grid.layout.item.property.column": "Colonne",
  "grid.layout.item.property.row": "Ligne",
  "grid.layout.item.property.start": "D\xE9but",
  "grid.layout.item.property.end": "Fin",
  "grid.layout.item.property.none": "Aucun",
  "grid.layout.item.property.value": "valeur",
  "box.model.property.title": "Mod\xE8le",
  "box.model.property.margin": "Marge",
  "box.model.property.padding": "Espace",
  "component.items.canvas": "Toile",
  "component.items.layer": "Objet",
  "component.items.3dlayer": "Objet 3D",
  "component.items.drawing": "Dessin",
  "component.items.custom": "Composant personnalis\xE9",
  "component.items.chart": "Chart",
  "component.items.plugin": "Plugin",
  "svg.text.property.title": "Style SVG Texte",
  "svg.text.property.textarea": "Zone Texte",
  "svg.text.property.size": "Taille",
  "svg.text.property.weight": "Poids",
  "svg.text.property.style": "Style",
  "svg.text.property.anchor": "Ancre Texte",
  "svg.text.property.family": "Famille",
  "svg.text.property.length.adjust": "Ajusteement longueur",
  "svg.text.property.text.length": "Ajusteement Texte",
  "svg.text.property.start.offset": "D\xE9callage d\xE9part",
  "fill.picker.popup.title": "S\xE9lection Fragment SVG",
  "gradient.editor.drag.message": "Glisser pour d\xE9placer centre.",
  "draw.manager.tolerance": "Tol\xE9rance",
  "pattern.property.title": "Motif",
  "pattern.info.popup.title": "Info Motif",
  "pattern.info.popup.width": "Largeur",
  "pattern.info.popup.height": "Hauteur",
  "pattern.info.popup.lineWidth": "Largeur ligne",
  "pattern.info.popup.lineHeight": "Hauteur de ligne",
  "pattern.info.popup.rotate": "Rotatation",
  "pattern.info.popup.blend": "M\xE9lange",
  "pattern.info.popup.foreColor": "Avant",
  "pattern.info.popup.backColor": "Arri\xE8re",
  "stroke.dasharray.editor.add": "Ajout tiret",
  "viewport.panning.enable": "You can move the area by holding down space and dragging the screen."
};
var ko_KR = {
  "app.title": "elf",
  "app.sample": (a, b, c2) => {
    return `${a}-${b}-${c2}`;
  },
  "app.lang.en_US": "English",
  "app.lang.ko_KR": "\uD55C\uAD6D\uC5B4",
  "app.lang.fr_FR": "Fran\xE7ais",
  "app.label.lang": "\uC5B8\uC5B4",
  "app.layout.all": "\uB808\uC774\uC544\uC6C3",
  "app.layout.css": "CSS \uBAA8\uB4DC",
  "app.layout.svg": "SVG \uBAA8\uB4DC",
  "app.label.layout": "\uBA54\uB274\uAD6C\uC131",
  "app.theme.dark": "\uC5B4\uB450\uC6B4",
  "app.theme.light": "\uBC1D\uC740",
  "app.theme.toon": "\uADF8\uB9AC\uAE30",
  "app.theme.gray": "\uD68C\uC0C9",
  "app.label.theme": "\uD14C\uB9C8",
  "app.tab.title.projects": "\uD504\uB85C\uC81D\uD2B8",
  "app.tab.title.layers": "\uB808\uC774\uC5B4",
  "app.tab.title.libraries": "\uB77C\uC774\uBE0C\uB7EC\uB9AC",
  "app.tab.title.components": "\uCEF4\uD3EC\uB10C\uD2B8",
  "app.tab.title.artboards": "\uC544\uD2B8\uBCF4\uB4DC",
  "app.tab.title.assets": "\uC5D0\uC14B",
  "app.tab.title.keyMap": "\uB2E8\uCD95\uD0A4",
  "app.confirm.message.artboard.items.removeArtboard": "\uC544\uD2B8\uBCF4\uB4DC \uD504\uB9AC\uBDF0\uB97C \uC0AD\uC81C \uD558\uC2DC\uACA0\uC2B5\uB2C8\uAE4C?",
  "app.confirm.message.custom-component.items.removeCustomComponent": "\uCEF4\uD3EC\uB10C\uD2B8 \uD504\uB9AC\uBDF0\uB97C \uC0AD\uC81C \uD558\uC2DC\uACA0\uC2B5\uB2C8\uAE4C?",
  "menu.item.download.title": "\uB2E4\uC6B4\uB85C\uB4DC",
  "menu.item.save.title": "\uC800\uC7A5",
  "menu.item.export.title": "\uB0B4\uBCF4\uB0B4\uAE30",
  "menu.item.fullscreen.title": "\uC804\uCCB4\uD654\uBA74",
  "menu.item.shortcuts.title": "\uB2E8\uCD95\uD0A4",
  "menu.item.github.title": "Github",
  "menu.item.learn.title": "\uBC30\uC6B0\uAE30",
  "menu.item.projects.title": "\uD504\uB85C\uC81D\uD2B8",
  "project.property.title": "\uD504\uB85C\uC81D\uD2B8",
  "project.information.property.title": "\uD504\uB85C\uC81D\uD2B8 \uC815\uBCF4",
  "project.information.property.name": "\uC774\uB984",
  "project.information.property.description": "\uC124\uBA85",
  "artboard.property.title": "\uC544\uD2B8\uBCF4\uB4DC",
  "artboard.property.layout.title.flex": "\uD50C\uB809\uC2A4",
  "artboard.property.layout.title.grid": "\uADF8\uB9AC\uB4DC",
  "layer.tree.property.title": "\uB808\uC774\uC5B4",
  "layer.tree.property.layout.title.flex": "\uD50C\uB809\uC2A4",
  "layer.tree.property.layout.title.grid": "\uADF8\uB9AC\uB4DC",
  "alignment.property.title": "\uC815\uB82C",
  "position.property.title": "\uC704\uCE58",
  "position.property.X": "X",
  "position.property.Y": "Y",
  "size.property.title": "\uD06C\uAE30",
  "position.property.width": "\uB113\uC774",
  "position.property.height": "\uB192\uC774",
  "position.property.rotate": "\uD68C\uC804",
  "position.property.opacity": "\uD22C\uBA85",
  "background.color.property.title": "\uD45C\uC2DC",
  "background.color.property.color": "\uBC30\uACBD\uC0C9",
  "background.color.property.zindex": "z-index",
  "background.color.property.blend": "\uBE14\uB80C\uB4DC\uBAA8\uB4DC",
  "background.color.property.overflow": "\uC624\uBC84\uD50C\uB85C\uC6B0",
  "background.color.property.overflow.visible": "\uBCF4\uC774\uAE30",
  "background.color.property.overflow.hidden": "\uC228\uAE30\uAE30",
  "background.color.property.overflow.scroll": "\uC2A4\uD06C\uB864",
  "background.color.property.overflow.auto": "\uC790\uB3D9",
  "blend.normal": "Normal(\uD45C\uC900) \uD63C\uD569\uBAA8\uB4DC",
  "blend.multiply": "Multiply(\uACF1\uD558\uAE30) \uBAA8\uB4DC",
  "blend.screen": "Screen(\uC2A4\uD06C\uB9B0) \uBAA8\uB4DC ",
  "blend.overlay": "Overlay(\uC624\uBC84\uB808\uC774) \uBAA8\uB4DC",
  "blend.darken": "Darken(\uC5B4\uB461\uAE30) \uBAA8\uB4DC",
  "blend.lighten": "Lighten(\uBC1D\uAE30) \uBAA8\uB4DC ",
  "blend.color-dodge": "Color Dodge(\uCEEC\uB7EC \uB2F7\uC9C0) \uBAA8\uB4DC ",
  "blend.color-burn": "Color Burn(\uCEEC\uB7EC \uBC88) \uBAA8\uB4DC ",
  "blend.hard-light": "Hard Light(\uD558\uB4DC \uB77C\uC774\uD2B8) \uBAA8\uB4DC ",
  "blend.soft-light": "Soft Light(\uC18C\uD504\uD2B8 \uB77C\uC774\uD2B8) \uBAA8\uB4DC ",
  "blend.difference": "Difference(\uCC28\uC774) \uBAA8\uB4DC",
  "blend.exclusion": "Exclusion(\uC81C\uC678) \uBAA8\uB4DC",
  "blend.hue": "Hue(\uC0C9\uC870) \uBAA8\uB4DC ",
  "blend.saturation": "Saturation(\uCC44\uB3C4) \uBAA8\uB4DC",
  "blend.color": "Color(\uC0C9\uC0C1) \uBAA8\uB4DC",
  "blend.luminosity": "Luminosity(\uAD11\uB3C4) \uBAA8\uB4DC ",
  "background.image.property.title": "\uCC44\uC6B0\uAE30",
  "border.property.title": "\uC678\uACFD\uC120",
  "border.radius.property.title": "\uB465\uADFC \uC678\uACFD\uC120",
  "boxshadow.property.title": "\uADF8\uB9BC\uC790",
  "filter.property.title": "\uD544\uD130",
  "filter.property.blur": "\uD750\uB9BC(Blur)",
  "filter.property.grayscale": "\uD68C\uC0C9(GrayScale)",
  "filter.property.hue-rotate": "\uC0C9\uC870(HueRotate)",
  "filter.property.invert": "\uBC18\uC804(Invert)",
  "filter.property.brightness": "\uBC1D\uAE30(Brightness)",
  "filter.property.contrast": "\uB300\b\uC870(Contrast)",
  "filter.property.drop-shadow": "\uADF8\uB9BC\uC790(Drop Shadow)",
  "filter.property.drop-shadow.color": "\uC0C9",
  "filter.property.drop-shadow.offsetX": "X",
  "filter.property.drop-shadow.offsetY": "Y",
  "filter.property.drop-shadow.blurRadius": "\uD750\uB9BC",
  "filter.property.opacity": "\uD22C\uBA85\uB3C4(Opacity)",
  "filter.property.saturate": "\uCC44\uB3C4(Saturate)",
  "filter.property.sepia": "\uAC08\uC0C9\uD1A4(Sepia)",
  "filter.property.svg": "SVG",
  "font.property.title": "\uD3F0\uD2B8",
  "font.property.color": "\uC0C9",
  "font.property.size": "\uD06C\uAE30",
  "font.property.stretch": "\uBED7\uAE30",
  "font.property.weight": "\uAD75\uAE30",
  "font.property.style": "\uC2A4\uD0C0\uC77C",
  "font.property.family": "\uAE00\uAF34",
  "font.spacing.property.title": "\uD3F0\uD2B8 \uACF5\uAC04",
  "font.spacing.property.lineHeight": "\uC904 \uB192\uC774",
  "font.spacing.property.letterSpacing": "\uAE00\uC790 \uAC04\uACA9",
  "font.spacing.property.wordSpacing": "\uB2E8\uC5B4 \uAC04\uACA9",
  "font.spacing.property.indent": "\uB4E4\uC5EC\uC4F0\uAE30",
  "backdrop.filter.property.title": "\uD6C4\uBA74 \uD544\uD130",
  "clippath.property.title": "\uD074\uB9BD\uD328\uC2A4",
  "export.property.title": "\uB0B4\uBCF4\uB0B4\uAE30",
  "export.property.download": "\uB2E4\uC6B4\uB85C\uB4DC",
  "iframe.property.title": "\uC544\uC774\uD504\uB808\uC784",
  "image.property.title": "\uC774\uBBF8\uC9C0",
  "image.property.origin": "\uC6D0\uBCF8",
  "image.property.size": "\uD06C\uAE30",
  "image.property.width": "\uB113\uC774",
  "image.property.height": "\uB192\uC774",
  "video.property.title": "\uBE44\uB514\uC624",
  "video.property.play": "\uC2DC\uC791",
  "video.property.pause": "\uBA48\uCDA4",
  "video.property.volume": "\uBCFC\uB968",
  "video.property.playbackRate": "\uBE60\uB974\uAE30",
  "video.property.currentTime": "\uD604\uC7AC \uC2DC\uAC04",
  "video.property.playTime": "\uD50C\uB808\uC774 \uC2DC\uAC04 \uAC04\uACA9",
  "motion.property.title": "\uBAA8\uC158",
  "path.data.property.title": "\uD328\uC2A4 \uC815\uBCF4",
  "polygon.data.property.title": "\uD3F4\uB9AC\uACE4 \uC815\uBCF4",
  "text.property.title": "\uD14D\uC2A4\uD2B8 \uC2A4\uD0C0\uC77C",
  "text.property.align": "\uC815\uB82C",
  "text.property.transform": "\uBCC0\uD615",
  "text.property.decoration": "\uC7A5\uC2DD",
  "text.clip.property.title": "\uD14D\uC2A4\uD2B8 \uD074\uB9BD",
  "text.shadow.property.title": "\uD14D\uC2A4\uD2B8 \uADF8\uB9BC\uC790",
  "text.fill.property.title": "\uD14D\uC2A4\uD2B8 \uCC44\uC6B0\uAE30",
  "text.fill.property.fill": "\uCC44\uC6B0\uAE30",
  "text.fill.property.stroke": "\uC724\uACFD\uC120",
  "text.fill.property.strokeWidth": "\uC724\uACFD\uC120 \uAD75\uAE30",
  "transform.property.title": "\uD2B8\uB79C\uC2A4\uD3FC",
  "transform.origin.property.title": "\uD2B8\uB79C\uC2A4\uD3FC Origin",
  "transition.property.title": "CSS \uD2B8\uB79C\uC9C0\uC158",
  "keyframe.property.title": "CSS \uD0A4\uD504\uB808\uC784",
  "selector.property.title": "CSS \uC140\uB809\uD130",
  "selector.property.none": "\uC120\uD0DD\uC790 \uC5C6\uC74C",
  "perspective.property.title": "\uD22C\uC601(perspective)",
  "perspective.origin.property.title": "\uD22C\uC601 \uC911\uC2EC\uC810",
  "svg.item.property.title": "\uBCF4\uC774\uAE30",
  "svg.item.property.isMotionPath": "\uBAA8\uC158 \uD328\uC2A4",
  "svg.item.property.fill": "\uCC44\uC6B0\uAE30",
  "svg.item.property.fillOpacity": "\uD22C\uBA85\uB3C4",
  "svg.item.property.path": "\uD328\uC2A4",
  "svg.item.property.polygon": "\uD3F4\uB9AC\uACE4",
  "svg.item.property.totalLength": "\uC804\uCCB4 \uAE38\uC774",
  "svg.item.property.fillRule": "\uCC44\uC6B0\uAE30 \uADDC\uCE59",
  "svg.item.property.stroke": "\uC120",
  "svg.item.property.strokeWidth": "\uC120 \uAD75\uAE30",
  "svg.item.property.dashArray": "\uC810\uC120 \uAE38\uC774",
  "svg.item.property.dashOffset": "\uC810\uC120 \uC704\uCE58",
  "svg.item.property.lineCap": "\uC120 \uBAA8\uC591",
  "svg.item.property.lineJoin": "\uACB9\uCE5C \uC120",
  "svg.item.property.filter": "\uD544\uD130",
  "svg.item.property.blend": "\uBE14\uB80C\uB4DC",
  "border.editor.all": "\uC804\uCCB4",
  "border.editor.width": "\uD06C\uAE30",
  "border.editor.style": "\uC2A4\uD0C0\uC77C",
  "border.editor.color": "\uC0C9",
  "border.editor.top": "\uC704",
  "border.editor.left": "\uC67C\uCABD",
  "border.editor.right": "\uC624\uB978\uCABD",
  "border.editor.bottom": "\uC544\uB798",
  "border.radius.editor.topLeft": "\uC67C\uCABD \uC704",
  "border.radius.editor.topRight": "\uC624\uB978\uCABD \uC704",
  "border.radius.editor.bottomLeft": "\uC67C\uCABD \uC544\uB798",
  "border.radius.editor.bottomRight": "\uC624\uB978\uCABD \uC544\uB798",
  "boxshadow.editor.blur": "\uD750\uB9BC",
  "boxshadow.editor.spread": "\uAE38\uC774",
  "css.property.editor.properties": "\uC18D\uC131",
  "offset.path.list.editor.path": "\uD328\uC2A4",
  "offset.path.list.editor.totalLength": "\uC804\uCCB4 \uAE38\uC774",
  "offset.path.list.editor.distance": "\uAC70\uB9AC",
  "offset.path.list.editor.direction": "\uBC29\uD5A5",
  "offset.path.list.editor.rotate": "\uD68C\uC804",
  "svgfilter.select.editor.message.create": "\uC0C8\uB85C\uC6B4 SVG Filter \uB97C \uB9CC\uB4DC\uC138\uC694.",
  "svgfilter.select.editor.message.select": "\uD544\uD130\uB97C \uC120\uD0DD\uD558\uC138\uC694.",
  "fill.editor.message.click.image": "\uC774\uBBF8\uC9C0\uB97C \uC120\uD0DD\uD558\uACE0 \uC2F6\uC73C\uBA74 \uD504\uB9AC\uBDF0 \uC601\uC5ED\uC744 \uD074\uB9AD\uD558\uC138\uC694.",
  "fill.editor.message.drag.position": "\uAC00\uC6B4\uB370 \uC704\uCE58\uB97C \uB4DC\uB798\uADF8 \uD574\uBCF4\uC138\uC694.",
  "fill.editor.x1": "\uC2DC\uC791 X",
  "fill.editor.x2": "\uB05D X",
  "fill.editor.y1": "\uC2DC\uC791 Y",
  "fill.editor.y2": "\uB05D Y",
  "fill.editor.spread": "\uD655\uC0B0",
  "fill.editor.offset": "\uC704\uCE58",
  "fill.editor.cx": "\uC911\uC2EC\uC810 X",
  "fill.editor.cy": "\uC911\uC2EC\uC810 Y",
  "fill.editor.r": "\uB05D \uBC18\uC9C0\uB984",
  "fill.editor.fx": "\uC2DC\uC791 X",
  "fill.editor.fy": "\uC2DC\uC791 Y",
  "fill.editor.fr": "\uC2DC\uC791 \uBC18\uC9C0\uB984",
  "perspective.origin.editor.originX": "\uC911\uC2EC\uC810 X",
  "perspective.origin.editor.originY": "\uC911\uC2EC\uC810 Y",
  "path.manager.msg": "\uD3B8\uC9D1\uC744 \uC885\uB8CC\uD560 \uB54C\uB294 ESC \uD0A4\uB098 Enter \uD0A4\uB97C \uB204\uB974\uC138\uC694. \uB610\uB294 \uD654\uBA74\uC744 \uD074\uB9AD\uD558\uC2DC\uBA74 \uB429\uB2C8\uB2E4.",
  "path.manager.mode.done": "\uC644\uB8CC",
  "path.manager.mode.modify": "\uC810 \uD3B8\uC9D1",
  "path.manager.mode.path": "\uC810 \uCD94\uAC00",
  "path.manager.mode.warp": "\uC6CC\uD504",
  "path.manager.mode.transform": "\uBCC0\uD615",
  "path.manager.mode.reverse": "\uC21C\uC11C\uBCC0\uACBD",
  "path.manager.mode.flipX": "X\uCD95 \uD68C\uC804",
  "path.manager.mode.flipY": "Y\uCD95 \uD68C\uC804",
  "path.manager.mode.flipOrigin": "\uC804\uCCB4 \uD68C\uC804",
  "colorpicker.popup.title": "\uC0C9\uC0C1 \uC120\uD0DD",
  "selector.popup.title": "\uC120\uD0DD\uC790 \uC18D\uC131",
  "selector.popup.selector": "\uC120\uD0DD\uC790",
  "background.image.position.popup.title": "\uBC30\uACBD \uD328\uD134",
  "background.image.position.popup.size": "\uD06C\uAE30",
  "background.image.position.popup.width": "\uB113\uC774",
  "background.image.position.popup.height": "\uB192\uC774",
  "background.image.position.popup.repeat": "\uBC18\uBCF5",
  "background.image.position.popup.blend": "\uBE14\uB80C\uB4DC",
  "background.image.position.popup.type.repeat": "\uBC18\uBCF5",
  "background.image.position.popup.type.no-repeat": "\uBC18\uBCF5 \uC548\uD568",
  "background.image.position.popup.type.repeat-x": "x\uCD95 \uBC18\uBCF5",
  "background.image.position.popup.type.repeat-y": "y\uCD95 \uBC18\uBCF5",
  "background.image.position.popup.type.space": "\uACF5\uBC31\uC720\uC9C0",
  "background.image.position.popup.type.round": "\uBC18\uC62C\uB9BC",
  "gradient.picker.popup.title": "\uADF8\uB77C\uB514\uC5B8\uD2B8\uC640 \uC774\uBBF8\uC9C0",
  "image.asset.property.title": "\uC774\uBBF8\uC9C0",
  "video.asset.property.title": "\uBE44\uB514\uC624",
  "color.asset.property.title": "\uC0C9",
  "gradient.asset.property.title": "\uADF8\uB77C\uB514\uC5B8\uD2B8",
  "pattern.asset.property.title": "\uD328\uD134",
  "svgfilter.asset.property.title": "SVG \uD544\uD130",
  "inspector.tab.title.design": "\uB514\uC790\uC778",
  "inspector.tab.title.component": "\uCEF4\uD3EC\uB10C\uD2B8 \uC18D\uC131",
  "inspector.tab.title.transition": "\uC560\uB2C8\uBA54\uC774\uC158",
  "inspector.tab.title.asset": "\uC5D0\uC14B \uAD00\uB9AC\uC790",
  "inspector.tab.title.text": "\uD14D\uC2A4\uD2B8",
  "inspector.tab.title.code": "\uCF54\uB4DC",
  "inspector.tab.title.history": "\uAE30\uB85D",
  "timeline.property.title": "\uD0C0\uC784\uB77C\uC778",
  "timeline.property.resize": "\uD0C0\uC784\uB77C\uC778 \uB192\uC774\uB97C \uBCC0\uACBD\uD569\uB2C8\uB2E4. \uB4DC\uB798\uADF8 \uD574\uC8FC\uC138\uC694.",
  "timeline.animation.property.title": "\uC560\uB2C8\uBA54\uC774\uC158",
  "timeline.play.control.play": "\uD50C\uB808\uC774",
  "timeline.play.control.pause": "\uBA48\uCDA4",
  "timeline.play.control.first": "\uCC98\uC74C\uC73C\uB85C",
  "timeline.play.control.prev": "\uC774\uC804\uC73C\uB85C",
  "timeline.play.control.next": "\uB2E4\uC74C\uC73C\uB85C",
  "timeline.play.control.last": "\uB9C8\uC9C0\uB9C9\uC73C\uB85C",
  "timeline.play.control.direction": "\uBC29\uD5A5",
  "timeline.play.control.speed": "\uC18D\uB825",
  "timeline.play.control.repeat": "\uBC18\uBCF5",
  "timeline.play.control.infinite": "\uBB34\uD55C",
  "timeline.play.control.normal": "normal",
  "timeline.play.control.alternate": "alternate",
  "timeline.play.control.reverse": "reverse",
  "timeline.play.control.alternate.reverse": "alternate reverse",
  "timeline.value.editor.value": "\uAC12",
  "timeline.value.editor.time": "\uC2DC\uAC04",
  "timeline.value.editor.timing": "\uD0C0\uC774\uBC0D \uD568\uC218",
  "timeline.value.editor.offset.message": "Enter\uD0A4\uB97C \uC785\uB825\uD558\uBA74 \uC801\uC6A9\uB429\uB2C8\uB2E4.",
  "svgfilter.popup.title": "SVG \uD544\uD130",
  "css.item.rotate": "\uD68C\uC804",
  "css.item.rotateX": "X\uCD95 \uD68C\uC804",
  "css.item.rotateY": "Y\uCD95 \uD68C\uC804",
  "css.item.rotateZ": "Z\uCD95 \uD68C\uC804",
  "css.item.rotate3d": "3D \uD68C\uC804",
  "css.item.skewX": "X\uCD95 \uB298\uC774\uAE30",
  "css.item.skewY": "Y\uCD95 \uB298\uC774\uAE30",
  "css.item.translate": "\uC774\uB3D9",
  "css.item.translateX": "X\uCD95 \uC774\uB3D9",
  "css.item.translateY": "Y\uCD95 \uC774\uB3D9",
  "css.item.translateZ": "Z\uCD95 \uC774\uB3D9",
  "css.item.translate3d": "3D \uC774\uB3D9",
  "css.item.perspective": "\uC6D0\uADFC",
  "css.item.scale": "\uD06C\uAE30\uBCC0\uACBD",
  "css.item.scaleX": "X\uCD95 \uD06C\uAE30\uBCC0\uACBD",
  "css.item.scaleY": "Y\uCD95 \uD06C\uAE30\uBCC0\uACBD",
  "css.item.scaleZ": "Z\uCD95 \uD06C\uAE30\uBCC0\uACBD",
  "css.item.scale3d": "3D \uD06C\uAE30\uBCC0\uACBD",
  "css.item.matrix": "\uBCC0\uD658 \uD589\uB82C",
  "css.item.matrix3d": "3D \uBCC0\uD658 \uD589\uB82C",
  "animation.property.title": "CSS \uC560\uB2C8\uBA54\uC774\uC158",
  "animation.property.direction": "\uBC29\uD5A5",
  "animation.property.play.state": "\uD50C\uB808\uC774 \uC0C1\uD0DC",
  "animation.property.fill.mode": "\uCC44\uC6B0\uAE30 \uBAA8\uB4DC",
  "animation.property.delay": "\uB300\uAE30\uC2DC\uAC04",
  "animation.property.duration": "\uC2DC\uAC04",
  "animation.property.iteration.count": "\uBC18\uBCF5 \uD69F\uC218",
  "animation.property.select a keyframe": "\uD0A4\uD504\uB808\uC784\uC744 \uC120\uD0DD\uD574\uC8FC\uC138\uC694",
  "animation.property.popup.title": "CSS \uC560\uB2C8\uBA54\uC774\uC158",
  "animation.property.popup.timing.function": "\uD0C0\uC774\uBC0D \uD568\uC218",
  "animation.property.popup.keyframe": "\uD0A4\uD504\uB808\uC784",
  "animation.property.popup.direction": "\uBC29\uD5A5",
  "animation.property.popup.play.state": "\uD50C\uB808\uC774 \uC0C1\uD0DC",
  "animation.property.popup.fill.mode": "\uCC44\uC6B0\uAE30 \uBAA8\uB4DC",
  "animation.property.popup.delay": "\uB300\uAE30\uC2DC\uAC04",
  "animation.property.popup.duration": "\uC2DC\uAC04",
  "animation.property.popup.iteration": "\uBC18\uBCF5 \uD69F\uC218",
  "animation.property.popup.normal": "\uC2DC\uAC04\uC21C",
  "animation.property.popup.reverse": "\uC5ED\uC2DC\uAC04\uC21C",
  "animation.property.popup.alternate": "\uC655\uBCF5 \uC2DC\uAC04\uC21C",
  "animation.property.popup.alternate-reverse": "\uC655\uBCF5 \uC5ED\uC2DC\uAC04\uC21C",
  "animation.property.popup.none": "none",
  "animation.property.popup.forwards": "forwards",
  "animation.property.popup.backwards": "backwards",
  "animation.property.popup.both": "both",
  "animation.property.popup.Select a keyframe": "\uD0A4\uD504\uB808\uC784\uC744 \uC120\uD0DD\uD574\uC8FC\uC138\uC694.",
  "keyframe.popup.title": "\uD0A4\uD504\uB808\uC784",
  "code.view.property.title": "\uCF54\uB4DC\uBDF0",
  "svg.filter.editor.tab.filter": "\uD544\uD130",
  "svg.filter.editor.tab.preset": "\uD504\uB9AC\uC14B",
  "svg.filter.editor.tab.asset": "\uC5D0\uC14B",
  "svg.filter.editor.GRAPHIC REFERENCES": "\uCC38\uC870 \uADF8\uB798\uD53D",
  "svg.filter.editor.SOURCES": "\uC6D0\uBCF8",
  "svg.filter.editor.MODIFIER": "\uC218\uC815",
  "svg.filter.editor.LIGHTING": "\uBE5B",
  "svg.filter.editor.COMBINERS": "\uACB0\uD569",
  "svg.filter.editor.Template": "\uD15C\uD50C\uB9BF",
  "layout.property.title": "\uB808\uC774\uC544\uC6C3",
  "layout.property.flex": "\uD50C\uB809\uC2A4 \uBC15\uC2A4",
  "layout.property.grid": "\uADF8\uB9AC\uB4DC",
  "layout.property.default": "\uAE30\uBCF8 \uC88C\uD45C",
  "layout.property.resizing.title": "\uC0AC\uC774\uC988 \uC870\uC808",
  "layout.property.resizing.self.title": "\uC544\uC774\uD15C \uC0AC\uC774\uC988 \uC870\uC808",
  "default.layout.item.property.title.constraints": "Constraints",
  "flex.layout.editor.row": "\uD589",
  "flex.layout.editor.column": "\uC5F4",
  "flex.layout.editor.row-reverse": "\uC5ED\uBC29\uD5A5 \uD589",
  "flex.layout.editor.column-reverse": "\uC5ED\uBC29\uD5A5 \uC5F4",
  "flex.layout.editor.nowrap": "\uAC10\uC2F8\uC9C0 \uC54A\uAE30",
  "flex.layout.editor.wrap": "\uAC10\uC2F8\uAE30",
  "flex.layout.editor.wrap-reverse": "\uC5ED\uBC29\uD5A5 \uAC10\uC2F8\uAE30",
  "flex.layout.editor.flex-start": "\uC2DC\uC791",
  "flex.layout.editor.flex-end": "\uB05D",
  "flex.layout.editor.center": "\uC911\uAC04",
  "flex.layout.editor.space-between": "\uACF5\uAC04 \uC911\uAC04 \uCC44\uC6C0",
  "flex.layout.editor.space-around": "\uACF5\uAC04 \uC591\uB05D \uCC44\uC6C0",
  "flex.layout.editor.baseline": "\uAE30\uBCF8\uC120",
  "flex.layout.editor.stretch": "\uD3BC\uCE58\uAE30",
  "flex.layout.editor.direction": "\uBC29\uD5A5",
  "flex.layout.editor.justify-content": "\uCEE8\uD150\uCE20 \uC870\uC815",
  "flex.layout.editor.align-items": "\uC544\uC774\uD15C \uC815\uB82C",
  "flex.layout.editor.align-content": "\uCEE8\uD150\uCE20 \uC815\uB82C",
  "flex.layout.item.property.title": "\uD50C\uB809\uC2A4 \uC544\uC774\uD15C \uC124\uC815",
  "flex.layout.item.property.grow": "\uACF5\uAC04 \uBE44\uC728",
  "flex.layout.item.property.shrink": "\uCD95\uC18C \uBE44\uC728",
  "flex.layout.item.property.basis": "\uCD08\uAE30 \uD06C\uAE30",
  "flex.layout.item.property.none": "\uC5C6\uC74C",
  "flex.layout.item.property.auto": "\uC790\uB3D9",
  "flex.layout.item.property.value": "\uAC12",
  "grid.layout.editor.template.columns": "\uC5F4",
  "grid.layout.editor.column.gap": "\uC5F4 \uAC04\uACA9",
  "grid.layout.editor.template.rows": "\uD589",
  "grid.layout.editor.row.gap": "\uD589 \uAC04\uACA9",
  "grid.box.editor.box.title": "\uC601\uC5ED",
  "grid.box.editor.type": "\uD0C0\uC785",
  "grid.box.editor.repeat": "\uBC18\uBCF5",
  "grid.box.editor.length": "\uAE38\uC774",
  "grid.box.editor.none": "\uC5C6\uC74C",
  "grid.box.editor.auto": "\uC790\uB3D9",
  "grid.box.editor.count": "\uAC1C\uC218",
  "grid.box.editor.value": "\uD06C\uAE30",
  "grid.layout.item.property.title": "\uADF8\uB9AC\uB4DC \uC544\uC774\uD15C \uC124\uC815",
  "grid.layout.item.property.column": "\uC5F4",
  "grid.layout.item.property.row": "\uD589",
  "grid.layout.item.property.start": "\uC2DC\uC791",
  "grid.layout.item.property.End": "\uB05D",
  "grid.layout.item.property.none": "\uC5C6\uC74C",
  "grid.layout.item.property.value": "\uAC12",
  "box.model.property.title": "\uBC15\uC2A4 \uBAA8\uB378",
  "box.model.property.margin": "\uB9C8\uC9C4",
  "box.model.property.padding": "\uD328\uB529",
  "component.items.canvas": "\uCE94\uBC84\uC2A4",
  "component.items.layer": "\uB808\uC774\uC5B4",
  "component.items.3dlayer": "3D \uB808\uC774\uC5B4",
  "component.items.drawing": "\uADF8\uB9AC\uAE30",
  "component.items.custom": "\uC0AC\uC6A9\uC790 \uC815\uC758 \uCEF4\uD3EC\uB10C\uD2B8",
  "component.items.chart": "\uCC28\uD2B8",
  "component.items.plugin": "\uD50C\uB7EC\uADF8\uC778",
  "svg.text.property.title": "SVG Text \uC2A4\uD0C0\uC77C",
  "svg.text.property.textarea": "\uD14D\uC2A4\uD2B8 \uC785\uB825",
  "svg.text.property.size": "\uD3F0\uD2B8 \uD06C\uAE30",
  "svg.text.property.weight": "\uD3F0\uD2B8 \uAD75\uAE30",
  "svg.text.property.style": "\uD3F0\uD2B8 \uC2A4\uD0C0\uC77C",
  "svg.text.property.anchor": "\uD14D\uC2A4\uD2B8 \uC704\uCE58",
  "svg.text.property.family": "\uD3F0\uD2B8 \uAE00\uAF34",
  "svg.text.property.length.adjust": "\uAE38\uC774 \uB300\uC751",
  "svg.text.property.text.length": "\uD14D\uC2A4\uD2B8 \uAE38\uC774",
  "svg.text.property.start.offset": "\uC2DC\uC791 \uC9C0\uC810",
  "fill.picker.popup.title": "\uC0C9 \uCC44\uC6B0\uAE30",
  "gradient.editor.drag.message": "\uB4DC\uB798\uADF8 \uD558\uBA74 \uC911\uC2EC\uC810\uC744 \uC62E\uAE38 \uC218 \uC788\uC2B5\uB2C8\uB2E4.",
  "draw.manager.tolerance": "\uD3EC\uC778\uD2B8 \uD5C8\uC6A9 \uC624\uCC28",
  "pattern.property.title": "\uD328\uD134",
  "pattern.info.popup.title": "\uD328\uD134 \uC815\uBCF4",
  "pattern.info.popup.width": "\uB113\uC774",
  "pattern.info.popup.height": "\uB192\uC774",
  "pattern.info.popup.lineWidth": "\uC120 \uB113\uC774",
  "pattern.info.popup.lineHeight": "\uC120 \uB192\uC774",
  "pattern.info.popup.rotate": "\uD68C\uC804",
  "pattern.info.popup.blend": "\uBE14\uB80C\uB4DC",
  "pattern.info.popup.foreColor": "\uD328\uD134\uC0C9",
  "pattern.info.popup.backColor": "\uBC30\uACBD\uC0C9",
  "stroke.dasharray.editor.add": "\uC810 \uCD94\uAC00",
  "viewport.panning.enable": "space \uB97C \uB204\uB978\uCC44 \uD654\uBA74\uC744 \uB4DC\uB798\uADF8 \uD558\uBA74 \uC601\uC5ED\uC744 \uC6C0\uC9C1\uC77C \uC218 \uC788\uC2B5\uB2C8\uB2E4."
};
var locales = {
  en_US,
  fr_FR,
  ko_KR
};
function defaultMessages(editor) {
  Object.keys(locales).forEach(function(locale) {
    editor.registerI18nMessage(locale, locales[locale]);
  });
}
var SelectEditor$1 = "";
const ConstraintsDirection = {
  HORIZONTAL: "constraints-horizontal",
  VERTICAL: "constraints-vertical"
};
const Constraints = {
  NONE: "none",
  MIN: "min",
  MAX: "max",
  STRETCH: "stretch",
  SCALE: "scale",
  CENTER: "center"
};
const BooleanOperation = {
  DIFFERENCE: "difference",
  INTERSECTION: "intersection",
  UNION: "union",
  REVERSE_DIFFERENCE: "reverse-difference",
  XOR: "xor"
};
const StrokeLineCap = {
  BUTT: "butt",
  ROUND: "round",
  SQUARE: "square"
};
const StrokeLineJoin = {
  MITER: "miter",
  ROUND: "round",
  BEVEL: "bevel"
};
const BlendMode = {
  NORMAL: "normal",
  MULTIPLY: "multiply",
  SCREEN: "screen",
  OVERLAY: "overlay",
  DARKEN: "darken",
  LIGHTEN: "lighten",
  COLOR_DODGE: "color-dodge",
  COLOR_BURN: "color-burn",
  HARD_LIGHT: "hard-light",
  SOFT_LIGHT: "soft-light",
  DIFFERENCE: "difference",
  EXCLUSION: "exclusion",
  HUE: "hue",
  SATURATION: "saturation",
  COLOR: "color",
  LUMINOSITY: "luminosity"
};
const TextDecoration = {
  NONE: "none",
  UNDERLINE: "underline",
  OVERLINE: "overline",
  LINE_THROUGH: "line-through",
  BLINK: "blink"
};
const TextTransform = {
  NONE: "none",
  CAPITALIZE: "capitalize",
  UPPERCASE: "uppercase",
  LOWERCASE: "lowercase"
};
const TextAlign = {
  START: "start",
  END: "end",
  LEFT: "left",
  RIGHT: "right",
  CENTER: "center",
  JUSTIFY: "justify"
};
const Overflow = {
  VISIBLE: "visible",
  HIDDEN: "hidden",
  SCROLL: "scroll",
  AUTO: "auto"
};
const BorderStyle = {
  NONE: "none",
  HIDDEN: "hidden",
  DOTTED: "dotted",
  DASHED: "dashed",
  SOLID: "solid",
  DOUBLE: "double",
  GROOVE: "groove",
  RIDGE: "ridge",
  INSET: "inset",
  OUTSET: "outset"
};
const TransformValue = {
  NONE: "none",
  PERSPECTIVE: "perspective",
  TRANSLATE: "translate",
  TRANSLATE_X: "translateX",
  TRANSLATE_Y: "translateY",
  TRANSLATE_Z: "translateZ",
  TRANSLATE_3D: "translate3d",
  SCALE: "scale",
  SCALE_X: "scaleX",
  SCALE_Y: "scaleY",
  SCALE_Z: "scaleZ",
  SCALE_3D: "scale3d",
  ROTATE: "rotate",
  ROTATE_X: "rotateX",
  ROTATE_Y: "rotateY",
  ROTATE_Z: "rotateZ",
  SKEW: "skew",
  SKEW_X: "skewX",
  SKEW_Y: "skewY",
  MATRIX: "matrix",
  MATRIX_3D: "matrix3d"
};
const Layout = {
  DEFAULT: "default",
  FLEX: "flex",
  GRID: "grid"
};
const FlexDirection = {
  ROW: "row",
  ROW_REVERSE: "row-reverse",
  COLUMN: "column",
  COLUMN_REVERSE: "column-reverse"
};
const JustifyContent = {
  FLEX_START: "flex-start",
  FLEX_END: "flex-end",
  CENTER: "center",
  SPACE_BETWEEN: "space-between",
  SPACE_AROUND: "space-around",
  SPACE_EVENLY: "space-evenly"
};
const AlignItems = {
  FLEX_START: "flex-start",
  FLEX_END: "flex-end",
  CENTER: "center",
  BASELINE: "baseline",
  STRETCH: "stretch"
};
const AlignContent = {
  FLEX_START: "flex-start",
  FLEX_END: "flex-end",
  CENTER: "center",
  SPACE_BETWEEN: "space-between",
  SPACE_AROUND: "space-around",
  SPACE_EVENLY: "space-evenly"
};
const FlexWrap = {
  NOWRAP: "nowrap",
  WRAP: "wrap",
  WRAP_REVERSE: "wrap-reverse"
};
const ResizingMode = {
  FIXED: "fixed",
  HUG_CONTENT: "hug-content",
  FILL_CONTAINER: "fill-container"
};
const TextClip = {
  NONE: "none",
  TEXT: "text"
};
const BoxShadowStyle = {
  OUTSET: "outset",
  INSET: "inset"
};
const GradientType = {
  STATIC: "static-gradient",
  LINEAR: "linear-gradient",
  RADIAL: "radial-gradient",
  CONIC: "conic-gradient",
  REPEATING_LINEAR: "repeating-linear-gradient",
  REPEATING_RADIAL: "repeating-radial-gradient",
  REPEATING_CONIC: "repeating-conic-gradient",
  IMAGE: "image",
  URL: "url"
};
const RadialGradientSizeType = {
  CLOSEST_SIDE: "closest-side",
  CLOSEST_CORNER: "closest-corner",
  FARTHEST_SIDE: "farthest-side",
  FARTHEST_CORNER: "farthest-corner"
};
const RadialGradientType = {
  CIRCLE: "circle",
  ELLIPSE: "ellipse"
};
const ClipPathType = {
  NONE: "none",
  CIRCLE: "circle",
  ELLIPSE: "ellipse",
  POLYGON: "polygon",
  INSET: "inset",
  PATH: "path",
  SVG: "svg"
};
const VisibilityType = {
  VISIBLE: "visible",
  HIDDEN: "hidden"
};
const TimingFunction = {
  LINEAR: "linear",
  EASE: "ease",
  EASE_IN: "ease-in",
  EASE_OUT: "ease-out",
  EASE_IN_OUT: "ease-in-out",
  STEPS: "steps",
  CUBIC_BEZIER: "cubic-bezier",
  PATH: "path"
};
const SpreadMethodType = {
  PAD: "pad",
  REFLECT: "reflect",
  REPEAT: "repeat"
};
const FuncType = {
  COMMA: "comma",
  COLOR: "color",
  LENGTH: "length",
  GRADIENT: "gradient",
  TIMING: "timing",
  KEYWORD: "keyword",
  STRING: "string",
  NUMBER: "number",
  BOOLEAN: "boolean",
  FUNCTION: "function",
  PATH: "path",
  URL: "url",
  REPEAT: "repeat",
  UNKNOWN: "unknown"
};
const PathSegmentType = {
  MOVETO: "M",
  LINETO: "L",
  CURVETO: "C",
  QUARDTO: "Q",
  ARCTO: "A",
  CLOSEPATH: "Z",
  UNKNOWN: "unknown"
};
const DirectionType = {
  TO_TOP: "to top",
  TO_RIGHT: "to right",
  TO_BOTTOM: "to bottom",
  TO_LEFT: "to left",
  TO_TOP_LEFT: "to top left",
  TO_TOP_RIGHT: "to top right",
  TO_BOTTOM_LEFT: "to bottom left",
  TO_BOTTOM_RIGHT: "to bottom right"
};
const DirectionNumberType = {
  1: DirectionType.TO_TOP_LEFT,
  2: DirectionType.TO_TOP_RIGHT,
  3: DirectionType.TO_BOTTOM_LEFT,
  4: DirectionType.TO_BOTTOM_RIGHT,
  11: DirectionType.TO_TOP,
  12: DirectionType.TO_RIGHT,
  13: DirectionType.TO_BOTTOM,
  14: DirectionType.TO_LEFT
};
const TargetActionType = {
  APPEND_CHILD: "appendChild",
  INSERT_BEFORE: "insertBefore",
  INSERT_AFTER: "insertAfter"
};
class SelectEditor extends EditorElement {
  initState() {
    var splitChar = this.props.split || ",";
    var options2 = Array.isArray(this.props.options) ? this.props.options.map((it) => {
      if (typeof it === "string") {
        return { value: it, text: it };
      }
      return it;
    }) : (this.props.options || "").split(splitChar).map((it) => it.trim()).map((it) => {
      const [value2, text2] = it.split(":");
      return { value: value2, text: text2 || value2 };
    });
    var value = this.props.value;
    var tabIndex = this.props.tabindex;
    var title2 = this.props.title;
    return {
      splitChar,
      label: this.props.label || "",
      title: title2,
      options: options2,
      value,
      tabIndex
    };
  }
  getOptionString() {
    var arr = this.state.options.map((it) => {
      var value = it.value;
      var label = it.text || it.value;
      if (label === "") {
        label = this.props["none-value"] ? this.props["none-value"] : "";
      } else if (label === "-") {
        label = "----------";
        value = "";
      }
      var selected = value === this.state.value ? "selected" : "";
      const disabled = it.disabled ? "disabled" : "";
      return `<option ${selected} value="${value}" ${disabled}>${label}</option>`;
    });
    return arr.join("");
  }
  template() {
    var { label, title: title2, tabIndex, value = BlendMode.NORMAL } = this.state;
    var hasLabel = label ? "has-label" : "";
    var hasTabIndex = tabIndex ? 'tabIndex="1"' : "";
    var compact = this.props.compact ? "compact" : "";
    if (obj$2[label]) {
      label = iconUse(label);
    }
    return `
            <div class='elf--select-editor ${hasLabel} ${compact}'>
                ${label ? `<label title="${title2}">${label}</label>` : ""}
                <div class="editor-view">
                    <select ref='$options' ${hasTabIndex}>
                        ${this.getOptionString()}
                    </select>
                    <div class='selected-value'>
                        <span class='value' ref="$selectedValue">${value}</span>
                        <span class='expand' ref='$expand'>${iconUse("expand_more")}</span>
                    </div>
                </div>
            </div>
        `;
  }
  getValue() {
    return this.refs.$options.value;
  }
  setValue(value) {
    this.refs.$options.val(this.state.value);
    this.setState({
      value: value + ""
    });
  }
  [BIND("$options")]() {
    return {
      "data-count": this.state.options.length.toString()
    };
  }
  [BIND("$selectedValue")]() {
    var _a;
    return {
      text: (_a = this.state.options.find((it) => it.value === this.state.value)) == null ? void 0 : _a.text
    };
  }
  [CHANGE("$options")]() {
    this.updateData({
      value: this.refs.$options.value
    });
    this.bindData("$selectedValue");
  }
  updateData(data) {
    this.setState(data, false);
    this.parent.trigger(this.props.onchange, this.props.key, this.state.value, this.props.params);
  }
}
const blend_list = [
  BlendMode.NORMAL,
  BlendMode.MULTIPLY,
  BlendMode.SCREEN,
  BlendMode.OVERLAY,
  BlendMode.DARKEN,
  BlendMode.LIGHTEN,
  BlendMode.COLOR_DODGE,
  BlendMode.COLOR_BURN,
  BlendMode.HARD_LIGHT,
  BlendMode.SOFT_LIGHT,
  BlendMode.DIFFERENCE,
  BlendMode.EXCLUSION,
  BlendMode.HUE,
  BlendMode.SATURATION,
  BlendMode.COLOR,
  BlendMode.LUMINOSITY
];
class BlendSelectEditor extends SelectEditor {
  getBlendList() {
    return blend_list.map((it) => {
      return { value: it, text: this.$i18n(`blend.${it}`) };
    });
  }
  initState() {
    return __spreadProps(__spreadValues({}, super.initState()), {
      options: this.getBlendList()
    });
  }
}
var BoxShadowEditor$1 = "";
class BoxShadowEditor extends EditorElement {
  initState() {
    return {
      boxShadows: this.props.value || []
    };
  }
  template() {
    return `
      <div class="elf--box-shadow-editor" >
        <div class='box-shadow-list' ref='$shadowList'></div>
      </div>
    `;
  }
  [LOAD("$shadowList") + DOMDIFF]() {
    var arr = this.state.boxShadows.map((shadow2, index2) => {
      return `
        <div class="shadow-item real" data-index="${index2}">
            <label draggable="true" data-index="${index2}">${iconUse("drag_indicator")}</label>
            <div class="shadow-content">
            ${createComponent("ColorViewEditor", {
        mini: true,
        key: "color",
        value: shadow2.color,
        params: index2,
        onchange: "changeKeyValue"
      })}
            ${createComponent("NumberInputEditor", {
        mini: true,
        key: "offsetX",
        label: "X",
        value: shadow2.offsetX,
        params: index2,
        onchange: "changeKeyValue"
      })}          
            ${createComponent("NumberInputEditor", {
        mini: true,
        key: "offsetY",
        label: "Y",
        value: shadow2.offsetY,
        params: index2,
        onchange: "changeKeyValue"
      })}                    
            ${createComponent("ToggleButton", {
        mini: true,
        key: "inset",
        value: shadow2.inset,
        params: index2,
        onChange: "changeKeyValue",
        checkedValue: BoxShadowStyle.INSET,
        toggleLabels: [iconUse("border_style"), iconUse("border_style")],
        toggleTitles: [BoxShadowStyle.INSET, BoxShadowStyle.INSET],
        toggleValues: [BoxShadowStyle.OUTSET, BoxShadowStyle.INSET]
      })}            

            ${createComponent("NumberInputEditor", {
        mini: true,
        label: "B",
        key: "blurRadius",
        value: shadow2.blurRadius,
        params: index2,
        onchange: "changeKeyValue"
      })} 
            ${createComponent("NumberInputEditor", {
        mini: true,
        label: "S",
        key: "spreadRadius",
        value: shadow2.spreadRadius,
        params: index2,
        onchange: "changeKeyValue"
      })}             
          </div>
          <div class="tools">
            <button type="button" class="remove" data-index="${index2}">
              ${iconUse("remove2")}
            </button>
          </div>
        </div>
      `;
    });
    return arr.join("");
  }
  modifyBoxShadow() {
    var value = this.state.boxShadows;
    this.parent.trigger(this.props.onchange, this.props.key, value);
  }
  [SUBSCRIBE("add")](shadows = void 0) {
    if (isArray(shadows)) {
      this.state.boxShadows.push(...shadows);
    } else {
      const shadowObj = {
        color: "black",
        inset: BoxShadowStyle.OUTSET,
        offsetX: 2,
        offsetY: 2,
        blurRadius: 3,
        spreadRadius: 1
      };
      this.state.boxShadows.push(shadowObj);
    }
    this.refresh();
    this.modifyBoxShadow();
  }
  [CLICK("$add")]() {
    this.trigger("add");
  }
  [DRAGSTART("$shadowList .shadow-item > label")](e) {
    this.startIndex = +e.$dt.attr("data-index");
  }
  [DRAGOVER("$shadowList .shadow-item") + PREVENT]() {
  }
  sortItem(arr, startIndex, targetIndex) {
    arr.splice(targetIndex + (startIndex < targetIndex ? -1 : 0), 0, ...arr.splice(startIndex, 1));
  }
  sortBoxShadow(startIndex, targetIndex) {
    this.sortItem(this.state.boxShadows, startIndex, targetIndex);
  }
  [DROP("$shadowList .shadow-item") + PREVENT](e) {
    var targetIndex = +e.$dt.attr("data-index");
    this.sortBoxShadow(this.startIndex, targetIndex);
    this.refresh();
    this.modifyBoxShadow();
  }
  [CLICK("$shadowList .remove")](e) {
    var index2 = +e.$dt.attr("data-index");
    this.state.boxShadows.splice(index2, 1);
    this.refresh();
    this.modifyBoxShadow();
  }
  [SUBSCRIBE_SELF("changeKeyValue")](key, value, index2) {
    var shadow2 = this.state.boxShadows[index2];
    this.state.boxShadows[index2] = __spreadProps(__spreadValues({}, shadow2), { [key]: value });
    this.modifyBoxShadow();
  }
}
const colors$k = [
  "#FFF8E1",
  "#FFECB3",
  "#FFE082",
  "#FFD54F",
  "#FFCA28",
  "#FFC107",
  "#FFB300",
  "#FFA000",
  "#FF8F00",
  "#FF6F00",
  "#FFE57F",
  "#FFD740",
  "#FFC400",
  "#FFAB00"
].map((color2) => {
  return { color: color2 };
});
var materialAmber = {
  title: "material amber",
  key: "material-amber",
  execute: function() {
    return colors$k;
  }
};
var __glob_0_0$4 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": materialAmber
}, Symbol.toStringTag, { value: "Module" }));
const colors$j = [
  "#e3f2fd",
  "#bbdefb",
  "#90caf9",
  "#64b5f6",
  "#42a5f5",
  "#2196f3",
  "#1e88e5",
  "#1976d2",
  "#1565c0",
  "#0d47a1",
  "#2196f3",
  "#82b1ff",
  "#448aff",
  "#2979ff",
  "#2962ff"
].map((color2) => {
  return { color: color2 };
});
var materialBlue = {
  title: "material blue",
  key: "material-blue",
  execute: function() {
    return colors$j;
  }
};
var __glob_0_1$4 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": materialBlue
}, Symbol.toStringTag, { value: "Module" }));
const colors$i = [
  "#ECEFF1",
  "#CFD8DC",
  "#B0BEC5",
  "#90A4AE",
  "#78909C",
  "#607D8B",
  "#546E7A",
  "#455A64",
  "#37474F",
  "#263238"
].map((color2) => {
  return { color: color2 };
});
var materialBluegray = {
  title: "material bluegray",
  key: "material-bluegray",
  execute: function() {
    return colors$i;
  }
};
var __glob_0_2$4 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": materialBluegray
}, Symbol.toStringTag, { value: "Module" }));
const colors$h = [
  "#EFEBE9",
  "#D7CCC8",
  "#BCAAA4",
  "#A1887F",
  "#8D6E63",
  "#795548",
  "#6D4C41",
  "#5D4037",
  "#4E342E",
  "#3E2723"
].map((color2) => {
  return { color: color2 };
});
var materialBrown = {
  title: "material brown",
  key: "material-brown",
  execute: function() {
    return colors$h;
  }
};
var __glob_0_3$4 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": materialBrown
}, Symbol.toStringTag, { value: "Module" }));
const colors$g = [
  "#e0f7fa",
  "#b2ebf2",
  "#80deea",
  "#4dd0e1",
  "#26c6da",
  "#00bcd4",
  "#00acc1",
  "#0097a7",
  "#00838f",
  "#006064",
  "#00bcd4",
  "#84ffff",
  "#18ffff",
  "#00e5ff",
  "#00b8d4"
].map((color2) => {
  return { color: color2 };
});
var materialCyan = {
  title: "material cyan",
  key: "material-cyan",
  execute: function() {
    return colors$g;
  }
};
var __glob_0_4$4 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": materialCyan
}, Symbol.toStringTag, { value: "Module" }));
const colors$f = [
  "#FBE9E7",
  "#FFCCBC",
  "#FFAB91",
  "#FF8A65",
  "#FF7043",
  "#FF5722",
  "#F4511E",
  "#E64A19",
  "#D84315",
  "#BF360C",
  "#FF9E80",
  "#FF6E40",
  "#FF3D00",
  "#DD2C00"
].map((color2) => {
  return { color: color2 };
});
var materialDeeporange = {
  title: "material deep orange",
  key: "material-deeporange",
  execute: function() {
    return colors$f;
  }
};
var __glob_0_5$4 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": materialDeeporange
}, Symbol.toStringTag, { value: "Module" }));
const colors$e = [
  "#ede7f6",
  "#d1c4e9",
  "#b39ddb",
  "#9575cd",
  "#7e57c2",
  "#673ab7",
  "#5e35b1",
  "#512da8",
  "#4527a0",
  "#311b92",
  "#673ab7",
  "#b388ff",
  "#7c4dff",
  "#651fff",
  "#6200ea"
].map((color2) => {
  return { color: color2 };
});
var materialDeeppurple = {
  title: "material deep purple",
  key: "material-deeppurple",
  execute: function() {
    return colors$e;
  }
};
var __glob_0_6$4 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": materialDeeppurple
}, Symbol.toStringTag, { value: "Module" }));
const colors$d = [
  "#FAFAFA",
  "#F5F5F5",
  "#EEEEEE",
  "#E0E0E0",
  "#BDBDBD",
  "#9E9E9E",
  "#757575",
  "#616161",
  "#424242",
  "#212121"
].map((color2) => {
  return { color: color2 };
});
var materialGray = {
  title: "material gray",
  key: "material-gray",
  execute: function() {
    return colors$d;
  }
};
var __glob_0_7$4 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": materialGray
}, Symbol.toStringTag, { value: "Module" }));
const colors$c = [
  "#E8F5E9",
  "#C8E6C9",
  "#A5D6A7",
  "#81C784",
  "#66BB6A",
  "#4CAF50",
  "#43A047",
  "#388E3C",
  "#2E7D32",
  "#1B5E20",
  "#B9F6CA",
  "#69F0AE",
  "#00E676",
  "#00C853"
].map((color2) => {
  return { color: color2 };
});
var materialGreen = {
  title: "material green",
  key: "material-green",
  execute: function() {
    return colors$c;
  }
};
var __glob_0_8$4 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": materialGreen
}, Symbol.toStringTag, { value: "Module" }));
const colors$b = [
  "#e8eaf6",
  "#c5cae9",
  "#9fa8da",
  "#7986cb",
  "#5c6bc0",
  "#3f51b5",
  "#3949ab",
  "#303f9f",
  "#283593",
  "#1a237e",
  "#3f51b5",
  "#8c9eff",
  "#536dfe",
  "#3d5afe",
  "#304ffe"
].map((color2) => {
  return { color: color2 };
});
var materialIndigo = {
  title: "material indigo",
  key: "material-indigo",
  execute: function() {
    return colors$b;
  }
};
var __glob_0_9$4 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": materialIndigo
}, Symbol.toStringTag, { value: "Module" }));
const colors$a = [
  "#e1f5fe",
  "#b3e5fc",
  "#81d4fa",
  "#4fc3f7",
  "#29b6f6",
  "#03a9f4",
  "#039be5",
  "#0288d1",
  "#0277bd",
  "#01579b",
  "#03a9f4",
  "#80d8ff",
  "#40c4ff",
  "#00b0ff",
  "#0091ea"
].map((color2) => {
  return { color: color2 };
});
var materialLightblue = {
  title: "material light blue",
  key: "material-lightblue",
  execute: function() {
    return colors$a;
  }
};
var __glob_0_10$4 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": materialLightblue
}, Symbol.toStringTag, { value: "Module" }));
const colors$9 = [
  "#F1F8E9",
  "#DCEDC8",
  "#C5E1A5",
  "#AED581",
  "#9CCC65",
  "#8BC34A",
  "#7CB342",
  "#689F38",
  "#558B2F",
  "#33691E",
  "#CCFF90",
  "#B2FF59",
  "#76FF03",
  "#64DD17"
].map((color2) => {
  return { color: color2 };
});
var materialLightgreen = {
  title: "material lightgreen",
  key: "material-lightgreen",
  execute: function() {
    return colors$9;
  }
};
var __glob_0_11$4 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": materialLightgreen
}, Symbol.toStringTag, { value: "Module" }));
const colors$8 = [
  "#F9FBE7",
  "#F0F4C3",
  "#E6EE9C",
  "#DCE775",
  "#D4E157",
  "#CDDC39",
  "#C0CA33",
  "#AFB42B",
  "#9E9D24",
  "#827717",
  "#F4FF81",
  "#EEFF41",
  "#C6FF00",
  "#AEEA00"
].map((color2) => {
  return { color: color2 };
});
var materialLime = {
  title: "material lime",
  key: "material-lime",
  execute: function() {
    return colors$8;
  }
};
var __glob_0_12$4 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": materialLime
}, Symbol.toStringTag, { value: "Module" }));
const colors$7 = [
  "#FFF3E0",
  "#FFE0B2",
  "#FFCC80",
  "#FFB74D",
  "#FFA726",
  "#FF9800",
  "#FB8C00",
  "#F57C00",
  "#EF6C00",
  "#E65100",
  "#FFD180",
  "#FFAB40",
  "#FF9100",
  "#FF6D00"
].map((color2) => {
  return { color: color2 };
});
var materialOrange = {
  title: "material orange",
  key: "material-orange",
  execute: function() {
    return colors$7;
  }
};
var __glob_0_13$4 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": materialOrange
}, Symbol.toStringTag, { value: "Module" }));
const colors$6 = [
  "#fce4ec",
  "#f8bbd0",
  "#f48fb1",
  "#f06292",
  "#ec407a",
  "#e91e63",
  "#d81b60",
  "#c2185b",
  "#ad1457",
  "#880e4f",
  "#e91e63",
  "#ff80ab",
  "#ff4081",
  "#f50057",
  "#c51162"
].map((color2) => {
  return { color: color2 };
});
var materialPink = {
  title: "material pink",
  key: "material-pink",
  execute: function() {
    return colors$6;
  }
};
var __glob_0_14$4 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": materialPink
}, Symbol.toStringTag, { value: "Module" }));
const colors$5 = [
  "#f3e5f5",
  "#e1bee7",
  "#ce93d8",
  "#ba68c8",
  "#ab47bc",
  "#9c27b0",
  "#8e24aa",
  "#7b1fa2",
  "#6a1b9a",
  "#4a148c",
  "#9c27b0",
  "#ea80fc",
  "#e040fb",
  "#d500f9",
  "#aa00ff"
].map((color2) => {
  return { color: color2 };
});
var materialPurple = {
  title: "material purple",
  key: "material-purple",
  execute: function() {
    return colors$5;
  }
};
var __glob_0_15$3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": materialPurple
}, Symbol.toStringTag, { value: "Module" }));
const colors$4 = [
  "#ffebee",
  "#ffcdd2",
  "#ef9a9a",
  "#e57373",
  "#ef5350",
  "#f44336",
  "#e53935",
  "#d32f2f",
  "#c62828",
  "#b71c1c",
  "#f44336",
  "#ff8a80",
  "#ff5252",
  "#ff1744",
  "#d50000"
].map((color2) => {
  return { color: color2 };
});
var materialRed = {
  title: "material red",
  key: "material-red",
  execute: function() {
    return colors$4;
  }
};
var __glob_0_16$3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": materialRed
}, Symbol.toStringTag, { value: "Module" }));
const colors$3 = [
  "#e0f2f1",
  "#b2dfdb",
  "#80cbc4",
  "#4db6ac",
  "#26a69a",
  "#009688",
  "#00897b",
  "#00796b",
  "#00695c",
  "#004d40",
  "#009688",
  "#a7ffeb",
  "#64ffda",
  "#1de9b6",
  "#00bfa5"
].map((color2) => {
  return { color: color2 };
});
var materialTeal = {
  title: "material teal",
  key: "material-teal",
  execute: function() {
    return colors$3;
  }
};
var __glob_0_17$3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": materialTeal
}, Symbol.toStringTag, { value: "Module" }));
const colors$2 = [
  "#FFFDE7",
  "#FFF9C4",
  "#FFF59D",
  "#FFF176",
  "#FFEE58",
  "#FFEB3B",
  "#FDD835",
  "#FBC02D",
  "#F9A825",
  "#F57F17",
  "#FFFF8D",
  "#FFFF00",
  "#FFEA00",
  "#FFD600"
].map((color2) => {
  return { color: color2 };
});
var materialYellow = {
  title: "material yellow",
  key: "material-yellow",
  execute: function() {
    return colors$2;
  }
};
var __glob_0_18$3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": materialYellow
}, Symbol.toStringTag, { value: "Module" }));
const colors$1 = [
  "#f8f9fa",
  "#f1f3f5",
  "#e9ecef",
  "#dee2e6",
  "#ced4da",
  "#adb5bd",
  "#868e96",
  "#495057",
  "#343a40",
  "#212529"
].map((color2) => {
  return { color: color2 };
});
var opencolorGray = {
  title: "opencolor gray",
  resource: "https://yeun.github.io/open-color/",
  key: "opencolor-gray",
  execute: function() {
    return colors$1;
  }
};
var __glob_0_19$3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": opencolorGray
}, Symbol.toStringTag, { value: "Module" }));
function format(obj2, type, defaultColor = "rgba(0, 0, 0, 0)") {
  if (Array.isArray(obj2)) {
    obj2 = { r: obj2[0], g: obj2[1], b: obj2[2], a: obj2[3] };
  }
  if (type == "hex") {
    return hex(obj2);
  } else if (type == "rgb") {
    return rgb(obj2, defaultColor);
  } else if (type == "hsl") {
    return hsl(obj2);
  }
  return obj2;
}
function formatWithoutAlpha(obj2, type, defaultColor = "rgba(0, 0, 0, 0)") {
  const newColorObj = clone$1(obj2);
  newColorObj.a = 1;
  return format(newColorObj, type, defaultColor);
}
function hex(obj2) {
  if (Array.isArray(obj2)) {
    obj2 = { r: obj2[0], g: obj2[1], b: obj2[2], a: obj2[3] };
  }
  var r = obj2.r.toString(16);
  if (obj2.r < 16)
    r = "0" + r;
  var g = obj2.g.toString(16);
  if (obj2.g < 16)
    g = "0" + g;
  var b = obj2.b.toString(16);
  if (obj2.b < 16)
    b = "0" + b;
  if (obj2.a == 1 || typeof obj2.a === "undefined") {
    return `#${r}${g}${b}`;
  } else {
    const alpha2 = Math.ceil(obj2.a * 255);
    var a = alpha2.toString(16);
    if (alpha2 < 16)
      a = "0" + a;
    return `#${r}${g}${b}${a}`;
  }
}
function rgb(obj2, defaultColor = "rgba(0, 0, 0, 0)") {
  if (Array.isArray(obj2)) {
    obj2 = { r: obj2[0], g: obj2[1], b: obj2[2], a: obj2[3] };
  }
  if (typeof obj2 === "undefined") {
    return void 0;
  }
  if (obj2.a == 1 || typeof obj2.a === "undefined") {
    if (isNaN(obj2.r)) {
      return defaultColor;
    }
    return `rgb(${obj2.r},${obj2.g},${obj2.b})`;
  } else {
    return `rgba(${obj2.r},${obj2.g},${obj2.b},${obj2.a})`;
  }
}
function hsl(obj2) {
  if (Array.isArray(obj2)) {
    obj2 = { r: obj2[0], g: obj2[1], b: obj2[2], a: obj2[3] };
  }
  if (obj2.a == 1 || typeof obj2.a === "undefined") {
    return `hsl(${obj2.h},${obj2.s}%,${obj2.l}%)`;
  } else {
    return `hsla(${obj2.h},${obj2.s}%,${obj2.l}%,${obj2.a})`;
  }
}
function randomNumber(min, max) {
  return Math.floor(Math.random() * (max - min + 1)) + min;
}
function randomByCount(count = 1) {
  let arr = [];
  for (var i = 0; i < count; i++) {
    arr[arr.length] = random$1();
  }
  return arr;
}
function random$1() {
  return rgb({
    r: randomNumber(0, 255),
    g: randomNumber(0, 255),
    b: randomNumber(0, 255)
  });
}
function randomRGBA() {
  return rgb({
    r: randomNumber(0, 255),
    g: randomNumber(0, 255),
    b: randomNumber(0, 255),
    a: randomNumber(0, 1e3) / 1e3
  });
}
function CMYKtoRGB(c2, m, y, k) {
  if (arguments.length == 1) {
    var { c: c2, m, y, k } = arguments[0];
  }
  const R = 255 * (1 - c2) * (1 - k);
  const G = 255 * (1 - m) * (1 - k);
  const B = 255 * (1 - y) * (1 - k);
  return { r: R, g: G, b: B };
}
function ReverseXyz(n) {
  return Math.pow(n, 3) > 8856e-6 ? Math.pow(n, 3) : (n - 16 / 116) / 7.787;
}
function ReverseRGB(n) {
  return n > 31308e-7 ? 1.055 * Math.pow(n, 1 / 2.4) - 0.055 : 12.92 * n;
}
function XYZtoRGB(x, y, z) {
  if (arguments.length == 1) {
    var { x, y, z } = arguments[0];
  }
  let X = x / 100;
  let Y = y / 100;
  let Z = z / 100;
  let R = X * 3.2406 + Y * -1.5372 + Z * -0.4986;
  let G = X * -0.9689 + Y * 1.8758 + Z * 0.0415;
  let B = X * 0.0557 + Y * -0.204 + Z * 1.057;
  R = ReverseRGB(R);
  G = ReverseRGB(G);
  B = ReverseRGB(B);
  const r = round(R * 255);
  const g = round(G * 255);
  const b = round(B * 255);
  return { r, g, b };
}
function LABtoXYZ(l, a, b) {
  if (arguments.length == 1) {
    var { l, a, b } = arguments[0];
  }
  let Y = (l + 16) / 116;
  let X = a / 500 + Y;
  let Z = Y - b / 200;
  Y = ReverseXyz(Y);
  X = ReverseXyz(X);
  Z = ReverseXyz(Z);
  const x = X * 95.047;
  const y = Y * 100;
  const z = Z * 108.883;
  return { x, y, z };
}
function PivotXyz(n) {
  return n > 8856e-6 ? Math.pow(n, 1 / 3) : (7.787 * n + 16) / 116;
}
function XYZtoLAB(x, y, z) {
  if (arguments.length == 1) {
    var { x, y, z } = arguments[0];
  }
  let X = x / 95.047;
  let Y = y / 100;
  let Z = z / 108.883;
  X = PivotXyz(X);
  Y = PivotXyz(Y);
  Z = PivotXyz(Z);
  const l = 116 * Y - 16;
  const a = 500 * (X - Y);
  const b = 200 * (Y - Z);
  return { l, a, b };
}
function LABtoRGB(l, a, b) {
  if (arguments.length == 1) {
    var { l, a, b } = arguments[0];
  }
  return XYZtoRGB(LABtoXYZ(l, a, b));
}
function RGBtoHSV(r, g, b) {
  if (arguments.length == 1) {
    var { r, g, b } = arguments[0];
  }
  const R1 = r / 255;
  const G1 = g / 255;
  const B1 = b / 255;
  const MaxC = Math.max(R1, G1, B1);
  const MinC = Math.min(R1, G1, B1);
  const DeltaC = MaxC - MinC;
  var H = 0;
  if (DeltaC == 0) {
    H = 0;
  } else if (MaxC == R1) {
    H = 60 * ((G1 - B1) / DeltaC % 6);
  } else if (MaxC == G1) {
    H = 60 * ((B1 - R1) / DeltaC + 2);
  } else if (MaxC == B1) {
    H = 60 * ((R1 - G1) / DeltaC + 4);
  }
  if (H < 0) {
    H = 360 + H;
  }
  var S = 0;
  if (MaxC == 0)
    S = 0;
  else
    S = DeltaC / MaxC;
  var V = MaxC;
  return { h: H, s: S, v: V };
}
function RGBtoCMYK(r, g, b) {
  if (arguments.length == 1) {
    var { r, g, b } = arguments[0];
  }
  const R1 = r / 255;
  const G1 = g / 255;
  const B1 = b / 255;
  const K = 1 - Math.max(R1, G1, B1);
  const C = (1 - R1 - K) / (1 - K);
  const M = (1 - G1 - K) / (1 - K);
  const Y = (1 - B1 - K) / (1 - K);
  return { c: C, m: M, y: Y, k: K };
}
function RGBtoHSL(r, g, b) {
  if (arguments.length == 1) {
    var { r, g, b } = arguments[0];
  }
  r /= 255, g /= 255, b /= 255;
  var max = Math.max(r, g, b), min = Math.min(r, g, b);
  var h, s, l = (max + min) / 2;
  if (max == min) {
    h = s = 0;
  } else {
    var d = max - min;
    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
    switch (max) {
      case r:
        h = (g - b) / d + (g < b ? 6 : 0);
        break;
      case g:
        h = (b - r) / d + 2;
        break;
      case b:
        h = (r - g) / d + 4;
        break;
    }
    h /= 6;
  }
  return { h: round(h * 360), s: round(s * 100), l: round(l * 100) };
}
function c(r, g, b) {
  if (arguments.length == 1) {
    var { r, g, b } = arguments[0];
  }
  return gray((r + g + b) / 3 > 90 ? 0 : 255);
}
function gray(gray2) {
  return { r: gray2, g: gray2, b: gray2 };
}
function RGBtoSimpleGray(r, g, b) {
  if (arguments.length == 1) {
    var { r, g, b } = arguments[0];
  }
  return gray(Math.ceil((r + g + b) / 3));
}
function RGBtoGray(r, g, b) {
  if (arguments.length == 1) {
    var { r, g, b } = arguments[0];
  }
  return gray(RGBtoYCrCb(r, g, b).y);
}
function brightness(r, g, b) {
  return Math.ceil(r * 0.2126 + g * 0.7152 + b * 0.0722);
}
function RGBtoYCrCb(r, g, b) {
  if (arguments.length == 1) {
    var { r, g, b } = arguments[0];
  }
  const Y = brightness(r, g, b);
  const Cb = 0.564 * (b - Y);
  const Cr = 0.713 * (r - Y);
  return { y: Y, cr: Cr, cb: Cb };
}
function PivotRGB(n) {
  return (n > 0.04045 ? Math.pow((n + 0.055) / 1.055, 2.4) : n / 12.92) * 100;
}
function RGBtoXYZ(r, g, b) {
  if (arguments.length == 1) {
    var { r, g, b } = arguments[0];
  }
  let R = r / 255;
  let G = g / 255;
  let B = b / 255;
  R = PivotRGB(R);
  G = PivotRGB(G);
  B = PivotRGB(B);
  const x = R * 0.4124 + G * 0.3576 + B * 0.1805;
  const y = R * 0.2126 + G * 0.7152 + B * 0.0722;
  const z = R * 0.0193 + G * 0.1192 + B * 0.9505;
  return { x, y, z };
}
function RGBtoLAB(r, g, b) {
  if (arguments.length == 1) {
    var { r, g, b } = arguments[0];
  }
  return XYZtoLAB(RGBtoXYZ(r, g, b));
}
function HUEtoRGB(p, q, t) {
  if (t < 0)
    t += 1;
  if (t > 1)
    t -= 1;
  if (t < 1 / 6)
    return p + (q - p) * 6 * t;
  if (t < 1 / 2)
    return q;
  if (t < 2 / 3)
    return p + (q - p) * (2 / 3 - t) * 6;
  return p;
}
function HSLtoHSV(h, s, l) {
  if (arguments.length == 1) {
    var { h, s, l } = arguments[0];
  }
  const rgb2 = HSLtoRGB(h, s, l);
  return RGBtoHSV(rgb2.r, rgb2.g, rgb2.b);
}
function HSLtoRGB(h, s, l) {
  if (arguments.length == 1) {
    var { h, s, l } = arguments[0];
  }
  var r, g, b;
  h /= 360;
  s /= 100;
  l /= 100;
  if (s == 0) {
    r = g = b = l;
  } else {
    var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
    var p = 2 * l - q;
    r = HUEtoRGB(p, q, h + 1 / 3);
    g = HUEtoRGB(p, q, h);
    b = HUEtoRGB(p, q, h - 1 / 3);
  }
  return { r: round(r * 255), g: round(g * 255), b: round(b * 255) };
}
function HSVtoRGB(h, s, v) {
  if (arguments.length == 1) {
    var { h, s, v } = arguments[0];
  }
  var H = h;
  var S = s;
  var V = v;
  if (H >= 360) {
    H = 0;
  }
  const C = S * V;
  const X = C * (1 - Math.abs(H / 60 % 2 - 1));
  const m = V - C;
  let temp = [];
  if (0 <= H && H < 60) {
    temp = [C, X, 0];
  } else if (60 <= H && H < 120) {
    temp = [X, C, 0];
  } else if (120 <= H && H < 180) {
    temp = [0, C, X];
  } else if (180 <= H && H < 240) {
    temp = [0, X, C];
  } else if (240 <= H && H < 300) {
    temp = [X, 0, C];
  } else if (300 <= H && H < 360) {
    temp = [C, 0, X];
  }
  return {
    r: round((temp[0] + m) * 255),
    g: round((temp[1] + m) * 255),
    b: round((temp[2] + m) * 255)
  };
}
function HSVtoHSL(h, s, v) {
  if (arguments.length == 1) {
    var { h, s, v } = arguments[0];
  }
  const rgb2 = HSVtoRGB(h, s, v);
  return RGBtoHSL(rgb2.r, rgb2.g, rgb2.b);
}
function YCrCbtoRGB(y, cr, cb, bit) {
  if (arguments.length == 1) {
    var { y, cr, cb, bit } = arguments[0];
    bit = bit || 0;
  }
  const R = y + 1.402 * (cr - bit);
  const G = y - 0.344 * (cb - bit) - 0.714 * (cr - bit);
  const B = y + 1.772 * (cb - bit);
  return { r: Math.ceil(R), g: Math.ceil(G), b: Math.ceil(B) };
}
const color_names = {
  aliceblue: "rgb(240, 248, 255)",
  antiquewhite: "rgb(250, 235, 215)",
  aqua: "rgb(0, 255, 255)",
  aquamarine: "rgb(127, 255, 212)",
  azure: "rgb(240, 255, 255)",
  beige: "rgb(245, 245, 220)",
  bisque: "rgb(255, 228, 196)",
  black: "rgb(0, 0, 0)",
  blanchedalmond: "rgb(255, 235, 205)",
  blue: "rgb(0, 0, 255)",
  blueviolet: "rgb(138, 43, 226)",
  brown: "rgb(165, 42, 42)",
  burlywood: "rgb(222, 184, 135)",
  cadetblue: "rgb(95, 158, 160)",
  chartreuse: "rgb(127, 255, 0)",
  chocolate: "rgb(210, 105, 30)",
  coral: "rgb(255, 127, 80)",
  cornflowerblue: "rgb(100, 149, 237)",
  cornsilk: "rgb(255, 248, 220)",
  crimson: "rgb(237, 20, 61)",
  cyan: "rgb(0, 255, 255)",
  darkblue: "rgb(0, 0, 139)",
  darkcyan: "rgb(0, 139, 139)",
  darkgoldenrod: "rgb(184, 134, 11)",
  darkgray: "rgb(169, 169, 169)",
  darkgrey: "rgb(169, 169, 169)",
  darkgreen: "rgb(0, 100, 0)",
  darkkhaki: "rgb(189, 183, 107)",
  darkmagenta: "rgb(139, 0, 139)",
  darkolivegreen: "rgb(85, 107, 47)",
  darkorange: "rgb(255, 140, 0)",
  darkorchid: "rgb(153, 50, 204)",
  darkred: "rgb(139, 0, 0)",
  darksalmon: "rgb(233, 150, 122)",
  darkseagreen: "rgb(143, 188, 143)",
  darkslateblue: "rgb(72, 61, 139)",
  darkslategray: "rgb(47, 79, 79)",
  darkslategrey: "rgb(47, 79, 79)",
  darkturquoise: "rgb(0, 206, 209)",
  darkviolet: "rgb(148, 0, 211)",
  deeppink: "rgb(255, 20, 147)",
  deepskyblue: "rgb(0, 191, 255)",
  dimgray: "rgb(105, 105, 105)",
  dimgrey: "rgb(105, 105, 105)",
  dodgerblue: "rgb(30, 144, 255)",
  firebrick: "rgb(178, 34, 34)",
  floralwhite: "rgb(255, 250, 240)",
  forestgreen: "rgb(34, 139, 34)",
  fuchsia: "rgb(255, 0, 255)",
  gainsboro: "rgb(220, 220, 220)",
  ghostwhite: "rgb(248, 248, 255)",
  gold: "rgb(255, 215, 0)",
  goldenrod: "rgb(218, 165, 32)",
  gray: "rgb(128, 128, 128)",
  grey: "rgb(128, 128, 128)",
  green: "rgb(0, 128, 0)",
  greenyellow: "rgb(173, 255, 47)",
  honeydew: "rgb(240, 255, 240)",
  hotpink: "rgb(255, 105, 180)",
  indianred: "rgb(205, 92, 92)",
  indigo: "rgb(75, 0, 130)",
  ivory: "rgb(255, 255, 240)",
  khaki: "rgb(240, 230, 140)",
  lavender: "rgb(230, 230, 250)",
  lavenderblush: "rgb(255, 240, 245)",
  lawngreen: "rgb(124, 252, 0)",
  lemonchiffon: "rgb(255, 250, 205)",
  lightblue: "rgb(173, 216, 230)",
  lightcoral: "rgb(240, 128, 128)",
  lightcyan: "rgb(224, 255, 255)",
  lightgoldenrodyellow: "rgb(250, 250, 210)",
  lightgreen: "rgb(144, 238, 144)",
  lightgray: "rgb(211, 211, 211)",
  lightgrey: "rgb(211, 211, 211)",
  lightpink: "rgb(255, 182, 193)",
  lightsalmon: "rgb(255, 160, 122)",
  lightseagreen: "rgb(32, 178, 170)",
  lightskyblue: "rgb(135, 206, 250)",
  lightslategray: "rgb(119, 136, 153)",
  lightslategrey: "rgb(119, 136, 153)",
  lightsteelblue: "rgb(176, 196, 222)",
  lightyellow: "rgb(255, 255, 224)",
  lime: "rgb(0, 255, 0)",
  limegreen: "rgb(50, 205, 50)",
  linen: "rgb(250, 240, 230)",
  magenta: "rgb(255, 0, 255)",
  maroon: "rgb(128, 0, 0)",
  mediumaquamarine: "rgb(102, 205, 170)",
  mediumblue: "rgb(0, 0, 205)",
  mediumorchid: "rgb(186, 85, 211)",
  mediumpurple: "rgb(147, 112, 219)",
  mediumseagreen: "rgb(60, 179, 113)",
  mediumslateblue: "rgb(123, 104, 238)",
  mediumspringgreen: "rgb(0, 250, 154)",
  mediumturquoise: "rgb(72, 209, 204)",
  mediumvioletred: "rgb(199, 21, 133)",
  midnightblue: "rgb(25, 25, 112)",
  mintcream: "rgb(245, 255, 250)",
  mistyrose: "rgb(255, 228, 225)",
  moccasin: "rgb(255, 228, 181)",
  navajowhite: "rgb(255, 222, 173)",
  navy: "rgb(0, 0, 128)",
  oldlace: "rgb(253, 245, 230)",
  olive: "rgb(128, 128, 0)",
  olivedrab: "rgb(107, 142, 35)",
  orange: "rgb(255, 165, 0)",
  orangered: "rgb(255, 69, 0)",
  orchid: "rgb(218, 112, 214)",
  palegoldenrod: "rgb(238, 232, 170)",
  palegreen: "rgb(152, 251, 152)",
  paleturquoise: "rgb(175, 238, 238)",
  palevioletred: "rgb(219, 112, 147)",
  papayawhip: "rgb(255, 239, 213)",
  peachpuff: "rgb(255, 218, 185)",
  peru: "rgb(205, 133, 63)",
  pink: "rgb(255, 192, 203)",
  plum: "rgb(221, 160, 221)",
  powderblue: "rgb(176, 224, 230)",
  purple: "rgb(128, 0, 128)",
  rebeccapurple: "rgb(102, 51, 153)",
  red: "rgb(255, 0, 0)",
  rosybrown: "rgb(188, 143, 143)",
  royalblue: "rgb(65, 105, 225)",
  saddlebrown: "rgb(139, 69, 19)",
  salmon: "rgb(250, 128, 114)",
  sandybrown: "rgb(244, 164, 96)",
  seagreen: "rgb(46, 139, 87)",
  seashell: "rgb(255, 245, 238)",
  sienna: "rgb(160, 82, 45)",
  silver: "rgb(192, 192, 192)",
  skyblue: "rgb(135, 206, 235)",
  slateblue: "rgb(106, 90, 205)",
  slategray: "rgb(112, 128, 144)",
  slategrey: "rgb(112, 128, 144)",
  snow: "rgb(255, 250, 250)",
  springgreen: "rgb(0, 255, 127)",
  steelblue: "rgb(70, 130, 180)",
  tan: "rgb(210, 180, 140)",
  teal: "rgb(0, 128, 128)",
  thistle: "rgb(216, 191, 216)",
  tomato: "rgb(255, 99, 71)",
  turquoise: "rgb(64, 224, 208)",
  violet: "rgb(238, 130, 238)",
  wheat: "rgb(245, 222, 179)",
  white: "rgb(255, 255, 255)",
  whitesmoke: "rgb(245, 245, 245)",
  yellow: "rgb(255, 255, 0)",
  yellowgreen: "rgb(154, 205, 50)",
  transparent: "rgba(0, 0, 0, 0)",
  currentColor: "currentColor"
};
function isColorName(name) {
  return !!color_names[name];
}
function getColorByName(name) {
  return color_names[name];
}
var ColorNames = {
  isColorName,
  getColorByName
};
const color_regexp = /(#(?:[\da-f]{3}){1,2}|#(?:[\da-f]{8})|rgb\((?:\s*\d{1,3},\s*){2}\d{1,3}\s*\)|rgba\((?:\s*\d{1,3},\s*){3}\d*\.?\d+\s*\)|hsl\(\s*\d{1,3}(?:,\s*\d{1,3}%){2}\s*\)|hsla\(\s*\d{1,3}(?:,\s*\d{1,3}%){2},\s*\d*\.?\d+\s*\)|([\w_-]+))/gi;
function getColorIndexString(it, prefix = "@") {
  return `${prefix}${it.startIndex}`.padEnd(10, "0");
}
function isColor(str) {
  const results = matches(str);
  return !!results.length;
}
function matches(str) {
  const matches2 = str.match(color_regexp);
  let result = [];
  if (!matches2) {
    return result;
  }
  for (var i = 0, len2 = matches2.length; i < len2; i++) {
    if (matches2[i].indexOf("#") > -1 || matches2[i].indexOf("rgb") > -1 || matches2[i].indexOf("hsl") > -1) {
      result.push({ color: matches2[i] });
    } else {
      var nameColor = ColorNames.getColorByName(matches2[i]);
      if (nameColor) {
        result.push({ color: matches2[i], nameColor });
      }
    }
  }
  var pos = { next: 0 };
  result.forEach((item) => {
    const startIndex = str.indexOf(item.color, pos.next);
    item.startIndex = startIndex;
    item.endIndex = startIndex + item.color.length;
    pos.next = item.endIndex;
  });
  return result;
}
function convertMatches(str, prefix = "@") {
  const m = matches(str);
  m.forEach((it) => {
    str = str.replace(it.color, getColorIndexString(it, prefix));
  });
  return { str, matches: m };
}
function convertMatchesArray(str, splitStr = ",") {
  const ret = convertMatches(str);
  return ret.str.split(splitStr).map((it, index2) => {
    it = trim(it);
    if (ret.matches[index2]) {
      it = it.replace(getColorIndexString(ret.matches[index2]), ret.matches[index2].color);
    }
    return it;
  });
}
function reverseMatches(str, matches2) {
  matches2.forEach((it) => {
    str = str.replace(getColorIndexString(it), it.color);
  });
  return str;
}
const REG_TRIM = /^\s+|\s+$/g;
function trim(str) {
  return str.replace(REG_TRIM, "");
}
function parse(str) {
  if (isString(str)) {
    if (ColorNames.isColorName(str)) {
      str = ColorNames.getColorByName(str);
    }
    if (str.indexOf("rgb(") > -1) {
      var arr = str.replace("rgb(", "").replace(")", "").split(",");
      for (var i = 0, len2 = arr.length; i < len2; i++) {
        arr[i] = parseInt(trim(arr[i]), 10);
      }
      var obj2 = { type: "rgb", r: arr[0], g: arr[1], b: arr[2], a: 1 };
      obj2 = __spreadValues(__spreadValues({}, obj2), RGBtoHSL(obj2));
      return obj2;
    } else if (str.indexOf("rgba(") > -1) {
      var arr = str.replace("rgba(", "").replace(")", "").split(",");
      for (var i = 0, len2 = arr.length; i < len2; i++) {
        if (len2 - 1 == i) {
          arr[i] = parseFloat(trim(arr[i]));
        } else {
          arr[i] = parseInt(trim(arr[i]), 10);
        }
      }
      var obj2 = { type: "rgb", r: arr[0], g: arr[1], b: arr[2], a: arr[3] };
      obj2 = __spreadValues(__spreadValues({}, obj2), RGBtoHSL(obj2));
      return obj2;
    } else if (str.indexOf("hsl(") > -1) {
      var arr = str.replace("hsl(", "").replace(")", "").split(",");
      for (var i = 0, len2 = arr.length; i < len2; i++) {
        arr[i] = parseFloat(trim(arr[i]));
      }
      var obj2 = { type: "hsl", h: arr[0], s: arr[1], l: arr[2], a: 1 };
      obj2 = __spreadValues(__spreadValues({}, obj2), HSLtoRGB(obj2));
      return obj2;
    } else if (str.indexOf("hsla(") > -1) {
      var arr = str.replace("hsla(", "").replace(")", "").split(",");
      for (var i = 0, len2 = arr.length; i < len2; i++) {
        if (len2 - 1 == i) {
          arr[i] = parseFloat(trim(arr[i]));
        } else {
          arr[i] = parseInt(trim(arr[i]), 10);
        }
      }
      var obj2 = { type: "hsl", h: arr[0], s: arr[1], l: arr[2], a: arr[3] };
      obj2 = __spreadValues(__spreadValues({}, obj2), HSLtoRGB(obj2));
      return obj2;
    } else if (str.indexOf("#") == 0) {
      str = str.replace("#", "");
      var arr = [];
      var a = 1;
      if (str.length == 3) {
        for (var i = 0, len2 = str.length; i < len2; i++) {
          var char = str.substr(i, 1);
          arr.push(parseInt(char + char, 16));
        }
      } else if (str.length === 8) {
        for (var i = 0, len2 = str.length; i < len2; i += 2) {
          arr.push(parseInt(str.substr(i, 2), 16));
        }
        a = arr.pop() / 255;
      } else {
        for (var i = 0, len2 = str.length; i < len2; i += 2) {
          arr.push(parseInt(str.substr(i, 2), 16));
        }
      }
      var obj2 = { type: "hex", r: arr[0], g: arr[1], b: arr[2], a };
      obj2 = __spreadValues(__spreadValues({}, obj2), RGBtoHSL(obj2));
      return obj2;
    }
  } else if (isNumber(str)) {
    if (0 <= str && str <= 16777215) {
      const r = (str & 16711680) >> 16;
      const g = (str & 65280) >> 8;
      const b = (str & 255) >> 0;
      var obj2 = { type: "hex", r, g, b, a: 1 };
      obj2 = __spreadValues(__spreadValues({}, obj2), RGBtoHSL(obj2));
      return obj2;
    } else if (0 <= str && str <= 4294967295) {
      const r = (str & 4278190080) >> 24;
      const g = (str & 16711680) >> 16;
      const b = (str & 65280) >> 8;
      const a2 = (str & 255) / 255;
      var obj2 = { type: "hex", r, g, b, a: a2 };
      obj2 = __spreadValues(__spreadValues({}, obj2), RGBtoHSL(obj2));
      return obj2;
    }
  }
  return str;
}
function parseGradient(colors2) {
  if (isString(colors2)) {
    colors2 = convertMatchesArray(colors2);
  }
  colors2 = colors2.map((it) => {
    if (isString(it)) {
      const ret = convertMatches(it);
      let arr = trim(ret.str).split(" ");
      if (arr[1]) {
        if (arr[1].indexOf("%") > -1) {
          arr[1] = parseFloat(arr[1].replace(/%/, "")) / 100;
        } else {
          arr[1] = parseFloat(arr[1]);
        }
      } else {
        arr[1] = "*";
      }
      arr[0] = reverseMatches(arr[0], ret.matches);
      return arr;
    } else if (Array.isArray(it)) {
      if (!it[1]) {
        it[1] = "*";
      } else if (isString(it[1])) {
        if (it[1].indexOf("%") > -1) {
          it[1] = parseFloat(it[1].replace(/%/, "")) / 100;
        } else {
          it[1] = +it[1];
        }
      }
      return [...it];
    }
  });
  const count = colors2.filter((it) => {
    return it[1] === "*";
  }).length;
  if (count > 0) {
    const sum = colors2.filter((it) => {
      return it[1] != "*" && it[1] != 1;
    }).map((it) => it[1]).reduce((total, cur) => {
      return total + cur;
    }, 0);
    const dist2 = (1 - sum) / count;
    colors2.forEach((it, index2) => {
      if (it[1] == "*" && index2 > 0) {
        if (colors2.length - 1 == index2)
          ;
        else {
          it[1] = dist2;
        }
      }
    });
  }
  return colors2;
}
function interpolateRGB(startColor, endColor, t = 0.5, exportFormat = "hex") {
  var obj2 = interpolateRGBObject(startColor, endColor, t);
  return format(obj2, exportFormat);
}
function interpolateRGBObject(startColor, endColor, t = 0.5) {
  const startColorAlpha = typeof startColor.a === "undefined" ? 1 : startColor.a;
  const endColorAlpha = typeof endColor.a === "undefined" ? 1 : endColor.a;
  return {
    r: round(startColor.r + (endColor.r - startColor.r) * t),
    g: round(startColor.g + (endColor.g - startColor.g) * t),
    b: round(startColor.b + (endColor.b - startColor.b) * t),
    a: round(startColorAlpha + (endColorAlpha - startColorAlpha) * t, 100)
  };
}
function scale(scale2, count = 5) {
  if (!scale2)
    return [];
  if (typeof scale2 === "string") {
    scale2 = convertMatchesArray(scale2);
  }
  scale2 = scale2 || [];
  var len2 = scale2.length;
  var colors2 = [];
  for (var i = 0; i < len2 - 1; i++) {
    for (var index2 = 0; index2 < count; index2++) {
      colors2.push(blend(scale2[i], scale2[i + 1], index2 / count));
    }
  }
  return colors2;
}
function blend(startColor, endColor, ratio = 0.5, format2 = "hex") {
  var s = parse(startColor);
  var e = parse(endColor);
  return interpolateRGB(s, e, ratio, format2);
}
function mix(startcolor, endColor, ratio = 0.5, format2 = "hex") {
  return blend(startcolor, endColor, ratio, format2);
}
function contrast(c2) {
  c2 = parse(c2);
  return (Math.round(c2.r * 299) + Math.round(c2.g * 587) + Math.round(c2.b * 114)) / 1e3;
}
function contrastColor(c2) {
  return contrast(c2) >= 128 ? "black" : "white";
}
function gradient$1(colors2, count = 10) {
  colors2 = parseGradient(colors2);
  let newColors = [];
  let maxCount = count - (colors2.length - 1);
  let allCount = maxCount;
  for (var i = 1, len2 = colors2.length; i < len2; i++) {
    var startColor = colors2[i - 1][0];
    var endColor = colors2[i][0];
    var rate = i == 1 ? colors2[i][1] : colors2[i][1] - colors2[i - 1][1];
    var colorCount = i == colors2.length - 1 ? allCount : Math.floor(rate * maxCount);
    newColors = newColors.concat(scale([startColor, endColor], colorCount), [
      endColor
    ]);
    allCount -= colorCount;
  }
  return newColors;
}
function scaleHSV(color2, target = "h", count = 9, exportFormat = "rgb", min = 0, max = 1, dist2 = 100) {
  var colorObj = parse(color2);
  var hsv = RGBtoHSV(colorObj);
  var unit = (max - min) * dist2 / count;
  var results = [];
  for (var i = 1; i <= count; i++) {
    hsv[target] = Math.abs((dist2 - unit * i) / dist2);
    results.push(format(HSVtoRGB(hsv), exportFormat));
  }
  return results;
}
function scaleH(color2, count = 9, exportFormat = "rgb", min = 0, max = 360) {
  return scaleHSV(color2, "h", count, exportFormat, min, max, 1);
}
function scaleS(color2, count = 9, exportFormat = "rgb", min = 0, max = 1) {
  return scaleHSV(color2, "s", count, exportFormat, min, max, 100);
}
function scaleV(color2, count = 9, exportFormat = "rgb", min = 0, max = 1) {
  return scaleHSV(color2, "v", count, exportFormat, min, max, 100);
}
scale.parula = function(count) {
  return scale(["#352a87", "#0f5cdd", "#00b5a6", "#ffc337", "#fdff00"], count);
};
scale.jet = function(count) {
  return scale([
    "#00008f",
    "#0020ff",
    "#00ffff",
    "#51ff77",
    "#fdff00",
    "#ff0000",
    "#800000"
  ], count);
};
scale.hsv = function(count) {
  return scale([
    "#ff0000",
    "#ffff00",
    "#00ff00",
    "#00ffff",
    "#0000ff",
    "#ff00ff",
    "#ff0000"
  ], count);
};
scale.hot = function(count) {
  return scale(["#0b0000", "#ff0000", "#ffff00", "#ffffff"], count);
};
scale.pink = function(count) {
  return scale(["#1e0000", "#bd7b7b", "#e7e5b2", "#ffffff"], count);
};
scale.bone = function(count) {
  return scale(["#000000", "#4a4a68", "#a6c6c6", "#ffffff"], count);
};
scale.copper = function(count) {
  return scale(["#000000", "#3d2618", "#9d623e", "#ffa167", "#ffc77f"], count);
};
const hue_color = [
  { rgb: "#ff0000", start: 0 },
  { rgb: "#ffff00", start: 0.17 },
  { rgb: "#00ff00", start: 0.33 },
  { rgb: "#00ffff", start: 0.5 },
  { rgb: "#0000ff", start: 0.67 },
  { rgb: "#ff00ff", start: 0.83 },
  { rgb: "#ff0000", start: 1 }
];
function checkHueColor(p) {
  var startColor, endColor;
  for (var i = 0; i < hue_color.length; i++) {
    if (hue_color[i].start >= p) {
      startColor = hue_color[i - 1];
      endColor = hue_color[i];
      break;
    }
  }
  if (startColor && endColor) {
    return mix(startColor, endColor, (p - startColor.start) / (endColor.start - startColor.start));
  }
  return hue_color[0].rgb;
}
function initHueColors() {
  for (var i = 0, len2 = hue_color.length; i < len2; i++) {
    var hue = hue_color[i];
    var obj2 = parse(hue.rgb);
    hue.r = obj2.r;
    hue.g = obj2.g;
    hue.b = obj2.b;
  }
}
initHueColors();
var random = {
  title: "random",
  key: "random",
  execute: function(count = 42) {
    const colorList = randomByCount(count).map((color2) => {
      return { color: color2 };
    });
    colorList.sort((a, b) => {
      const localA = parse(a.color);
      const localB = parse(b.color);
      return localA.h > localB.h ? 1 : -1;
    });
    return colorList;
  }
};
var __glob_0_20$3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": random
}, Symbol.toStringTag, { value: "Module" }));
const modules$4 = { "./colors_list/material-amber.js": __glob_0_0$4, "./colors_list/material-blue.js": __glob_0_1$4, "./colors_list/material-bluegray.js": __glob_0_2$4, "./colors_list/material-brown.js": __glob_0_3$4, "./colors_list/material-cyan.js": __glob_0_4$4, "./colors_list/material-deeporange.js": __glob_0_5$4, "./colors_list/material-deeppurple.js": __glob_0_6$4, "./colors_list/material-gray.js": __glob_0_7$4, "./colors_list/material-green.js": __glob_0_8$4, "./colors_list/material-indigo.js": __glob_0_9$4, "./colors_list/material-lightblue.js": __glob_0_10$4, "./colors_list/material-lightgreen.js": __glob_0_11$4, "./colors_list/material-lime.js": __glob_0_12$4, "./colors_list/material-orange.js": __glob_0_13$4, "./colors_list/material-pink.js": __glob_0_14$4, "./colors_list/material-purple.js": __glob_0_15$3, "./colors_list/material-red.js": __glob_0_16$3, "./colors_list/material-teal.js": __glob_0_17$3, "./colors_list/material-yellow.js": __glob_0_18$3, "./colors_list/opencolor-gray.js": __glob_0_19$3, "./colors_list/random.js": __glob_0_20$3 };
var colors = Object.values(modules$4).map((it) => it.default);
var ColorAssetsEditor$1 = "";
class ColorAssetsEditor extends EditorElement {
  initState() {
    return {
      mode: "grid",
      preset: "random",
      isLoaded: false,
      colors
    };
  }
  getTools() {
    return `<div ref="$tools"></div>`;
  }
  [LOAD("$tools")]() {
    const options2 = this.state.colors.map((it) => {
      return { value: it.key, text: it.title };
    });
    return createComponent("SelectEditor", {
      key: "preset",
      value: this.state.preset,
      options: options2,
      onchange: "changePreset"
    });
  }
  [SUBSCRIBE("changePreset")](key, value) {
    this.setState({
      [key]: value
    });
  }
  template() {
    return `
      <div class='elf--color-assets-editor'>
        <div class='color-assets-head'>
          <div class='tools'>${this.getTools()}</div>
        </div>
        <div class='color-list' ref='$colorList' data-view-mode='${this.state.mode}'></div>
      </div>
    `;
  }
  [CLICK("$title")]() {
    this.$el.toggleClass("is-open");
  }
  [LOAD("$colorList")]() {
    var preset = this.state.colors.find((it) => it.key === this.state.preset);
    if (!preset) {
      return "";
    }
    var results = preset.execute().map((item, index2) => {
      return `<div class='color-item' data-index="${index2}" data-color="${item.color}"><div class='preview' title="${item.color}" data-index="${index2}"><div class='color-view' style='background-color: ${item.color};'></div></div></div>`;
    });
    return results;
  }
  executeColor(callback, isRefresh = true, isEmit = true) {
    var project2 = this.$context.selection.currentProject;
    if (project2) {
      callback && callback(project2);
      if (isRefresh)
        this.refresh();
      if (isEmit)
        this.emit("refreshColorAssets");
    } else {
      window.alert("Please select a project.");
    }
  }
  [CLICK("$colorList .preview")](e) {
    const color2 = e.$dt.$(".color-view").css("background-color");
    this.modifyColorPicker(color2);
  }
  modifyColorPicker(color2) {
    this.parent.trigger(this.props.onchange, this.props.key, color2, this.props.params);
  }
}
var ColorSingleEditor$1 = "";
class ColorSingleEditor extends EditorElement {
  initState() {
    return {
      params: this.props.params,
      color: this.props.color || "rgba(0, 0, 0, 1)"
    };
  }
  updateData(opt = {}) {
    this.setState(opt, false);
    this.modifyColor();
  }
  modifyColor() {
    this.parent.trigger(this.props.onchange, this.props.key, this.state.color, this.state.params);
  }
  changeColor(color2) {
    this.setState({ color: color2 });
  }
  setValue(color2) {
    this.changeColor(color2);
  }
  [BIND("$miniView")]() {
    return {
      style: {
        "background-color": this.state.color
      }
    };
  }
  template() {
    return `
            <div class='elf--color-single-editor'>
                <div class='preview' ref='$preview'>
                    <div class='mini-view'>
                        <div class='color-view' style="background-color: ${this.state.color}" ref='$miniView'></div>
                    </div>
                </div>
            </div>
        `;
  }
  [CLICK("$preview")]() {
    this.viewColorPicker();
  }
  viewColorPicker() {
    this.emit("showColorPickerPopup", {
      target: this,
      changeEvent: (color2) => {
        this.refs.$miniView.cssText(`background-color: ${color2}`);
        this.updateData({ color: color2 });
      },
      color: this.state.color
    });
  }
}
var ColorViewEditor$1 = "";
class ColorViewEditor extends EditorElement {
  initState() {
    const value = this.props.value || "rgba(0, 0, 0, 1)";
    const compact = isBoolean(this.props.compact) ? this.props.compact : this.props.compact === "true";
    const mini = isBoolean(this.props.mini) ? this.props.mini : this.props.mini === "true";
    return {
      label: this.props.label,
      value,
      compact,
      mini,
      color: parse(value),
      colorFocus: false,
      opacityFocus: false
    };
  }
  updateData(opt = {}) {
    this.setState(opt);
    this.modifyColor();
  }
  updateEndData(opt = {}) {
    this.setState(opt);
    this.modifyEndColor();
  }
  getValue() {
    return this.state.value;
  }
  setValue(value) {
    this.changeColor(value);
  }
  modifyColor() {
    this.parent.trigger(this.props.onchange, this.props.key, this.state.value, this.props.params);
  }
  modifyEndColor() {
    this.parent.trigger(this.props.onchangeend, this.props.key, this.state.value, this.props.params);
  }
  changeColor(value) {
    this.setState({
      value,
      color: parse(value)
    });
  }
  get alpha() {
    return this.state.color.a * 100;
  }
  get hexColor() {
    return formatWithoutAlpha(this.state.color, "hex");
  }
  get fullColor() {
    return format(this.state.color, this.state.color.type);
  }
  refresh() {
    this.refreshColorView();
    this.refs.$colorCode.val(this.state.value);
    this.refs.$opacityCode.val(this.alpha);
  }
  refreshColorView() {
    this.bindData("$miniView1");
    this.bindData("$miniView2");
  }
  template() {
    var { label } = this.state;
    return `
            <div class='elf--color-view-editor'>
                ${label ? `<label>${label}</label>` : ""}            
                <div class='color-code' ref="$container">
                    <div class='preview' ref='$preview'>
                        <div class='mini-view'>
                            <div class='color-view' ref='$miniView1'></div>
                            <div class='color-view' ref='$miniView2'></div>
                        </div>
                    </div>                
                    <div class="color-input">
                        <input type="text" ref='$colorCode' value='${this.state.value}' tabIndex="1" />
                    </div>
                    <div class="opacity-input">                    
                        <input type="number" ref='$opacityCode' value='${this.alpha}' tabIndex="2" max="100" min="0" step="0.1" />
                    </div>                    
                </div>
            </div>
        `;
  }
  [BIND("$el")]() {
    var { label, compact, mini, colorFocus, opacityFocus } = this.state;
    return {
      class: [
        "elf--color-view-editor",
        {
          "has-label": label,
          compact,
          mini
        },
        {
          focused: colorFocus || opacityFocus
        }
      ]
    };
  }
  [BIND("$miniView1")]() {
    return {
      style: {
        "background-color": this.hexColor
      }
    };
  }
  [BIND("$miniView2")]() {
    return {
      style: {
        "background-color": this.fullColor
      }
    };
  }
  [BIND("$colorCode")]() {
    return {
      value: this.props.format ? this.hexColor : this.state.value
    };
  }
  [BIND("$opacityCode")]() {
    return {
      value: this.alpha
    };
  }
  [FOCUSIN("$colorCode")]() {
    this.setState({
      colorFocus: true
    });
    this.refs.$colorCode.select();
  }
  [FOCUSOUT("$colorCode")]() {
    this.setState({
      colorFocus: false
    });
  }
  [FOCUSIN("$opacityCode")]() {
    this.setState({
      opacityFocus: true
    });
    this.refs.$opacityCode.select();
  }
  [FOCUSOUT("$opacityCode")]() {
    this.setState({
      opacityFocus: false
    });
  }
  [CLICK("$preview")]() {
    this.viewColorPicker();
  }
  viewColorPicker() {
    this.emit("showColorPickerPopup", {
      target: this,
      changeEvent: (color2) => {
        this.updateData({ value: color2, color: parse(color2) });
      },
      changeEndEvent: (color2) => {
        this.updateEndData({ value: color2, color: parse(color2) });
      },
      color: this.state.value
    }, null, this.$el.rect());
  }
  [CLICK("$remove")]() {
    this.updateData({ value: "" });
  }
  [INPUT("$el .color-input input")](e) {
    var color2 = e.$dt.value;
    this.updateData({
      value: color2,
      color: parse(color2)
    });
    this.refreshColorView();
  }
  [INPUT("$el .opacity-input input")](e) {
    var opacity2 = +e.$dt.value;
    opacity2 = Math.max(0, Math.min(100, opacity2));
    const color2 = parse(this.state.value);
    color2.a = round(opacity2 / 100, 1e3);
    const value = format(color2, color2.type);
    this.updateData({
      value,
      color: color2
    });
    this.refreshColorView();
  }
}
var ComponentEditor$1 = "";
class ComponentEditor extends EditorElement {
  initState() {
    return {
      inspector: this.props.inspector
    };
  }
  template() {
    return `
      <div ref='$body' class="component-editor"></div>
    `;
  }
  getPropertyEditor(index2, childEditor) {
    if (childEditor.type === "folder") {
      return `
        <div class='component-folder'>
          <label>${iconUse("chevron_right")} ${childEditor.label}</label>
          <ul>
            ${childEditor.children.map((it, itemIndex) => {
        return `<li>${this.getPropertyEditor(`${index2}${itemIndex}`, it)}</li>`;
      }).join("")}
          </ul>
        </div>
      `;
    } else if (childEditor.type === "column") {
      const size2 = (childEditor.size || [2]).join("-");
      return `
        <div class='column column-${size2}' style="--column-gap: ${childEditor.gap || 0}px; --row-gap: ${childEditor.rowGap || 0}px" >
          ${childEditor.columns.map((it, itemIndex) => {
        if (it === "-") {
          return `<div class="column-item"></div>`;
        } else if (it.type === "label") {
          return `<div class="column-item">
                    <label>${it.label}</label>
                  </div>`;
        }
        return `
                  <div class='column-item'>
                    ${this.getPropertyEditor(`${index2}${itemIndex}`, it)}
                  </div>
                `;
      }).join("")}  
        </div>
      `;
    }
    return createComponent(childEditor.editor, __spreadProps(__spreadValues({}, childEditor.editorOptions), {
      onchange: (key, value) => {
        const newValue = isFunction(childEditor.convert) ? childEditor.convert(key, value) : value;
        this.trigger("changeComponentValue", key, newValue);
      },
      ref: `${childEditor.key}${index2}`,
      key: childEditor.key,
      value: childEditor.defaultValue
    }));
  }
  [LOAD("$body")]() {
    const inspector2 = this.state.inspector;
    var self2 = inspector2.map((it, index2) => {
      if (isString(it) || it.type === "label") {
        const title2 = it.label || it;
        return `
          <div class='component-item'> 
            <label>${title2}</label>
          </div>`;
      } else if (it.type === "folder") {
        return `
          <div class='component-item'>
            ${this.getPropertyEditor(index2, it)}
          </div>
        `;
      } else {
        return `
            <div class='component-item'> 
              ${this.getPropertyEditor(index2, it)}
            </div>
          `;
      }
    });
    return self2;
  }
  setInspector(inspector2) {
    this.setState({
      inspector: inspector2
    });
  }
  setValue(obj2 = {}) {
    Object.keys(obj2).forEach((key) => {
      const value = obj2[key];
      this.eachChildren((child) => {
        if (child.setValue && child.props.key === key) {
          child.setValue(value);
        }
      });
    });
  }
  getValue() {
    const result = {};
    this.eachChildren((child) => {
      if (isFunction(child.getValue) && child.props.key) {
        result[child.props.key] = child.getValue();
      }
    });
    return result;
  }
  [SUBSCRIBE_SELF("changeComponentValue")](key, value) {
    this.parent.trigger(this.props.onchange, key, value);
  }
  [CLICK("$el .component-folder > label")](e) {
    const $target = e.$dt.closest("component-folder");
    $target.toggleClass("close");
  }
}
var CSSPropertyEditor$1 = "";
class CSSPropertyEditor extends EditorElement {
  initState() {
    return {
      hideTitle: this.props["hide-title"] === "true",
      hideRefresh: this.props["hide-refresh"] === "true",
      properties: []
    };
  }
  updateData(opt) {
    this.setState(opt, false);
    this.modifyProperty();
  }
  modifyProperty() {
    this.parent.trigger(this.props.onchange, this.state.properties);
  }
  template() {
    const hideTitleClass = this.state.hideTitle ? "hide-title" : "";
    const hideRefreshClass = this.state.hideRefresh ? "hide-refresh" : "";
    return `
      <div class='elf--css-property-editor ${hideTitleClass} ${hideRefreshClass}'>
        <div class='title'>
          <label>${this.$i18n("css.property.editor.properties")}</label>
          <div class='tools'>
            ${this.makePropertySelect()}
            <button type="button" ref='$addProperty'>${obj$2.add}</button>
          </div>
        </div>
        <div class='input grid-1 css-property-list' ref='$property'></div>
      </div>
    `;
  }
  getPropertyDefaultValue(key) {
    switch (key) {
      case "animation-timing-function":
      case "box-shadow":
      case "text-shadow":
      case "color":
      case "background-image":
      case "background-color":
      case "text-fill-color":
      case "text-stroke-color":
      case "filter":
      case "backdrop-filter":
      case "var":
      case "transform":
      case "transform-origin":
      case "perspective-origin":
      case "playTime":
        return Length.string("");
      case "offset-distance":
        return Length.percent(0);
      case "rotate":
        return Length.deg(0);
      case "mix-blend-mode":
        return "normal";
      case "clip-path":
        return "";
      case "opacity":
        return 1;
      default:
        return 0;
    }
  }
  [CLICK("$addProperty")]() {
    var key = this.getRef("$propertySelect").value;
    var searchItem = this.state.properties.find((it) => {
      return it.key === key;
    });
    if (searchItem) {
      window.alert(`${key} is already added.`);
      return;
    }
    var value = this.getPropertyDefaultValue(key);
    var current = this.$context.selection.current;
    if (current) {
      value = current[key];
    }
    this.state.properties.push({ key, value });
    this.refresh();
    this.modifyProperty();
  }
  makeIndivisualPropertyColorEditor(property, index2) {
    var key = property.key.split("-").join("");
    return `
      <div class='property-editor'>
        <object refClass="ColorViewEditor" ref='$${key}${index2}' value="${property.value}" key="${property.key}" onChange="changeColorProperty" />
      </div>
    `;
  }
  makeCustomePropertyEditor(property, index2) {
    return `
      <div class='property-editor'>
        ${createComponent(property.editor, {
      onchange: "changeSelect",
      ref: `$customProperty${index2}`,
      key: property.key,
      value: property.value
    })}
      </div>
    `;
  }
  makeIndivisualPropertyEditor(property, index2) {
    if (property.key === "background-image") {
      return `
        <div class='property-editor'>
          ${createComponent("BackgroundImageEditor", {
        ref: `$backgroundImage${index2}`,
        key: property.key,
        "hide-title": this.state.hideTitle,
        value: property.value,
        onchange: "changeKeyValue"
      })}
        </div>
      `;
    } else if (property.key === "filter") {
      return `
        <div class='property-editor'>
          <object refClass="FilterEditor" ref='$filter${index2}' key="${property.key}" value="${property.value}" onChange="changeKeyValue" />
        </div>
      `;
    } else if (property.key === "backdrop-filter") {
      return `
        <div class='property-editor'>
          <object refClass="FilterEditor" ref='$backdropFilter${index2}' key="${property.key}" value="${property.value}" onChange="changeKeyValue" />
        </div>
      `;
    } else if (property.key === "box-shadow") {
      return `
        <div class='property-editor'>
          <object refClass="BoxShadowEditor" ref='$boxshadow${index2}' value="${property.value}" hide-label="false" onChange="changeBoxShadowProperty" />
        </div>
      `;
    } else if (property.key === "text-shadow") {
      return `
        <div class='property-editor'>
          <object refClass="TextShadowEditor" ref='$textshadow${index2}' value="${property.value}" hide-label="false" onChange="changeTextShadowProperty" />
        </div>
      `;
    } else if (property.key === "var") {
      return `
        <div class='property-editor'>
          <object refClass="VarEditor" ref='$var${index2}' value="${property.value}" onChange="changeVar" />
        </div>
      `;
    } else if (property.key === "transform") {
      return `
        <div class='property-editor'>
          <object refClass="TransformEditor" ref='$transform${index2}' value="${property.value}" onChange="changeTransform" />
        </div>
      `;
    } else if (property.key === "transform-origin") {
      return `
        <div class='property-editor'>
          <object refClass="TransformOriginEditor" ref='$transformOrigin${index2}' value="${property.value}" onChange="changeTransformOrigin" />
        </div>
      `;
    } else if (property.key === "perspective-origin") {
      return `
        <div class='property-editor'>
          <object refClass="PerspectiveOriginEditor" ref='$perspectiveOrigin${index2}' value="${property.value}" onChange="changePerspectiveOrigin" />
        </div>
      `;
    } else if (property.key === "fill-rule") {
      return `
        <div class='property-editor'>
          <object refClass="SelectEditor"  
          ref='$fillRule${index2}' 
          key='fill-rule' 
          icon="true" 
          options=${variable$4(["nonzero", "evenodd"])}
          value="${property.value}"
          onchange="changeSelect" />
        </div>
      `;
    } else if (property.key === "stroke-linecap") {
      return `
        <div class='property-editor'>
          <object refClass="SelectEditor"  
          ref='$strokeLinecap${index2}' 
          key='stroke-linecap' 
          icon="true" 
          options=${variable$4(["butt", "round", "square"])}          
          value="${property.value}"
          onchange="changeSelect" />
        </div>
      `;
    } else if (property.key === "stroke-linejoin") {
      return `
        <div class='property-editor'>
          <object refClass="SelectEditor"  
          ref='$strokeLinejoin${index2}' 
          key='stroke-linejoin' 
          icon="true" 
          options=${variable$4([
        "miter",
        "arcs",
        "bevel",
        "miter-clip",
        "round"
      ])}                    
          value="${property.value}"
          onchange="changeSelect" />
        </div>
      `;
    } else if (property.key === "mix-blend-mode") {
      return `
        <div class='property-editor'>
          <object refClass="BlendSelectEditor" 
          ref='$mixBlendMode${index2}' 
          key='mix-blend-mode' 
          icon="true" 
          value="${property.value}"
          onchange="changeSelect" />
        </div>
      `;
    } else if (property.key === "stroke-dasharray") {
      return `
        <object refClass="StrokeDashArrayEditor" 
          ref='$strokeDashArray${index2}' 
          key='stroke-dasharray'
          value='${property.value}' 
          onchange='changeSelect' 
        />
      `;
    } else if (property.key === "border-radius") {
      return `
        <object refClass="BorderRadiusEditor"
          ref='$borderRadius${index2}' 
          key='border-radius'
          value='${property.value}' 
          onchange='changeBorderRadius' 
        />
      `;
    } else if (property.key === "border") {
      return `
        <object refClass="BorderEditor"
          ref='$border${index2}' 
          key='border'
          value='${property.value}' 
          onchange='changeKeyValue' 
        />
      `;
    } else if (property.key === "clip-path") {
      return `
        <object refClass="ClipPathEditor"
          ref='$clipPath${index2}' 
          key='clip-path'
          value='${property.value}' 
          onchange='changeClipPath' 
        />
      `;
    } else if (property.key === "d") {
      return `
        <object refClass="PathDataEditor" ref='$pathData${index2}' key='d' value='${property.value}' onchange='changeSelect' />
      `;
    } else if (property.key === "points") {
      return `
        <object refClass="PolygonDataEditor" ref='$polygonData${index2}' key='points' value='${property.value}' onchange='changeSelect' />
      `;
    } else if (property.key === "playTime") {
      return `
        <object refClass="MediaProgressEditor" ref='$playTime${index2}'  key='playTime' value="${property.value}" onchange="changeSelect" />      
      `;
    }
    return `
      <div class='property-editor'>
        ???

      </div>
    `;
  }
  [SUBSCRIBE_SELF("changeKeyValue")](key, value) {
    this.modifyPropertyValue(key, value);
  }
  [SUBSCRIBE_SELF("changeBorderRadius")](value) {
    this.modifyPropertyValue("border-radius", value);
  }
  [SUBSCRIBE_SELF("changeClipPath")](value) {
    this.modifyPropertyValue("clip-path", value);
  }
  [SUBSCRIBE_SELF("changeColorProperty")](key, color2) {
    this.modifyPropertyValue(key, color2);
  }
  [SUBSCRIBE_SELF("changeBackgroundImageProperty")](key, backgroundImage2) {
    this.modifyPropertyValue(key, backgroundImage2);
  }
  [SUBSCRIBE_SELF("changeFilterProperty")](filter2) {
    this.modifyPropertyValue("filter", filter2);
  }
  [SUBSCRIBE_SELF("changeBackdropFilterProperty")](filter2) {
    this.modifyPropertyValue("backdrop-filter", filter2);
  }
  [SUBSCRIBE_SELF("changeBoxShadowProperty")](boxshadow) {
    this.modifyPropertyValue("box-shadow", boxshadow);
  }
  [SUBSCRIBE_SELF("changeTextShadowProperty")](textShadow2) {
    this.modifyPropertyValue("text-shadow", textShadow2);
  }
  [SUBSCRIBE_SELF("changeVar")](value) {
    this.modifyPropertyValue("var", value);
  }
  [SUBSCRIBE_SELF("changeTransform")](value) {
    this.modifyPropertyValue("transform", value);
  }
  [SUBSCRIBE_SELF("changeTransformOrigin")](value) {
    this.modifyPropertyValue("transform-origin", value);
  }
  [SUBSCRIBE_SELF("changePerspectiveOrigin")](value) {
    this.modifyPropertyValue("perspective-origin", value);
  }
  [SUBSCRIBE_SELF("changeSelect")](key, value) {
    this.modifyPropertyValue(key, value);
  }
  makePropertyEditor(property, index2) {
    if (property.editor) {
      return this.makeCustomePropertyEditor(property, index2);
    }
    switch (property.key) {
      case "animation-timing-function":
      case "box-shadow":
      case "text-shadow":
      case "background-image":
      case "filter":
      case "backdrop-filter":
      case "var":
      case "transform":
      case "transform-origin":
      case "perspective-origin":
      case "mix-blend-mode":
      case "border":
      case "border-radius":
      case "clip-path":
      case "fill-rule":
      case "stroke-linecap":
      case "stroke-linejoin":
      case "stroke-dasharray":
      case "d":
      case "points":
      case "offset-path":
      case "playTime":
        return this.makeIndivisualPropertyEditor(property, index2);
      case "color":
      case "background-color":
      case "text-fill-color":
      case "text-stroke-color":
      case "stroke":
      case "fill":
        return this.makeIndivisualPropertyColorEditor(property, index2);
      case "opacity":
      case "fill-opacity":
      case "stroke-dashoffset":
      case "offset-distance":
        let min = 0;
        let max = 1;
        let step2 = 0.01;
        return `
          <div class='property-editor'>
            <object refClass="NumberRangeEditor"  
              ref='$opacity${index2}' 
              key='${property.key}' 
              min="${min}"
              max="${max}"
              step="${step2}"
              value="${property.value || 1}"
              selected-unit='number'
              removable="true"
              onchange="changeRangeEditor" />
          </div>
        `;
      case "rotate":
        return `
          <div class='property-editor'>
            <object refClass="RangeEditor"  
              ref='rangeEditor${index2}' 
              key='${property.key}' 
              value='${property.value}'  
              min="-2000"
              max="2000"
              units="deg" 
              onChange="changeRangeEditor" />
          </div>
        `;
      case "left":
      case "margin-top":
      case "margin-bottom":
      case "margin-left":
      case "margin-right":
      case "padding-top":
      case "padding-bottom":
      case "padding-left":
      case "padding-right":
      case "width":
      case "height":
      case "perspective":
      case "text-stroke-width":
      default:
        return `
          <div class='property-editor'>
            <object refClass="RangeEditor"  ref='rangeEditor${index2}' key='${property.key}' value='${property.value}' max="1000" onChange="changeRangeEditor" />
          </div>
        `;
    }
  }
  [SUBSCRIBE_SELF("changeRangeEditor")](key, value) {
    this.modifyPropertyValue(key, value + "");
  }
  searchKey(key, callback) {
    this.state.properties.filter((it) => it.key === key).forEach(callback);
  }
  modifyPropertyValue(key, value) {
    this.searchKey(key, (it) => {
      it.value = value;
    });
    this.modifyProperty();
  }
  makePropertySelect() {
    return `
      <select class='property-select' ref='$propertySelect'>
        <optgroup label='Position'>
          <option value='x'>x</option>
          <option value='y'>y</option>        
        </optgroup>
        <optgroup label='Size'>
          <option value='width'>width</option>
          <option value='height'>height</option>
        </optgroup>      
        <optgroup label='Box Model'>
          <option value='margin-left'>margin-left</option>
          <option value='margin-right'>margin-right</option>
          <option value='margin-bottom'>margin-bottom</option>
          <option value='margin-top'>margin-top</option>
          <option value='padding-left'>padding-left</option>
          <option value='padding-right'>padding-right</option>
          <option value='padding-bottom'>padding-bottom</option>
          <option value='padding-top'>padding-top</option>       
        </optgroup>
        <optgroup label='Border'>
          <option value='border'>border</option>
          <option value='border-radius'>border-radius</option>
        </optgroup>        
        <optgroup label='Style'>
          <option value='background-color'>background-color</option>
          <option value='background-image'>background-image</option>
          <option value='box-shadow'>box-shadow</option>
          <option value='text-shadow'>text-shadow</option>
          <option value='filter'>filter</option>      
          <option value='backdrop-filter'>backdrop-filter</option>
          <option value='mix-blend-mode'>mix-blend-mode</option>
        </optgroup>            
        <optgroup label='Transform'>
          <option value='transform'>transform</option>
          <option value='transform-origin'>transform-origin</option>
          <option value='perspective'>perspective</option>
          <option value='perspective-origin'>perspective-origin</option>
        </optgroup>
        <optgroup label='Font'>
          <option value='font-size'>font-size</option>
          <option value='font-weight'>font-weight</option>          
        </optgroup>
        <optgroup label='Animation'>
          <option value='animation-timing-function'>timing-function</option>
        </optgroup>        
      </select>
    `;
  }
  [LOAD("$property")]() {
    return this.state.properties.map((it, index2) => {
      return `
        <div class='css-property-item'>
          <div class='title'>
            <label>${it.key}</label>
            <div class='tools'>
              <button type="button" class='remove' data-index="${index2}">${obj$2.remove2}</button>
            </div>
          </div>
          <div class='title-2'>
            <div class='tools'>
              <label><button type="button" class='refresh' data-index="${index2}">${obj$2.refresh}</button> Refresh</label>
            </div>
          </div>
          <div class='value-editor'>
            ${this.makePropertyEditor(it, index2)}
          </div>
        </div>
      `;
    });
  }
  [SUBSCRIBE("showCSSPropertyEditor")](properties = []) {
    this.setState({ properties });
    this.refresh();
  }
  [CLICK("$property .remove")](e) {
    var index2 = +e.$dt.attr("data-index");
    this.state.properties.splice(index2, 1);
    this.refresh();
    this.modifyProperty();
  }
  [CLICK("$property .refresh")]() {
    this.parent.trigger("refreshPropertyValue");
  }
}
var CubicBezierEditor$1 = "";
const MAX_CACHE_COUNT$2 = 1e3;
const cachedTransformOriginMap = /* @__PURE__ */ new Map();
class TransformOriginCache {
  static has(key) {
    return cachedTransformOriginMap.has(key);
  }
  static get(key) {
    return cachedTransformOriginMap.get(key);
  }
  static set(key, parsedValue) {
    if (cachedTransformOriginMap.size > MAX_CACHE_COUNT$2) {
      cachedTransformOriginMap.clear();
    }
    cachedTransformOriginMap.set(key, parsedValue);
  }
}
class TransformOrigin {
  static parseStyle(transformOrigin = "50% 50% 0px") {
    if (TransformOriginCache.has(transformOrigin)) {
      return TransformOriginCache.get(transformOrigin);
    }
    const origins = transformOrigin.trim().split(" ").filter((it) => it.trim());
    let parsedTransformOrigin = null;
    if (origins.length === 1) {
      parsedTransformOrigin = [origins[0], origins[0]].map((it) => Length.parse(it));
    } else {
      parsedTransformOrigin = origins.map((it) => Length.parse(it));
    }
    TransformOriginCache.set(transformOrigin, parsedTransformOrigin);
    return parsedTransformOrigin;
  }
  static scale(transformOrigin, width2, height2) {
    let parsedTransformOrigin = TransformOrigin.parseStyle(transformOrigin);
    if (width2 === 0 && height2 === 0) {
      return [0, 0, 0];
    }
    const originX = parsedTransformOrigin[0].toPx(width2).value;
    const originY = parsedTransformOrigin[1].toPx(height2).value;
    const originZ = parsedTransformOrigin[2].value;
    return [originX, originY, originZ];
  }
  static toPx(transformOrigin, width2, height2, distance2 = 0) {
    let [transformOriginX, transformOriginY, transformOriginZ] = TransformOrigin.parseStyle(transformOrigin);
    transformOriginX = transformOriginX.toPx(width2);
    transformOriginY = transformOriginY.toPx(height2);
    transformOriginZ = transformOriginZ.toPx(distance2);
    return `${transformOriginX} ${transformOriginY} ${transformOriginZ}`;
  }
}
function rectRect(rx1, ry1, rw1, rh1, rx2, ry2, rw2, rh2) {
  return rx1 + rw1 >= rx2 && rx1 <= rx2 + rw2 && ry1 + rh1 >= ry2 && ry1 <= ry2 + rh2;
}
class Rect {
  constructor(x, y, width2, height2) {
    this.x = x;
    this.y = y;
    this.width = width2;
    this.height = height2;
  }
  get left() {
    return this.x;
  }
  get right() {
    return this.x + this.width;
  }
  get top() {
    return this.y;
  }
  get bottom() {
    return this.y + this.height;
  }
  get centerX() {
    return this.x + this.width / 2;
  }
  get centerY() {
    return this.y + this.height / 2;
  }
  get center() {
    return [this.centerX, this.centerY];
  }
  get topLeft() {
    return [this.left, this.top];
  }
  get topRight() {
    return [this.right, this.top];
  }
  get bottomLeft() {
    return [this.left, this.bottom];
  }
  get bottomRight() {
    return [this.right, this.bottom];
  }
  get vertices() {
    return [this.topLeft, this.topRight, this.bottomLeft, this.bottomRight];
  }
  intersect(rect2) {
    return intersectRectRect(this, rect2);
  }
}
function intersectRectRect(rect1, rect2) {
  const minRectX = Math.min(rect1.x, rect2.x);
  const minRectY = Math.min(rect1.y, rect2.y);
  const rect1Verties = rectToVerties(rect1.x - minRectX, rect1.y - minRectY, rect1.width, rect1.height);
  const rect2Verties = rectToVerties(rect2.x - minRectX, rect2.y - minRectY, rect2.width, rect2.height);
  const startPoint = [
    Math.max(rect1Verties[0][0], rect2Verties[0][0]),
    Math.max(rect1Verties[0][1], rect2Verties[0][1]),
    Math.max(rect1Verties[0][2], rect2Verties[0][2])
  ];
  const endPoint = [
    Math.min(rect1Verties[2][0], rect2Verties[2][0]),
    Math.min(rect1Verties[2][1], rect2Verties[2][1]),
    Math.min(rect1Verties[2][2], rect2Verties[2][2])
  ];
  const minX = Math.min(startPoint[0], endPoint[0]);
  const minY = Math.min(startPoint[1], endPoint[1]);
  const maxX = Math.max(startPoint[0], endPoint[0]);
  const maxY = Math.max(startPoint[1], endPoint[1]);
  return new Rect(minX + minRectX, minY + minRectY, maxX - minX, maxY - minY);
}
function linePoint(x1, y1, x2, y2, px, py, buffer = 0.1) {
  const dist1 = Math.hypot(px - x1, py - y1);
  const dist2 = Math.hypot(px - x2, py - y2);
  const lineLength = Math.hypot(x1 - x2, y1 - y2);
  const calcDist = dist1 + dist2;
  return calcDist >= lineLength - buffer && calcDist <= lineLength + buffer;
}
function lineLineWithoutPoint(x1, y1, x2, y2, x3, y3, x4, y4) {
  let A = ((x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3)) / ((y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1));
  let B = ((x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3)) / ((y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1));
  return 0 <= A && A <= 1 && 0 <= B && B <= 1;
}
function lineLine(x1, y1, x2, y2, x3, y3, x4, y4, epsilon = 0.1) {
  if (linePoint(x1, y1, x2, y2, x3, y3))
    return true;
  else if (linePoint(x1, y1, x2, y2, x4, y4))
    return true;
  else if (linePoint(x3, y3, x4, y4, x1, y1))
    return [x1, y1];
  else if (linePoint(x3, y3, x4, y4, x2, y2))
    return [x2, y2];
  return lineLineWithoutPoint(x1, y1, x2, y2, x3, y3, x4, y4);
}
function polyPoint(verties = [], px, py, withoutPoint = false) {
  let isCollision = false;
  const len2 = verties.length;
  if (withoutPoint === false) {
    for (let i = 0; i < len2; i++) {
      const v1 = verties[i];
      const v2 = verties[(i + 1) % len2];
      if (linePoint(v1[0], v1[1], v2[0], v2[1], px, py)) {
        isCollision = true;
        break;
      }
    }
  }
  if (isCollision)
    return true;
  verties.forEach((vector, index2) => {
    const [cx, cy] = vector;
    const [nx, ny] = verties[(index2 + 1) % len2];
    if ((cy >= py && ny < py || cy < py && ny >= py) && px < (nx - cx) * (py - cy) / (ny - cy) + cx) {
      isCollision = !isCollision;
    }
  });
  return isCollision;
}
function polyLine(verties = [], x1, y1, x2, y2, withoutPoint = false) {
  const len2 = verties.length;
  return verties.some((vector, index2) => {
    const [x3, y3] = vector;
    const [x4, y4] = verties[(index2 + 1) % len2];
    if (withoutPoint) {
      return lineLineWithoutPoint(x1, y1, x2, y2, x3, y3, x4, y4);
    } else {
      return lineLine(x1, y1, x2, y2, x3, y3, x4, y4);
    }
  });
}
function polyPoly(verties = [], targetVerties = [], withoutPoint = false) {
  const len2 = verties.length;
  return verties.some((vector, index2) => {
    const [x1, y1] = vector;
    const [x2, y2] = verties[(index2 + 1) % len2];
    let collision = polyLine(targetVerties, x1, y1, x2, y2, withoutPoint);
    if (collision)
      return true;
    collision = polyPoint(verties, targetVerties[0][0], targetVerties[0][1], withoutPoint);
    if (collision)
      return true;
    return false;
  });
}
function rectToVerties(x, y, width2, height2, origin = "50% 50% 0px") {
  const center2 = TransformOrigin.scale(origin, width2, height2);
  return [
    [x, y, 0],
    [x + width2, y, 0],
    [x + width2, y + height2, 0],
    [x, y + height2, 0],
    [x + center2[0], y + center2[1], 0]
  ];
}
function getRotatePointer(verties, dist2 = 0) {
  const topPointer = lerp([], verties[0], verties[1], 0.5);
  const bottomPointer = lerp([], verties[2], verties[3], 0.5);
  const rotatePointer = getPointBetweenVerties(bottomPointer, topPointer, dist2);
  return rotatePointer;
}
function rectToVertiesForArea(x, y, width2, height2) {
  return rectToVerties(x, y, width2, height2);
}
function itemsToRectVerties(items = []) {
  let minX = Number.MAX_SAFE_INTEGER;
  let minY = Number.MAX_SAFE_INTEGER;
  let maxX = Number.MIN_SAFE_INTEGER;
  let maxY = Number.MIN_SAFE_INTEGER;
  const xList = [];
  const yList = [];
  items.forEach((item) => {
    item.originVerties.forEach((vector) => {
      xList.push(vector[0]);
      yList.push(vector[1]);
    });
  });
  minX = Math.min.apply(Math, xList);
  maxX = Math.max.apply(Math, xList);
  minY = Math.min.apply(Math, yList);
  maxY = Math.max.apply(Math, yList);
  if (minX === Number.MAX_SAFE_INTEGER)
    minX = 0;
  if (minY === Number.MAX_SAFE_INTEGER)
    minY = 0;
  if (maxX === Number.MIN_SAFE_INTEGER)
    maxX = 0;
  if (maxY === Number.MIN_SAFE_INTEGER)
    maxY = 0;
  return rectToVerties(minX, minY, maxX - minX, maxY - minY);
}
function targetItemsToRectVerties(items = []) {
  let minX = Number.MAX_SAFE_INTEGER;
  let minY = Number.MAX_SAFE_INTEGER;
  let maxX = Number.MIN_SAFE_INTEGER;
  let maxY = Number.MIN_SAFE_INTEGER;
  const xList = [];
  const yList = [];
  items.forEach((item) => {
    item.targetVerties.forEach((vector) => {
      xList.push(vector[0]);
      yList.push(vector[1]);
    });
  });
  minX = Math.min.apply(Math, xList);
  maxX = Math.max.apply(Math, xList);
  minY = Math.min.apply(Math, yList);
  maxY = Math.max.apply(Math, yList);
  if (minX === Number.MAX_SAFE_INTEGER)
    minX = 0;
  if (minY === Number.MAX_SAFE_INTEGER)
    minY = 0;
  if (maxX === Number.MIN_SAFE_INTEGER)
    maxX = 0;
  if (maxY === Number.MIN_SAFE_INTEGER)
    maxY = 0;
  return rectToVerties(minX, minY, maxX - minX, maxY - minY);
}
function vertiesToRectangle(verties) {
  const x = verties[0][0];
  const y = verties[0][1];
  const width2 = dist(verties[0], verties[1]);
  const height2 = dist(verties[0], verties[3]);
  return new Rect(x, y, width2, height2);
}
function vertiesToPath(verties = []) {
  const results = [];
  for (var i = 0; i < verties.length; i++) {
    if (i === 0) {
      results.push(`M ${verties[i][0]} ${verties[i][1]}`);
    } else {
      results.push(`L ${verties[i][0]} ${verties[i][1]}`);
    }
  }
  if (results.length) {
    results.push("Z");
  }
  return results.join(" ");
}
function toRectVertiesWithoutTransformOrigin(verties) {
  return toRectVerties(verties).filter((it, index2) => {
    return index2 < 4;
  });
}
function toRectVerties(verties) {
  let minX = Number.MAX_SAFE_INTEGER;
  let minY = Number.MAX_SAFE_INTEGER;
  let maxX = Number.MIN_SAFE_INTEGER;
  let maxY = Number.MIN_SAFE_INTEGER;
  const xList = [];
  const yList = [];
  verties.forEach((vector) => {
    xList.push(vector[0]);
    yList.push(vector[1]);
  });
  minX = Math.min.apply(Math, xList);
  maxX = Math.max.apply(Math, xList);
  minY = Math.min.apply(Math, yList);
  maxY = Math.max.apply(Math, yList);
  if (minX === Number.MAX_SAFE_INTEGER)
    minX = 0;
  if (minY === Number.MAX_SAFE_INTEGER)
    minY = 0;
  if (maxX === Number.MIN_SAFE_INTEGER)
    maxX = 0;
  if (maxY === Number.MIN_SAFE_INTEGER)
    maxY = 0;
  return rectToVerties(minX, minY, maxX - minX, maxY - minY);
}
const predefinedBezier = {
  linear: true,
  ease: true,
  "ease-in": true,
  "ease-out": true,
  "ease-in-out": true
};
const bezierObj = {
  ease: "cubic-bezier(0.25, 0.1, 0.25, 1)",
  "ease-in": "cubic-bezier(0.42, 0, 1, 1)",
  "ease-out": "cubic-bezier(0, 0, 0.58, 1)"
};
const bezierList = [
  [0, 0, 1, 1, "linear", true],
  [0.25, 0.1, 0.25, 1, "ease", true],
  [0.42, 0, 1, 1, "ease-in", true],
  [0, 0, 0.58, 1, "ease-out", true],
  [0.47, 0, 0.745, 0.715, "ease-in-sine"],
  [0.39, 0.575, 0.565, 1, "ease-out-sine"],
  [0.445, 0.05, 0.55, 0.95, "ease-in-out-sine"],
  [0.55, 0.085, 0.68, 0.53, "ease-in-quad"],
  [0.25, 0.46, 0.45, 0.94, "ease-out-quad"],
  [0.455, 0.03, 0.515, 0.955, "ease-in-out-quad"],
  [0.55, 0.055, 0.675, 0.19, "ease-in-cubic"],
  [0.215, 0.61, 0.355, 1, "ease-out-cubic"],
  [0.645, 0.045, 0.355, 1, "ease-in-out-cubic"],
  [0.895, 0.03, 0.685, 0.22, "ease-in-quart"],
  [0.165, 0.84, 0.44, 1, "ease-out-quart"],
  [0.77, 0, 0.175, 1, "ease-in-out-quart"],
  [0.6, 0.04, 0.98, 0.335, "ease-in-circ"],
  [0.075, 0.82, 0.165, 1, "ease-out-circ"],
  [0.785, 0.135, 0.15, 0.86, "ease-in-out-circ"],
  [0.95, 0.05, 0.795, 0.035, "ease-in-expo"],
  [0.19, 1, 0.22, 1, "ease-out-expo"],
  [1, 0, 0, 1, "ease-in-out-expo"],
  [0.755, 0.05, 0.855, 0.06, "ease-in-quint"],
  [0.23, 1, 0.32, 1, "ease-out-quint"],
  [0.86, 0, 0.07, 1, "ease-in-out-quint"],
  [0.6, -0.28, 0.735, 0.045, "ease-in-back"],
  [0.175, 0.885, 0.32, 1.275, "ease-out-back"],
  [0.68, -0.55, 0.265, 1.55, "ease-in-out-back"]
];
const getPredefinedCubicBezier = (str) => {
  return [...parseCubicBezier(bezierObj[str] || str)];
};
const formatCubicBezier = (arr) => {
  arr = arr.map((it) => Math.floor(it * 100) / 100);
  for (var i = 0, len2 = bezierList.length; i < len2; i++) {
    var bezier = bezierList[i];
    if (bezier[0] == arr[0] && bezier[1] == arr[1] && bezier[2] == arr[2] && bezier[3] == arr[3] && bezier[5]) {
      return bezier[4];
    }
  }
  return `cubic-bezier( ${arr.filter((_, index2) => index2 < 4).join(",")} )`;
};
function parseCubicBezier(str) {
  if (typeof str == "string") {
    if (predefinedBezier[str]) {
      return bezierList.filter((it) => it[4] === str)[0];
    } else {
      var arr = str.replace("cubic-bezier", "").replace("(", "").replace(")", "").split(",");
      arr = arr.map((it) => parseFloat(it.trim()));
      return arr;
    }
  }
  return str;
}
const createBezier = (C1, C2, C3, C4) => {
  var points = [C1, C2, C3, C4];
  return function(t) {
    return getBezierPointOne(points, t);
  };
};
const createBezierQuard = (C1, C2, C3) => {
  var points = [C1, C2, C3];
  return function(t) {
    return getBezierPointOneQuard(points, t);
  };
};
const createBezierLine = (C1, C2) => {
  var points = [C1, C2];
  return function(t) {
    return getBezierPointOneLine(points, t);
  };
};
const checkDist = (obj2, curve, t, x, y) => {
  var p = curve(t);
  var dist2 = getDist(x, y, p.x, p.y);
  if (dist2 < obj2.minDist) {
    obj2.minDist = dist2;
    obj2.minT = t;
  }
};
const getPolygonalDist = (points = []) => {
  let total = 0;
  points.forEach((point2, index2) => {
    var next = points[index2 + 1];
    if (!next) {
      return;
    }
    var dist$1 = dist(fromValues(point2.x, point2.y, 0), fromValues(next.x, next.y, 0));
    total += dist$1;
  });
  return total;
};
const getCurveDist = (sx, sy, cx1, cy1, cx2, cy2, ex, ey, count = 1e3) => {
  var curve = createBezier({ x: sx, y: sy }, { x: cx1, y: cy1 }, { x: cx2, y: cy2 }, { x: ex, y: ey });
  var total = 0;
  var startPoint = curve(0);
  for (var i = 0; i <= count; i++) {
    var t = i / count;
    var xy2 = curve(t);
    total += getDist(startPoint.x, startPoint.y, xy2.x, xy2.y);
    startPoint = xy2;
  }
  return total;
};
const getQuardDist = (sx, sy, cx1, cy1, ex, ey, count = 1e3) => {
  var curve = createBezierQuard({ x: sx, y: sy }, { x: cx1, y: cy1 }, { x: ex, y: ey });
  var total = 0;
  var startPoint = curve(0);
  for (var i = 0; i <= count; i++) {
    var t = i / count;
    var xy2 = curve(t);
    total += getDist(startPoint.x, startPoint.y, xy2.x, xy2.y);
    startPoint = xy2;
  }
  return total;
};
const makeCurveFunction = (curve, count = 10) => {
  var obj2 = {
    minDist: Infinity,
    minT: 0
  };
  return function(x, y) {
    for (var i = 0; i <= count; i++) {
      checkDist(obj2, curve, i / count, x, y);
    }
    var step2 = 1 / (count * 2);
    var t = obj2.minT;
    for (var i = 0; i < count; i++) {
      checkDist(obj2, curve, Math.max(0, t - step2), x, y);
      checkDist(obj2, curve, Math.min(1, t + step2), x, y);
      step2 /= 2;
    }
    return obj2.minT;
  };
};
const recoverBezier = (C1, C2, C3, C4, count = 20) => {
  return makeCurveFunction(createBezier(C1, C2, C3, C4), count);
};
const recoverBezierQuard = (C1, C2, C3, count = 20) => {
  return makeCurveFunction(createBezierQuard(C1, C2, C3), count);
};
const recoverBezierLine = (C1, C2, count = 20) => {
  return makeCurveFunction(createBezierLine(C1, C2), count);
};
const createBezierForPattern = (bezierString) => {
  if (bezierString === "linear") {
    var C1 = { x: 0, y: 0 };
    var C2 = { x: 1, y: 1 };
    return createBezierLine(C1, C2);
  }
  var bezierList2 = parseCubicBezier(bezierString);
  var C1 = { x: 0, y: 0 };
  var C2 = { x: bezierList2[0], y: bezierList2[1] };
  var C3 = { x: bezierList2[2], y: bezierList2[3] };
  var C4 = { x: 1, y: 1 };
  return createBezier(C1, C2, C3, C4);
};
const interpolate = (p1, p2, t) => {
  return {
    x: p1.x + (p2.x - p1.x) * t,
    y: p1.y + (p2.y - p1.y) * t
  };
};
const getBezierPointOne = (points, t) => {
  var p0 = interpolate(points[0], points[1], t);
  var p1 = interpolate(points[1], points[2], t);
  var p2 = interpolate(points[2], points[3], t);
  var p3 = interpolate(p0, p1, t);
  var p4 = interpolate(p1, p2, t);
  return interpolate(p3, p4, t);
};
const getBezierPointOneQuard = (points, t) => {
  var p0 = interpolate(points[0], points[1], t);
  var p1 = interpolate(points[1], points[2], t);
  return interpolate(p0, p1, t);
};
const getBezierPointOneLine = (points, t) => {
  return interpolate(points[0], points[1], t);
};
const getBezierPoints = (points, t) => {
  var p0 = interpolate(points[0], points[1], t);
  var p1 = interpolate(points[1], points[2], t);
  var p2 = interpolate(points[2], points[3], t);
  var p3 = interpolate(p0, p1, t);
  var p4 = interpolate(p1, p2, t);
  var p5 = interpolate(p3, p4, t);
  return {
    first: [points[0], p0, p3, p5],
    second: [p5, p4, p2, points[3]]
  };
};
const getBezierPointsQuard = (points, t) => {
  var p0 = interpolate(points[0], points[1], t);
  var p1 = interpolate(points[1], points[2], t);
  var p2 = interpolate(p0, p1, t);
  return {
    first: [points[0], p0, p2],
    second: [p2, p1, points[2]]
  };
};
const splitBezierPointsByCount = (points, count = 1) => {
  var result = [];
  while (count > 0) {
    const curve = getBezierPoints(points, 1 / count);
    result.push(curve.first);
    points = curve.second;
    count--;
  }
  return result;
};
const splitBezierPointsQuardByCount = (points, count = 1) => {
  var result = [];
  while (count > 0) {
    const curve = getBezierPointsQuard(points, 1 / count);
    result.push(curve.first);
    points = curve.second;
    count--;
  }
  return result;
};
const splitBezierPointsLineByCount = (points, count = 1) => {
  var result = [];
  const unit = 1 / count;
  while (count > 0) {
    const curve = getBezierPointsLine(points, unit);
    result.push(curve.first);
    points = curve.second;
    count--;
  }
  return result;
};
const getBezierPointsLine = (points, t) => {
  var p0 = interpolate(points[0], points[1], t);
  return {
    first: [points[0], p0],
    second: [p0, points[1]]
  };
};
const normalizeCurveForLine = (points) => {
  return [
    clone(points[0]),
    [
      points[0][0] + (points[1][0] - points[0][0]) * 0.33,
      points[0][1] + (points[1][1] - points[0][1]) * 0.33,
      0
    ],
    [
      points[0][0] + (points[1][0] - points[0][0]) * 0.66,
      points[0][1] + (points[1][1] - points[0][1]) * 0.66,
      0
    ],
    clone(points[1])
  ];
};
const normalizeCurveForQuard = (points) => {
  const twoOfThree = 2 / 3;
  return [
    clone(points[0]),
    fromValues(points[0][0] + twoOfThree * (points[1][0] - points[0][0]), points[0][1] + twoOfThree * (points[1][1] - points[0][1]), 0),
    fromValues(points[2][0] + twoOfThree * (points[1][0] - points[2][0]), points[2][1] + twoOfThree * (points[1][1] - points[2][1]), 0),
    clone(points[2])
  ];
};
const polygonalForCurve = (c1, c2, c3, c4, count = 1e3) => {
  const totalLength = getCurveDist(c1[0], c1[1], c2[0], c2[1], c3[0], c3[1], c4[0], c4[1], count);
  let samplingCount = 10;
  let samplingStep = totalLength / samplingCount;
  let lastLength = 0;
  let points = [];
  const bezierPoints = [c1, c2, c3, c4].map((point2) => ({
    x: point2[0],
    y: point2[1]
  }));
  do {
    points = [];
    let currentLength = 0;
    for (let i = 0; i <= samplingCount; i++) {
      const nextPoint = getBezierPointOne(bezierPoints, currentLength / totalLength);
      points.push(nextPoint);
      currentLength += samplingStep;
    }
    lastLength = getPolygonalDist(points);
    samplingCount += samplingCount * (totalLength - lastLength) / totalLength;
    samplingStep = totalLength / samplingCount;
  } while (totalLength - lastLength > 0.25);
  return points.map((point2) => fromValues(point2.x, point2.y, 0));
};
const calculateA = (points) => {
  const a1 = negate([], points[0]);
  const a2 = multiply([], [3, 3, 3], points[1]);
  const a3 = multiply([], [-3, -3, -3], points[2]);
  const a4 = points[3];
  const newP = add$1([], add$1([], a1, a2), add$1([], a3, a4));
  return multiply([], [3, 3, 3], newP);
};
const calculateB = (points) => {
  const b1 = points[0];
  const b2 = multiply([], [-2, -2, -2], points[1]);
  const b3 = points[2];
  const newP = add$1([], add$1([], b1, b2), b3);
  return multiply([], [6, 6, 6], newP);
};
const calculateC = (points) => {
  const newP = add$1([], points[1], negate([], points[0]));
  return multiply([], [3, 3, 3], newP);
};
const findRootForCurve = (points) => {
  const a = calculateA(points);
  const b = calculateB(points);
  const c2 = calculateC(points);
  const roots = [];
  const distX = b[0] * b[0] - 4 * a[0] * c2[0];
  if (distX < 0)
    ;
  else if (distX === 0) {
    let rootX = -b[0] / (2 * a[0]);
    if (isNaN(rootX))
      rootX = 0;
    if (0 <= rootX && rootX <= 1) {
      roots.push(rootX);
    }
  } else if (distX > 0) {
    const rootX1 = (-b[0] + Math.sqrt(distX)) / (2 * a[0]);
    const rootX2 = (-b[0] - Math.sqrt(distX)) / (2 * a[0]);
    if (0 <= rootX1 && rootX1 <= 1) {
      roots.push(rootX1);
    }
    if (0 <= rootX2 && rootX2 <= 1) {
      roots.push(rootX2);
    }
  }
  const distY = b[1] * b[1] - 4 * a[1] * c2[1];
  if (distY < 0)
    ;
  else if (distY === 0) {
    let rootY = -b[1] / (2 * a[1]);
    if (isNaN(rootY))
      rootY = 0;
    if (0 <= rootY && rootY <= 1) {
      roots.push(rootY);
    }
  } else if (distY > 0) {
    const rootY1 = (-b[1] + Math.sqrt(distY)) / (2 * a[1]);
    const rootY2 = (-b[1] - Math.sqrt(distY)) / (2 * a[1]);
    if (0 <= rootY1 && rootY1 <= 1) {
      roots.push(rootY1);
    }
    if (0 <= rootY2 && rootY2 <= 1) {
      roots.push(rootY2);
    }
  }
  return roots;
};
const getCurveBBox = (points) => {
  const roots = findRootForCurve(points);
  const xyPoints = points.map((p) => {
    return { x: p[0], y: p[1] };
  });
  roots.push(0, 1);
  return roots.map((t) => {
    const { x, y } = getBezierPointOne(xyPoints, t);
    return [x, y, 0];
  });
};
function randomItem(...args2) {
  return args2[randomNumber(0, args2.length - 1)];
}
function repeat(count) {
  return [...Array(count)];
}
function CSS_TO_STRING(style, postfix = "") {
  var newStyle = style || {};
  return Object.keys(newStyle).filter((key) => isNotUndefined(newStyle[key])).map((key) => `${key}: ${newStyle[key]}`).join(";" + postfix);
}
function STRING_TO_CSS(str = "", splitChar = ";", keySplitChar = ":") {
  str = str + "";
  var style = {};
  if (str === "")
    return style;
  str.split(splitChar).forEach((it) => {
    var [key, ...value] = it.split(keySplitChar).map((it2) => it2.trim());
    if (key != "") {
      style[key] = value.join(keySplitChar);
    }
  });
  return style;
}
function OBJECT_TO_PROPERTY(obj2) {
  const target = obj2 || {};
  return Object.keys(target).map((key) => {
    if (key === "class") {
      if (isObject(obj2[key])) {
        return `${key}="${classnames(obj2[key])}"`;
      }
    }
    if (key === "style") {
      if (isObject(obj2[key])) {
        return `${key}="${CSS_TO_STRING(obj2[key])}"`;
      }
    }
    if (isBoolean(obj2[key]) || isUndefined(obj2[key]) || obj2[key] === "undefined") {
      if (obj2[key]) {
        return key;
      } else {
        return "";
      }
    }
    return `${key}="${obj2[key]}"`;
  }).join(" ");
}
function TAG_TO_STRING(str) {
  return str.replace(/</g, "&lt;").replace(/>/g, "&gt;");
}
function mapjoin(arr, callback, joinString = "") {
  return arr.map(callback).join(joinString);
}
function isArrayEquals(A, B) {
  const s = /* @__PURE__ */ new Set([...A, ...B]);
  return s.size === A.length && s.size === B.length;
}
const curveToPath = (timingFunction, width2 = 30, height2 = 30) => {
  const currentBezier = getPredefinedCubicBezier(timingFunction);
  return `
        M0 ${width2} 
        C 
        ${currentBezier[0] * width2} ${currentBezier[1] == 0 ? height2 : (1 - currentBezier[1]) * height2},
        ${currentBezier[2] * width2} ${currentBezier[3] == 1 ? 0 : (1 - currentBezier[3]) * height2},
        ${width2} 0
    `;
};
const curveToPointLine = (timingFunction, width2 = 30, height2 = 30) => {
  const currentBezier = getPredefinedCubicBezier(timingFunction);
  return `
        M 0 ${width2} 
        L ${currentBezier[0] * width2} ${currentBezier[1] == 0 ? height2 : (1 - currentBezier[1]) * height2}
        M ${width2} 0
        L ${currentBezier[2] * width2} ${currentBezier[3] == 1 ? 0 : (1 - currentBezier[3]) * height2}
    `;
};
const valueFunctionIdentity = (v) => v;
const valueMap = (obj2, valueFunction = valueFunctionIdentity) => {
  const newObj = clone$1(obj2);
  Object.keys(newObj).forEach((key) => {
    newObj[key] = valueFunction(newObj[key]);
  });
  return newObj;
};
const objectFloor = (obj2) => valueMap(obj2, Math.floor);
class CubicBezierEditor extends EditorElement {
  initState() {
    return {
      key: this.props.key,
      currentBezier: getPredefinedCubicBezier(this.props.value || "linear"),
      isAnimating: isUndefined(this.props.isAnimating) ? true : Boolean(this.props.isAnimating),
      currentBezierIndex: 0,
      selectedColor: "#609de2",
      animatedColor: "#609de266",
      curveColor: "#609de2",
      baseLineColor: "rgba(117, 117, 117, 0.46)"
    };
  }
  afterRender() {
    window.setTimeout(() => {
      this.refresh();
    }, 10);
  }
  template() {
    const linearCurve = curveToPath(this.state.currentBezier, 150, 150);
    const linearCurvePoint = curveToPointLine(this.state.currentBezier, 150, 150);
    const easeCurve = curveToPath("ease", 30, 30);
    const easeCurvePoint = curveToPointLine("ease", 30, 30);
    const easeInCurve = curveToPath("ease-in", 30, 30);
    const easeInCurvePoint = curveToPointLine("ease-in", 30, 30);
    const easeOutCurve = curveToPath("ease-out", 30, 30);
    const easeOutCurvePoint = curveToPointLine("ease-out", 30, 30);
    return `
            <div class='elf--cubic-bezier-editor'>
                <div class='predefined'>
                    <div class='left' ref='$left'>${obj$2.chevron_left}</div>
                    <div class='predefined-text' ref='$text'></div>
                    <div class='right' ref='$right'>${obj$2.chevron_right}</div>
                </div>
                <div class='animation' ref='$animationArea'>
                    <canvas 
                        class='animation-canvas' 
                        ref='$animationCanvas' 
                        title='Click and Replay point animation' 
                        width='230px' 
                        height='20px'
                    ></canvas>
                </div>
                <div class='item-list' ref='$itemList' data-selected-value=''>
                    <div class='item' data-bezier='ease' title='ease'>
                        <svg class='item-canvas' width="30" height="30" viewBox="0 0 30 30">
                            <path d="${easeCurve}" stroke="white" stroke-width="1" fill='none' />
                            <path d="${easeCurvePoint}" stroke="gray" stroke-width="1" fill='none' />
                        </svg>
                    </div>
                    <div class='item' data-bezier='ease-in' title='ease-in'>
                        <svg class='item-canvas' width="30" height="30" viewBox="0 0 30 30">
                            <path d="${easeInCurve}" stroke="white" stroke-width="1" fill='none' />
                            <path d="${easeInCurvePoint}" stroke="gray" stroke-width="1" fill='none' /> 
                        </svg>
                    </div>
                    <div class='item' data-bezier='ease-out' title='ease-out'>
                        <svg class='item-canvas' width="30" height="30" viewBox="0 0 30 30">
                            <path d="${easeOutCurve}" stroke="white" stroke-width="1" fill='none' />
                            <path d="${easeOutCurvePoint}" stroke="gray" stroke-width="1" fill='none' />
                        </svg>
                    </div>
                </div>
                <div class='bezier'>
                    <svg class='bezier-canvas' width="150" height="150" viewBox="0 0 150 150" overflow="visible">
                        <path d="${linearCurve}" stroke="black" stroke-width="1" fill='none' ref='$bezierCanvas' />
                        <path d="${linearCurvePoint}" stroke="gray" stroke-width="1" fill='none' ref='$bezierCanvasPoint' />
                    </svg>                
                    <div class='control' ref='$control'>
                        <div class='pointer1' ref='$pointer1'></div>
                        <div class='pointer2' ref='$pointer2'></div>
                    </div>
                </div>
            </div>
        `;
  }
  [BIND("$animationArea")]() {
    return {
      style: {
        display: this.state.isAnimating ? "block" : "none"
      }
    };
  }
  [BIND("$bezierCanvas")]() {
    return {
      d: curveToPath(this.state.currentBezier, 150, 150)
    };
  }
  [BIND("$bezierCanvasPoint")]() {
    return {
      d: curveToPointLine(this.state.currentBezier, 150, 150)
    };
  }
  updateData(opt = {}) {
    this.setState(opt);
    this.modifyCubicBezier();
  }
  modifyCubicBezier() {
    this.parent.trigger(this.props.onchange, this.state.key, formatCubicBezier(this.state.currentBezier));
  }
  [CLICK("$left")]() {
    var { currentBezier, currentBezierIndex } = this.state;
    if (currentBezierIndex == 0) {
      currentBezierIndex = bezierList.length - 1;
    } else {
      --currentBezierIndex;
    }
    var currentBezier = bezierList[currentBezierIndex];
    this.updateData({ currentBezierIndex, currentBezier });
    this.refresh();
  }
  [CLICK("$right")]() {
    var { currentBezier, currentBezierIndex } = this.state;
    currentBezierIndex = ++currentBezierIndex % bezierList.length;
    currentBezier = bezierList[currentBezierIndex];
    this.updateData({ currentBezierIndex, currentBezier });
    this.refresh();
  }
  [CLICK("$text")]() {
    var currentBezier = [...bezierList[this.state.currentBezierIndex]];
    this.updateData({ currentBezier });
    this.refresh();
  }
  [CLICK("$itemList .item")](e) {
    var bezierString = e.$dt.attr("data-bezier");
    this.refs.$itemList.attr("data-selected-value", bezierString);
    var currentBezier = getPredefinedCubicBezier(bezierString);
    this.updateData({
      currentBezier
    });
    this.refresh();
  }
  refresh() {
    this.refreshEasingText();
    this.refreshBezierCanvas();
  }
  refreshBezierCanvas() {
    this.bindData("$bezierCanvas");
    this.bindData("$bezierCanvasPoint");
    this.refreshPointer();
    this.drawPoint();
  }
  refreshEasingText() {
    this.refs.$text.html(this.state.currentBezier[4] || "ease");
  }
  refreshPointer() {
    var currentBezier = getPredefinedCubicBezier(this.state.currentBezier);
    var width2 = this.refs.$control.width();
    var height2 = this.refs.$control.height();
    var left2 = currentBezier[0] * width2;
    var top2 = (1 - currentBezier[1]) * height2;
    this.refs.$pointer1.css({
      left: Length.px(left2),
      top: Length.px(top2)
    });
    left2 = currentBezier[2] * width2;
    top2 = (1 - currentBezier[3]) * height2;
    this.refs.$pointer2.css({
      left: Length.px(left2),
      top: Length.px(top2)
    });
  }
  drawPoint() {
    if (this.state.isAnimating === false)
      return;
    if (this.timer)
      window.clearTimeout(this.timer);
    if (this.animationTimer)
      window.clearTimeout(this.animationTimer);
    this.timer = window.setTimeout(() => {
      this.animationPoint();
    }, 100);
  }
  start(i) {
    var pos = this.animationCanvasData.func(i);
    var x = 10 + (this.animationCanvasData.width - 20) * pos.y;
    var y = 10;
    var context = this.animationCanvasData.context;
    context.beginPath();
    context.arc(x, y, 5, 0, 2 * Math.PI);
    context.fill();
    context.stroke();
    context.closePath();
    if (i >= 1) {
      return;
    }
    this.animationTimer = window.setTimeout(() => {
      this.start(i + 0.05);
    }, 50);
  }
  animationPoint() {
    const currentBezier = getPredefinedCubicBezier(this.state.currentBezier);
    var func = createBezierForPattern(formatCubicBezier(currentBezier));
    this.refs.$animationCanvas.clear();
    var width2 = this.refs.$animationCanvas.width();
    var height2 = this.refs.$animationCanvas.height();
    var context = this.refs.$animationCanvas.context();
    context.fillStyle = this.state.animatedColor;
    context.strokeStyle = this.state.selectedColor;
    context.lineWidth = 1;
    this.animationCanvasData = {
      func,
      width: width2,
      height: height2,
      context
    };
    this.start(0);
  }
  setPosition(e) {
    var width2 = this.refs.$control.width();
    var height2 = this.refs.$control.height();
    var minX = this.refs.$control.offset().left;
    var minY = this.refs.$control.offset().top;
    var p = e;
    var x = p.x;
    if (0 > x) {
      x = 0;
    } else if (p.x > document.body.clientWidth) {
      x = document.body.clientWidth;
    }
    x -= minX;
    if (x < 0) {
      x = 0;
    }
    if (width2 < x) {
      x = width2;
    }
    var y = p.y;
    y -= minY;
    return {
      x: div(x, width2),
      y: y == height2 ? 0 : div(height2 - y, height2)
    };
  }
  [POINTERSTART("$pointer1") + MOVE("movePointer1") + END("drawPoint")](e) {
    this.clientX = e.clientX;
    this.clientY = e.clientY;
  }
  movePointer1(dx, dy) {
    var pos = this.setPosition({
      x: this.clientX + dx,
      y: this.clientY + dy
    });
    this.state.currentBezier[0] = pos.x;
    this.state.currentBezier[1] = pos.y;
    this.refreshBezierCanvas();
    this.modifyCubicBezier();
  }
  [POINTERSTART("$pointer2") + MOVE("movePointer2") + END("drawPoint")](e) {
    this.clientX = e.clientX;
    this.clientY = e.clientY;
  }
  movePointer2(dx, dy) {
    var pos = this.setPosition({
      x: this.clientX + dx,
      y: this.clientY + dy
    });
    this.state.currentBezier[2] = pos.x;
    this.state.currentBezier[3] = pos.y;
    this.refreshBezierCanvas();
    this.modifyCubicBezier();
  }
  [SUBSCRIBE("showCubicBezierEditor")](timingFunction) {
    var currentBezier = getPredefinedCubicBezier(timingFunction || this.state.currentBezier);
    this.setState({ currentBezier });
    this.refresh();
  }
}
var DirectionEditor$1 = "";
class DirectionLength {
  static parse(str) {
    var temp = str.split(" ").filter((it) => it.trim()).map((it) => Length.parse(it));
    var top2 = Length.percent(0), right2 = Length.percent(0), bottom2 = Length.percent(0), left2 = Length.percent(0);
    if (temp.length === 1) {
      top2 = temp[0].clone();
      right2 = temp[0].clone();
      bottom2 = temp[0].clone();
      left2 = temp[0].clone();
    } else if (temp.length === 2) {
      top2 = temp[0].clone();
      right2 = temp[1].clone();
      bottom2 = temp[0].clone();
      left2 = temp[1].clone();
    } else if (temp.length === 3) {
      top2 = temp[0].clone();
      right2 = temp[1].clone();
      bottom2 = temp[2].clone();
      left2 = temp[1].clone();
    } else if (temp.length === 4) {
      top2 = temp[0].clone();
      right2 = temp[1].clone();
      bottom2 = temp[2].clone();
      left2 = temp[3].clone();
    }
    return [temp.length, top2, right2, bottom2, left2];
  }
}
const typeList$2 = [
  { key: "top", title: "Top" },
  { key: "right", title: "Right" },
  { key: "bottom", title: "Bottom" },
  { key: "left", title: "Left" }
];
class DirectionEditor extends EditorElement {
  initState() {
    var [count, top2, right2, bottom2, left2] = DirectionLength.parse(this.props.value);
    return {
      isAll: count === 1,
      all: top2.clone(),
      top: top2.clone(),
      right: right2.clone(),
      bottom: bottom2.clone(),
      left: left2.clone()
    };
  }
  template() {
    return `<div class='elf--direction-editor' ref='$body'></div>`;
  }
  [SUBSCRIBE("changeBorderRadius")](key, value) {
    if (key === "all") {
      typeList$2.forEach((it) => {
        this.state[it.key] = value.clone();
        this.children[`$${it.key}`].setValue(value.clone());
      });
    }
    this.updateData({
      [key]: value
    });
  }
  [LOAD("$body")]() {
    var selectedValue = this.state.isAll ? "all" : "partitial";
    var direction2 = this.state.all;
    var display = selectedValue === "all" ? "display:none" : "display:block";
    return `
      <div class="property-item direction-item">
        <div class="radius-selector" data-selected-value="${selectedValue}" ref="$selector">
          <button type="button" data-value="all">${obj$2.border_all}</button>
          <button type="button" data-value="partitial">
            ${obj$2.border_inner}
          </button>
        </div>
        <div class="radius-value">
          ${createComponent("RangeEditor", {
      ref: "$all",
      key: "all",
      value: direction2,
      onchange: "changeBorderRadius"
    })}
        </div>
      </div>
      <div
        class="property-item full direction-item"
        ref="$partitialSetting"
        style="${display}"
      >
        <div class="radius-setting-box">
          ${typeList$2.map((it) => {
      var value = this.state[it.key];
      return `
              <div>
                  ${createComponent("RangeEditor", {
        ref: `$${it.key}`,
        label: it.title,
        key: it.key,
        value,
        onchange: "changeBorderRadius"
      })}
              </div>  
            `;
    }).join("")}
        </div>
      </div>
    `;
  }
  updateData(opt = {}) {
    this.setState(opt, false);
    var value = [];
    if (this.state.isAll) {
      value = [
        1,
        this.state.all,
        this.state.all,
        this.state.all,
        this.state.all
      ];
    } else {
      value = [
        4,
        this.state.top,
        this.state.right,
        this.state.bottom,
        this.state.left
      ];
    }
    this.parent.trigger(this.props.onchange, value);
  }
  [CLICK("$selector button")](e) {
    var type = e.$dt.attr("data-value");
    this.refs.$selector.attr("data-selected-value", type);
    if (type === "all") {
      this.refs.$partitialSetting.hide();
    } else {
      this.refs.$partitialSetting.show("grid");
    }
    this.updateData({
      isAll: type === "all"
    });
  }
}
var FilterEditor$1 = "";
const identity$2 = () => true;
function _traverse(obj2, filterCallback = identity$2) {
  var results = [];
  let len2 = obj2.layers.length;
  for (let start2 = len2; start2--; ) {
    let it = obj2.layers[start2];
    results.push(..._traverse(it.ref, filterCallback));
  }
  if (filterCallback(obj2)) {
    results.push(obj2);
  }
  return results;
}
class Item {
  constructor(json = {}) {
    this.ref = new Proxy(this, {
      get: (target, key) => {
        var originMethod = target[key];
        if (isFunction(originMethod)) {
          return (...args2) => {
            return originMethod.apply(target, args2);
          };
        } else {
          return originMethod || target.json[key];
        }
      },
      set: (target, key, value) => {
        const isDiff = target.json[key] != value;
        if (isDiff) {
          target.json[key] = value;
          this.changed();
        }
        return true;
      }
    });
    if (json instanceof Item) {
      json = json.toJSON();
    }
    this.json = this.convert(Object.assign(this.getDefaultObject(), json));
    this.lastChangedField = {};
    this.lastChangedFieldKeys = [];
    this.cachedValue = {};
    return this.ref;
  }
  getDefaultTitle() {
    return "Item";
  }
  getIcon() {
    return "";
  }
  isAttribute() {
    return false;
  }
  isChanged(timestamp) {
    return this.json.timestamp != Number(timestamp);
  }
  changed() {
    this.json.timestamp = this.json._timestamp + window.performance.now();
  }
  get title() {
    return this.json.name || this.getDefaultTitle();
  }
  renameWithCount() {
    let arr = this.json.name.split(" ");
    if (arr.length < 2) {
      return;
    }
    let last = arr.pop();
    let lastNumber = +last;
    if (isNumber(lastNumber) && isNaN(lastNumber) === false) {
      lastNumber++;
    } else {
      lastNumber = last;
    }
    const nextName = [...arr, lastNumber].join(" ");
    this.reset({
      name: nextName
    });
  }
  get allLayers() {
    return _traverse(this.ref);
  }
  filteredAllLayers(filterCallback) {
    return _traverse(this.ref, filterCallback);
  }
  get id() {
    return this.json.id;
  }
  get layers() {
    return this.json.layers;
  }
  get parent() {
    return this.json.parent;
  }
  setParent(otherParent) {
    this.json.parent = otherParent;
  }
  get depth() {
    if (!this.parent)
      return 1;
    return this.parent.depth + 1;
  }
  get top() {
    if (!this.parent)
      return this.ref;
    let localParent = this.parent;
    do {
      if (!localParent.parent) {
        return localParent;
      }
      localParent = localParent.parent;
    } while (localParent);
  }
  get project() {
    return this.path.find((it) => it.is("project"));
  }
  get artboard() {
    return this.path.find((it) => it.is("artboard"));
  }
  get path() {
    if (!this.parent)
      return [this.ref];
    const list2 = this.parent.path;
    list2.push(this.ref);
    return list2;
  }
  getInnerId(postfix = "") {
    return this.json.id + postfix;
  }
  is(checkItemType) {
    if (!this.json)
      return false;
    return checkItemType === this.json.itemType;
  }
  isNot(checkItemType) {
    return this.is(checkItemType) === false;
  }
  isSVG() {
    return false;
  }
  addCache(key, value) {
    this.cachedValue[key] = value;
  }
  getCache(key) {
    return this.cachedValue[key];
  }
  computed(key, newValueCallback) {
    const cachedKey = `__cachedKey_${key}`;
    const parsedKey = `${cachedKey}__parseValue`;
    const value = this.json[key];
    if (this.getCache(key) === value && this.getCache(parsedKey)) {
      return this.getCache(parsedKey);
    }
    this.addCache(key, value);
    this.addCache(parsedKey, newValueCallback(value, this.ref));
    return this.getCache(parsedKey);
  }
  editable() {
    return true;
  }
  generateListNumber() {
    this.layers.forEach((it, index2) => {
      it.no = index2;
      it.generateListNumber();
    });
  }
  convert(json) {
    if (json.layers) {
      json.layers.forEach((layer) => {
        layer.parent = this.ref;
      });
    }
    return json;
  }
  setCache() {
  }
  toCloneObject(isDeep = true) {
    var json = this.attrs("itemType", "name", "elementType", "type", "visible", "lock", "selected");
    if (isDeep) {
      json.layers = this.json.layers.map((layer) => layer.clone(isDeep));
    }
    return json;
  }
  clone(isDeep = true) {
    var ItemClass = this.constructor;
    var item = new ItemClass(this.toCloneObject(isDeep));
    item.setParent(this.json.parent);
    return item;
  }
  reset(obj2) {
    if (!obj2.__changedId)
      obj2.__changedId = uuid();
    if (this.lastChangedField.__changedId !== obj2.__changedId) {
      this.json = this.convert(Object.assign(this.json, obj2));
      this.lastChangedField = obj2;
      this.lastChangedFieldKeys = Object.keys(obj2);
      this.changed();
    }
    return true;
  }
  hasChangedField(...args2) {
    return args2.some((it) => this.lastChangedFieldKeys.includes(it));
  }
  getDefaultObject(obj2 = {}) {
    var id = uuidShort();
    return __spreadValues({
      id,
      _timestamp: Date.now(),
      _time: window.performance.now(),
      visible: true,
      lock: false,
      selected: false,
      layers: []
    }, obj2);
  }
  attrs(...args2) {
    const result = {};
    args2.forEach((field) => {
      result[field] = clone$1(this.json[field]);
    });
    return result;
  }
  hasChildren() {
    return this.layers.length > 0;
  }
  appendChild(layer) {
    if (layer.parent === this.ref) {
      return layer;
    }
    this.resetMatrix(layer);
    if (layer.parent) {
      layer.remove();
    }
    layer.setParent(this.ref);
    this.json.layers.push(layer);
    this.project.addIndexItem(layer);
    return layer;
  }
  prependChildItem(layer) {
    this.resetMatrix(layer);
    if (layer.parent) {
      layer.remove();
    }
    layer.setParent(this.ref);
    this.json.layers.unshift(layer);
    this.project.addIndexItem(layer);
    return layer;
  }
  resetMatrix() {
  }
  refreshMatrixCache() {
  }
  insertChild(layer, index2 = 0) {
    this.resetMatrix(layer);
    if (layer.parent) {
      layer.remove();
    }
    layer.setParent(this.ref);
    this.json.layers.splice(index2, 0, layer);
    this.project.addIndexItem(layer);
    return layer;
  }
  insertAfter(layer) {
    const index2 = this.parent.findIndex(this);
    this.parent.insertChild(layer, index2);
    this.project.addIndexItem(layer);
    return layer;
  }
  insertBefore(layer) {
    const index2 = this.parent.findIndex(this);
    this.parent.insertChild(layer, index2 - 1);
    this.project.addIndexItem(layer);
    return layer;
  }
  setPositionInPlace(position2, item) {
    this.layers.splice(position2, 0, item);
  }
  toggle(field, toggleValue) {
    if (isUndefined(toggleValue)) {
      this.json[field] = !this.json[field];
    } else {
      this.json[field] = !!toggleValue;
    }
  }
  isTreeItemHide() {
    let currentParent = this.parent;
    let collapsedList = [];
    do {
      if (currentParent.is("project"))
        break;
      collapsedList.push(Boolean(currentParent.collapsed));
      currentParent = currentParent.parent;
    } while (currentParent);
    return Boolean(collapsedList.filter(Boolean).length);
  }
  expectJSON(key) {
    if (key === "parent")
      return false;
    if (isUndefined(this.json[key]))
      return false;
    return true;
  }
  toJSON() {
    const json = this.json;
    let newJSON = {};
    Object.keys(json).filter((key) => this.expectJSON(key)).forEach((key) => {
      newJSON[key] = json[key];
    });
    return newJSON;
  }
  resize() {
  }
  copy(dist2 = 0) {
    return this.json.parent.copyItem(this.ref, dist2);
  }
  findIndex(item) {
    return this.json.layers.indexOf(item.ref);
  }
  copyItem(childItem, dist2 = 10) {
    var child = childItem.clone();
    child.renameWithCount();
    child.move([dist2, dist2, 0]);
    var childIndex = this.findIndex(childItem);
    if (childIndex > -1) {
      this.json.layers.push(child);
      this.project.addIndexItem(child);
    }
    return child;
  }
  remove() {
    this.json.parent.removeChild(this.ref);
    this.project.removeIndexItem(this.ref);
  }
  removeChild(childItem) {
    const index2 = this.findIndex(childItem);
    if (index2 > -1) {
      this.json.layers.splice(index2, 1);
    }
  }
  hasParent(parentId) {
    var isParent = this.json.parent.id === parentId;
    if (!isParent && this.json.parent.is("project") === false)
      return this.json.parent.hasParent(parentId);
    return isParent;
  }
}
class PropertyItem extends Item {
  getDefaultObject(obj2 = {}) {
    return __spreadValues({
      selected: false,
      layers: []
    }, obj2);
  }
  isAttribute() {
    return true;
  }
  toCSS() {
    return {};
  }
  toString() {
    return CSS_TO_STRING(this.toCSS());
  }
}
const FILTER_REG = /((blur|grayscale|drop-shadow|hue-rotate|invert|brightness|contrast|opacity|saturate|sepia|url)\(([^)]*)\))/gi;
class Filter extends PropertyItem {
  getDefaultObject(obj2 = {}) {
    return super.getDefaultObject(__spreadValues({
      itemType: "filter"
    }, obj2));
  }
  toString() {
    return `${this.json.type}(${this.json.value || ""})`;
  }
  static parse(obj2) {
    var FilterClass = FilterClassName[obj2.type];
    if (FilterClass) {
      return new FilterClass(obj2);
    } else {
      return new URLSvgFilter({
        value: obj2.value
      });
    }
  }
  static parseStyle(filter2) {
    var filters = [];
    if (!filter2)
      return filters;
    var results = convertMatches(filter2);
    var matches2 = results.str.match(FILTER_REG) || [];
    matches2.forEach((value, index2) => {
      var [filterName, filterValue] = value.split("(");
      filterValue = filterValue.split(")")[0];
      if (filterName === "drop-shadow") {
        var arr = filterValue.split(" ");
        var colors2 = arr.filter((it) => it.includes("@")).map((it) => {
          return reverseMatches(it, results.matches);
        });
        var values = arr.filter((it) => !it.includes("@"));
        filters[index2] = Filter.parse({
          type: filterName,
          offsetX: Length.parse(values[0]),
          offsetY: Length.parse(values[1]),
          blurRadius: Length.parse(values[2]),
          color: colors2[0] || "rgba(0, 0, 0, 1)"
        });
      } else {
        filters[index2] = Filter.parse({
          type: filterName,
          value: Length.parse(filterValue)
        });
      }
    });
    return filters;
  }
  static join(list2) {
    return list2.map((it) => Filter.parse(it)).join(" ");
  }
  toJSON() {
    return {
      type: this.json.type,
      value: this.json.value
    };
  }
}
class BlurFilter extends Filter {
  getDefaultObject() {
    return super.getDefaultObject({
      type: "blur",
      value: BlurFilter.spec.defaultValue
    });
  }
  toCloneObject() {
    return __spreadValues(__spreadValues({}, super.toCloneObject()), this.attrs("value"));
  }
}
BlurFilter.spec = {
  inputType: "range",
  min: 0,
  max: 100,
  step: 1,
  unit: "px",
  units: ["px", "em"],
  defaultValue: "0px"
};
class URLSvgFilter extends Filter {
  getDefaultObject() {
    return super.getDefaultObject({
      type: "svg",
      value: URLSvgFilter.spec.defaultValue
    });
  }
  toCloneObject() {
    return __spreadValues(__spreadValues({}, super.toCloneObject()), this.attrs("value"));
  }
  toString() {
    return `url(#${this.json.value || ""})`;
  }
}
URLSvgFilter.spec = {
  inputType: "select",
  defaultValue: ""
};
class GrayscaleFilter extends Filter {
  getDefaultObject() {
    return super.getDefaultObject({
      type: "grayscale",
      value: GrayscaleFilter.spec.defaultValue
    });
  }
  toCloneObject() {
    return __spreadValues(__spreadValues({}, super.toCloneObject()), this.attrs("value"));
  }
}
GrayscaleFilter.spec = {
  inputType: "range",
  min: 0,
  max: 100,
  step: 1,
  unit: "%",
  units: ["%"],
  defaultValue: Length.percent(0)
};
class HueRotateFilter extends Filter {
  getDefaultObject() {
    return super.getDefaultObject({
      type: "hue-rotate",
      value: HueRotateFilter.spec.defaultValue
    });
  }
}
HueRotateFilter.spec = {
  inputType: "range",
  min: 0,
  max: 360,
  step: 1,
  unit: "deg",
  units: ["deg"],
  defaultValue: Length.deg(0)
};
class InvertFilter extends Filter {
  getDefaultObject() {
    return super.getDefaultObject({
      type: "invert",
      value: InvertFilter.spec.defaultValue
    });
  }
}
InvertFilter.spec = {
  inputType: "range",
  min: 0,
  max: 100,
  step: 1,
  unit: "%",
  units: ["%"],
  defaultValue: Length.percent(0)
};
class BrightnessFilter extends Filter {
  getDefaultObject() {
    return super.getDefaultObject({
      type: "brightness",
      value: BrightnessFilter.spec.defaultValue
    });
  }
}
BrightnessFilter.spec = {
  inputType: "range",
  min: 0,
  max: 200,
  step: 1,
  unit: "%",
  units: ["%"],
  defaultValue: Length.percent(100)
};
class ContrastFilter extends Filter {
  getDefaultObject() {
    return super.getDefaultObject({
      type: "contrast",
      value: ContrastFilter.spec.defaultValue
    });
  }
}
ContrastFilter.spec = {
  inputType: "range",
  min: 0,
  max: 200,
  step: 1,
  unit: "%",
  units: ["%"],
  defaultValue: Length.percent(100)
};
class OpacityFilter extends Filter {
  getDefaultObject() {
    return super.getDefaultObject({
      type: "opacity",
      value: OpacityFilter.spec.defaultValue
    });
  }
}
OpacityFilter.spec = {
  inputType: "range",
  min: 0,
  max: 100,
  step: 1,
  unit: "%",
  units: ["%"],
  defaultValue: Length.percent(100)
};
class SaturateFilter extends Filter {
  getDefaultObject() {
    return super.getDefaultObject({
      type: "saturate",
      value: SaturateFilter.spec.defaultValue
    });
  }
}
SaturateFilter.spec = {
  inputType: "range",
  min: 0,
  max: 100,
  step: 1,
  unit: "%",
  units: ["%"],
  defaultValue: Length.percent(100)
};
class SepiaFilter extends Filter {
  getDefaultObject() {
    return super.getDefaultObject({
      type: "sepia",
      value: SepiaFilter.spec.defaultValue
    });
  }
}
SepiaFilter.spec = {
  inputType: "range",
  min: 0,
  max: 100,
  step: 1,
  unit: "%",
  units: ["%"],
  defaultValue: Length.percent(0)
};
class DropshadowFilter extends Filter {
  getDefaultObject() {
    return super.getDefaultObject({
      type: "drop-shadow",
      multi: true,
      offsetX: DropshadowFilter.spec.offsetX.defaultValue,
      offsetY: DropshadowFilter.spec.offsetY.defaultValue,
      blurRadius: DropshadowFilter.spec.blurRadius.defaultValue,
      color: DropshadowFilter.spec.color.defaultValue
    });
  }
  toString() {
    var json = this.json;
    return `drop-shadow(${json.offsetX} ${json.offsetY} ${json.blurRadius} ${json.color})`;
  }
  toJSON() {
    return {
      type: this.json.type,
      offsetX: this.json.offsetX,
      offsetY: this.json.offsetY,
      blurRadius: this.json.blurRadius,
      color: this.json.color
    };
  }
}
DropshadowFilter.spec = {
  offsetX: {
    title: "Offset X",
    inputType: "range",
    min: -100,
    max: 100,
    step: 1,
    defaultValue: "0px",
    unit: "px",
    units: ["px", "em"]
  },
  offsetY: {
    title: "Offset Y",
    inputType: "range",
    min: -100,
    max: 100,
    step: 1,
    defaultValue: "0px",
    unit: "px",
    units: ["px", "em"]
  },
  blurRadius: {
    title: "Blur Radius",
    inputType: "range",
    min: 0,
    max: 100,
    step: 1,
    defaultValue: "0px",
    unit: "px",
    units: ["px", "em", "%"]
  },
  color: {
    title: "Color",
    inputType: "color",
    defaultValue: "rgba(0, 0, 0, 1)",
    unit: "color"
  }
};
const FilterClassName = {
  blur: BlurFilter,
  grayscale: GrayscaleFilter,
  "hue-rotate": HueRotateFilter,
  invert: InvertFilter,
  brightness: BrightnessFilter,
  contrast: ContrastFilter,
  opacity: OpacityFilter,
  saturate: SaturateFilter,
  sepia: SepiaFilter,
  "drop-shadow": DropshadowFilter,
  svg: URLSvgFilter
};
const filter_list$2 = [
  "blur",
  "grayscale",
  "hue-rotate",
  "invert",
  "brightness",
  "contrast",
  "drop-shadow",
  "opacity",
  "saturate",
  "sepia",
  "svg"
];
var specList = {
  blur: BlurFilter.spec,
  grayscale: GrayscaleFilter.spec,
  "hue-rotate": HueRotateFilter.spec,
  invert: InvertFilter.spec,
  brightness: BrightnessFilter.spec,
  contrast: ContrastFilter.spec,
  "drop-shadow": DropshadowFilter.spec,
  opacity: OpacityFilter.spec,
  saturate: SaturateFilter.spec,
  sepia: SepiaFilter.spec,
  svg: URLSvgFilter.spec
};
class FilterEditor extends EditorElement {
  initState() {
    return {
      hideLabel: this.props.hideLabel === "true" ? true : false,
      filters: this.props.value || []
    };
  }
  template() {
    return `
      <div class='elf--filter-editor filter-list'>
          <div class='filter-list' ref='$filterList'></div>
      </div>`;
  }
  [LOAD("$filterSelect")]() {
    var list2 = filter_list$2.map((it) => {
      return { title: it, value: it };
    });
    var svgFilterList = this.getSVGFilterList();
    var totalList = [];
    if (svgFilterList.length) {
      totalList = [...list2, { title: "-------", value: "" }, ...svgFilterList];
    } else {
      totalList = [...list2];
    }
    return totalList.map((it) => {
      var { title: title2, value } = it;
      return `<option value='${value}'>${title2}</option>`;
    });
  }
  getSpec(filterType) {
    return specList[filterType];
  }
  makeDropShadowFilterTemplate(spec, filter2, index2) {
    return `
      <div class="filter-item">
        <div class="title drop-shadow">
          <label draggable="true"  data-index="${index2}">${iconUse("drag_indicator")}</label>
          <span class='sub-title'>${this.$i18n("filter.property.drop-shadow")}</span>
          <div class="filter-menu">
            <button type="button" class="del" data-index="${index2}">${iconUse("remove2")}</button>
          </div>
        </div>
        <div class="filter-ui-list">
          ${createComponentList([
      "ColorViewEditor",
      {
        ref: `$dropShadowColorView${index2}`,
        params: index2,
        compact: true,
        value: filter2.color,
        onchange: "changeDropShadowColor"
      }
    ], ...["offsetX", "offsetY", "blurRadius"].map((key) => {
      return [
        "InputRangeEditor",
        {
          ref: `$${key}${index2}`,
          label: this.$i18n(`filter.property.drop-shadow.${key}`),
          key: index2,
          min: spec[key].min,
          max: spec[key].max,
          step: spec[key].step,
          params: key,
          value: filter2[key].value || spec[key].defaultValue,
          units: spec[key].units,
          onchange: "changeRangeEditor"
        }
      ];
    }))}
        </div>

      </div>
    `;
  }
  getSVGFilterList() {
    var current = this.$context.selection.current;
    var arr = [];
    if (current) {
      arr = current.svgfilters.map((it) => {
        return {
          title: `svg - #${it.id}`,
          value: it.id
        };
      });
    }
    return arr;
  }
  makeOneFilterEditor(index2, filter2, spec) {
    if (filter2.type === "svg") {
      var options2 = "";
      var current = this.$context.selection.current;
      if (current) {
        options2 = current.svgfilters.map((it) => {
          return { value: it.id };
        });
      }
      return createComponent("SelectEditor", {
        ref: `$select${index2}`,
        key: index2,
        label: "SVG Filter",
        value: filter2.value,
        options: ["", ...options2],
        onchange: "changeRangeEditor"
      });
    }
    return createComponent("InputRangeEditor", {
      ref: `$range${index2}_${filter2.type}`,
      label: this.$i18n("filter.property." + filter2.type),
      key: index2,
      min: spec.min,
      max: spec.max,
      value: filter2.value,
      units: spec.units,
      onchange: "changeRangeEditor"
    });
  }
  makeOneFilterTemplate(spec, filter2, index2) {
    return `
      <div class="filter-item" data-index="${index2}">
        <div class="title" >
          <label draggable="true" data-index="${index2}">${iconUse("drag_indicator")}</label>
          ${filter2.type != "svg" ? `
          <div class="filter-ui">
            ${this.makeOneFilterEditor(index2, filter2, spec)}
          </div>
        ` : `
          <div>
            <span class='svg-filter-edit' data-index="${index2}">${filter2.value}</span>
          </div>
        `}          
          <div class="filter-menu">
            <button type="button" class="del" data-index="${index2}">
              ${iconUse("remove2")}
            </button>
          </div>
        </div>
      </div>
    `;
  }
  makeFilterTemplate(filter2, index2) {
    if (filter2.type === "drop-shadow") {
      return this.makeDropShadowFilterTemplate(this.getSpec(filter2.type), filter2, index2);
    } else {
      return this.makeOneFilterTemplate(this.getSpec(filter2.type), filter2, index2);
    }
  }
  [LOAD("$filterList")]() {
    return this.state.filters.map((filter2, index2) => {
      return this.makeFilterTemplate(filter2, index2.toString());
    });
  }
  [DRAGSTART("$filterList .filter-item > .title > label")](e) {
    this.startIndex = +e.$dt.attr("data-index");
  }
  [DRAGOVER("$filterList .filter-item > .title > label") + PREVENT]() {
  }
  sortItem(arr, startIndex, targetIndex) {
    arr.splice(targetIndex + (startIndex < targetIndex ? -1 : 0), 0, ...arr.splice(startIndex, 1));
  }
  sortFilter(startIndex, targetIndex) {
    this.sortItem(this.state.filters, startIndex, targetIndex);
  }
  [DROP("$filterList .filter-item") + PREVENT](e) {
    var targetIndex = +e.$dt.attr("data-index");
    var current = this.$context.selection.current;
    if (!current)
      return;
    this.sortFilter(this.startIndex, targetIndex);
    this.refresh();
    this.modifyFilter();
  }
  modifyFilter() {
    var value = this.state.filters;
    this.parent.trigger(this.props.onchange, this.props.key, value, this.props.params);
  }
  makeFilter(type, opt = {}) {
    return Filter.parse(__spreadProps(__spreadValues({}, opt), { type }));
  }
  [CLICK("$filterList .svg-filter-edit")](e) {
    var _a, _b;
    var index2 = +e.$dt.attr("data-index");
    var filter2 = this.state.filters[index2];
    var current = this.$context.selection.current;
    if (current) {
      var svgfilterIndex = current.getSVGFilterIndex((_b = (_a = filter2.value) == null ? void 0 : _a.value) == null ? void 0 : _b.replace("#", ""));
      this.trigger("openSVGFilterPopup", svgfilterIndex);
    }
  }
  [SUBSCRIBE("openSVGFilterPopup")](index2) {
    const current = this.$context.selection.current || { svgfilters: [] };
    const svgfilter = current.svgfilters[index2];
    this.emit("showSVGFilterPopup", {
      changeEvent: (params) => {
        var current2 = this.$context.selection.current;
        if (current2) {
          current2.setSVGFilterValue(params.index, {
            filters: params.filters
          });
          this.$commands.executeCommand("setAttribute", "change filter", this.$context.selection.pack("svgfilters", "filter"));
        }
      },
      index: index2,
      preview: false,
      filters: svgfilter.filters
    });
  }
  [SUBSCRIBE_SELF("add")](filterType) {
    if (filterType === "svg") {
      const index2 = this.$context.selection.current.createSVGFilter({
        filters: []
      });
      const filter2 = this.$context.selection.current.svgfilters[index2];
      this.state.filters.push(this.makeFilter(filterType, {
        value: filter2.id
      }));
      this.refresh();
      this.modifyFilter();
      this.trigger("openSVGFilterPopup", index2);
    } else {
      this.state.filters.push(this.makeFilter(filterType));
      this.refresh();
      this.modifyFilter();
    }
  }
  [CLICK("$add")]() {
    var filterType = this.refs.$filterSelect.value;
    this.trigger("add", filterType);
  }
  [CLICK("$filterList .filter-menu .del")](e) {
    var index2 = +e.$dt.attr("data-index");
    this.state.filters.splice(index2, 1);
    this.refresh();
    this.modifyFilter();
  }
  [SUBSCRIBE_SELF("changeDropShadowColor")](key, color2, params) {
    var index2 = +params;
    this.state.filters[index2].color = color2;
    this.modifyFilter();
  }
  [SUBSCRIBE_SELF("changeRangeEditor")](key, value, params) {
    if (params) {
      this.state.filters[+key][params] = value;
    } else {
      this.state.filters[+key].value = value;
    }
    this.modifyFilter();
  }
}
const font_list = [
  "",
  "Arial",
  "Arial Black",
  "Times New Roman",
  "Times",
  "Courier New",
  "Courier",
  "Verdana",
  "Georgia",
  "Palatino",
  "Garamond",
  "Bookman",
  "Tahoma",
  "Trebuchet MS",
  "Impact",
  "Comic Sans MS",
  "serif",
  "sans-serif",
  "monospace",
  "cursive",
  "fantasy",
  "system-ui"
];
class FontSelectEditor extends SelectEditor {
  getFontList() {
    return font_list.map((it) => {
      return { value: it };
    });
  }
  initState() {
    return __spreadProps(__spreadValues({}, super.initState()), {
      options: this.getFontList()
    });
  }
}
var GradientEditor$1 = "";
const CSS_FUNC_REGEXP = /(([-]?[\d.]+)(px|pt|fr|r?em|deg|vh|vw|m?s|%|g?rad|turn)?)|#(?:[\da-f]{8})|(#(?:[\da-f]{3}){1,2}|([a-z_-]+)\([^()]+\)|([a-z_-]+))|(,)/gi;
const CSS_LENGTH_REGEXP = /^[-]?([\d.]+)(px|pt|fr|r?em|deg|vh|vw|m?s|%|g?rad|turn)?$/gi;
const CSS_KEYWORD_REGEXP = /^[a-z_-]+$/gi;
const GRADIENT_LIST = [
  GradientType.STATIC,
  GradientType.LINEAR,
  GradientType.RADIAL,
  GradientType.CONIC,
  GradientType.REPEATING_CONIC,
  GradientType.REPEATING_LINEAR,
  GradientType.REPEATING_RADIAL
];
const TIMIING_LIST = [
  TimingFunction.LINEAR,
  TimingFunction.EASE,
  TimingFunction.EASE_IN,
  TimingFunction.EASE_OUT,
  TimingFunction.EASE_IN_OUT
];
const CSS_FUNC_MATCHES = (str) => {
  if (str === ",") {
    return "comma";
  } else if (str.indexOf("#") === 0) {
    return "hex";
  } else if (ColorNames.isColorName(str)) {
    return "color";
  } else if (GRADIENT_LIST.includes(str) || TIMIING_LIST.includes(str)) {
    return str;
  } else if (str.match(CSS_LENGTH_REGEXP)) {
    return "length";
  } else if (str.match(CSS_KEYWORD_REGEXP)) {
    return "keyword";
  }
};
const findFunctionEndIndex = (allString, startIndex, funcStartCharacter = "(", funcEndCharacter = ")") => {
  const result = [];
  for (var i = startIndex; i < allString.length; i++) {
    const it = allString[i];
    if (it === funcStartCharacter) {
      result.push(funcStartCharacter);
    } else if (it === funcEndCharacter) {
      result.pop();
      if (result.length === 0) {
        break;
      }
    }
  }
  if (result.length > 0) {
    return -1;
  }
  return i + 1;
};
const makeFuncType = (type) => {
  if (GRADIENT_LIST.includes(type)) {
    return FuncType.GRADIENT;
  } else if (TIMIING_LIST.includes(type)) {
    return FuncType.TIMING;
  } else if (type === "color") {
    return FuncType.COLOR;
  } else if (type === "hex") {
    return FuncType.COLOR;
  } else if (type === "length") {
    return FuncType.LENGTH;
  } else if (type === "comma") {
    return FuncType.COMMA;
  }
  return type;
};
const makeGroupFunction = (type) => (item, allString, funcStartCharacter = "(", funcEndCharacter = ")") => {
  const lastIndex = findFunctionEndIndex(allString, item.startIndex, funcStartCharacter, funcEndCharacter);
  if (lastIndex === -1) {
    return {
      convert: true,
      funcType: makeFuncType(type),
      matchedString: allString,
      type,
      startIndex: item.startIndex,
      endIndex: item.startIndex + allString.length
    };
  }
  const matchedString = allString.substring(item.startIndex, lastIndex);
  const matchedStringIndex = matchedString.indexOf(funcStartCharacter) + funcStartCharacter.length;
  const args2 = allString.substring(item.startIndex + matchedStringIndex, item.startIndex + matchedString.lastIndexOf(funcEndCharacter));
  const startIndex = item.startIndex;
  const endIndex = item.startIndex + matchedString.length;
  const newParsed = parseValue(args2).map((it) => {
    return __spreadProps(__spreadValues({}, it), {
      fullTextStartIndex: item.startIndex + matchedStringIndex + it.startIndex,
      fullTextEndIndex: item.startIndex + matchedStringIndex + it.endIndex
    });
  });
  let parameters = [];
  let commaIndex = 0;
  newParsed.forEach((it) => {
    if (it.func === FuncType.COMMA) {
      commaIndex++;
    } else {
      if (!parameters[commaIndex])
        parameters[commaIndex] = [];
      parameters[commaIndex].push(it);
    }
  });
  return {
    convert: true,
    funcType: makeFuncType(type),
    type,
    startIndex,
    endIndex,
    matchedString,
    args: args2,
    parameters
  };
};
const CSS_FUNC_PARSER_MAP = {
  length: (item) => Length.parse(item.matchedString),
  hex: (item) => __spreadValues({
    funcType: FuncType.COLOR
  }, parse(item.matchedString)),
  rgb: (item) => __spreadValues({
    funcType: FuncType.COLOR
  }, parse(item.matchedString)),
  rgba: (item) => __spreadValues({
    funcType: FuncType.COLOR
  }, parse(item.matchedString)),
  hsl: (item) => __spreadValues({
    funcType: FuncType.COLOR
  }, parse(item.matchedString)),
  hsla: (item) => __spreadValues({
    funcType: FuncType.COLOR
  }, parse(item.matchedString)),
  color: (item) => __spreadValues({
    funcType: FuncType.COLOR
  }, parse(item.matchedString)),
  steps: (item) => ({
    funcType: FuncType.TIMING,
    name: TimingFunction.STEPS,
    count: +item.parameters[0],
    direction: item.parameters[1]
  }),
  path: (item) => ({
    funcType: FuncType.TIMING,
    name: TimingFunction.PATH,
    d: item.args
  }),
  repeat: (item) => {
    return {
      funcType: FuncType.REPEAT,
      count: +item.parameters[0],
      length: Length.parse(item.parameters[1])
    };
  },
  "static-gradient": makeGroupFunction("static-gradient"),
  "linear-gradient": makeGroupFunction("linear-gradient"),
  "radial-gradient": makeGroupFunction("radial-gradient"),
  "conic-gradient": makeGroupFunction("conic-gradient"),
  "repeating-linear-gradient": makeGroupFunction("repeating-linear-gradient"),
  "repeating-radial-gradient": makeGroupFunction("repeating-radial-gradient"),
  "repeating-conic-gradient": makeGroupFunction("repeating-conic-gradient"),
  "cubic-bezier": (item) => ({
    funcType: FuncType.TIMING,
    name: TimingFunction.CUBIC_BEZIER,
    matchedString: item.matchedString,
    x1: +item.parameters[0],
    y1: +item.parameters[1],
    x2: +item.parameters[2],
    y2: +item.parameters[3]
  }),
  ease: (item) => ({
    funcType: FuncType.TIMING,
    name: TimingFunction.EASE,
    matchedString: item.matchedString,
    x1: 0.25,
    y1: 0.1,
    x2: 0.25,
    y2: 1
  }),
  "ease-in": (item) => ({
    funcType: FuncType.TIMING,
    name: TimingFunction.EASE_IN,
    matchedString: item.matchedString,
    x1: 0.42,
    y1: 0,
    x2: 1,
    y2: 1
  }),
  "ease-out": (item) => ({
    funcType: FuncType.TIMING,
    name: TimingFunction.EASE_OUT,
    matchedString: item.matchedString,
    x1: 0,
    y1: 0,
    x2: 0.58,
    y2: 1
  }),
  "ease-in-out": (item) => ({
    funcType: FuncType.TIMING,
    name: TimingFunction.EASE_IN_OUT,
    matchedString: item.matchedString,
    x1: 0.42,
    y1: 0,
    x2: 0.58,
    y2: 1
  }),
  linear: (item) => ({
    funcType: FuncType.TIMING,
    name: TimingFunction.LINEAR,
    matchedString: item.matchedString,
    x1: 0,
    y1: 0,
    x2: 1,
    y2: 1
  })
};
function parseValue(str, {
  funcStartCharacter = "(",
  funcEndCharacter = ")",
  parameterSaparator = ",",
  customFuncMap: customFuncMap2 = {}
} = {}) {
  let matches2 = str.match(CSS_FUNC_REGEXP);
  let result = [];
  if (!matches2) {
    return result;
  }
  function checkParsedResult(startIndex, endIndex, matchedString) {
    return result.some((it) => {
      if (it.parsed && isArray(it.parsed)) {
        return it.parsed.some((parsedIt) => {
          if (parsedIt.startIndex === startIndex && parsedIt.endIndex === endIndex && matchedString === parsedIt.matchedString) {
            return true;
          }
          return false;
        });
      }
      if (it.startIndex === startIndex && it.endIndex === endIndex && matchedString === it.matchedString) {
        return true;
      }
      return false;
    });
  }
  var pos = { next: 0 };
  matches2 = matches2.map((matchedString) => {
    const startIndex = str.indexOf(matchedString, pos.next);
    pos.next = startIndex + matchedString.length;
    return { index: startIndex, matchedString };
  });
  pos.next = 0;
  for (var i = 0, len2 = matches2.length; i < len2; i++) {
    const { matchedString, index: index2 } = matches2[i];
    if (index2 < pos.next)
      continue;
    let parsedFunc = CSS_FUNC_MATCHES(matchedString);
    let item = {
      matchedString
    };
    const startIndex = str.indexOf(item.matchedString, pos.next);
    if (startIndex < 0) {
      continue;
    }
    item.startIndex = startIndex;
    item.endIndex = startIndex + item.matchedString.length;
    const isContinue = checkParsedResult(item.startIndex, item.endIndex, item.matchedString);
    if (isContinue) {
      continue;
    }
    if (parsedFunc) {
      item = __spreadProps(__spreadValues({}, item), {
        func: parsedFunc
      });
    } else {
      const [func, rest] = matchedString.split(funcStartCharacter);
      const [args2] = rest.split(funcEndCharacter);
      item = __spreadProps(__spreadValues({}, item), {
        func,
        args: args2,
        parameters: args2.split(parameterSaparator).map((it) => it.trim())
      });
      parsedFunc = func;
    }
    let customFunctionCallback;
    if (CSS_FUNC_PARSER_MAP[parsedFunc]) {
      customFunctionCallback = CSS_FUNC_PARSER_MAP[parsedFunc] || CSS_FUNC_PARSER_MAP[item.matchedString];
    } else if (customFuncMap2[parsedFunc] || customFuncMap2[item.matchedString]) {
      customFunctionCallback = customFuncMap2[parsedFunc] || customFuncMap2[item.matchedString];
    }
    if (customFunctionCallback) {
      const parsed = customFunctionCallback.call(null, item, str, funcStartCharacter, funcEndCharacter, parameterSaparator);
      if (parsed == null ? void 0 : parsed.convert) {
        item = __spreadValues(__spreadValues({}, item), parsed);
        delete item.convert;
      } else {
        item = __spreadProps(__spreadValues({}, item), {
          parsed
        });
      }
    }
    result.push(item);
    pos.next = item.endIndex;
  }
  return result;
}
function parseOneValue(str) {
  return parseValue(str)[0];
}
function parseGroupValue(str, customMapFuncName = "temp") {
  var _a;
  return (_a = parseValue(`${customMapFuncName}(${str})`, {
    customFuncMap: {
      [customMapFuncName]: makeGroupFunction(customMapFuncName)
    }
  })[0]) == null ? void 0 : _a.parameters;
}
class ColorStep {
  constructor(obj2 = {}) {
    this.id = obj2.id || uuidShort();
    this.color = obj2.color || "transparent";
    this.cut = obj2.cut || false;
    this.percent = obj2.percent || 0;
    this.unit = obj2.unit || "%";
    this.px = obj2.px || 0;
    this.em = obj2.em || 0;
    this.prevColorStep = obj2.prevColorStep || null;
    this.timing = obj2.timing || parseValue("linear")[0].parsed;
    this.timingCount = obj2.timingCount || 1;
  }
  toCloneObject() {
    return {
      id: this.id,
      color: this.color,
      cut: this.cut,
      percent: this.percent,
      unit: this.unit,
      px: this.px,
      em: this.em,
      prevColorStep: this.prevColorStep,
      timing: this.timing,
      timingCount: this.timingCount
    };
  }
  on() {
    this.cut = true;
  }
  off() {
    this.cut = false;
  }
  toggle() {
    this.cut = !this.cut;
  }
  toggleTiming() {
    switch (this.timing.name) {
      case TimingFunction.LINEAR:
        this.timing = parseOneValue("steps(1, start)").parsed;
        break;
      case TimingFunction.STEPS:
        this.timing = parseOneValue("ease").parsed;
        this.timingCount = 15;
        break;
      case TimingFunction.EASE:
      case TimingFunction.EASE_IN:
      case TimingFunction.EASE_IN_OUT:
      case TimingFunction.EASE_OUT:
      case TimingFunction.CUBIC_BEZIER:
        this.timing = parseOneValue("path(M 0 0 C 0.25 0.25 0.75 0.75 1 1)").parsed;
        this.timingCount = 15;
        break;
      default:
        this.timing = parseOneValue("linear").parsed;
        this.timingCount = 1;
        break;
    }
  }
  getUnit() {
    return this.unit == "%" ? "percent" : this.unit;
  }
  add(num) {
    var unit = this.getUnit();
    this[unit] += +num;
    return this;
  }
  sub(num) {
    var unit = this.getUnit();
    this[unit] -= +num;
    return this;
  }
  mul(num) {
    var unit = this.getUnit();
    this[unit] *= +num;
    return this;
  }
  div(num) {
    var unit = this.getUnit();
    this[unit] /= +num;
    return this;
  }
  mod(num) {
    var unit = this.getUnit();
    this[unit] %= +num;
    return this;
  }
  get isPx() {
    return this.unit == "px";
  }
  get isPercent() {
    return this.unit == "%" || this.unit === "percent";
  }
  get isEm() {
    return this.unit == "em";
  }
  toLength() {
    if (this.isPx) {
      return Length.px(this.px);
    } else if (this.isPercent) {
      return Length.percent(this.percent);
    } else if (this.isEm) {
      return Length.em(this.em);
    }
  }
  getPrevLength() {
    if (!this.prevColorStep)
      return "";
    return this.prevColorStep.toLength();
  }
  toString() {
    var prev = this.cut ? this.getPrevLength() : "";
    var color2 = this.color || "transparent";
    return `${color2} ${prev} ${this.toLength()}`;
  }
  setValue(percent, maxValue) {
    if (this.isPx) {
      this.px = maxValue * percent / 100;
    } else if (this.isPercent) {
      this.percent = percent;
    } else if (this.isEm) {
      this.em = maxValue * percent / 100 / 16;
    }
    if (this.parent) {
      this.parent.sortColorStep();
    }
  }
  static parse(colorStepString) {
    let colorsteps = [];
    const results = convertMatches(colorStepString);
    var arr = results.str.split(" ").filter((it) => it.trim());
    const colorIndex = +arr[0].replace("@", "");
    const color2 = results.matches[colorIndex].color;
    if (arr.length === 1) {
      colorsteps.push(new ColorStep({
        color: color2,
        unit: "%",
        percent: 0,
        hasNotUnit: true
      }));
    } else if (arr.length === 2) {
      const len2 = Length.parse(arr[1]);
      let data = { unit: len2.unit };
      if (len2.isPercent()) {
        data.percent = len2.value;
      } else if (len2.isPx()) {
        data.px = len2.value;
      } else if (len2.isEm()) {
        data.em = len2.value;
      }
      colorsteps.push(new ColorStep(__spreadValues({ color: color2 }, data)));
    } else if (arr.length === 3) {
      const len2 = Length.parse(arr[2]);
      let data = { unit: len2.unit };
      if (len2.isPercent()) {
        data.percent = len2.value;
      } else if (len2.isPx()) {
        data.px = len2.value;
      } else if (len2.isEm()) {
        data.em = len2.value;
      }
      colorsteps.push(new ColorStep(__spreadValues({ color: color2, cut: true }, data)));
    }
    return colorsteps;
  }
  static createColorStep(maxCount = 2, maxValue = 100, unitType = "%") {
    var colorStepCount = randomNumber(2, maxCount);
    var unitValue = maxValue / colorStepCount;
    var colorsteps = repeat(colorStepCount).map((_, index2) => {
      return `${random$1()} ${index2 * unitValue}${unitType}`;
    }).join(",");
    return colorsteps;
  }
  static createRepeatColorStep(maxCount = 2, unitValue = 1) {
    var colorStepCount = randomNumber(2, maxCount);
    var colorsteps = repeat(colorStepCount).map((_, index2) => {
      return `${random$1()} ${Length.parse(unitValue).mul(index2 + 1)}`;
    }).join(",");
    return colorsteps;
  }
}
class ImageResource extends PropertyItem {
  getDefaultObject(obj2 = {}) {
    return __spreadValues({
      itemType: "image-resource",
      type: "image"
    }, obj2);
  }
  isGradient() {
    return false;
  }
  isLinear() {
    return false;
  }
  isImage() {
    return false;
  }
  hasAngle() {
    return false;
  }
  isUrl() {
    return false;
  }
  isFile() {
    return false;
  }
  isAttribute() {
    return true;
  }
  toString() {
    return "none";
  }
}
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getAugmentedNamespace(n) {
  if (n.__esModule)
    return n;
  var a = Object.defineProperty({}, "__esModule", { value: true });
  Object.keys(n).forEach(function(k) {
    var d = Object.getOwnPropertyDescriptor(n, k);
    Object.defineProperty(a, k, d.get ? d : {
      enumerable: true,
      get: function() {
        return n[k];
      }
    });
  });
  return a;
}
var fitCurve$1 = { exports: {} };
(function(module, exports) {
  (function(global2, factory) {
    {
      factory(module);
    }
  })(commonjsGlobal, function(module2) {
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    /**
     *  @preserve  JavaScript implementation of
     *  Algorithm for Automatically Fitting Digitized Curves
     *  by Philip J. Schneider
     *  "Graphics Gems", Academic Press, 1990
     *
     *  The MIT License (MIT)
     *
     *  https://github.com/soswow/fit-curves
     */
    function fitCurve2(points, maxError, progressCallback) {
      if (!Array.isArray(points)) {
        throw new TypeError("First argument should be an array");
      }
      points.forEach(function(point2) {
        if (!Array.isArray(point2) || point2.some(function(item) {
          return typeof item !== "number";
        }) || point2.length !== points[0].length) {
          throw Error("Each point should be an array of numbers. Each point should have the same amount of numbers.");
        }
      });
      points = points.filter(function(point2, i) {
        return i === 0 || !point2.every(function(val, j) {
          return val === points[i - 1][j];
        });
      });
      if (points.length < 2) {
        return [];
      }
      var len2 = points.length;
      var leftTangent = createTangent(points[1], points[0]);
      var rightTangent = createTangent(points[len2 - 2], points[len2 - 1]);
      return fitCubic(points, leftTangent, rightTangent, maxError, progressCallback);
    }
    function fitCubic(points, leftTangent, rightTangent, error, progressCallback) {
      var MaxIterations = 20;
      var bezCurve, u, uPrime, maxError, prevErr, splitPoint, prevSplit, centerVector, toCenterTangent, fromCenterTangent, beziers, dist2, i;
      if (points.length === 2) {
        dist2 = maths.vectorLen(maths.subtract(points[0], points[1])) / 3;
        bezCurve = [points[0], maths.addArrays(points[0], maths.mulItems(leftTangent, dist2)), maths.addArrays(points[1], maths.mulItems(rightTangent, dist2)), points[1]];
        return [bezCurve];
      }
      u = chordLengthParameterize(points);
      var _generateAndReport = generateAndReport(points, u, u, leftTangent, rightTangent, progressCallback);
      bezCurve = _generateAndReport[0];
      maxError = _generateAndReport[1];
      splitPoint = _generateAndReport[2];
      if (maxError === 0 || maxError < error) {
        return [bezCurve];
      }
      if (maxError < error * error) {
        uPrime = u;
        prevErr = maxError;
        prevSplit = splitPoint;
        for (i = 0; i < MaxIterations; i++) {
          uPrime = reparameterize(bezCurve, points, uPrime);
          var _generateAndReport2 = generateAndReport(points, u, uPrime, leftTangent, rightTangent, progressCallback);
          bezCurve = _generateAndReport2[0];
          maxError = _generateAndReport2[1];
          splitPoint = _generateAndReport2[2];
          if (maxError < error) {
            return [bezCurve];
          } else if (splitPoint === prevSplit) {
            var errChange = maxError / prevErr;
            if (errChange > 0.9999 && errChange < 1.0001) {
              break;
            }
          }
          prevErr = maxError;
          prevSplit = splitPoint;
        }
      }
      beziers = [];
      centerVector = maths.subtract(points[splitPoint - 1], points[splitPoint + 1]);
      if (centerVector.every(function(val) {
        return val === 0;
      })) {
        centerVector = maths.subtract(points[splitPoint - 1], points[splitPoint]);
        var _ref = [-centerVector[1], centerVector[0]];
        centerVector[0] = _ref[0];
        centerVector[1] = _ref[1];
      }
      toCenterTangent = maths.normalize(centerVector);
      fromCenterTangent = maths.mulItems(toCenterTangent, -1);
      beziers = beziers.concat(fitCubic(points.slice(0, splitPoint + 1), leftTangent, toCenterTangent, error, progressCallback));
      beziers = beziers.concat(fitCubic(points.slice(splitPoint), fromCenterTangent, rightTangent, error, progressCallback));
      return beziers;
    }
    function generateAndReport(points, paramsOrig, paramsPrime, leftTangent, rightTangent, progressCallback) {
      var bezCurve, maxError, splitPoint;
      bezCurve = generateBezier(points, paramsPrime, leftTangent, rightTangent);
      var _computeMaxError = computeMaxError(points, bezCurve, paramsOrig);
      maxError = _computeMaxError[0];
      splitPoint = _computeMaxError[1];
      if (progressCallback) {
        progressCallback({
          bez: bezCurve,
          points,
          params: paramsOrig,
          maxErr: maxError,
          maxPoint: splitPoint
        });
      }
      return [bezCurve, maxError, splitPoint];
    }
    function generateBezier(points, parameters, leftTangent, rightTangent) {
      var bezCurve, A, a, C, X, det_C0_C1, det_C0_X, det_X_C1, alpha_l, alpha_r, epsilon, segLength, i, len2, tmp2, u, ux, firstPoint = points[0], lastPoint = points[points.length - 1];
      bezCurve = [firstPoint, null, null, lastPoint];
      A = maths.zeros_Xx2x2(parameters.length);
      for (i = 0, len2 = parameters.length; i < len2; i++) {
        u = parameters[i];
        ux = 1 - u;
        a = A[i];
        a[0] = maths.mulItems(leftTangent, 3 * u * (ux * ux));
        a[1] = maths.mulItems(rightTangent, 3 * ux * (u * u));
      }
      C = [[0, 0], [0, 0]];
      X = [0, 0];
      for (i = 0, len2 = points.length; i < len2; i++) {
        u = parameters[i];
        a = A[i];
        C[0][0] += maths.dot(a[0], a[0]);
        C[0][1] += maths.dot(a[0], a[1]);
        C[1][0] += maths.dot(a[0], a[1]);
        C[1][1] += maths.dot(a[1], a[1]);
        tmp2 = maths.subtract(points[i], bezier.q([firstPoint, firstPoint, lastPoint, lastPoint], u));
        X[0] += maths.dot(a[0], tmp2);
        X[1] += maths.dot(a[1], tmp2);
      }
      det_C0_C1 = C[0][0] * C[1][1] - C[1][0] * C[0][1];
      det_C0_X = C[0][0] * X[1] - C[1][0] * X[0];
      det_X_C1 = X[0] * C[1][1] - X[1] * C[0][1];
      alpha_l = det_C0_C1 === 0 ? 0 : det_X_C1 / det_C0_C1;
      alpha_r = det_C0_C1 === 0 ? 0 : det_C0_X / det_C0_C1;
      segLength = maths.vectorLen(maths.subtract(firstPoint, lastPoint));
      epsilon = 1e-6 * segLength;
      if (alpha_l < epsilon || alpha_r < epsilon) {
        bezCurve[1] = maths.addArrays(firstPoint, maths.mulItems(leftTangent, segLength / 3));
        bezCurve[2] = maths.addArrays(lastPoint, maths.mulItems(rightTangent, segLength / 3));
      } else {
        bezCurve[1] = maths.addArrays(firstPoint, maths.mulItems(leftTangent, alpha_l));
        bezCurve[2] = maths.addArrays(lastPoint, maths.mulItems(rightTangent, alpha_r));
      }
      return bezCurve;
    }
    function reparameterize(bezier2, points, parameters) {
      return parameters.map(function(p, i) {
        return newtonRaphsonRootFind(bezier2, points[i], p);
      });
    }
    function newtonRaphsonRootFind(bez, point2, u) {
      var d = maths.subtract(bezier.q(bez, u), point2), qprime = bezier.qprime(bez, u), numerator = maths.mulMatrix(d, qprime), denominator = maths.sum(maths.squareItems(qprime)) + 2 * maths.mulMatrix(d, bezier.qprimeprime(bez, u));
      if (denominator === 0) {
        return u;
      } else {
        return u - numerator / denominator;
      }
    }
    function chordLengthParameterize(points) {
      var u = [], currU, prevU, prevP;
      points.forEach(function(p, i) {
        currU = i ? prevU + maths.vectorLen(maths.subtract(p, prevP)) : 0;
        u.push(currU);
        prevU = currU;
        prevP = p;
      });
      u = u.map(function(x) {
        return x / prevU;
      });
      return u;
    }
    function computeMaxError(points, bez, parameters) {
      var dist2, maxDist, splitPoint, v, i, count, point2, t;
      maxDist = 0;
      splitPoint = Math.floor(points.length / 2);
      var t_distMap = mapTtoRelativeDistances(bez, 10);
      for (i = 0, count = points.length; i < count; i++) {
        point2 = points[i];
        t = find_t(bez, parameters[i], t_distMap, 10);
        v = maths.subtract(bezier.q(bez, t), point2);
        dist2 = v[0] * v[0] + v[1] * v[1];
        if (dist2 > maxDist) {
          maxDist = dist2;
          splitPoint = i;
        }
      }
      return [maxDist, splitPoint];
    }
    var mapTtoRelativeDistances = function mapTtoRelativeDistances2(bez, B_parts) {
      var B_t_curr;
      var B_t_dist = [0];
      var B_t_prev = bez[0];
      var sumLen = 0;
      for (var i = 1; i <= B_parts; i++) {
        B_t_curr = bezier.q(bez, i / B_parts);
        sumLen += maths.vectorLen(maths.subtract(B_t_curr, B_t_prev));
        B_t_dist.push(sumLen);
        B_t_prev = B_t_curr;
      }
      B_t_dist = B_t_dist.map(function(x) {
        return x / sumLen;
      });
      return B_t_dist;
    };
    function find_t(bez, param, t_distMap, B_parts) {
      if (param < 0) {
        return 0;
      }
      if (param > 1) {
        return 1;
      }
      var lenMax, lenMin, tMax, tMin, t;
      for (var i = 1; i <= B_parts; i++) {
        if (param <= t_distMap[i]) {
          tMin = (i - 1) / B_parts;
          tMax = i / B_parts;
          lenMin = t_distMap[i - 1];
          lenMax = t_distMap[i];
          t = (param - lenMin) / (lenMax - lenMin) * (tMax - tMin) + tMin;
          break;
        }
      }
      return t;
    }
    function createTangent(pointA, pointB) {
      return maths.normalize(maths.subtract(pointA, pointB));
    }
    var maths = function() {
      function maths2() {
        _classCallCheck(this, maths2);
      }
      maths2.zeros_Xx2x2 = function zeros_Xx2x2(x) {
        var zs = [];
        while (x--) {
          zs.push([0, 0]);
        }
        return zs;
      };
      maths2.mulItems = function mulItems(items, multiplier) {
        return items.map(function(x) {
          return x * multiplier;
        });
      };
      maths2.mulMatrix = function mulMatrix(m1, m2) {
        return m1.reduce(function(sum, x1, i) {
          return sum + x1 * m2[i];
        }, 0);
      };
      maths2.subtract = function subtract2(arr1, arr2) {
        return arr1.map(function(x1, i) {
          return x1 - arr2[i];
        });
      };
      maths2.addArrays = function addArrays(arr1, arr2) {
        return arr1.map(function(x1, i) {
          return x1 + arr2[i];
        });
      };
      maths2.addItems = function addItems(items, addition) {
        return items.map(function(x) {
          return x + addition;
        });
      };
      maths2.sum = function sum(items) {
        return items.reduce(function(sum2, x) {
          return sum2 + x;
        });
      };
      maths2.dot = function dot2(m1, m2) {
        return maths2.mulMatrix(m1, m2);
      };
      maths2.vectorLen = function vectorLen(v) {
        return Math.hypot.apply(Math, v);
      };
      maths2.divItems = function divItems(items, divisor) {
        return items.map(function(x) {
          return x / divisor;
        });
      };
      maths2.squareItems = function squareItems(items) {
        return items.map(function(x) {
          return x * x;
        });
      };
      maths2.normalize = function normalize2(v) {
        return this.divItems(v, this.vectorLen(v));
      };
      return maths2;
    }();
    var bezier = function() {
      function bezier2() {
        _classCallCheck(this, bezier2);
      }
      bezier2.q = function q(ctrlPoly, t) {
        var tx = 1 - t;
        var pA = maths.mulItems(ctrlPoly[0], tx * tx * tx), pB = maths.mulItems(ctrlPoly[1], 3 * tx * tx * t), pC = maths.mulItems(ctrlPoly[2], 3 * tx * t * t), pD = maths.mulItems(ctrlPoly[3], t * t * t);
        return maths.addArrays(maths.addArrays(pA, pB), maths.addArrays(pC, pD));
      };
      bezier2.qprime = function qprime(ctrlPoly, t) {
        var tx = 1 - t;
        var pA = maths.mulItems(maths.subtract(ctrlPoly[1], ctrlPoly[0]), 3 * tx * tx), pB = maths.mulItems(maths.subtract(ctrlPoly[2], ctrlPoly[1]), 6 * tx * t), pC = maths.mulItems(maths.subtract(ctrlPoly[3], ctrlPoly[2]), 3 * t * t);
        return maths.addArrays(maths.addArrays(pA, pB), pC);
      };
      bezier2.qprimeprime = function qprimeprime(ctrlPoly, t) {
        return maths.addArrays(maths.mulItems(maths.addArrays(maths.subtract(ctrlPoly[2], maths.mulItems(ctrlPoly[1], 2)), ctrlPoly[0]), 6 * (1 - t)), maths.mulItems(maths.addArrays(maths.subtract(ctrlPoly[3], maths.mulItems(ctrlPoly[2], 2)), ctrlPoly[1]), 6 * t));
      };
      return bezier2;
    }();
    module2.exports = fitCurve2;
    module2.exports.fitCubic = fitCubic;
    module2.exports.createTangent = createTangent;
  });
})(fitCurve$1);
var fitCurve = fitCurve$1.exports;
var _slicedToArray = function() {
  function sliceIterator(arr, i) {
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = void 0;
    try {
      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);
        if (i && _arr.length === i)
          break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"])
          _i["return"]();
      } finally {
        if (_d)
          throw _e;
      }
    }
    return _arr;
  }
  return function(arr, i) {
    if (Array.isArray(arr)) {
      return arr;
    } else if (Symbol.iterator in Object(arr)) {
      return sliceIterator(arr, i);
    } else {
      throw new TypeError("Invalid attempt to destructure non-iterable instance");
    }
  };
}();
var TAU = Math.PI * 2;
var mapToEllipse = function mapToEllipse2(_ref, rx, ry, cosphi, sinphi, centerx, centery) {
  var x = _ref.x, y = _ref.y;
  x *= rx;
  y *= ry;
  var xp = cosphi * x - sinphi * y;
  var yp = sinphi * x + cosphi * y;
  return {
    x: xp + centerx,
    y: yp + centery
  };
};
var approxUnitArc = function approxUnitArc2(ang1, ang2) {
  var a = ang2 === 1.5707963267948966 ? 0.551915024494 : ang2 === -1.5707963267948966 ? -0.551915024494 : 4 / 3 * Math.tan(ang2 / 4);
  var x1 = Math.cos(ang1);
  var y1 = Math.sin(ang1);
  var x2 = Math.cos(ang1 + ang2);
  var y2 = Math.sin(ang1 + ang2);
  return [{
    x: x1 - y1 * a,
    y: y1 + x1 * a
  }, {
    x: x2 + y2 * a,
    y: y2 - x2 * a
  }, {
    x: x2,
    y: y2
  }];
};
var vectorAngle = function vectorAngle2(ux, uy, vx, vy) {
  var sign = ux * vy - uy * vx < 0 ? -1 : 1;
  var dot2 = ux * vx + uy * vy;
  if (dot2 > 1) {
    dot2 = 1;
  }
  if (dot2 < -1) {
    dot2 = -1;
  }
  return sign * Math.acos(dot2);
};
var getArcCenter = function getArcCenter2(px, py, cx, cy, rx, ry, largeArcFlag, sweepFlag, sinphi, cosphi, pxp, pyp) {
  var rxsq = Math.pow(rx, 2);
  var rysq = Math.pow(ry, 2);
  var pxpsq = Math.pow(pxp, 2);
  var pypsq = Math.pow(pyp, 2);
  var radicant = rxsq * rysq - rxsq * pypsq - rysq * pxpsq;
  if (radicant < 0) {
    radicant = 0;
  }
  radicant /= rxsq * pypsq + rysq * pxpsq;
  radicant = Math.sqrt(radicant) * (largeArcFlag === sweepFlag ? -1 : 1);
  var centerxp = radicant * rx / ry * pyp;
  var centeryp = radicant * -ry / rx * pxp;
  var centerx = cosphi * centerxp - sinphi * centeryp + (px + cx) / 2;
  var centery = sinphi * centerxp + cosphi * centeryp + (py + cy) / 2;
  var vx1 = (pxp - centerxp) / rx;
  var vy1 = (pyp - centeryp) / ry;
  var vx2 = (-pxp - centerxp) / rx;
  var vy2 = (-pyp - centeryp) / ry;
  var ang1 = vectorAngle(1, 0, vx1, vy1);
  var ang2 = vectorAngle(vx1, vy1, vx2, vy2);
  if (sweepFlag === 0 && ang2 > 0) {
    ang2 -= TAU;
  }
  if (sweepFlag === 1 && ang2 < 0) {
    ang2 += TAU;
  }
  return [centerx, centery, ang1, ang2];
};
var arcToBezier = function arcToBezier2(_ref2) {
  var px = _ref2.px, py = _ref2.py, cx = _ref2.cx, cy = _ref2.cy, rx = _ref2.rx, ry = _ref2.ry, _ref2$xAxisRotation = _ref2.xAxisRotation, xAxisRotation = _ref2$xAxisRotation === void 0 ? 0 : _ref2$xAxisRotation, _ref2$largeArcFlag = _ref2.largeArcFlag, largeArcFlag = _ref2$largeArcFlag === void 0 ? 0 : _ref2$largeArcFlag, _ref2$sweepFlag = _ref2.sweepFlag, sweepFlag = _ref2$sweepFlag === void 0 ? 0 : _ref2$sweepFlag;
  var curves = [];
  if (rx === 0 || ry === 0) {
    return [];
  }
  var sinphi = Math.sin(xAxisRotation * TAU / 360);
  var cosphi = Math.cos(xAxisRotation * TAU / 360);
  var pxp = cosphi * (px - cx) / 2 + sinphi * (py - cy) / 2;
  var pyp = -sinphi * (px - cx) / 2 + cosphi * (py - cy) / 2;
  if (pxp === 0 && pyp === 0) {
    return [];
  }
  rx = Math.abs(rx);
  ry = Math.abs(ry);
  var lambda = Math.pow(pxp, 2) / Math.pow(rx, 2) + Math.pow(pyp, 2) / Math.pow(ry, 2);
  if (lambda > 1) {
    rx *= Math.sqrt(lambda);
    ry *= Math.sqrt(lambda);
  }
  var _getArcCenter = getArcCenter(px, py, cx, cy, rx, ry, largeArcFlag, sweepFlag, sinphi, cosphi, pxp, pyp), _getArcCenter2 = _slicedToArray(_getArcCenter, 4), centerx = _getArcCenter2[0], centery = _getArcCenter2[1], ang1 = _getArcCenter2[2], ang2 = _getArcCenter2[3];
  var ratio = Math.abs(ang2) / (TAU / 4);
  if (Math.abs(1 - ratio) < 1e-7) {
    ratio = 1;
  }
  var segments = Math.max(Math.ceil(ratio), 1);
  ang2 /= segments;
  for (var i = 0; i < segments; i++) {
    curves.push(approxUnitArc(ang1, ang2));
    ang1 += ang2;
  }
  return curves.map(function(curve) {
    var _mapToEllipse = mapToEllipse(curve[0], rx, ry, cosphi, sinphi, centerx, centery), x1 = _mapToEllipse.x, y1 = _mapToEllipse.y;
    var _mapToEllipse2 = mapToEllipse(curve[1], rx, ry, cosphi, sinphi, centerx, centery), x2 = _mapToEllipse2.x, y2 = _mapToEllipse2.y;
    var _mapToEllipse3 = mapToEllipse(curve[2], rx, ry, cosphi, sinphi, centerx, centery), x = _mapToEllipse3.x, y = _mapToEllipse3.y;
    return { x1, y1, x2, y2, x, y };
  });
};
class Point {
  static isEqual(a, b, c2) {
    if (arguments.length === 2) {
      return a.x === b.x && a.y === b.y;
    } else if (arguments.length === 3) {
      return Point.isEqual(a, b) && Point.isEqual(b, c2);
    }
  }
  static isFirst(point2) {
    return point2 && point2.command == "M";
  }
  static DouglasPeuker(tolerance, points, start2, last) {
    if (last <= start2 + 1)
      return;
    let maxdist2 = 0;
    let breakIndex = start2;
    const tol2 = tolerance * tolerance;
    const startPoint = points[start2];
    const lastPoint = points[last];
    for (var i = start2 + 1; i < last; i++) {
      const dist2 = Point.segmentDistance2(points[i].x, points[i].y, startPoint, lastPoint);
      if (dist2 <= maxdist2)
        continue;
      breakIndex = i;
      maxdist2 = dist2;
    }
    if (maxdist2 > tol2) {
      points[breakIndex].mark = true;
      Point.DouglasPeuker(tolerance, points, start2, breakIndex);
      Point.DouglasPeuker(tolerance, points, breakIndex, last);
    }
  }
  static simply(points, tolerance = 10) {
    if (points.length <= 2) {
      return points;
    }
    points = clone$1(points);
    points[0].mark = true;
    points[points.length - 1].mark = true;
    Point.DouglasPeuker(tolerance, points, 0, points.length - 1);
    return points.filter((it) => Boolean(it.mark));
  }
  static segmentDistance2(x, y, A, B) {
    let dx = B.x - A.x;
    let dy = B.y - A.y;
    let lenAB = dx * dx + dy * dy;
    let du = x - A.x;
    let dv = y - A.y;
    let dot2 = dx * du + dy * dv;
    if (lenAB === 0)
      return du * du + dv * dv;
    if (dot2 <= 0)
      return du * du + dv * dv;
    else if (dot2 >= lenAB) {
      du = x - B.x;
      dv = y - B.y;
      return du * du + dv * dv;
    } else {
      const slash = du * dy - dv * dx;
      return slash * slash / lenAB;
    }
  }
  static isInLine(A, B, C) {
    if (A.x === C.x)
      return B.x === C.x;
    if (A.y === C.y)
      return B.y === C.y;
    return (A.x - C.x) * (A.y - C.y) === (C.x - B.x) * (C.y - B.y);
  }
  static isLine(point2) {
    return Point.isInLine(point2.endPoint, point2.startPoint, point2, point2.reversePoint);
  }
  static getReversePoint(start2, end2) {
    const [x, y] = lerp([], [end2.x, end2.y, 0], [start2.x, start2.y, 0], 2);
    return { x, y };
  }
  static getIndexPoint(points, index2) {
    return points[index2];
  }
  static getPoint(points, p0) {
    return points.filter((p) => {
      return Point.isEqual(p.startPoint, p0);
    })[0];
  }
  static getIndex(points, p0) {
    var firstIndex = -1;
    for (var i = 0, len2 = points.length; i < len2; i++) {
      var p = points[i];
      if (Point.isEqual(p.startPoint, p0)) {
        firstIndex = i;
        break;
      }
    }
    return firstIndex;
  }
  static getGroupList(points) {
    const groupList = [];
    let groupIndex = 0;
    points.forEach((point2, index2) => {
      if (point2.command === "M") {
        groupList.push({ point: point2, index: index2, groupIndex: groupIndex++ });
      }
    });
    return groupList;
  }
  static getSplitedGroupList(points) {
    const localPoints = clone$1(points);
    const splitedGroupList = [];
    for (var i = 0, groupIndex = -1, len2 = localPoints.length; i < len2; i++) {
      const point2 = localPoints[i];
      if (point2.command === "M") {
        groupIndex++;
        splitedGroupList[groupIndex] = {
          startPointIndex: i,
          point: point2,
          points: []
        };
      }
      splitedGroupList[groupIndex].points.push(point2);
    }
    return splitedGroupList;
  }
  static getGroup(groupList, pointIndex) {
    const list2 = groupList.filter((group2) => group2.point.index <= pointIndex);
    return list2.pop();
  }
  static getGroupIndex(points, index2) {
    var groupIndex = -1;
    for (var i = 0, len2 = points.length; i < len2; i++) {
      if (points[i].command === "M") {
        groupIndex++;
      }
      if (points[i].index === index2) {
        return groupIndex;
      }
    }
  }
  static getLastPoint(points, index2) {
    if (!points.length)
      return null;
    var lastIndex = -1;
    for (var i = index2 + 1, len2 = points.length; i < len2; i++) {
      if (points[i].command === "M") {
        lastIndex = i - 1;
        break;
      }
    }
    if (lastIndex == -1) {
      lastIndex = points.length - 1;
    }
    if (points[lastIndex] && points[lastIndex].command === "Z") {
      lastIndex -= 1;
    }
    var point2 = points[lastIndex];
    if (point2) {
      point2.index = lastIndex;
    }
    return point2;
  }
  static getFirstPoint(points, index2) {
    var firstIndex = -1;
    for (var i = index2 - 1; i > 0; i--) {
      if (points[i].command === "M") {
        firstIndex = i;
        break;
      }
    }
    if (firstIndex === -1) {
      firstIndex = 0;
    }
    var point2 = points[firstIndex];
    if (point2) {
      point2.index = firstIndex;
    }
    return point2;
  }
  static getConnectedPointList(points, index2) {
    const current = points[index2];
    return points.filter((p, i) => i !== index2 && Point.isEqual(p.startPoint, current.startPoint));
  }
  static getPrevPoint(points, index2) {
    var prevIndex = index2 - 1;
    if (prevIndex < 0) {
      return Point.getLastPoint(points, index2);
    }
    var point2 = points[prevIndex];
    if (point2) {
      point2.index = prevIndex;
    }
    return point2;
  }
  static getNextPoint(points, index2) {
    var currentPoint = points[index2];
    var nextPoint = points[index2 + 1];
    if (nextPoint) {
      nextPoint.index = index2 + 1;
    }
    if (currentPoint.connected || currentPoint.close) {
      nextPoint = Point.getFirstPoint(points, index2);
    }
    return nextPoint;
  }
  static removePoint(points, pIndex, segment) {
    if (segment === "startPoint") {
      return points.filter((_, index2) => index2 !== pIndex);
    }
  }
  static splitPoints(points) {
    let splitedPointGroup = [];
    let lastPoints = [];
    points.forEach((p) => {
      if (Point.isFirst(p)) {
        lastPoints = [p];
        splitedPointGroup.push(lastPoints);
      } else {
        lastPoints.push(p);
      }
    });
    return splitedPointGroup;
  }
  static recoverPoints(pointGroup) {
    const newPoints = [];
    pointGroup.forEach((points) => {
      points.forEach((p, index2) => {
        if (index2 === 0) {
          p.command = "M";
          p.originalCommand = "M";
        }
      });
      newPoints.push.apply(newPoints, points);
    });
    newPoints.forEach((p, index2) => {
      p.index = index2;
    });
    return newPoints;
  }
}
class Segment {
  static M(x, y) {
    return {
      command: "M",
      values: [x, y]
    };
  }
  static L(x, y) {
    return {
      command: "L",
      values: [x, y]
    };
  }
  static Q(x1, y1, x, y) {
    return {
      command: "Q",
      values: [x1, y1, x, y]
    };
  }
  static C(x1, y1, x2, y2, x, y) {
    return {
      command: "C",
      values: [x1, y1, x2, y2, x, y]
    };
  }
  static A(rx, ry, xrot, laf, sf, x, y) {
    return {
      command: "A",
      values: [rx, ry, xrot, laf, sf, x, y]
    };
  }
  static Z() {
    return {
      command: "Z",
      values: []
    };
  }
  static isMoveTo(segment) {
    return segment.command === "M";
  }
  static isLineTo(segment) {
    return segment.command === "L";
  }
  static isQuadraticBezierCurve(segment) {
    return segment.command === "Q";
  }
  static isCubicBezierCurve(segment) {
    return segment.command === "C";
  }
  static isArc(segment) {
    return segment.command === "A";
  }
  static isClosePath(segment) {
    return segment.command === "Z";
  }
}
const REG_PARSE_NUMBER_FOR_PATH = /([mMlLvVhHcCsSqQtTaAzZ]([^mMlLvVhHcCsSqQtTaAzZ]*))/g;
var numberReg = /-?[0-9]*\.?[0-9]+(?:e[-+]?\d+)?/gi;
function xy$2(point2) {
  return {
    x: point2[0],
    y: point2[1]
  };
}
class PathParser {
  constructor(pathString2 = "") {
    this.reset(pathString2);
  }
  reset(pathString2 = "") {
    this.segments = [];
    this.pathString = pathString2.trim();
    this.parse();
    return this;
  }
  resetSegments(segments) {
    this.segments = segments || [];
    this.pathString = this.joinPath();
    return this;
  }
  addSegments(segments) {
    return this.resetSegments([...this.segments, ...segments]);
  }
  addPath(otherPath, transform2 = create$4()) {
    const newPath = otherPath.clone();
    newPath.transformMat4(transform2);
    return this.addSegments(newPath.segments);
  }
  trim(str = "") {
    var arr = str.match(numberReg) || [];
    return arr.filter((it) => it != "");
  }
  parse() {
    var arr = this.pathString.match(REG_PARSE_NUMBER_FOR_PATH) || [];
    this.segments = arr.map((s) => {
      var command = s[0];
      var values = this.trim(s.replace(command, "")).map((it) => +it);
      return { command, values };
    });
    this.segments = this.segments.map((s, index2) => {
      switch (s.command) {
        case "m":
          var prev = this.segments[index2 - 1];
          if (prev && (prev.command == "z" || prev.command == "Z")) {
            prev = this.segments[index2 - 2];
          }
          var x = (prev == null ? void 0 : prev.values[prev.values.length - 2]) || 0;
          var y = (prev == null ? void 0 : prev.values[prev.values.length - 1]) || 0;
          for (var i = 0, len2 = s.values.length; i < len2; i += 2) {
            s.values[i] += x;
            s.values[i + 1] += y;
          }
          return {
            command: s.command.toUpperCase(),
            values: [...s.values]
          };
        case "c":
        case "l":
        case "q":
        case "s":
        case "t":
        case "v":
        case "h":
          var prev = this.segments[index2 - 1];
          var x = (prev == null ? void 0 : prev.values[prev.values.length - 2]) || 0;
          var y = (prev == null ? void 0 : prev.values[prev.values.length - 1]) || 0;
          for (var i = 0, len2 = s.values.length; i < len2; i += 2) {
            s.values[i] += x;
            s.values[i + 1] += y;
          }
          return {
            command: s.command.toUpperCase(),
            values: [...s.values]
          };
        case "a":
          var prev = this.segments[index2 - 1];
          var x = (prev == null ? void 0 : prev.values[prev.values.length - 2]) || 0;
          var y = (prev == null ? void 0 : prev.values[prev.values.length - 1]) || 0;
          s.values[5] += x;
          s.values[6] += y;
          return {
            command: s.command.toUpperCase(),
            values: [...s.values]
          };
        case "z":
          return {
            command: s.command.toUpperCase(),
            values: []
          };
        default:
          return s;
      }
    });
    this.segments.forEach((it, index2) => {
      const prev = this.segments[index2 - 1];
      if (it.command == "A") {
        const x1 = (prev == null ? void 0 : prev.values[prev.values.length - 2]) || 0;
        const y1 = (prev == null ? void 0 : prev.values[prev.values.length - 1]) || 0;
        const [rx, ry, xrotate, largeArcFlag, sweepFlag, x, y] = it.values;
        const path = PathParser.arcToCurve(x1, y1, rx, ry, xrotate, largeArcFlag, sweepFlag, x, y);
        path.segments.forEach((seg) => {
          if (seg.command !== "M" || seg.command !== "Z")
            ;
        });
      }
    });
    return this;
  }
  convertGenerator() {
    var points = [];
    for (var index2 = 0, len2 = this.segments.length; index2 < len2; index2++) {
      var s = this.segments[index2];
      var nextSegment = this.segments[index2 + 1];
      const { command, values } = s;
      if (command === "M") {
        var [x, y] = values;
        points.push({
          command,
          originalCommand: command,
          startPoint: { x, y },
          endPoint: { x, y },
          reversePoint: { x, y },
          curve: false
        });
      } else if (command === "L") {
        var prevPoint = Point.getPrevPoint(points, points.length);
        if (prevPoint.curve) {
          var [x, y] = values;
          points.push({
            command,
            originalCommand: command,
            startPoint: { x, y },
            endPoint: { x, y },
            reversePoint: clone$1(prevPoint.endPoint),
            curve: true
          });
        } else {
          var [x, y] = values;
          points.push({
            command,
            originalCommand: command,
            startPoint: { x, y },
            endPoint: { x, y },
            reversePoint: { x, y },
            curve: false
          });
        }
      } else if (command === "Q") {
        var [cx1, cy1, x, y] = values;
        var prevPoint = Point.getPrevPoint(points, points.length);
        if (prevPoint.curve) {
          var startPoint = { x, y };
          var endPoint = { x, y };
          var reversePoint = { x, y };
          points.push({
            command: "L",
            originalCommand: command,
            startPoint,
            endPoint,
            reversePoint,
            curve: false
          });
          prevPoint.endPoint = { x: cx1, y: cy1 };
        } else {
          if (nextSegment && nextSegment.command === "L") {
            prevPoint.curve = true;
            prevPoint.endPoint = { x: cx1, y: cy1 };
            var startPoint = { x, y };
            var reversePoint = { x, y };
            var endPoint = { x, y };
            points.push({
              command: "L",
              originalCommand: command,
              curve: false,
              startPoint,
              endPoint,
              reversePoint
            });
          } else {
            var startPoint = { x, y };
            var reversePoint = { x: cx1, y: cy1 };
            var endPoint = { x, y };
            points.push({
              command,
              originalCommand: command,
              curve: true,
              startPoint,
              endPoint,
              reversePoint
            });
          }
        }
      } else if (command === "T") {
        var [x, y] = values;
        var prevSegment = this.segments[index2 - 1];
        if (prevSegment && prevSegment.command === "Q") {
          var [cx1, cy1, sx, sy] = prevSegment.values;
          var prevPoint = Point.getPrevPoint(points, points.length);
          prevPoint.endPoint = Point.getReversePoint({ x: sx, y: sy }, { x: cx1, y: cy1 });
          var startPoint = { x, y };
          var endPoint = { x, y };
          var reversePoint = { x, y };
          points.push({
            command: "L",
            originalCommand: command,
            startPoint,
            endPoint,
            reversePoint,
            curve: false
          });
        }
      } else if (command === "C") {
        var prevPoint = Point.getPrevPoint(points, points.length);
        var [cx1, cy1, cx2, cy2, x, y] = values;
        var startPoint = { x, y };
        var reversePoint = { x: cx2, y: cy2 };
        var endPoint = { x, y };
        points.push({
          command,
          originalCommand: command,
          curve: true,
          startPoint,
          endPoint,
          reversePoint
        });
        if (prevPoint) {
          prevPoint.curve = true;
          prevPoint.endPoint = { x: cx1, y: cy1 };
        }
      } else if (command === "S") {
        var [x, y] = values;
        var prevSegment = this.segments[index2 - 1];
        if (prevSegment && prevSegment.command === "C") {
          var [cx2, cy2, sx, sy] = prevSegment.values;
          var prevPoint = Point.getPrevPoint(points, points.length);
          prevPoint.endPoint = Point.getReversePoint(prevPoint.startPoint, prevPoint.reversePoint);
          var startPoint = { x, y };
          var endPoint = { x, y };
          var reversePoint = { x: cx2, y: cy2 };
          points.push({
            command: "Q",
            originalCommand: command,
            startPoint,
            endPoint,
            reversePoint,
            curve: false
          });
        }
      } else if (command === "Z") {
        var prevPoint = Point.getPrevPoint(points, points.length);
        var firstPoint = Point.getFirstPoint(points, points.length);
        if (Point.isEqual(prevPoint.startPoint, firstPoint.startPoint)) {
          prevPoint.connected = true;
          prevPoint.endPoint = clone$1(firstPoint.endPoint);
          firstPoint.reversePoint = clone$1(prevPoint.reversePoint);
        }
        prevPoint.close = true;
      }
    }
    points = points.filter((p) => !!p);
    return points;
  }
  setSegments(index2, seg) {
    this.segments[index2] = seg;
  }
  getSegments(index2) {
    if (isNotUndefined(index2)) {
      return this.segments[index2];
    }
    return this.segments;
  }
  joinPath(segments, split = "") {
    var list2 = segments || this.segments;
    return list2.map((it) => {
      return `${it.command} ${it.values.length ? it.values.join(" ") : ""}`;
    }).join(split);
  }
  each(callback, isReturn = false) {
    var newSegments = this.segments.map((segment, index2) => {
      return callback.call(this, segment, index2);
    });
    if (isReturn) {
      return newSegments;
    } else {
      this.segments = newSegments;
    }
    return this;
  }
  _loop(m, isReturn = false) {
    return this.each(function(segment) {
      var v = segment.values;
      var c2 = segment.command;
      switch (c2) {
        case "M":
        case "L":
          var result = m(v, 0);
          segment.values = [result[0], result[1]];
          break;
        case "V":
          var result = m([+v[0], 0]);
          segment.values = [result[0]];
          break;
        case "H":
          var result = m([0, +v[0]]);
          segment.values = [result[1]];
          break;
        case "C":
        case "S":
        case "T":
        case "Q":
          for (var i = 0, len2 = v.length; i < len2; i += 2) {
            var result = m(v, i);
            segment.values[i] = result[0];
            segment.values[i + 1] = result[1];
          }
          break;
      }
      return segment;
    }, isReturn);
  }
  clone() {
    const path = new PathParser();
    path.resetSegments(this.segments.map((it) => {
      return {
        command: it.command,
        values: it.values.slice()
      };
    }));
    return path;
  }
  translate(tx, ty) {
    this.transformMat4(fromTranslation([], [tx, ty, 0]));
    return this;
  }
  translateTo(tx, ty) {
    return this.joinPath(this.transformMat4(fromTranslation([], [tx, ty, 0]), true));
  }
  scale(sx, sy) {
    this.transformMat4(fromScaling([], [sx, sy, 1]));
    return this;
  }
  scaleTo(sx, sy) {
    return this.joinPath(this.transformMat4(fromScaling([], [sx, sy, 1]), true));
  }
  scaleWith(width2, height2) {
    const newPath = this.clone();
    const rect2 = vertiesToRectangle(newPath.getBBox());
    newPath.translate(-rect2.x, -rect2.y);
    const scale2 = Math.min(width2 / rect2.width, height2 / rect2.height);
    return newPath.scale(scale2, scale2).translate(width2 / 2 - rect2.width / 2 * scale2, height2 / 2 - rect2.height / 2 * scale2);
  }
  scaleFunc(xScale = (x) => x, yScale = (y) => y) {
    return this.each(function(segment) {
      var v = segment.values;
      var c2 = segment.command;
      switch (c2) {
        case "M":
        case "L":
          segment.values = [xScale(v[0]), yScale(v[1])];
          break;
        case "C":
        case "Q":
          for (var i = 0, len2 = v.length; i < len2; i += 2) {
            segment.values[i] = xScale(v[i]);
            segment.values[i + 1] = yScale(v[i + 1]);
          }
          break;
      }
      return segment;
    });
  }
  rotate(angle, centerX = 0, centerY = 0) {
    const view = create$4();
    multiply$1(view, view, fromTranslation([], [centerX, centerY, 0]));
    multiply$1(view, view, fromZRotation([], degreeToRadian(angle)));
    multiply$1(view, view, fromTranslation([], negate([], [centerX, centerY, 0])));
    this.transformMat4(view);
    return this;
  }
  rotateTo(angle, centerX = 0, centerY = 0) {
    const view = create$4();
    multiply$1(view, view, fromTranslation([], [centerX, centerY, 0]));
    multiply$1(view, view, fromZRotation([], degreeToRadian(angle)));
    multiply$1(view, view, fromTranslation([], negate([], [centerX, centerY, 0])));
    return this.joinPath(this.transformMat4(view, true));
  }
  reflectionOrigin() {
    this.transformMat4(fromScaling([], [-1, -1, 0]));
    return this;
  }
  reflectionOriginTo() {
    return this.joinPath(this.transformMat4(fromScaling([], [-1, -1, 0]), true));
  }
  flipX() {
    this.transformMat4(fromScaling([], [1, -1, 0]));
    return this;
  }
  flipXTo() {
    return this.joinPath(this.transformMat4(fromScaling([], [1, -1, 0]), true));
  }
  flipY() {
    this.transformMat4(fromScaling([], [-1, 1, 0]));
    return this;
  }
  flipYTo() {
    return this.joinPath(this.transformMat4(fromScaling([], [-1, 1, 0]), true));
  }
  skewX(angle) {
    this.transformMat4(fromValues$1(1, Math.tan(degreeToRadian(angle)), 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1));
    return this;
  }
  skewXTo(angle) {
    return this.joinPath(this.transformMat4(fromValues$1(1, Math.tan(degreeToRadian(angle)), 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), true));
  }
  skewY(angle) {
    this.transformMat4(fromValues$1(1, 0, 0, 0, Math.tan(degreeToRadian(angle)), 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1));
    return this;
  }
  skewYTo(angle) {
    return this.joinPath(this.transformMat4(fromValues$1(1, 0, 0, 0, Math.tan(degreeToRadian(angle)), 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), true));
  }
  forEachGroup(callback) {
    const groupList = this.getGroup();
    for (let i = 0, len2 = groupList.length; i < len2; i++) {
      const group2 = groupList[i];
      callback(group2, i, groupList);
    }
  }
  forEach(callback) {
    this.forEachGroup((segments, index2, groupList) => {
      for (let i = 0, len2 = segments.length; i < len2; i++) {
        const segment = segments[i];
        callback(segment, i, segments, groupList, index2);
      }
    });
  }
  normalize() {
    const allSegments = [];
    const groupList = this.getGroup();
    groupList.forEach((group2) => {
      const newSegments = [];
      group2.segments.forEach(({ segment }, index2) => {
        var _a;
        const prevSegment = (_a = group2.segments[index2 - 1]) == null ? void 0 : _a.segment;
        if (segment.command === "M") {
          newSegments.push(segment);
          return;
        } else if (segment.command === "L") {
          const localCurve = normalizeCurveForLine([
            [
              prevSegment.values[prevSegment.values.length - 2],
              prevSegment.values[prevSegment.values.length - 1],
              0
            ],
            [segment.values[0], segment.values[1], 0]
          ]);
          newSegments.push({
            command: "C",
            values: [
              localCurve[1][0],
              localCurve[1][1],
              localCurve[2][0],
              localCurve[2][1],
              localCurve[3][0],
              localCurve[3][1]
            ]
          });
          return;
        } else if (segment.command === "C") {
          newSegments.push(segment);
        } else if (segment.command === "Q") {
          const localCurve = normalizeCurveForQuard([
            [
              prevSegment.values[prevSegment.values.length - 2],
              prevSegment.values[prevSegment.values.length - 1],
              0
            ],
            [segment.values[0], segment.values[1], 0],
            [segment.values[2], segment.values[3], 0]
          ]);
          newSegments.push({
            command: "C",
            values: [
              localCurve[1][0],
              localCurve[1][1],
              localCurve[2][0],
              localCurve[2][1],
              localCurve[3][0],
              localCurve[3][1]
            ]
          });
        } else if (segment.command === "Z") {
          newSegments.push(segment);
        }
      });
      allSegments.push(...newSegments);
    });
    return PathParser.fromSegments(allSegments);
  }
  polygonal() {
    const pathList = this.toPathList();
    pathList.forEach((path) => {
      const newSegments = [];
      path.segments.forEach((segment, index2) => {
        const prevSegment = path.segments[index2 - 1];
        if (segment.command === "M") {
          newSegments.push(segment);
        } else if (segment.command === "L") {
          newSegments.push(segment);
        } else if (segment.command === "C") {
          newSegments.push(...polygonalForCurve([
            prevSegment.values[prevSegment.values.length - 2],
            prevSegment.values[prevSegment.values.length - 1],
            0
          ], [segment.values[0], segment.values[1], 0], [segment.values[2], segment.values[3], 0], [segment.values[4], segment.values[5], 0]).map((point2) => ({
            command: "L",
            values: [point2[0], point2[1], 0]
          })));
        } else if (segment.command === "Q") {
          newSegments.push(...polygonalForCurve(...normalizeCurveForQuard([
            [
              prevSegment.values[prevSegment.values.length - 2],
              prevSegment.values[prevSegment.values.length - 1],
              0
            ],
            [segment.values[0], segment.values[1], 0],
            [segment.values[2], segment.values[3], 0]
          ])).map((point2) => ({
            command: "L",
            values: [point2[0], point2[1], 0]
          })));
        } else if (segment.command === "Z") {
          newSegments.push(segment);
        }
      });
      path.resetSegments(newSegments);
    });
    return PathParser.joinPathList(pathList);
  }
  divideSegmentByCount(count = 1) {
    let allSegments = [];
    const groupList = this.getGroup();
    groupList.forEach((group2) => {
      const newSegments = [];
      group2.segments.forEach(({ segment }, index2) => {
        var _a;
        const prevSegment = (_a = group2.segments[index2 - 1]) == null ? void 0 : _a.segment;
        if (segment.command === "M") {
          newSegments.push(segment);
        } else if (segment.command === "L") {
          const linePoints = splitBezierPointsLineByCount([
            {
              x: prevSegment.values[prevSegment.values.length - 2],
              y: prevSegment.values[prevSegment.values.length - 1]
            },
            {
              x: segment.values[0],
              y: segment.values[1]
            }
          ], count);
          linePoints.forEach(([, end2]) => {
            newSegments.push(Segment.L(end2.x, end2.y));
          });
        } else if (segment.command === "Q") {
          const quardPoints = splitBezierPointsQuardByCount([
            {
              x: prevSegment.values[prevSegment.values.length - 2],
              y: prevSegment.values[prevSegment.values.length - 1]
            },
            {
              x: segment.values[0],
              y: segment.values[1]
            },
            {
              x: segment.values[2],
              y: segment.values[3]
            }
          ], count);
          quardPoints.forEach(([, middle2, end2]) => {
            newSegments.push(Segment.Q(middle2.x, middle2.y, end2.x, end2.y));
          });
        } else if (segment.command === "C") {
          const curvePoints = splitBezierPointsByCount([
            {
              x: prevSegment.values[prevSegment.values.length - 2],
              y: prevSegment.values[prevSegment.values.length - 1]
            },
            {
              x: segment.values[0],
              y: segment.values[1]
            },
            {
              x: segment.values[2],
              y: segment.values[3]
            },
            {
              x: segment.values[4],
              y: segment.values[5]
            }
          ], count);
          curvePoints.forEach(([, c1, c2, end2]) => {
            newSegments.push(Segment.C(c1.x, c1.y, c2.x, c2.y, end2.x, end2.y));
          });
        } else if (segment.command === "Z") {
          newSegments.push(segment);
        }
      });
      allSegments = allSegments.concat(newSegments);
    });
    return PathParser.fromSegments(allSegments);
  }
  getBBox() {
    let minX = Number.MAX_SAFE_INTEGER, minY = Number.MAX_SAFE_INTEGER;
    let maxX = Number.MIN_SAFE_INTEGER, maxY = Number.MIN_SAFE_INTEGER;
    this.each(function(segment, index2) {
      var v = segment.values;
      var c2 = segment.command;
      const prevSegment = this.segments[index2 - 1];
      switch (c2) {
        case "M":
        case "L":
          minX = Math.min(minX, v[0]);
          maxX = Math.max(maxX, v[0]);
          minY = Math.min(minY, v[1]);
          maxY = Math.max(maxY, v[1]);
          break;
        case "C":
          getCurveBBox([
            [
              prevSegment.values[prevSegment.values.length - 2],
              prevSegment.values[prevSegment.values.length - 1],
              0
            ],
            [v[0], v[1], 0],
            [v[2], v[3], 0],
            [v[4], v[5], 0]
          ]).forEach((p) => {
            minX = Math.min(minX, p[0]);
            maxX = Math.max(maxX, p[0]);
            minY = Math.min(minY, p[1]);
            maxY = Math.max(maxY, p[1]);
          });
          break;
        case "Q":
          getCurveBBox(normalizeCurveForQuard([
            [
              prevSegment.values[prevSegment.values.length - 2],
              prevSegment.values[prevSegment.values.length - 1],
              0
            ],
            [v[0], v[1], 0],
            [v[2], v[3], 0]
          ])).forEach((p) => {
            minX = Math.min(minX, p[0]);
            maxX = Math.max(maxX, p[0]);
            minY = Math.min(minY, p[1]);
            maxY = Math.max(maxY, p[1]);
          });
          break;
      }
      return segment;
    });
    return [
      [minX, minY, 0],
      [maxX, minY, 0],
      [maxX, maxY, 0],
      [minX, maxY, 0]
    ];
  }
  rect() {
    const bbox = this.getBBox();
    return {
      x: bbox[0][0],
      y: bbox[0][1],
      width: distance$1(bbox[0], bbox[1]),
      height: distance$1(bbox[0], bbox[3]),
      right: bbox[0][0] + distance$1(bbox[0], bbox[1]),
      bottom: bbox[0][1] + distance$1(bbox[0], bbox[3])
    };
  }
  getClosedPointInfo({ x, y }, count = 20) {
    let minDist = Number.MAX_SAFE_INTEGER;
    let targetInfo = {};
    let info = {};
    for (var i = 1, len2 = this.segments.length; i < len2; i++) {
      const segment = this.segments[i];
      const prev = this.segments[i - 1].values;
      const current = segment.values;
      const command = segment.command;
      const lastPoint = { x: prev[prev.length - 2], y: prev[prev.length - 1] };
      if (command === "C") {
        var points = [
          lastPoint,
          { x: current[0], y: current[1] },
          { x: current[2], y: current[3] },
          { x: current[4], y: current[5] }
        ];
        var curve = recoverBezier(...points, count);
        var t = curve(x, y);
        info = {
          segment,
          index: i,
          t,
          points,
          targetPoint: getBezierPoints(points, t).first[3]
        };
      } else if (command === "Q") {
        var points = [
          lastPoint,
          { x: current[0], y: current[1] },
          { x: current[2], y: current[3] }
        ];
        var curve = recoverBezierQuard(...points, count);
        var t = curve(x, y);
        info = {
          segment,
          index: i,
          t,
          points,
          targetPoint: getBezierPointsQuard(points, t).first[2]
        };
      } else if (command === "L") {
        var points = [lastPoint, { x: current[0], y: current[1] }];
        var curve = recoverBezierLine(...points, count);
        var t = curve(x, y);
        info = {
          segment,
          index: i,
          t,
          points,
          targetPoint: getBezierPointsLine(points, t).first[1]
        };
      }
      if (info) {
        var dist2 = Math.sqrt(Math.pow(info.targetPoint.x - x, 2) + Math.pow(info.targetPoint.y - y, 2));
        if (dist2 < minDist) {
          minDist = dist2;
          targetInfo = info;
        }
      }
    }
    return targetInfo;
  }
  getClosedPoint({ x, y }, count = 20) {
    const info = this.getClosedPointInfo({ x, y }, count);
    if (info.targetPoint) {
      return info.targetPoint;
    }
    return { x, y };
  }
  isPointInPath({ x, y }, dist$1 = 1) {
    const info = this.getClosedPointInfo({ x, y }, 20);
    if (info.targetPoint) {
      if (dist([info.targetPoint.x, info.targetPoint.y, 0], [x, y, 0]) <= dist$1) {
        return true;
      }
    }
    return false;
  }
  toString(split = "") {
    return this.joinPath(void 0, split);
  }
  toSVGString() {
    return this.d;
  }
  transformMat4(transformMatrix, isReturn = false) {
    return this.each(function(segment) {
      var v = segment.values;
      var c2 = segment.command;
      switch (c2) {
        case "M":
        case "L":
          var result = transformMat4([], [v[0], v[1], 0], transformMatrix);
          segment.values = [result[0], result[1]];
          break;
        case "C":
        case "Q":
          for (var i = 0, len2 = v.length; i < len2; i += 2) {
            var result = transformMat4([], [v[i], v[i + 1], 0], transformMatrix);
            segment.values[i] = result[0];
            segment.values[i + 1] = result[1];
          }
          break;
      }
      return segment;
    }, isReturn);
  }
  transform(customTransformFunction = ([x, y, z]) => [x, y, z]) {
    const bbox = vertiesToRectangle(this.getBBox());
    return this.each(function(segment) {
      var v = segment.values;
      var c2 = segment.command;
      switch (c2) {
        case "M":
        case "L":
        case "C":
        case "Q":
          for (var i = 0, len2 = v.length; i < len2; i += 2) {
            var result = customTransformFunction([v[i], v[i + 1], 0], { bbox });
            segment.values[i] = result[0];
            segment.values[i + 1] = result[1];
          }
          break;
      }
      return segment;
    });
  }
  invert(transformMatrix) {
    this.transformMat4(invert([], transformMatrix));
    return this;
  }
  round(k = 1) {
    this.each(function(segment) {
      segment.values = segment.values.map((it) => round(it, k));
      return segment;
    });
    return this;
  }
  reverseSegments(segments) {
    const newSegments = [];
    let lastIndex = segments.length - 1;
    for (var i = lastIndex; i > 0; i--) {
      const segment = segments[i];
      const v = segment.values;
      const c2 = segment.command;
      const prevSegment = segments[i - 1];
      const lastX = prevSegment.values[prevSegment.values.length - 2];
      const lastY = prevSegment.values[prevSegment.values.length - 1];
      switch (c2) {
        case "L":
          if (i === lastIndex) {
            newSegments.push(Segment.M(v[0], v[1]));
          }
          newSegments.push(Segment.L(lastX, lastY));
          break;
        case "C":
          if (i === lastIndex) {
            newSegments.push(Segment.M(v[4], v[5]));
          }
          newSegments.push(Segment.C(v[2], v[3], v[0], v[1], lastX, lastY));
          break;
        case "Q":
          if (i === lastIndex) {
            newSegments.push(Segment.M(v[2], v[3]));
          }
          newSegments.push(Segment.Q(v[0], v[1], lastX, lastY));
          break;
        case "Z":
          newSegments.push(segment);
          lastIndex = i - 1;
          break;
      }
    }
    if (newSegments[0].command === "Z") {
      newSegments.push(newSegments.shift());
    }
    return newSegments;
  }
  splitSegments() {
    const groupSegments = [];
    let newSegments = [];
    this.segments.forEach((s) => {
      if (s.command === "M") {
        newSegments = [s];
        groupSegments.push(newSegments);
      } else {
        newSegments.push(s);
      }
    });
    return groupSegments;
  }
  reverse(...groupIndexList) {
    const groupSegments = this.splitSegments();
    const newSegments = [];
    if (groupIndexList.length === 0) {
      groupSegments.forEach((segments) => {
        newSegments.push.apply(newSegments, this.reverseSegments(segments));
      });
    } else {
      groupSegments.forEach((segments, index2) => {
        if (groupIndexList.includes(index2)) {
          newSegments.push.apply(newSegments, this.reverseSegments(segments));
        } else {
          newSegments.push.apply(newSegments, segments);
        }
      });
    }
    return this.resetSegments(newSegments);
  }
  reversePathStringByFunc(func) {
    const pathList = this.toPathList().map((p, index2) => {
      if (func(p, index2)) {
        return p.reverse();
      }
      return p;
    });
    return PathParser.joinPathList(pathList).toSVGString();
  }
  getCenterPointers() {
    let arr = [];
    let lastValues = [];
    this.segments.forEach((segment, index2) => {
      var v = segment.values;
      var c2 = segment.command;
      switch (c2) {
        case "M":
        case "L":
          arr.push({
            index: index2,
            pointer: [...segment.values, 0]
          });
          break;
        case "V":
          arr.push({
            index: index2,
            pointer: [v[0], lastValues.pop(), 0]
          });
          break;
        case "H":
          lastValues.pop();
          arr.push({
            index: index2,
            pointer: [lastValues.pop(), v[0], 0]
          });
          break;
        case "C":
        case "S":
        case "T":
        case "Q":
          arr.push({
            index: index2,
            pointer: [v[v.length - 2], v[v.length - 1], 0]
          });
          break;
      }
      lastValues = clone$1(v);
    });
    return arr;
  }
  get points() {
    return this.getCenterPointers();
  }
  getSamePointers(pointer, dist2 = 0) {
    return this.getCenterPointers().filter((p) => {
      if (distance$1(p.pointer, pointer) <= dist2) {
        return true;
      }
    });
  }
  getGroup() {
    const groupSegments = [];
    let newSegments = [];
    this.segments.forEach((segment, index2) => {
      if (segment.command === "M") {
        newSegments = [
          {
            index: index2,
            segment
          }
        ];
        groupSegments.push({
          index: index2,
          groupIndex: groupSegments.length,
          segments: newSegments
        });
      } else {
        newSegments.push({
          index: index2,
          segment
        });
      }
    });
    return groupSegments;
  }
  createGroupPath(index2) {
    var _a, _b;
    const path = new PathParser();
    path.resetSegments(((_b = (_a = this.getGroup()[index2]) == null ? void 0 : _a.segments) == null ? void 0 : _b.map((it) => {
      return it.segment;
    })) || []);
    return path;
  }
  toPathList() {
    return this.getGroup().map((group2) => {
      return PathParser.fromSegments(group2.segments.map((it) => it.segment));
    });
  }
  replaceSegment(index2, ...segments) {
    const newSegments = [...this.segments];
    newSegments.splice(index2, 1, ...segments);
    this.resetSegments(newSegments);
  }
  splitSegmentByPoint(pos, dist2 = 0) {
    const closedPointInfo = this.getClosedPointInfo(pos, dist2);
    if (closedPointInfo && closedPointInfo.t > 0 && closedPointInfo.t < 1) {
      switch (closedPointInfo.segment.command) {
        case "C":
          var list2 = getBezierPoints(closedPointInfo.points, closedPointInfo.t);
          var first = list2.first;
          var firstSegment = Segment.C(first[1].x, first[1].y, first[2].x, first[2].y, first[3].x, first[3].y);
          var second = list2.second;
          var secondSegment = Segment.C(second[1].x, second[1].y, second[2].x, second[2].y, second[3].x, second[3].y);
          this.replaceSegment(closedPointInfo.index, firstSegment, secondSegment);
          break;
        case "Q":
          var list2 = getBezierPointsQuard(closedPointInfo.points, closedPointInfo.t);
          var first = list2.first;
          var firstSegment = Segment.Q(first[1].x, first[1].y, first[2].x, first[2].y);
          var second = list2.second;
          var secondSegment = Segment.Q(second[1].x, second[1].y, second[2].x, second[2].y);
          this.replaceSegment(closedPointInfo.index, firstSegment, secondSegment);
          break;
        case "L":
          var list2 = getBezierPointsLine(closedPointInfo.points, closedPointInfo.t);
          var first = list2.first;
          var firstSegment = Segment.L(first[1].x, first[1].y);
          var second = list2.second;
          var secondSegment = Segment.L(second[1].x, second[1].y);
          this.replaceSegment(closedPointInfo.index, firstSegment, secondSegment);
          break;
        default:
          return;
      }
      return closedPointInfo;
    }
  }
  toMultiSegmentPathList() {
    const paths = [];
    const group2 = this.getGroup();
    group2.forEach((group3) => {
      group3.segments.forEach((s, index2) => {
        var _a;
        const prevSegment = group3.segments[index2 - 1];
        const lastValues = ((_a = prevSegment == null ? void 0 : prevSegment.segment) == null ? void 0 : _a.values) || [];
        const lastX = lastValues[lastValues.length - 2];
        const lastY = lastValues[lastValues.length - 1];
        const values = s.segment.values;
        if (s.segment.command === "M")
          ;
        else if (s.segment.command === "L") {
          paths.push(new PathParser(`M ${lastX} ${lastY}L ${values.join(" ")}`));
        } else if (s.segment.command === "C") {
          paths.push(new PathParser(`M ${lastX} ${lastY}C ${values.join(" ")}`));
        } else if (s.segment.command === "Q") {
          paths.push(new PathParser(`M ${lastX} ${lastY}Q ${values.join(" ")}`));
        } else
          ;
      });
    });
    return paths;
  }
  simplify(tolerance = 0.1) {
    const newGroupSegments = [];
    const groupList = this.getGroup();
    groupList.forEach((group2) => {
      const points = [
        ...group2.segments.filter((it) => it.segment.command.toLowerCase() !== "z").map((it) => {
          return {
            x: it.segment.values[0],
            y: it.segment.values[1]
          };
        })
      ];
      const newPoints = Point.simply(points, tolerance);
      const newSegments = [];
      newPoints.forEach((p, index2) => {
        if (index2 === 0) {
          newSegments.push(Segment.M(p.x, p.y));
        } else {
          newSegments.push(Segment.L(p.x, p.y));
        }
      });
      newGroupSegments.push(...newSegments);
    });
    return PathParser.fromSegments(newGroupSegments);
  }
  smooth(error = 50) {
    let newGroupSegments = [];
    const groupList = this.getGroup();
    groupList.forEach((group2) => {
      const points = [
        ...group2.segments.filter((it) => it.segment.command.toLowerCase() !== "z").map((it) => {
          return [...it.segment.values, 0];
        })
      ];
      const bezierCurve = fitCurve(points, error);
      const newSegments = [];
      bezierCurve.forEach((curve, index2) => {
        if (index2 === 0) {
          newSegments.push(Segment.M(...curve[0]));
        }
        newSegments.push(Segment.C(curve[1][0], curve[1][1], curve[2][0], curve[2][1], curve[3][0], curve[3][1]));
      });
      if (group2.segments[group2.segments.length - 1].segment.command.toLowerCase() === "z") {
        newSegments.push(Segment.Z());
      }
      newGroupSegments = newGroupSegments.concat(newSegments);
    });
    return PathParser.fromSegments(newGroupSegments);
  }
  cardinalSplines(tension = 0.5) {
    const newGroupSegments = [];
    const groupList = this.getGroup();
    groupList.forEach((group2) => {
      const points = [
        ...group2.segments.filter((it) => it.segment.command.toLowerCase() !== "z").map((it) => {
          return [...it.segment.values, 0];
        })
      ];
      const newPoints = [];
      points.forEach((point2, index2) => {
        const prevPoint = points[index2 - 1];
        const nextPoint = points[index2 + 1];
        if (index2 === 0) {
          newPoints.push({ point: point2 });
        } else if (index2 === points.length - 1) {
          const firstPoint = points[0];
          if (equals$1(firstPoint, point2)) {
            const p0 = prevPoint;
            const p1 = point2;
            const p2 = points[1];
            const V1 = div$1([], subtract([], p2, p0), [2, 2, 1]);
            const V3 = multiply([], V1, [1 - tension, 1 - tension, 1]);
            const V2 = negate([], V3);
            newPoints.push({
              reversePoint: add$1([], p1, V2),
              point: p1,
              endPoint: add$1([], p1, V3)
            });
          } else {
            newPoints.push({ point: point2 });
          }
        } else {
          const p0 = prevPoint;
          const p1 = point2;
          const p2 = nextPoint;
          const V1 = div$1([], subtract([], p2, p0), [2, 2, 1]);
          const V3 = multiply([], V1, [1 - tension, 1 - tension, 1]);
          const V2 = negate([], V3);
          newPoints.push({
            reversePoint: add$1([], p1, V2),
            point: p1,
            endPoint: add$1([], p1, V3)
          });
        }
      });
      const newSegments = [];
      newPoints.forEach((p, index2) => {
        if (index2 === 0) {
          newSegments.push(Segment.M(p.point[0], p.point[1]));
        } else {
          const prevPoint = newPoints[index2 - 1] || newPoints[newPoints.length - 1];
          if (!prevPoint.endPoint) {
            if (index2 === 1) {
              const lastPoint = newPoints[newPoints.length - 1];
              if (lastPoint.endPoint) {
                newSegments.push(Segment.C(lastPoint.endPoint[0], lastPoint.endPoint[1], p.reversePoint[0], p.reversePoint[1], p.point[0], p.point[1]));
              } else {
                newSegments.push(Segment.Q(p.reversePoint[0], p.reversePoint[1], p.point[0], p.point[1]));
              }
            } else {
              newSegments.push(Segment.Q(p.reversePoint[0], p.reversePoint[1], p.point[0], p.point[1]));
            }
          } else if (!p.reversePoint) {
            newSegments.push(Segment.Q(prevPoint.endPoint[0], prevPoint.endPoint[1], p.point[0], p.point[1]));
          } else {
            newSegments.push(Segment.C(prevPoint.endPoint[0], prevPoint.endPoint[1], p.reversePoint[0], p.reversePoint[1], p.point[0], p.point[1]));
          }
        }
      });
      newGroupSegments.push(...newSegments);
    });
    const newPath = new PathParser();
    newPath.resetSegments(newGroupSegments);
    return newPath;
  }
  Z() {
    this.segments.push(Segment.Z());
    return this;
  }
  M(x, y) {
    this.segments.push(Segment.M(x, y));
    return this;
  }
  L(x, y) {
    this.segments.push(Segment.L(x, y));
    return this;
  }
  C(x1, y1, x2, y2, x, y) {
    this.segments.push(Segment.C(x1, y1, x2, y2, x, y));
    return this;
  }
  Q(x1, y1, x, y) {
    this.segments.push(Segment.Q(x1, y1, x, y));
    return this;
  }
  drawRect(x, y, width2, height2) {
    this.segments.push(Segment.M(x, y), Segment.L(x + width2, y), Segment.L(x + width2, y + height2), Segment.L(x, y + height2), Segment.L(x, y), Segment.Z());
    return this;
  }
  drawLine(x1, y1, x2, y2) {
    this.segments.push(Segment.M(x1, y1), Segment.L(x2, y2));
    return this;
  }
  drawCircleWithRect(x, y, width2, height2 = width2) {
    var segmentSize = 0.552284749831;
    const path = new PathParser();
    path.resetSegments([
      Segment.M(0, -1),
      Segment.C(segmentSize, -1, 1, -segmentSize, 1, 0),
      Segment.C(1, segmentSize, segmentSize, 1, 0, 1),
      Segment.C(-segmentSize, 1, -1, segmentSize, -1, 0),
      Segment.C(-1, -segmentSize, -segmentSize, -1, 0, -1),
      Segment.Z()
    ]);
    path.translate(1, 1).scale(width2 / 2, height2 / 2).translate(x, y);
    this.addPath(path);
    return this;
  }
  drawCircle(cx, cy, radius) {
    return this.drawCircleWithRect(cx - radius, cy - radius, radius * 2, radius * 2);
  }
  drawArc(rx, ry, xAxisRotation, largeArcFlag, sweepFlag, x, y) {
    const [x1, y1] = this.lastPoint;
    return this.addPath(PathParser.arcToCurve(x1, y1, rx, ry, xAxisRotation, largeArcFlag, sweepFlag, x, y));
  }
  get verties() {
    let arr = [];
    let lastValues = [];
    this.each(function(segment) {
      var v = segment.values;
      var c2 = segment.command;
      switch (c2) {
        case "M":
        case "L":
          arr.push([...segment.values, 0]);
          break;
        case "V":
          arr.push([v[0], lastValues.pop(), 0]);
          break;
        case "H":
          lastValues.pop();
          arr.push([lastValues.pop(), v[0], 0]);
          break;
        case "C":
        case "S":
        case "T":
        case "Q":
          for (var i = 0, len2 = v.length; i < len2; i += 2) {
            arr.push([v[i], v[i + 1], 0]);
          }
          break;
      }
      lastValues = v;
    });
    return arr;
  }
  get pathVerties() {
    const pathVerties = [];
    this.segments.forEach((segment, segmentIndex) => {
      const prevSegment = this.segments[segmentIndex - 1];
      const nextSegment = this.segments[segmentIndex + 1];
      if (segment.values.length > 0) {
        const arr = segment.values;
        for (var i = 0, len2 = arr.length; i < len2; i += 2) {
          pathVerties.push({
            prevSegment,
            nextSegment,
            segment,
            segmentIndex,
            valueIndex: i,
            vertex: [arr[i], arr[i + 1], 0],
            x: arr[i],
            y: arr[i + 1]
          });
        }
      }
    });
    return pathVerties;
  }
  get d() {
    return this.toString().trim();
  }
  get closed() {
    return this.segments.some((segment) => segment.command === "Z") && equals(this.lastPoint, this.firstPoint);
  }
  get opened() {
    return !this.closed;
  }
  get length() {
    let totalLength = 0;
    const group2 = this.getGroup();
    group2.forEach((group3) => {
      group3.segments.forEach((s, index2) => {
        var _a;
        const prevSegment = group3.segments[index2 - 1];
        const lastValues = ((_a = prevSegment == null ? void 0 : prevSegment.segment) == null ? void 0 : _a.values) || [];
        const lastX = lastValues[lastValues.length - 2];
        const lastY = lastValues[lastValues.length - 1];
        const values = s.segment.values;
        if (s.segment.command === "M")
          ;
        else if (s.segment.command === "L") {
          totalLength += getDist(lastX, lastY, values[0], values[1]);
        } else if (s.segment.command === "C") {
          totalLength += getCurveDist(lastX, lastY, values[0], values[1], values[2], values[3], values[4], values[5]);
        } else if (s.segment.command === "Q") {
          totalLength += getQuardDist(lastX, lastY, values[0], values[1], values[2], values[3]);
        } else
          ;
      });
    });
    return totalLength;
  }
  get lengthList() {
    let totalLengthList = [];
    const group2 = this.getGroup();
    group2.forEach((group3, groupIndex) => {
      group3.segments.forEach((s, index2) => {
        var _a;
        const prevSegment = group3.segments[index2 - 1];
        const lastValues = ((_a = prevSegment == null ? void 0 : prevSegment.segment) == null ? void 0 : _a.values) || [];
        const lastX = lastValues[lastValues.length - 2];
        const lastY = lastValues[lastValues.length - 1];
        const values = s.segment.values;
        if (s.segment.command === "M")
          ;
        else if (s.segment.command === "L") {
          totalLengthList.push({
            groupIndex,
            segmentIndex: index2,
            length: getDist(lastX, lastY, values[0], values[1])
          });
        } else if (s.segment.command === "C") {
          totalLengthList.push({
            groupIndex,
            segmentIndex: index2,
            length: getCurveDist(lastX, lastY, values[0], values[1], values[2], values[3], values[4], values[5])
          });
        } else if (s.segment.command === "Q") {
          totalLengthList.push({
            groupIndex,
            segmentIndex: index2,
            length: getQuardDist(lastX, lastY, values[0], values[1], values[2], values[3])
          });
        } else
          ;
      });
    });
    return totalLengthList;
  }
  get lastSegment() {
    const segment = this.segments[this.segments.length - 1];
    if (segment.command !== "Z") {
      return segment;
    }
    return this.segments[this.segments.length - 2];
  }
  get lastPoint() {
    const values = this.lastSegment.values;
    return [values[values.length - 2], values[values.length - 1]];
  }
  get firstSegment() {
    const segment = this.segments[0];
    return segment;
  }
  get firstPoint() {
    const values = this.firstSegment.values;
    return [values[0], values[1]];
  }
  static joinPathList(pathList = []) {
    const newPath = PathParser.fromSVGString();
    pathList.forEach((path) => {
      newPath.addPath(path);
    });
    return newPath;
  }
  static fromSegments(segments) {
    const path = new PathParser();
    path.resetSegments(segments);
    return path;
  }
  static fromStructuredVerties(verties) {
    const path = new PathParser();
    const segments = [];
    verties.forEach((v) => {
      if (!segments[v.segmentIndex]) {
        segments[v.segmentIndex] = {
          command: v.segment.command,
          values: []
        };
      }
      if (segments[v.segmentIndex].command !== PathSegmentType.CLOSEPATH) {
        segments[v.segmentIndex].values[v.valueIndex] = v.vertex[0];
        segments[v.segmentIndex].values[v.valueIndex + 1] = v.vertex[1];
      }
    });
    path.resetSegments(segments);
    return path;
  }
  static fromSVGString(d = "") {
    return new PathParser(d);
  }
  static makeRect(x, y, width2, height2) {
    return PathParser.fromSVGString().drawRect(x, y, width2, height2);
  }
  static makeLine(x, y, x2, y2) {
    return PathParser.fromSVGString().drawLine(x, y, x2, y2);
  }
  static makeCircle(x, y, width2, height2) {
    return PathParser.fromSVGString().drawCircleWithRect(x, y, width2, height2);
  }
  static makePathByPoints(points = []) {
    const segments = points.map((p, index2) => {
      if (index2 === 0) {
        return Segment.M(p.x, p.y);
      } else {
        return Segment.L(p.x, p.y);
      }
    });
    segments.push(Segment.Z());
    return PathParser.fromSegments(segments);
  }
  static makePathByVerties(verties = [], isClosed = true) {
    const segments = verties.map((v, index2) => {
      if (index2 === 0) {
        return Segment.M(v[0], v[1]);
      } else {
        return Segment.L(v[0], v[1]);
      }
    });
    if (isClosed) {
      segments.push(Segment.Z());
    }
    return PathParser.fromSegments(segments);
  }
  static makePolygon(width2, height2, count = 3) {
    const segments = [];
    const centerX = 1 / 2;
    const centerY = 1 / 2;
    for (var i = 0; i < count; i++) {
      var angle = i / count * Math.PI * 2 - Math.PI / 2;
      var x = Math.cos(angle) * centerX + centerX;
      var y = Math.sin(angle) * centerY + centerY;
      if (i === 0) {
        segments.push(Segment.M(x, y));
      } else {
        segments.push(Segment.L(x, y));
      }
    }
    segments.push(Segment.L(segments[0].values[0], segments[0].values[1]));
    segments.push(Segment.Z());
    return PathParser.fromSegments(segments).scale(width2, height2);
  }
  static makeStar(width2, height2, count = 5, radius = 0.5) {
    const segments = [];
    const centerX = 1 / 2;
    const centerY = 1 / 2;
    const outerRadius = Math.min(centerX, centerY);
    const innerRadius = outerRadius * radius;
    const npoints = count * 2;
    let firstX, firstY = 0;
    for (var i = 0; i < npoints; i++) {
      var angle = i / npoints * Math.PI * 2 - Math.PI / 2;
      var radius = i % 2 === 0 ? outerRadius : innerRadius;
      var x = Math.cos(angle) * radius + centerX;
      var y = Math.sin(angle) * radius + centerY;
      if (i === 0) {
        segments.push(Segment.M(x, y));
        firstX = x;
        firstY = y;
      } else {
        segments.push(Segment.L(x, y));
      }
    }
    segments.push(Segment.L(firstX, firstY));
    segments.push(Segment.Z());
    return PathParser.fromSegments(segments).scale(width2, height2);
  }
  static makeCurvedStar(width2, height2, count = 5, radius = 0.5, tension = 0.5) {
    const starPath = PathParser.makeStar(width2, height2, count, radius);
    return starPath.cardinalSplines(tension);
  }
  static arcToCurve(x1, y1, rx, ry, xAxisRotation, largeArcFlag, sweepFlag, x2, y2) {
    const bezierCurveList = arcToBezier({
      px: x1,
      py: y1,
      cx: x2,
      cy: y2,
      rx,
      ry,
      xAxisRotation,
      largeArcFlag,
      sweepFlag
    });
    const path = new PathParser();
    path.M(x1, y1);
    bezierCurveList.forEach((bezierCurve) => {
      path.C(bezierCurve.x1, bezierCurve.y1, bezierCurve.x2, bezierCurve.y2, bezierCurve.x, bezierCurve.y);
    });
    return path;
  }
  toCurveList() {
    const curveList = [];
    this.segments.forEach((segment, index2) => {
      if (index2 > 0) {
        const prevSegment = this.segments[index2 - 1];
        const lastPoint = [
          prevSegment.values[prevSegment.values.length - 2],
          prevSegment.values[prevSegment.values.length - 1]
        ];
        const points = [
          xy$2(lastPoint),
          xy$2([segment.values[0], segment.values[1]]),
          xy$2([segment.values[2], segment.values[3]]),
          xy$2([segment.values[4], segment.values[5]])
        ];
        curveList.push({
          points,
          curveFunction: createBezier(...points)
        });
      }
    });
    return curveList;
  }
  toInterpolateFunction() {
    const curveList = this.normalize().toCurveList().map((curve) => {
      return {
        points: curve.points,
        curveFunction: curve.curveFunction,
        start: curve.points[0].x,
        end: curve.points[curve.points.length - 1].x
      };
    });
    return (t) => {
      const currentCurve = curveList.find((it) => {
        return it.start <= t && t <= it.end;
      });
      if (currentCurve) {
        const point2 = currentCurve.curveFunction(t);
        return point2.y;
      }
      if (t === 0) {
        return curveList[0].points[0].y;
      }
      const points = curveList[curveList.length - 1].points;
      return points[points.length - 1].y;
    };
  }
}
function easeOutElastic() {
  return (rate) => {
    return Math.pow(2, -10 * rate) * Math.sin((rate - 0.1) * 5 * Math.PI) + 1;
  };
}
const stepTimingFunction = (step2 = 1, direction2 = "end") => {
  var stepDist = 1 / step2;
  return function(rate) {
    let pos = 0;
    const offset = round(rate / stepDist, 1e7);
    if (direction2 == "start") {
      pos = Math.ceil(offset);
    } else if (direction2 == "end") {
      if (rate === 0)
        return 0;
      else if (rate === 1)
        return 1;
      pos = Math.ceil(offset) - 1;
    }
    return Math.min(Math.max(stepDist * pos, 0), 1);
  };
};
function step(step2 = 1, direction2 = "end") {
  return stepTimingFunction(step2, direction2);
}
function stepStart() {
  return stepTimingFunction(1, "start");
}
function stepEnd() {
  return stepTimingFunction(1, "end");
}
var timingFunctions = {
  step,
  "step-start": stepStart,
  "step-end": stepEnd,
  stepStart,
  stepEnd,
  "ease-out-elastic": easeOutElastic,
  easeOutElastic
};
function createTimingFunction(timing = "linear") {
  var [funcName] = timing.split("(").map((it) => it.trim());
  var func = timingFunctions[funcName];
  if (func) {
    var args2 = timing.split("(")[1].split(")")[0].split(",").map((it) => it.trim());
    return func(...args2);
  } else {
    return createCurveFunction(timing);
  }
}
function createCurveFunction(timing) {
  var func = createBezierForPattern(timing);
  return (rate) => {
    return func(rate).y;
  };
}
const DEFINED_ANGLES$2 = {
  "to top": 0,
  "to top right": 45,
  "to right": 90,
  "to bottom right": 135,
  "to bottom": 180,
  "to bottom left": 225,
  "to left": 270,
  "to top left": 315
};
class Gradient extends ImageResource {
  isGradient() {
    return true;
  }
  toString() {
    return "none";
  }
  getDefaultObject(obj2 = {}) {
    return __spreadValues({
      itemType: "image-resource",
      type: "gradient",
      colorsteps: []
    }, obj2);
  }
  toCloneObject() {
    return __spreadProps(__spreadValues({}, super.toCloneObject()), {
      colorsteps: this.json.colorsteps.map((color2) => color2.clone())
    });
  }
  convert(json) {
    if (json.colorsteps[0] instanceof ColorStep)
      ;
    else {
      json.colorsteps = json.colorsteps.map((c2) => new ColorStep(c2));
    }
    return json;
  }
  calculateAngle() {
    var angle = this.json.angle;
    return isUndefined(DEFINED_ANGLES$2[angle]) ? angle : DEFINED_ANGLES$2[angle] || 0;
  }
  addColorStep(colorstep, isSort = true) {
    this.json.colorsteps.push(colorstep);
    if (isSort)
      this.sortColorStep();
    return colorstep;
  }
  pickColorStep(percent) {
    var colorsteps = this.colorsteps;
    if (!colorsteps.length) {
      return { percent: 0, color: "rgba(0,0,0,0)" };
    }
    if (percent < colorsteps[0].percent) {
      return {
        percent,
        color: colorsteps[0].color
      };
    }
    var lastIndex = colorsteps.length - 1;
    if (colorsteps[lastIndex].percent < percent) {
      return {
        percent,
        color: colorsteps[lastIndex].color
      };
    }
    for (var i = 0, len2 = colorsteps.length - 1; i < len2; i++) {
      var currentStep = colorsteps[i];
      var nextStep = colorsteps[i + 1];
      if (currentStep.percent <= percent && percent <= nextStep.percent) {
        const timing = nextStep.timing;
        switch (timing.name) {
          case TimingFunction.STEPS:
            var func = step(timing.count, timing.direction);
            break;
          case TimingFunction.PATH:
            var func = PathParser.fromSVGString(timing.d).toInterpolateFunction();
          default:
            var func = createTimingFunction(timing.matchedString);
            break;
        }
        var stopPercent = (percent - currentStep.percent) / (nextStep.percent - currentStep.percent);
        const color2 = mix(currentStep.color, nextStep.color, func(stopPercent));
        return {
          percent,
          color: color2
        };
      }
    }
  }
  insertColorStep(percent, startColor = "rgba(216,216,216,0)", endColor = "rgba(216,216,216,1)") {
    var colorsteps = this.colorsteps;
    if (!colorsteps.length) {
      this.addColorStepList([
        new ColorStep({ color: startColor, percent, index: 0 }),
        new ColorStep({ color: endColor, percent: 100, index: 100 })
      ]);
      return;
    }
    if (percent < colorsteps[0].percent) {
      colorsteps[0].index = 1;
      this.addColorStep(new ColorStep({ index: 0, color: colorsteps[0].color, percent }));
      return 0;
    }
    var lastIndex = colorsteps.length - 1;
    if (colorsteps[lastIndex].percent < percent) {
      var color2 = colorsteps[lastIndex].color;
      var index2 = colorsteps[lastIndex].index + 1;
      this.addColorStep(new ColorStep({ index: index2, color: color2, percent }));
      return index2;
    }
    for (var i = 0, len2 = colorsteps.length - 1; i < len2; i++) {
      var step2 = colorsteps[i];
      var nextStep = colorsteps[i + 1];
      if (step2.percent <= percent && percent <= nextStep.percent) {
        var color2 = mix(step2.color, nextStep.color, (percent - step2.percent) / (nextStep.percent - step2.percent), "rgb");
        this.addColorStep(new ColorStep({ index: step2.index + 1, color: color2, percent }));
        return i + 1;
      }
    }
  }
  sortColorStep() {
    var children2 = this.colorsteps;
    children2.sort((a, b) => {
      if (a.percent > b.percent)
        return 1;
      if (a.percent < b.percent)
        return -1;
      if (a.percent == b.percent) {
        if (a.index === b.index)
          return 0;
        return a.index > b.index ? 1 : -1;
      }
    });
    children2.forEach((it, index2) => {
      it.index = index2 * 100;
    });
  }
  sortToRight() {
    var children2 = this.colorsteps;
    const length2 = children2.length;
    const unit = 100 / length2;
    children2.forEach((it, index2) => {
      it.percent = unit * (index2 + 1);
    });
    this.sortColorStep();
  }
  sortToLeft() {
    var children2 = this.colorsteps;
    const length2 = children2.length;
    const unit = 100 / length2;
    children2.forEach((it, index2) => {
      it.percent = unit * index2;
    });
    this.sortColorStep();
  }
  addColorStepList(colorstepList = []) {
    colorstepList.forEach((c2) => {
      this.addColorStep(c2, false);
    });
    this.sortColorStep();
  }
  getColorStep(id) {
    return this.json.colorsteps.filter((c2) => c2.id == id)[0];
  }
  clear(...args2) {
    if (args2.length) {
      this.json.colorsteps.splice(+args2[0], 1);
    } else {
      this.json.colorsteps = [];
    }
  }
  removeColorStepByIndex(index2) {
    this.json.colorsteps.splice(index2, 1);
  }
  removeColorStep(id) {
    this.json.colorsteps = this.json.colorsteps.filter((it) => it.id != id);
  }
  get colorsteps() {
    return this.json.colorsteps;
  }
  makeTimingString(timing, timingCount = 1) {
    switch (timing.name) {
      case TimingFunction.LINEAR:
        return ``;
      case TimingFunction.EASE:
      case TimingFunction.EASE_IN:
      case TimingFunction.EASE_OUT:
      case TimingFunction.EASE_IN_OUT:
        return `${timing.name} ${timingCount}`;
      case TimingFunction.STEPS:
        return `steps(${timing.count}, ${timing.direction})`;
      case TimingFunction.PATH:
        return `path(${timing.d}) ${timingCount}`;
      default:
        return `cubic-bezier(${timing.x1}, ${timing.y1}, ${timing.x2}, ${timing.y2}) ${timingCount}`;
    }
  }
  getColorString() {
    return this.colorsteps.map((it) => {
      const { color: color2, percent, timing, timingCount } = it;
      return `${color2} ${percent}% ${this.makeTimingString(timing, timingCount)}`;
    }).join(",");
  }
  static makeColorStepList(colorsteps) {
    const results = [];
    colorsteps.forEach((it, index2) => {
      const { color: color2, percent, timing, timingCount } = it;
      var prevColorStep = colorsteps[index2 - 1];
      if (index2 === 0) {
        results.push({ color: color2, percent });
        return results;
      }
      switch (timing.name) {
        case TimingFunction.STEPS:
          var func = step(timing.count, timing.direction);
          var localColorSteps = [];
          for (var i = 0; i <= timing.count; i++) {
            var stopPercent = prevColorStep.percent + (percent - prevColorStep.percent) * (i / timing.count);
            var stopColor = mix(prevColorStep.color, color2, func(i / timing.count));
            localColorSteps.push({ percent: stopPercent, color: stopColor });
          }
          localColorSteps.forEach((obj2, index3) => {
            if (index3 === 0) {
              results.push({
                percent: prevColorStep.percent,
                color: obj2.color
              });
              results.push(obj2);
            } else {
              const prev = localColorSteps[index3 - 1];
              results.push({ percent: prev.percent, color: obj2.color });
              results.push(obj2);
            }
          });
          break;
        case TimingFunction.PATH:
          var func = PathParser.fromSVGString(timing.d).toInterpolateFunction();
          var localColorSteps = [];
          for (var i = 0; i <= timingCount; i++) {
            const stopPercent2 = prevColorStep.percent + (percent - prevColorStep.percent) * (i / timingCount);
            const stopColor2 = mix(prevColorStep.color, color2, func(i / timingCount));
            localColorSteps.push({ percent: stopPercent2, color: stopColor2 });
          }
          results.push(...localColorSteps);
          break;
        default:
          var func = createTimingFunction(timing.matchedString);
          var localColorSteps = [];
          for (var i = 0; i <= timingCount; i++) {
            const stopPercent2 = prevColorStep.percent + (percent - prevColorStep.percent) * (i / timingCount);
            const stopColor2 = mix(prevColorStep.color, color2, func(i / timingCount));
            localColorSteps.push({ percent: stopPercent2, color: stopColor2 });
          }
          results.push(...localColorSteps);
          break;
      }
    });
    return results;
  }
  static toCSSColorString(colorsteps = [], unit = "%", maxValue = 100) {
    const list2 = Gradient.makeColorStepList(colorsteps);
    return list2.map((it) => {
      const { color: color2, percent } = it;
      const pos = percent / 100 * maxValue;
      return `${color2} ${pos}${unit}`;
    }).join(",");
  }
  static parseColorSteps(colors2) {
    return colors2.map((it, index2) => {
      var _a, _b, _c;
      if (it.length === 1) {
        const prev = ((_a = colors2[index2 - 1]) == null ? void 0 : _a[1]) || { parsed: { value: 0 } };
        const next = ((_b = colors2[index2 + 1]) == null ? void 0 : _b[1]) || { parsed: { value: 100 } };
        let percent = 0;
        if (!colors2[index2 - 1]) {
          percent = 0;
        } else if (!colors2[index2 + 1]) {
          percent = 100;
        } else {
          percent = prev.parsed.value + (next.parsed.value - prev.parsed.value) * 0.5;
        }
        return new ColorStep({
          color: it[0].matchedString,
          percent,
          unit: "%",
          timing: parseOneValue("linear").parsed,
          timingCount: 1
        });
      }
      if (it.length === 2) {
        return new ColorStep({
          color: it[0].matchedString,
          percent: it[1].parsed.value,
          unit: it[1].parsed.unit,
          timing: parseOneValue("linear").parsed,
          timingCount: 1
        });
      } else if (it.length === 3) {
        if (it[2].parsed.funcType === FuncType.TIMING) {
          return new ColorStep({
            color: it[0].matchedString,
            percent: it[1].parsed.value,
            unit: it[1].parsed.unit,
            timing: it[2].parsed,
            timingCount: (_c = it[3]) == null ? void 0 : _c.parsed.value
          });
        }
        return new ColorStep({
          color: it[0].matchedString,
          percent: it[2].parsed.value,
          unit: it[2].parsed.unit,
          timing: parseOneValue(`steps(1, start)`).parsed
        });
      } else if (it.length === 4) {
        return new ColorStep({
          color: it[0].matchedString,
          percent: it[1].parsed.value,
          unit: it[1].parsed.unit,
          timing: it[2].parsed,
          timingCount: it[3].parsed.value
        });
      }
    });
  }
}
const DEFINED_POSITIONS$1 = {
  ["center"]: true,
  ["top"]: true,
  ["left"]: true,
  ["right"]: true,
  ["bottom"]: true
};
const DEFINED_ANGLES$1 = {
  "to top": 0,
  "to top right": 45,
  "to right": 90,
  "to bottom right": 135,
  "to bottom": 180,
  "to bottom left": 225,
  "to left": 270,
  "to top left": 315
};
class ConicGradient extends Gradient {
  getDefaultObject(obj2 = {}) {
    return super.getDefaultObject(__spreadValues({
      type: "conic-gradient",
      angle: 0,
      radialPosition: [Position.CENTER, Position.CENTER]
    }, obj2));
  }
  toCloneObject() {
    return __spreadProps(__spreadValues({}, super.toCloneObject()), {
      angle: this.json.angle,
      radialPosition: clone$1(this.json.radialPosition)
    });
  }
  hasAngle() {
    return true;
  }
  pickColorStep(percent) {
    return super.pickColorStep((percent + 100) % 100);
  }
  getStartEndPoint(result) {
    let startPoint, endPoint, shapePoint;
    let [rx, ry] = this.json.radialPosition;
    const backRect = result.backRect;
    const backVerties = rectToVerties(backRect.x, backRect.y, backRect.width, backRect.height);
    if (rx == "center")
      rx = Length.percent(50);
    if (ry == "center")
      ry = Length.percent(50);
    const newRx = rx.toPx(backRect.width);
    const newRy = ry.toPx(backRect.height);
    const centerPoisiton = [
      backRect.x + newRx.value,
      backRect.y + newRy.value,
      0
    ];
    let topLeftPoint = backVerties[0];
    let topRightPoint = backVerties[1];
    let bottomLeftPoint = backVerties[3];
    let bottomRightPoint = backVerties[2];
    const topLeftDist = dist(centerPoisiton, topLeftPoint);
    const topRightDist = dist(centerPoisiton, topRightPoint);
    const bottomLeftDist = dist(centerPoisiton, bottomLeftPoint);
    const bottomRightDist = dist(centerPoisiton, bottomRightPoint);
    startPoint = clone(centerPoisiton);
    const dist$1 = Math.max(topLeftDist, topRightDist, bottomLeftDist, bottomRightDist);
    endPoint = fromValues(startPoint[0] + dist$1, startPoint[1], startPoint[2]);
    shapePoint = fromValues(startPoint[0], startPoint[1] - dist$1, startPoint[2]);
    return {
      startPoint,
      endPoint,
      shapePoint
    };
  }
  toString() {
    var colorString = this.getColorString();
    var opt = [];
    var json = this.json;
    var conicAngle = json.angle;
    var conicPosition = json.radialPosition || Position.CENTER;
    conicPosition = DEFINED_POSITIONS$1[conicPosition] ? conicPosition : conicPosition.join(" ");
    if (isNotUndefined(conicAngle)) {
      conicAngle = +(DEFINED_ANGLES$1[conicAngle] || conicAngle);
      opt.push(`from ${conicAngle}deg`);
    }
    if (conicPosition) {
      opt.push(`at ${conicPosition}`);
    }
    var optString = opt.length ? opt.join(" ") + "," : "";
    return `${json.type}(${optString} ${colorString})`;
  }
  toCSSString() {
    if (this.colorsteps.length === 0)
      return "";
    var colorString = ConicGradient.toCSSColorString(this.colorsteps, "deg", 360);
    var opt = [];
    var json = this.json;
    var conicAngle = json.angle;
    var conicPosition = json.radialPosition || Position.CENTER;
    conicPosition = DEFINED_POSITIONS$1[conicPosition] ? conicPosition : conicPosition.join(" ");
    if (isNotUndefined(conicAngle)) {
      conicAngle = +(DEFINED_ANGLES$1[conicAngle] || conicAngle);
      opt.push(`from ${conicAngle}deg`);
    }
    if (conicPosition) {
      opt.push(`at ${conicPosition}`);
    }
    var optString = opt.length ? opt.join(" ") + "," : "";
    return `${json.type}(${optString} ${colorString})`;
  }
  static parse(str) {
    const result = parseOneValue(str);
    var opt = {
      angle: 0,
      radialPosition: ["center", "center"]
    };
    let [options2, ...colors2] = result.parameters;
    if (options2[0].func !== FuncType.COLOR) {
      let hasFrom = false;
      let hasAt = false;
      let positions = [];
      let angle = [];
      options2.forEach((it) => {
        if (it.func === FuncType.KEYWORD && it.matchedString === "from") {
          hasFrom = true;
        } else if (it.func === FuncType.KEYWORD && it.matchedString === "at") {
          hasAt = true;
        } else if (hasAt) {
          positions.push(it);
        } else if (hasFrom) {
          angle.push(it);
        }
      });
      opt.radialPosition = positions.map((it) => {
        if (it.func === FuncType.KEYWORD) {
          switch (it.matchedString) {
            case "top":
              return Length.percent(0);
            case "left":
              return Length.percent(0);
            case "right":
              return Length.percent(100);
            case "bottom":
              return Length.percent(100);
            case "center":
              return Length.percent(50);
          }
        }
        return it.parsed;
      });
      if (angle.length) {
        opt.angle = angle[0].parsed.value;
      }
    } else {
      colors2 = result.parameters;
    }
    const colorsteps = ConicGradient.parseColorSteps(colors2);
    return new ConicGradient(__spreadProps(__spreadValues({}, opt), { colorsteps }));
  }
}
const DEFINED_DIRECTIONS = {
  0: "to top",
  45: "to top right",
  90: "to right",
  135: "to bottom right",
  180: "to bottom",
  225: "to bottom left",
  270: "to left",
  315: "to top left"
};
const DEFINED_ANGLES = {
  "to top": 0,
  "to top right": 45,
  "to right": 90,
  "to bottom right": 135,
  "to bottom": 180,
  "to bottom left": 225,
  "to left": 270,
  "to top left": 315
};
class LinearGradient extends Gradient {
  getDefaultObject(obj2) {
    return super.getDefaultObject(__spreadValues({
      type: "linear-gradient",
      angle: 0
    }, obj2));
  }
  toCloneObject() {
    return __spreadProps(__spreadValues({}, super.toCloneObject()), {
      angle: this.json.angle
    });
  }
  isLinear() {
    return true;
  }
  hasAngle() {
    return true;
  }
  getRealAngle() {
    return this.json.angle;
  }
  get angle() {
    return this.getRealAngle();
  }
  toString() {
    if (this.colorsteps.length === 0)
      return "";
    var colorString = this.getColorString();
    var opt = "";
    var angle = this.json.angle || 0;
    opt = angle;
    if (isNumber(opt)) {
      opt = DEFINED_DIRECTIONS[`${opt}`] || opt;
    }
    if (isNumber(opt)) {
      opt = opt > 360 ? opt % 360 : opt;
      opt = `${opt}deg`;
    }
    var result = `${this.json.type}(${opt}, ${colorString})`;
    return result;
  }
  toCSSString() {
    if (this.colorsteps.length === 0)
      return "";
    var colorString = LinearGradient.toCSSColorString(this.colorsteps);
    var opt = "";
    var angle = this.json.angle || 0;
    opt = angle;
    if (isNumber(opt)) {
      opt = DEFINED_DIRECTIONS[`${opt}`] || opt;
    }
    if (isNumber(opt)) {
      opt = opt > 360 ? opt % 360 : opt;
      opt = `${opt}deg`;
    }
    var result = `${this.json.type}(${opt}, ${colorString})`;
    return result;
  }
  static parse(str) {
    const result = parseOneValue(str);
    var opt = {};
    let [options2, ...colors2] = result.parameters;
    const list2 = [];
    const keywords = [];
    if (options2[0].func !== FuncType.COLOR) {
      options2.forEach((it) => {
        if (it.func === FuncType.KEYWORD) {
          keywords.push(it);
        } else {
          list2.push(it);
        }
      });
    } else {
      colors2 = result.parameters;
    }
    let angle = keywords.map((it) => it.matchedString).join(" ");
    if (angle === "") {
      [angle] = list2.map((it) => it.parsed.value);
    } else {
      angle = DEFINED_ANGLES[angle];
    }
    opt = __spreadProps(__spreadValues({}, opt), {
      angle
    });
    const colorsteps = LinearGradient.parseColorSteps(colors2);
    return new LinearGradient(__spreadProps(__spreadValues({}, opt), { colorsteps }));
  }
}
const DEFINED_POSITIONS = {
  ["center"]: true,
  ["top"]: true,
  ["left"]: true,
  ["right"]: true,
  ["bottom"]: true
};
class RadialGradient extends Gradient {
  getDefaultObject(obj2 = {}) {
    return super.getDefaultObject(__spreadValues({
      type: "radial-gradient",
      radialType: "ellipse",
      radialSize: RadialGradientSizeType.FARTHEST_CORNER,
      radialPosition: [Position.CENTER, Position.CENTER]
    }, obj2));
  }
  toCloneObject() {
    return __spreadValues(__spreadValues({}, super.toCloneObject()), this.attrs("radialType", "radialSize", "radialPosition"));
  }
  getConerDist(result) {
    let topLeftPoint = result.backVerties[0];
    let topRightPoint = result.backVerties[1];
    let bottomLeftPoint = result.backVerties[3];
    let bottomRightPoint = result.backVerties[2];
    const topLeftDist = dist(result.radialCenterPosition, topLeftPoint);
    const topRightDist = dist(result.radialCenterPosition, topRightPoint);
    const bottomLeftDist = dist(result.radialCenterPosition, bottomLeftPoint);
    const bottomRightDist = dist(result.radialCenterPosition, bottomRightPoint);
    const cornerList = [
      ["top-left", topLeftPoint, topLeftDist],
      ["top-right", topRightPoint, topRightDist],
      ["bottom-left", bottomLeftPoint, bottomLeftDist],
      ["bottom-right", bottomRightPoint, bottomRightDist]
    ];
    cornerList.sort((a, b) => {
      return a[2] - b[2];
    });
    return {
      cornerList,
      topLeftDist,
      topRightDist,
      bottomLeftDist,
      bottomRightDist
    };
  }
  EllipseRadiusToSide(result, isClosest = true) {
    var dx1 = Math.abs(result.radialCenterPoint[0]);
    var dy1 = Math.abs(result.radialCenterPoint[1]);
    var dx2 = Math.abs(result.radialCenterPoint[0] - result.backRect.width);
    var dy2 = Math.abs(result.radialCenterPoint[1] - result.backRect.height);
    if (isClosest) {
      var dx = dx1 < dx2 ? dx1 : dx2;
      var dy = dy1 < dy2 ? dy1 : dy2;
    } else {
      var dx = dx1 > dx2 ? dx1 : dx2;
      var dy = dy1 > dy2 ? dy1 : dy2;
    }
    return { width: dx, height: dy };
  }
  EllipseRadius(newSize, result, isClosest = true) {
    const {
      cornerList,
      topLeftDist,
      topRightDist,
      bottomRightDist,
      bottomLeftDist
    } = this.getConerDist(result);
    const targetList = [
      topLeftDist,
      topRightDist,
      bottomLeftDist,
      bottomRightDist
    ];
    var raySize = isClosest ? Math.min(...targetList) : Math.max(...targetList);
    var point2 = cornerList.find((it) => it[2] === raySize)[1];
    var aspect_ratio = newSize.width / newSize.height;
    if (aspect_ratio === 0) {
      return;
    }
    var distPoint = subtract([], point2, result.radialCenterPosition);
    var a = Math.sqrt(Math.pow(distPoint[0], 2) + Math.pow(distPoint[1], 2) * Math.pow(aspect_ratio, 2));
    var b = a / aspect_ratio;
    return { width: a, height: b };
  }
  getStartEndPoint(result) {
    let startPoint, endPoint, shapePoint;
    const radialType = this.json.radialType;
    const radialSize = this.json.radialSize;
    let [rx, ry] = this.json.radialPosition;
    const backRect = result.backRect;
    const backVerties = rectToVerties(backRect.x, backRect.y, backRect.width, backRect.height);
    if (rx == "center")
      rx = Length.percent(50);
    if (ry == "center")
      ry = Length.percent(50);
    const newRx = rx.toPx(backRect.width);
    const newRy = ry.toPx(backRect.height);
    const centerPoisiton = [
      backRect.x + newRx.value,
      backRect.y + newRy.value,
      0
    ];
    let leftPoint = [backVerties[0][0], newRy.value, 0];
    let rightPoint = [backVerties[1][0], newRy.value, 0];
    let topPoint = [newRx.value, backVerties[0][1], 0];
    let bottomPoint = [newRx.value, backVerties[3][1], 0];
    const leftDist = dist(centerPoisiton, leftPoint);
    const rightDist = dist(centerPoisiton, rightPoint);
    const topDist = dist(centerPoisiton, topPoint);
    const bottomDist = dist(centerPoisiton, bottomPoint);
    const list2 = [
      ["top", topPoint, topDist],
      ["left", leftPoint, leftDist],
      ["right", rightPoint, rightDist],
      ["bottom", bottomPoint, bottomDist]
    ];
    list2.sort((a, b) => {
      return a[2] - b[2];
    });
    let topLeftPoint = backVerties[0];
    let topRightPoint = backVerties[1];
    let bottomLeftPoint = backVerties[3];
    let bottomRightPoint = backVerties[2];
    const topLeftDist = dist(centerPoisiton, topLeftPoint);
    const topRightDist = dist(centerPoisiton, topRightPoint);
    const bottomLeftDist = dist(centerPoisiton, bottomLeftPoint);
    const bottomRightDist = dist(centerPoisiton, bottomRightPoint);
    const cornerList = [
      ["top-left", topLeftPoint, topLeftDist],
      ["top-right", topRightPoint, topRightDist],
      ["bottom-left", bottomLeftPoint, bottomLeftDist],
      ["bottom-right", bottomRightPoint, bottomRightDist]
    ];
    cornerList.sort((a, b) => {
      return a[2] - b[2];
    });
    startPoint = clone(centerPoisiton);
    switch (radialType) {
      case RadialGradientType.CIRCLE:
        switch (radialSize) {
          case RadialGradientSizeType.CLOSEST_SIDE:
            var [, , dist$1] = list2[0];
            endPoint = fromValues(startPoint[0] + dist$1, startPoint[1], startPoint[2]);
            shapePoint = fromValues(startPoint[0], startPoint[1] + dist$1, startPoint[2]);
            break;
          case RadialGradientSizeType.CLOSEST_CORNER:
            var [, , dist$1] = cornerList[0];
            endPoint = fromValues(startPoint[0] + dist$1, startPoint[1], startPoint[2]);
            shapePoint = fromValues(startPoint[0], startPoint[1] + dist$1, startPoint[2]);
            break;
          case RadialGradientSizeType.FARTHEST_SIDE:
            var [, , dist$1] = list2[list2.length - 1];
            endPoint = fromValues(startPoint[0] + dist$1, startPoint[1], startPoint[2]);
            shapePoint = fromValues(startPoint[0], startPoint[1] + dist$1, startPoint[2]);
            break;
          case RadialGradientType.CIRCLE:
          case RadialGradientSizeType.FARTHEST_CORNER:
            var [, , dist$1] = cornerList[cornerList.length - 1];
            endPoint = fromValues(startPoint[0] + dist$1, startPoint[1], startPoint[2]);
            shapePoint = fromValues(startPoint[0], startPoint[1] + dist$1, startPoint[2]);
            break;
          default:
            var dist$1 = (radialSize[0] || radialSize).toPx(dist(result.backVerties[1], result.backVerties[0])).value;
            endPoint = fromValues(startPoint[0] + dist$1, startPoint[1], startPoint[2]);
            shapePoint = fromValues(startPoint[0], startPoint[1] + dist$1, startPoint[2]);
            break;
        }
        break;
      case RadialGradientType.ELLIPSE:
        switch (radialSize) {
          case RadialGradientSizeType.CLOSEST_SIDE:
            var newSize = this.EllipseRadiusToSide(result, true);
            endPoint = fromValues(startPoint[0] + newSize.width, startPoint[1], startPoint[2]);
            shapePoint = fromValues(startPoint[0], startPoint[1] + newSize.height, startPoint[2]);
            break;
          case RadialGradientSizeType.CLOSEST_CORNER:
            var newSize = this.EllipseRadiusToSide(result, true);
            var radius = this.EllipseRadius(newSize, result, true);
            endPoint = fromValues(startPoint[0] + radius.width, startPoint[1], startPoint[2]);
            shapePoint = fromValues(startPoint[0], startPoint[1] + radius.height, startPoint[2]);
            break;
          case RadialGradientSizeType.FARTHEST_SIDE:
            var newSize = this.EllipseRadiusToSide(result, false);
            endPoint = fromValues(startPoint[0] + newSize.width, startPoint[1], startPoint[2]);
            shapePoint = fromValues(startPoint[0], startPoint[1] + newSize.height, startPoint[2]);
            break;
          case RadialGradientSizeType.FARTHEST_CORNER:
            var newSize = this.EllipseRadiusToSide(result, false);
            var radius = this.EllipseRadius(newSize, result, false);
            endPoint = fromValues(startPoint[0] + radius.width, startPoint[1], startPoint[2]);
            shapePoint = fromValues(startPoint[0], startPoint[1] + radius.height, startPoint[2]);
            break;
          default:
            var raySize = radialSize[0].toPx(dist(result.backVerties[1], result.backVerties[0])).value;
            var shapeSize = radialSize[1].toPx(dist(result.backVerties[3], result.backVerties[0])).value;
            endPoint = fromValues(startPoint[0] + raySize, startPoint[1], startPoint[2]);
            shapePoint = fromValues(startPoint[0], startPoint[1] + shapeSize, startPoint[2]);
            break;
        }
        break;
    }
    return {
      startPoint,
      endPoint,
      shapePoint
    };
  }
  toString() {
    if (this.colorsteps.length === 0)
      return "";
    var colorString = this.getColorString();
    var json = this.json;
    var opt = "";
    var radialType = json.radialType || RadialGradientType.ELLIPSE;
    var radialSize = json.radialSize || RadialGradientSizeType.FARTHEST_CORNER;
    var radialPosition = json.radialPosition || ["center", "center"];
    radialPosition = DEFINED_POSITIONS[radialPosition] ? radialPosition : radialPosition.join(" ");
    radialSize = isArray(radialSize) ? radialSize.join(" ") : radialSize;
    opt = radialPosition ? `${radialType} ${radialSize} at ${radialPosition}` : `${radialType} ${radialSize}`;
    return `${json.type || "radial-gradient"}(${opt}, ${colorString})`;
  }
  toCSSString() {
    if (this.colorsteps.length === 0)
      return "";
    var colorString = RadialGradient.toCSSColorString(this.colorsteps);
    var json = this.json;
    var opt = "";
    var radialType = json.radialType || RadialGradientType.ELLIPSE;
    var radialSize = json.radialSize || RadialGradientSizeType.FARTHEST_CORNER;
    var radialPosition = json.radialPosition || ["center", "center"];
    radialPosition = DEFINED_POSITIONS[radialPosition] ? radialPosition : radialPosition.join(" ");
    radialSize = isArray(radialSize) ? radialSize.join(" ") : radialSize;
    opt = radialPosition ? `${radialType} ${radialSize} at ${radialPosition}` : `${radialType} ${radialSize}`;
    return `${json.type || "radial-gradient"}(${opt}, ${colorString})`;
  }
  static parse(str) {
    const result = parseOneValue(str);
    var opt = {
      radialType: RadialGradientType.ELLIPSE,
      radialSize: RadialGradientSizeType.FARTHEST_CORNER,
      radialPosition: ["center", "center"]
    };
    let [options2, ...colors2] = result.parameters;
    if (options2[0].func !== FuncType.COLOR) {
      let radialType = RadialGradientType.ELLIPSE;
      let hasAt = false;
      let positions = [];
      let sizeOption = [];
      options2.forEach((it) => {
        if (it.func === FuncType.KEYWORD && it.matchedString === "at") {
          hasAt = true;
        } else if (hasAt) {
          positions.push(it);
        } else {
          switch (it.matchedString) {
            case RadialGradientType.CIRCLE:
            case RadialGradientType.ELLIPSE:
              radialType = it.matchedString;
              break;
            default:
              sizeOption.push(it);
              break;
          }
        }
      });
      opt.radialType = radialType;
      opt.radialPosition = positions.map((it) => {
        if (it.func === FuncType.KEYWORD) {
          switch (it.matchedString) {
            case "top":
              return Length.percent(0);
            case "left":
              return Length.percent(0);
            case "right":
              return Length.percent(100);
            case "bottom":
              return Length.percent(100);
            case "center":
              return Length.percent(50);
          }
        }
        return it.parsed;
      });
      opt.radialSize = sizeOption.map((it) => {
        if (it.func === FuncType.KEYWORD)
          return it.matchedString;
        return it.parsed;
      });
      if (opt.radialSize.length === 1) {
        opt.radialSize = opt.radialSize[0];
      }
    } else {
      colors2 = result.parameters;
    }
    const colorsteps = RadialGradient.parseColorSteps(colors2);
    return new RadialGradient(__spreadProps(__spreadValues({}, opt), { colorsteps }));
  }
}
class RepeatingConicGradient extends ConicGradient {
  getDefaultObject() {
    return super.getDefaultObject({
      type: "repeating-conic-gradient",
      angle: 0,
      radialPosition: [Position.CENTER, Position.CENTER]
    });
  }
  static parse(str) {
    var conic2 = ConicGradient.parse(str);
    return new RepeatingConicGradient({
      angle: conic2.angle,
      radialPosition: conic2.radialPosition,
      colorsteps: conic2.colorsteps
    });
  }
}
class RepeatingLinearGradient extends LinearGradient {
  getDefaultObject() {
    return super.getDefaultObject({
      type: "repeating-linear-gradient",
      angle: 0
    });
  }
  static parse(str) {
    var linear2 = LinearGradient.parse(str);
    return new RepeatingLinearGradient({
      angle: linear2.angle,
      colorsteps: linear2.colorsteps
    });
  }
}
class RepeatingRadialGradient extends RadialGradient {
  getDefaultObject() {
    return super.getDefaultObject({
      type: "repeating-radial-gradient"
    });
  }
  static parse(str) {
    var radial2 = RadialGradient.parse(str);
    return new RepeatingRadialGradient({
      radialType: radial2.radialType,
      radialSize: radial2.radialSize,
      radialPosition: radial2.radialPosition,
      colorsteps: radial2.colorsteps
    });
  }
}
class StaticGradient extends Gradient {
  getDefaultObject() {
    return super.getDefaultObject({
      type: "static-gradient",
      static: true,
      colorsteps: [
        new ColorStep({ color: "red", percent: 0, index: 0 }),
        new ColorStep({ color: "red", percent: 100, index: 0 })
      ]
    });
  }
  toCloneObject() {
    return __spreadProps(__spreadValues({}, super.toCloneObject()), {
      static: true
    });
  }
  static parse(str) {
    const result = parseOneValue(str);
    var colorsteps = Gradient.parseColorSteps(result.parameters);
    return new StaticGradient({ colorsteps });
  }
  static create(color2 = "transparent") {
    return new StaticGradient({
      colorsteps: [
        new ColorStep({ color: color2, percent: 0, index: 0 }),
        new ColorStep({ color: color2, percent: 100, index: 1 })
      ]
    });
  }
  toString() {
    var color2 = this.json.colorsteps[0].color;
    return `static-gradient(${color2})`;
  }
  toCSSString() {
    if (this.colorsteps.length === 0)
      return "";
    const color2 = this.colorsteps[0].color || "black";
    return `linear-gradient(${color2} 0%, ${color2} 100%)`;
  }
}
const IMAGE_LIST$1 = ["jpg", "jpeg", "png", "gif", "svg"];
class URLImageResource extends ImageResource {
  getDefaultObject(obj2 = {}) {
    return super.getDefaultObject(__spreadValues({
      type: GradientType.URL,
      url: "",
      datauri: ""
    }, obj2));
  }
  toCloneObject() {
    return __spreadValues(__spreadValues({}, super.toCloneObject()), this.attrs("url", "datauri"));
  }
  static parse(str) {
    var url = str.split("(")[1].split(")")[0];
    return new URLImageResource({ url });
  }
  isUrl() {
    return true;
  }
  toString(url) {
    return `url(${url || this.json.url})`;
  }
  static isImageFile(fileExt) {
    return IMAGE_LIST$1.includes(fileExt);
  }
}
const RepeatList = [
  "repeat",
  "no-repeat",
  "repeat-x",
  "repeat-y",
  "round",
  "space"
];
class BackgroundImage extends PropertyItem {
  addImageResource(imageResource) {
    this.clear("image-resource");
    return this.addItem("image-resource", imageResource);
  }
  addGradient(gradient2) {
    return this.addImageResource(gradient2);
  }
  setImageUrl(data) {
    if (!data.images)
      return;
    if (!data.images.length)
      return;
    this.reset({
      type: "image",
      image: BackgroundImage.createImage(data.images[0])
    });
  }
  static createImage(url) {
    return new URLImageResource({ url });
  }
  setGradient(data) {
    this.reset({
      type: data.type,
      image: BackgroundImage.createGradient(data, this.json.image)
    });
  }
  static createGradient(data, gradient2) {
    const colorsteps = data.colorsteps || gradient2.colorsteps;
    const angle = data.angle || gradient2.angle;
    const radialType = data.radialType || gradient2.radialType;
    const radialPosition = data.radialPosition || gradient2.radialPosition;
    let json = gradient2.toJSON();
    delete json.itemType;
    delete json.type;
    switch (data.type) {
      case "static-gradient":
        return new StaticGradient(__spreadProps(__spreadValues({}, json), { colorsteps }));
      case "linear-gradient":
        return new LinearGradient(__spreadProps(__spreadValues({}, json), { colorsteps, angle }));
      case "repeating-linear-gradient":
        return new RepeatingLinearGradient(__spreadProps(__spreadValues({}, json), { colorsteps, angle }));
      case "radial-gradient":
        return new RadialGradient(__spreadProps(__spreadValues({}, json), {
          colorsteps,
          radialType,
          radialPosition
        }));
      case "repeating-radial-gradient":
        return new RepeatingRadialGradient(__spreadProps(__spreadValues({}, json), {
          colorsteps,
          radialType,
          radialPosition
        }));
      case "conic-gradient":
        return new ConicGradient(__spreadProps(__spreadValues({}, json), {
          colorsteps,
          angle,
          radialPosition
        }));
      case "repeating-conic-gradient":
        return new RepeatingConicGradient(__spreadProps(__spreadValues({}, json), {
          colorsteps,
          angle,
          radialPosition
        }));
    }
    return new Gradient();
  }
  getDefaultObject() {
    return super.getDefaultObject({
      itemType: "background-image",
      checked: false,
      blendMode: "normal",
      size: "auto",
      repeat: "repeat",
      width: Length.percent(100),
      height: Length.percent(100),
      x: Length.percent(0),
      y: Length.percent(0)
    });
  }
  toCloneObject() {
    var json = this.json;
    return __spreadProps(__spreadValues(__spreadValues({}, super.toCloneObject()), this.attrs("checked", "blendMode", "size", "repeat", "width", "height", "x", "y")), {
      image: json.image.toString()
    });
  }
  convert(json) {
    json.x = Length.parse(json.x);
    json.y = Length.parse(json.y);
    if (json.width)
      json.width = Length.parse(json.width);
    if (json.height)
      json.height = Length.parse(json.height);
    if (isString(json.image)) {
      json.image = BackgroundImage.parseImage(json.image);
    }
    return json;
  }
  get image() {
    return this.json.image;
  }
  set image(image2) {
    this.json.image = image2;
  }
  checkField(key, value) {
    if (key === "repeat") {
      return RepeatList.includes(value);
    }
    return super.checkField(key, value);
  }
  recoverOffset(newX, newY, contentBox, dx = 0, dy = 0, options2 = {}) {
    const { x, y, width: width2, height: height2 } = this.json;
    const newWidth = Math.floor(width2.toPx(contentBox.width).value + dx);
    const newHeight = options2.shiftKey ? newWidth : Math.floor(height2.toPx(contentBox.height).value + dy);
    newX -= contentBox.x;
    newY -= contentBox.y;
    if (newWidth < 0) {
      newX += newWidth;
    }
    if (newHeight < 0) {
      newY += newHeight;
    }
    let nextX = Length.px(newX);
    let nextY = Length.px(newY);
    const dist2 = 2;
    if (x.isPercent()) {
      if (Math.abs(newX) < dist2) {
        nextX = Length.percent(0);
      } else if (Math.abs(contentBox.width - newWidth - newX) < dist2) {
        nextX = Length.percent(100);
      } else if (Math.abs((contentBox.width - newWidth) / 2 - newX) < dist2) {
        nextX = Length.percent(50);
      } else {
        nextX = Length.makePercent(newX, contentBox.width - newWidth);
      }
    }
    if (y.isPercent()) {
      if (Math.abs(newY) < dist2) {
        nextY = Length.percent(0);
      } else if (Math.abs(contentBox.height - newHeight - newY) < dist2) {
        nextY = Length.percent(100);
      } else if (Math.abs((contentBox.height - newHeight) / 2 - newY) < dist2) {
        nextY = Length.percent(50);
      } else {
        nextY = Length.makePercent(newY, contentBox.height - newHeight);
      }
    }
    return {
      x: nextX,
      y: nextY,
      width: Length.px(Math.abs(newWidth)).to(width2.unit, contentBox.width),
      height: Length.px(Math.abs(newHeight)).to(height2.unit, contentBox.height)
    };
  }
  getOffset(contentBox) {
    const { x, y, width: width2, height: height2 } = this.json;
    const newWidth = width2.toPx(contentBox.width);
    const newHeight = height2.toPx(contentBox.height);
    const newX = x.toPx(contentBox.width);
    const newY = y.toPx(contentBox.height);
    return {
      x: contentBox.x + (x.isPercent() ? (contentBox.width - newWidth) * (x.value / 100) : newX),
      y: contentBox.y + (y.isPercent() ? (contentBox.height - newHeight) * (y.value / 100) : newY),
      width: newWidth.value,
      height: newHeight.value
    };
  }
  toBackgroundImageCSS() {
    if (!this.json.image)
      return {};
    return {
      "background-image": this.json.image.toCSSString()
    };
  }
  toBackgroundImageProperty() {
    if (!this.json.image)
      return {};
    return {
      "background-image": this.json.image.toString()
    };
  }
  toBackgroundPositionCSS() {
    var json = this.json;
    return {
      "background-position": `${json.x} ${json.y}`
    };
  }
  toBackgroundSizeCSS() {
    var json = this.json;
    var backgroundSize = "auto";
    if (json.size == "contain" || json.size == "cover") {
      backgroundSize = json.size;
    } else if (json.width.isPercent() && json.width.isPercent()) {
      if (+json.width !== 100 || +json.height !== 100) {
        backgroundSize = `${json.width} ${json.height}`;
      }
    } else {
      backgroundSize = `${json.width} ${json.height}`;
    }
    return {
      "background-size": backgroundSize
    };
  }
  toBackgroundRepeatCSS() {
    var json = this.json;
    return {
      "background-repeat": json.repeat
    };
  }
  toBackgroundBlendCSS() {
    var json = this.json;
    return {
      "background-blend-mode": json.blendMode
    };
  }
  toBackgroundVisibilityCSS() {
    var json = this.json;
    return {
      "background-visibility": json.visibility === VisibilityType.HIDDEN ? VisibilityType.HIDDEN : VisibilityType.VISIBLE
    };
  }
  toCSS() {
    const results = __spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues({}, this.toBackgroundImageCSS()), this.toBackgroundPositionCSS()), this.toBackgroundSizeCSS()), this.toBackgroundRepeatCSS()), this.toBackgroundBlendCSS()), this.toBackgroundVisibilityCSS());
    return results;
  }
  toProperty() {
    const results = __spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues({}, this.toBackgroundImageProperty()), this.toBackgroundPositionCSS()), this.toBackgroundSizeCSS()), this.toBackgroundRepeatCSS()), this.toBackgroundBlendCSS()), this.toBackgroundVisibilityCSS());
    return results;
  }
  toString() {
    return keyMap(this.toCSS(), (key, value) => {
      return `${key}: ${value}`;
    }).join(";");
  }
  toBackgroundCSS() {
    var obj2 = this.toCSS();
    return {
      background: `${obj2["background-image"]} `
    };
  }
  static parse(obj2) {
    return new BackgroundImage(obj2);
  }
  static parseImage(str) {
    const result = parseOneValue(str);
    let image2 = null;
    if (!result || str === "undefined") {
      return StaticGradient.create(str || "transparent");
    }
    switch (result.func) {
      case GradientType.LINEAR:
        image2 = LinearGradient.parse(result.matchedString);
        break;
      case GradientType.REPEATING_LINEAR:
        image2 = RepeatingLinearGradient.parse(result.matchedString);
        break;
      case GradientType.RADIAL:
        image2 = RadialGradient.parse(result.matchedString);
        break;
      case GradientType.REPEATING_RADIAL:
        image2 = RepeatingRadialGradient.parse(result.matchedString);
        break;
      case GradientType.CONIC:
        image2 = ConicGradient.parse(result.matchedString);
        break;
      case GradientType.REPEATING_CONIC:
        image2 = RepeatingConicGradient.parse(result.matchedString);
        break;
      case GradientType.URL:
        image2 = URLImageResource.parse(result.matchedString);
        break;
      default:
        image2 = StaticGradient.parse(result.matchedString);
        break;
    }
    return image2;
  }
  static changeImageType(options2) {
    switch (options2.type) {
      case GradientType.STATIC:
        return new StaticGradient(options2);
      case GradientType.LINEAR:
        return new LinearGradient(options2);
      case GradientType.REPEATING_LINEAR:
        return new RepeatingLinearGradient(options2);
      case GradientType.RADIAL:
        return new RadialGradient(options2);
      case GradientType.REPEATING_RADIAL:
        return new RepeatingRadialGradient(options2);
      case GradientType.CONIC:
        return new ConicGradient(options2);
      case GradientType.REPEATING_CONIC:
        return new RepeatingConicGradient(options2);
      case GradientType.URL:
        return new URLImageResource(options2);
    }
  }
  static parseStyle(style) {
    var backgroundImages = [];
    if (style["background-image"]) {
      const result = parseGroupValue(style["background-image"], "background-image");
      result.forEach((parsedValue, index2) => {
        const item = parsedValue[0];
        let image2;
        switch (item.func) {
          case GradientType.STATIC:
            image2 = StaticGradient.parse(item.matchedString);
            break;
          case GradientType.LINEAR:
            image2 = LinearGradient.parse(item.matchedString);
            break;
          case GradientType.REPEATING_LINEAR:
            image2 = RepeatingLinearGradient.parse(item.matchedString);
            break;
          case GradientType.RADIAL:
            image2 = RadialGradient.parse(item.matchedString);
            break;
          case GradientType.REPEATING_RADIAL:
            image2 = RepeatingRadialGradient.parse(item.matchedString);
            break;
          case GradientType.CONIC:
            image2 = ConicGradient.parse(item.matchedString);
            break;
          case GradientType.REPEATING_CONIC:
            image2 = RepeatingConicGradient.parse(item.matchedString);
            break;
          case GradientType.URL:
            image2 = URLImageResource.parse(item.matchedString);
            break;
        }
        backgroundImages[index2] = new BackgroundImage({
          type: image2.type,
          image: image2
        });
      });
    }
    if (style["background-repeat"]) {
      style["background-repeat"].split(",").map((it) => it.trim()).forEach((it, index2) => {
        if (backgroundImages[index2]) {
          backgroundImages[index2].repeat = it;
        }
      });
    }
    if (style["background-blend-mode"]) {
      style["background-blend-mode"].split(",").map((it) => it.trim()).forEach((it, index2) => {
        if (backgroundImages[index2]) {
          backgroundImages[index2].blendMode = it;
        }
      });
    }
    if (style["background-size"]) {
      style["background-size"].split(",").map((it) => it.trim()).forEach((it, index2) => {
        if (backgroundImages[index2]) {
          if (it == "cover" || it === "contain" || it === "auto") {
            backgroundImages[index2].size = it;
          } else {
            backgroundImages[index2].size = "auto";
            let [width2, height2] = it.split(" ");
            backgroundImages[index2].width = Length.parse(width2);
            backgroundImages[index2].height = Length.parse(height2);
          }
        }
      });
    }
    if (style["background-position"]) {
      style["background-position"].split(",").map((it) => it.trim()).forEach((it, index2) => {
        if (backgroundImages[index2]) {
          let [x, y] = it.split(" ");
          backgroundImages[index2].x = Length.parse(x);
          backgroundImages[index2].y = Length.parse(y);
        }
      });
    }
    if (style["background-visibility"]) {
      style["background-visibility"].split(",").map((it) => it.trim()).forEach((it, index2) => {
        if (backgroundImages[index2]) {
          backgroundImages[index2].visibility = it === VisibilityType.HIDDEN ? VisibilityType.HIDDEN : VisibilityType.VISIBLE;
        }
      });
    }
    return backgroundImages;
  }
  static toCSS(list2) {
    var results = {};
    list2.forEach((item) => {
      keyEach(item.toCSS(), (key, value) => {
        if (!results[key])
          results[key] = [];
        results[key].push(value);
      });
    });
    return combineKeyArray(results);
  }
  static toProperty(list2) {
    var results = {};
    list2.forEach((item) => {
      keyEach(item.toProperty(), (key, value) => {
        if (!results[key])
          results[key] = [];
        results[key].push(value);
      });
    });
    return combineKeyArray(results);
  }
  static join(list2) {
    return CSS_TO_STRING(BackgroundImage.toProperty(list2.map((it) => BackgroundImage.parse(it))));
  }
  static joinCSS(list2) {
    return BackgroundImage.toCSS(list2.map((it) => BackgroundImage.parse(it)));
  }
  static parseList(list2 = []) {
    return list2.map((it) => BackgroundImage.parse(it));
  }
}
class GradientEditor extends EditorElement {
  initState() {
    var _a;
    const image2 = BackgroundImage.parseImage(this.props.value || "static-gradient(#ececec)");
    const id = (_a = image2.colorsteps[this.props.index]) == null ? void 0 : _a.id;
    this.$context.selection.selectColorStep(id);
    if (id) {
      this.currentStep = image2.colorsteps.find((it) => this.$context.selection.isSelectedColorStep(it.id));
    }
    return {
      id,
      index: +(this.props.index || 0),
      value: this.props.value,
      image: image2
    };
  }
  setValue(value) {
    this.setState({
      image: BackgroundImage.parseImage(value)
    }, false);
    this.refresh();
  }
  template() {
    return `
        <div class='elf--gradient-editor'>
            <div class='gradient-steps' data-editor='gradient'>
                <div class="hue-container" ref="$back"></div>            
                <div class="hue" ref="$steps">
                    <div class='step-list' ref="$stepList" ></div>
                </div>
            </div>
        </div>
      `;
  }
  [CHANGE("$file")](e) {
    var project2 = this.$context.selection.currentProject;
    if (project2) {
      [...e.target.files].forEach((item) => {
        this.$commands.emit("updateImageAssetItem", item, (local) => {
          this.trigger("setImageUrl", local);
        });
      });
    }
  }
  [SUBSCRIBE_SELF("changeTabType")](type) {
    var _a, _b;
    const oldType = (_a = this.state.image) == null ? void 0 : _a.type;
    const colorsteps = ((_b = this.state.image) == null ? void 0 : _b.colorsteps) || [];
    if (oldType === GradientType.STATIC) {
      if (colorsteps.length === 0) {
        colorsteps.push(colorsteps[0], colorsteps[0]);
      } else if (colorsteps.length === 1) {
        colorsteps.push(colorsteps[0], colorsteps[0]);
      }
    }
    var url = type === "image-resource" ? this.state.image.url : this.state.url;
    this.state.image = BackgroundImage.changeImageType({
      type,
      url,
      colorsteps,
      angle: this.state.image.angle || 0,
      radialType: this.state.image.radialType || RadialGradientType.CIRCLE,
      radialPosition: this.state.image.radialPosition || ["50%", "50%"]
    });
    this.refresh();
    this.updateData();
  }
  [SUBSCRIBE_SELF("changeColorStepOffset")](key, value) {
    if (this.currentStep) {
      this.currentStep.percent = value.value;
      this.state.image.sortColorStep();
      this.refresh();
      this.updateData();
    }
  }
  [CLICK("$back")](e) {
    var rect2 = this.refs.$stepList.rect();
    var minX = rect2.x;
    var maxX = rect2.right;
    var x = e.xy.x;
    if (x < minX)
      x = minX;
    else if (x > maxX)
      x = maxX;
    var percent = (x - minX) / rect2.width * 100;
    this.state.image.insertColorStep(percent);
    this.state.image.sortColorStep();
    this.refresh();
    this.updateData();
  }
  [BIND("$el")]() {
    var type = this.state.image.type;
    if (type === "url") {
      type = "image-resource";
    }
    return {
      "data-selected-editor": type
    };
  }
  [BIND("$stepList")]() {
    return {
      style: {
        "background-image": this.getLinearGradient()
      }
    };
  }
  [LOAD("$stepList") + DOMDIFF]() {
    var _a;
    var colorsteps = ((_a = this.state.image) == null ? void 0 : _a.colorsteps) || [];
    return colorsteps.map((it) => {
      var selected = this.$context.selection.isSelectedColorStep(it.id) ? "selected" : "";
      return `
      <div class='step ${selected}' data-id='${it.id}' data-cut='${it.cut}' tabindex="-1" style='left: ${it.toLength()};'>
        <div class='color-view' style="background-color: ${it.color}">
          <span>${Math.floor(it.percent * 10) / 10}</span>
        </div>      
        <div class='arrow'></div>      
      </div>`;
    });
  }
  removeStep(id) {
    this.state.image.removeColorStep(id);
    this.refresh();
    this.updateData();
  }
  selectStep(id) {
    this.state.id = id;
    this.$context.selection.selectColorStep(id);
    if (this.state.image.colorsteps) {
      this.currentStep = this.state.image.colorsteps.find((it) => this.$context.selection.isSelectedColorStep(it.id));
      this.parent.trigger("selectColorStep", this.currentStep.color);
    }
    this.refresh();
  }
  [KEYUP("$el .step")](e) {
    const id = e.$dt.data("id");
    switch (e.code) {
      case "Delete":
      case "Backspace":
        this.removeStep(id);
        break;
      case "BracketRight":
        this.sortToRight(id);
        break;
      case "BracketLeft":
        this.sortToLeft(id);
        break;
      case "Equal":
        this.appendColorStep(id);
        break;
      case "Minus":
        this.prependColorStep(id);
        break;
    }
  }
  sortToRight(id) {
    this.state.image.sortToRight();
    this.refresh();
    this.updateData();
    this.doFocus(id);
  }
  sortToLeft(id) {
    this.state.image.sortToLeft();
    this.refresh();
    this.updateData();
    this.doFocus(id);
  }
  appendColorStep(id) {
    const currentIndex = this.state.image.colorsteps.findIndex((it) => it.id === id);
    const nextIndex = currentIndex + 1;
    const currentColorStep = this.state.image.colorsteps[currentIndex];
    const nextColorStep = this.state.image.colorsteps[nextIndex];
    if (!nextColorStep) {
      if (currentColorStep.percent !== 100) {
        this.state.image.insertColorStep(currentColorStep.percent + (100 - currentColorStep.percent) / 2);
      }
    } else {
      this.state.image.insertColorStep(currentColorStep.percent + (nextColorStep.percent - currentColorStep.percent) / 2);
    }
    this.refresh();
    this.updateData();
    this.doFocus(id);
  }
  doFocus(id) {
    this.nextTick(() => {
      this.refs.$stepList.$(".step[data-id='" + id + "']").focus();
    }, 100);
  }
  prependColorStep(id) {
    const currentIndex = this.state.image.colorsteps.findIndex((it) => it.id === id);
    const prevIndex = currentIndex - 1;
    const currentColorStep = this.state.image.colorsteps[currentIndex];
    const prevColorStep = this.state.image.colorsteps[prevIndex];
    if (!prevColorStep) {
      if (currentColorStep.percent !== 0) {
        this.state.image.insertColorStep(currentColorStep.percent);
      }
    } else {
      this.state.image.insertColorStep(prevColorStep.percent + (currentColorStep.percent - prevColorStep.percent) / 2);
    }
    this.refresh();
    this.updateData();
    this.doFocus(id);
  }
  [POINTERSTART("$stepList .step") + MOVE() + END()](e) {
    var id = e.$dt.attr("data-id");
    if (e.altKey) {
      this.removeStep(id);
      return false;
    } else {
      e.$dt.focus();
      this.isSelectedColorStep = this.$context.selection.isSelectedColorStep(id);
      this.selectStep(id);
      this.startXY = e.xy;
      this.cachedStepListRect = this.refs.$stepList.rect();
    }
  }
  getStepListRect() {
    return this.cachedStepListRect;
  }
  move(dx) {
    var rect2 = this.getStepListRect();
    var minX = rect2.x;
    var maxX = rect2.right;
    var x = this.startXY.x + dx;
    if (x < minX)
      x = minX;
    else if (x > maxX)
      x = maxX;
    var percent = (x - minX) / rect2.width * 100;
    if (this.$config.get("bodyEvent").shiftKey) {
      percent = Math.floor(percent);
    }
    this.currentStep.setValue(percent, rect2.width);
    this.state.image.sortColorStep();
    this.refresh();
    this.updateData();
  }
  end(dx, dy) {
    if (dx === 0 && dy === 0) {
      if (this.isSelectedColorStep) {
        if (this.currentStep) {
          this.currentStep.cut = !this.currentStep.cut;
          this.refresh();
          this.updateData();
        }
      }
    }
    this.doFocus(this.state.id);
  }
  getLinearGradient() {
    var { image: image2 } = this.state;
    return `linear-gradient(to right, ${Gradient.toCSSColorString(image2.colorsteps)})`;
  }
  [SUBSCRIBE_SELF("setColorStepColor")](color2) {
    if (this.state.image.type === "static-gradient") {
      this.state.image.colorsteps[0].color = color2;
      this.refresh();
      this.updateData();
    } else {
      if (this.currentStep) {
        this.currentStep.color = color2;
        this.refresh();
        this.updateData();
      }
    }
  }
  [SUBSCRIBE("setImageUrl")](url) {
    if (this.state.image) {
      this.state.url = url;
      this.state.image.reset({ url });
      this.refresh();
      this.updateData();
    }
  }
  updateData(data = {}) {
    this.setState(data, false);
    this.parent.trigger(this.props.onchange, this.state.image.toString());
  }
}
var IconListViewEditor$1 = "";
class IconListViewEditor extends EditorElement {
  initState() {
    return {
      value: this.props.value
    };
  }
  template() {
    return `<div class='select-editor elf--list-view-editor' ref='$body'></div>`;
  }
  [BIND("$body")]() {
    return {
      "data-column": this.props.column || 1
    };
  }
  [LOAD("$body")]() {
    return Object.keys(obj$2).map((key) => {
      var html = obj$2[key];
      var selected = key === this.state.value ? "selected" : "";
      return `<div class='list-view-item ${selected}'  data-key='${key}'>${html}</div>`;
    });
  }
  getValue() {
    return this.state.value;
  }
  setValue(value) {
    this.state.value = value;
    this.refresh();
  }
  [CLICK("$body .list-view-item")](e) {
    var key = e.$dt.attr("data-key");
    e.$dt.onlyOneClass("selected");
    this.updateData({
      value: key
    });
  }
  updateData(data) {
    this.setState(data, false);
    this.parent.trigger(this.props.onchange, this.props.key, this.state.value, this.props.params);
  }
}
class InputArrayEditor extends EditorElement {
  initState() {
    var values = this.props.values.split(" ").map((it) => +it);
    return {
      values,
      column: this.props.column
    };
  }
  template() {
    return `<div class='small-editor input-array-editor' ref='$body' ></div>`;
  }
  [BIND("$body")]() {
    return {
      cssText: `
                display: grid;
                grid-template-columns: repeat(${this.state.column}, 1fr);
                grid-column-gap: 2px;
                grid-row-gap: 2px;
            `
    };
  }
  [LOAD("$body")]() {
    var { values } = this.state;
    return values.map((value, index2) => {
      return `
                <div class='number-editor'>
                    <input type="number" value="${value}" step="0.01" data-index="${index2}" />
                </div>
            `;
    });
  }
  updateData(data) {
    this.setState(data, false);
    this.parent.trigger(this.props.onchange, this.props.key, this.state.values, this.props.params);
  }
  [INPUT("$body input")](e) {
    var $el = e.$dt;
    var index2 = +$el.attr("data-index");
    var value = +$el.value;
    this.state.values[index2] = value;
    this.updateData();
  }
}
var InputRangeEditor$1 = "";
class InputRangeEditor extends EditorElement {
  initState() {
    var units = this.props.units || ["px", "em", "%", "auto"];
    var value = Length.parse(this.props.value || "0px");
    let label = this.props.label || "";
    if (obj$2[label]) {
      label = obj$2[label];
    }
    return {
      removable: this.props.removable,
      label,
      compact: this.props.compact,
      wide: this.props.wide,
      min: +this.props.min || 0,
      max: +this.props.max || 100,
      step: +this.props.step || 1,
      key: this.props.key,
      params: this.props.params || "",
      layout: this.props.layout || "",
      disabled: this.props.disabled,
      title: this.props.title || "",
      units,
      value
    };
  }
  template() {
    return `<div class='small-editor' ref='$body'></div>`;
  }
  [LOAD("$body") + DOMDIFF]() {
    var {
      min,
      max,
      step: step2,
      label,
      title: title2,
      compact,
      wide,
      removable,
      layout: layout2,
      disabled
    } = this.state;
    var value = +this.state.value.value.toString();
    if (isNaN(value)) {
      value = 0;
    }
    var layoutClass = layout2;
    var realValue = (+value).toString();
    const units = this.state.units;
    return `
        <div 
            ref="$range",
            class="${classnames({
      "elf--input-range-editor": true,
      "has-label": !!label,
      compact: !!compact,
      wide: !!wide,
      "is-removable": removable,
      disabled,
      [layoutClass]: true
    })}"
        >
            ${label ? `<label title="${title2}">${label}</label>` : ""}
            <div class='range--editor-type' data-type='range'>
                <div class='area'>
                    <input type='number' class='property-number' ref='$propertyNumber' value="${realValue}" min="${min}" max="${max}" step="${step2}" tabIndex="1" />
                    
                    ${units.length === 1 ? `<span class='unit'>${units[0]}</span>` : createComponent("SelectEditor", {
      ref: "$unit",
      key: "unit",
      compact: true,
      value: this.state.selectedUnit || this.state.value.unit,
      options: this.state.units,
      onchange: "changeUnit"
    })}
                    
                    
                </div>
            </div>
            <button type='button' class='remove' ref='$remove' title='Remove'>${obj$2.remove}</button>
        </div>
    `;
  }
  getValue() {
    return this.state.value.clone();
  }
  setValue(value) {
    var _a;
    this.setState({
      value: Length.parse(value)
    }, false);
    this.refs.$propertyNumber.val(this.state.value.value);
    (_a = this.children.$unit) == null ? void 0 : _a.setValue(this.state.value.unit);
  }
  disabled() {
    this.setState({
      disabled: true
    });
  }
  enabled() {
    this.setState({
      disabled: false
    });
  }
  [CLICK("$remove")]() {
    this.updateData({
      value: ""
    });
  }
  getUnit() {
    var _a;
    return ((_a = this.children.$unit) == null ? void 0 : _a.getValue()) || this.state.value.unit;
  }
  updateData(data) {
    this.setState(data, false);
    this.parent.trigger(this.props.onchange, this.props.key, this.state.value, this.props.params);
  }
  initValue() {
    if (this.state.value == "") {
      this.state.value = new Length(0, this.getUnit());
    }
  }
  [INPUT("$body .property-number")](e) {
    var value = +e.$dt.value;
    this.initValue();
    this.updateData({
      value: new Length(value, this.getUnit())
    });
  }
  [SUBSCRIBE_SELF("changeUnit")](key, value) {
    this.initValue();
    this.updateData({
      value: this.state.value.toUnit(value)
    });
  }
  [FOCUSIN("$body input[type=number]")](e) {
    this.refs.$range.addClass("focused");
    e.$dt.select();
  }
  [FOCUSOUT("$body input[type=number]")]() {
    this.refs.$range.removeClass("focused");
  }
  [POINTERSTART("$body .elf--input-range-editor label") + MOVE("moveDrag") + END("moveDragEnd")]() {
    this.refs.$range.addClass("drag");
    this.initNumberValue = +this.refs.$propertyNumber.value;
    this.initUnit = this.state.value.unit;
    this.initUnits = this.state.units;
    this.refs.$propertyNumber.focus();
    this.refs.$propertyNumber.select();
  }
  moveDrag(dx) {
    let newValue = Math.floor(round(this.initNumberValue + dx * this.state.step, 100));
    newValue = Math.min(this.state.max, Math.max(this.state.min, newValue));
    this.updateData({
      value: new Length(newValue, this.getUnit())
    });
    this.refs.$propertyNumber.val(this.state.value.value);
  }
  moveDragEnd() {
    this.refs.$range.removeClass("drag");
  }
}
var RangeEditor$1 = "";
class RangeEditor extends EditorElement {
  initState() {
    var units = this.props.units || ["px", "em", "%"];
    var value = Length.parse(this.props.value || 0);
    return {
      removable: this.props.removable === "true",
      calc: this.props.calc === "true" ? true : false,
      compact: this.props.compact === "true" ? true : false,
      label: this.props.label || "",
      min: +this.props.min || 0,
      max: +this.props.max || 100,
      step: +this.props.step || 1,
      key: this.props.key,
      params: this.props.params || "",
      layout: this.props.layout || "",
      units,
      value
    };
  }
  template() {
    return `<div class='small-editor' ref='$body'></div>`;
  }
  [LOAD("$body")]() {
    var { min, max, step: step2, label, removable, layout: layout2, compact } = this.state;
    var value = +this.state.value.value.toString();
    if (isNaN(value)) {
      value = 0;
    }
    var layoutClass = layout2;
    var realValue = (+value).toString();
    if (this.state.units === "%") {
      throw new Error("%");
    }
    var units = this.state.units.map((it) => {
      let description = it;
      if (description === "number") {
        description = "";
      }
      return { value: it, text: description };
    });
    return `
        <div 
            ref="$range"
            class="${classnames({
      "elf--range--editor": true,
      "has-label": !!label,
      compact: !!compact,
      "is-removable": removable,
      [layoutClass]: true
    })}"
        >
            ${label ? `<label title="${label}">${label}</label>` : ""}
            <div class='range--editor-type' data-type='range'>
                <input type='range' ref='$property' value="${realValue}" min="${min}" max="${max}" step="${step2}" /> 
                <div class='area' ref='$rangeArea'>
                    <input type='number' ref='$propertyNumber' value="${realValue}" min="${min}" max="${max}" step="${step2}" tabIndex="1" />
                    ${createComponent("SelectEditor", {
      ref: "$unit",
      key: "unit",
      value: this.state.value.unit,
      options: units,
      onchange: "changeUnit"
    })}
                </div>
            </div>
            <button type='button' class='remove thin' ref='$remove' title='Remove'>${obj$2.remove}</button>
        </div>
    `;
  }
  getValue() {
    return this.state.value.clone();
  }
  setValue(value) {
    this.setState({
      value: Length.parse(value)
    });
  }
  [FOCUS('$body input[type="number"]')]() {
    this.refs.$rangeArea.addClass("focused");
  }
  [BLUR('$body input[type="number"]')]() {
    this.refs.$rangeArea.removeClass("focused");
  }
  updateData(data) {
    this.setState(data, false);
    this.parent.trigger(this.props.onchange, this.props.key, this.state.value, this.props.params);
  }
  initValue() {
    if (this.state.value == "") {
      this.state.value = new Length(0, this.children.$unit.getValue());
    }
  }
  [INPUT('$body input[type="number"]')]() {
    var value = +this.refs.$propertyNumber.value;
    this.getRef("$property").val(value);
    this.initValue();
    this.updateData({
      value: new Length(value, this.children.$unit.getValue())
    });
  }
  [INPUT('$body input[type="range"]')]() {
    this.trigger("changeRangeValue");
  }
  [POINTERSTART('$body input[type="range"]') + END()]() {
  }
  end() {
    this.trigger("changeRangeValue");
  }
  [SUBSCRIBE_SELF("changeRangeValue")]() {
    var value = +this.getRef("$property").value;
    this.refs.$propertyNumber.val(value);
    this.initValue();
    this.updateData({
      value: new Length(value, this.children.$unit.getValue())
    });
  }
  [SUBSCRIBE_SELF("changeUnit")](key, value) {
    this.initValue();
    this.updateData({
      value: this.state.value.toUnit(value)
    });
  }
}
class IterationCountEditor extends RangeEditor {
  initState() {
    var value = this.props.value;
    if (value === "infinite") {
      value = new Length(0, "infinite");
    } else {
      value = Length.number(value);
    }
    var units = this.props.units || ["px", "em", "%"];
    return __spreadValues(__spreadValues({}, super.initState()), {
      key: this.props.key,
      params: this.props.params || "",
      units,
      value
    });
  }
}
var MediaProgressEditor$1 = "";
class MediaProgressEditor extends EditorElement {
  initState() {
    const [start2, end2, duration] = (this.props.value || "").split(":");
    return {
      start: +(start2 || 0),
      end: +(end2 || 1),
      duration: +(duration || 1)
    };
  }
  refresh() {
    this.load();
    this.children.$s.setValue(this.state.start * this.state.duration);
    this.children.$e.setValue(this.state.end * this.state.duration);
    this.children.$s.setMax(this.state.duration);
    this.children.$e.setMax(this.state.duration);
  }
  template() {
    const { start: start2, end: end2, duration } = this.state;
    return `
            <div class='elf--media-progress-editor'>
                <div class='drag-area'>
                    <div class='progress-bar' ref='$progress'></div>
                    <div class='bar' ref='$bar'></div>                
                    <div class='drag-item start' ref='$start'></div>
                    <div class='drag-item end' ref='$end'></div>
                </div>
                <div class='item'>
                    ${createComponent("NumberRangeEditor", {
      ref: "$s",
      label: "Start",
      key: "start",
      min: 0,
      max: duration,
      step: 1e-3,
      value: start2 * duration,
      onchange: "changeValue"
    })}
                </div>
                <div class='item'>
                    ${createComponent("NumberRangeEditor", {
      ref: "$e",
      label: "End",
      key: "end",
      min: 0,
      max: duration,
      step: 1e-3,
      value: end2 * duration,
      onchange: "changeValue"
    })}
                </div>                
            </div>
        `;
  }
  [SUBSCRIBE_SELF("changeValue")](key, value) {
    this.updateData({
      [key]: value / this.state.duration
    }, true);
  }
  [POINTERSTART("$start") + MOVE("moveStart")]() {
    this.rect = this.refs.$progress.rect();
    this.pos = Length.parse(this.refs.$start.css("left")).toPx(this.rect.width);
    this.max = Length.parse(this.refs.$end.css("left")).toPx(this.rect.width);
  }
  moveStart(dx) {
    var realPos = Math.min(this.max.value, Math.max(0, this.pos.value + dx));
    this.state.start = realPos / this.rect.width;
    this.children.$s.setValue(this.state.start * this.state.duration);
    this.refresh();
    this.updateData();
  }
  [BIND("$start")]() {
    return {
      "data-info": this.state.start,
      style: {
        left: Length.percent((this.state.start || 0) * 100)
      }
    };
  }
  [POINTERSTART("$end") + MOVE("moveStartForEnd")]() {
    this.rect = this.refs.$progress.rect();
    this.pos = Length.parse(this.refs.$end.css("left")).toPx(this.rect.width);
    this.min = Length.parse(this.refs.$start.css("left")).toPx(this.rect.width);
    this.max = this.rect.width;
  }
  moveStartForEnd(dx) {
    var realPos = Math.max(this.min.value, Math.min(this.max.value, this.pos.value + dx));
    this.state.end = realPos / this.rect.width;
    this.children.$e.setValue(this.state.end * this.state.duration);
    this.refresh();
    this.updateData();
  }
  [BIND("$end")]() {
    return {
      "data-info": this.state.end,
      style: {
        left: Length.percent((this.state.end || 1) * 100)
      }
    };
  }
  [BIND("$bar")]() {
    const start2 = this.state.start || 0;
    const end2 = this.state.end || 1;
    return {
      style: {
        left: Length.percent(start2 * 100),
        width: Length.percent((end2 - start2) * 100)
      }
    };
  }
  getValue() {
    const { start: start2, end: end2, duration } = this.state;
    return `${start2}:${end2}:${duration}`;
  }
  setValue(value) {
    const [start2, end2, duration] = value.split(":");
    this.setState({
      start: Number(start2),
      end: Number(end2),
      duration: Number(duration)
    });
  }
  updateData(data = {}, isRefresh = false) {
    this.setState(data, isRefresh);
    this.parent.trigger(this.props.onchange, this.props.key, this.getValue(), this.props.params);
  }
}
var NumberInputEditor$1 = "";
class NumberInputEditor extends EditorElement {
  initState() {
    var value = +this.props.value;
    let label = this.props.label || "";
    if (obj$2[label]) {
      label = obj$2[label];
    }
    const compact = isBoolean(this.props.compact) ? this.props.compact : this.props.compact === "true";
    const wide = isBoolean(this.props.wide) ? this.props.wide : this.props.wide === "true";
    const mini = isBoolean(this.props.mini) ? this.props.mini : this.props.mini === "true";
    const trigger = this.props.trigger || "input";
    return {
      label,
      compact,
      wide,
      mini,
      trigger,
      min: +this.props.min || 0,
      max: +this.props.max || 100,
      step: +this.props.step || 1,
      key: this.props.key,
      params: this.props.params || "",
      layout: this.props.layout || "",
      value
    };
  }
  template() {
    return `<div class='small-editor' ref='$body'></div>`;
  }
  [LOAD("$body") + DOMDIFF]() {
    var {
      min,
      max,
      step: step2,
      label,
      type,
      layout: layout2,
      mini,
      compact,
      wide,
      disabled,
      removable
    } = this.state;
    var value = this.state.value;
    if (isNaN(value)) {
      value = 0;
    }
    var layoutClass = layout2;
    var realValue = (+value).toString();
    return `
        <div 
            class="${classnames({
      "elf--number-input-editor": true,
      "has-label": !!label,
      compact: !!compact,
      wide: !!wide,
      mini: !!mini,
      "is-removable": removable,
      disabled,
      [layoutClass]: true
    })}"
            ref="$range"
            data-selected-type='${type}'>
            ${label ? `<label>${label}</label>` : ""}
            <div class='range--editor-type' data-type='range'>
                <div class='area'>
                    <input type='number' ref='$propertyNumber' value="${realValue}" min="${min}" max="${max}" step="${step2}" />
                </div>
            </div>
        </div>
    `;
  }
  getValue() {
    return this.state.value || 0;
  }
  setValue(value) {
    this.setState({
      value
    }, false);
    this.refs.$propertyNumber.val(this.state.value);
  }
  updateData(data) {
    this.setState(data, false);
    this.parent.trigger(this.props.onchange, this.props.key, this.state.value, this.props.params);
  }
  [FOCUSIN("$body input[type=number]")](e) {
    this.refs.$range.addClass("focused");
    e.$dt.select();
  }
  [FOCUSOUT("$body input[type=number]")]() {
    this.refs.$range.removeClass("focused");
  }
  updateValue(e) {
    var value = +e.$dt.value;
    this.updateData({
      value
    });
  }
  isTriggerInput() {
    return this.state.trigger === "input";
  }
  isTriggerEnter() {
    return this.state.trigger === "enter";
  }
  [INPUT("$body input[type=number]") + IF("isTriggerInput") + DEBOUNCE(500)](e) {
    this.updateValue(e);
  }
  [KEYUP("$body input[type=number]") + IF("isTriggerEnter") + ENTER](e) {
    this.updateValue(e);
    e.$dt.select();
  }
  [POINTERSTART("$body label") + MOVE("moveDrag") + END("moveDragEnd")]() {
    this.refs.$range.addClass("drag");
    this.initValue = +this.refs.$propertyNumber.value;
  }
  moveDrag(dx) {
    let newValue = round(this.initValue + dx * this.state.step, 1 / this.state.step);
    newValue = Math.min(this.state.max, Math.max(this.state.min, newValue));
    this.updateData({
      value: newValue
    });
    this.refs.$propertyNumber.val(this.state.value);
  }
  moveDragEnd() {
    this.refs.$range.removeClass("drag");
  }
}
var NumberRangeEditor$1 = "";
class NumberRangeEditor extends EditorElement {
  initState() {
    var value = Length.parse(this.props.value || Length.number(0));
    value = value.toUnit("number");
    return {
      removable: this.props.removable === "true",
      compact: this.props.compact === "true",
      wide: this.props.wide === "true",
      clamp: this.props.clamp === "true",
      label: this.props.label || "",
      min: +this.props.min || 0,
      max: +this.props.max || 100,
      step: +this.props.step || 1,
      key: this.props.key,
      params: this.props.params || "",
      layout: this.props.layout || "",
      value
    };
  }
  template() {
    return `<div class='small-editor' ref='$body'></div>`;
  }
  [LOAD("$body")]() {
    var { min, max, step: step2, label, removable, layout: layout2, compact, wide, disabled } = this.state;
    var value = +this.state.value.value.toString();
    if (isNaN(value)) {
      value = 0;
    }
    var layoutClass = layout2;
    var realValue = (+value).toString();
    return `
        <div 
            class="${classnames({
      "elf--number-range-editor": true,
      "has-label": !!label,
      compact: !!compact,
      wide: !!wide,
      "is-removable": removable,
      disabled,
      [layoutClass]: true
    })}"
        >
            ${label ? `<label title="${label}">${label}</label>` : ""}
            <div class='range--editor-type' data-type='range'>
                <div class='area'>
                    <div>
                        <input type='range' ref='$property' value="${realValue}" min="${min}" max="${max}" step="${step2}" />
                    </div>
                    <div>
                        <input type='number' ref='$propertyNumber' value="${realValue}" min="${min}" max="${max}" step="${step2}" tabIndex="1" />
                    </div>
                </div>
            </div>
            <button type='button' class='remove' ref='$remove' title='Remove'>${obj$2.remove}</button>
        </div>
    `;
  }
  setMin(value) {
    this.setState({
      min: Length.parse(value)
    });
  }
  setMax(value) {
    this.setState({
      max: Length.parse(value)
    });
  }
  getValue() {
    if (this.state.clamp) {
      return this.state.value.clamp(this.state.min, this.state.max);
    }
    return this.state.value;
  }
  setValue(value) {
    console.log(value);
    this.setState({
      value: Length.parse(value)
    });
  }
  [FOCUS('$body input[type="number"]')]() {
    this.refs.$propertyNumber.addClass("focused");
  }
  [BLUR('$body input[type="number"]')]() {
    this.refs.$propertyNumber.removeClass("focused");
  }
  [CLICK("$remove")]() {
    this.updateData({
      value: ""
    });
  }
  updateData(data) {
    this.setState(data, false);
    this.parent.trigger(this.props.onchange, this.props.key, this.getValue(), this.props.params);
  }
  [INPUT('$body input[type="number"]')]() {
    var value = +this.refs.$propertyNumber.value;
    this.getRef("$property").val(value);
    this.updateData({
      value: this.state.value.set(value)
    });
  }
  [INPUT('$body input[type="range"]')]() {
    this.trigger("changeRangeValue");
  }
  [POINTERSTART('$body input[type="range"]') + END()]() {
  }
  end() {
    this.trigger("changeRangeValue");
  }
  [SUBSCRIBE_SELF("changeRangeValue")]() {
    var value = +this.getRef("$property").value;
    this.getRef("$propertyNumber").val(value);
    if (this.state.value === "") {
      this.state.value = Length.number(0);
    }
    this.updateData({
      value: this.state.value.set(value)
    });
  }
}
var PathEditor$1 = "";
class PathStringManager {
  constructor() {
    this.pathArray = [];
  }
  reset() {
    this.pathArray = [];
  }
  getPointString(values) {
    return values.map((v) => `${v.x} ${v.y}`).join(" ");
  }
  makeString(command, values = []) {
    this.pathArray.push(`${command} ${this.getPointString(values)}`);
    return this;
  }
  M(...values) {
    return this.makeString("M", values);
  }
  L(...values) {
    return this.makeString("L", values);
  }
  X(...values) {
    const dist2 = 3;
    const point2 = values[0];
    const topLeft = { x: point2.x - dist2, y: point2.y - dist2 };
    const topRight = { x: point2.x + dist2, y: point2.y - dist2 };
    const bottomLeft = { x: point2.x - dist2, y: point2.y + dist2 };
    const bottomRight = { x: point2.x + dist2, y: point2.y + dist2 };
    return this.M(topLeft).L(bottomRight).M(topRight).L(bottomLeft);
  }
  Q(...values) {
    return this.makeString("Q", values);
  }
  C(...values) {
    return this.makeString("C", values);
  }
  Z() {
    return this.makeString("Z");
  }
  get d() {
    return this.pathArray.join(" ").trim();
  }
  toString(className = "object") {
    return `<path d="${this.d}" class='${className}'/>`;
  }
}
class SegmentManager {
  constructor(viewport) {
    this.viewport = viewport;
    this.segmentList = [];
  }
  get hasViewport() {
    return Boolean(this.viewport);
  }
  reset() {
    this.segmentList = [];
    return this;
  }
  checkInViewport(point2) {
    if (!this.hasViewport)
      return true;
    const vertext = this.viewport.applyVertexInverse([point2.x, point2.y, 0]);
    return this.viewport.checkInViewport(vertext);
  }
  addLine(a, b) {
    if (this.hasViewport && getDist(a.x, a.y, b.x, b.y) < 1)
      return this;
    if (this.checkInViewport(a) || this.checkInViewport(b)) {
      this.segmentList.push({
        line: true,
        x1: a.x,
        y1: a.y,
        x2: b.x,
        y2: b.y
      });
    }
    return this;
  }
  addGuideLine(a, b) {
    if (this.hasViewport && getDist(a.x, a.y, b.x, b.y) < 1)
      return this;
    if (this.checkInViewport(a) || this.checkInViewport(b)) {
      this.segmentList.push({
        line: true,
        guide: true,
        x1: a.x,
        y1: a.y,
        x2: b.x,
        y2: b.y
      });
    }
    return this;
  }
  addDistanceLine(a, b) {
    if (this.hasViewport && getDist(a.x, a.y, b.x, b.y) < 1)
      return this;
    this.segmentList.push({
      line: true,
      distance: true,
      x1: a.x,
      y1: a.y,
      x2: b.x,
      y2: b.y
    });
    return this;
  }
  addDistanceAngle(center2, rx, ry, degree, last, line2) {
    this.segmentList.push({
      angle: true,
      rx,
      ry,
      line: line2,
      degree,
      center: center2,
      last
    });
    return this;
  }
  addPoint(obj2, point2, index2, segment, selected = false) {
    if (this.checkInViewport(point2)) {
      this.segmentList.push(__spreadProps(__spreadValues({}, obj2), {
        cx: point2.x,
        cy: point2.y,
        selected,
        index: index2,
        segment,
        isFirst: point2.isFirst,
        isLast: point2.isLast,
        isSecond: point2.isSecond
      }));
    }
    return this;
  }
  addStartPoint(obj2, point2) {
    if (this.checkInViewport(point2)) {
      this.segmentList.push(__spreadProps(__spreadValues({}, obj2), {
        cx: point2.x,
        cy: point2.y,
        start: true
      }));
    }
    return this;
  }
  addCurvePoint(point2, index2, segment, selected = false) {
    if (this.checkInViewport(point2)) {
      this.segmentList.push({
        curve: true,
        cx: point2.x,
        cy: point2.y,
        index: index2,
        selected,
        segment,
        isFirst: point2.isFirst,
        isLast: point2.isLast,
        isSecond: point2.isSecond
      });
    }
    return this;
  }
  addText(point2, text2) {
    this.segmentList.push({
      type: "text",
      cx: point2.x,
      cy: point2.y,
      text: text2 + ""
    });
    return this;
  }
  toString() {
    this.segmentList.sort((a, b) => {
      if (a.line && !b.line) {
        return -1;
      } else if (!a.line && b.line) {
        return 1;
      }
      return 0;
    });
    return this.segmentList.map((it) => {
      if (it.angle) {
        return `
                <path stroke-width='1' 
                    data-distance='true'
                    fill="rgba(0,0,0,0.5)"
                    d="M ${it.center.x},${it.center.y} A ${it.rx} ${it.ry},${it.degree},0,0,${it.last.x} ${it.last.y} L${it.line.x} ${it.line.y} Z"
                />`;
      } else if (it.line) {
        return `
                <line stroke-width='1' 
                    data-segment="true"
                    data-is-last="${it.isLast}"                
                    data-guide='${it.guide}'
                    data-distance='${it.distance}'
                    x1='${it.x1}' x2='${it.x2}' y1='${it.y1}' y2='${it.y2}' 
                />`;
      } else if (it.text) {
        return "";
      } else if (it.curve && it.segment !== "startPoint") {
        return `
                <path stroke-width='1'
                    class='curve' 
                    ${it.selected && `data-selected="true"`}
                    ${it.isLast && `data-is-last="true"`}
                    ${it.isFirst && `data-is-first="true"`}
                    ${it.isSecond && `data-is-second="true"`}
                    title="${it.segment} curve"  
                    data-index='${it.index}'
                    data-segment-point='${it.segment}'
                    data-segment="true" 
                    d="M ${it.cx} ${it.cy - 4}L ${it.cx + 4} ${it.cy} L ${it.cx} ${it.cy + 4} L ${it.cx - 4} ${it.cy} Z"
                />`;
      } else if (it.start) {
        return `
                <circle 
                    cx='${it.cx}' 
                    cy='${it.cy}' 
                    r='4'                    
                    class='segment'
                    data-selected='${it.selected}'
                    title="Center"
                    data-start="true" 
                    tabIndex="-1"
                />`;
      } else {
        return `
                <circle 
                    cx='${it.cx}' 
                    cy='${it.cy}' 
                    r='4'                    
                    class='segment'
                    data-selected='${it.selected}'
                    title="${it.segment}"
                    data-is-last="${it.isLast}"
                    data-is-first="${it.isFirst}"
                    data-is-second="${it.isSecond}"
                    data-index='${it.index}' 
                    data-segment-point='${it.segment}' 
                    data-segment="true" 
                    tabIndex="-1"                    
                />`;
      }
    }).join("");
  }
}
const SEGMENT_DIRECTION$1 = ["startPoint", "endPoint", "reversePoint"];
function calculateSnapPoint$1(points, sourceKey, target, distanceValue, dist2) {
  var checkedPointList = points.filter((p) => {
    if (!p)
      return false;
    return Math.abs(p[sourceKey] - target) <= dist2;
  }).map((p) => {
    return { dist: Math.abs(p[sourceKey] - target), point: p };
  });
  checkedPointList.sort((a, b) => {
    return a.dist < b.dist ? -1 : 1;
  });
  var point2 = null;
  if (checkedPointList.length) {
    point2 = checkedPointList[0].point;
    distanceValue += point2[sourceKey] - target;
  }
  return { point: point2, distanceValue };
}
function calculateMovePointSnap$1(points, moveXY, dist2 = 1) {
  var snapPointX = calculatePointDist$1(points, "x", moveXY.x, dist2);
  var snapPointY = calculatePointDist$1(points, "y", moveXY.y, dist2);
  var snapEndPoint = __spreadValues({}, moveXY);
  if (snapPointX) {
    snapEndPoint.x = snapPointX.x;
  }
  if (snapPointY) {
    snapEndPoint.y = snapPointY.y;
  }
  var snapPointList = [];
  if (snapPointX) {
    snapPointList.push({ startPoint: snapPointX, endPoint: snapEndPoint });
  }
  if (snapPointY) {
    snapPointList.push({ startPoint: snapPointY, endPoint: snapEndPoint });
  }
  return { snapPointList, moveXY: snapEndPoint };
}
function calculatePointDist$1(points, sourceKey, target, dist2) {
  var checkedPointList = [];
  var arr = SEGMENT_DIRECTION$1;
  points.filter((p) => p).forEach((p) => {
    arr.filter((key) => p[key]).forEach((key) => {
      var point2 = p[key];
      var tempDist = Math.abs(point2[sourceKey] - target);
      if (tempDist <= dist2) {
        checkedPointList.push({ dist: tempDist, point: point2 });
      }
    });
  });
  checkedPointList.sort((a, b) => {
    return a.dist > b.dist ? 1 : -1;
  });
  return checkedPointList.length ? checkedPointList[0].point : null;
}
function toPath$1(points, minX, minY, scale2 = 1) {
  var d = [];
  for (var index2 = 0, len2 = points.length; index2 < len2; index2++) {
    var currentIndex = index2;
    var current = points[currentIndex];
    if (!current)
      continue;
    if (current.command === "M") {
      d.push({ command: "M", values: [current.startPoint] });
    } else {
      var prevPoint = Point.getPrevPoint(points, index2);
      if (current.curve === false) {
        if (prevPoint.curve === false) {
          d.push({ command: "L", values: [current.startPoint] });
        } else {
          d.push({
            command: "Q",
            values: [prevPoint.endPoint, current.startPoint]
          });
        }
      } else {
        if (prevPoint.curve === false) {
          if (Point.isEqual(current.reversePoint, current.startPoint)) {
            d.push({ command: "L", values: [current.startPoint] });
          } else {
            d.push({
              command: "Q",
              values: [current.reversePoint, current.startPoint]
            });
          }
        } else {
          d.push({
            command: "C",
            values: [
              prevPoint.endPoint,
              current.reversePoint,
              current.startPoint
            ]
          });
        }
      }
    }
    if (current.close) {
      d.push({ command: "Z" });
    }
  }
  var dString = d.map((segment) => {
    return calculateRelativePosition$1(minX, minY, segment, scale2);
  }).join(" ");
  return {
    d: dString
  };
}
function calculateRelativePosition$1(minX, minY, segment, scale2 = 1) {
  var { command, values } = segment;
  switch (command) {
    case "Z":
      return "Z";
    default:
      var str = values.map((v) => {
        var tx = v.x - minX === 0 ? 0 : (v.x - minX) / scale2;
        var ty = v.y - minY === 0 ? 0 : (v.y - minY) / scale2;
        return `${tx} ${ty}`;
      }).join(" ");
      return `${command} ${str}`;
  }
}
function checkInArea$1(area2, point2) {
  if (area2.x2.value < point2.x) {
    return false;
  }
  if (area2.y2.value < point2.y) {
    return false;
  }
  if (area2.x.value > point2.x) {
    return false;
  }
  if (area2.y.value > point2.y) {
    return false;
  }
  return true;
}
class PurePathGenerator {
  generatorPathString(points, minX = 0, minY = 0, scale2 = 1) {
    return toPath$1(points, minX, minY, scale2).d;
  }
  constructor(pathEditor) {
    this.pathEditor = pathEditor;
    this.pathStringManager = new PathStringManager();
    this.guideLineManager = new PathStringManager();
    this.segmentManager = new SegmentManager(null);
    this.points = [];
    this.cachedSegmentKeys = {};
    this.initialize();
    this.initializeSelect();
  }
  initialize() {
    this.splitLines = [];
    this.guideLineManager.reset();
    this.segmentManager.reset();
    this.pathStringManager.reset();
  }
  initializeSelect(initPointList = []) {
    this.selectedPointKeys = {};
    this.selectedPointList = [];
    if (initPointList.length) {
      this.select(...initPointList.map((p) => {
        const checkedPoint = this.points[p.index][p.key];
        if (!checkedPoint)
          return void 0;
        return {
          x: checkedPoint.x,
          y: checkedPoint.y,
          key: p.key,
          index: checkedPoint.index
        };
      }).filter(Boolean));
    }
  }
  get state() {
    return this.pathEditor.state;
  }
  get clonePoints() {
    return [...this.points];
  }
  get length() {
    return this.points.length;
  }
  setPoints(points = []) {
    this.points = points;
    this.snapPointList = [];
    if (this.points.length === 0) {
      this.select();
      this.selectGroup(-1);
    }
  }
  selectInBox(box, isToggle = false) {
    var list2 = [];
    this.points.forEach((point2, index2) => {
      SEGMENT_DIRECTION$1.forEach((key) => {
        const p = point2[key];
        if (checkInArea$1(box, p)) {
          list2.push({ x: p.x, y: p.y, key, index: index2 });
        }
      });
    });
    if (isToggle) {
      list2 = list2.map((it) => {
        const selectedKey = this.makeSegmentKey(it);
        return __spreadProps(__spreadValues({}, it), {
          included: Boolean(this.selectedPointKeys[selectedKey])
        });
      });
      const includedList = list2.filter((it) => it.included);
      const notIncludedList = list2.filter((it) => !it.included);
      let uniqueList = [...this.selectedPointList];
      if (includedList.length) {
        uniqueList = this.selectedPointList.filter((it) => {
          const oldKey = this.makeSegmentKey(it);
          return Boolean(includedList.find((includeNode) => {
            return oldKey === this.makeSegmentKey(includeNode);
          })) === false;
        });
      }
      this.select(...uniqueList, ...notIncludedList);
    } else {
      this.select(...list2);
    }
  }
  makeSegmentKey(p) {
    return `${p.key}_${p.index}`;
  }
  select(...list2) {
    this.selectedPointKeys = {};
    this.selectedPointList = list2.map(({ x, y, key, index: index2 }) => ({
      x,
      y,
      key,
      index: +index2
    }));
    list2.forEach((it) => {
      var key = this.makeSegmentKey(it);
      this.selectedPointKeys[key] = true;
    });
  }
  convertPointsToSelectionList(points) {
    var list2 = [];
    points.forEach((point2) => {
      SEGMENT_DIRECTION$1.forEach((key) => {
        const { x, y } = point2[key];
        list2.push({ x, y, key, index: point2.index });
      });
    });
    return list2;
  }
  selectGroup(groupIndex) {
    const group2 = this.splitedGroupList[groupIndex];
    if (group2) {
      this.select(...this.convertPointsToSelectionList(group2.points));
    } else {
      this.select();
    }
  }
  getCacheSegmentKey(segmentKey, index2) {
    if (!this.cachedSegmentKeys[segmentKey]) {
      this.cachedSegmentKeys[segmentKey] = {};
    }
    if (!this.cachedSegmentKeys[segmentKey][index2]) {
      this.cachedSegmentKeys[segmentKey][index2] = this.makeSegmentKey({
        key: segmentKey,
        index: index2
      });
    }
    return this.cachedSegmentKeys[segmentKey][index2];
  }
  toggleSelect(key, index2) {
    if (this.points[index2]) {
      var point2 = this.points[index2][key];
      if (point2 && !this.isSelectedSegment(key, index2)) {
        this.select(...this.selectedPointList, {
          x: point2.x,
          y: point2.y,
          key,
          index: index2
        });
      } else {
        this.select(...this.selectedPointList.filter((it) => {
          return it.key !== key || it.index !== index2;
        }));
      }
    }
  }
  selectKeyIndex(key, index2) {
    if (this.points[index2]) {
      var point2 = this.points[index2][key];
      if (point2 && !this.isSelectedSegment(key, index2)) {
        this.select({ x: point2.x, y: point2.y, key, index: index2 });
      }
    }
  }
  reselect() {
    this.selectedPointList.filter(Boolean).forEach((it) => {
      var _a;
      var point2 = (_a = this.points[it.index]) == null ? void 0 : _a[it.key];
      if (point2) {
        it.x = point2.x;
        it.y = point2.y;
      }
    });
  }
  isSelectedSegment(segment, index2) {
    var key = this.getCacheSegmentKey(segment, index2);
    return this.selectedPointKeys[key];
  }
  commitTransformMatrix(point2, transformMatrix) {
    var result = transformMat4([], [point2.x, point2.y, 0], transformMatrix);
    return { x: result[0], y: result[1] };
  }
  transformMat4(transformMatrix) {
    this.transformPoints.forEach((p, index2) => {
      var realPoint = this.points[index2];
      Object.assign(realPoint.startPoint, this.commitTransformMatrix(p.startPoint, transformMatrix));
      Object.assign(realPoint.endPoint, this.commitTransformMatrix(p.endPoint, transformMatrix));
      Object.assign(realPoint.reversePoint, this.commitTransformMatrix(p.reversePoint, transformMatrix));
    });
  }
  transform(type) {
    var { x, y, width: width2, height: height2 } = this.transformRect;
    var view = create$4();
    translate(view, view, [x, y, 0]);
    switch (type) {
      case "flipX":
        scale$1(view, view, [-1, 1, 1]);
        translate(view, view, [-width2, 0, 0]);
        break;
      case "flipY":
        scale$1(view, view, [1, -1, 1]);
        translate(view, view, [0, -height2, 0]);
        break;
      case "flip":
        scale$1(view, view, [-1, -1, 1]);
        translate(view, view, [-width2, -height2, 0]);
        break;
    }
    translate(view, view, [-x, -y, 0]);
    this.transformMat4(view);
  }
  initTransform(rect2) {
    this.transformRect = clone$1(rect2);
    this.transformPoints = this.clonePoints.map((p) => {
      return {
        startPoint: clone$1(p.startPoint),
        endPoint: clone$1(p.endPoint),
        reversePoint: clone$1(p.reversePoint)
      };
    });
  }
  setConnectedPoint(dx, dy) {
    var state = this.state;
    var x = state.dragXY.x + dx;
    var y = state.dragXY.y + dy;
    var endPoint = { x, y };
    var reversePoint = { x, y };
    if (state.dragPoints) {
      state.reversePoint = Point.getReversePoint(state.startPoint, endPoint);
    }
    var point2 = {
      startPoint: state.startPoint,
      endPoint,
      curve: !!state.dragPoints,
      reversePoint,
      connected: true,
      close: true
    };
    this.points.push(point2);
  }
  setLastPoint(startPoint) {
    var endPoint = clone$1(startPoint);
    var reversePoint = clone$1(startPoint);
    var point2 = {
      startPoint,
      endPoint,
      curve: false,
      reversePoint,
      connected: false,
      close: false
    };
    this.points.push(point2);
  }
  getPrevPoint(index2) {
    return Point.getPrevPoint(this.points, index2);
  }
  getIndexPoint(index2) {
    return Point.getIndexPoint(this.points, index2);
  }
  getNextPoint(index2) {
    return Point.getNextPoint(this.points, index2);
  }
  getConnectedPointList(index2) {
    return Point.getConnectedPointList(this.points, index2);
  }
  isFirst(segment) {
    return Point.isFirst(segment);
  }
  getLastPoint(index2) {
    return Point.getLastPoint(this.points, index2);
  }
  setCachePoint(index2, segmentKey) {
    var state = this.state;
    this.snapPointList = [];
    this.selectedIndex = index2;
    state.connectedPoint = this.getPrevPoint(index2);
    state.connectedPointList = clone$1(Point.getConnectedPointList(this.points, this.selectedIndex));
    if (state.connectedPoint && !state.connectedPoint.connected) {
      state.connectedPoint = null;
    }
    state.segment = this.getIndexPoint(index2);
    if (state.segment.connected) {
      state.connectedPoint = this.getNextPoint(index2);
    }
    var isFirstSegment = this.isFirst(state.segment);
    if (isFirstSegment) {
      var lastPoint = this.getLastPoint(index2);
      if (lastPoint.connected) {
        state.connectedPoint = lastPoint;
      }
    }
    state.segmentKey = segmentKey;
    state.isCurveSegment = state.segment.curve && state.segmentKey != "startPoint";
    state.originalSegment = clone$1(state.segment);
    if (state.connectedPoint) {
      state.originalConnectedPoint = clone$1(state.connectedPoint);
    }
    state.cachedPoints = [];
    this.points.filter((p) => p && p != state.segment).forEach((p) => {
      state.cachedPoints.push(p.startPoint, p.reversePoint, p.endPoint);
    });
  }
  clamp(value, min, max) {
    if (isUndefined(min) || isUndefined(max)) {
      return value;
    }
    return Math.max(min, Math.min(max, value));
  }
  moveSegment(segmentKey, dx, dy, originSegment = void 0, maxWidth = void 0, maxHeight = void 0) {
    if (originSegment) {
      const segment = this.points[originSegment.index][segmentKey];
      segment.x = this.clamp(originSegment[segmentKey].x + dx, 0, maxWidth);
      segment.y = this.clamp(originSegment[segmentKey].y + dy, 0, maxHeight);
    } else {
      var state = this.state;
      var originPoint = state.originalSegment[segmentKey];
      var targetPoint = state.segment[segmentKey];
      if (originPoint) {
        targetPoint.x = this.clamp(originPoint.x + dx, 0, maxWidth);
        targetPoint.y = this.clamp(originPoint.y + dy, 0, maxHeight);
      }
    }
  }
  calculateToCurve(point2, nextPoint, prevPoint) {
    var centerX = (nextPoint.startPoint.x + prevPoint.startPoint.x) / 2;
    var centerY = (nextPoint.startPoint.y + prevPoint.startPoint.y) / 2;
    var dx = (nextPoint.startPoint.x - centerX) / 2;
    var dy = (nextPoint.startPoint.y - centerY) / 2;
    point2.endPoint = {
      x: point2.startPoint.x + dx,
      y: point2.startPoint.y + dy
    };
    point2.reversePoint = {
      x: point2.startPoint.x - dx,
      y: point2.startPoint.y - dy
    };
    return { dx, dy };
  }
  convertToCurve(index2) {
    var point2 = this.points[index2];
    if (point2.curve) {
      point2.curve = false;
      point2.reversePoint = clone$1(point2.startPoint);
      point2.endPoint = clone$1(point2.startPoint);
      if (point2.command === "M") {
        var lastPoint = Point.getPrevPoint(this.points, point2.index);
        if (lastPoint.connected) {
          lastPoint.curve = false;
          lastPoint.reversePoint = clone$1(lastPoint.startPoint);
          lastPoint.endPoint = clone$1(lastPoint.startPoint);
        }
      } else {
        var nextPoint = this.getNextPoint(index2);
        if (nextPoint && nextPoint.command === "M") {
          var firstPoint = nextPoint;
          firstPoint.curve = false;
          firstPoint.reversePoint = clone$1(firstPoint.startPoint);
          firstPoint.endPoint = clone$1(firstPoint.startPoint);
        }
      }
    } else {
      point2.curve = true;
      var prevPoint = this.getPrevPoint(index2);
      var nextPoint = this.getNextPoint(index2);
      if (nextPoint && nextPoint.index < index2 && nextPoint.command === "M") {
        var firstPoint = nextPoint;
        nextPoint = this.getNextPoint(firstPoint.index);
        this.calculateToCurve(point2, nextPoint, prevPoint);
        firstPoint.curve = true;
        firstPoint.endPoint = clone$1(point2.endPoint);
        firstPoint.reversePoint = clone$1(point2.reversePoint);
      } else if (nextPoint && nextPoint.index > index2 && nextPoint.command !== "M") {
        this.calculateToCurve(point2, nextPoint, prevPoint);
      } else if (!nextPoint && prevPoint) {
        var centerX = (point2.startPoint.x - prevPoint.startPoint.x) / 3;
        var centerY = (point2.startPoint.y - prevPoint.startPoint.y) / 3;
        point2.endPoint = {
          x: point2.startPoint.x + centerX,
          y: point2.startPoint.y + centerY
        };
        point2.reversePoint = Point.getReversePoint(point2.startPoint, point2.endPoint);
      } else if (!prevPoint && nextPoint) {
        var centerX = (point2.startPoint.x - nextPoint.startPoint.x) / 3;
        var centerY = (point2.startPoint.y - nextPoint.startPoint.y) / 3;
        point2.endPoint = {
          x: point2.startPoint.x + centerX,
          y: point2.startPoint.y + centerY
        };
        point2.reverse = Point.getReversePoint(point2.startPoint, point2.endPoint);
      }
    }
  }
  moveCurveSegment(segmentKey, dx, dy) {
    var state = this.state;
    this.moveSegment(segmentKey, dx, dy);
    var targetSegmentKey = segmentKey === "endPoint" ? "reversePoint" : "endPoint";
    state.segment[targetSegmentKey] = Point.getReversePoint(state.segment.startPoint, state.segment[segmentKey]);
  }
  rotateSegmentTarget(segmentKey, target) {
    var state = this.state;
    if (state.originalSegment && state.segment) {
      var { x: cx, y: cy } = state.originalSegment.startPoint;
      var { x: rx, y: ry } = state.segment[segmentKey];
      var { x: tx, y: ty } = state.originalSegment[target];
      var { x, y } = getXYInCircle(calculateAngle360(rx - cx, ry - cy), getDist(tx, ty, cx, cy), cx, cy);
      state.segment[target] = { x, y };
    }
  }
  rotateSegment(segmentKey) {
    this.rotateSegmentTarget(segmentKey, segmentKey === "endPoint" ? "reversePoint" : "endPoint");
  }
  calculateSnap(segmentKey, dx, dy, dist2 = 1) {
    var state = this.state;
    var cachedPoints = state.cachedPoints;
    var original = state.originalSegment[segmentKey];
    if (!segmentKey) {
      return { dx, dy, snapPointList: [] };
    }
    var realX = original.x + dx;
    var realY = original.y + dy;
    var { point: snapPointX, distanceValue: dx } = calculateSnapPoint$1(cachedPoints, "x", realX, dx, dist2);
    var { point: snapPointY, distanceValue: dy } = calculateSnapPoint$1(cachedPoints, "y", realY, dy, dist2);
    var snapEndPoint = {
      x: original.x + dx,
      y: original.y + dy
    };
    var snapPointList = [];
    if (snapPointX) {
      snapPointList.push({ startPoint: snapPointX, endPoint: snapEndPoint });
    }
    if (snapPointY) {
      snapPointList.push({ startPoint: snapPointY, endPoint: snapEndPoint });
    }
    return { dx, dy, snapPointList };
  }
  copySegment(from, to) {
    to.startPoint = clone$1(from.startPoint);
    to.endPoint = clone$1(from.endPoint);
    to.reversePoint = clone$1(from.reversePoint);
  }
  get selectedLength() {
    return this.selectedPointList.length;
  }
  moveSelectedSegment(dx, dy) {
    if (this.selectedPointList.length > 0) {
      this.selectedPointList.forEach((it) => {
        var target = this.points[it.index][it.key];
        target.x = it.x + dx;
        target.y = it.y + dy;
      });
    } else if (this.selectedGroup) {
      this.moveSelectedGroup(dx, dy);
    }
  }
  moveSelectedGroup(dx, dy, maxWidth, maxHeight) {
    this.selectedGroup.points.forEach((it) => {
      const target = this.points[it.index];
      target.startPoint.x = this.clamp(it.startPoint.x + dx, 0, maxWidth);
      target.startPoint.y = this.clamp(it.startPoint.y + dy, 0, maxHeight);
      target.endPoint.x = it.endPoint.x + dx;
      target.endPoint.y = it.endPoint.y + dy;
      target.reversePoint.x = it.reversePoint.x + dx;
      target.reversePoint.y = it.reversePoint.y + dy;
    });
  }
  get selectedGroup() {
    return this.splitedGroupList[this.state.selectedGroupIndex];
  }
  get splitedGroupList() {
    return Point.getSplitedGroupList(this.points);
  }
  get groupList() {
    return Point.getGroupList(this.points);
  }
  getGroup(groupList, pointIndex) {
    return Point.getGroup(groupList, pointIndex);
  }
  get selectedGroupIndexList() {
    const groupIndexList = /* @__PURE__ */ new Set();
    const groupList = this.groupList;
    if (this.selectedPointList.length === 0 && this.state.selectedGroupIndex < 0) {
      return groupList.map((group2) => group2.groupIndex);
    }
    const points = this.selectedPointList;
    points.forEach((it) => {
      const group2 = this.getGroup(groupList, it.index);
      if (group2) {
        groupIndexList.add(group2.groupIndex);
      }
    });
    return [.../* @__PURE__ */ new Set([...groupIndexList, this.state.selectedGroupIndex])];
  }
  removeSelectedSegment() {
    this.selectedPointList.forEach((it) => {
      var target = this.points[it.index][it.key];
      target.removed = true;
    });
    const pointGroup = Point.splitPoints(this.points);
    const newPoints = Point.recoverPoints(pointGroup.map((points) => {
      return points.filter((p) => !p.startPoint.removed).map((p) => {
        if (p.endPoint.removed) {
          p.endPoint = clone$1(p.startPoint);
        }
        if (p.reversePoint.removed) {
          p.reversePoint = clone$1(p.startPoint);
        }
        if (Point.isEqual(p.endPoint, p.startPoint, p.reversePoint)) {
          p.command = "L";
          p.curve = false;
        }
        return p;
      });
    }));
    this.points = newPoints;
    this.select();
  }
  move(dx, dy, e, maxWidth, maxHeight) {
    var state = this.state;
    var { isCurveSegment, segmentKey, connectedPoint } = state;
    if (this.selectedPointList.length > 1) {
      this.moveSelectedSegment(dx, dy, maxWidth, maxHeight);
    } else if (this.selectedPointList.length === 1) {
      var { dx, dy, snapPointList } = this.calculateSnap(segmentKey, dx, dy, 3);
      this.snapPointList = snapPointList || [];
      if (isCurveSegment) {
        if (e.altKey) {
          this.moveSegment(segmentKey, dx, dy);
          this.rotateSegment(segmentKey);
        } else if (e.shiftKey) {
          this.moveSegment(segmentKey, dx, dy);
        } else {
          this.moveSegment(segmentKey, dx, dy);
          var targetSegmentKey = segmentKey === "endPoint" ? "reversePoint" : "endPoint";
          state.segment[targetSegmentKey] = Point.getReversePoint(state.segment.startPoint, state.segment[segmentKey]);
        }
      } else {
        this.moveSegment("startPoint", dx, dy, null, maxWidth, maxHeight);
        this.moveSegment("endPoint", dx, dy);
        this.moveSegment("reversePoint", dx, dy);
        if (!e.altKey) {
          state.connectedPointList.forEach((it) => {
            this.moveSegment("startPoint", dx, dy, it, maxWidth, maxHeight);
            this.moveSegment("endPoint", dx, dy, it);
            this.moveSegment("reversePoint", dx, dy, it);
          });
        }
      }
      connectedPoint && this.copySegment(state.segment, state.connectedPoint);
    } else if (this.state.selectedGroupIndex > -1) {
      this.moveSelectedGroup(dx, dy, maxWidth, maxHeight);
    }
  }
  moveEnd(dx, dy) {
    var state = this.state;
    var points = this.points;
    var x = state.dragXY.x + dx;
    var y = state.dragXY.y + dy;
    var endPoint = { x, y };
    var reversePoint = { x, y };
    if (state.dragPoints) {
      reversePoint = Point.getReversePoint(state.startPoint, endPoint);
    }
    points.push({
      command: state.clickCount === 0 ? "M" : "",
      startPoint: state.startPoint,
      endPoint,
      curve: !!state.dragPoints,
      reversePoint
    });
    state.startPoint = null;
    state.dragPoints = false;
    state.moveXY = null;
  }
  setPoint(obj2) {
    var p0 = obj2.first[0];
    var p1 = obj2.second[obj2.second.length - 1];
    var allPoints = this.clonePoints;
    var firstItem = Point.getPoint(allPoints, p0);
    var secondItem = Point.getPoint(allPoints, p1);
    var newPoints = [
      __spreadProps(__spreadValues({}, firstItem), { endPoint: obj2.first[1] }),
      {
        startPoint: obj2.first[3],
        reversePoint: obj2.first[2],
        curve: true,
        endPoint: obj2.second[1]
      },
      __spreadProps(__spreadValues({}, secondItem), { reversePoint: obj2.second[2] })
    ];
    var firstIndex = Point.getIndex(allPoints, p0);
    allPoints.splice(firstIndex, 2, ...newPoints);
    this.points = allPoints;
    return firstIndex + 1;
  }
  setPointQuard(obj2) {
    var p0 = obj2.first[0];
    var p1 = obj2.second[obj2.second.length - 1];
    var allPoints = this.clonePoints;
    var firstItem = Point.getPoint(allPoints, p0);
    var secondItem = Point.getPoint(allPoints, p1);
    if (firstItem.curve && secondItem.curve === false) {
      var newPoints = [
        __spreadProps(__spreadValues({}, firstItem), { endPoint: firstItem.startPoint }),
        {
          startPoint: obj2.first[2],
          reversePoint: obj2.first[1],
          curve: true,
          endPoint: obj2.second[1]
        }
      ];
      var firstIndex = Point.getIndex(allPoints, p0);
      allPoints.splice(firstIndex, 1, ...newPoints);
    } else {
      var newPoints = [
        __spreadValues({}, firstItem),
        {
          startPoint: obj2.first[2],
          reversePoint: obj2.first[1],
          curve: true,
          endPoint: obj2.second[1]
        },
        __spreadProps(__spreadValues({}, secondItem), { reversePoint: obj2.second[1], curve: true })
      ];
      var firstIndex = Point.getIndex(allPoints, p0);
      allPoints.splice(firstIndex, 2, ...newPoints);
    }
    this.points = allPoints;
    return firstIndex + 1;
  }
  setPointLine(obj2) {
    var p0 = obj2.first[0];
    var allPoints = this.clonePoints;
    var newPoints = [
      {
        command: "L",
        startPoint: obj2.first[1],
        curve: false,
        endPoint: obj2.first[1],
        reversePoint: obj2.first[1]
      }
    ];
    var firstIndex = Point.getIndex(allPoints, p0);
    allPoints.splice(firstIndex + 1, 0, ...newPoints);
    this.points = allPoints;
    return firstIndex + 1;
  }
  toPath(minX = 0, minY = 0, scale2 = 1) {
    return toPath$1(this.clonePoints, minX, minY, scale2);
  }
  makeSVGPath() {
    this.initialize();
    this.makePointGuide(this.points);
    this.makeMovePositionGuide();
    return this.toSVGString();
  }
  makeTriangleDistancePointGuide(first, second) {
    var minX = Math.min(first.startPoint.x, second.startPoint.x);
    var maxX = Math.max(first.startPoint.x, second.startPoint.x);
    var minY = Math.min(first.startPoint.y, second.startPoint.y);
    var maxY = Math.max(first.startPoint.y, second.startPoint.y);
    if (first.startPoint.x < second.startPoint.x && first.startPoint.y < second.startPoint.y) {
      this.segmentManager.addDistanceLine({ x: minX, y: minY }, { x: maxX, y: minY }).addDistanceLine({ x: maxX, y: minY }, { x: maxX, y: maxY });
      var centerX = minX;
      var centerY = minY;
      var angle = calculateAngle360(maxX - minX, maxY - minY) - 180;
      var dist2 = 20;
      var { x, y } = getXYInCircle(0, dist2, centerX, centerY);
      var last = getXYInCircle(angle, dist2, centerX, centerY);
      this.segmentManager.addDistanceAngle(last, dist2, dist2, angle, { x, y }, { x: x - dist2, y });
    } else if (first.startPoint.x < second.startPoint.x && first.startPoint.y > second.startPoint.y) {
      this.segmentManager.addDistanceLine({ x: minX, y: maxY }, { x: maxX, y: maxY }).addDistanceLine({ x: maxX, y: minY }, { x: maxX, y: maxY });
    } else if (first.startPoint.x > second.startPoint.x && first.startPoint.y > second.startPoint.y) {
      this.segmentManager.addDistanceLine({ x: minX, y: minY }, { x: minX, y: maxY }).addDistanceLine({ x: minX, y: maxY }, { x: maxX, y: maxY });
    } else if (first.startPoint.x > second.startPoint.x && first.startPoint.y < second.startPoint.y) {
      this.segmentManager.addDistanceLine({ x: minX, y: maxY }, { x: maxX, y: maxY }).addDistanceLine({ x: maxX, y: minY }, { x: maxX, y: maxY });
    }
  }
  makeDistancePointGuide(prevPoint, current, nextPoint) {
    if (current.selected) {
      if (prevPoint) {
        this.makeTriangleDistancePointGuide(prevPoint, current);
      }
      if (nextPoint) {
        this.makeTriangleDistancePointGuide(current, nextPoint);
      }
    }
  }
  makeStartPointGuide(prevPoint, current, nextPoint, index2) {
    current.startPoint.isFirst = true;
    if (current.curve === false) {
      this.segmentManager.addPoint({}, current.startPoint, index2, "startPoint", this.isSelectedSegment("startPoint", index2));
    } else {
      this.segmentManager.addPoint({}, current.startPoint, index2, "startPoint", this.isSelectedSegment("startPoint", index2)).addGuideLine(current.startPoint, current.endPoint);
      if (Point.isEqual(current.startPoint, current.endPoint) === false) {
        this.segmentManager.addCurvePoint(current.endPoint, index2, "endPoint", this.isSelectedSegment("endPoint", index2));
      }
    }
  }
  makeMiddlePointGuideSegment(prevPoint, current, nextPoint, index2) {
    var mng = this.segmentManager;
    if (current.curve === false) {
      if (prevPoint.curve === false) {
        mng.addPoint({}, current.startPoint, index2, "startPoint", this.isSelectedSegment("startPoint", index2));
      } else {
        mng.addGuideLine(prevPoint.startPoint, prevPoint.endPoint).addCurvePoint(current.startPoint, index2, "startPoint", this.isSelectedSegment("startPoint", index2));
        if (Point.isEqual(prevPoint.startPoint, prevPoint.endPoint) === false) {
          mng.addCurvePoint(prevPoint.endPoint, prevPoint.index, "endPoint", this.isSelectedSegment("endPoint", prevPoint.index));
        }
      }
    } else {
      if (prevPoint.curve === false) {
        if (Point.isEqual(current.reversePoint, current.startPoint)) {
          mng.addPoint({}, current.startPoint, index2, "startPoint", this.isSelectedSegment("startPoint", index2));
        } else {
          mng.addGuideLine(current.startPoint, current.reversePoint).addCurvePoint(current.startPoint, index2, "startPoint", this.isSelectedSegment("startPoint", index2));
          if (Point.isEqual(current.startPoint, current.reversePoint) === false) {
            mng.addCurvePoint(current.reversePoint, index2, "reversePoint", this.isSelectedSegment("reversePoint", index2));
          }
        }
      } else {
        if (current.connected) {
          mng.addGuideLine(prevPoint.startPoint, prevPoint.endPoint).addGuideLine(current.startPoint, current.reversePoint);
          if (Point.isEqual(prevPoint.startPoint, prevPoint.endPoint) === false) {
            mng.addCurvePoint(prevPoint.endPoint, prevPoint.index, "endPoint", this.isSelectedSegment("endPoint", prevPoint.index));
          }
          if (Point.isEqual(current.startPoint, current.reversePoint) === false) {
            mng.addCurvePoint(current.reversePoint, index2, "reversePoint", this.isSelectedSegment("reversePoint", index2));
          }
        } else {
          mng.addGuideLine(prevPoint.startPoint, prevPoint.endPoint).addGuideLine(current.startPoint, current.reversePoint).addCurvePoint(current.startPoint, index2, "startPoint", this.isSelectedSegment("startPoint", index2));
          if (Point.isEqual(prevPoint.startPoint, prevPoint.endPoint) === false) {
            mng.addCurvePoint(prevPoint.endPoint, prevPoint.index, "endPoint", this.isSelectedSegment("endPoint", prevPoint.index));
          }
          if (Point.isEqual(current.startPoint, current.reversePoint) === false) {
            mng.addCurvePoint(current.reversePoint, index2, "reversePoint", this.isSelectedSegment("reversePoint", index2));
          }
        }
      }
    }
  }
  makeMiddlePointGuideSplitLine(prevPoint, current) {
    const selected = "selected";
    if (current.curve === false) {
      if (prevPoint.curve === false) {
        this.splitLines.push(new PathStringManager().M(prevPoint.startPoint).L(current.startPoint).toString(`split-path ${selected}`));
      } else {
        this.splitLines.push(new PathStringManager().M(prevPoint.startPoint).Q(prevPoint.endPoint, current.startPoint).toString(`split-path ${selected}`));
      }
    } else {
      if (prevPoint.curve === false) {
        if (Point.isEqual(current.reversePoint, current.startPoint)) {
          this.splitLines.push(new PathStringManager().M(prevPoint.startPoint).L(current.startPoint).toString(`split-path ${selected}`));
        } else {
          this.splitLines.push(new PathStringManager().M(prevPoint.startPoint).Q(current.reversePoint, current.startPoint).toString(`split-path ${selected}`));
        }
      } else {
        this.splitLines.push(new PathStringManager().M(prevPoint.startPoint).C(prevPoint.endPoint, current.reversePoint, current.startPoint).toString(`split-path ${selected}`));
      }
    }
  }
  makePointGuide(points) {
    for (var index2 = 0, len2 = points.length; index2 < len2; index2++) {
      var currentIndex = index2;
      var current = points[currentIndex];
      if (!current)
        continue;
      var nextPoint = Point.getNextPoint(points, index2);
      var prevPoint = Point.getPrevPoint(points, index2);
      if (prevPoint && prevPoint.command === "M") {
        if (current.startPoint) {
          current.startPoint.isSecond = true;
        }
      }
      if (current.startPoint) {
        if (nextPoint) {
          current.startPoint.isLast = nextPoint.command === "M";
        } else {
          current.startPoint.isLast = index2 === len2 - 1;
        }
      }
      current.selected = this.selectedIndex === index2;
      if (current.command === "M") {
        this.makeStartPointGuide(prevPoint, current, nextPoint, index2);
      } else {
        this.makeMiddlePointGuideSplitLine(prevPoint, current, nextPoint, index2);
        this.makeMiddlePointGuideSegment(prevPoint, current, nextPoint, index2);
      }
      if (current.close) {
        this.pathStringManager.Z();
      }
    }
  }
  makeMovePositionGuide() {
    var state = this.state;
    var {
      startPoint,
      moveXY,
      dragPoints,
      snapPointList,
      isGroupSegment
    } = state;
    var points = this.points;
    if (moveXY) {
      snapPointList = snapPointList || [];
      var { snapPointList: movePointSnapPointList, moveXY: newMoveXY } = calculateMovePointSnap$1(points, moveXY, 3);
      snapPointList.push.apply(snapPointList, movePointSnapPointList);
      state.moveXY = newMoveXY;
      moveXY = newMoveXY;
      this.snapPointList = snapPointList;
      var prev = points[points.length - 1];
      if (dragPoints && !isGroupSegment) {
        if (!prev) {
          var { x, y } = Point.getReversePoint(startPoint, moveXY);
          this.guideLineManager.M(moveXY).L(startPoint).L({ x, y });
          this.segmentManager.addCurvePoint(startPoint).addCurvePoint(moveXY).addCurvePoint({ x, y });
        } else if (prev.curve) {
          var { x, y } = Point.getReversePoint(startPoint, moveXY);
          this.guideLineManager.M(prev.startPoint).C(prev.endPoint, { x, y }, startPoint);
          this.segmentManager.addGuideLine(prev.startPoint, prev.endPoint).addGuideLine(startPoint, { x, y }).addGuideLine(startPoint, moveXY).addCurvePoint(prev.endPoint).addCurvePoint({ x, y }).addCurvePoint(moveXY).addPoint(false, startPoint);
        } else if (prev.curve === false) {
          var { x, y } = Point.getReversePoint(startPoint, moveXY);
          this.guideLineManager.M(prev.startPoint).Q({ x, y }, startPoint);
          this.segmentManager.addGuideLine(moveXY, { x, y }).addPoint(false, startPoint).addCurvePoint({ x, y }).addCurvePoint(moveXY);
        }
      } else {
        if (!prev)
          ;
        else if (prev.curve) {
          this.guideLineManager.M(prev.startPoint).Q(prev.endPoint, moveXY);
          this.segmentManager.addGuideLine(prev.endPoint, prev.startPoint).addCurvePoint(prev.endPoint);
        } else {
          if (!prev.close) {
            this.guideLineManager.M(prev.startPoint).L(moveXY);
            this.segmentManager.addPoint(false, prev.startPoint);
          }
        }
      }
    }
  }
  makeSnapLines() {
    var snapLines = [];
    if (this.snapPointList) {
      var snapPath = new PathStringManager();
      snapLines = this.snapPointList.map((snapPoint) => {
        snapPath.reset();
        return snapPath.M(snapPoint.startPoint).L(snapPoint.endPoint).X(snapPoint.startPoint).toString("snap-path");
      });
    }
    return snapLines.join("");
  }
  makePathArea() {
    const pathList = this.splitedGroupList.map(({ startPointIndex, points }, groupIndex) => {
      const d = this.generatorPathString(points);
      const verties = toRectVerties(PathParser.fromSVGString(d).getBBox());
      return {
        points,
        startPointIndex,
        groupIndex,
        center: verties[4],
        d
      };
    });
    const pathCount = pathList.length;
    return `
            <g>
               ${pathList.map((it) => {
      const { center: center2 } = it;
      const [x, y] = center2;
      const selected = this.state.selectedGroupIndex === it.groupIndex;
      return `
                        <path class="path-area ${selected ? "selected" : ""}" 
                            d="${it.d}" 
                            data-point-index="${it.startPointIndex}" 
                            data-group-index="${it.groupIndex}" 
                        />

                        ${pathCount > 1 && `
                            <text class="path-area-text" x="${x}" y="${y}" >${it.groupIndex + 1}</text>
                        `}
                    `;
    }).join("")}
            </g>
        `;
  }
  toSVGString() {
    return `
        <svg width="100%" height="100%" class='svg-editor-canvas' tabIndex="-1">
            ${this.guideLineManager.toString("guide")}
            ${this.splitLines.join("")}
            ${this.makeSnapLines()}
            ${this.makePathArea()}
            ${this.segmentManager.toString()}
        </svg>
        `;
  }
}
function xy$1([x, y]) {
  return { x, y };
}
function scaleLinear(source2, target) {
  function targetScale(t) {
    if (target[0] < target[1]) {
      return target[0] + t * (target[1] - target[0]);
    } else if (target[0] > target[1]) {
      return target[0] - t * (target[0] - target[1]);
    }
  }
  function rate(v1, v2, current) {
    const minValue = Math.min(v1, v2);
    const maxValue = Math.max(v1, v2);
    return (current - minValue) / (maxValue - minValue);
  }
  return (x) => {
    if (source2[0] < source2[1]) {
      return targetScale(rate(source2[0], source2[1], x));
    } else if (source2[0] > source2[1]) {
      return targetScale(1 - rate(source2[0], source2[1], x));
    }
  };
}
const SegmentConvertor$1 = class extends EditorElement {
  convertToCurve(index2) {
    this.pathGenerator.convertToCurve(index2);
    this.renderPath();
    this.updatePathLayer();
  }
  isEditableSegment() {
    return this.state.disableCurve === false;
  }
  [DOUBLECLICK("$view [data-segment]") + IF("isEditableSegment") + PREVENT](e) {
    var index2 = +e.$dt.attr("data-index");
    this.convertToCurve(index2);
  }
  [DOUBLETAB("$view [data-segment]") + PREVENT + DELAY(300)](e) {
    var index2 = +e.$dt.attr("data-index");
    this.convertToCurve(index2);
  }
};
const PathCutter$1 = class extends SegmentConvertor$1 {
  calculatePointOnLine(d, clickPosition) {
    var parser = new PathParser(d);
    return parser.getClosedPoint(clickPosition);
  }
  [POINTERSTART("$view .split-path") + MOVE() + END()](e) {
    this.initRect();
    var parser = new PathParser(e.$dt.attr("d"));
    var clickPosition = {
      x: e.xy.x - this.state.rect.x,
      y: e.xy.y - this.state.rect.y
    };
    var selectedSegmentIndex = -1;
    if (this.isMode("path")) {
      this.state.dragXY = clickPosition;
      this.state.startPoint = this.state.dragXY;
      this.pathGenerator.setLastPoint(this.state.startPoint);
      this.state.isSplitPath = true;
      this.renderPath();
      if (this.state.current) {
        this.updatePathLayer();
      }
      return;
    } else {
      if (parser.segments[1].command === "C") {
        var points = [
          xy$1(parser.segments[0].values),
          xy$1(parser.segments[1].values.slice(0, 2)),
          xy$1(parser.segments[1].values.slice(2, 4)),
          xy$1(parser.segments[1].values.slice(4, 6))
        ];
        var curve = recoverBezier(...points, 20);
        var t = curve(clickPosition.x, clickPosition.y);
        selectedSegmentIndex = this.pathGenerator.setPoint(getBezierPoints(points, t));
      } else if (parser.segments[1].command === "Q") {
        var points = [
          xy$1(parser.segments[0].values),
          xy$1(parser.segments[1].values.slice(0, 2)),
          xy$1(parser.segments[1].values.slice(2, 4))
        ];
        var curve = recoverBezierQuard(...points, 20);
        var t = curve(clickPosition.x, clickPosition.y);
        selectedSegmentIndex = this.pathGenerator.setPointQuard(getBezierPointsQuard(points, t));
      } else if (parser.segments[1].command === "L") {
        var points = [
          xy$1(parser.segments[0].values),
          xy$1(parser.segments[1].values.slice(0, 2))
        ];
        var curve = recoverBezierLine(...points, 20);
        var t = curve(clickPosition.x, clickPosition.y);
        selectedSegmentIndex = this.pathGenerator.setPointLine(getBezierPointsLine(points, t));
        if (e.altKey) {
          this.pathGenerator.convertToCurve(selectedSegmentIndex);
        }
      }
      this.renderPath();
      this.updatePathLayer();
      this.changeMode("segment-move");
      this.pathGenerator.setCachePoint(selectedSegmentIndex, "startPoint");
      this.pathGenerator.selectKeyIndex("startPoint", selectedSegmentIndex);
    }
  }
};
class PathEditor extends PathCutter$1 {
  initialize() {
    super.initialize();
    this.pathParser = new PathParser();
    this.pathGenerator = new PurePathGenerator(this);
  }
  initState() {
    return {
      domain: this.props.domain || [0, 1],
      range: this.props.range || [1, 0],
      isControl: false,
      disableCurve: false,
      points: [],
      mode: "path",
      clickCount: 0,
      isSegment: false,
      isFirstSegment: false,
      current: null
    };
  }
  template() {
    return `
        <div class='elf--path-editor' tabIndex="-1">
            <style type="text/css" ref="$styleView"></style>
            <svg id='patternId' width='100%' height='100%' xmlns='http://www.w3.org/2000/svg'>
                <defs>
                    <pattern id='stripe' patternUnits='userSpaceOnUse' width='20' height='33' patternTransform='scale(1) rotate(135)'>
                        <path d='M0 8h20z'   stroke-width='1' stroke='#07A3FB' fill='none'/>
                        <path d='M0 16h20z'   stroke-width='1' stroke='#07A3FB' fill='none'/>
                        <path d='M0 24h20z'   stroke-width='1' stroke='#07A3FB' fill='none'/>
                        <path d='M0 32h20z'   stroke-width='1' stroke='#07A3FB' fill='none'/>
                    </pattern>
                </defs>    
            </svg>
            <div class='path-container' ref='$view'></div>
            <div class='path-container split-panel'>
                <svg width="100%" height="100%">
                    <circle ref='$splitCircle' class='split-circle' />
                </svg>
            </div>
            <div class='segment-box' ref='$segmentBox'></div>
        </div>`;
  }
  [BIND("$el")]() {
    return {
      style: {
        height: Length.px(this.props.height) || 200
      }
    };
  }
  initRect(isForce = false) {
    if (!this.state.rect || isForce || this.state.rect.width == 0 || this.state.rect.height == 0) {
      this.state.rect = this.refs.$view.rect();
    }
  }
  [SUBSCRIBE("PathEditorDone")]() {
    this.updatePathLayer();
  }
  [KEYUP() + ENTER]() {
    this.trigger("PathEditorDone");
  }
  [KEYUP() + ESCAPE]() {
    if (this.state.current) {
      this.updatePathLayer();
    }
  }
  [KEYUP() + DELETE]() {
    console.log("delete");
  }
  [KEYUP("$el .segment")](e) {
    const index2 = +e.$dt.data("index");
    console.log(index2);
    switch (e.code) {
      case "Delete":
      case "Backspace":
        this.trigger("deleteSegment");
        break;
    }
  }
  [SUBSCRIBE_SELF("deleteSegment")]() {
    this.pathGenerator.reselect();
    this.pathGenerator.removeSelectedSegment();
    this.renderPath();
    this.updatePathLayer();
  }
  [SUBSCRIBE_SELF("moveSegment")](dx, dy) {
    this.pathGenerator.reselect();
    this.pathGenerator.moveSelectedSegment(dx, dy);
    this.renderPath();
    this.updatePathLayer();
  }
  recoverAreaToPath(d) {
    this.initRect(true);
    var parser = new PathParser(d);
    parser.scaleFunc(this.state.domainScaleInvert, this.state.rangeScaleInvert);
    return parser.d;
  }
  updatePathLayer() {
    var { d } = this.pathGenerator.toPath();
    const value = this.recoverAreaToPath(d);
    this.parent.trigger(this.props.onchange, this.state.key, value);
  }
  changeMode(mode, obj2) {
    this.setState(__spreadValues({
      mode,
      clickCount: 0,
      moveXY: null
    }, obj2), false);
    if (obj2 == null ? void 0 : obj2.points) {
      this.pathGenerator.setPoints(obj2.points || []);
    }
  }
  isMode(mode) {
    return this.state.mode === mode;
  }
  convertPathToArea(obj2) {
    this.initRect(true);
    const width2 = this.state.rect.width;
    const height2 = this.state.rect.height;
    this.state.domainScale = scaleLinear([0, 1], [0, width2]);
    this.state.rangeScale = scaleLinear([1, 0], [0, height2]);
    this.state.domainScaleInvert = scaleLinear([0, width2], [0, 1]);
    this.state.rangeScaleInvert = scaleLinear([0, height2], [1, 0]);
    this.pathParser.reset(obj2.d).scaleFunc(this.state.domainScale, this.state.rangeScale);
  }
  refreshEditorView(obj2) {
    this.convertPathToArea(obj2);
    this.pathGenerator.setPoints(this.pathParser.convertGenerator());
    this.renderPath();
  }
  afterRender() {
    const { mode, value } = this.props;
    const obj2 = { d: value };
    if (mode === "move") {
      obj2.current = null;
      obj2.points = [];
    }
    this.changeMode(mode, obj2);
    window.setTimeout(() => {
      this.refreshEditorView(obj2, true);
    }, 10);
  }
  [BIND("$view")]() {
    var _a;
    const path = this.pathGenerator.makeSVGPath();
    const strokeWidth = Length.parse((_a = this.state.current) == null ? void 0 : _a["stroke-width"]).value || 0;
    return {
      class: {
        path: this.state.mode === "path",
        modify: this.state.mode === "modify",
        transform: this.state.mode === "transform",
        "segment-move": this.state.mode === "segment-move",
        "is-control": this.state.isControl,
        "has-one-stroke-width": strokeWidth === 1
      },
      htmlDiff: path
    };
  }
  [BIND("$splitCircle")]() {
    if (this.state.splitXY) {
      return {
        cx: this.state.splitXY.x,
        cy: this.state.splitXY.y,
        r: 5
      };
    } else {
      return {
        r: 0
      };
    }
  }
  renderPath() {
    this.bindData("$view");
  }
  get checkDistance() {
    return false;
  }
  getPathRect() {
    this.initRect(true);
    const { d } = this.pathGenerator.toPath();
    return vertiesToRectangle(PathParser.fromSVGString(d).getBBox());
  }
  resetTransformZone() {
    var rect2 = this.getPathRect();
    this.state.transformZoneRect = rect2;
  }
  [POINTERMOVE("$view") + PREVENT](e) {
    this.initRect();
    if (this.isMode("path") && this.state.rect) {
      this.state.moveXY = {
        x: e.xy.x - this.state.rect.x,
        y: e.xy.y - this.state.rect.y
      };
      this.state.altKey = e.altKey;
      this.renderPath();
    } else {
      var $target = Dom.create(e.target);
      var isSplitPath = $target.hasClass("split-path");
      if (isSplitPath) {
        this.state.splitXY = this.calculatePointOnLine($target.attr("d"), {
          x: e.xy.x - this.state.rect.x,
          y: e.xy.y - this.state.rect.y
        });
      } else {
        this.state.splitXY = null;
      }
      this.bindData("$splitCircle");
      this.state.altKey = false;
    }
  }
  [POINTERSTART("$view :not(.split-path)") + PREVENT + STOP + MOVE() + END()](e) {
    this.initRect();
    this.state.altKey = false;
    var isPathMode = this.isMode("path");
    this.$config.set("set.move.control.point", true);
    this.state.dragXY = {
      x: e.xy.x - this.state.rect.x,
      y: e.xy.y - this.state.rect.y
    };
    var $target = Dom.create(e.target);
    this.$segmentTarget = $target;
    if ($target.hasClass("svg-editor-canvas") && !isPathMode)
      ;
    else {
      this.pathGenerator.reselect();
      this.state.isSegment = $target.attr("data-segment") === "true";
      this.state.isFirstSegment = this.state.isSegment && $target.attr("data-is-first") === "true";
      this.state.selectedGroupIndex = -1;
      this.state.selectedPointIndex = -1;
    }
    if (isPathMode) {
      if (this.state.isFirstSegment) {
        var index2 = +$target.attr("data-index");
        this.state.startPoint = this.pathGenerator.points[index2].startPoint;
      } else {
        this.state.startPoint = this.state.dragXY;
      }
      this.state.dragPoints = false;
      this.state.endPoint = null;
    } else {
      if (this.state.isSegment) {
        this.changeMode("segment-move");
        var [index2, segmentKey] = $target.attrs("data-index", "data-segment-point");
        const localIndex = +index2;
        this.pathGenerator.setCachePoint(localIndex, segmentKey);
        this.pathGenerator.selectKeyIndex(segmentKey, localIndex);
        this.state.segmentKey = segmentKey;
        this.renderPath();
      }
    }
  }
  move(dx, dy) {
    const e = this.$config.get("bodyEvent");
    if (this.state.segmentKey === "startPoint") {
      const newXY = {
        x: Math.max(0, Math.min(this.state.rect.width, e.xy.x - this.state.rect.x)),
        y: Math.max(0, Math.min(this.state.rect.height, e.xy.y - this.state.rect.y))
      };
      dx = newXY.x - this.state.dragXY.x;
      dy = newXY.y - this.state.dragXY.y;
    }
    if (this.isMode("segment-move")) {
      this.pathGenerator.move(dx, dy, e, this.state.rect.width, this.state.rect.height);
      this.renderPath();
      this.updatePathLayer();
    } else if (this.isMode("path")) {
      const dist2 = getDist(dx, dy, 0, 0);
      if (dist2 >= 2) {
        this.state.dragPoints = e.altKey ? false : true;
      }
    }
  }
  renderSegment(callback) {
    if (this.pathGenerator.selectedLength) {
      this.pathGenerator.reselect();
      if (isFunction(callback))
        callback();
      this.renderPath();
      this.updatePathLayer();
    }
  }
  end(dx, dy) {
    this.$config.set("set.move.control.point", false);
    if (this.isMode("modify")) {
      this.pathGenerator.reselect();
    } else if (this.isMode("segment-move")) {
      this.changeMode("modify");
      this.pathGenerator.reselect();
      this.renderPath();
      this.updatePathLayer();
    } else if (this.isMode("path")) {
      if (this.state.isFirstSegment) {
        this.changeMode("modify");
        this.pathGenerator.setConnectedPoint(dx, dy);
        this.renderPath();
        if (this.state.current) {
          this.updatePathLayer();
        }
      } else {
        if (this.state.isSplitPath)
          ;
        else {
          this.pathGenerator.moveEnd(dx, dy);
          this.state.clickCount++;
          this.renderPath();
          this.pathGenerator.reselect();
        }
      }
      this.state.isSplitPath = false;
    }
  }
}
var PathDataEditor$1 = "";
class PathDataEditor extends EditorElement {
  initState() {
    var parser = new PathParser(this.props.value || "");
    return {
      parser
    };
  }
  makeSegments() {
    return this.refs.$data.$$(".segment").map(($segment) => {
      var $command = $segment.$(".command");
      var command = $command.attr("data-command");
      if (command === "Z" && $command.attr("data-toggle") === "false") {
        return null;
      }
      var values = $segment.$$(".values input[type=number]").map((it) => {
        return +it.value;
      });
      return {
        command,
        values
      };
    }).filter((it) => it);
  }
  updateData() {
    var segments = this.makeSegments();
    this.state.parser.resetSegments(segments);
    this.modifyPathData();
  }
  modifyPathData() {
    this.parent.trigger(this.props.onchange, this.props.key, this.getValue(), this.props.params);
  }
  setValue(value) {
    this.setState({
      parser: new PathParser(value)
    });
  }
  getValue() {
    return this.state.parser.joinPath();
  }
  template() {
    return `
            <div class='elf--path-data-editor'>
                <div class='data' ref='$data'></div>
            </div>
        `;
  }
  [LOAD("$data")]() {
    var segments = [];
    this.state.parser.segments.forEach((it, index2) => {
      var s = __spreadValues({}, it);
      segments.push(s);
      var next = this.state.parser.segments[index2 + 1];
      if (next && next.command === "M") {
        if (s.command !== "Z") {
          segments.push({ command: "Z", toggle: false, values: [] });
        } else {
          s.toggle = true;
        }
      }
    });
    var last = this.state.parser.segments[this.state.parser.segments.length - 1];
    if (last && last.command !== "Z") {
      segments.push({ command: "Z", toggle: false, values: [] });
    }
    var arr = segments.map((it) => {
      var cls = it.command === "M" ? "m" : "";
      return `
                <div class='segment ${cls}'>
                    <div class='command' data-command='${it.command}' data-toggle="${it.toggle}" title='Toggle'>${it.command}</div>
                    <div class='values'>
                        ${it.values.map((v) => {
        return `<input type="number" value="${v}" />`;
      }).join("")}

                        ${it.command === "Z" ? it.toggle === false ? "opened" : "closed" : ""}
                    </div>
                </div>
            `;
    });
    arr.unshift(`
            <div class='segment-empty'>
                <div class='command'></div>
                <div class='values'>
                    <span>X</span>
                    <span>Y</span>
                </div>
            </div>
        `);
    return arr;
  }
  [INPUT("$data input[type=number]") + DEBOUNCE(300)]() {
    this.updateData();
  }
  [CLICK("$data .command[data-toggle]")](e) {
    var [command, toggle] = e.$dt.attrs("data-command", "data-toggle");
    if (command === "Z") {
      if (toggle !== "false") {
        toggle = "false";
      } else {
        toggle = "true";
      }
      e.$dt.attr("data-toggle", toggle);
      this.updateData();
    }
  }
}
var PolygonDataEditor$1 = "";
const splitReg = /[\b\t ,]/g;
class PolygonParser extends PathParser {
  constructor(points = "") {
    super(points);
  }
  reset(points = "") {
    this.segments = [];
    this.points = points;
    this.parse();
  }
  resetSegments(segments = []) {
    this.segments = segments;
    this.points = this.joinPoints();
  }
  parse() {
    var points = this.points;
    if (Array.isArray(points)) {
      points = points.join(" ");
    }
    var arr = points.trim().split(splitReg).filter((it) => it);
    var segments = [];
    for (var i = 0, len2 = arr.length; i < len2; i += 2) {
      segments.push({ x: +arr[i], y: +arr[i + 1] });
    }
    this.segments = segments;
  }
  convertGenerator() {
    return this.segments;
  }
  length() {
    return this.segments.length;
  }
  toPathString() {
    var path = new PathStringManager();
    for (var i = 0, len2 = this.segments.length; i < len2; i++) {
      var s = this.segments[i];
      if (i === 0) {
        path.M(s);
      } else if (i === len2 - 1) {
        path.L(s).L(this.segments[0]).Z();
      } else {
        path.L(s);
      }
    }
    return path.d;
  }
  joinPath(segments) {
    return this.joinPoints(segments);
  }
  joinPoints(segments) {
    var list2 = segments || this.segments;
    return list2.map((it) => {
      return `${it.x},${it.y}`;
    }).join(" ");
  }
  each(callback, isReturn = false) {
    var newSegments = this.segments.map((segment) => {
      return callback.call(this, segment);
    });
    if (isReturn) {
      return newSegments;
    } else {
      this.segments = newSegments;
    }
  }
  _loop(m, isReturn = false) {
    return this.each(function(segment) {
      var [x, y] = m([segment.x, segment.y], 0);
      segment.x = x;
      segment.y = y;
      return segment;
    }, isReturn);
  }
  clone() {
    return new PolygonParser(this.joinPoints());
  }
  toString() {
    return this.joinPoints();
  }
}
class PolygonDataEditor extends EditorElement {
  initState() {
    var parser = new PolygonParser(this.props.value || "");
    return {
      parser
    };
  }
  makeSegments() {
    return this.refs.$data.$$(".segment").map(($segment) => {
      var x = +$segment.$('[data-key="x"]').value;
      var y = +$segment.$('[data-key="y"]').value;
      return { x, y };
    });
  }
  updateData() {
    var segments = this.makeSegments();
    this.state.parser.resetSegments(segments);
    this.modifyPolygonData();
  }
  modifyPolygonData() {
    this.parent.trigger(this.props.onchange, this.props.key, this.getValue(), this.props.params);
  }
  setValue(value) {
    this.setState({
      parser: new PolygonParser(value || "")
    });
  }
  getValue() {
    return this.state.parser.joinPoints();
  }
  template() {
    return `
            <div class='elf--polygon-data-editor'>
                <div class='data' ref='$data'></div>
            </div>
        `;
  }
  [LOAD("$data")]() {
    return this.state.parser.segments.map((it) => {
      return `
                <div class='segment'>
                    <div class='values'>
                        <label>X <input type="number" data-key="x" value="${it.x}" /></label>
                        <label>Y <input type="number" data-key="y" value="${it.y}" /></label>
                    </div>
                </div>
            `;
    });
  }
  [INPUT("$data input[type=number]") + DEBOUNCE(300)]() {
    this.updateData();
  }
}
var SelectIconEditor$1 = "";
class SelectIconEditor extends EditorElement {
  initState() {
    var splitChar = this.props.split || ",";
    var options2 = Array.isArray(this.props.options) ? this.props.options.map((it) => {
      if (isString(it)) {
        return { value: it, text: it };
      }
      return it;
    }) : (this.props.options || "").split(splitChar).map((it) => it.trim()).map((it) => {
      const [value2, text2] = it.split(":");
      return { value: value2, text: text2 };
    });
    var icons = this.props.icons || [];
    var colors2 = this.props.colors || [];
    var value = this.props.value || "";
    return {
      label: this.props.label || "",
      compact: isBoolean(this.props.compact) ? this.props.compact : this.props.compact === "true",
      options: options2,
      icons,
      colors: colors2,
      value,
      height: this.props.height
    };
  }
  template() {
    var { label, compact, height: height2 } = this.state;
    var hasLabel = label ? "has-label" : "";
    var hasCompact = compact ? "compact" : "";
    var heightVar = height2 ? `--elf--input-height: ${height2}px;` : "";
    return `
            <div class='elf--select-icon-editor ${hasLabel}' style="${heightVar}">
                ${label ? `<label title="${label}">${label}</label>` : ""}
                <div class='items ${hasCompact}' ref='$options'></div>
            </div>
        `;
  }
  [CLICK("$close")]() {
    this.updateData({
      value: ""
    });
    this.refresh();
  }
  getValue() {
    return this.state.value || "";
  }
  setValue(value) {
    this.setState({
      value
    });
  }
  [LOAD("$options") + DOMDIFF]() {
    return this.state.options.map((it, index2) => {
      var value = it.value;
      var label = it.text;
      var title2 = it.text;
      var iconClass = "";
      var isSelected = value === this.state.value;
      var selected = isSelected ? "selected" : "";
      if (it.value === "") {
        var label = "";
        title2 = "close";
        if (isNotUndefined(this.state.icons[index2])) {
          iconClass = "icon";
          label = iconBlank();
          value = "__blank__";
        }
      } else {
        var iconKey = this.state.icons[index2];
        if (obj$2[iconKey]) {
          iconClass = "icon";
        }
        title2 = label;
        label = obj$2[iconKey] || label || iconKey || it.text || it.value;
      }
      var color2 = this.state.colors[index2];
      var css = {};
      if (isSelected && color2) {
        css["background-color"] = color2;
      }
      return `<div class='select-icon-item ${selected} ${iconClass}' 
          style='${CSS_TO_STRING(css)}' 
          data-value="${value}" 
          data-tooltip='${title2}'
      >${label}</div>`;
    });
  }
  [CLICK("$options .select-icon-item")](e) {
    var value = e.$dt.attr("data-value");
    if (!value || value === "__blank__")
      return;
    this.updateData({
      value
    });
    this.refresh();
  }
  updateData(data) {
    this.setState(data, false);
    this.parent.trigger(this.props.onchange, this.props.key, this.getValue(), this.props.params);
  }
}
var StrokeDashArrayEditor$1 = "";
const dash_list = [
  [10, 5],
  [5, 1],
  [1, 5],
  [0.9],
  [15, 10, 5],
  [15, 10, 5, 10],
  [15, 10, 5, 10, 15],
  [5, 5, 1, 5]
];
class StrokeDashArrayEditor extends EditorElement {
  initState() {
    var value = isArray(this.props.value) ? this.props.value : this.generateValue(this.props.value || "");
    return {
      label: this.props.label || "",
      value,
      count: 1
    };
  }
  template() {
    const { label } = this.state;
    const hasLabel = !!label;
    return `
      <div class='elf--stroke-dasharray-editor'>
        <div class='tools ${hasLabel ? "has-label" : ""}'>
          ${hasLabel ? `<label class='label'>${label}</label>` : ""}
          <div class="buttons">
            <label ref='$add'>${obj$2.add}</label>          
          </div>
        </div>      
        <div ref='$body' class='dash-list'></div>
        <div ref='$list' class='dash-sample-list'></div>
      </div>
    `;
  }
  [CLICK("$el .tools label")]() {
    this.refs.$list.toggle();
  }
  getValue() {
    return this.state.value;
  }
  generateValue(value) {
    return value.split(" ").filter(Boolean).map((it) => +it);
  }
  setValue(value) {
    if (!isArray(value)) {
      value = this.generateValue(value);
    }
    this.setState({
      value
    });
  }
  [LOAD("$list")]() {
    return dash_list.map((value, index2) => {
      return `
        <div class='dash-sample' data-index='${index2}'>
          <div class='dash-sample-value'>
            <svg width="100" height="2">
              <line x1="5" y1="0" x2="95" y2="0" stroke-dasharray="${value.join(",")}" stroke-width="2" stroke="black" />
            </svg>
          </div>
        </div>
      `;
    });
  }
  [LOAD("$body")]() {
    this.state.count++;
    return this.state.value.map((value, index2) => {
      var num = index2 + 1;
      return `
        <div class='dasharray-item'>
          ${createComponent("NumberInputEditor", {
        ref: `$dash-${this.state.count}-${num}`,
        compact: true,
        key: index2,
        value,
        min: 0,
        max: 100,
        step: 1,
        onchange: "changeRangeEditor"
      })}  
          <button type="button" data-index="${index2}" class='delete'>${iconUse("close")}</button>
        </div>
      `;
    });
  }
  [SUBSCRIBE_SELF("changeRangeEditor")](key, value) {
    var index2 = +key;
    this.state.value[index2] = value;
    this.modifyStrokeDashArray();
  }
  [CLICK("$list .dash-sample")](e) {
    const value = dash_list[+e.$dt.data("index")];
    this.setState({ value }, false);
    this.refresh();
    this.modifyStrokeDashArray();
    this.refs.$list.toggle();
  }
  [CLICK("$add")]() {
    this.setState({
      value: [...this.state.value, 0]
    }, false);
    this.refresh();
    this.modifyStrokeDashArray();
  }
  [CLICK("$body .delete")](e) {
    const index2 = +e.$dt.attr("data-index");
    this.state.value.splice(index2, 1);
    this.refresh();
    this.modifyStrokeDashArray();
  }
  modifyStrokeDashArray() {
    this.parent.trigger(this.props.onchange, this.props.key, this.getValue(), this.props.params);
  }
  [POINTERSTART("document")](e) {
    const $target = Dom.create(e.target);
    const parent = $target.closest("elf--stroke-dasharray-editor");
    if (!parent) {
      this.refs.$list.hide();
    }
  }
}
var TextAreaEditor$1 = "";
class TextAreaEditor extends EditorElement {
  initState() {
    var value = this.props.value;
    return {
      label: this.props.label || "",
      height: 100,
      value
    };
  }
  template() {
    var { label, height: height2, value } = this.state;
    var hasLabel = label ? "has-label" : "";
    return `
            <div class='elf--text-area-editor ${hasLabel}'>
                ${label ? `<label>${label}</label>` : ""}
                <textarea ref='$text' style='height:${height2}'>${value}</textarea>
            </div>
        `;
  }
  getValue() {
    return this.refs.$options.value;
  }
  setValue(value, height2) {
    this.setState({ value }, false);
    if (height2) {
      this.setState({ height: height2 }, false);
    }
    this.refresh();
  }
  [BIND("$text")]() {
    return {
      text: this.state.value || "",
      style: {
        height: this.state.height
      }
    };
  }
  [INPUT("$text")]() {
    this.updateData({
      value: this.refs.$text.value
    });
  }
  updateData(data) {
    this.setState(data);
    this.parent.trigger(this.props.onchange, this.props.key, this.state.value, this.props.params);
  }
}
var TextEditor$1 = "";
class TextEditor extends EditorElement {
  initState() {
    var value = this.props.value;
    return {
      label: this.props.label || "",
      value
    };
  }
  template() {
    var { label, value } = this.state;
    var hasLabel = label ? "has-label" : "";
    return `
            <div class='elf--text-editor ${hasLabel}'>
                ${label ? `<label>${label}</label>` : ""}
                <div>
                    <input type='text' ref='$text' value="${value}" />
                </div>
            </div>
        `;
  }
  getValue() {
    return this.refs.$text.value;
  }
  setValue(value) {
    this.refs.$text.val(value);
    this.setState({
      value
    }, false);
  }
  [BIND("$text")]() {
    return {
      value: this.state.value
    };
  }
  [INPUT("$text")]() {
    this.updateData({
      value: this.refs.$text.value
    });
  }
  updateData(data) {
    this.setState(data, false);
    this.parent.trigger(this.props.onchange, this.props.key, this.getValue(), this.props.params);
  }
}
var TextShadowEditor$1 = "";
class TextShadowEditor extends EditorElement {
  initState() {
    return {
      textShadows: this.props.value || []
    };
  }
  template() {
    return `
      <div class="elf--text-shadow-editor" >
        <div class='text-shadow-list' ref='$shadowList'></div>
      </div>
    `;
  }
  [LOAD("$shadowList")]() {
    var arr = this.state.textShadows.map((shadow2, index2) => {
      return `
        <div class="shadow-item real" data-index="${index2}">
          <label draggable="true" data-index="${index2}">${iconUse("drag_indicator")}</label>
          ${createComponent("ColorViewEditor", {
        mini: true,
        key: "color",
        value: shadow2.color,
        params: index2,
        onchange: "changeKeyValue"
      })}
          ${createComponent("NumberInputEditor", {
        mini: true,
        key: "offsetX",
        label: "X",
        value: shadow2.offsetX,
        params: index2,
        onchange: "changeKeyValue"
      })}          
          ${createComponent("NumberInputEditor", {
        mini: true,
        key: "offsetY",
        label: "Y",
        value: shadow2.offsetY,
        params: index2,
        onchange: "changeKeyValue"
      })}                    
          ${createComponent("NumberInputEditor", {
        mini: true,
        label: "B",
        key: "blurRadius",
        value: shadow2.blurRadius,
        params: index2,
        onchange: "changeKeyValue"
      })}                    
          <div class="tools">
            <button type="button" class="remove" data-index="${index2}">
              ${iconUse("remove2")}
            </button>
          </div>
        </div>
      `;
    });
    return arr.join("");
  }
  modifyTextShadow() {
    var value = this.state.textShadows;
    this.parent.trigger(this.props.onchange, this.props.key, value);
  }
  [SUBSCRIBE("add")](shadows) {
    if (isArray(shadows)) {
      this.state.textShadows.push(...shadows);
    } else {
      this.state.textShadows.push({
        color: "#000000",
        offsetX: 0,
        offsetY: 0,
        blurRadius: 0
      });
    }
    this.refresh();
    this.modifyTextShadow();
  }
  [CLICK("$add")]() {
    this.trigger("add");
  }
  [DRAGSTART("$shadowList .shadow-item > label")](e) {
    this.startIndex = +e.$dt.attr("data-index");
  }
  [DRAGOVER("$shadowList .shadow-item") + PREVENT]() {
  }
  sortItem(arr, startIndex, targetIndex) {
    arr.splice(targetIndex + (startIndex < targetIndex ? -1 : 0), 0, ...arr.splice(startIndex, 1));
  }
  sortTextShadow(startIndex, targetIndex) {
    this.sortItem(this.state.textShadows, startIndex, targetIndex);
  }
  [DROP("$shadowList .shadow-item") + PREVENT](e) {
    var targetIndex = +e.$dt.attr("data-index");
    this.sortTextShadow(this.startIndex, targetIndex);
    this.refresh();
    this.modifyTextShadow();
  }
  [CLICK("$shadowList .remove")](e) {
    var index2 = +e.$dt.attr("data-index");
    this.state.textShadows.splice(index2, 1);
    this.refresh();
    this.modifyTextShadow();
  }
  [SUBSCRIBE_SELF("changeKeyValue")](key, value, index2) {
    var shadow2 = this.state.textShadows[index2];
    this.state.textShadows[index2] = __spreadProps(__spreadValues({}, shadow2), { [key]: value });
    this.modifyTextShadow();
  }
}
var VarEditor$1 = "";
class VarEditor extends EditorElement {
  initState() {
    var values = this.props.value.split(";").filter((it) => it.trim()).map((it) => {
      let [key, value] = it.split(":");
      key = key.replace("--", "");
      return { key, value };
    });
    return {
      hideLabel: this.props.hideLabel == "true" ? true : false,
      params: this.props.params || "",
      values
    };
  }
  template() {
    var labelClass = this.state.hideLabel ? "hide" : "";
    return `
        <div class='elf--var-editor var-list'>
            <div class='label ${labelClass}' >
                <label>${this.props.title || ""}</label>
                <div class='tools'>
                    <button type="button" ref="$add" title="add Var">${obj$2.add}</button>
                </div>
            </div>
            <div class='var-list' ref='$varList'></div>
        </div>`;
  }
  [SUBSCRIBE("add")]() {
    this.state.values.push({
      key: "",
      value: ""
    });
    this.refresh();
    this.updateData();
  }
  [CLICK("$add")]() {
    this.trigger("add");
  }
  [LOAD("$varList")]() {
    return this.state.values.map((it, index2) => {
      return `
                <div class='var-item' >
                    <div>
                        <input type="text" data-type="key" value="${it.key}" data-index="${index2}"  placeholder="variable" />
                    </div>
                    <div>
                        <input type="text" data-type="value" value="${it.value}" data-index="${index2}"  placeholder="value" />
                    </div>
                    <div class="tools">
                        <button type="button" class="del" data-index="${index2}">
                        ${obj$2.remove2}
                        </button>
                    </div>
                </div>
            `;
    });
  }
  [CLICK("$varList .del")](e) {
    var index2 = +e.$dt.attr("data-index");
    this.state.values.splice(index2, 1);
    this.refresh();
    this.updateData();
  }
  [INPUT("$varList input")](e) {
    var index2 = +e.$dt.attr("data-index");
    var type = e.$dt.attr("data-type");
    this.state.values[index2][type] = e.$dt.value;
    this.updateData();
  }
  updateData() {
    var value = this.state.values.map((it) => {
      return `${it.key}:${it.value}`;
    }).join(";");
    this.parent.trigger(this.props.onchange, value, this.props.params);
  }
}
var propertyEditor$1 = {
  BlendSelectEditor,
  BoxShadowEditor,
  ColorAssetsEditor,
  ColorSingleEditor,
  ColorViewEditor,
  ComponentEditor,
  CSSPropertyEditor,
  CubicBezierEditor,
  DirectionEditor,
  FilterEditor,
  FontSelectEditor,
  GradientEditor,
  IconListViewEditor,
  InputArrayEditor,
  InputRangeEditor,
  IterationCountEditor,
  MediaProgressEditor,
  NumberInputEditor,
  NumberRangeEditor,
  PathEditor,
  PathDataEditor,
  PolygonDataEditor,
  RangeEditor,
  SelectEditor,
  SelectIconEditor,
  StrokeDashArrayEditor,
  TextAreaEditor,
  TextEditor,
  TextShadowEditor,
  VarEditor
};
function propertyEditor(editor) {
  editor.registerElement(propertyEditor$1);
  editor.registerAlias({
    "icon-list-view": "IconListViewEditor",
    "box-shadow": "BoxShadowEditor",
    "text-shadow": "TextShadowEditor",
    component: "ComponentEditor",
    "text-area": "TextAreaEditor",
    text: "TextEditor",
    "color-single": "ColorSingleEditor",
    "cubic-bezier": "CubicBezierEditor",
    path: "PathEditor",
    "clip-path": "ClipPathEditor",
    "color-view": "ColorViewEditor",
    var: "VarEditor",
    "path-data": "PathDataEditor",
    "polygon-data": "PolygonDataEditor",
    "input-array": "InputArrayEditor",
    "stroke-dash-array": "StrokeDashArrayEditor",
    "number-input": "NumberInputEditor",
    "number-range": "NumberRangeEditor",
    "media-progress": "MediaProgressEditor",
    "select-icon": "SelectIconEditor",
    "css-property": "CSSPropertyEditor",
    direction: "DirectionEditor",
    "iteration-count": "IterationCountEditor",
    gradient: "GradientEditor",
    filter: "FilterEditor",
    select: "SelectEditor",
    "blend-select": "BlendSelectEditor",
    range: "RangeEditor",
    "input-range": "InputRangeEditor",
    "color-assets": "ColorAssetsEditor",
    "font-select": "FontSelectEditor"
  });
}
var blankEditorPlugins = [
  defaultConfigs,
  defaultIcons,
  defaultMessages,
  baseEditor,
  propertyEditor,
  configs$3
];
var ContextMenuManager$1 = "";
class ContextMenuManager extends EditorElement {
  template() {
    return /* @__PURE__ */ createElementJsx("div", {
      class: "elf--context-menu-manger"
    }, this.$injectManager.generate("context.menu"));
  }
  [SUBSCRIBE(OPEN_CONTEXT_MENU)](obj2) {
    this.$context.config.set("context.menu.open", obj2);
  }
}
class IconManager$1 extends EditorElement {
  template() {
    return `
      <svg viewBox="0 0 30 10" xmlns="http://www.w3.org/2000/svg" ref="$list" style="display:none;">
      </svg>
    `;
  }
  [LOAD("$list")]() {
    return Object.entries(obj$2).map(([key, value]) => {
      if (isString(value) === false)
        return "";
      return value.replace(/\<svg/g, `<svg id="icon-${key}"`).trim();
    }).filter(Boolean);
  }
}
const formElements = ["TEXTAREA", "INPUT", "SELECT"];
class KeyboardManager extends EditorElement {
  isNotFormElement(e) {
    var tagName = e.target.tagName;
    if (formElements.includes(tagName))
      return false;
    else if (Dom.create(e.target).attr("contenteditable") === "true")
      return false;
    return true;
  }
  [KEYDOWN("document") + IF("isNotFormElement")](e) {
    this.$commands.emit("keymap.keydown", e);
  }
  [KEYUP("document") + IF("isNotFormElement")](e) {
    this.$commands.emit("keymap.keyup", e);
  }
}
var Console = {
  command: "Console",
  description: "do console.log()",
  execute: (editor, ...args2) => {
    console.log(...args2);
  }
};
var __glob_0_0$3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": Console
}, Symbol.toStringTag, { value: "Module" }));
var history_redo$1 = {
  command: "history.redo",
  execute: function(editor) {
    editor.context.history.redo();
  }
};
var __glob_0_1$3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": history_redo$1
}, Symbol.toStringTag, { value: "Module" }));
var history_undo$1 = {
  command: "history.undo",
  execute: function(editor) {
    editor.context.history.undo();
  }
};
var __glob_0_2$3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": history_undo$1
}, Symbol.toStringTag, { value: "Module" }));
var keymap_keydown$1 = {
  command: "keymap.keydown",
  execute: function(editor, e) {
    editor.context.keyboardManager.add(e.code, e.keyCode, e);
    if (editor.context.shortcuts) {
      editor.context.shortcuts.execute(e, "keydown");
    }
  }
};
var __glob_0_3$3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": keymap_keydown$1
}, Symbol.toStringTag, { value: "Module" }));
var keymap_keyup = {
  command: "keymap.keyup",
  execute: function(editor, e) {
    editor.context.keyboardManager.remove(e.key, e.keyCode);
    if (editor.context.shortcuts) {
      editor.context.shortcuts.execute(e, "keyup");
    }
  }
};
var __glob_0_4$3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": keymap_keyup
}, Symbol.toStringTag, { value: "Module" }));
var moveToCenter = {
  command: "moveToCenter",
  description: "Move Layer to Center on Viewport",
  execute: function(editor, areaVerties, withScale = false) {
    if (areaVerties) {
      editor.context.viewport.moveToCenter(areaVerties, withScale ? -0.2 : 0, withScale);
    }
  }
};
var __glob_0_5$3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": moveToCenter
}, Symbol.toStringTag, { value: "Module" }));
var pop_mode_view = {
  command: "pop.mode.view",
  execute: function(editor, modeView = void 0) {
    editor.context.modeViewManager.popMode(modeView);
  }
};
var __glob_0_6$3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": pop_mode_view
}, Symbol.toStringTag, { value: "Module" }));
var push_mode_view = {
  command: "push.mode.view",
  execute: function(editor, modeView = ViewModeType.CanvasView) {
    editor.context.modeViewManager.pushMode(modeView);
    editor.emit("updateModeView");
  }
};
var __glob_0_7$3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": push_mode_view
}, Symbol.toStringTag, { value: "Module" }));
var recoverCursor = {
  command: "recoverCursor",
  execute: function(editor) {
    editor.context.config.set("editor.cursor", "auto");
    editor.context.config.set("editor.cursor.args", []);
  }
};
var __glob_0_8$3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": recoverCursor
}, Symbol.toStringTag, { value: "Module" }));
var refreshCursor = {
  command: "refreshCursor",
  execute: function(editor, iconType, ...args2) {
    editor.context.config.set("editor.cursor", iconType);
    editor.context.config.set("editor.cursor.args", args2);
  }
};
var __glob_0_9$3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": refreshCursor
}, Symbol.toStringTag, { value: "Module" }));
var setLocale = {
  command: "setLocale",
  execute: function(editor, locale) {
    editor.setLocale(locale);
    editor.emit("changed.locale");
  }
};
var __glob_0_10$3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": setLocale
}, Symbol.toStringTag, { value: "Module" }));
var toggle_tool_hand = {
  command: "toggleHandTool",
  execute: function(editor) {
    if (editor.context.config.is("editing.mode", EditingMode.HAND)) {
      editor.context.config.set("editing.mode", EditingMode.SELECT);
    } else {
      editor.context.config.set("editing.mode", EditingMode.HAND);
    }
    editor.emit("hideLayerAppendView");
  }
};
var __glob_0_11$3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": toggle_tool_hand
}, Symbol.toStringTag, { value: "Module" }));
var zoom_default$1 = {
  command: "zoom.default",
  execute: function(editor) {
    editor.context.viewport.zoomDefault();
  }
};
var __glob_0_12$3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": zoom_default$1
}, Symbol.toStringTag, { value: "Module" }));
var zoom_in$1 = {
  command: "zoom.in",
  execute: function(editor) {
    editor.context.viewport.zoomIn(0.02);
  }
};
var __glob_0_13$3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": zoom_in$1
}, Symbol.toStringTag, { value: "Module" }));
var zoom_out$1 = {
  command: "zoom.out",
  execute: function(editor) {
    editor.context.viewport.zoomOut(0.02);
  }
};
var __glob_0_14$3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": zoom_out$1
}, Symbol.toStringTag, { value: "Module" }));
const modules$3 = { "./command_list/Console.js": __glob_0_0$3, "./command_list/history.redo.js": __glob_0_1$3, "./command_list/history.undo.js": __glob_0_2$3, "./command_list/keymap.keydown.js": __glob_0_3$3, "./command_list/keymap.keyup.js": __glob_0_4$3, "./command_list/moveToCenter.js": __glob_0_5$3, "./command_list/pop.mode.view.js": __glob_0_6$3, "./command_list/push.mode.view.js": __glob_0_7$3, "./command_list/recoverCursor.js": __glob_0_8$3, "./command_list/refreshCursor.js": __glob_0_9$3, "./command_list/setLocale.js": __glob_0_10$3, "./command_list/toggle.tool.hand.js": __glob_0_11$3, "./command_list/zoom.default.js": __glob_0_12$3, "./command_list/zoom.in.js": __glob_0_13$3, "./command_list/zoom.out.js": __glob_0_14$3 };
const obj$1 = {};
Object.entries(modules$3).forEach(([key, value]) => {
  key = key.replace("./command_list/", "").replace(".js", "");
  obj$1[key] = value.default;
});
class AssetParser {
  static parse(datauri, enableParselocal = false) {
    var [, data] = datauri.split("data:");
    var [mediaType, ...content2] = data.split(",");
    var [mimeType, encoding] = mediaType.split(";");
    content2 = content2.join(",");
    return {
      mimeType,
      local: enableParselocal && AssetParser.getLink(mimeType, encoding, content2)
    };
  }
  static getLink(mimeType, encoding, content2) {
    if (encoding === "base64") {
      var binary = window.atob(content2);
      var len2 = binary.length;
      var unit8Array = new window.Uint8Array(len2);
      for (var i = 0; i < len2; i++) {
        unit8Array[i] = binary.charCodeAt(i);
      }
      var blob = new window.Blob([unit8Array], { type: mimeType });
      return window.URL.createObjectURL(blob);
    }
    return "";
  }
}
class AssetManager {
  constructor(editor) {
    this.$editor = editor;
  }
  get project() {
    return this.$editor.context.selection.currentProject;
  }
  revokeResource(value) {
    var json = JSON.parse(value || "[]");
    var assets = {};
    json.forEach((project2) => {
      project2.images.forEach((it) => {
        assets[`#${it.id}`] = it;
      });
    });
    Object.keys(assets).map((idString) => {
      var a = assets[idString];
      var info = AssetParser.parse(a.original, true);
      a.local = info.local;
    });
    json.forEach((project2) => {
      project2.layers = this.applyAsset(project2.layers, assets);
    });
    return json;
  }
  applyAsset(json, assets) {
    if (Array.isArray(json)) {
      json = json.map((it) => this.applyAsset(it, assets));
    } else if (isObject(json)) {
      Object.keys(json).forEach((key) => {
        json[key] = this.applyAsset(json[key], assets);
      });
    } else if (isString(json)) {
      Object.keys(assets).forEach((idString) => {
        var a = assets[idString];
        if (json.indexOf(`#${a.id}`) > -1) {
          json = json.replace(new RegExp(`#${a.id}`, "g"), a.local);
        }
      });
    }
    return json;
  }
}
class CommandMaker {
  constructor(editor) {
    this.editor = editor;
    this.commands = [];
  }
  log() {
    console.log(this.commands);
  }
  emit(...args2) {
    this.commands.push(args2);
  }
  run() {
    this.editor.emit(this.commands);
  }
  add(otherCommandMaker) {
    this.commands = this.commands.concat(otherCommandMaker.commands);
  }
}
class CommandManager {
  constructor(editor) {
    this.$editor = editor;
    this.promiseProxy = this.localCommands = {};
    this.loadCommands();
    return new Proxy(this, {
      get: (target, key) => {
        var originMethod = target[key];
        if (isFunction(originMethod)) {
          return (...args2) => {
            return originMethod.apply(target, args2);
          };
        } else {
          return this.makePromiseEvent(key);
        }
      }
    });
  }
  loadCommands(userCommands = {}) {
    Object.keys(userCommands).forEach((command) => {
      if (isFunction(userCommands[command])) {
        this.registerCommand(command, userCommands[command]);
      } else {
        this.registerCommand(userCommands[command]);
      }
    });
  }
  registerCommand(command, commandCallback) {
    if (this.localCommands[command]) {
      throw new Error(`command ${command} is already registered`);
    }
    if (arguments.length === 2) {
      const callback = (...args2) => {
        const result = commandCallback.call(this, this.$editor, ...args2);
        this.$editor.debug("command execute", this, ...args2);
        return result;
      };
      callback.source = command;
      this.localCommands[command] = callback;
    } else if (isObject(command)) {
      const callback = (...args2) => {
        const result = command.execute.call(command, this.$editor, ...args2);
        this.$editor.debug("command execute", command, ...args2);
        return result;
      };
      callback.source = command.command;
      this.localCommands[command.command] = callback;
    }
  }
  getCallback(command) {
    return this.localCommands[command];
  }
  makePromiseEvent(command) {
    const callback = this.getCallback(command);
    if (callback) {
      return (...args2) => new Promise((resolve) => {
        resolve(callback(...args2));
      });
    }
  }
  executeCommand(command, description, ...args2) {
    if (this.$editor.context.stateManager.isPointerUp) {
      command = `history.${command}`;
      const callback = this.getCallback(command);
      return callback(description, ...args2);
    } else {
      return this.emit(command, ...args2);
    }
  }
  emit(command, ...args2) {
    const callback = this.getCallback(command);
    if (callback) {
      return callback(...args2);
    }
  }
}
class ComponentManager {
  constructor(editor) {
    this.editor = editor;
    this.components = {};
    this.inspectors = {};
  }
  registerComponent(name, componentProperty) {
    this.components[name] = componentProperty;
  }
  registerInspector(name, inspectorCallback) {
    this.inspectors[name] = inspectorCallback;
  }
  isComponentClass(name) {
    return !!this.getComponentClass(name);
  }
  getComponentClass(name) {
    return this.components[name] || this.components["rect"];
  }
  getInspector(name) {
    return this.inspectors[name];
  }
  createComponent(itemType, obj2 = {}) {
    var ComponentClass = this.getComponentClass(itemType);
    if (!ComponentClass) {
      console.warn(`${itemType} type is not valid.`);
      return void 0;
    }
    return new ComponentClass(obj2);
  }
  createInspector(item, name = "") {
    const inspector2 = this.getInspector(name || item.itemType);
    if (isFunction(inspector2)) {
      return inspector2(item) || [];
    }
    if (isFunction(item.getProps)) {
      return item.getProps() || [];
    }
    return [];
  }
}
class ConfigManager {
  constructor(editor) {
    this.editor = editor;
    this.configList = [];
    this.config = /* @__PURE__ */ new Map();
  }
  load() {
    const obj2 = this.editor.loadItem("config") || {};
    Object.keys(obj2).forEach((key) => {
      this.config.set(key, obj2[key]);
    });
  }
  get(key) {
    var _a;
    if (this.config.has(key) === false) {
      this.config.set(key, (_a = this.configList.find((it) => it.key == key)) == null ? void 0 : _a.defaultValue);
    }
    return this.config.get(key);
  }
  set(key, value, isSave = true) {
    const oldValue = this.config.get(key);
    if (oldValue !== value) {
      this.config.set(key, value);
      this.editor.emit("config:" + key, value, oldValue);
      if (isSave) {
        this.save();
      }
    }
  }
  push(key, value) {
    const list2 = this.get(key);
    const lastIndex = list2.length;
    this.setIndexValue(key, lastIndex, value);
    return lastIndex;
  }
  setIndexValue(key, index2, value) {
    const list2 = this.get(key);
    list2[index2] = value;
    this.set(key, [...list2]);
  }
  getIndexValue(key, index2) {
    const list2 = this.get(key);
    return list2[index2];
  }
  removeByIndex(key, index2) {
    const list2 = this.get(key);
    list2.splice(index2, 1);
    this.set(key, [...list2]);
  }
  init(key, value) {
    this.set(key, value, false);
  }
  save() {
    const obj2 = {};
    this.configList.filter((it) => it.storage !== "none").forEach((it) => {
      obj2[it.key] = this.get(it.key);
    });
    this.editor.saveItem("config", obj2);
  }
  setAll(obj2) {
    Object.keys(obj2).forEach((key) => {
      this.set(key, obj2[key]);
    });
  }
  getType(key) {
    var _a;
    return (_a = this.configList.find((it) => it.key == key)) == null ? void 0 : _a.type;
  }
  isType(key, type) {
    return this.getType(key) === type;
  }
  isBoolean(key) {
    return this.isType(key, "boolean");
  }
  toggle(key) {
    this.set(key, !this.get(key));
  }
  toggleWith(key, firstValue, secondValue) {
    if (this.get(key) === firstValue) {
      this.set(key, secondValue);
    } else {
      this.set(key, firstValue);
    }
  }
  true(key) {
    return this.get(key) === true;
  }
  false(key) {
    return this.get(key) === false;
  }
  is(key, value) {
    return this.get(key) === value;
  }
  remove(key) {
    this.config.delete(key);
    this.editor.emit("config:" + key);
  }
  registerConfig(config) {
    this.config.set(config.key, config.defaultValue);
    this.configList.push(config);
  }
}
class CursorManager {
  async load(iconName = "default", ...args2) {
    if (obj$2[iconName]) {
      const iconContent = isFunction(obj$2[iconName]) ? obj$2[iconName].call(obj$2[iconName], ...args2) : obj$2[iconName];
      const blob = new window.Blob([iconContent], { type: "image/svg+xml" });
      return new Promise((resolve) => {
        const reader = new window.FileReader();
        reader.onload = (e) => {
          const datauri = e.target.result;
          resolve(`url(${datauri}) 12 12, auto`);
        };
        reader.readAsDataURL(blob);
      });
    } else {
      return iconName;
    }
  }
}
class I18nManager {
  constructor(editor) {
    this.editor = editor;
    this.locales = {};
    this.fallbackLang = "en_US";
  }
  getLang(lang = void 0) {
    return lang || this.fallbackLang;
  }
  setFallbackLang(lang) {
    this.fallbackLang = lang;
  }
  get(key, params = {}, lang = void 0) {
    var _a, _b;
    const currentLang = this.getLang(lang);
    const str = ((_a = this.locales[currentLang]) == null ? void 0 : _a[key]) || ((_b = this.locales[this.fallbackLang]) == null ? void 0 : _b[key]) || key || void 0;
    if (isFunction(str)) {
      return str(params);
    } else {
      let newValue = str;
      if (key === newValue) {
        return key.split(".").pop();
      }
      Object.entries(params).forEach(([key2, value]) => {
        newValue = newValue.replace(new RegExp(`{${key2}}`, "ig"), value);
      });
      return newValue;
    }
  }
  hasKey(key, lang = void 0) {
    const currentLang = this.getLang(lang);
    return !!(this.locales[currentLang][key] || this.locales[this.fallbackLang][key]);
  }
  registerI18nMessage(lang, messages) {
    if (!this.locales[lang]) {
      this.locales[lang] = {};
    }
    Object.assign(this.locales[lang], messages);
  }
}
class IconManager {
  constructor(editor) {
    this.editor = editor;
    this.iconMap = {};
  }
  get(itemType, item) {
    const icon = this.iconMap[itemType];
    if (isFunction(icon)) {
      return icon(item);
    }
    return iconUse(icon || item.getIcon() || "rect");
  }
  set(itemType, value) {
    this.iconMap[itemType] = value;
  }
  registerIcon(itemType, iconOrFunction) {
    this.set(itemType, iconOrFunction);
  }
}
class InjectManager {
  constructor(editor) {
    this.editor = editor;
    this.ui = {};
  }
  registerUI(target, obj2 = {}, order = 1) {
    if (!this.ui[target]) {
      this.ui[target] = [];
    }
    Object.keys(obj2).forEach((refClass) => {
      const targetClass = this.ui[target].find((it) => it.refClass === refClass);
      if (targetClass) {
        targetClass.class = obj2[refClass];
      } else {
        this.ui[target].push({
          refClass,
          order,
          class: obj2[refClass]
        });
      }
    });
  }
  getTargetUI(target) {
    return this.ui[target] || [];
  }
  generate(target, hasRef = false) {
    const list2 = this.getTargetUI(target);
    list2.sort((a, b) => {
      if (a.order === b.order)
        return 0;
      return a.order > b.order ? 1 : -1;
    });
    return list2.map((it, index2) => {
      if (isArray(it.class)) {
        return createElementJsx(...it.class);
      } else {
        const props = {};
        if (hasRef) {
          props.ref = `$${it.refClass}-${index2}`;
        }
        return createComponent(it.refClass, props);
      }
    }).join("\n");
  }
}
class KeyBoardManager {
  constructor(editor) {
    this.editor = editor;
    this.codeSet = /* @__PURE__ */ new Set();
    this.keyCodeSet = /* @__PURE__ */ new Set();
    this.event = {};
  }
  add(key, keyCode, e) {
    if (this.codeSet.has(key) === false) {
      this.codeSet.add(key);
    }
    if (this.keyCodeSet.has(keyCode) === false) {
      this.keyCodeSet.add(keyCode);
    }
    this.event = e;
  }
  remove(key, keyCode) {
    this.codeSet.delete(key);
    this.keyCodeSet.delete(keyCode);
  }
  hasKey(keyOrKeyCode) {
    return this.codeSet.has(keyOrKeyCode) || this.keyCodeSet.has(keyOrKeyCode);
  }
  check(...args2) {
    return args2.some((keyOrKeyCode) => this.hasKey(keyOrKeyCode));
  }
  isShift() {
    return Boolean(this.event.shiftKey);
  }
  isCtrl() {
    return Boolean(this.event.ctrlKey);
  }
  isAlt() {
    return Boolean(this.event.altKey);
  }
  isMeta() {
    return Boolean(this.event.metaKey);
  }
}
class MenuManager {
  constructor(editor) {
    this.editor = editor;
    this.menus = {};
  }
  registerMenu(target, obj2 = [], order = 1) {
    if (!this.menus[target]) {
      this.menus[target] = [];
    }
    if (!isArray(obj2)) {
      obj2 = [obj2];
    }
    obj2.forEach((it) => {
      this.menus[target].push(it);
    });
    this.editor.emit("updateMenu", target);
  }
  getTargetMenu(target, sort = "asc") {
    if (sort === "desc") {
      return this.menus[target].reverse();
    }
    return this.menus[target] || [];
  }
}
class ModeViewManager {
  constructor(editor) {
    this.editor = editor;
    this.modes = [ViewModeType.CanvasView];
  }
  pushMode(mode) {
    if (!this.isCurrentMode(mode)) {
      this.modes.push(mode);
    }
  }
  popMode(mode = void 0) {
    if (mode) {
      if (this.isCurrentMode(mode)) {
        this.modes.pop();
      }
    } else {
      this.modes.pop();
    }
  }
  currentMode() {
    return this.modes[this.modes.length - 1];
  }
  isCurrentMode(mode) {
    return this.currentMode() === mode;
  }
}
class PluginManager {
  constructor(editor) {
    this.editor = editor;
    this.plugins = [];
  }
  registerPlugin(func) {
    this.plugins.push(func);
  }
  async initializePlugin(options2 = {}) {
    return await Promise.all(this.plugins.map(async (CreatePluginFunction) => {
      return await CreatePluginFunction(this.editor, options2);
    }));
  }
}
class RendererManager {
  constructor(editor) {
    this.editor = editor;
    this.renderers = {};
    this.rendererTypes = {};
  }
  getRenderType(rendererType) {
    if (!this.renderers[rendererType]) {
      this.renderers[rendererType] = {};
    }
    return this.renderers[rendererType];
  }
  registerRenderer(rendererType, name, rendererInstance) {
    const typedRenderer = this.getRenderType(rendererType);
    typedRenderer[name] = rendererInstance;
  }
  registerRendererType(rendererType, rendererTypeInstance) {
    this.rendererTypes[rendererType] = rendererTypeInstance;
  }
  getRenderer(rendererType) {
    return this.rendererTypes[rendererType];
  }
  getRendererInstance(rendererType, name) {
    const typedRenderer = this.getRenderType(rendererType);
    return typedRenderer[name];
  }
}
var add_artboard = {
  category: "Tool",
  key: "a",
  command: "addLayerView",
  args: ["artboard"],
  description: "Add ArtBoard",
  when: "CanvasView"
};
var __glob_0_0$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": add_artboard
}, Symbol.toStringTag, { value: "Module" }));
var add_artboard_pan = {
  category: "Tool",
  key: "a",
  command: "addLayerView",
  args: ["artboard"],
  description: "Add ArtBoard",
  when: "LayerAppendView"
};
var __glob_0_1$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": add_artboard_pan
}, Symbol.toStringTag, { value: "Module" }));
var add_brush = {
  category: "Tool",
  key: "b",
  command: "addLayerView",
  args: ["brush"],
  description: "Draw SVG Path",
  when: "CanvasView"
};
var __glob_0_2$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": add_brush
}, Symbol.toStringTag, { value: "Module" }));
var add_circle = {
  category: "Tool",
  key: "o",
  command: "addLayerView",
  args: ["circle"],
  description: "Add circle layer",
  when: "CanvasView"
};
var __glob_0_3$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": add_circle
}, Symbol.toStringTag, { value: "Module" }));
var add_circle_l = {
  category: "Tool",
  key: "l",
  command: "addLayerView",
  args: ["circle"],
  description: "Add circle layer",
  when: "CanvasView"
};
var __glob_0_4$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": add_circle_l
}, Symbol.toStringTag, { value: "Module" }));
var add_path = {
  category: "Tool",
  key: "p",
  command: "addLayerView",
  args: ["path"],
  description: "Add SVG Path layer",
  when: "CanvasView"
};
var __glob_0_5$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": add_path
}, Symbol.toStringTag, { value: "Module" }));
var add_rect = {
  category: "Tool",
  key: "r",
  command: "addLayerView",
  args: [
    "rect",
    {
      backgroundColor: "gray"
    }
  ],
  description: "Add rect layer",
  when: "CanvasView"
};
var __glob_0_6$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": add_rect
}, Symbol.toStringTag, { value: "Module" }));
var add_rect_m = {
  category: "Tool",
  key: "m",
  command: "addLayerView",
  args: ["rect"],
  description: "Add rect layer",
  when: "CanvasView"
};
var __glob_0_7$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": add_rect_m
}, Symbol.toStringTag, { value: "Module" }));
var add_rect_pan = {
  category: "Tool",
  key: "r",
  command: "addLayerView",
  args: [
    "rect",
    {
      backgroundColor: "gray"
    }
  ],
  description: "Add rect layer",
  when: "LayerAppendView"
};
var __glob_0_8$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": add_rect_pan
}, Symbol.toStringTag, { value: "Module" }));
var add_text = {
  category: "Tool",
  key: "t",
  command: "addLayerView",
  args: ["text"],
  description: "Add text layer",
  when: "CanvasView"
};
var __glob_0_9$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": add_text
}, Symbol.toStringTag, { value: "Module" }));
var clipboard_copy$1 = {
  category: "Edit",
  key: "cmd+c",
  command: "clipboard.copy",
  description: "Copy objects",
  when: "CanvasView"
};
var __glob_0_10$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": clipboard_copy$1
}, Symbol.toStringTag, { value: "Module" }));
var clipboard_paste$1 = {
  category: "Edit",
  key: "cmd+v",
  win: "ctrl+v",
  command: "clipboard.paste",
  description: "Paste selected objects",
  when: "CanvasView"
};
var __glob_0_11$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": clipboard_paste$1
}, Symbol.toStringTag, { value: "Module" }));
var escape = {
  category: "Tool",
  key: "escape",
  command: "select.none",
  description: "None selection",
  when: "CanvasView"
};
var __glob_0_12$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": escape
}, Symbol.toStringTag, { value: "Module" }));
var group_item$1 = {
  category: "Group",
  key: "cmd+g",
  win: "ctrl+g",
  command: "group.item",
  description: "Grouping selected items",
  when: "CanvasView"
};
var __glob_0_13$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": group_item$1
}, Symbol.toStringTag, { value: "Module" }));
var history_redo = {
  category: "History",
  key: "cmd+shift+z",
  win: "ctrl+shift+z",
  command: "history.redo",
  description: "redoing in history",
  when: "CanvasView"
};
var __glob_0_14$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": history_redo
}, Symbol.toStringTag, { value: "Module" }));
var history_undo = {
  category: "History",
  key: "cmd+z",
  win: "ctrl+z",
  command: "history.undo",
  description: "undoing in history",
  when: "CanvasView"
};
var __glob_0_15$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": history_undo
}, Symbol.toStringTag, { value: "Module" }));
var item_move_alt_down = {
  category: "Layer",
  key: "Alt+ArrowDown",
  command: "moveLayer",
  description: "move 5px to down",
  args: [0, 5],
  when: "CanvasView"
};
var __glob_0_16$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": item_move_alt_down
}, Symbol.toStringTag, { value: "Module" }));
var item_move_alt_left = {
  category: "Layer",
  key: "Alt+ArrowLeft",
  command: "moveLayer",
  description: "move 5px to left",
  args: [-5, 0],
  when: "CanvasView"
};
var __glob_0_17$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": item_move_alt_left
}, Symbol.toStringTag, { value: "Module" }));
var item_move_alt_right = {
  category: "Layer",
  key: "Alt+ArrowRight",
  command: "moveLayer",
  description: "move 5px to right",
  args: [5, 0],
  when: "CanvasView"
};
var __glob_0_18$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": item_move_alt_right
}, Symbol.toStringTag, { value: "Module" }));
var item_move_alt_up = {
  category: "Layer",
  key: "Alt+ArrowUp",
  command: "moveLayer",
  description: "move 5px to up",
  args: [0, -5],
  when: "CanvasView"
};
var __glob_0_19$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": item_move_alt_up
}, Symbol.toStringTag, { value: "Module" }));
var item_move_depth_down$1 = {
  category: "Layer",
  key: "[",
  command: "history.send.backward",
  description: "move layer to below",
  args: ["send backward"],
  when: "CanvasView"
};
var __glob_0_20$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": item_move_depth_down$1
}, Symbol.toStringTag, { value: "Module" }));
var item_move_depth_up$1 = {
  category: "Layer",
  key: "]",
  command: "history.bring.forward",
  description: "move layer to above",
  args: ["bring forward"],
  when: "CanvasView"
};
var __glob_0_21$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": item_move_depth_up$1
}, Symbol.toStringTag, { value: "Module" }));
var item_move_key_down = {
  category: "Layer",
  key: "ArrowDown",
  command: "moveLayer",
  description: "move 1px to down",
  args: [0, 1],
  when: "CanvasView"
};
var __glob_0_22$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": item_move_key_down
}, Symbol.toStringTag, { value: "Module" }));
var item_move_key_left = {
  category: "Layer",
  key: "ArrowLeft",
  command: "moveLayer",
  description: "move 1px to left",
  args: [-1, 0],
  when: "CanvasView"
};
var __glob_0_23$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": item_move_key_left
}, Symbol.toStringTag, { value: "Module" }));
var item_move_key_right = {
  category: "Layer",
  key: "ArrowRight",
  command: "moveLayer",
  description: "move 1px to right",
  args: [1, 0],
  when: "CanvasView"
};
var __glob_0_24$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": item_move_key_right
}, Symbol.toStringTag, { value: "Module" }));
var item_move_key_up = {
  category: "Layer",
  key: "ArrowUp",
  command: "moveLayer",
  description: "move 1px to up",
  args: [0, -1],
  when: "CanvasView"
};
var __glob_0_25$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": item_move_key_up
}, Symbol.toStringTag, { value: "Module" }));
var item_move_shift_down = {
  category: "Layer",
  key: "Shift+ArrowDown",
  command: "moveLayer",
  description: "move 10px to down",
  args: [0, 10],
  when: "CanvasView"
};
var __glob_0_26$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": item_move_shift_down
}, Symbol.toStringTag, { value: "Module" }));
var item_move_shift_left = {
  category: "Layer",
  key: "Shift+ArrowLeft",
  command: "moveLayer",
  description: "move 10px to left",
  args: [-10, 0],
  when: "CanvasView"
};
var __glob_0_27$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": item_move_shift_left
}, Symbol.toStringTag, { value: "Module" }));
var item_move_shift_right = {
  category: "Layer",
  key: "Shift+ArrowRight",
  command: "moveLayer",
  description: "move 10px to right",
  args: [10, 0],
  when: "CanvasView"
};
var __glob_0_28$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": item_move_shift_right
}, Symbol.toStringTag, { value: "Module" }));
var item_move_shift_up = {
  category: "Layer",
  key: "Shift+ArrowUp",
  command: "moveLayer",
  description: "move 10px to up",
  args: [0, -10],
  when: "CanvasView"
};
var __glob_0_29$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": item_move_shift_up
}, Symbol.toStringTag, { value: "Module" }));
var item_rotate_meta_left = {
  category: "Layer",
  key: "Meta+ArrowLeft",
  command: "rotateLayer",
  description: "rotate to left",
  args: [-5],
  when: "CanvasView"
};
var __glob_0_30$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": item_rotate_meta_left
}, Symbol.toStringTag, { value: "Module" }));
var item_rotate_meta_right = {
  category: "Layer",
  key: "Meta+ArrowRight",
  command: "rotateLayer",
  description: "rotate to right",
  args: [5],
  when: "CanvasView"
};
var __glob_0_31$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": item_rotate_meta_right
}, Symbol.toStringTag, { value: "Module" }));
var removeLayer$1 = {
  category: "Layer",
  key: "Backspace",
  command: "history.removeLayer",
  description: "Delete selected items",
  args: ["Delete selected items"],
  when: "CanvasView"
};
var __glob_0_32$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": removeLayer$1
}, Symbol.toStringTag, { value: "Module" }));
var removeLayerByDeleteKey = {
  category: "Layer",
  key: "Delete",
  command: "history.removeLayer",
  description: "Delete selected items",
  args: ["Delete selected items"],
  when: "CanvasView"
};
var __glob_0_33$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": removeLayerByDeleteKey
}, Symbol.toStringTag, { value: "Module" }));
var segment_delete$1 = {
  category: "Path",
  key: "Backspace",
  command: "segment.delete",
  description: "Delete selected segment",
  when: "PathEditorView"
};
var __glob_0_34$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": segment_delete$1
}, Symbol.toStringTag, { value: "Module" }));
var segment_move_alt_down = {
  category: "Path",
  key: "Alt+ArrowDown",
  command: "segment.move.down",
  description: "move 5px to down",
  args: [{ dy: 5 }],
  when: "PathEditorView"
};
var __glob_0_35$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": segment_move_alt_down
}, Symbol.toStringTag, { value: "Module" }));
var segment_move_alt_left = {
  category: "Path",
  key: "Alt+ArrowLeft",
  command: "segment.move.left",
  description: "move 5px to left",
  args: [{ dx: 5 }],
  when: "PathEditorView"
};
var __glob_0_36$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": segment_move_alt_left
}, Symbol.toStringTag, { value: "Module" }));
var segment_move_alt_right = {
  category: "Path",
  key: "Alt+ArrowRight",
  command: "segment.move.right",
  description: "move 5px to right",
  args: [{ dx: 5 }],
  when: "PathEditorView"
};
var __glob_0_37$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": segment_move_alt_right
}, Symbol.toStringTag, { value: "Module" }));
var segment_move_alt_up = {
  category: "Path",
  key: "Alt+ArrowUp",
  command: "segment.move.up",
  description: "move 5px to up ",
  args: [{ dy: 5 }],
  when: "PathEditorView"
};
var __glob_0_38$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": segment_move_alt_up
}, Symbol.toStringTag, { value: "Module" }));
var segment_move_key_down = {
  category: "Path",
  key: "ArrowDown",
  command: "segment.move.down",
  description: "move 1px to down",
  args: [{ dy: 1 }],
  when: "PathEditorView"
};
var __glob_0_39$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": segment_move_key_down
}, Symbol.toStringTag, { value: "Module" }));
var segment_move_key_left = {
  category: "Path",
  key: "ArrowLeft",
  command: "segment.move.left",
  description: "move 1px to left",
  args: [{ dx: 1 }],
  when: "PathEditorView"
};
var __glob_0_40$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": segment_move_key_left
}, Symbol.toStringTag, { value: "Module" }));
var segment_move_key_right = {
  category: "Path",
  key: "ArrowRight",
  command: "segment.move.right",
  description: "move 1px to right",
  args: [{ dx: 1 }],
  when: "PathEditorView"
};
var __glob_0_41$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": segment_move_key_right
}, Symbol.toStringTag, { value: "Module" }));
var segment_move_key_up = {
  category: "Path",
  key: "ArrowUp",
  command: "segment.move.up",
  description: "move 1px to up",
  args: [{ dy: 1 }],
  when: "PathEditorView"
};
var __glob_0_42$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": segment_move_key_up
}, Symbol.toStringTag, { value: "Module" }));
var segment_move_shift_down = {
  category: "Path",
  key: "Shift+ArrowDown",
  command: "segment.move.down",
  description: "move 10px to down",
  args: [{ dy: 10 }],
  when: "PathEditorView"
};
var __glob_0_43$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": segment_move_shift_down
}, Symbol.toStringTag, { value: "Module" }));
var segment_move_shift_left = {
  category: "Path",
  key: "Shift+ArrowLeft",
  command: "segment.move.left",
  description: "move 10px to left",
  args: [{ dx: 10 }],
  when: "PathEditorView"
};
var __glob_0_44$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": segment_move_shift_left
}, Symbol.toStringTag, { value: "Module" }));
var segment_move_shift_right = {
  category: "Path",
  key: "Shift+ArrowRight",
  command: "segment.move.right",
  description: "move 10px to right",
  args: [{ dx: 10 }],
  when: "PathEditorView"
};
var __glob_0_45$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": segment_move_shift_right
}, Symbol.toStringTag, { value: "Module" }));
var segment_move_shift_up = {
  category: "Path",
  key: "Shift+ArrowUp",
  command: "segment.move.up",
  description: "move 10px to up",
  args: [{ dy: 10 }],
  when: "PathEditorView"
};
var __glob_0_46$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": segment_move_shift_up
}, Symbol.toStringTag, { value: "Module" }));
var select_all$1 = {
  category: "Tool",
  key: "CMD+A",
  win: "CTRL+A",
  command: "select.all",
  description: "Selection all layers"
};
var __glob_0_47$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": select_all$1
}, Symbol.toStringTag, { value: "Module" }));
var select_view = {
  category: "Tool",
  key: "v",
  command: "addLayerView",
  args: ["select"],
  description: "Selection"
};
var __glob_0_48$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": select_view
}, Symbol.toStringTag, { value: "Module" }));
var set_tool_hand = {
  category: "Tools",
  key: "h",
  command: "toggleHandTool",
  description: "set hand tool on",
  when: "CanvasView"
};
var __glob_0_49$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": set_tool_hand
}, Symbol.toStringTag, { value: "Module" }));
var set_tool_hand_m = {
  category: "Tools",
  key: "h",
  command: "toggleHandTool",
  description: "set hand tool on",
  when: "LayerAppendView"
};
var __glob_0_50$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": set_tool_hand_m
}, Symbol.toStringTag, { value: "Module" }));
var show_pan = {
  category: "Tool",
  key: "space",
  command: "showPan",
  description: "Show panning area",
  when: "CanvasView"
};
var __glob_0_51$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": show_pan
}, Symbol.toStringTag, { value: "Module" }));
var ungroup_item$1 = {
  category: "Group",
  key: "shift+cmd+g",
  win: "shift+ctrl+g",
  command: "ungroup.item",
  description: "Ungrouping selected group layer",
  when: "CanvasView"
};
var __glob_0_52$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": ungroup_item$1
}, Symbol.toStringTag, { value: "Module" }));
var zoom_default = {
  category: "View",
  key: "0",
  command: "zoom.default",
  description: "zoom by scale 1",
  when: "CanvasView"
};
var __glob_0_53$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": zoom_default
}, Symbol.toStringTag, { value: "Module" }));
var zoom_in = {
  category: "View",
  key: "Equal",
  command: "zoom.in",
  description: "zoom in",
  when: "CanvasView"
};
var __glob_0_54$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": zoom_in
}, Symbol.toStringTag, { value: "Module" }));
var zoom_out = {
  category: "View",
  key: "minus",
  command: "zoom.out",
  description: "zoom Out",
  when: "CanvasView"
};
var __glob_0_55$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": zoom_out
}, Symbol.toStringTag, { value: "Module" }));
const modules$2 = { "./shortcuts_list/add.artboard.js": __glob_0_0$2, "./shortcuts_list/add.artboard.pan.js": __glob_0_1$2, "./shortcuts_list/add.brush.js": __glob_0_2$2, "./shortcuts_list/add.circle.js": __glob_0_3$2, "./shortcuts_list/add.circle.l.js": __glob_0_4$2, "./shortcuts_list/add.path.js": __glob_0_5$2, "./shortcuts_list/add.rect.js": __glob_0_6$2, "./shortcuts_list/add.rect.m.js": __glob_0_7$2, "./shortcuts_list/add.rect.pan.js": __glob_0_8$2, "./shortcuts_list/add.text.js": __glob_0_9$2, "./shortcuts_list/clipboard.copy.js": __glob_0_10$2, "./shortcuts_list/clipboard.paste.js": __glob_0_11$2, "./shortcuts_list/escape.js": __glob_0_12$2, "./shortcuts_list/group.item.js": __glob_0_13$2, "./shortcuts_list/history.redo.js": __glob_0_14$2, "./shortcuts_list/history.undo.js": __glob_0_15$2, "./shortcuts_list/item.move.alt.down.js": __glob_0_16$2, "./shortcuts_list/item.move.alt.left.js": __glob_0_17$2, "./shortcuts_list/item.move.alt.right.js": __glob_0_18$2, "./shortcuts_list/item.move.alt.up.js": __glob_0_19$2, "./shortcuts_list/item.move.depth.down.js": __glob_0_20$2, "./shortcuts_list/item.move.depth.up.js": __glob_0_21$2, "./shortcuts_list/item.move.key.down.js": __glob_0_22$2, "./shortcuts_list/item.move.key.left.js": __glob_0_23$2, "./shortcuts_list/item.move.key.right.js": __glob_0_24$1, "./shortcuts_list/item.move.key.up.js": __glob_0_25$1, "./shortcuts_list/item.move.shift.down.js": __glob_0_26$1, "./shortcuts_list/item.move.shift.left.js": __glob_0_27$1, "./shortcuts_list/item.move.shift.right.js": __glob_0_28$1, "./shortcuts_list/item.move.shift.up.js": __glob_0_29$1, "./shortcuts_list/item.rotate.meta.left.js": __glob_0_30$1, "./shortcuts_list/item.rotate.meta.right.js": __glob_0_31$1, "./shortcuts_list/removeLayer.js": __glob_0_32$1, "./shortcuts_list/removeLayerByDeleteKey.js": __glob_0_33$1, "./shortcuts_list/segment.delete.js": __glob_0_34$1, "./shortcuts_list/segment.move.alt.down.js": __glob_0_35$1, "./shortcuts_list/segment.move.alt.left.js": __glob_0_36$1, "./shortcuts_list/segment.move.alt.right.js": __glob_0_37$1, "./shortcuts_list/segment.move.alt.up.js": __glob_0_38$1, "./shortcuts_list/segment.move.key.down.js": __glob_0_39$1, "./shortcuts_list/segment.move.key.left.js": __glob_0_40$1, "./shortcuts_list/segment.move.key.right.js": __glob_0_41$1, "./shortcuts_list/segment.move.key.up.js": __glob_0_42$1, "./shortcuts_list/segment.move.shift.down.js": __glob_0_43$1, "./shortcuts_list/segment.move.shift.left.js": __glob_0_44$1, "./shortcuts_list/segment.move.shift.right.js": __glob_0_45$1, "./shortcuts_list/segment.move.shift.up.js": __glob_0_46$1, "./shortcuts_list/select.all.js": __glob_0_47$1, "./shortcuts_list/select.view.js": __glob_0_48$1, "./shortcuts_list/set.tool.hand.js": __glob_0_49$1, "./shortcuts_list/set.tool.hand.m.js": __glob_0_50$1, "./shortcuts_list/show.pan.js": __glob_0_51$1, "./shortcuts_list/ungroup.item.js": __glob_0_52$1, "./shortcuts_list/zoom.default.js": __glob_0_53$1, "./shortcuts_list/zoom.in.js": __glob_0_54$1, "./shortcuts_list/zoom.out.js": __glob_0_55$1 };
var shortcuts = Object.values(modules$2).map((it) => it.default);
function joinKeys(...args2) {
  return args2.filter(Boolean).join("+");
}
function generateKeyCode(code2) {
  return KEY_CODE[`${code2}`.toLowerCase()] || code2;
}
class ShortCutManager {
  constructor(editor) {
    this.$editor = editor;
    this.loadShortCuts();
  }
  getGeneratedKeyCode(code2) {
    return generateKeyCode(code2);
  }
  loadShortCuts() {
    this.list = [];
    this.commands = {};
    shortcuts.forEach((shortcut) => {
      this.registerShortCut(shortcut);
    });
    this.sort();
  }
  registerShortCut(shortcut) {
    const OSName2 = os();
    this.list.push(__spreadProps(__spreadValues({
      key: "",
      command: "",
      args: [],
      eventType: "keydown"
    }, shortcut), {
      checkKeyString: this.splitShortCut(shortcut[OSName2] || shortcut.key),
      whenFunction: this.makeWhenFunction(shortcut.command, shortcut.when || true)
    }));
    this.sort();
  }
  makeWhenFunction(command, when) {
    if (isBoolean(when) && when) {
      return () => true;
    }
    const editor = this.$editor;
    const whenList = when.split("|").map((it) => it.trim());
    return () => {
      return whenList.some((it) => editor.context.modeViewManager.isCurrentMode(it));
    };
  }
  sort() {
    this.commands = {};
    this.list.forEach((it) => {
      if (Array.isArray(this.commands[it.checkKeyString]) === false) {
        this.commands[it.checkKeyString] = [];
      }
      this.commands[it.checkKeyString].push(it);
    });
  }
  splitShortCut(key) {
    var arr = key.toUpperCase().split("+").map((it) => it.trim()).filter(Boolean);
    let isAlt = false;
    let isControl = false;
    let isShift = false;
    let isMeta = false;
    let restKeys = [];
    arr.forEach((key2) => {
      if (key2.includes("ALT"))
        isAlt = true;
      else if (key2.includes("CTRL"))
        isControl = true;
      else if (key2.includes("SHIFT"))
        isShift = true;
      else if (key2.includes("CMD") || key2.includes("WIN") || key2.includes("META"))
        isMeta = true;
      else
        restKeys.push(key2);
    });
    return joinKeys(isAlt ? "ALT" : "", isControl ? "CTRL" : "", isShift ? "SHIFT" : "", isMeta ? "META" : "", generateKeyCode(restKeys.join("")));
  }
  makeKeyString(e) {
    return joinKeys(e.altKey ? "ALT" : "", e.ctrlKey ? "CTRL" : "", e.shiftKey ? "SHIFT" : "", e.metaKey ? "META" : "", e.key.toUpperCase());
  }
  makeCodeString(e) {
    return joinKeys(e.altKey ? "ALT" : "", e.ctrlKey ? "CTRL" : "", e.shiftKey ? "SHIFT" : "", e.metaKey ? "META" : "", e.code.toUpperCase());
  }
  makeKeyCodeString(e) {
    return joinKeys(e.altKey ? "ALT" : "", e.ctrlKey ? "CTRL" : "", e.shiftKey ? "SHIFT" : "", e.metaKey ? "META" : "", e.keyCode);
  }
  checkShortCut(keyCodeString, keyString, codeString) {
    return this.commands[keyCodeString] || this.commands[keyString] || this.commands[codeString];
  }
  checkWhen(command) {
    return command.whenFunction();
  }
  execute(e, eventType = "keydown") {
    let commands2 = this.checkShortCut(this.makeKeyCodeString(e), this.makeKeyString(e), this.makeCodeString(e));
    if (commands2) {
      const filteredCommands = commands2.filter((it) => it.eventType === eventType).filter((it) => this.checkWhen(it));
      if (filteredCommands.length) {
        filteredCommands.forEach((it) => {
          this.$editor.context.commands.emit(it.command, ...it.args);
        });
      }
    }
  }
}
class StateManager {
  constructor(editor) {
    this.editor = editor;
  }
  get config() {
    return this.editor.context.config;
  }
  get zIndex() {
    return this.popupZIndex++;
  }
  get isPointerUp() {
    const e = this.config.get("bodyEvent");
    if (!e)
      return true;
    if (e.type === "pointerup")
      return true;
    else if (e.type === "pointermove" && e.buttons === 0)
      return true;
    return false;
  }
  get isPointerDown() {
    return !this.isPointerUp;
  }
  get isPointerMove() {
    if (!this.config.get("bodyEvent"))
      return false;
    return this.config.get("bodyEvent").type === "pointermove";
  }
}
class StorageManager {
  constructor(editor) {
    this.editor = editor;
    this.customAssetKey = "custom-assets";
  }
  async getCustomAssetList() {
    let isNew = false;
    const artboards = (this.editor.loadItem(this.customAssetKey) || []).map((it) => {
      if (!it.id) {
        it.id = uuid();
        isNew = true;
      }
      return it;
    });
    if (isNew) {
      await this.setCustomAssetList(artboards);
    }
    return artboards;
  }
  async setCustomAssetList(list2) {
    this.editor.saveItem(this.customAssetKey, list2);
  }
  async getCustomAsset(id) {
    const assetList = await this.getCustomAssetList();
    const it = assetList.find((it2) => it2.id === id);
    if (it && it.component) {
      return it.component;
    }
    return null;
  }
  async saveCustomAsset(datauri = "") {
    const current = this.editor.context.selection.current;
    if (current) {
      const assetList = await this.getCustomAssetList();
      const json = await this.editor.json.render(current);
      json.x = 0;
      json.y = 0;
      await this.setCustomAssetList([
        ...assetList,
        {
          id: uuid(),
          preview: datauri,
          component: json
        }
      ]);
    }
  }
  async removeCustomAsset(id) {
    const assetList = await this.getCustomAssetList();
    await this.setCustomAssetList(assetList.filter((it) => {
      return it.id !== id;
    }));
  }
}
class ViewportManager {
  constructor(editor) {
    this.editor = editor;
    this.context = this.editor.context;
    this.canvasSize = null;
    this.cachedViewport = rectToVerties(0, 0, 0, 0);
    this.mouse = create$3();
    this.scaleMax = 1e5;
    this.scale = 1;
    this.translate = create$3();
    this.transformOrigin = create$3();
    this.maxScale = 25;
    this.minScale = 0.02;
    this.zoomFactor = 1;
    this.resetWorldMatrix();
  }
  setTransformOrigin(originVec) {
    this.transformOrigin = originVec;
    this.resetWorldMatrix();
  }
  setTransformOriginWithTranslate(newOrigin) {
    const oldOrigin = clone(this.transformOrigin);
    this.setTransformOrigin(newOrigin);
    this.setTranslate(add$1([], this.translate, subtract([], oldOrigin, newOrigin)));
  }
  setScale(scale2) {
    this.scale = Math.min(Math.max(this.minScale, scale2), this.maxScale);
    this.scaleMax = this.scale * 1e5;
    this.resetWorldMatrix();
  }
  setTranslate(translate2) {
    this.translate = translate2;
    this.resetWorldMatrix();
  }
  resetWorldMatrix() {
    this.translate = this.translate.map((it) => +it.toFixed(4));
    this.transformOrigin = this.transformOrigin.map((it) => +it.toFixed(4));
    this.scale = +this.scale.toFixed(4);
    this.matrix = calculateMatrix(fromTranslation([], this.translate), fromTranslation([], this.transformOrigin), fromScaling([], [this.scale, this.scale, 1]), fromTranslation([], negate([], this.transformOrigin)));
    this.matrixInverse = invert([], this.matrix);
    this.scaleMatrix = calculateMatrix(fromScaling([], [this.scale, this.scale, 1]));
    this.scaleMatrixInverse = invert([], this.scaleMatrix);
    this.refresh();
  }
  refreshCanvasSize(rect2) {
    if (this.canvasSize) {
      this.canvasSize = rect2;
      this.cachedViewport = rectToVerties(0, 0, this.canvasSize.width, this.canvasSize.height);
      const newVerties = transformMat4([], [this.canvasSize.width, this.canvasSize.height, 0], this.scaleMatrixInverse);
      const newTransformOrigin = add$1([], this.verties[0], [
        newVerties[0] / 2,
        newVerties[1] / 2,
        0
      ]);
      const newTranslate = getTranslation([], calculateMatrix(this.matrix, calculateMatrixInverse(fromTranslation([], newTransformOrigin), this.scaleMatrix, invert([], fromTranslation([], newTransformOrigin)))));
      this.setTranslate(newTranslate);
      this.setTransformOrigin(newTransformOrigin);
    } else {
      this.canvasSize = rect2;
      this.cachedViewport = rectToVerties(0, 0, this.canvasSize.width, this.canvasSize.height);
      this.setTransformOrigin([
        this.canvasSize.width / 2,
        this.canvasSize.height / 2,
        0
      ]);
    }
    this.editor.emit(UPDATE_VIEWPORT);
  }
  refresh() {
    if (this.cachedViewport) {
      this.verties = vertiesMap(this.cachedViewport, this.matrixInverse);
      this.originVerties = this.verties.filter((_, index2) => index2 < 4);
      this.originRect = vertiesToRectangle(this.originVerties);
    }
  }
  getWorldPosition(e) {
    e = e || this.context.config.get("bodyEvent");
    if (!e) {
      return this.createWorldPosition(0, 0);
    }
    return this.createWorldPosition(e.clientX, e.clientY);
  }
  createWorldPosition(x, y) {
    if (!this.canvasSize) {
      return create$3();
    }
    const origin = {
      x: x - this.canvasSize.x,
      y: y - this.canvasSize.y
    };
    const mouseX = this.verties[0][0] + (this.verties[2][0] - this.verties[0][0]) * (origin.x / this.canvasSize.width);
    const mouseY = this.verties[0][1] + (this.verties[2][1] - this.verties[0][1]) * (origin.y / this.canvasSize.height);
    return [mouseX, mouseY, 0];
  }
  setMousePoint(x, y) {
    this.mouse = this.createWorldPosition(x, y);
    this.setTransformOriginWithTranslate(lerp([], this.verties[0], this.verties[2], 0.5));
    this.editor.emit(UPDATE_VIEWPORT);
  }
  zoom(zoomFactor) {
    const oldScale = this.scale;
    const newScale = oldScale * zoomFactor;
    this.setScale(newScale);
    const newZoomFactor = this.scale / oldScale;
    this.zoomFactor = newZoomFactor;
    if (newZoomFactor !== 1) {
      this.setTransformOriginWithTranslate(lerp([], this.mouse, this.transformOrigin, 1 / zoomFactor));
      this.editor.emit(UPDATE_VIEWPORT);
    }
  }
  pan(x, y, z = 0) {
    this.setTransformOriginWithTranslate(add$1([], this.transformOrigin, [x, y, 0]));
    this.editor.emit(UPDATE_VIEWPORT);
  }
  moveToCenter(areaVerties, scaleRate = -0.2, withScale = true) {
    if (!this.canvasSize)
      return;
    const areaCenter = lerp([], areaVerties[0], areaVerties[2], 0.5);
    const width2 = dist(areaVerties[0], areaVerties[1]);
    const height2 = dist(areaVerties[0], areaVerties[3]);
    const viewportCenter = lerp([], this.verties[0], this.verties[2], 0.5);
    const viewportWidth = dist(this.verties[0], this.verties[1]);
    const viewportHeight = dist(this.verties[0], this.verties[3]);
    const minRate = withScale ? Math.min(viewportWidth / width2, viewportHeight / height2) + scaleRate : 1;
    this.setTranslate(add$1([], this.translate, subtract([], viewportCenter, areaCenter)));
    this.setTransformOrigin(areaCenter);
    this.setScale(this.scale * minRate);
    this.editor.emit(UPDATE_VIEWPORT);
  }
  get pos() {
    const mouseX = (this.mouse[0] - this.verties[0][0]) / (this.verties[2][0] - this.verties[0][0]) * 100;
    const mouseY = (this.mouse[1] - this.verties[0][1]) / (this.verties[2][1] - this.verties[0][1]) * 100;
    return [mouseX, mouseY, 0];
  }
  get minX() {
    return this.verties[0][0];
  }
  get maxX() {
    return this.verties[2][0];
  }
  get minY() {
    return this.verties[0][1];
  }
  get maxY() {
    return this.verties[2][1];
  }
  get center() {
    return this.verties[4];
  }
  get height() {
    return this.maxY - this.minY;
  }
  get width() {
    return this.maxX - this.minX;
  }
  get pixelSize() {
    return Math.round(this.width / this.canvasSize.width);
  }
  checkInViewport(pointVertex) {
    const xInViewport = this.minX < pointVertex[0] && pointVertex[0] < this.maxX;
    const yInViewport = this.minY < pointVertex[1] && pointVertex[1] < this.maxY;
    return xInViewport && yInViewport;
  }
  checkInViewportArea(verties = []) {
    const source2 = vertiesToRectangle(verties);
    const target = this.originRect;
    return rectRect(source2.x, source2.y, source2.width, source2.height, target.x, target.y, target.width, target.height);
  }
  applyVertex(vertex) {
    return transformMat4([], vertex, this.matrix);
  }
  applyVertexInverse(vertex) {
    return transformMat4([], vertex, this.matrixInverse);
  }
  applyScaleVertex(vertex) {
    return transformMat4([], vertex, this.scaleMatrix);
  }
  applyScaleVertexInverse(vertex) {
    return transformMat4([], vertex, this.scaleMatrixInverse);
  }
  applyVerties(verties) {
    return vertiesMap(verties, this.matrix);
  }
  applyScaleVerties(verties) {
    return vertiesMap(verties, this.scaleMatrix);
  }
  applyVertiesInverse(verties) {
    return vertiesMap(verties, this.matrixInverse);
  }
  applyScaleVertiesInverse(verties) {
    return vertiesMap(verties, this.scaleMatrixInverse);
  }
  createAreaVerties(x, y, width2, height2) {
    return this.applyVertiesInverse(rectToVertiesForArea(x, y, width2, height2));
  }
  zoomIn(zoomFactor = 0.01) {
    this.setScale(this.scale + zoomFactor);
    this.editor.emit(UPDATE_VIEWPORT);
  }
  zoomOut(zoomFactor = 0.01) {
    this.zoomIn(-zoomFactor);
  }
  zoomDefault() {
    this.setScale(1);
    this.editor.emit(UPDATE_VIEWPORT);
  }
}
var dark = {
  left_size: 250,
  left_max_size: 400,
  bottom_size: 150,
  bottom_max_size: 500,
  timeline_grid_font_color: "#ececec",
  timeline_line_color: "red",
  timeline_timeview_bottom_color: "black"
};
var light = {
  left_size: 250,
  left_max_size: 400,
  bottom_size: 150,
  bottom_max_size: 500,
  timeline_grid_font_color: "black",
  timeline_line_color: "#4778d4",
  timeline_timeview_bottom_color: "#ececec"
};
var theme = {
  dark,
  light
};
class Editor {
  constructor(opt = {}) {
    this.EDITOR_ID = uuid();
    this.projects = [];
    this.popupZIndex = 1e4;
    this.symbols = {};
    this.images = {};
    this.openRightPanel = true;
    this.ignoreManagers = opt.ignoreManagers || [];
    this.context = {};
    this.loadManagers();
  }
  loadManagers() {
    this.registerManager({
      store: BaseStore,
      config: ConfigManager,
      commands: CommandManager,
      keyboardManager: KeyBoardManager,
      viewport: ViewportManager,
      storageManager: StorageManager,
      modeViewManager: ModeViewManager,
      cursorManager: CursorManager,
      assetManager: AssetManager,
      injectManager: InjectManager,
      components: ComponentManager,
      pluginManager: PluginManager,
      renderers: RendererManager,
      i18n: I18nManager,
      icon: IconManager,
      stateManager: StateManager,
      menuManager: MenuManager
    });
    if (this.ignoreManagers.includes("ShortCutManager") === false) {
      this.registerManager({
        shortcuts: ShortCutManager
      });
    }
    this.loadCommands(obj$1);
    this.initPlugins();
    this.initStorage();
  }
  registerManager(obj2 = {}) {
    Object.keys(obj2).forEach((name) => {
      const DataManagerClass = obj2[name];
      Object.defineProperty(this.context, name, {
        value: new DataManagerClass(this),
        writable: false
      });
    });
  }
  initStorage() {
    this.locale = this.loadItem("locale") || "en_US";
    this.layout = this.loadItem("layout") || "all";
  }
  createProject() {
    return this.createModel({ itemType: "project" });
  }
  getI18nMessage(key, params = {}, locale) {
    return this.context.i18n.get(key, params, locale || this.locale);
  }
  $i18n(key, params = {}, locale) {
    return this.getI18nMessage(key, params, locale);
  }
  hasI18nkey(key, locale) {
    return this.context.i18n.hasKey(key, locale || this.locale);
  }
  initI18nMessage(root = "") {
    return (key, params = {}, locale) => {
      const i18nKey = `${root}.${key}`;
      if (this.hasI18nkey(i18nKey, locale)) {
        return this.context.i18(`${root}.${key}`, params, locale);
      } else {
        return this.context.i18(`${key}`, params, locale);
      }
    };
  }
  setLocale(locale = "en_US") {
    this.locale = locale;
    this.saveItem("locale", this.locale);
  }
  setUser(user) {
    this.user = user;
  }
  async initPlugins(options2 = {}) {
    await this.context.pluginManager.initializePlugin(options2);
  }
  themeValue(key, defaultValue2 = "") {
    return theme[this.context.config.get("editor.theme")][key] || defaultValue2;
  }
  get zIndex() {
    return this.popupZIndex++;
  }
  getFile(url) {
    return this.images[url] || url;
  }
  setStore(store) {
    this.store = store;
  }
  emit(...args2) {
    this.context.store.source = this.EDITOR_ID;
    this.context.store.emit(...args2);
  }
  on(...args2) {
    const [name, callback, context, ...rest] = args2;
    return this.context.store.on(name, callback, context || this, ...rest);
  }
  off(...args2) {
    this.context.store.off(...args2);
  }
  offAll(...args2) {
    this.context.store.offAll(...args2);
  }
  debug() {
  }
  command(command, message, ...args2) {
    console.warn("command", command, message, args2);
    if (this.context.stateManager.isPointerUp) {
      return this.context.store.emit(`history.${command}`, message, ...args2);
    } else {
      return this.context.store.emit(command, ...args2);
    }
  }
  nextTick(callback, delay = 0) {
    if (this.context.store) {
      window.setTimeout(() => {
        this.context.store.nextTick(callback);
      }, delay);
    }
  }
  get(idOrModel) {
    return this.context.modelManager.get((idOrModel == null ? void 0 : idOrModel.id) || idOrModel);
  }
  replaceLocalUrltoRealUrl(str) {
    var project2 = this.context.selection.currentProject;
    var images = {};
    project2.images.forEach((a) => {
      if (str.indexOf(a.local) > -1) {
        images[a.local] = a.original;
      }
    });
    Object.keys(images).forEach((local) => {
      if (str.indexOf(local) > -1) {
        str = str.replace(new RegExp(local, "g"), images[local]);
      }
    });
    return str;
  }
  createModel(itemObject, isRegister = true) {
    return this.context.modelManager.createModel(itemObject, isRegister);
  }
  searchItem(id) {
    return this.context.modelManager.searchItem(id);
  }
  get storeKey() {
    return `__els__.${this.context.config.get("store.key")}`;
  }
  saveItem(key, value) {
    window.localStorage.setItem(`${this.storeKey}.${key}`, JSON.stringify(value));
  }
  loadItem(key) {
    return JSON.parse(window.localStorage.getItem(`${this.storeKey}.${key}`) || JSON.stringify(""));
  }
  createCommandMaker() {
    return new CommandMaker(this);
  }
  registerElement(obj2) {
    registElement(obj2);
  }
  registerAlias(obj2) {
    Object.entries(obj2).forEach(([key, value]) => {
      registAlias(key, value);
    });
  }
  registerUI(target, obj2 = {}, order = 1) {
    this.context.injectManager.registerUI(target, obj2, order);
    this.registerElement(obj2);
  }
  isComponentClass(name) {
    return this.context.components.isComponentClass(name);
  }
  registerComponent(name, component2) {
    this.context.components.registerComponent(name, component2);
  }
  registerItem(name, item) {
    this.registerComponent(name, item);
  }
  registerInspector(name, inspectorCallback) {
    this.context.components.registerInspector(name, inspectorCallback);
  }
  registerRenderer(rendererType, name, rendererInstance) {
    this.context.renderers.registerRenderer(rendererType, name, rendererInstance);
  }
  registerRendererType(rendererType, rendererTypeInstance) {
    this.context.renderers.registerRendererType(rendererType, rendererTypeInstance);
  }
  getRendererInstance(rendererType, itemType) {
    return this.context.renderers.getRendererInstance(rendererType, itemType);
  }
  renderer(rendererType) {
    return this.context.renderers.getRenderer(rendererType);
  }
  get json() {
    return this.renderer("json");
  }
  loadCommands(userCommands) {
    return this.context.commands.loadCommands(userCommands);
  }
  registerCommand(commandObject) {
    return this.context.commands.registerCommand(commandObject);
  }
  registerShortCut(shortcut) {
    this.context.shortcuts.registerShortCut(shortcut);
  }
  registerPlugin(createPluginFunction) {
    this.context.pluginManager.registerPlugin(createPluginFunction);
  }
  registerPluginList(plugins = []) {
    plugins.forEach((p) => this.registerPlugin(p));
  }
  registerConfig(config) {
    this.context.config.registerConfig(config);
  }
  registerI18nMessage(locale, messages) {
    this.context.i18n.registerI18nMessage(locale, messages);
  }
  registerI18nMessageWithLocale(messages) {
    Object.entries(messages).forEach(([locale, messages2]) => {
      this.registerI18nMessage(locale, messages2);
    });
  }
  registerIcon(itemType, iconOrFunction) {
    this.context.icon.registerIcon(itemType, iconOrFunction);
  }
  registerMenu(target, menu) {
    this.context.menuManager.registerMenu(target, menu);
  }
}
const EMPTY_POS = { x: 0, y: 0 };
const DEFAULT_POS = { x: Number.MAX_SAFE_INTEGER, y: Number.MAX_SAFE_INTEGER };
const MOVE_CHECK_MS = 0;
class BaseLayout extends EditorElement {
  async created() {
    this.$editor.registerManager(this.getManagers());
    this.$editor.registerPluginList(this.getPlugins());
    if (Array.isArray(this.opt.plugins)) {
      this.$editor.registerPluginList(this.opt.plugins);
    }
    await this.$editor.initPlugins();
    this.$config.load();
    if (isObject(this.opt.config)) {
      this.$config.setAll(this.opt.config || {});
    }
    this._isPluginLoaded = true;
  }
  get isPreLoaded() {
    return Boolean(this._isPluginLoaded);
  }
  get $editor() {
    if (!this.__editorInstance) {
      this.__editorInstance = this.createEditorInstance();
    }
    return this.__editorInstance;
  }
  createEditorInstance() {
    return new Editor();
  }
  afterRender() {
    super.afterRender();
    this.$el.attr("data-theme", this.$config.get("editor.theme"));
    this.$el.addClass(window.navigator.userAgent.includes("Windows") ? "ua-window" : "ua-default");
    this.trigger("initialize");
  }
  initialize() {
    super.initialize();
    this.__initBodyMoves();
  }
  [CONFIG("editor.theme")]() {
    this.$el.attr("data-theme", this.$config.get("editor.theme"));
  }
  getPlugins() {
    return [];
  }
  getManagers() {
    return {};
  }
  __initBodyMoves() {
    this.__firstMove = /* @__PURE__ */ new Set();
    this.__moves = /* @__PURE__ */ new Set();
    this.__ends = /* @__PURE__ */ new Set();
    this.__modifyBodyMoveSecond(MOVE_CHECK_MS);
  }
  __modifyBodyMoveSecond(ms = MOVE_CHECK_MS) {
    this.$config.set("body.move.ms", ms);
    const callback = ms === 0 ? this.__loopBodyMoves.bind(this) : debounce(this.__loopBodyMoves.bind(this), this.$config.get("body.move.ms"));
    this.__funcBodyMoves = callback;
  }
  __loopBodyMoves() {
    var pos = this.pos;
    var e = this.$config.get("bodyEvent");
    var lastPos = this.lastPos || DEFAULT_POS;
    var isNotEqualLastPos = !(lastPos.x === pos.x && lastPos.y === pos.y);
    if (isNotEqualLastPos && this.__firstMove.size) {
      let i = 0;
      this.__firstMove.forEach((v) => {
        const dist2 = getDist(pos.x, pos.y, v.xy.x, v.xy.y);
        if (Math.abs(dist2) > 0) {
          var dx = pos.x - v.xy.x;
          var dy = pos.y - v.xy.y;
          v.func.call(v.context, dx, dy, "move", e.pressure);
          i++;
        }
      });
      if (i > 0) {
        this.__firstMove.clear();
      }
    }
    if (isNotEqualLastPos && this.__moves.size) {
      this.__moves.forEach((v) => {
        const dist2 = getDist(pos.x, pos.y, v.xy.x, v.xy.y);
        if (Math.abs(dist2) > 0.5) {
          var dx = pos.x - v.xy.x;
          var dy = pos.y - v.xy.y;
          v.func.call(v.context, dx, dy, "move", e.pressure);
        }
      });
      this.lastPos = pos;
    }
    window.requestAnimationFrame(this.__funcBodyMoves);
  }
  __removeBodyMoves() {
    var pos = this.lastPos;
    var e = this.$config.get("bodyEvent");
    if (pos) {
      this.__ends.forEach((v) => {
        v.func.call(v.context, pos.x - v.xy.x, pos.y - v.xy.y, "end", e.pressure);
      });
    }
    this.__firstMove.clear();
    this.__moves.clear();
    this.__ends.clear();
  }
  [SUBSCRIBE_ALL(ADD_BODY_FIRST_MOUSEMOVE)](func, context, xy2) {
    this.__firstMove.add({ func, context, xy: xy2 });
  }
  [SUBSCRIBE_ALL(ADD_BODY_MOUSEMOVE)](func, context, xy2) {
    this.__moves.add({ func, context, xy: xy2 });
  }
  [SUBSCRIBE_ALL(ADD_BODY_MOUSEUP)](func, context, xy2) {
    this.__ends.add({ func, context, xy: xy2 });
  }
  [POINTERSTART()](e) {
    var newPos = e.xy || EMPTY_POS;
    this.$config.init("bodyEvent", e);
    this.pos = newPos;
  }
  [POINTERMOVE()](e) {
    var newPos = e.xy || EMPTY_POS;
    this.$config.init("bodyEvent", e);
    this.$commands.emit("change.bodyEvent");
    this.pos = newPos;
    if (!this.__requestId) {
      this.__requestId = window.requestAnimationFrame(this.__funcBodyMoves);
    }
  }
  [POINTEREND()](e) {
    this.$config.set("bodyEvent", e);
    this.__removeBodyMoves();
    window.cancelAnimationFrame(this.__requestId);
    this.__requestId = null;
  }
  [RESIZE("window") + DEBOUNCE(100)]() {
    this.emit(RESIZE_WINDOW);
  }
  [SUBSCRIBE("refreshAll")]() {
    this.emit("refreshProjectList");
    this.$commands.emit("refreshArtboard");
  }
  [SUBSCRIBE("changed.locale")]() {
    this.rerender();
  }
}
var DefaultLayout$1 = "";
const DefaultLayoutDirection = {
  LEFT: "left",
  RIGHT: "right",
  TOP: "top",
  BOTTOM: "bottom",
  BODY: "body",
  INNER: "inner",
  OUTER: "outer"
};
class DefaultLayoutItem extends EditorElement {
  get size() {
    return this.props.size;
  }
}
class DefaultLayout extends EditorElement {
  getLayoutElements() {
    return this.refs;
  }
  initState() {
    return {
      showLeftPanel: isNotUndefined(this.props.showLeftPanel) ? Boolean(this.props.showLeftPanel) : true,
      showRightPanel: isNotUndefined(this.props.showRightPanel) ? Boolean(this.props.showRightPanel) : true,
      topSize: isNotUndefined(this.props.topSize) ? Number(this.props.topSize) : 48,
      leftSize: isNotUndefined(this.props.leftSize) ? Number(this.props.leftSize) : 340,
      rightSize: isNotUndefined(this.props.rightSize) ? Number(this.props.rightSize) : 280,
      bottomSize: this.props.bottomSize || 20,
      lastBottomSize: this.props.lastBottomSize || 150,
      minSize: isNotUndefined(this.props.minSize) ? Boolean(this.props.minSize) : 240,
      maxSize: isNotUndefined(this.props.maxSize) ? Boolean(this.props.maxSize) : 500
    };
  }
  getDirection(direction2) {
    return this.getChildContent((it) => it.props.type === direction2);
  }
  template() {
    const top2 = this.getDirection(DefaultLayoutDirection.TOP);
    const left2 = this.getDirection(DefaultLayoutDirection.LEFT);
    const right2 = this.getDirection(DefaultLayoutDirection.RIGHT);
    const bottom2 = this.getDirection(DefaultLayoutDirection.BOTTOM);
    const body = this.getDirection(DefaultLayoutDirection.BODY);
    const inner = this.getDirection(DefaultLayoutDirection.INNER);
    const outer = this.getDirection(DefaultLayoutDirection.OUTER);
    return /* @__PURE__ */ createElementJsx("div", {
      class: "elf--default-layout-container"
    }, /* @__PURE__ */ createElementJsx("div", {
      class: `elf--default-layout`
    }, top2 ? /* @__PURE__ */ createElementJsx("div", {
      class: "layout-top",
      ref: "$topPanel"
    }, top2) : "", /* @__PURE__ */ createElementJsx("div", {
      class: "layout-middle",
      ref: "$middle"
    }, left2 ? /* @__PURE__ */ createElementJsx("div", {
      class: "layout-left",
      ref: "$leftPanel"
    }, left2) : "", /* @__PURE__ */ createElementJsx("div", {
      class: "layout-body",
      ref: "$bodyPanel"
    }, body), right2 ? /* @__PURE__ */ createElementJsx("div", {
      class: "layout-right",
      ref: "$rightPanel"
    }, right2) : "", /* @__PURE__ */ createElementJsx("div", {
      class: "splitter",
      ref: "$splitter"
    })), bottom2 ? /* @__PURE__ */ createElementJsx("div", {
      class: "layout-bottom",
      ref: "$bottomPanel"
    }, bottom2) : "", inner), outer);
  }
  [BIND("$splitter")]() {
    let left2 = this.state.leftSize;
    if (!this.state.showLeftPanel) {
      left2 = 0;
    }
    return {
      style: {
        left: Length.px(left2)
      }
    };
  }
  [BIND("$leftPanel")]() {
    let width2 = this.state.leftSize;
    if (!this.state.showLeftPanel) {
      width2 = 0;
    }
    return {
      style: { width: width2 }
    };
  }
  [BIND("$rightPanel")]() {
    let width2 = this.state.rightSize;
    if (!this.state.showRightPanel) {
      width2 = 0;
    }
    return {
      class: classnames("layout-right", { closed: !this.state.showRightPanel }),
      style: { width: width2 }
    };
  }
  setOptions(obj2 = {}) {
    this.setState(obj2);
  }
  [POINTERSTART("$splitter") + MOVE("moveSplitter") + END("moveEndSplitter")]() {
    this.leftSize = this.state.leftSize;
    this.refs.$splitter.addClass("selected");
  }
  moveSplitter(dx) {
    this.setState({
      leftSize: Math.max(Math.min(this.leftSize + dx, this.state.maxSize), this.state.minSize)
    });
  }
  moveEndSplitter() {
    this.refs.$splitter.removeClass("selected");
  }
}
var PopupManager$1 = "";
var NotificationView$1 = "";
class NotificationView extends EditorElement {
  template() {
    return `
            <div class='elf--notification-view'>
            </div>
        `;
  }
  [TRANSITIONEND("$el")](e) {
    Dom.create(e.target).remove();
  }
  [CLICK("$el .item > .icon")](e) {
    e.$dt.parent().remove();
  }
  getMessageTemplate(type, title2, description, duration = 1e3) {
    return `
        <div class='item ${type}' style='transition-duration: ${duration}ms;'>
            <div class='title'>${title2}</div> 
            <div class='description'>${description}</div>
            <span class='icon'>${iconUse("close")}</span>
        </div>
    `;
  }
  [SUBSCRIBE(SHOW_NOTIFY)](type, title2, description, duration = 1e3) {
    const $dom = Dom.createByHTML(this.getMessageTemplate(type, title2, description, 1e3));
    this.$el.prepend($dom);
    window.setTimeout(($dom2) => {
      $dom2.css("opacity", 0);
    }, duration, $dom);
  }
}
var BaseWindow$1 = "";
class BaseWindow extends EditorElement {
  template() {
    return `
      <div class='elf--window-background'>
        <div class='window ${this.getClassName()}'>
            <div class='window-title' ref="$title">
                <label>${this.getTitle()}</label>
                <span class="tools">
                  ${this.getTools()}
                  <button type='button' class='close' ref='$close'>${iconUse("close")}</button>
                </span>
            </div>
            <div class='window-body'>${this.getBody()}</div>
        </div>
      </div>
        `;
  }
  getClassName() {
    return "";
  }
  getTitle() {
    return "";
  }
  getTools() {
    return "";
  }
  getBody() {
    return "";
  }
  [CLICK("$close")]() {
    this.$el.hide();
  }
  show() {
    this.$el.show("block");
  }
  hide() {
    this.$el.hide();
  }
}
var ExportWindow$1 = "";
class EmbedEditorWindow extends BaseWindow {
  getClassName() {
    return "elf--export-window";
  }
  getTitle() {
    return "Mini Editor";
  }
  initState() {
    return {
      selectedIndex: 1
    };
  }
  refresh() {
    if (this.$el.isShow()) {
      createDesignEditor({
        container: this.refs.$body.el,
        config: {
          "editor.design.mode": "item"
        }
      });
    }
  }
  getBody() {
    return `
        <div class="test" ref="$body">

      </div>
        `;
  }
  [SUBSCRIBE("showEmbedEditorWindow")]() {
    this.show();
    this.refresh();
  }
}
registElement({ EmbedEditorWindow });
class ExportWindow extends BaseWindow {
  getClassName() {
    return "elf--export-window";
  }
  getTitle() {
    return "Export";
  }
  initState() {
    return {
      selectedIndex: 1
    };
  }
  getBody() {
    return `
        <div class="tab" ref="$tab">
            <div class="tab-header full" ref="$header">
                <div class="tab-item selected" data-value="1">
                    <label>HTML</label>
                </div>
                <div class="tab-item" data-value="2">
                    <label>CSS</label>
                </div>                
                <div class="tab-item" data-value="6">
                    <label>SVG Image</label>
                </div>     
            </div>
            <div class="tab-body" ref="$body">
                <div class="tab-content selected" data-value="1" ref="$html">
                </div>
                <div class='tab-content' data-value='2' ref="$css">
                </div>                        
                <div class="tab-content" data-value="6" ref="$svgimage">
                </div>                                                                       
            </div>
      </div>
        `;
  }
  [SUBSCRIBE("showExportWindow")]() {
    this.show();
    this.refresh();
  }
  refresh() {
    var project2 = this.$context.selection.currentProject || { layers: [] };
    var css = `
${this.makeStyle(project2)}
${project2.layers.map((item) => this.makeStyle(item)).join("\n")}
`;
    var html = `
${this.$editor.renderer("html").renderSVG(project2)}
${this.$editor.renderer("html").render(project2)}
        `;
    var svgData = project2.layers.map((item) => {
      return this.$editor.svg.render(item);
    });
    if (shiki) {
      shiki.getHighlighter({
        theme: "light-plus"
      }).then((highlighter) => {
        if (html_beautify) {
          html = html_beautify(html, { indent: 2 });
          const changedHtml = highlighter.codeToHtml(html, "html");
          this.refs.$html.html(changedHtml);
          css = html_beautify(css, { indent: 2 });
          const changedCss = highlighter.codeToHtml(css, "html");
          this.refs.$css.html(changedCss);
          svgData = html_beautify(svgData.join(""), { indent: 2 });
          const changedSvgData = highlighter.codeToHtml(svgData, "html");
          this.refs.$svgimage.html(changedSvgData);
        }
      });
    }
  }
  makeStyle(item) {
    return this.$editor.renderer("html").toExportStyle(item, null);
  }
  makeHTML(item) {
    return this.$editor.renderer("html").render(item);
  }
  [CLICK("$header .tab-item")](e) {
    var selectedIndex = +e.$dt.attr("data-value");
    if (this.state.selectedIndex === selectedIndex) {
      return;
    }
    this.$el.$$(`[data-value="${this.state.selectedIndex}"]`).forEach((it) => it.removeClass("selected"));
    this.$el.$$(`[data-value="${selectedIndex}"]`).forEach((it) => it.addClass("selected"));
    this.setState({ selectedIndex }, false);
  }
}
registElement({ ExportWindow });
var ProjectWindow$1 = "";
class ProjectWindow extends BaseWindow {
  getClassName() {
    return "elf--project-window";
  }
  getTitle() {
    return "Project Manager";
  }
  initState() {
    return {
      selectedIndex: 1
    };
  }
  getBody() {
    return `
        <div class="project-container">
            <div class="project-menu left">
                Project Menu
            </div>
            <div class="project-list right">
                Project List
            </div>
        </div>
        `;
  }
  [SUBSCRIBE("open.projects")]() {
    this.show();
    this.refresh();
  }
  refresh() {
  }
}
registElement({ ProjectWindow });
var ShortcutWindow$1 = "";
const categories = /* @__PURE__ */ new Set();
shortcuts.forEach((it) => {
  categories.add(it.category);
});
const keys = {};
categories.forEach((it) => {
  shortcuts.filter((item) => item.category === it).forEach((item) => {
    if (!keys[item.category]) {
      keys[item.category] = [];
    }
    keys[item.category].push(item);
  });
});
const keyAlias = {
  ARROWRIGHT: "\u2192",
  ARROWLEFT: "\u2190",
  ARROWUP: "\u2191",
  ARROWDOWN: "\u2192",
  BACKSPACE: "\u232B",
  CMD: "\u2318"
};
const OSName = os();
class ShortcutWindow extends BaseWindow {
  getClassName() {
    return "elf--shortcut-window";
  }
  getTitle() {
    return "ShortCuts";
  }
  getKeyString(os2, item) {
    return (item[os2] || item.key).split("+").map((it) => it.trim()).map((it) => {
      const keyString = it.toUpperCase();
      return `<span>${keyAlias[keyString] || keyString}</span>`;
    }).join(" + ");
  }
  getTemplateForShortcutItem(item) {
    return `
            <div class='shortcut-view-item'>
                <div class='title'>${item.description}</div>
                <div class='os-item'>${this.getKeyString(OSName, item)}</div>
            </div>                        
        `;
  }
  getTemplateForCategory(category, list2 = []) {
    return `
            <div class='item'>
                <h2>${category}</h2>
                <div>
                    ${list2.map((it) => this.getTemplateForShortcutItem(it)).join("")}
                </div>
            </div>
        `;
  }
  getTemplateForLayer() {
    return `
            <div class='item'>
                <h2>Layer</h2>
                <div>
                    <div class='shortcut-view-item'>
                        <div class='title'>
                            Add Rect
                            <span class='description'>fdsafdsfdf</span>
                        </div>

                        <div class='os-item mac'><span>CTRL</span>+<span>R</span></div>
                        <div class='os-item win'>R</div>
                        <div class='os-item linux'>R</div>
                    </div>
                </div>
            </div>
        `;
  }
  getBody() {
    return `
        <div class="list">
            ${Object.keys(keys).map((category) => {
      return this.getTemplateForCategory(category, keys[category]);
    }).join("")}
        </div>
        `;
  }
  [SUBSCRIBE("showShortcutWindow")]() {
    this.show();
  }
}
registElement({ ShortcutWindow });
class PopupManager extends EditorElement {
  components() {
    return {
      NotificationView
    };
  }
  template() {
    return /* @__PURE__ */ createElementJsx("div", {
      class: "elf--popup-manager"
    }, createComponent("ExportWindow"), createComponent("EmbedEditorWindow"), createComponent("ProjectWindow"), createComponent("ShortcutWindow"), createComponent("NotificationView"), this.$injectManager.generate("popup", true));
  }
}
class BlankEditor extends BaseLayout {
  afterRender() {
    super.afterRender();
    this.$config.init("editor.layout.elements", this.refs);
  }
  getPlugins() {
    return blankEditorPlugins;
  }
  initState() {
    return {
      leftSize: 340
    };
  }
  getTopPanel() {
    return /* @__PURE__ */ createElementJsx(DefaultLayoutItem, {
      type: "top"
    }, /* @__PURE__ */ createElementJsx(BlankToolBar, null));
  }
  getLeftPanel() {
    return /* @__PURE__ */ createElementJsx(DefaultLayoutItem, {
      type: "left",
      resizable: true
    }, /* @__PURE__ */ createElementJsx(BlankLayerTab, null));
  }
  getRightPanel() {
    return /* @__PURE__ */ createElementJsx(DefaultLayoutItem, {
      type: "right"
    }, /* @__PURE__ */ createElementJsx(BlankInspector, null));
  }
  getBodyPanel() {
    return /* @__PURE__ */ createElementJsx(DefaultLayoutItem, {
      type: "body"
    }, /* @__PURE__ */ createElementJsx(BlankBodyPanel, null));
  }
  getInnerPanel() {
    return /* @__PURE__ */ createElementJsx(DefaultLayoutItem, {
      type: "inner"
    }, /* @__PURE__ */ createElementJsx(KeyboardManager, null));
  }
  getOuterPanel() {
    return /* @__PURE__ */ createElementJsx(DefaultLayoutItem, {
      type: "outer"
    }, /* @__PURE__ */ createElementJsx(IconManager$1, null), /* @__PURE__ */ createElementJsx(PopupManager, null), /* @__PURE__ */ createElementJsx(ContextMenuManager, null));
  }
  template() {
    return /* @__PURE__ */ createElementJsx("div", {
      class: "elf-editor"
    }, /* @__PURE__ */ createElementJsx(DefaultLayout, {
      showLeftPanel: this.$config.get("show.left.panel"),
      showRightPanel: this.$config.get("show.right.panel"),
      leftSize: 340,
      rightSize: 280,
      ref: "$layout"
    }, this.getTopPanel(), this.getLeftPanel(), this.getRightPanel(), this.getBodyPanel(), this.getInnerPanel(), this.getOuterPanel()));
  }
  [CONFIG("show.left.panel")]() {
    this.children.$layout.setOptions({
      showLeftPanel: this.$config.get("show.left.panel")
    });
  }
  [CONFIG("show.right.panel")]() {
    this.children.$layout.setOptions({
      showRightPanel: this.$config.get("show.right.panel")
    });
  }
  refresh() {
    super.refresh();
    this.emit("resizeEditor");
  }
  [SUBSCRIBE(TOGGLE_FULLSCREEN)]() {
    this.$el.toggleFullscreen();
  }
}
var layout$1 = "";
class ClipboardManager {
  constructor(editor) {
    this.editor = editor;
    this.clipboard = [];
  }
  get length() {
    return this.clipboard.length;
  }
  clear() {
    this.clipboard = [];
  }
  get isEmpty() {
    return this.clipboard.length == 0;
  }
  get last() {
    return this.clipboard[this.clipboard.length - 1];
  }
  push(data) {
    this.clipboard.push(data);
  }
  pop() {
    return this.clipboard.pop();
  }
}
class HistoryManager {
  constructor(editor) {
    this.$editor = editor;
    this.$context = editor.context;
    this.currentIndex = -1;
    this.undoHistories = [];
    this.redoHistories = [];
    this.selection = {};
  }
  get length() {
    return this.undoHistories.length;
  }
  get selectedIds() {
    return Object.keys(this.selection);
  }
  createCommand(commandString) {
    return this.$context.stateManager.isPointerUp ? `history.${commandString}` : commandString;
  }
  saveSelection(obj2 = {}) {
    this.selection = this.$editor.context.selection.toCloneObject();
  }
  getUndoValues(multiAttrs = {}) {
    let result = {};
    Object.keys(multiAttrs).forEach((id) => {
      result[id] = {};
      const selectedObject = this.selection[id] || this.$editor.context.selection.itemsByIds(id)[0];
      const attrs = multiAttrs[id];
      Object.keys(attrs).forEach((key) => {
        result[id][key] = selectedObject[key];
      });
    });
    return result;
  }
  add(message, command, data) {
    const time = window.performance.now();
    const lastUndoObject = this.undoHistories[this.undoHistories.length - 1];
    const historyObject = { message, command, data, time };
    if (lastUndoObject && lastUndoObject.message === message && time - lastUndoObject.time < this.$editor.context.config.get("history.delay.ms")) {
      this.undoHistories[this.undoHistories.length - 1] = historyObject;
    } else {
      this.undoHistories.push(historyObject);
      this.currentIndex++;
      this.undoHistories.length = this.currentIndex + 1;
    }
    this.$context.commands.emit("refreshHistory", command.command);
    this.$editor.emit("refreshHistoryList");
    return historyObject;
  }
  map(callback) {
    let results = [
      ...this.undoHistories.map(callback),
      "-",
      ...this.redoHistories.map(callback)
    ].reverse();
    return results;
  }
  undo() {
    if (this.currentIndex < -1)
      return;
    if (this.currentIndex === this.length) {
      this.currentIndex--;
    }
    const commandObject = this.undoHistories[this.currentIndex];
    if (commandObject && commandObject.command) {
      commandObject.command.undo(this.$editor, commandObject.data);
      this.currentIndex--;
      this.$editor.nextTick(() => {
        this.$context.commands.emit("refreshHistory", commandObject.command);
        this.$editor.emit("refreshHistoryList");
      });
    }
  }
  redo() {
    if (this.currentIndex > this.length)
      return;
    if (this.currentIndex < 0) {
      this.currentIndex++;
    }
    const commandObject = this.undoHistories[this.currentIndex];
    if (commandObject && commandObject.command) {
      this.currentIndex++;
      commandObject.command.redo(this.$editor, commandObject.data);
      this.$editor.debug(commandObject);
      this.$editor.nextTick(() => {
        this.$context.commands.emit("refreshHistory", commandObject.command);
        this.$editor.emit("refreshHistoryList");
      });
    }
  }
}
class LockManager {
  constructor(editor) {
    this.editor = editor;
    this.lockList = {};
  }
  get(key) {
    return this.lockList[key];
  }
  set(key, value) {
    this.lockList[key] = true;
  }
  toggle(key) {
    if (this.lockList[key]) {
      delete this.lockList[key];
    } else {
      this.lockList[key] = true;
    }
  }
}
const identity$1 = () => true;
class ModelManager {
  constructor(editor) {
    this.editor = editor;
    this.context = this.editor.context;
    this.version = "0.0.0";
    this.name = "";
    this.description = "";
    this.items = /* @__PURE__ */ new Map();
    this.projects = [];
  }
  load(doc2 = void 0, context = { origin: "*" }) {
    var _a;
    const newDoc = doc2 || this.editor.loadItem("model");
    this.items.clear();
    this.version = newDoc == null ? void 0 : newDoc.version;
    this.name = newDoc == null ? void 0 : newDoc.name;
    this.description = newDoc == null ? void 0 : newDoc.description;
    (_a = newDoc == null ? void 0 : newDoc.projects) == null ? void 0 : _a.forEach((project2) => {
      this.createModel(project2);
    });
    if (this.projects.length === 0) {
      this.createProject();
    }
  }
  createProject() {
    this.createModel({
      itemType: "project",
      name: "New Project"
    });
  }
  getProjectByIndex(index2 = 0) {
    return this.get(this.projects[index2]);
  }
  get(id) {
    return this.items.get(id);
  }
  set(id, item) {
    this.items.set(id, item);
    this.setChanged("set", id, item);
  }
  remove(id) {
    const obj2 = this.items.get(id);
    const children2 = obj2.parent.children;
    const index2 = children2.indexOf(id);
    obj2.reset({
      removed: true,
      removedIndex: index2,
      removedLeftSibling: index2 > 0 ? children2[index2 - 1] : null,
      removedRightSibling: index2 < children2.length - 1 ? children2[index2 + 1] : null
    });
    this.setChanged("remove", id);
  }
  recover(id) {
    const obj2 = this.items.get(id);
    const parent = this.getParent(id);
    if (!obj2.get("removedLeftSibling") && obj2.get("removedRightSibling")) {
      parent.children.splice(parent.children.findIndex(() => obj2.get("removedRightSibling")) - 1, 0, id);
    } else if (obj2.get("removedLeftSibling") && !obj2.get("removedRightSibling")) {
      parent.children.splice(parent.children.findIndex(() => obj2.get("removedLeftSibling")) + 1, 0, id);
    } else {
      parent.children.splice(obj2.get("removedIndex"), 0, id);
    }
    obj2.removeField("removed");
    obj2.removeField("removedLeftSibling");
    obj2.removeField("removedRightSibling");
    obj2.removeField("removedIndex");
    this.setChanged("recover", id);
  }
  clear() {
    this.items.clear();
  }
  toJSON() {
    return {
      version: this.version,
      name: this.name,
      description: this.description,
      projects: this.projects.map((id) => {
        return this.get(id).toJSON();
      })
    };
  }
  setChanged(type, id, obj2) {
    this.editor.emit("changed", type, id, obj2);
  }
  removeChild(rootId, childId) {
    const obj2 = this.get(rootId);
    obj2.reset({
      children: obj2.children.filter((it) => it !== childId)
    });
    this.setChanged("removeChild", rootId, { childId });
  }
  get components() {
    return this.context.components;
  }
  searchItem(id) {
    return this.get(id);
  }
  searchLayers(rootId, childId) {
    const obj2 = this.get(rootId);
    return this.get(obj2.children.find((it) => it === childId));
  }
  searchItemsById(ids) {
    return ids.map((id) => this.get(id));
  }
  findGroupItem(rootId) {
    const obj2 = this.get(rootId);
    if (obj2.hasChildren()) {
      return obj2;
    }
    if (obj2.parent && (obj2.parent.is("project") || obj2.parent.is("artboard") || obj2.isBooleanItem)) {
      return obj2;
    }
    return obj2.parent && this.findGroupItem(obj2.parentId);
  }
  convertGroupItems(items) {
    const objectList = {};
    items.forEach((item) => {
      if (item.parent && item.isNot("project") && item.parent.hasLayout()) {
        const groupItem = item.parent;
        objectList[groupItem.id] = groupItem;
      } else {
        const groupItem = this.findGroupItem(item.id) || item;
        objectList[groupItem.id] = groupItem;
      }
    });
    return Object.values(objectList).filter((it) => it.isNot("project"));
  }
  searchLiveItemsById(ids) {
    return ids.map((id) => this.get(id)).filter((it) => !it.removed);
  }
  markRemove(ids = []) {
    ids.forEach((id) => {
      this.remove(id);
    });
    this.setChanged("markRemove", ids, { isLayer: true });
  }
  markRemoveProject(id) {
    const index2 = this.projects.findIndex((it) => it === id);
    this.projects.splice(index2, 1);
    this.get(id).removed = true;
    this.setChanged("markRemoveProject", [id], { isProject: true });
    return index2;
  }
  unmarkRemove(ids = []) {
    ids.forEach((id) => {
      this.recover(id);
    });
    this.setChanged("unmarkRemove", ids, { isLayer: true });
  }
  unmarkRemoveProject(id, index2) {
    this.projects.splice(index2, 0, id);
    this.get(id).removed = false;
    this.setChanged("unmarkRemoveProject", [id], {
      removed: true,
      isProject: true
    });
  }
  createModel(itemObject, isRegister = true, context = { origin: "*" }) {
    const layers2 = itemObject.layers;
    delete itemObject.layers;
    let item;
    if (this.get(itemObject.id)) {
      item = this.get(itemObject.id);
      item.reset(itemObject);
    } else {
      item = this.components.createComponent(itemObject.itemType, __spreadValues({}, itemObject));
      item.setModelManager(this);
    }
    if (isRegister) {
      this.set(item.id, item);
      if (item.is("project")) {
        this.projects = [.../* @__PURE__ */ new Set([...this.projects, item.id])];
      }
    }
    const children2 = (layers2 || []).map((it) => {
      return this.createModel(__spreadProps(__spreadValues({}, it), { parentId: item.id }), true, context);
    });
    if (children2.length) {
      item.reset({
        children: children2.map((it) => {
          return it.id;
        })
      }, context);
    }
    return item;
  }
  getAllLayers(rootId, filterCallback = identity$1) {
    var results = [];
    const obj2 = this.get(rootId);
    let len2 = obj2.children.length;
    for (let start2 = len2; start2--; ) {
      let id = obj2.children[start2];
      results.push(...this.getAllLayers(id, filterCallback));
    }
    if (isFunction(filterCallback) && filterCallback(obj2)) {
      results.push(obj2);
    }
    return results;
  }
  getLayers(rootId) {
    var _a;
    const obj2 = this.get(rootId);
    return ((_a = obj2 == null ? void 0 : obj2.children) == null ? void 0 : _a.map((childId) => this.get(childId))) || [];
  }
  eachLayers(rootId, callback) {
    const obj2 = this.get(rootId);
    let len2 = obj2.children.length;
    for (let start2 = len2; start2--; ) {
      let id = obj2.children[start2];
      callback(this.get(id));
    }
  }
  mapLayers(rootId, callback) {
    const obj2 = this.get(rootId);
    return obj2.children.map((childId) => {
      return callback(this.get(childId));
    });
  }
  getParent(rootId) {
    var _a;
    return this.get((_a = this.get(rootId)) == null ? void 0 : _a.parentId);
  }
  getDepth(rootId) {
    const parent = this.getParent(rootId);
    if (!parent)
      return 1;
    return this.getDepth(parent.id) + 1;
  }
  getPath(rootId, defaultRef = null) {
    const obj2 = this.get(rootId) || defaultRef;
    const parent = this.getParent(rootId);
    if (!parent)
      return [obj2];
    const list2 = this.getPath(parent.id);
    list2.push(obj2);
    return list2;
  }
  clone(rootId, isDeep = true) {
    const obj2 = this.get(rootId);
    const json = obj2.toCloneObject(isDeep);
    const item = this.createModel(json);
    item.setParentId(obj2.parentId);
    return item;
  }
}
var pathkit = { exports: {} };
var __viteBrowserExternal = {};
var __viteBrowserExternal$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": __viteBrowserExternal
}, Symbol.toStringTag, { value: "Module" }));
var require$$0 = /* @__PURE__ */ getAugmentedNamespace(__viteBrowserExternal$1);
(function(module, exports) {
  var PathKitInit2 = function() {
    var _scriptDir = typeof document !== "undefined" && document.currentScript ? document.currentScript.src : void 0;
    if (typeof __filename !== "undefined")
      _scriptDir = _scriptDir || __filename;
    return function(PathKitInit3) {
      PathKitInit3 = PathKitInit3 || {};
      var d;
      d || (d = typeof PathKitInit3 !== "undefined" ? PathKitInit3 : {});
      var aa;
      d.ready = new Promise(function(a) {
        aa = a;
      });
      (function(a) {
        var b = {};
        a.loadCmdsTypedArray = function(h) {
          for (var k = 0, l = 0; l < h.length; l++)
            k += h[l].length;
          if (b[k])
            var n = b[k];
          else
            n = new Float32Array(k), b[k] = n;
          var p = 0;
          for (l = 0; l < h.length; l++)
            for (var q = 0; q < h[l].length; q++) {
              var t = h[l][q];
              typeof t === "string" && (t = a.SkBits2FloatUnsigned(parseInt(t)));
              n[p] = t;
              p++;
            }
          h = a._malloc(n.length * n.BYTES_PER_ELEMENT);
          a.HEAPF32.set(n, h / n.BYTES_PER_ELEMENT);
          return [h, k];
        };
        a.FromCmds = function(h) {
          h = a.loadCmdsTypedArray(h);
          var k = a._FromCmds(h[0], h[1]);
          a._free(h[0]);
          return k;
        };
        var c2, e, f, g, m;
        a.cubicYFromX = function(h, k, l, n, p) {
          c2 && e === h && f === k && g === l && m === n || (c2 && c2.delete(), c2 = new a._SkCubicMap([h, k], [l, n]), e = h, f = k, g = l, m = n);
          return c2.computeYFromX(p);
        };
        a.cubicPtFromT = function(h, k, l, n, p) {
          c2 && e === h && f === k && g === l && m === n || (c2 && c2.delete(), c2 = new a._SkCubicMap([h, k], [l, n]), e = h, f = k, g = l, m = n);
          return c2.computePtFromT(p);
        };
      })(d);
      (function(a) {
        a.onRuntimeInitialized = function() {
          a.SkPath.prototype.addPath = function() {
            var b = arguments[0];
            if (arguments.length === 1)
              this._addPath(b, 1, 0, 0, 0, 1, 0, 0, 0, 1);
            else if (arguments.length === 2) {
              var c2 = arguments[1];
              this._addPath(b, c2.a, c2.c, c2.e, c2.b, c2.d, c2.f, 0, 0, 1);
            } else if (arguments.length === 7)
              c2 = arguments, this._addPath(b, c2[1], c2[3], c2[5], c2[2], c2[4], c2[6], 0, 0, 1);
            else if (arguments.length === 10)
              c2 = arguments, this._addPath(b, c2[1], c2[2], c2[3], c2[4], c2[5], c2[6], c2[7], c2[8], c2[9]);
            else
              return console.Fb("addPath expected to take 1, 2, 7, or 10 args. Got " + arguments.length), null;
            return this;
          };
          a.SkPath.prototype.arc = function(b, c2, e, f, g, m) {
            this._arc(b, c2, e, f, g, !!m);
            return this;
          };
          a.SkPath.prototype.arcTo = function(b, c2, e, f, g) {
            this._arcTo(b, c2, e, f, g);
            return this;
          };
          a.SkPath.prototype.bezierCurveTo = function(b, c2, e, f, g, m) {
            this._cubicTo(b, c2, e, f, g, m);
            return this;
          };
          a.SkPath.prototype.close = function() {
            this._close();
            return this;
          };
          a.SkPath.prototype.closePath = function() {
            this._close();
            return this;
          };
          a.SkPath.prototype.conicTo = function(b, c2, e, f, g) {
            this._conicTo(b, c2, e, f, g);
            return this;
          };
          a.SkPath.prototype.cubicTo = function(b, c2, e, f, g, m) {
            this._cubicTo(b, c2, e, f, g, m);
            return this;
          };
          a.SkPath.prototype.dash = function(b, c2, e) {
            return this._dash(b, c2, e) ? this : null;
          };
          a.SkPath.prototype.ellipse = function(b, c2, e, f, g, m, h, k) {
            this._ellipse(b, c2, e, f, g, m, h, !!k);
            return this;
          };
          a.SkPath.prototype.lineTo = function(b, c2) {
            this._lineTo(b, c2);
            return this;
          };
          a.SkPath.prototype.moveTo = function(b, c2) {
            this._moveTo(b, c2);
            return this;
          };
          a.SkPath.prototype.op = function(b, c2) {
            return this._op(b, c2) ? this : null;
          };
          a.SkPath.prototype.quadraticCurveTo = function(b, c2, e, f) {
            this._quadTo(b, c2, e, f);
            return this;
          };
          a.SkPath.prototype.quadTo = function(b, c2, e, f) {
            this._quadTo(b, c2, e, f);
            return this;
          };
          a.SkPath.prototype.rect = function(b, c2, e, f) {
            this._rect(b, c2, e, f);
            return this;
          };
          a.SkPath.prototype.simplify = function() {
            return this._simplify() ? this : null;
          };
          a.SkPath.prototype.stroke = function(b) {
            b = b || {};
            b.width = b.width || 1;
            b.miter_limit = b.miter_limit || 4;
            b.cap = b.cap || a.StrokeCap.BUTT;
            b.join = b.join || a.StrokeJoin.MITER;
            return this._stroke(b) ? this : null;
          };
          a.SkPath.prototype.transform = function() {
            if (arguments.length === 1)
              this._transform(arguments[0]);
            else if (arguments.length === 9) {
              var b = arguments;
              this._transform(b[0], b[1], b[2], b[3], b[4], b[5], b[6], b[7], b[8]);
            } else
              return console.Fb("transform expected to take 1 or 9 arguments. Got " + arguments.length), null;
            return this;
          };
          a.SkPath.prototype.trim = function(b, c2, e) {
            return this._trim(b, c2, !!e) ? this : null;
          };
        };
      })(d);
      var r = {}, v;
      for (v in d)
        d.hasOwnProperty(v) && (r[v] = d[v]);
      var ba = false, w = false, ca = false, da = false;
      ba = typeof window === "object";
      w = typeof importScripts === "function";
      ca = typeof process === "object" && typeof process.versions === "object" && typeof process.versions.node === "string";
      da = !ba && !ca && !w;
      var x = "", ea, fa, ha, ia;
      if (ca)
        x = w ? require$$0.dirname(x) + "/" : __dirname + "/", ea = function(a, b) {
          ha || (ha = require$$0);
          ia || (ia = require$$0);
          a = ia.normalize(a);
          return ha.readFileSync(a, b ? null : "utf8");
        }, fa = function(a) {
          a = ea(a, true);
          a.buffer || (a = new Uint8Array(a));
          assert(a.buffer);
          return a;
        }, 1 < process.argv.length && process.argv[1].replace(/\\/g, "/"), process.argv.slice(2), process.on("uncaughtException", function(a) {
          throw a;
        }), process.on("unhandledRejection", y), d.inspect = function() {
          return "[Emscripten Module object]";
        };
      else if (da)
        typeof read != "undefined" && (ea = function(a) {
          return read(a);
        }), fa = function(a) {
          if (typeof readbuffer === "function")
            return new Uint8Array(readbuffer(a));
          a = read(a, "binary");
          assert(typeof a === "object");
          return a;
        }, typeof print !== "undefined" && (typeof console === "undefined" && (console = {}), console.log = print, console.warn = console.error = typeof printErr !== "undefined" ? printErr : print);
      else if (ba || w)
        w ? x = self.location.href : document.currentScript && (x = document.currentScript.src), _scriptDir && (x = _scriptDir), x.indexOf("blob:") !== 0 ? x = x.substr(0, x.lastIndexOf("/") + 1) : x = "", ea = function(a) {
          var b = new XMLHttpRequest();
          b.open("GET", a, false);
          b.send(null);
          return b.responseText;
        }, w && (fa = function(a) {
          var b = new XMLHttpRequest();
          b.open("GET", a, false);
          b.responseType = "arraybuffer";
          b.send(null);
          return new Uint8Array(b.response);
        });
      var ja = d.print || console.log.bind(console), z = d.printErr || console.warn.bind(console);
      for (v in r)
        r.hasOwnProperty(v) && (d[v] = r[v]);
      r = null;
      var ka;
      d.wasmBinary && (ka = d.wasmBinary);
      d.noExitRuntime && d.noExitRuntime;
      typeof WebAssembly !== "object" && z("no native wasm support detected");
      var la, ma = new WebAssembly.Table({ initial: 309, maximum: 309, element: "anyfunc" }), na = false;
      function assert(a, b) {
        a || y("Assertion failed: " + b);
      }
      var oa = typeof TextDecoder !== "undefined" ? new TextDecoder("utf8") : void 0;
      function pa(a, b, c2) {
        var e = b + c2;
        for (c2 = b; a[c2] && !(c2 >= e); )
          ++c2;
        if (16 < c2 - b && a.subarray && oa)
          return oa.decode(a.subarray(b, c2));
        for (e = ""; b < c2; ) {
          var f = a[b++];
          if (f & 128) {
            var g = a[b++] & 63;
            if ((f & 224) == 192)
              e += String.fromCharCode((f & 31) << 6 | g);
            else {
              var m = a[b++] & 63;
              f = (f & 240) == 224 ? (f & 15) << 12 | g << 6 | m : (f & 7) << 18 | g << 12 | m << 6 | a[b++] & 63;
              65536 > f ? e += String.fromCharCode(f) : (f -= 65536, e += String.fromCharCode(55296 | f >> 10, 56320 | f & 1023));
            }
          } else
            e += String.fromCharCode(f);
        }
        return e;
      }
      function qa(a, b, c2) {
        var e = B;
        if (0 < c2) {
          c2 = b + c2 - 1;
          for (var f = 0; f < a.length; ++f) {
            var g = a.charCodeAt(f);
            if (55296 <= g && 57343 >= g) {
              var m = a.charCodeAt(++f);
              g = 65536 + ((g & 1023) << 10) | m & 1023;
            }
            if (127 >= g) {
              if (b >= c2)
                break;
              e[b++] = g;
            } else {
              if (2047 >= g) {
                if (b + 1 >= c2)
                  break;
                e[b++] = 192 | g >> 6;
              } else {
                if (65535 >= g) {
                  if (b + 2 >= c2)
                    break;
                  e[b++] = 224 | g >> 12;
                } else {
                  if (b + 3 >= c2)
                    break;
                  e[b++] = 240 | g >> 18;
                  e[b++] = 128 | g >> 12 & 63;
                }
                e[b++] = 128 | g >> 6 & 63;
              }
              e[b++] = 128 | g & 63;
            }
          }
          e[b] = 0;
        }
      }
      var ra = typeof TextDecoder !== "undefined" ? new TextDecoder("utf-16le") : void 0;
      function sa(a, b) {
        var c2 = a >> 1;
        for (var e = c2 + b / 2; !(c2 >= e) && ta[c2]; )
          ++c2;
        c2 <<= 1;
        if (32 < c2 - a && ra)
          return ra.decode(B.subarray(a, c2));
        c2 = 0;
        for (e = ""; ; ) {
          var f = D[a + 2 * c2 >> 1];
          if (f == 0 || c2 == b / 2)
            return e;
          ++c2;
          e += String.fromCharCode(f);
        }
      }
      function ua(a, b, c2) {
        c2 === void 0 && (c2 = 2147483647);
        if (2 > c2)
          return 0;
        c2 -= 2;
        var e = b;
        c2 = c2 < 2 * a.length ? c2 / 2 : a.length;
        for (var f = 0; f < c2; ++f)
          D[b >> 1] = a.charCodeAt(f), b += 2;
        D[b >> 1] = 0;
        return b - e;
      }
      function va(a) {
        return 2 * a.length;
      }
      function wa(a, b) {
        for (var c2 = 0, e = ""; !(c2 >= b / 4); ) {
          var f = E[a + 4 * c2 >> 2];
          if (f == 0)
            break;
          ++c2;
          65536 <= f ? (f -= 65536, e += String.fromCharCode(55296 | f >> 10, 56320 | f & 1023)) : e += String.fromCharCode(f);
        }
        return e;
      }
      function xa(a, b, c2) {
        c2 === void 0 && (c2 = 2147483647);
        if (4 > c2)
          return 0;
        var e = b;
        c2 = e + c2 - 4;
        for (var f = 0; f < a.length; ++f) {
          var g = a.charCodeAt(f);
          if (55296 <= g && 57343 >= g) {
            var m = a.charCodeAt(++f);
            g = 65536 + ((g & 1023) << 10) | m & 1023;
          }
          E[b >> 2] = g;
          b += 4;
          if (b + 4 > c2)
            break;
        }
        E[b >> 2] = 0;
        return b - e;
      }
      function ya(a) {
        for (var b = 0, c2 = 0; c2 < a.length; ++c2) {
          var e = a.charCodeAt(c2);
          55296 <= e && 57343 >= e && ++c2;
          b += 4;
        }
        return b;
      }
      var za, Aa, B, D, ta, E, F, Ba, Ca, Da = d.INITIAL_MEMORY || 16777216;
      d.wasmMemory ? la = d.wasmMemory : la = new WebAssembly.Memory({ initial: Da / 65536, maximum: Da / 65536 });
      la && (za = la.buffer);
      Da = za.byteLength;
      var G = za;
      za = G;
      d.HEAP8 = Aa = new Int8Array(G);
      d.HEAP16 = D = new Int16Array(G);
      d.HEAP32 = E = new Int32Array(G);
      d.HEAPU8 = B = new Uint8Array(G);
      d.HEAPU16 = ta = new Uint16Array(G);
      d.HEAPU32 = F = new Uint32Array(G);
      d.HEAPF32 = Ba = new Float32Array(G);
      d.HEAPF64 = Ca = new Float64Array(G);
      E[3e3] = 5255040;
      function Ea(a) {
        for (; 0 < a.length; ) {
          var b = a.shift();
          if (typeof b == "function")
            b(d);
          else {
            var c2 = b.Jb;
            typeof c2 === "number" ? b.tb === void 0 ? d.dynCall_v(c2) : d.dynCall_vi(c2, b.tb) : c2(b.tb === void 0 ? null : b.tb);
          }
        }
      }
      var Fa = [], Ga = [], Ha = [], Ia = [];
      function Ja() {
        var a = d.preRun.shift();
        Fa.unshift(a);
      }
      var H = 0, La = null;
      d.preloadedImages = {};
      d.preloadedAudios = {};
      function y(a) {
        if (d.onAbort)
          d.onAbort(a);
        ja(a);
        z(a);
        na = true;
        throw new WebAssembly.RuntimeError("abort(" + a + "). Build with -s ASSERTIONS=1 for more info.");
      }
      function Ma(a) {
        var b = I;
        return String.prototype.startsWith ? b.startsWith(a) : b.indexOf(a) === 0;
      }
      function Na() {
        return Ma("data:application/octet-stream;base64,");
      }
      var I = "pathkit.wasm";
      if (!Na()) {
        var Oa = I;
        I = d.locateFile ? d.locateFile(Oa, x) : x + Oa;
      }
      function Pa() {
        try {
          if (ka)
            return new Uint8Array(ka);
          if (fa)
            return fa(I);
          throw "both async and sync fetching of the wasm failed";
        } catch (a) {
          y(a);
        }
      }
      function Qa() {
        return ka || !ba && !w || typeof fetch !== "function" || Ma("file://") ? new Promise(function(a) {
          a(Pa());
        }) : fetch(I, { credentials: "same-origin" }).then(function(a) {
          if (!a.ok)
            throw "failed to load wasm binary file at '" + I + "'";
          return a.arrayBuffer();
        }).catch(function() {
          return Pa();
        });
      }
      Ga.push({ Jb: function() {
        Ra();
      } });
      var Sa = {};
      function Ta(a) {
        for (; a.length; ) {
          var b = a.pop();
          a.pop()(b);
        }
      }
      function J(a) {
        return this.fromWireType(F[a >> 2]);
      }
      var K = {}, L = {}, Ua = {};
      function Va(a) {
        if (a === void 0)
          return "_unknown";
        a = a.replace(/[^a-zA-Z0-9_]/g, "$");
        var b = a.charCodeAt(0);
        return 48 <= b && 57 >= b ? "_" + a : a;
      }
      function Wa(a, b) {
        a = Va(a);
        return new Function("body", "return function " + a + '() {\n    "use strict";    return body.apply(this, arguments);\n};\n')(b);
      }
      function Xa(a) {
        var b = Error, c2 = Wa(a, function(e) {
          this.name = a;
          this.message = e;
          e = Error(e).stack;
          e !== void 0 && (this.stack = this.toString() + "\n" + e.replace(/^Error(:[^\n]*)?\n/, ""));
        });
        c2.prototype = Object.create(b.prototype);
        c2.prototype.constructor = c2;
        c2.prototype.toString = function() {
          return this.message === void 0 ? this.name : this.name + ": " + this.message;
        };
        return c2;
      }
      var Ya = void 0;
      function Za(a) {
        throw new Ya(a);
      }
      function N(a, b, c2) {
        function e(h) {
          h = c2(h);
          h.length !== a.length && Za("Mismatched type converter count");
          for (var k = 0; k < a.length; ++k)
            O(a[k], h[k]);
        }
        a.forEach(function(h) {
          Ua[h] = b;
        });
        var f = Array(b.length), g = [], m = 0;
        b.forEach(function(h, k) {
          L.hasOwnProperty(h) ? f[k] = L[h] : (g.push(h), K.hasOwnProperty(h) || (K[h] = []), K[h].push(function() {
            f[k] = L[h];
            ++m;
            m === g.length && e(f);
          }));
        });
        g.length === 0 && e(f);
      }
      var $a = {};
      function ab(a) {
        switch (a) {
          case 1:
            return 0;
          case 2:
            return 1;
          case 4:
            return 2;
          case 8:
            return 3;
          default:
            throw new TypeError("Unknown type size: " + a);
        }
      }
      var bb = void 0;
      function P(a) {
        for (var b = ""; B[a]; )
          b += bb[B[a++]];
        return b;
      }
      var Q = void 0;
      function R(a) {
        throw new Q(a);
      }
      function O(a, b, c2) {
        c2 = c2 || {};
        if (!("argPackAdvance" in b))
          throw new TypeError("registerType registeredInstance requires argPackAdvance");
        var e = b.name;
        a || R('type "' + e + '" must have a positive integer typeid pointer');
        if (L.hasOwnProperty(a)) {
          if (c2.Mb)
            return;
          R("Cannot register type '" + e + "' twice");
        }
        L[a] = b;
        delete Ua[a];
        K.hasOwnProperty(a) && (b = K[a], delete K[a], b.forEach(function(f) {
          f();
        }));
      }
      function cb(a) {
        return { count: a.count, lb: a.lb, nb: a.nb, bb: a.bb, cb: a.cb, gb: a.gb, ib: a.ib };
      }
      function db(a) {
        R(a.$a.cb.ab.name + " instance already deleted");
      }
      var eb = false;
      function fb() {
      }
      function gb(a) {
        --a.count.value;
        a.count.value === 0 && (a.gb ? a.ib.hb(a.gb) : a.cb.ab.hb(a.bb));
      }
      function hb(a) {
        if (typeof FinalizationGroup === "undefined")
          return hb = function(b) {
            return b;
          }, a;
        eb = new FinalizationGroup(function(b) {
          for (var c2 = b.next(); !c2.done; c2 = b.next())
            c2 = c2.value, c2.bb ? gb(c2) : console.warn("object already deleted: " + c2.bb);
        });
        hb = function(b) {
          eb.register(b, b.$a, b.$a);
          return b;
        };
        fb = function(b) {
          eb.unregister(b.$a);
        };
        return hb(a);
      }
      var ib = void 0, jb = [];
      function kb() {
        for (; jb.length; ) {
          var a = jb.pop();
          a.$a.lb = false;
          a["delete"]();
        }
      }
      function S() {
      }
      var lb = {};
      function mb(a, b, c2) {
        if (a[b].eb === void 0) {
          var e = a[b];
          a[b] = function() {
            a[b].eb.hasOwnProperty(arguments.length) || R("Function '" + c2 + "' called with an invalid number of arguments (" + arguments.length + ") - expects one of (" + a[b].eb + ")!");
            return a[b].eb[arguments.length].apply(this, arguments);
          };
          a[b].eb = [];
          a[b].eb[e.qb] = e;
        }
      }
      function nb(a, b, c2) {
        d.hasOwnProperty(a) ? ((c2 === void 0 || d[a].eb !== void 0 && d[a].eb[c2] !== void 0) && R("Cannot register public name '" + a + "' twice"), mb(d, a, a), d.hasOwnProperty(c2) && R("Cannot register multiple overloads of a function with the same number of arguments (" + c2 + ")!"), d[a].eb[c2] = b) : (d[a] = b, c2 !== void 0 && (d[a].Sb = c2));
      }
      function ob(a, b, c2, e, f, g, m, h) {
        this.name = a;
        this.constructor = b;
        this.mb = c2;
        this.hb = e;
        this.jb = f;
        this.Kb = g;
        this.pb = m;
        this.Hb = h;
        this.Pb = [];
      }
      function pb(a, b, c2) {
        for (; b !== c2; )
          b.pb || R("Expected null or instance of " + c2.name + ", got an instance of " + b.name), a = b.pb(a), b = b.jb;
        return a;
      }
      function qb(a, b) {
        if (b === null)
          return this.xb && R("null is not a valid " + this.name), 0;
        b.$a || R('Cannot pass "' + U(b) + '" as a ' + this.name);
        b.$a.bb || R("Cannot pass deleted object as a pointer of type " + this.name);
        return pb(b.$a.bb, b.$a.cb.ab, this.ab);
      }
      function rb(a, b) {
        if (b === null) {
          this.xb && R("null is not a valid " + this.name);
          if (this.sb) {
            var c2 = this.ob();
            a !== null && a.push(this.hb, c2);
            return c2;
          }
          return 0;
        }
        b.$a || R('Cannot pass "' + U(b) + '" as a ' + this.name);
        b.$a.bb || R("Cannot pass deleted object as a pointer of type " + this.name);
        !this.rb && b.$a.cb.rb && R("Cannot convert argument of type " + (b.$a.ib ? b.$a.ib.name : b.$a.cb.name) + " to parameter type " + this.name);
        c2 = pb(b.$a.bb, b.$a.cb.ab, this.ab);
        if (this.sb)
          switch (b.$a.gb === void 0 && R("Passing raw pointer to smart pointer is illegal"), this.Rb) {
            case 0:
              b.$a.ib === this ? c2 = b.$a.gb : R("Cannot convert argument of type " + (b.$a.ib ? b.$a.ib.name : b.$a.cb.name) + " to parameter type " + this.name);
              break;
            case 1:
              c2 = b.$a.gb;
              break;
            case 2:
              if (b.$a.ib === this)
                c2 = b.$a.gb;
              else {
                var e = b.clone();
                c2 = this.Qb(c2, V(function() {
                  e["delete"]();
                }));
                a !== null && a.push(this.hb, c2);
              }
              break;
            default:
              R("Unsupporting sharing policy");
          }
        return c2;
      }
      function sb(a, b) {
        if (b === null)
          return this.xb && R("null is not a valid " + this.name), 0;
        b.$a || R('Cannot pass "' + U(b) + '" as a ' + this.name);
        b.$a.bb || R("Cannot pass deleted object as a pointer of type " + this.name);
        b.$a.cb.rb && R("Cannot convert argument of type " + b.$a.cb.name + " to parameter type " + this.name);
        return pb(b.$a.bb, b.$a.cb.ab, this.ab);
      }
      function tb(a, b, c2) {
        if (b === c2)
          return a;
        if (c2.jb === void 0)
          return null;
        a = tb(a, b, c2.jb);
        return a === null ? null : c2.Hb(a);
      }
      var ub = {};
      function vb(a, b) {
        for (b === void 0 && R("ptr should not be undefined"); a.jb; )
          b = a.pb(b), a = a.jb;
        return ub[b];
      }
      function wb(a, b) {
        b.cb && b.bb || Za("makeClassHandle requires ptr and ptrType");
        !!b.ib !== !!b.gb && Za("Both smartPtrType and smartPtr must be specified");
        b.count = { value: 1 };
        return hb(Object.create(a, { $a: { value: b } }));
      }
      function W(a, b, c2, e) {
        this.name = a;
        this.ab = b;
        this.xb = c2;
        this.rb = e;
        this.sb = false;
        this.hb = this.Qb = this.ob = this.Eb = this.Rb = this.Ob = void 0;
        b.jb !== void 0 ? this.toWireType = rb : (this.toWireType = e ? qb : sb, this.fb = null);
      }
      function xb(a, b, c2) {
        d.hasOwnProperty(a) || Za("Replacing nonexistant public symbol");
        d[a].eb !== void 0 && c2 !== void 0 ? d[a].eb[c2] = b : (d[a] = b, d[a].qb = c2);
      }
      function X(a, b) {
        a = P(a);
        var c2 = d["dynCall_" + a];
        for (var e = [], f = 1; f < a.length; ++f)
          e.push("a" + f);
        f = "return function dynCall_" + (a + "_" + b) + "(" + e.join(", ") + ") {\n";
        f += "    return dynCall(rawFunction" + (e.length ? ", " : "") + e.join(", ") + ");\n";
        c2 = new Function("dynCall", "rawFunction", f + "};\n")(c2, b);
        typeof c2 !== "function" && R("unknown function pointer with signature " + a + ": " + b);
        return c2;
      }
      var yb = void 0;
      function zb(a) {
        a = Ab(a);
        var b = P(a);
        Y(a);
        return b;
      }
      function Db(a, b) {
        function c2(g) {
          f[g] || L[g] || (Ua[g] ? Ua[g].forEach(c2) : (e.push(g), f[g] = true));
        }
        var e = [], f = {};
        b.forEach(c2);
        throw new yb(a + ": " + e.map(zb).join([", "]));
      }
      function Eb(a, b) {
        for (var c2 = [], e = 0; e < a; e++)
          c2.push(E[(b >> 2) + e]);
        return c2;
      }
      function Fb(a) {
        var b = Function;
        if (!(b instanceof Function))
          throw new TypeError("new_ called with constructor type " + typeof b + " which is not a function");
        var c2 = Wa(b.name || "unknownFunctionName", function() {
        });
        c2.prototype = b.prototype;
        c2 = new c2();
        a = b.apply(c2, a);
        return a instanceof Object ? a : c2;
      }
      function Gb(a, b, c2, e, f) {
        var g = b.length;
        2 > g && R("argTypes array size mismatch! Must at least get return value and 'this' types!");
        var m = b[1] !== null && c2 !== null, h = false;
        for (c2 = 1; c2 < b.length; ++c2)
          if (b[c2] !== null && b[c2].fb === void 0) {
            h = true;
            break;
          }
        var k = b[0].name !== "void", l = "", n = "";
        for (c2 = 0; c2 < g - 2; ++c2)
          l += (c2 !== 0 ? ", " : "") + "arg" + c2, n += (c2 !== 0 ? ", " : "") + "arg" + c2 + "Wired";
        a = "return function " + Va(a) + "(" + l + ") {\nif (arguments.length !== " + (g - 2) + ") {\nthrowBindingError('function " + a + " called with ' + arguments.length + ' arguments, expected " + (g - 2) + " args!');\n}\n";
        h && (a += "var destructors = [];\n");
        var p = h ? "destructors" : "null";
        l = "throwBindingError invoker fn runDestructors retType classParam".split(" ");
        e = [R, e, f, Ta, b[0], b[1]];
        m && (a += "var thisWired = classParam.toWireType(" + p + ", this);\n");
        for (c2 = 0; c2 < g - 2; ++c2)
          a += "var arg" + c2 + "Wired = argType" + c2 + ".toWireType(" + p + ", arg" + c2 + "); // " + b[c2 + 2].name + "\n", l.push("argType" + c2), e.push(b[c2 + 2]);
        m && (n = "thisWired" + (0 < n.length ? ", " : "") + n);
        a += (k ? "var rv = " : "") + "invoker(fn" + (0 < n.length ? ", " : "") + n + ");\n";
        if (h)
          a += "runDestructors(destructors);\n";
        else
          for (c2 = m ? 1 : 2; c2 < b.length; ++c2)
            g = c2 === 1 ? "thisWired" : "arg" + (c2 - 2) + "Wired", b[c2].fb !== null && (a += g + "_dtor(" + g + "); // " + b[c2].name + "\n", l.push(g + "_dtor"), e.push(b[c2].fb));
        k && (a += "var ret = retType.fromWireType(rv);\nreturn ret;\n");
        l.push(a + "}\n");
        return Fb(l).apply(null, e);
      }
      var Hb = [], Z = [{}, { value: void 0 }, { value: null }, { value: true }, { value: false }];
      function Ib(a) {
        4 < a && --Z[a].yb === 0 && (Z[a] = void 0, Hb.push(a));
      }
      function V(a) {
        switch (a) {
          case void 0:
            return 1;
          case null:
            return 2;
          case true:
            return 3;
          case false:
            return 4;
          default:
            var b = Hb.length ? Hb.pop() : Z.length;
            Z[b] = { yb: 1, value: a };
            return b;
        }
      }
      function Jb(a, b, c2) {
        switch (b) {
          case 0:
            return function(e) {
              return this.fromWireType((c2 ? Aa : B)[e]);
            };
          case 1:
            return function(e) {
              return this.fromWireType((c2 ? D : ta)[e >> 1]);
            };
          case 2:
            return function(e) {
              return this.fromWireType((c2 ? E : F)[e >> 2]);
            };
          default:
            throw new TypeError("Unknown integer type: " + a);
        }
      }
      function Kb(a, b) {
        var c2 = L[a];
        c2 === void 0 && R(b + " has unknown type " + zb(a));
        return c2;
      }
      function U(a) {
        if (a === null)
          return "null";
        var b = typeof a;
        return b === "object" || b === "array" || b === "function" ? a.toString() : "" + a;
      }
      function Lb(a, b) {
        switch (b) {
          case 2:
            return function(c2) {
              return this.fromWireType(Ba[c2 >> 2]);
            };
          case 3:
            return function(c2) {
              return this.fromWireType(Ca[c2 >> 3]);
            };
          default:
            throw new TypeError("Unknown float type: " + a);
        }
      }
      function Mb(a, b, c2) {
        switch (b) {
          case 0:
            return c2 ? function(e) {
              return Aa[e];
            } : function(e) {
              return B[e];
            };
          case 1:
            return c2 ? function(e) {
              return D[e >> 1];
            } : function(e) {
              return ta[e >> 1];
            };
          case 2:
            return c2 ? function(e) {
              return E[e >> 2];
            } : function(e) {
              return F[e >> 2];
            };
          default:
            throw new TypeError("Unknown integer type: " + a);
        }
      }
      var Nb = {};
      function Ob(a) {
        var b = Nb[a];
        return b === void 0 ? P(a) : b;
      }
      var Pb = [];
      function Qb(a) {
        a || R("Cannot use deleted val. handle = " + a);
        return Z[a].value;
      }
      function Rb() {
        return typeof globalThis === "object" ? globalThis : Function("return this")();
      }
      function Sb(a) {
        var b = Pb.length;
        Pb.push(a);
        return b;
      }
      function Tb(a, b) {
        for (var c2 = Array(a), e = 0; e < a; ++e)
          c2[e] = Kb(E[(b >> 2) + e], "parameter " + e);
        return c2;
      }
      var Ub = {}, Vb = [null, [], []];
      Ya = d.InternalError = Xa("InternalError");
      for (var Wb = Array(256), Xb = 0; 256 > Xb; ++Xb)
        Wb[Xb] = String.fromCharCode(Xb);
      bb = Wb;
      Q = d.BindingError = Xa("BindingError");
      S.prototype.isAliasOf = function(a) {
        if (!(this instanceof S && a instanceof S))
          return false;
        var b = this.$a.cb.ab, c2 = this.$a.bb, e = a.$a.cb.ab;
        for (a = a.$a.bb; b.jb; )
          c2 = b.pb(c2), b = b.jb;
        for (; e.jb; )
          a = e.pb(a), e = e.jb;
        return b === e && c2 === a;
      };
      S.prototype.clone = function() {
        this.$a.bb || db(this);
        if (this.$a.nb)
          return this.$a.count.value += 1, this;
        var a = hb(Object.create(Object.getPrototypeOf(this), { $a: { value: cb(this.$a) } }));
        a.$a.count.value += 1;
        a.$a.lb = false;
        return a;
      };
      S.prototype["delete"] = function() {
        this.$a.bb || db(this);
        this.$a.lb && !this.$a.nb && R("Object already scheduled for deletion");
        fb(this);
        gb(this.$a);
        this.$a.nb || (this.$a.gb = void 0, this.$a.bb = void 0);
      };
      S.prototype.isDeleted = function() {
        return !this.$a.bb;
      };
      S.prototype.deleteLater = function() {
        this.$a.bb || db(this);
        this.$a.lb && !this.$a.nb && R("Object already scheduled for deletion");
        jb.push(this);
        jb.length === 1 && ib && ib(kb);
        this.$a.lb = true;
        return this;
      };
      W.prototype.Lb = function(a) {
        this.Eb && (a = this.Eb(a));
        return a;
      };
      W.prototype.Cb = function(a) {
        this.hb && this.hb(a);
      };
      W.prototype.argPackAdvance = 8;
      W.prototype.readValueFromPointer = J;
      W.prototype.deleteObject = function(a) {
        if (a !== null)
          a["delete"]();
      };
      W.prototype.fromWireType = function(a) {
        function b() {
          return this.sb ? wb(this.ab.mb, { cb: this.Ob, bb: c2, ib: this, gb: a }) : wb(this.ab.mb, { cb: this, bb: a });
        }
        var c2 = this.Lb(a);
        if (!c2)
          return this.Cb(a), null;
        var e = vb(this.ab, c2);
        if (e !== void 0) {
          if (e.$a.count.value === 0)
            return e.$a.bb = c2, e.$a.gb = a, e.clone();
          e = e.clone();
          this.Cb(a);
          return e;
        }
        e = this.ab.Kb(c2);
        e = lb[e];
        if (!e)
          return b.call(this);
        e = this.rb ? e.Gb : e.pointerType;
        var f = tb(c2, this.ab, e.ab);
        return f === null ? b.call(this) : this.sb ? wb(e.ab.mb, { cb: e, bb: f, ib: this, gb: a }) : wb(e.ab.mb, { cb: e, bb: f });
      };
      d.getInheritedInstanceCount = function() {
        return Object.keys(ub).length;
      };
      d.getLiveInheritedInstances = function() {
        var a = [], b;
        for (b in ub)
          ub.hasOwnProperty(b) && a.push(ub[b]);
        return a;
      };
      d.flushPendingDeletes = kb;
      d.setDelayFunction = function(a) {
        ib = a;
        jb.length && ib && ib(kb);
      };
      yb = d.UnboundTypeError = Xa("UnboundTypeError");
      d.count_emval_handles = function() {
        for (var a = 0, b = 5; b < Z.length; ++b)
          Z[b] !== void 0 && ++a;
        return a;
      };
      d.get_first_emval = function() {
        for (var a = 5; a < Z.length; ++a)
          if (Z[a] !== void 0)
            return Z[a];
        return null;
      };
      var Zb = {
        s: function(a) {
          var b = Sa[a];
          delete Sa[a];
          var c2 = b.elements, e = c2.length, f = c2.map(function(h) {
            return h.wb;
          }).concat(c2.map(function(h) {
            return h.Ab;
          })), g = b.ob, m = b.hb;
          N([a], f, function(h) {
            c2.forEach(function(k, l) {
              var n = h[l], p = k.ub, q = k.vb, t = h[l + e], u = k.zb, M = k.Bb;
              k.read = function(A) {
                return n.fromWireType(p(q, A));
              };
              k.write = function(A, T) {
                var C = [];
                u(M, A, t.toWireType(C, T));
                Ta(C);
              };
            });
            return [{ name: b.name, fromWireType: function(k) {
              for (var l = Array(e), n = 0; n < e; ++n)
                l[n] = c2[n].read(k);
              m(k);
              return l;
            }, toWireType: function(k, l) {
              if (e !== l.length)
                throw new TypeError("Incorrect number of tuple elements for " + b.name + ": expected=" + e + ", actual=" + l.length);
              for (var n = g(), p = 0; p < e; ++p)
                c2[p].write(n, l[p]);
              k !== null && k.push(m, n);
              return n;
            }, argPackAdvance: 8, readValueFromPointer: J, fb: m }];
          });
        },
        v: function(a) {
          var b = $a[a];
          delete $a[a];
          var c2 = b.ob, e = b.hb, f = b.Db, g = f.map(function(m) {
            return m.wb;
          }).concat(f.map(function(m) {
            return m.Ab;
          }));
          N([a], g, function(m) {
            var h = {};
            f.forEach(function(k, l) {
              var n = m[l], p = k.ub, q = k.vb, t = m[l + f.length], u = k.zb, M = k.Bb;
              h[k.Ib] = { read: function(A) {
                return n.fromWireType(p(q, A));
              }, write: function(A, T) {
                var C = [];
                u(M, A, t.toWireType(C, T));
                Ta(C);
              } };
            });
            return [{ name: b.name, fromWireType: function(k) {
              var l = {}, n;
              for (n in h)
                l[n] = h[n].read(k);
              e(k);
              return l;
            }, toWireType: function(k, l) {
              for (var n in h)
                if (!(n in l))
                  throw new TypeError("Missing field");
              var p = c2();
              for (n in h)
                h[n].write(p, l[n]);
              k !== null && k.push(e, p);
              return p;
            }, argPackAdvance: 8, readValueFromPointer: J, fb: e }];
          });
        },
        G: function(a, b, c2, e, f) {
          var g = ab(c2);
          b = P(b);
          O(a, {
            name: b,
            fromWireType: function(m) {
              return !!m;
            },
            toWireType: function(m, h) {
              return h ? e : f;
            },
            argPackAdvance: 8,
            readValueFromPointer: function(m) {
              if (c2 === 1)
                var h = Aa;
              else if (c2 === 2)
                h = D;
              else if (c2 === 4)
                h = E;
              else
                throw new TypeError("Unknown boolean type size: " + b);
              return this.fromWireType(h[m >> g]);
            },
            fb: null
          });
        },
        k: function(a, b, c2, e, f, g, m, h, k, l, n, p, q) {
          n = P(n);
          g = X(f, g);
          h && (h = X(m, h));
          l && (l = X(k, l));
          q = X(p, q);
          var t = Va(n);
          nb(t, function() {
            Db("Cannot construct " + n + " due to unbound types", [e]);
          });
          N([a, b, c2], e ? [e] : [], function(u) {
            u = u[0];
            if (e) {
              var M = u.ab;
              var A = M.mb;
            } else
              A = S.prototype;
            u = Wa(t, function() {
              if (Object.getPrototypeOf(this) !== T)
                throw new Q("Use 'new' to construct " + n);
              if (C.kb === void 0)
                throw new Q(n + " has no accessible constructor");
              var Bb = C.kb[arguments.length];
              if (Bb === void 0)
                throw new Q("Tried to invoke ctor of " + n + " with invalid number of parameters (" + arguments.length + ") - expected (" + Object.keys(C.kb).toString() + ") parameters instead!");
              return Bb.apply(this, arguments);
            });
            var T = Object.create(A, { constructor: { value: u } });
            u.prototype = T;
            var C = new ob(n, u, T, q, M, g, h, l);
            M = new W(n, C, true, false);
            A = new W(n + "*", C, false, false);
            var Cb = new W(n + " const*", C, false, true);
            lb[a] = { pointerType: A, Gb: Cb };
            xb(t, u);
            return [M, A, Cb];
          });
        },
        h: function(a, b, c2, e, f, g) {
          assert(0 < b);
          var m = Eb(b, c2);
          f = X(e, f);
          var h = [g], k = [];
          N([], [a], function(l) {
            l = l[0];
            var n = "constructor " + l.name;
            l.ab.kb === void 0 && (l.ab.kb = []);
            if (l.ab.kb[b - 1] !== void 0)
              throw new Q("Cannot register multiple constructors with identical number of parameters (" + (b - 1) + ") for class '" + l.name + "'! Overload resolution is currently only performed using the parameter count, not actual type info!");
            l.ab.kb[b - 1] = function() {
              Db("Cannot construct " + l.name + " due to unbound types", m);
            };
            N([], m, function(p) {
              l.ab.kb[b - 1] = function() {
                arguments.length !== b - 1 && R(n + " called with " + arguments.length + " arguments, expected " + (b - 1));
                k.length = 0;
                h.length = b;
                for (var q = 1; q < b; ++q)
                  h[q] = p[q].toWireType(k, arguments[q - 1]);
                q = f.apply(null, h);
                Ta(k);
                return p[0].fromWireType(q);
              };
              return [];
            });
            return [];
          });
        },
        a: function(a, b, c2, e, f, g, m, h) {
          var k = Eb(c2, e);
          b = P(b);
          g = X(f, g);
          N([], [a], function(l) {
            function n() {
              Db("Cannot call " + p + " due to unbound types", k);
            }
            l = l[0];
            var p = l.name + "." + b;
            h && l.ab.Pb.push(b);
            var q = l.ab.mb, t = q[b];
            t === void 0 || t.eb === void 0 && t.className !== l.name && t.qb === c2 - 2 ? (n.qb = c2 - 2, n.className = l.name, q[b] = n) : (mb(q, b, p), q[b].eb[c2 - 2] = n);
            N([], k, function(u) {
              u = Gb(p, u, l, g, m);
              q[b].eb === void 0 ? (u.qb = c2 - 2, q[b] = u) : q[b].eb[c2 - 2] = u;
              return [];
            });
            return [];
          });
        },
        M: function(a, b, c2) {
          a = P(a);
          N([], [b], function(e) {
            e = e[0];
            d[a] = e.fromWireType(c2);
            return [];
          });
        },
        E: function(a, b) {
          b = P(b);
          O(a, { name: b, fromWireType: function(c2) {
            var e = Z[c2].value;
            Ib(c2);
            return e;
          }, toWireType: function(c2, e) {
            return V(e);
          }, argPackAdvance: 8, readValueFromPointer: J, fb: null });
        },
        g: function(a, b, c2, e) {
          function f() {
          }
          c2 = ab(c2);
          b = P(b);
          f.values = {};
          O(a, { name: b, constructor: f, fromWireType: function(g) {
            return this.constructor.values[g];
          }, toWireType: function(g, m) {
            return m.value;
          }, argPackAdvance: 8, readValueFromPointer: Jb(b, c2, e), fb: null });
          nb(b, f);
        },
        j: function(a, b, c2) {
          var e = Kb(a, "enum");
          b = P(b);
          a = e.constructor;
          e = Object.create(e.constructor.prototype, { value: { value: c2 }, constructor: { value: Wa(e.name + "_" + b, function() {
          }) } });
          a.values[c2] = e;
          a[b] = e;
        },
        p: function(a, b, c2) {
          c2 = ab(c2);
          b = P(b);
          O(a, { name: b, fromWireType: function(e) {
            return e;
          }, toWireType: function(e, f) {
            if (typeof f !== "number" && typeof f !== "boolean")
              throw new TypeError('Cannot convert "' + U(f) + '" to ' + this.name);
            return f;
          }, argPackAdvance: 8, readValueFromPointer: Lb(b, c2), fb: null });
        },
        f: function(a, b, c2, e, f, g) {
          var m = Eb(b, c2);
          a = P(a);
          f = X(e, f);
          nb(a, function() {
            Db("Cannot call " + a + " due to unbound types", m);
          }, b - 1);
          N([], m, function(h) {
            h = [h[0], null].concat(h.slice(1));
            xb(a, Gb(a, h, null, f, g), b - 1);
            return [];
          });
        },
        e: function(a, b, c2, e, f) {
          function g(l) {
            return l;
          }
          b = P(b);
          f === -1 && (f = 4294967295);
          var m = ab(c2);
          if (e === 0) {
            var h = 32 - 8 * c2;
            g = function(l) {
              return l << h >>> h;
            };
          }
          var k = b.indexOf("unsigned") != -1;
          O(a, { name: b, fromWireType: g, toWireType: function(l, n) {
            if (typeof n !== "number" && typeof n !== "boolean")
              throw new TypeError('Cannot convert "' + U(n) + '" to ' + this.name);
            if (n < e || n > f)
              throw new TypeError('Passing a number "' + U(n) + '" from JS side to C/C++ side to an argument of type "' + b + '", which is outside the valid range [' + e + ", " + f + "]!");
            return k ? n >>> 0 : n | 0;
          }, argPackAdvance: 8, readValueFromPointer: Mb(b, m, e !== 0), fb: null });
        },
        b: function(a, b, c2) {
          function e(g) {
            g >>= 2;
            return new f(za, F[g + 1], F[g]);
          }
          var f = [Int8Array, Uint8Array, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array][b];
          c2 = P(c2);
          O(a, { name: c2, fromWireType: e, argPackAdvance: 8, readValueFromPointer: e }, { Mb: true });
        },
        q: function(a, b) {
          b = P(b);
          var c2 = b === "std::string";
          O(a, { name: b, fromWireType: function(e) {
            var f = F[e >> 2];
            if (c2)
              for (var g = e + 4, m = 0; m <= f; ++m) {
                var h = e + 4 + m;
                if (B[h] == 0 || m == f) {
                  g = g ? pa(B, g, h - g) : "";
                  if (k === void 0)
                    var k = g;
                  else
                    k += String.fromCharCode(0), k += g;
                  g = h + 1;
                }
              }
            else {
              k = Array(f);
              for (m = 0; m < f; ++m)
                k[m] = String.fromCharCode(B[e + 4 + m]);
              k = k.join("");
            }
            Y(e);
            return k;
          }, toWireType: function(e, f) {
            f instanceof ArrayBuffer && (f = new Uint8Array(f));
            var g = typeof f === "string";
            g || f instanceof Uint8Array || f instanceof Uint8ClampedArray || f instanceof Int8Array || R("Cannot pass non-string to std::string");
            var m = (c2 && g ? function() {
              for (var l = 0, n = 0; n < f.length; ++n) {
                var p = f.charCodeAt(n);
                55296 <= p && 57343 >= p && (p = 65536 + ((p & 1023) << 10) | f.charCodeAt(++n) & 1023);
                127 >= p ? ++l : l = 2047 >= p ? l + 2 : 65535 >= p ? l + 3 : l + 4;
              }
              return l;
            } : function() {
              return f.length;
            })(), h = Yb(4 + m + 1);
            F[h >> 2] = m;
            if (c2 && g)
              qa(f, h + 4, m + 1);
            else if (g)
              for (g = 0; g < m; ++g) {
                var k = f.charCodeAt(g);
                255 < k && (Y(h), R("String has UTF-16 code units that do not fit in 8 bits"));
                B[h + 4 + g] = k;
              }
            else
              for (g = 0; g < m; ++g)
                B[h + 4 + g] = f[g];
            e !== null && e.push(Y, h);
            return h;
          }, argPackAdvance: 8, readValueFromPointer: J, fb: function(e) {
            Y(e);
          } });
        },
        l: function(a, b, c2) {
          c2 = P(c2);
          if (b === 2) {
            var e = sa;
            var f = ua;
            var g = va;
            var m = function() {
              return ta;
            };
            var h = 1;
          } else
            b === 4 && (e = wa, f = xa, g = ya, m = function() {
              return F;
            }, h = 2);
          O(a, { name: c2, fromWireType: function(k) {
            for (var l = F[k >> 2], n = m(), p, q = k + 4, t = 0; t <= l; ++t) {
              var u = k + 4 + t * b;
              if (n[u >> h] == 0 || t == l)
                q = e(q, u - q), p === void 0 ? p = q : (p += String.fromCharCode(0), p += q), q = u + b;
            }
            Y(k);
            return p;
          }, toWireType: function(k, l) {
            typeof l !== "string" && R("Cannot pass non-string to C++ string type " + c2);
            var n = g(l), p = Yb(4 + n + b);
            F[p >> 2] = n >> h;
            f(l, p + 4, n + b);
            k !== null && k.push(Y, p);
            return p;
          }, argPackAdvance: 8, readValueFromPointer: J, fb: function(k) {
            Y(k);
          } });
        },
        u: function(a, b, c2, e, f, g) {
          Sa[a] = { name: P(b), ob: X(c2, e), hb: X(f, g), elements: [] };
        },
        t: function(a, b, c2, e, f, g, m, h, k) {
          Sa[a].elements.push({ wb: b, ub: X(c2, e), vb: f, Ab: g, zb: X(m, h), Bb: k });
        },
        w: function(a, b, c2, e, f, g) {
          $a[a] = { name: P(b), ob: X(c2, e), hb: X(f, g), Db: [] };
        },
        i: function(a, b, c2, e, f, g, m, h, k, l) {
          $a[a].Db.push({ Ib: P(b), wb: c2, ub: X(e, f), vb: g, Ab: m, zb: X(h, k), Bb: l });
        },
        H: function(a, b) {
          b = P(b);
          O(a, { Nb: true, name: b, argPackAdvance: 0, fromWireType: function() {
          }, toWireType: function() {
          } });
        },
        d: function(a, b, c2, e) {
          a = Pb[a];
          b = Qb(b);
          c2 = Ob(c2);
          a(b, c2, null, e);
        },
        N: Ib,
        z: function(a) {
          if (a === 0)
            return V(Rb());
          a = Ob(a);
          return V(Rb()[a]);
        },
        c: function(a, b) {
          b = Tb(a, b);
          for (var c2 = b[0], e = c2.name + "_$" + b.slice(1).map(function(l) {
            return l.name;
          }).join("_") + "$", f = ["retType"], g = [c2], m = "", h = 0; h < a - 1; ++h)
            m += (h !== 0 ? ", " : "") + "arg" + h, f.push("argType" + h), g.push(b[1 + h]);
          e = "return function " + Va("methodCaller_" + e) + "(handle, name, destructors, args) {\n";
          var k = 0;
          for (h = 0; h < a - 1; ++h)
            e += "    var arg" + h + " = argType" + h + ".readValueFromPointer(args" + (k ? "+" + k : "") + ");\n", k += b[h + 1].argPackAdvance;
          e += "    var rv = handle[name](" + m + ");\n";
          for (h = 0; h < a - 1; ++h)
            b[h + 1].deleteObject && (e += "    argType" + h + ".deleteObject(arg" + h + ");\n");
          c2.Nb || (e += "    return retType.toWireType(destructors, rv);\n");
          f.push(e + "};\n");
          a = Fb(f).apply(null, g);
          return Sb(a);
        },
        n: function(a) {
          4 < a && (Z[a].yb += 1);
        },
        x: function(a, b, c2, e) {
          a = Qb(a);
          var f = Ub[b];
          if (!f) {
            f = "";
            for (var g = 0; g < b; ++g)
              f += (g !== 0 ? ", " : "") + "arg" + g;
            var m = "return function emval_allocator_" + b + "(constructor, argTypes, args) {\n";
            for (g = 0; g < b; ++g)
              m += "var argType" + g + " = requireRegisteredType(Module['HEAP32'][(argTypes >>> 2) + " + g + '], "parameter ' + g + '");\nvar arg' + g + " = argType" + g + ".readValueFromPointer(args);\nargs += argType" + g + "['argPackAdvance'];\n";
            f = new Function("requireRegisteredType", "Module", "__emval_register", m + ("var obj = new constructor(" + f + ");\nreturn __emval_register(obj);\n}\n"))(Kb, d, V);
            Ub[b] = f;
          }
          return f(a, c2, e);
        },
        O: function() {
          return V([]);
        },
        F: function(a) {
          return V(Ob(a));
        },
        L: function(a, b) {
          a = Kb(a, "_emval_take_value");
          a = a.readValueFromPointer(b);
          return V(a);
        },
        m: function() {
          y();
        },
        B: function(a, b, c2) {
          B.copyWithin(a, b, b + c2);
        },
        C: function() {
          y("OOM");
        },
        D: function() {
          return 0;
        },
        y: function() {
        },
        o: function(a, b, c2, e) {
          for (var f = 0, g = 0; g < c2; g++) {
            for (var m = E[b + 8 * g >> 2], h = E[b + (8 * g + 4) >> 2], k = 0; k < h; k++) {
              var l = B[m + k], n = Vb[a];
              l === 0 || l === 10 ? ((a === 1 ? ja : z)(pa(n, 0)), n.length = 0) : n.push(l);
            }
            f += h;
          }
          E[e >> 2] = f;
          return 0;
        },
        memory: la,
        K: function() {
        },
        r: function() {
        },
        J: function() {
        },
        I: function() {
        },
        A: function() {
        },
        table: ma
      }, $b = function() {
        function a(f) {
          d.asm = f.exports;
          H--;
          d.monitorRunDependencies && d.monitorRunDependencies(H);
          H == 0 && (La && (f = La, La = null, f()));
        }
        function b(f) {
          a(f.instance);
        }
        function c2(f) {
          return Qa().then(function(g) {
            return WebAssembly.instantiate(g, e);
          }).then(f, function(g) {
            z("failed to asynchronously prepare wasm: " + g);
            y(g);
          });
        }
        var e = { a: Zb };
        H++;
        d.monitorRunDependencies && d.monitorRunDependencies(H);
        if (d.instantiateWasm)
          try {
            return d.instantiateWasm(e, a);
          } catch (f) {
            return z("Module.instantiateWasm callback failed with error: " + f), false;
          }
        (function() {
          if (ka || typeof WebAssembly.instantiateStreaming !== "function" || Na() || Ma("file://") || typeof fetch !== "function")
            return c2(b);
          fetch(I, { credentials: "same-origin" }).then(function(f) {
            return WebAssembly.instantiateStreaming(f, e).then(b, function(g) {
              z("wasm streaming compile failed: " + g);
              z("falling back to ArrayBuffer instantiation");
              c2(b);
            });
          });
        })();
        return {};
      }();
      d.asm = $b;
      var Ra = d.___wasm_call_ctors = function() {
        return (Ra = d.___wasm_call_ctors = d.asm.P).apply(null, arguments);
      };
      d.__Z6ToCmdsRK6SkPath = function() {
        return (d.__Z6ToCmdsRK6SkPath = d.asm.Q).apply(null, arguments);
      };
      d.__Z8FromCmdsmi = function() {
        return (d.__Z8FromCmdsmi = d.asm.R).apply(null, arguments);
      };
      d.__Z7NewPathv = function() {
        return (d.__Z7NewPathv = d.asm.S).apply(null, arguments);
      };
      d.__Z8CopyPathRK6SkPath = function() {
        return (d.__Z8CopyPathRK6SkPath = d.asm.T).apply(null, arguments);
      };
      d.__Z6EqualsRK6SkPathS1_ = function() {
        return (d.__Z6EqualsRK6SkPathS1_ = d.asm.U).apply(null, arguments);
      };
      d.__Z11ToSVGStringRK6SkPath = function() {
        return (d.__Z11ToSVGStringRK6SkPath = d.asm.V).apply(null, arguments);
      };
      d.__Z13FromSVGStringNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEE = function() {
        return (d.__Z13FromSVGStringNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEE = d.asm.W).apply(null, arguments);
      };
      d.__Z13ApplySimplifyR6SkPath = function() {
        return (d.__Z13ApplySimplifyR6SkPath = d.asm.X).apply(null, arguments);
      };
      d.__Z11ApplyPathOpR6SkPathRKS_8SkPathOp = function() {
        return (d.__Z11ApplyPathOpR6SkPathRKS_8SkPathOp = d.asm.Y).apply(null, arguments);
      };
      d.__Z10MakeFromOpRK6SkPathS1_8SkPathOp = function() {
        return (d.__Z10MakeFromOpRK6SkPathS1_8SkPathOp = d.asm.Z).apply(null, arguments);
      };
      d.__Z14ResolveBuilderR11SkOpBuilder = function() {
        return (d.__Z14ResolveBuilderR11SkOpBuilder = d.asm._).apply(null, arguments);
      };
      d.__Z8ToCanvasRK6SkPathN10emscripten3valE = function() {
        return (d.__Z8ToCanvasRK6SkPathN10emscripten3valE = d.asm.$).apply(null, arguments);
      };
      d.__Z8ToPath2DRK6SkPath = function() {
        return (d.__Z8ToPath2DRK6SkPath = d.asm.aa).apply(null, arguments);
      };
      var Y = d._free = function() {
        return (Y = d._free = d.asm.ba).apply(null, arguments);
      }, Yb = d._malloc = function() {
        return (Yb = d._malloc = d.asm.ca).apply(null, arguments);
      }, Ab = d.___getTypeName = function() {
        return (Ab = d.___getTypeName = d.asm.da).apply(null, arguments);
      };
      d.___embind_register_native_and_builtin_types = function() {
        return (d.___embind_register_native_and_builtin_types = d.asm.ea).apply(null, arguments);
      };
      d.dynCall_vi = function() {
        return (d.dynCall_vi = d.asm.fa).apply(null, arguments);
      };
      d.dynCall_iiiii = function() {
        return (d.dynCall_iiiii = d.asm.ga).apply(null, arguments);
      };
      d.dynCall_ii = function() {
        return (d.dynCall_ii = d.asm.ha).apply(null, arguments);
      };
      d.dynCall_i = function() {
        return (d.dynCall_i = d.asm.ia).apply(null, arguments);
      };
      d.dynCall_viifffffffff = function() {
        return (d.dynCall_viifffffffff = d.asm.ja).apply(null, arguments);
      };
      d.dynCall_vifffffi = function() {
        return (d.dynCall_vifffffi = d.asm.ka).apply(null, arguments);
      };
      d.dynCall_vifffff = function() {
        return (d.dynCall_vifffff = d.asm.la).apply(null, arguments);
      };
      d.dynCall_viffffff = function() {
        return (d.dynCall_viffffff = d.asm.ma).apply(null, arguments);
      };
      d.dynCall_vifffffffi = function() {
        return (d.dynCall_vifffffffi = d.asm.na).apply(null, arguments);
      };
      d.dynCall_viff = function() {
        return (d.dynCall_viff = d.asm.oa).apply(null, arguments);
      };
      d.dynCall_viffff = function() {
        return (d.dynCall_viffff = d.asm.pa).apply(null, arguments);
      };
      d.dynCall_vii = function() {
        return (d.dynCall_vii = d.asm.qa).apply(null, arguments);
      };
      d.dynCall_iii = function() {
        return (d.dynCall_iii = d.asm.ra).apply(null, arguments);
      };
      d.dynCall_iifff = function() {
        return (d.dynCall_iifff = d.asm.sa).apply(null, arguments);
      };
      d.dynCall_iiffi = function() {
        return (d.dynCall_iiffi = d.asm.ta).apply(null, arguments);
      };
      d.dynCall_vifffffffff = function() {
        return (d.dynCall_vifffffffff = d.asm.ua).apply(null, arguments);
      };
      d.dynCall_iiii = function() {
        return (d.dynCall_iiii = d.asm.va).apply(null, arguments);
      };
      d.dynCall_viii = function() {
        return (d.dynCall_viii = d.asm.wa).apply(null, arguments);
      };
      d.dynCall_viiii = function() {
        return (d.dynCall_viiii = d.asm.xa).apply(null, arguments);
      };
      d.dynCall_fif = function() {
        return (d.dynCall_fif = d.asm.ya).apply(null, arguments);
      };
      d.dynCall_viif = function() {
        return (d.dynCall_viif = d.asm.za).apply(null, arguments);
      };
      d.dynCall_fi = function() {
        return (d.dynCall_fi = d.asm.Aa).apply(null, arguments);
      };
      d.dynCall_viiifffffffff = function() {
        return (d.dynCall_viiifffffffff = d.asm.Ba).apply(null, arguments);
      };
      d.dynCall_viifffffi = function() {
        return (d.dynCall_viifffffi = d.asm.Ca).apply(null, arguments);
      };
      d.dynCall_viifffff = function() {
        return (d.dynCall_viifffff = d.asm.Da).apply(null, arguments);
      };
      d.dynCall_viiffffff = function() {
        return (d.dynCall_viiffffff = d.asm.Ea).apply(null, arguments);
      };
      d.dynCall_viifffffffi = function() {
        return (d.dynCall_viifffffffi = d.asm.Fa).apply(null, arguments);
      };
      d.dynCall_viiff = function() {
        return (d.dynCall_viiff = d.asm.Ga).apply(null, arguments);
      };
      d.dynCall_viiffff = function() {
        return (d.dynCall_viiffff = d.asm.Ha).apply(null, arguments);
      };
      d.dynCall_iiifff = function() {
        return (d.dynCall_iiifff = d.asm.Ia).apply(null, arguments);
      };
      d.dynCall_iiiffi = function() {
        return (d.dynCall_iiiffi = d.asm.Ja).apply(null, arguments);
      };
      d.dynCall_fii = function() {
        return (d.dynCall_fii = d.asm.Ka).apply(null, arguments);
      };
      d.dynCall_iiffff = function() {
        return (d.dynCall_iiffff = d.asm.La).apply(null, arguments);
      };
      d.dynCall_fiif = function() {
        return (d.dynCall_fiif = d.asm.Ma).apply(null, arguments);
      };
      d.dynCall_iiif = function() {
        return (d.dynCall_iiif = d.asm.Na).apply(null, arguments);
      };
      d.dynCall_vifii = function() {
        return (d.dynCall_vifii = d.asm.Oa).apply(null, arguments);
      };
      d.dynCall_viifd = function() {
        return (d.dynCall_viifd = d.asm.Pa).apply(null, arguments);
      };
      d.dynCall_viid = function() {
        return (d.dynCall_viid = d.asm.Qa).apply(null, arguments);
      };
      d.dynCall_viddi = function() {
        return (d.dynCall_viddi = d.asm.Ra).apply(null, arguments);
      };
      d.dynCall_iidi = function() {
        return (d.dynCall_iidi = d.asm.Sa).apply(null, arguments);
      };
      d.dynCall_viffi = function() {
        return (d.dynCall_viffi = d.asm.Ta).apply(null, arguments);
      };
      d.dynCall_fffff = function() {
        return (d.dynCall_fffff = d.asm.Ua).apply(null, arguments);
      };
      d.dynCall_viiiii = function() {
        return (d.dynCall_viiiii = d.asm.Va).apply(null, arguments);
      };
      d.dynCall_viiiiiffii = function() {
        return (d.dynCall_viiiiiffii = d.asm.Wa).apply(null, arguments);
      };
      d.dynCall_iiiiii = function() {
        return (d.dynCall_iiiiii = d.asm.Xa).apply(null, arguments);
      };
      d.dynCall_iiiiiii = function() {
        return (d.dynCall_iiiiiii = d.asm.Ya).apply(null, arguments);
      };
      d.dynCall_iidiiii = function() {
        return (d.dynCall_iidiiii = d.asm.Za).apply(null, arguments);
      };
      d.dynCall_jiji = function() {
        return (d.dynCall_jiji = d.asm._a).apply(null, arguments);
      };
      d.asm = $b;
      var ac;
      La = function bc() {
        ac || cc();
        ac || (La = bc);
      };
      function cc() {
        function a() {
          if (!ac && (ac = true, d.calledRun = true, !na)) {
            Ea(Ga);
            Ea(Ha);
            aa(d);
            if (d.onRuntimeInitialized)
              d.onRuntimeInitialized();
            if (d.postRun)
              for (typeof d.postRun == "function" && (d.postRun = [d.postRun]); d.postRun.length; ) {
                var b = d.postRun.shift();
                Ia.unshift(b);
              }
            Ea(Ia);
          }
        }
        if (!(0 < H)) {
          if (d.preRun)
            for (typeof d.preRun == "function" && (d.preRun = [d.preRun]); d.preRun.length; )
              Ja();
          Ea(Fa);
          0 < H || (d.setStatus ? (d.setStatus("Running..."), setTimeout(function() {
            setTimeout(function() {
              d.setStatus("");
            }, 1);
            a();
          }, 1)) : a());
        }
      }
      d.run = cc;
      if (d.preInit)
        for (typeof d.preInit == "function" && (d.preInit = [d.preInit]); 0 < d.preInit.length; )
          d.preInit.pop()();
      cc();
      return PathKitInit3.ready;
    };
  }();
  module.exports = PathKitInit2;
})(pathkit);
var PathKitInit = pathkit.exports;
class PathKitManager {
  constructor(editor) {
    this.editor = editor;
    this.pathkit = null;
  }
  async load() {
    this.registerPathKit(await PathKitInit());
  }
  registerPathKit(pathkit2) {
    this.pathkit = pathkit2;
    this.editor.emit("updatePathKit");
  }
  has() {
    return !!this.pathkit;
  }
  booleanOperation(first, second, pathOp) {
    const PathKit = this.pathkit;
    return PathKit.MakeFromOp(PathKit.FromSVGString(first), PathKit.FromSVGString(second), pathOp).toSVGString();
  }
  intersection(first, second) {
    const PathKit = this.pathkit;
    if (!PathKit)
      return;
    return this.reversePathString(this.booleanOperation(first, second, PathKit.PathOp.INTERSECT));
  }
  union(first, second) {
    const PathKit = this.pathkit;
    if (!PathKit)
      return;
    return this.booleanOperation(first, second, PathKit.PathOp.UNION);
  }
  difference(first, second) {
    const PathKit = this.pathkit;
    if (!PathKit)
      return;
    return this.reversePathString(this.booleanOperation(first, second, PathKit.PathOp.DIFFERENCE));
  }
  reverseDifference(first, second) {
    const PathKit = this.pathkit;
    if (!PathKit)
      return;
    return this.reversePathString(this.booleanOperation(first, second, PathKit.PathOp.REVERSE_DIFFERENCE));
  }
  xor(first, second) {
    const PathKit = this.pathkit;
    if (!PathKit)
      return;
    return this.reversePathString(this.booleanOperation(first, second, PathKit.PathOp.XOR));
  }
  reversePathString(pathString2) {
    return PathParser.fromSVGString(pathString2).reversePathStringByFunc((_, index2) => index2 % 2 === 0);
  }
  isValidPath(path) {
    const PathKit = this.pathkit;
    let pathKitPath = PathKit.FromSVGString(path);
    return pathKitPath.isValid();
  }
  simplify(path) {
    const PathKit = this.pathkit;
    const pathObject = PathKit.FromSVGString(path);
    return pathObject.simplify().toSVGString();
  }
  convertLineJoin(lineJoin) {
    const PathKit = this.pathkit;
    switch (lineJoin) {
      case "miter":
        return PathKit.StrokeJoin.MITER;
      case "round":
        return PathKit.StrokeJoin.ROUND;
      case "bevel":
        return PathKit.StrokeJoin.BEVEL;
    }
  }
  convertLineCap(lineCap) {
    const PathKit = this.pathkit;
    switch (lineCap) {
      case "butt":
        return PathKit.StrokeCap.BUTT;
      case "round":
        return PathKit.StrokeCap.ROUND;
      case "square":
        return PathKit.StrokeCap.SQUARE;
    }
  }
  stroke(path, opt = { width: 1, miter_limit: 4 }) {
    const PathKit = this.pathkit;
    const pathObject = PathKit.FromSVGString(path);
    if (isArray(opt["stroke-dasharray"])) {
      const arr = opt["stroke-dasharray"];
      if (arr.length >= 2) {
        pathObject.dash(arr[0], arr[1], +(opt["stroke-dashoffset"] || 0));
      }
    }
    let newPathObject = pathObject.stroke({
      width: +opt["stroke-width"],
      join: this.convertLineJoin(opt["stroke-linejoin"]),
      cap: this.convertLineCap(opt["stroke-linecap"])
    });
    newPathObject.setFillType(PathKit.FillType.WINDING);
    return newPathObject.simplify().toSVGString();
  }
  round(path, opt = { width: 1, miter_limit: 4 }) {
    return this.stroke(path, __spreadProps(__spreadValues({}, opt), {
      "stroke-linejoin": "round"
    }));
  }
  grow(path, opt = { width: 1, miter_limit: 4 }) {
    const PathKit = this.pathkit;
    const pathObject = PathKit.FromSVGString(path);
    return pathObject.copy().stroke(opt).op(pathObject, PathKit.PathOp.DIFFERENCE).toSVGString();
  }
  shrink(path, opt = { width: 1, miter_limit: 4 }) {
    const PathKit = this.pathkit;
    const pathObject = PathKit.FromSVGString(path);
    const simplifyPath = pathObject.copy().simplify();
    return pathObject.copy().stroke(opt).op(simplifyPath, PathKit.PathOp.DIFFERENCE).toSVGString();
  }
  dash(path, on, off, phase = 1) {
    const PathKit = this.pathkit;
    const pathObject = PathKit.FromSVGString(path);
    return pathObject.dash(on, off, phase).toSVGString();
  }
  trim(path, startT, stopT, isComplement = false) {
    const PathKit = this.pathkit;
    const pathObject = PathKit.FromSVGString(path);
    return pathObject.trim(startT, stopT, isComplement).toSVGString();
  }
}
class SegmentSelectionManager {
  constructor(editor) {
    this.$editor = editor;
    this.selectedPointKeys = {};
    this.selectedPointList = [];
  }
  get length() {
    return this.selectedPointList.length;
  }
  initialize() {
    this.selectedPointKeys = {};
    this.selectedPointList = [];
  }
  makeSegmentKey(index2, key) {
    return `${index2}_${key}`;
  }
  select(...list2) {
    this.selectedPointKeys = {};
    this.selectedPointList = list2.map(({ key, index: index2 }) => ({
      key,
      index: +index2 || 0
    }));
    list2.forEach((it) => {
      var key = this.makeSegmentKey(it.index, it.key);
      this.selectedPointKeys[key] = it;
    });
  }
  toggleSegment(index2, key) {
    if (!this.isSelectedSegment(key, index2)) {
      this.select(...this.selectedPointList, { key, index: index2 });
    } else {
      this.select(...this.selectedPointList.filter((it) => {
        return it.key !== key || it.index !== index2;
      }));
    }
  }
  toggleSelect(...list2) {
    list2 = list2.map((it) => {
      return __spreadProps(__spreadValues({}, it), { included: this.isSelectedSegment(it.index, it.key) });
    });
    const includedList = list2.filter((it) => it.included);
    const notIncludedList = list2.filter((it) => !it.included);
    let uniqueList = [...this.selectedPointList];
    if (includedList.length) {
      uniqueList = this.selectedPointList.filter((it) => {
        const oldKey = this.makeSegmentKey(it);
        return Boolean(includedList.find((includeNode) => {
          return oldKey === this.makeSegmentKey(includeNode);
        })) === false;
      });
    }
    this.select(...uniqueList, ...notIncludedList);
  }
  selectKeyIndex(index2, key) {
    if (!this.isSelectedSegment(index2, key)) {
      this.select({ key, index: index2 });
    }
  }
  isSelectedSegment(index2, key) {
    var key = this.makeSegmentKey(index2, key);
    return !!this.selectedPointKeys[key];
  }
}
class SelectionManager {
  constructor(editor) {
    this.$editor = editor;
    this.$context = this.$editor.context;
    this.project = null;
    this.itemKeys = {};
    this.hoverId = "";
    this.hoverItems = [];
    this.ids = [];
    this.colorsteps = [];
    this.ghosts = [];
    this.cachedItemMatrices = [];
    this.cachedArtBoardVerties = [];
    this.cachedVerties = rectToVerties(0, 0, 0, 0, "50% 50% 0px");
    this.gridInformation = {};
    this.dragTargetItem = null;
    this.$editor.on("config:bodyEvent", () => {
      this.refreshMousePosition();
    });
  }
  refreshMousePosition() {
    const areaWidth = this.$context.config.get("area.width");
    const pos = this.$context.viewport.getWorldPosition();
    this.pos = pos;
    const [row, column] = area(pos[0], pos[1], areaWidth);
    this.row = row;
    this.column = column;
  }
  get modelManager() {
    return this.$context.modelManager;
  }
  get lockManager() {
    return this.$context.lockManager;
  }
  get items() {
    return this.modelManager.searchLiveItemsById(this.ids);
  }
  get current() {
    return this.modelManager.searchItem(this.ids[0]);
  }
  get currentProject() {
    if (!this.project) {
      this.project = this.modelManager.getProjectByIndex();
    }
    return this.project;
  }
  get isEmpty() {
    return !this.length;
  }
  get isOne() {
    if (this.length === 1 && this.current.is("artboard"))
      return true;
    return this.length === 1;
  }
  get isMany() {
    return this.length > 1;
  }
  get length() {
    return this.ids.length;
  }
  get isLayoutItem() {
    var _a;
    return (_a = this.current) == null ? void 0 : _a.isLayoutItem();
  }
  get allLayers() {
    return this.currentProject.allLayers || [];
  }
  get filteredLayers() {
    var _a;
    const areaWidth = this.$editor.context.config.get("area.width");
    return ((_a = this.currentProject) == null ? void 0 : _a.filteredAllLayers((item) => {
      if (item.is("project"))
        return false;
      const areaPosition = item.getAreaPosition(areaWidth);
      if (!areaPosition) {
        return false;
      }
      const { column, row } = areaPosition;
      return column[0] <= this.column && this.column <= column[1] && row[0] <= this.row && this.row <= row[1];
    }).filter((item) => {
      return item.isPointInRect(this.pos[0], this.pos[1]);
    })) || [];
  }
  get notSelectedLayers() {
    return this.filteredLayers.filter((it) => this.check(it) === false);
  }
  get selectedArtboards() {
    return [...new Set(this.items.map((it) => it.artboard))];
  }
  hasChangedField(...args2) {
    if (this.current) {
      return this.current.hasChangedField(...args2);
    }
    return false;
  }
  getRootItem(current) {
    var rootItem = current;
    if (current && current.parentId) {
      rootItem = current.parent;
    }
    return rootItem;
  }
  selectColorStep(...args2) {
    this.colorsteps = args2;
  }
  isSelectedColorStep(id) {
    return this.colorsteps.includes(id);
  }
  selectProject(project2) {
    if (isString(project2)) {
      project2 = this.modelManager.get(project2);
    }
    this.project = project2;
    this.select();
  }
  isSameIds(newIds) {
    if (this.ids.length != newIds.length) {
      return false;
    }
    if (this.ids.filter((id) => newIds.includes(id)).length === this.ids.length) {
      return true;
    }
    return false;
  }
  filterIds(ids = []) {
    return ids.map((it) => it.id || it).filter(Boolean);
  }
  selectByGroup(...ids) {
    var list2 = this.modelManager.searchItemsById(this.filterIds(ids || [])).filter((it) => {
      return !this.lockManager.get(it.id);
    });
    const newSelectedItems = this.modelManager.convertGroupItems(list2);
    return this.select(...newSelectedItems);
  }
  select(...ids) {
    var list2 = this.modelManager.searchItemsById(this.filterIds(ids || [])).filter((it) => !it.lock && it.isAbsolute);
    const newSelectedItems = list2.filter((it) => {
      return it.path.filter((element) => list2.includes(element)).length < 2;
    });
    const newSelectedIds = newSelectedItems.map((it) => it.id);
    if (this.isSameIds(newSelectedIds)) {
      return false;
    }
    this.itemKeys = {};
    newSelectedItems.forEach((item) => {
      this.itemKeys[item.id] = item;
    });
    this.ids = newSelectedIds;
    this.setRectCache();
    this.$editor.emit(REFRESH_SELECTION);
    return true;
  }
  reload() {
    return this.select(...this.ids);
  }
  reselect() {
    this.setRectCache();
  }
  check(item) {
    return !!this.itemKeys[item.id];
  }
  hasPathOf(item) {
    return item.hasPathOf(this.items.filter((it) => it.isNot("artboard")));
  }
  hasParent(parentId) {
    return this.items.some((it) => it.hasParent(parentId));
  }
  get(id) {
    return this.itemKeys[id];
  }
  empty() {
    this.select();
  }
  itemsByIds(ids = null) {
    let itemIdList = [];
    if (Array.isArray(ids)) {
      itemIdList = ids;
    } else if (isString(ids) || isObject(ids)) {
      itemIdList = [ids];
    }
    return this.modelManager.searchItemsById(itemIdList);
  }
  selectById(id) {
    this.select(id);
  }
  selectAfterCopy() {
    this.select(...this.items.map((it) => it.copy()));
  }
  addById(id) {
    if (this.itemKeys[id])
      return;
    this.select(...this.ids, id);
  }
  removeById(id) {
    let ids = id;
    if (isString(id)) {
      ids = [id];
    }
    const filteredItems = this.ids.filter((id2) => ids.includes(id2) === false);
    this.select(...filteredItems);
  }
  toggleById(id) {
    if (this.itemKeys[id]) {
      this.removeById(id);
    } else {
      this.addById(id);
    }
  }
  getArtboardByPoint(vec) {
    return this.currentProject.artboards.find((artboard2) => {
      return polyPoint(artboard2.originVerties, ...vec);
    });
  }
  changeInLayoutArea() {
    let checkedParentChange = false;
    this.each((instance) => {
      if (instance.is("artboard") === false) {
        if (instance.artboard) {
          const localArtboardVerties = instance.artboard.originVerties;
          const isInArtboard = polyPoint(localArtboardVerties, this.pos[0], this.pos[1]);
          if (isInArtboard) {
            return false;
          }
        }
        const selectedArtBoard = this.cachedArtBoardVerties.find((artboard2) => {
          return polyPoint(artboard2.matrix.originVerties, this.pos[0], this.pos[1]);
        });
        if (selectedArtBoard) {
          if (selectedArtBoard.item !== instance.artboard && selectedArtBoard.item.hasLayout() === false) {
            selectedArtBoard.item.appendChild(instance);
            checkedParentChange = true;
          }
        } else {
          if (instance.artboard) {
            this.currentProject.appendChild(instance);
            checkedParentChange = true;
          }
        }
      }
    });
    return checkedParentChange;
  }
  setRectCache() {
    if (this.isEmpty) {
      this.cachedVerties = [];
      this.cachedRectVerties = [];
      this.cachedItemMatrices = [];
      this.ghosts = [];
      this.cachedArtBoardVerties = this.currentProject.artboards.map((item) => {
        return { item, matrix: item.matrix };
      });
      return;
    }
    this.cachedVerties = this.verties;
    this.cachedRectVerties = toRectVerties(this.verties);
    this.cachedItemMatrices = [];
    this.cachedChildren = [];
    this.ghosts = [];
    this.items.forEach((it) => {
      if (it.is("artboard")) {
        this.cachedItemMatrices.push(it.matrix);
      } else if (it.hasChildren()) {
        const list2 = this.modelManager.getAllLayers(it.id).map((it2) => it2.matrix);
        this.cachedChildren.push(...list2.map((it2) => it2.id));
        this.cachedItemMatrices.push(...list2);
      } else {
        this.cachedItemMatrices.push(it.matrix);
      }
      this.ghosts.push(it.absoluteMatrix);
    });
    this.cachedArtBoardVerties = this.currentProject.artboards.map((item) => {
      return { item, matrix: item.matrix };
    });
  }
  startToCacheChildren() {
    this.items.forEach((item) => {
      item.startToCacheChildren();
    });
  }
  recoverChildren() {
    this.items.forEach((item) => {
      item.recoverChildren();
    });
  }
  get verties() {
    if (this.isOne) {
      return this.current.verties;
    } else {
      return this.rectVerties;
    }
  }
  get targetVerties() {
    if (this.isOne) {
      return this.current.originVerties;
    } else {
      return targetItemsToRectVerties(this.items);
    }
  }
  get originVerties() {
    return this.rectVerties.filter((_, index2) => index2 < 4);
  }
  get rectVerties() {
    if (this.isEmpty) {
      return [];
    }
    return itemsToRectVerties(this.items);
  }
  get itemRect() {
    const verties = this.verties;
    return {
      x: verties[0][0],
      y: verties[0][1],
      width: distance$1(verties[0], verties[1]),
      height: distance$1(verties[0], verties[3])
    };
  }
  toCloneObject() {
    let data = {};
    this.each((item) => {
      data[item.id] = item.toCloneObject(false);
    });
    return data;
  }
  pack(...keys2) {
    let data = {};
    this.each((item) => {
      data[item.id] = {};
      keys2.forEach((key) => {
        data[item.id][key] = item[key];
      });
    });
    return data;
  }
  packByIds(ids, ...keys2) {
    let data = {};
    let localItems = [];
    if (ids === null) {
      localItems = this.items;
    } else if (isString(ids) || Array.isArray(ids)) {
      localItems = this.itemsByIds(ids);
    }
    const valueObject = {};
    keys2.forEach((it) => {
      valueObject[it] = true;
    });
    localItems.forEach((item) => {
      data[item.id] = item.attrs(...keys2);
    });
    return data;
  }
  packByValue(valueObject, ids = null) {
    let data = {};
    let localItems = [];
    if (ids === null) {
      localItems = this.items;
    } else if (isString(ids) || Array.isArray(ids)) {
      localItems = this.itemsByIds(ids);
    }
    localItems.forEach((item) => {
      data[item.id] = {};
      Object.keys(valueObject).forEach((key) => {
        data[item.id][key] = isFunction(valueObject[key]) ? valueObject[key].call(valueObject, item) : valueObject[key];
      });
    });
    return data;
  }
  each(callback) {
    if (isFunction(callback)) {
      this.items.forEach((item) => {
        callback(item);
      });
    }
  }
  map(callback) {
    if (isFunction(callback)) {
      return this.items.map((item, index2) => {
        return callback(item, index2);
      });
    }
    return this.items;
  }
  reset(obj2) {
    Object.entries(obj2).forEach(([id, attrs]) => {
      var _a;
      (_a = this.get(id)) == null ? void 0 : _a.reset(attrs);
    });
  }
  resetCallback(callback) {
    this.each((item) => item.reset(callback(item)));
  }
  resize() {
    this.each((item) => item.resize());
  }
  remove() {
    this.each((item) => item.remove());
    this.empty();
  }
  copy() {
    console.warn("copy is deprecated");
    this.copyItems = this.items.map((item) => item);
  }
  paste() {
    console.warn("paste is deprecated. use copy and paste");
    this.select(...this.copyItems.map((item) => item.copy(10)));
    this.copy();
  }
  hasPoint(point2) {
    var _a;
    if (this.isMany) {
      return polyPoint(this.originVerties, point2[0], point2[1]);
    } else {
      return (_a = this.current) == null ? void 0 : _a.hasPoint(point2[0], point2[1]);
    }
  }
  hasChildrenPoint(point2) {
    return this.cachedChildren.some((it) => {
      var _a;
      return (_a = this.modelManager.get(it)) == null ? void 0 : _a.hasPoint(point2[0], point2[1]);
    });
  }
  checkChildren(childId) {
    return this.cachedChildren.includes(childId);
  }
  checkHover(itemOrId) {
    if (isString(itemOrId)) {
      return this.hoverId === itemOrId;
    } else {
      return this.hoverItems.findIndex((it) => it.id === itemOrId.id) > -1;
    }
  }
  hasHoverItem() {
    return this.hoverId !== "";
  }
  selectHoverItem() {
    this.select(this.hoverId);
  }
  setHoverId(id) {
    let isChanged = false;
    if (!id || this.itemKeys[id]) {
      if (this.hoverId != "") {
        isChanged = true;
      }
      this.hoverId = "";
      this.hoverItems = [];
    } else if (this.cachedArtBoardVerties.find((it) => it.item.id === id)) {
      if (this.hoverId != "") {
        isChanged = true;
      }
      this.hoverId = "";
      this.hoverItems = [];
    } else {
      if (this.hoverId != id) {
        isChanged = true;
      }
      this.hoverId = id;
      this.hoverItems = this.itemsByIds([id]).filter((it) => it.isNot("artboard"));
      if (this.hoverItems.length === 0) {
        this.hoverId = "";
        isChanged = true;
      }
    }
    if (isChanged) {
      this.$editor.emit("changeHoverItem");
    }
    return isChanged;
  }
  is(...args2) {
    var _a;
    return args2.includes((_a = this.current) == null ? void 0 : _a.itemType);
  }
  isAll(...args2) {
    return this.items.every((it) => args2.includes(it.itemType));
  }
  updateGridInformation(obj2 = {}) {
    this.gridInformation = obj2;
  }
  updateDragTargetItem(item) {
    this.dragTargetItem = item;
  }
}
const MAX_SNAP_DISTANCE = 3;
const DEFAULT_DIST_VECTOR = { dist: fromValues(0, 0, 0) };
const AXIS_X = "x";
const AXIS_Y = "y";
function checkXAxis(sourceVertex, targetVertex, dist2 = 1) {
  return Math.abs(sourceVertex[0] - targetVertex[0]) < dist2;
}
function checkYAxis(sourceVertex, targetVertex, dist2 = 1) {
  return Math.abs(sourceVertex[1] - targetVertex[1]) < dist2;
}
class SnapManager {
  constructor(editor, snapDistance = MAX_SNAP_DISTANCE) {
    this.editor = editor;
    this.context = this.editor.context;
    this.map = /* @__PURE__ */ new Map();
    this.snapTargetLayers = [];
    this.snapDistance = snapDistance;
  }
  get dist() {
    return this.context.config.get("snap.distance") || this.snapDistance;
  }
  get gridSize() {
    return this.context.config.get("snap.grid") || 50;
  }
  makeSnapTargetLayers() {
    if (!this.context.selection.currentProject)
      return [];
    return this.context.selection.currentProject.allLayers.filter((item) => {
      if (item.is("project"))
        return false;
      if (this.context.selection.check(item))
        return false;
      const inViewport = this.context.viewport.checkInViewportArea(item.originVerties);
      return inViewport;
    });
  }
  clear() {
    this.snapTargetLayers = this.makeSnapTargetLayers();
  }
  convertMatrix(item) {
    const verties = this.convertGuideAndPathMatrix(item);
    const xList = verties.map((it) => it[0]);
    const yList = verties.map((it) => it[1]);
    return {
      id: item.id,
      xList,
      yList,
      verties,
      rectVerties: toRectVertiesWithoutTransformOrigin(item.originVerties)
    };
  }
  convertGuideAndPathMatrix(item) {
    const guideVerties = item.guideVerties;
    return [...guideVerties];
  }
  get snapTargetLayersWithSelection() {
    if (!this.context.selection.currentProject)
      return [];
    return this.context.selection.currentProject.allLayers.filter((item) => {
      if (item.is("project"))
        return false;
      const inViewport = item.verties.some((v) => {
        return this.context.viewport.checkInViewport(v);
      });
      return inViewport;
    });
  }
  getSnapPoints() {
    const points = [];
    this.snapTargetLayersWithSelection.forEach((it) => {
      points.push.apply(points, this.convertGuideAndPathMatrix(it));
    });
    return points;
  }
  checkX(targetXList, sourceXList, dist2 = 0) {
    const checkXList = [];
    targetXList.forEach((targetX, targetIndex) => {
      sourceXList.forEach((sourceX, sourceIndex) => {
        if (Math.abs(targetX - sourceX) <= dist2) {
          checkXList.push({
            targetX,
            sourceX,
            sourceIndex,
            targetIndex,
            dx: targetX - sourceX
          });
        }
      });
    });
    return checkXList;
  }
  checkY(targetYList, sourceYList, dist2 = 0) {
    const checkYList = [];
    targetYList.forEach((targetY, targetIndex) => {
      sourceYList.forEach((sourceY, sourceIndex) => {
        const localDistY = targetY - sourceY;
        if (Math.abs(localDistY) <= dist2) {
          checkYList.push({
            targetY,
            sourceY,
            sourceIndex,
            targetIndex,
            dy: localDistY
          });
        }
      });
    });
    return checkYList;
  }
  check(sourceVerties, dist2 = 0) {
    const snaps = [];
    const sourceXList = sourceVerties.map((it) => it[0]);
    const sourceYList = sourceVerties.map((it) => it[1]);
    const guideXList = this.context.config.get("horizontal.line");
    const guideYList = this.context.config.get("vertical.line");
    if (guideXList && guideYList) {
      const x = this.checkX(guideXList, sourceXList, dist2)[0];
      const y = this.checkY(guideYList, sourceYList, dist2)[0];
      const distVector = fromValues(x ? x.dx : 0, y ? y.dy : 0, 0);
      if (isNotZero(distVector[0]) || isNotZero(distVector[1])) {
        snaps.push({ target: null, dist: distVector });
      }
    }
    this.snapTargetLayers.forEach((target) => {
      const x = this.checkX(target.xList, sourceXList, dist2)[0];
      const y = this.checkY(target.yList, sourceYList, dist2)[0];
      const distVector = fromValues(x ? x.dx : 0, y ? y.dy : 0, 0);
      if (isNotZero(distVector[0]) || isNotZero(distVector[1])) {
        snaps.push({ target, dist: distVector });
      }
    });
    return snaps.find((it) => isNotZero(it[0]) || isNotZero(it[1])) || DEFAULT_DIST_VECTOR;
  }
  checkPoint(sourceVertex) {
    const snap = this.check([sourceVertex]);
    return add$1([], sourceVertex, snap.dist);
  }
  getGuidesByPointPoint(sourceVerties, targetVerties, dist$1 = 0) {
    const points = [];
    const groupPoints = {};
    let sourceVertex, targetVertex;
    for (let sourceIndex = 0, sourceLength = sourceVerties.length; sourceIndex < sourceLength; sourceIndex++) {
      sourceVertex = sourceVerties[sourceIndex];
      const keyX = `${sourceVertex[0]}_x`;
      const keyY = `${sourceVertex[1]}_y`;
      if (!groupPoints[keyX]) {
        groupPoints[keyX] = [];
      }
      if (!groupPoints[keyY]) {
        groupPoints[keyY] = [];
      }
      for (let targetIndex = 0, targetLength = targetVerties.length; targetIndex < targetLength; targetIndex++) {
        targetVertex = targetVerties[targetIndex];
        if (checkXAxis(sourceVertex, targetVertex, dist$1)) {
          groupPoints[keyX].push([
            sourceVertex,
            targetVertex,
            AXIS_X,
            dist(sourceVertex, targetVertex)
          ]);
        }
        if (checkYAxis(sourceVertex, targetVertex, dist$1)) {
          groupPoints[keyY].push([
            sourceVertex,
            targetVertex,
            AXIS_Y,
            dist(sourceVertex, targetVertex)
          ]);
        }
      }
    }
    Object.keys(groupPoints).forEach((key) => {
      if (groupPoints[key] && groupPoints[key].length) {
        const sorted = groupPoints[key].sort((a, b) => a[3] - b[3]);
        points.push(...sorted);
      }
    });
    return points;
  }
  findGuide(sourceVerties, dist2 = 0) {
    const guides = [];
    this.snapTargetLayers.forEach((target) => {
      const points = this.getGuidesByPointPoint(sourceVerties, target.guideVerties, dist2);
      guides.push.apply(guides, points);
    });
    guides.sort((a, b) => {
      return a[3] - b[3];
    });
    return guides.filter((_, index2) => index2 < 10);
  }
  findGuideOne(sourceVerties) {
    return [this.findGuide(sourceVerties)[0]];
  }
  getWorldPosition() {
    const pos = round$2([], this.context.viewport.getWorldPosition());
    const snap = this.check([pos], 3 / this.context.viewport.scale);
    const newPos = add$1([], snap.dist, pos);
    return newPos;
  }
  getSnapTarget() {
    const pos = round$2([], this.context.viewport.getWorldPosition());
    const snap = this.check([pos], 3 / this.context.viewport.scale);
    const newPos = add$1([], snap.dist, pos);
    return {
      vertex: newPos,
      snap
    };
  }
}
class TimelineSelectionManager {
  constructor(editor) {
    this.$editor = editor;
    this.items = [];
    this.itemKeys = {};
  }
  initialize() {
    this.items = [];
    this.itemKeys = {};
  }
  currentProject(callback) {
    var project2 = this.$editor.context.selection.currentProject;
    if (project2) {
      callback && callback(project2);
    }
  }
  empty() {
    this.select();
  }
  each(callback) {
    this.items.forEach((item, index2) => {
      callback && callback(item, index2);
    });
  }
  refreshCache(list2) {
    this.items = list2;
    this.itemKeys = {};
    this.items.forEach((it) => {
      this.itemKeys[it.id] = it;
    });
  }
  cachedList() {
    return this.items.map((it) => {
      return __spreadValues({}, it);
    });
  }
  checked(id) {
    return !!this.itemKeys[id];
  }
  selectLayer(layerId) {
    this.currentProject((project2) => {
      var list2 = project2.getKeyframeListReturnArray().filter((it) => {
        return it.layerId === layerId;
      });
      this.refreshCache(list2);
    });
  }
  toggleLayerContainer(animationId) {
    this.currentProject((project2) => {
      project2.getSelectedTimeline().animations.filter((it) => {
        return it.id === animationId;
      }).forEach((it) => {
        it.collapsed = !it.collapsed;
      });
    });
  }
  selectProperty(layerId, property) {
    this.currentProject((project2) => {
      var list2 = project2.getKeyframeListReturnArray().filter((it) => {
        return it.layerId === layerId && it.property === property;
      });
      this.refreshCache(list2);
    });
  }
  select(...args2) {
    this.refreshCache(args2);
  }
  selectBySearch(list2, startTime, endTime) {
    this.currentProject((project2) => {
      var totalList = [];
      list2.forEach((it) => {
        var results = [];
        if (it.property) {
          var p = project2.getTimelineProperty(it.layerId, it.property);
          results = p.keyframes.filter((keyframe2) => {
            return startTime <= keyframe2.time && keyframe2.time <= endTime;
          });
        } else {
          var p = project2.getTimelineObject(it.layerId);
          p.properties.filter((property) => {
            return property.property === it.property;
          }).forEach((property) => {
            results.push.apply(results, property.keyframes.filter((keyframe2) => {
              return startTime <= keyframe2.time && keyframe2.time <= endTime;
            }));
          });
        }
        totalList.push.apply(totalList, results);
      });
      var uniqueOffset = {};
      totalList.forEach((it) => {
        uniqueOffset[it.id] = it;
      });
      this.select(...Object.values(uniqueOffset));
    });
  }
  checkLayer(layerId) {
    return Object.keys(this.itemKeys).some((key) => {
      return this.itemKeys[key].layerId === layerId;
    });
  }
  checkProperty(layerId, property) {
    return Object.keys(this.itemKeys).some((key) => {
      return this.itemKeys[key].layerId === layerId && this.itemKeys[key].property === property;
    });
  }
}
class VisibleManager {
  constructor(editor) {
    this.editor = editor;
    this.hiddenList = {};
  }
  get list() {
    return Object.keys(this.hiddenList);
  }
  get(key) {
    return !this.hiddenList[key];
  }
  set(key, value) {
    if (value) {
      delete this.hiddenList[key];
    } else {
      this.hiddenList[key] = true;
    }
  }
  toggle(key) {
    if (this.get(key)) {
      this.set(key, false);
    } else {
      this.set(key, true);
    }
  }
}
var ContextMenuRenderer$1 = "";
class ContextDropdownMenu extends DropdownMenuList {
  template() {
    return `
      <div class="dropdown-menu opened flat">
          <ul>
              ${this.props.items.map((child, index2) => makeMenuItem(child, `${this.groupId}-${index2}`)).join("")}
          </ul>
      </div>
    `;
  }
}
class ContextMenuRenderer extends EditorElement {
  checkProps(props = {}) {
    return props;
  }
  components() {
    return {
      ContextDropdownMenu,
      ToolbarButtonMenuItem
    };
  }
  template() {
    return `<div class="elf--context-menu-renderer"></div>`;
  }
  [LOAD("$el")]() {
    var _a;
    return (_a = this.props.items) == null ? void 0 : _a.map((item, index2) => {
      return this.renderMenuItem(item, index2);
    });
  }
  renderMenuItem(item, index2) {
    switch (item.type) {
      case MenuItemType.LINK:
        return this.renderLink(item, index2);
      case MenuItemType.SUBMENU:
        return this.renderMenu(item, index2);
      case MenuItemType.BUTTON:
        return this.renderButton(item, index2);
      case MenuItemType.DROPDOWN:
        return this.renderDropdown(item, index2);
      default:
        return this.renderButton(item, index2);
    }
  }
  renderButton(item, index2) {
    return createComponent("ToolbarButtonMenuItem", {
      ref: "$button-" + index2,
      title: item.title,
      icon: item.icon,
      command: item.command,
      shortcut: item.shortcut,
      args: item.args,
      nextTick: item.nextTick,
      disabled: item.disabled,
      selected: item.selected,
      selectedKey: item.selectedKey,
      checked: item.checked,
      action: item.action,
      events: item.events,
      style: item.style
    });
  }
  renderDropdown(item, index2) {
    return createComponent("ContextDropdownMenu", __spreadProps(__spreadValues({
      ref: "$dropdown-" + index2
    }, item), {
      items: item.items,
      icon: item.icon,
      title: item.title,
      events: item.events || []
    }));
  }
}
var ContextMenuView$1 = "";
class ContextMenuView extends EditorElement {
  template() {
    return /* @__PURE__ */ createElementJsx("div", {
      class: "elf--context-menu-view"
    });
  }
  [BIND("$el")]() {
    const contextMenuOpenInfo = this.$context.config.get("context.menu.open");
    if (!contextMenuOpenInfo) {
      return;
    }
    return {
      style: {
        left: Length.px(contextMenuOpenInfo.x),
        top: Length.px(contextMenuOpenInfo.y + 10)
      }
    };
  }
  [LOAD("$el")]() {
    const info = this.$context.config.get("context.menu.open");
    if (!info)
      return;
    const items = this.$menu.getTargetMenu(info.target) || [];
    return /* @__PURE__ */ createElementJsx(ContextMenuRenderer, {
      items: [{ type: "dropdown", items: [...items, ...info.items || []] }]
    });
  }
  [CONFIG("context.menu.open")]() {
    this.refresh();
    if (this.$context.config.get("context.menu.open")) {
      this.$el.show();
    } else {
      this.$el.hide();
    }
  }
  close() {
    this.$el.hide();
    this.$context.config.set("context.menu.open", null);
  }
  [POINTERSTART("document")](e) {
    const $target = Dom.create(e.target);
    const $dropdown = $target.closest("elf--context-menu-view");
    if (!$dropdown) {
      this.close();
    } else if ($dropdown.el !== this.$el.el) {
      this.close();
    }
  }
}
var AlignmentProperty$1 = "";
const DEFAULT_TITLE = "";
const DEFAULT_ICON = "";
const DEFAULT_CHECKED = false;
class MenuItem extends EditorElement {
  template() {
    return `
        <button 
            type="button" 
            class='elf--menu-item ${this.getClassName()}' 
            data-no-title="${this.isHideTitle()}" 
            ${this.isHideTitle() && this.isHideTooltip() === false ? `data-tooltip="${this.getTitle()}"` : ""} 
            checked="${this.getChecked() ? "checked" : ""}"
            ${this.isDisabled() ? "disabled" : ""}
            data-direction="${this.getDirection()}"
        >
            <div class="icon ${this.getIcon()}" ref="$icon">${obj$2[this.getIconString()] || this.getIconString() || ""}</div>
            ${this.isHideTitle() ? "" : `<div class="title">${this.getTitle()}</div>`}
            
        </button>
        `;
  }
  getClassName() {
    return "";
  }
  clickButton() {
  }
  getChecked() {
    return DEFAULT_CHECKED;
  }
  isDisabled() {
    return false;
  }
  setSelected(isSelected) {
    this.$el.toggleClass("selected", isSelected);
  }
  getTitle() {
    return DEFAULT_TITLE;
  }
  getIcon() {
    return DEFAULT_ICON;
  }
  setIcon(iconString) {
    this.refs.$icon.html(obj$2[iconString] || iconString || "");
  }
  getIconString() {
    return DEFAULT_ICON;
  }
  isHideTitle() {
    return false;
  }
  isHideTooltip() {
    return true;
  }
  [CLICK()](e) {
    this.clickButton(e);
  }
  getDirection() {
    return this.props.direction || "";
  }
  static createMenuItem(opt = {}) {
    return class extends MenuItem {
      getIconString() {
        return opt.iconString || "add_box";
      }
      getTitle() {
        return opt.title || "New Item";
      }
      isHideTitle() {
        return opt.isHideTitle || true;
      }
      clickButton(e) {
        opt.clickButton(e);
      }
      getDirection() {
        return opt.direction;
      }
    };
  }
}
class BottomAlign extends MenuItem {
  getIconString() {
    return "align_vertical_bottom";
  }
  getTitle() {
    return "Bottom";
  }
  isHideTitle() {
    return true;
  }
  clickButton() {
    this.$commands.emit("sort.bottom");
  }
}
class CenterAlign extends MenuItem {
  getIconString() {
    return "align_horizontal_center";
  }
  getTitle() {
    return "Center";
  }
  isHideTitle() {
    return true;
  }
  clickButton() {
    this.$commands.emit("sort.center");
  }
}
class LeftAlign extends MenuItem {
  getIconString() {
    return "align_horizontal_left";
  }
  getTitle() {
    return "Left";
  }
  isHideTitle() {
    return true;
  }
  clickButton() {
    this.$commands.emit("sort.left");
  }
}
class MiddleAlign extends MenuItem {
  getIconString() {
    return "align_vertical_center";
  }
  getTitle() {
    return "middle";
  }
  isHideTitle() {
    return true;
  }
  clickButton() {
    this.$commands.emit("sort.middle");
  }
}
class RightAlign extends MenuItem {
  getIconString() {
    return "align_horizontal_right";
  }
  getTitle() {
    return "Right";
  }
  isHideTitle() {
    return true;
  }
  clickButton() {
    this.$commands.emit("sort.right");
  }
}
class SameHeight extends MenuItem {
  getIconString() {
    return "vertical_distribute";
  }
  getTitle() {
    return "height";
  }
  isHideTitle() {
    return true;
  }
  clickButton() {
    this.$commands.emit("same.height");
  }
}
class SameWidth extends MenuItem {
  getIconString() {
    return "horizontal_distribute";
  }
  getTitle() {
    return "width";
  }
  isHideTitle() {
    return true;
  }
  clickButton() {
    this.$commands.emit("same.width");
  }
}
class TopAlign extends MenuItem {
  getIconString() {
    return "align_vertical_top";
  }
  getTitle() {
    return "Top";
  }
  isHideTitle() {
    return true;
  }
  clickButton() {
    this.$commands.emit("sort.top");
  }
}
var BaseProperty$1 = "";
class BaseProperty extends EditorElement {
  onToggleShow() {
  }
  template() {
    return `
        <div class='elf--property ${this.isHideHeader() ? "no-title" : ""} ${this.getClassName()} ${this.isFirstShow() ? "show" : ""}'>
            ${this.isHideHeader() ? "" : `
            <div class='property-title ${this.getTitleClassName()}' ref="$title">
                <label class="${this.hasKeyframe() ? "has-keyframe" : ""}"> 
                  ${this.hasKeyframe() ? `
                      <span class='add-timeline-property' data-property='${this.getKeyframeProperty()}'></span>
                    ` : ""} 
                  <span ref='$propertyTitle'>${this.getTitle()}</span>
                </label>
                <span class="tools">${this.getTools()}</span>
            </div>`}
            <div class='property-body ${this.getBodyClassName()}'>${this.getBody()}</div>
            ${this.getFooter() ? `<div class='property-footer'>${this.getFooter()}</div>` : ""}
        </div>
        `;
  }
  [BIND("$el")]() {
    return {
      style: {
        "--property-order": this.order
      }
    };
  }
  setTitle(title2) {
    this.refs.$propertyTitle.html(title2);
  }
  hasKeyframe() {
    return false;
  }
  isHideHeader() {
    return false;
  }
  isFirstShow() {
    return true;
  }
  getClassName() {
    return "";
  }
  getTitleClassName() {
    return "";
  }
  getBodyClassName() {
    return "";
  }
  getKeyframeProperty() {
    return "";
  }
  getTitle() {
    return "";
  }
  getTools() {
    return "";
  }
  getBody() {
    return "";
  }
  getFooter() {
    return "";
  }
  isPropertyShow() {
    return this.$el.hasClass("show");
  }
  toggle(isShow) {
    this.$el.toggle(isShow);
  }
  hide() {
    this.$el.hide();
  }
  show() {
    this.$el.show();
  }
  onShowTitle() {
  }
  refreshShowIsNot(type = "", isRefresh = true) {
    var current = this.$context.selection.current;
    if (current) {
      if (type.includes(current.itemType)) {
        this.hide();
      } else {
        this.show();
        if (isRefresh)
          this.refresh();
      }
    }
  }
  refreshShow(type, isRefresh = true) {
    var current = this.$context.selection.current;
    if (current) {
      if (isFunction(type) && type()) {
        this.show();
        if (isRefresh)
          this.refresh();
      } else {
        if (!isFunction(type) && type.includes(current.itemType)) {
          this.show();
          if (isRefresh)
            this.refresh();
        } else {
          this.hide();
        }
      }
    } else {
      this.hide();
    }
  }
  startInputEditing(input2) {
    if (!input2)
      return;
    input2.attr("contenteditable", true);
    input2.css({
      "background-color": "white",
      outline: "1px auto black",
      color: "black"
    });
    input2.focus();
  }
  endInputEditing(input2, callback) {
    if (!input2)
      return;
    input2.attr("contenteditable", false);
    input2.css({
      "background-color": null,
      outline: null,
      color: null
    });
    var index2 = input2.attr("data-index");
    callback && callback(index2, input2.text().trim());
    input2.blur();
  }
  get editableProperty() {
    return "";
  }
  get order() {
    return 1e3;
  }
  checkShow() {
    if (!this.$context.selection.current) {
      this.hide();
      return false;
    }
    if (this.$context.selection.current.editable(this.editableProperty)) {
      this.show();
      return true;
    } else {
      this.hide();
      return false;
    }
  }
}
class AlignmentProperty extends BaseProperty {
  components() {
    return {
      LeftAlign,
      CenterAlign,
      RightAlign,
      TopAlign,
      MiddleAlign,
      BottomAlign,
      SameWidth,
      SameHeight
    };
  }
  getTitle() {
    return this.$i18n("alignment.property.title");
  }
  isHideHeader() {
    return true;
  }
  getBody() {
    return `
      <div class="elf--alignment-item">
        ${createComponentList("LeftAlign", "CenterAlign", "RightAlign", "TopAlign", "MiddleAlign", "BottomAlign", ["SameWidth", { direction: "bottom" }], "SameHeight")}
      </div>
    `;
  }
}
function alignment(editor) {
  editor.registerUI("inspector.tab.style", {
    AlignmentProperty
  });
}
var AnimationProperty$1 = "";
function getCustomParseIndexString(it, prefix = "@") {
  return `${prefix}${it.startIndex}`.padEnd(10, "0");
}
function customParseMatches(str, regexp) {
  const matches2 = str.match(regexp);
  let result = [];
  if (!matches2) {
    return result;
  }
  for (var i = 0, len2 = matches2.length; i < len2; i++) {
    result.push({ parsedString: matches2[i] });
  }
  var pos = { next: 0 };
  result.forEach((item) => {
    const startIndex = str.indexOf(item.parsedString, pos.next);
    item.startIndex = startIndex;
    item.endIndex = startIndex + item.parsedString.length;
    pos.next = item.endIndex;
  });
  return result;
}
function customParseConvertMatches(str, regexp) {
  const m = customParseMatches(str, regexp);
  m.forEach((it) => {
    str = str.replace(it.parsedString, getCustomParseIndexString(it));
  });
  return { str, matches: m };
}
function customParseReverseMatches(str, matches2) {
  matches2.forEach((it) => {
    str = str.replace(getCustomParseIndexString(it), it.parsedString);
  });
  return str;
}
const ANIMATION_TIMING_REG = /((cubic-bezier|steps)\(([^)]*)\))/gi;
class Animation extends PropertyItem {
  static parse(obj2) {
    return new Animation(obj2);
  }
  getDefaultObject() {
    return {
      itemType: "animation",
      checked: true,
      name: "none",
      direction: "normal",
      duration: Length.second(0),
      timingFunction: "linear",
      delay: Length.second(0),
      iterationCount: Length.string("infinite"),
      playState: "running",
      fillMode: "none"
    };
  }
  convert(json) {
    json = super.convert(json);
    json.duration = Length.parse(json.duration);
    json.iterationCount = Length.parse(json.iterationCount);
    return json;
  }
  toCloneObject() {
    return __spreadValues({}, this.attrs("name", "direction", "duration", "timingFunction", "delay", "iterationCount", "playState", "fillMode"));
  }
  togglePlayState(forcedValue) {
    if (forcedValue) {
      this.reset({
        playState: forcedValue === "running" ? "running" : "paused"
      });
    } else {
      if (this.json.playState === "paused") {
        this.reset({ playState: "running" });
      } else {
        this.reset({ playState: "paused" });
      }
    }
  }
  toCSS() {
    if (!this.json.name)
      return {};
    return {
      animation: this.toString()
    };
  }
  toString() {
    var json = this.json;
    return [
      json.duration,
      json.timingFunction,
      json.delay,
      json.iterationCount,
      json.direction,
      json.fillMode,
      json.playState,
      json.name
    ].join(" ");
  }
  static join(list2) {
    return list2.map((it) => new Animation(it).toString()).join(",");
  }
  static add(animation2, item = {}) {
    const list2 = Animation.parseStyle(animation2);
    list2.push(Animation.parse(item));
    return Animation.join(list2);
  }
  static remove(animation2, removeIndex) {
    return Animation.filter(animation2, (it, index2) => {
      return removeIndex != index2;
    });
  }
  static filter(animation2, filterFunction) {
    return Animation.join(Animation.parseStyle(animation2).filter((it) => filterFunction(it)));
  }
  static replace(animation2, replaceIndex, valueObject) {
    var list2 = Animation.parseStyle(animation2);
    if (list2[replaceIndex]) {
      list2[replaceIndex] = valueObject;
    } else {
      list2.push(valueObject);
    }
    return Animation.join(list2);
  }
  static get(animation2, index2) {
    var arr = Animation.parseStyle(animation2);
    return arr[index2];
  }
  static parseStyle(animation2) {
    var list2 = [];
    if (!animation2)
      return list2;
    const result = customParseConvertMatches(animation2, ANIMATION_TIMING_REG);
    list2 = result.str.split(",").map((it) => {
      const fields2 = it.split(" ").filter(Boolean);
      if (fields2.length >= 7) {
        return {
          duration: Length.parse(fields2[0]),
          timingFunction: customParseReverseMatches(fields2[1], result.matches),
          delay: Length.parse(fields2[2]),
          iterationCount: fields2[3] === "infinite" ? Length.string("infinite") : Length.parse(fields2[3]),
          direction: fields2[4],
          fillMode: fields2[5],
          playState: fields2[6],
          name: fields2[7]
        };
      } else if (fields2.length >= 3) {
        return {
          duration: Length.parse(fields2[0]),
          timingFunction: customParseReverseMatches(fields2[1], result.matches),
          delay: Length.parse(fields2[2]),
          name: fields2[3]
        };
      } else if (fields2.length >= 1) {
        return {
          duration: Length.parse(fields2[0]),
          name: fields2[1]
        };
      } else {
        return {};
      }
    });
    return list2.map((it) => Animation.parse(it));
  }
}
class AnimationProperty extends BaseProperty {
  getTitle() {
    return this.$i18n("animation.property.title");
  }
  getBody() {
    return `<div class='animation-list' ref='$animationList'></div>`;
  }
  getTools() {
    return `
        <button type="button" ref="$add" title="add Fill">${iconUse("add")}</button>
    `;
  }
  isFirstShow() {
    return true;
  }
  [LOAD("$animationList") + DOMDIFF]() {
    var current = this.$context.selection.current;
    if (!current)
      return "";
    return Animation.parseStyle(current.animation).map((it, index2) => {
      const selectedClass = this.state.selectedIndex === index2 ? "selected" : "";
      const path = curveToPath(it.timingFunction, 30, 30);
      return `
      <div class='animation-group-item'>
        <div class='animation-item ${selectedClass}' 
             data-index='${index2}' 
             ref="animationIndex${index2}" 
          >
            <div class='timing preview' data-index='${index2}' ref='$preview${index2}'>
              <svg class='item-canvas' width="30" height="30" viewBox="0 0 30 30">
                <path d="${path}" stroke="white" stroke-width="1" fill='none' />
              </svg>
            </div>
            <div class='name'>
              <div class='title' ref="animationName${index2}">
                ${it.name ? it.name : `&lt; ${this.$i18n("animation.property.select a keyframe")} &gt;`}
              </div>
              <div class='labels'>
                <label class='count' title='${this.$i18n("animation.property.iteration.count")}'><small>${it.iterationCount}</small></label>
                <label class='delay' title='${this.$i18n("animation.property.delay")}'><small>${it.delay}</small></label>
                <label class='duration' title='${this.$i18n("animation.property.duration")}'><small>${it.duration}</small></label>
                <label class='direction' title='${this.$i18n("animation.property.direction")}'><small>${it.direction}</small></label>
                <label class='fill-mode' title='${this.$i18n("animation.property.fill.mode")}'><small>${it.fillMode}</small></label>
                <label class='play-state' title='${this.$i18n("animation.property.play.state")}' data-index='${index2}' data-play-state-selected-value="${it.playState}">
                  <small data-play-state-value='running'>${iconUse("play")}</small>
                  <small data-play-state-value='paused'>${iconUse("pause")}</small>
                </label>
              </div>
            </div>
            <div class='tools'>
                <button type="button" class="del" data-index="${index2}">
                  ${iconUse("remove2")}
                </button>
            </div>
        </div>
      </div>        
      `;
    });
  }
  [SUBSCRIBE(REFRESH_SELECTION) + DEBOUNCE(100)]() {
    const current = this.$context.selection.current;
    if (current && current.hasChangedField("animation")) {
      this.refresh();
    }
    this.emit("hideAnimationPropertyPopup");
  }
  [CLICK("$add")]() {
    var current = this.$context.selection.current;
    if (current) {
      this.$commands.executeCommand("setAttribute", "add animation property", this.$context.selection.packByValue({
        animation: (item) => Animation.add(item.animation, { name: null })
      }));
      this.nextTick(() => {
        window.setTimeout(() => {
          this.refresh();
        }, 100);
      });
    } else {
      window.alert("Select a layer");
    }
  }
  [CLICK("$animationList .tools .del")](e) {
    var removeIndex = e.$dt.attr("data-index");
    var current = this.$context.selection.current;
    if (!current)
      return;
    current.reset({
      animation: Animation.remove(current.animation, removeIndex)
    });
    this.$commands.emit("setAttribute", this.$context.selection.packByValue({
      animation: Animation.remove(current.animation, removeIndex)
    }));
    this.refresh();
  }
  [CLICK("$animationList .play-state")](e) {
    var index2 = +e.$dt.attr("data-index");
    var current = this.$context.selection.current;
    if (!current)
      return;
    const list2 = Animation.parseStyle(current.animation);
    var animation2 = list2[index2];
    if (animation2) {
      animation2.togglePlayState();
      e.$dt.attr("data-play-state-selected-value", animation2.playState);
      this.$commands.emit("setAttribute", this.$context.selection.packByValue({
        animation: Animation.join(list2)
      }));
    }
  }
  selectItem(selectedIndex, isSelected = true) {
    if (isSelected) {
      this.refs[`animationIndex${selectedIndex}`].addClass("selected");
    } else {
      this.refs[`animationIndex${selectedIndex}`].removeClass("selected");
    }
  }
  viewAnimationPicker($preview) {
    if (typeof this.selectedIndex === "number") {
      this.selectItem(this.selectedIndex, false);
    }
    this.selectedIndex = +$preview.attr("data-index");
    this.current = this.$context.selection.current;
    if (!this.current)
      return;
    this.currentAnimation = Animation.get(this.current.animation, this.selectedIndex);
    this.viewAnimationPropertyPopup();
  }
  viewAnimationPropertyPopup() {
    if (!this.currentAnimation)
      return;
    const animation2 = this.currentAnimation;
    this.emit("showAnimationPropertyPopup", {
      changeEvent: "changeAnimationPropertyPopup",
      data: animation2.toCloneObject(),
      instance: this
    });
  }
  [CLICK("$animationList .preview")](e) {
    this.viewAnimationPicker(e.$dt);
  }
  getRef(...args2) {
    return this.refs[args2.join("")];
  }
  [SUBSCRIBE("changeAnimationPropertyPopup")](data) {
    if (this.currentAnimation) {
      this.currentAnimation.reset(__spreadValues({}, data));
      if (this.current) {
        this.$commands.executeCommand("setAttribute", "change animation property", this.$context.selection.packByValue({
          animation: (item) => Animation.replace(item.animation, this.selectedIndex, this.currentAnimation)
        }));
        this.refresh();
      }
    }
  }
}
var AnimationPropertyPopup$1 = "";
var BasePopup$1 = "";
class BasePopup extends EditorElement {
  template() {
    return `
        <div class='elf--popup ${this.getClassName()}'>
            <div class='popup-title' ref="$title">
                <label>${this.getTitle()}</label>
                <span class="tools">
                  ${this.getTools()}
                  <button type='button' class='close' ref='$close'>${iconUse("close")}</button>
                </span>
            </div>
            <div class='popup-body'>${this.getBody()}</div>
            <!--<div class='popup-resizer' ref='$resizer'></div> -->
        </div>
        `;
  }
  getClassName() {
    return "";
  }
  getTitle() {
    return "";
  }
  getTools() {
    return "";
  }
  getBody() {
    return "";
  }
  onClose() {
  }
  [CLICK("$close")]() {
    this.$el.hide();
    this.onClose();
  }
  setTitle(title2) {
    this.refs.$title.$("label").text(title2);
  }
  [POINTERSTART("$title") + MOVE("movePopupTitle") + END("endPopupTitle")]() {
    this.x = Length.parse(this.$el.css("left"));
    this.y = Length.parse(this.$el.css("top"));
  }
  movePopupTitle(dx, dy) {
    var left2 = Length.px(this.x.value + dx);
    var top2 = Length.px(this.y.value + dy);
    this.$el.css({ left: left2, top: top2, right: "auto", bottom: "auto" });
  }
  show(width2 = 200) {
    var popupPadding = 28;
    var rightPosition = 320;
    var top2 = this.$el.css("top");
    var left2 = this.$el.css("left");
    var realTop = top2 !== "auto" ? Length.parse(top2) : 110;
    var realLeft = left2 !== "auto" ? Length.parse(left2) : document.body.clientWidth - rightPosition - popupPadding - width2;
    this.$el.css({
      top: Length.px(realTop),
      left: Length.px(realLeft),
      "z-index": this.$editor.zIndex
    }).show("inline-block");
  }
  makeRect(width2, height2, rect2) {
    const elements = this.$config.get("editor.layout.elements");
    const bodyRect = elements.$bodyPanel.rect();
    let left2 = bodyRect.left + bodyRect.width - width2 - 10;
    let top2 = rect2.top + height2 > bodyRect.top + bodyRect.height ? bodyRect.top + bodyRect.height - height2 - 10 : rect2.top;
    if (top2 < 10) {
      top2 = 10;
    }
    return {
      top: top2,
      left: left2,
      width: width2,
      height: height2
    };
  }
  showByRect(rect2) {
    this.$el.css({
      top: Length.px(rect2.top),
      left: Length.px(rect2.left),
      width: Length.px(rect2.width),
      height: Length.px(rect2.height),
      "z-index": this.$editor.zIndex
    }).show("inline-block");
  }
  hide() {
    this.$el.hide();
  }
  [SUBSCRIBE("hidePropertyPopup")]() {
    this.hide();
  }
  [POINTERSTART("$resizer") + MOVE("moveResizer")]() {
    this.width = Length.parse(this.$el.css("width"));
    this.height = Length.parse(this.$el.css("height"));
  }
  moveResizer(dx, dy) {
    this.$el.css({
      width: Math.min(this.width + dx, 1e3),
      height: Math.min(this.height + dy, 700)
    });
  }
}
class AnimationPropertyPopup extends BasePopup {
  getTitle() {
    return this.$i18n("animation.property.popup.title");
  }
  initState() {
    return {
      changeEvent: "",
      instance: {},
      data: {}
    };
  }
  updateData(opt) {
    this.state.data = __spreadValues(__spreadValues({}, this.state.data), opt);
    if (this.state.instance) {
      this.state.instance.trigger(this.state.changeEvent, this.state.data);
    }
  }
  getBody() {
    return `<div class='elf--animation-property-popup' ref='$popup'></div>`;
  }
  [LOAD("$popup")]() {
    return `
      <div class="box">
        ${this.templateForKeyframe()}
        ${this.templateForTimingFunction()}
        ${this.templateForIterationCount()}
        ${this.templateForDelay()}
        ${this.templateForDuration()}
        ${this.templateForDirection()}
        ${this.templateForFillMode()}
        ${this.templateForPlayState()}
      </div>
    `;
  }
  templateForTimingFunction() {
    return `
    <div class='timing-function'>
      <label>${this.$i18n("animation.property.popup.timing.function")}</label>
      ${createComponent("CubicBezierEditor", {
      ref: "$cubicBezierEditor",
      key: "timingFunction",
      value: this.state.data.timingFunction || "linear",
      onChange: "changeCubicBezier"
    })}
    </div>
    `;
  }
  templateForKeyframe() {
    return `
      <div class='name'>
        <label>${this.$i18n("animation.property.popup.keyframe")}</label>
        <div class='input grid-1'>
          <select ref='$name'></select>
        </div>
      </div>
    `;
  }
  [LOAD("$name")]() {
    var current = this.$context.selection.currentProject;
    var names2 = [];
    if (current && current.keyframes) {
      names2 = current.keyframes.map((it) => {
        return { key: it.name, value: it.name };
      });
    }
    names2.unshift({ key: "Select a keyframe", value: "" });
    return names2.map((it) => {
      var selected = it.value === this.name ? "selected" : "";
      var label = this.$i18n(it.key);
      return `<option value='${it.value}' ${selected}>${label}</option>`;
    });
  }
  [CHANGE("$name")]() {
    this.updateData({ name: this.refs.$name.value });
  }
  templateForDirection() {
    var options2 = "normal,reverse,alternate,alternate-reverse".split(",").map((it) => {
      return `${it}:${this.$i18n(it)}`;
    }).join(",");
    return `
      <div class='direction'>
        ${createComponent("SelectEditor", {
      label: this.$i18n("animation.property.popup.direction"),
      ref: "$direction",
      key: "direction",
      value: this.state.data.direction,
      options: options2,
      onChange: "changeSelect"
    })}
      </div>
    `;
  }
  [SUBSCRIBE_SELF("changeSelect")](key, value) {
    this.updateData({ [key]: value });
  }
  templateForPlayState() {
    return `
    <div class='play-state'>
      ${createComponent("SelectEditor", {
      label: this.$i18n("animation.property.popup.play.state"),
      ref: "$playState",
      key: "playState",
      value: this.state.data.playState,
      options: ["paused", "running"],
      onChange: "changeSelect"
    })}
    </div>
  `;
  }
  templateForFillMode() {
    var options2 = "none,forwards,backwards,both".split(",").map((it) => {
      return `${it}:${this.$i18n(it)}`;
    }).join(",");
    return `
    <div class='fill-mode'>
      ${createComponent("SelectEditor", {
      label: this.$i18n("animation.property.popup.fill.mode"),
      ref: "$fillMode",
      key: "fillMode",
      value: this.state.data.fillMode,
      options: options2,
      onChange: "changeSelect"
    })}
    </div>
  `;
  }
  templateForDelay() {
    return `
    <div class='delay'>
      ${createComponent("RangeEditor", {
      ref: "$delay",
      label: this.$i18n("animation.property.popup.delay"),
      key: "delay",
      value: this.state.data.delay,
      units: ["s", "ms"],
      onChange: "changeRangeEditor"
    })} 
    </div>
    `;
  }
  templateForDuration() {
    return `
    <div class='duration'>
      ${createComponent("RangeEditor", {
      ref: "$duration",
      label: this.$i18n("animation.property.popup.duration"),
      key: "duration",
      value: this.state.data.duration,
      units: ["s", "ms"],
      onChange: "changeRangeEditor"
    })} 
    </div>
    `;
  }
  templateForIterationCount() {
    return `
      <div class='iteration-count'>
        ${createComponent("IterationCountEditor", {
      ref: "$iterationCount",
      label: this.$i18n("animation.property.popup.iteration"),
      key: "iterationCount",
      value: this.state.iterationCount || 0,
      units: ["normal", "infinite"],
      onChange: "changeRangeEditor"
    })}
      </div>
    `;
  }
  [SUBSCRIBE_SELF("changeRangeEditor")](key, value) {
    if (key === "iterationCount") {
      if (value.unit === "normal") {
        value = Length.number(value.value);
      } else {
        value = Length.string(value.unit);
      }
    }
    this.updateData({ [key]: value });
  }
  [SUBSCRIBE_SELF("changeCubicBezier")](key, value) {
    this.updateData({ [key]: value });
  }
  [SUBSCRIBE("showAnimationPropertyPopup")](data) {
    this.setState(data);
    this.show(250);
    this.children.$cubicBezierEditor.trigger("showCubicBezierEditor", data.data.timingFunction);
  }
  [SUBSCRIBE("hideAnimationPropertyPopup")]() {
    this.$el.hide();
  }
}
function animation(editor) {
  editor.registerUI("inspector.tab.transition", {
    AnimationProperty
  });
  editor.registerUI("popup", {
    AnimationPropertyPopup
  });
}
class ObjectProperty {
  static create(json) {
    return class extends BaseProperty {
      getTitle() {
        return json.title;
      }
      getClassName() {
        return json.className || "item";
      }
      get editableProperty() {
        return json.editableProperty;
      }
      get order() {
        return isUndefined(json.order) ? 1e3 : json.order;
      }
      afterComponentRendering($dom, refName, instance) {
        var _a;
        if (refName == "$comp") {
          const current = ((_a = this.$context.selection) == null ? void 0 : _a.current) || {};
          const inspector2 = isFunction(json.inspector) ? json.inspector(current) : this.$context.components.createInspector(current, json.editableProperty);
          instance.setInspector(inspector2);
        }
      }
      refresh() {
        const current = this.$context.selection.current || {};
        if (current || json.visible) {
          this.setTitle(json.title || current.getDefaultTitle() || current.itemType || current.name);
          this.load();
        }
      }
      [SUBSCRIBE(REFRESH_SELECTION) + IF("checkShow")]() {
        if (json.preventUpdate) {
          if (this.$stateManager.isPointerUp) {
            this.refresh();
          }
        } else {
          this.refresh();
        }
      }
      [LOAD("$body")]() {
        var _a;
        var current = (_a = this.$context.selection) == null ? void 0 : _a.current;
        if (!current && !json.visible)
          return "";
        const inspector2 = isFunction(json.inspector) ? json.inspector(current || {}) : this.$context.components.createInspector(current || {}, json.editableProperty);
        return createComponent("ComponentEditor", {
          ref: "$comp",
          inspector: inspector2,
          onchange: "changeComponentProperty"
        });
      }
      getBody() {
        return `<div ref='$body'></div>`;
      }
      [SUBSCRIBE_SELF("changeComponentProperty")](key, value) {
        if (json.action) {
          this.$commands.executeCommand(json.action, `change attribute : ${key}`, key, value);
        } else {
          this.$commands.executeCommand("setAttribute", `change attribute : ${key}`, this.$context.selection.packByValue({
            [key]: value
          }));
        }
      }
    };
  }
}
function appearance(editor) {
  editor.registerUI("inspector.tab.style", {
    AppearanceProperty: ObjectProperty.create({
      title: editor.$i18n("background.color.property.title"),
      editableProperty: "appearance",
      preventUpdate: true,
      inspector: (current) => {
        return [
          {
            type: "column",
            size: [1, 1],
            columns: [
              {
                key: "backgroundColor",
                editor: "color-view",
                editorOptions: {
                  compact: true,
                  format: true
                },
                defaultValue: current.backgroundColor
              },
              {
                key: "mixBlendMode",
                editor: "blend-select",
                editorOptions: {
                  label: "tonality",
                  compact: true
                },
                defaultValue: current.mixBlendMode || BlendMode.NORMAL
              }
            ]
          },
          {
            key: "overflow",
            editor: "select",
            editorOptions: {
              label: editor.$i18n("background.color.property.overflow"),
              options: [
                Overflow.VISIBLE,
                Overflow.HIDDEN,
                Overflow.SCROLL,
                Overflow.AUTO
              ].map((it) => {
                return {
                  value: it,
                  text: editor.$i18n(`background.color.property.overflow.${it}`)
                };
              })
            },
            defaultValue: current.overflow
          }
        ];
      }
    })
  });
}
var ArtBoardSizeProperty$1 = "";
var artboardSize = [
  {
    category: "Web",
    groups: [
      {
        group: "Landscape",
        devices: [
          { device: "Web Small", size: "1024x600" },
          { device: "Web Medium", size: "1280x800" },
          { device: "Web Large", size: "1440x900" },
          { device: "Web X Large", size: "1920x1200" }
        ]
      },
      {
        group: "Portrait",
        devices: [
          { device: "Web Small", size: "600x1024" },
          { device: "Web Medium", size: "800x1280" },
          { device: "Web Large", size: "900x1440" },
          { device: "Web X Large", size: "1200x1920" }
        ]
      }
    ]
  },
  {
    category: "Apple Devices",
    groups: [
      {
        group: "iphone",
        devices: [
          { device: "iPhone 8", size: "375x667" },
          { device: "iPhone 8 Plus", size: "414x736" },
          { device: "iPhone SE", size: "320x568" },
          { device: "iPhone XS", size: "375x812" },
          { device: "iPhone XR", size: "414x896" },
          { device: "iPhone XS Max", size: "414x896" }
        ]
      },
      {
        group: "ipad",
        devices: [
          { device: "iPad", size: "768x1024" },
          { device: "iPad Pro", size: "1024x1366" }
        ]
      },
      {
        group: "apple watch",
        devices: [
          { device: "Apple Watch 38nm", size: "272x340" },
          { device: "Apple Watch 40nm", size: "326x394" },
          { device: "Apple Watch 42nm", size: "313x390" },
          { device: "Apple Watch 44nm", size: "368x448" }
        ]
      },
      {
        group: "apple tv",
        devices: [{ device: "Apple TV", size: "1920x1080" }]
      },
      { group: "MAC", devices: [{ device: "Touch Bar", size: "1085x30" }] }
    ]
  },
  {
    category: "Android Devices",
    groups: [
      {
        group: "android mobile",
        devices: [{ device: "Android Mobile", size: "360x640" }]
      },
      {
        group: "android tablet",
        devices: [{ device: "Android Tablet", size: "768x1024" }]
      }
    ]
  }
];
class ArtBoardSizeProperty extends BaseProperty {
  getClassName() {
    return "elf--artboard-size-list";
  }
  get editableProperty() {
    return "artboardSize";
  }
  [SUBSCRIBE(REFRESH_SELECTION) + IF("checkShow")]() {
    this.refresh();
  }
  initState() {
    return {
      selectedIndex: 0
    };
  }
  getTitle() {
    return "ArtBoard Preset";
  }
  getTools() {
    var categories2 = artboardSize.map((it, index2) => {
      return { category: it.category, index: index2 };
    });
    return createComponent("SelectEditor", {
      ref: "$select",
      value: categories2[0].category,
      options: categories2.map((it) => it.category),
      onchange: "changeSizeIndex"
    });
  }
  [SUBSCRIBE_SELF("changeSizeIndex")](key, value) {
    var selectedIndex = this.state.selectedIndex;
    artboardSize.forEach((it, index2) => {
      if (it.category === value) {
        selectedIndex = index2;
      }
    });
    this.state.selectedIndex = selectedIndex;
    this.refresh();
  }
  getBody() {
    return `
      <div class='artboard-size-item' ref='$list'></div>
    `;
  }
  makeDevice(device) {
    return `
      <div class='device-item' data-size='${device.size}'>
        <div class='title'>${device.device}</div>
        <div class='size'>${device.size}</div>
      </div>
    `;
  }
  [CLICK("$list .device-item")](e) {
    var size2 = e.$dt.attr("data-size");
    this.$commands.emit("resizeArtBoard", size2);
  }
  makeGroup(group2) {
    return `
      <div class='group-item'>
        <div class='title'>${group2.group}</div>
      </div>
      <div class='devices'>
        ${group2.devices.map((device) => this.makeDevice(device)).join("")}
      </div>
    `;
  }
  makeCategory(category) {
    return `
      <div class='category'>
        <div class='title'>${category.category}</div>
      </div>
      <div class='groups'>
        ${category.groups.map((group2) => this.makeGroup(group2)).join("")}
      </div>
    `;
  }
  [LOAD("$list") + DOMDIFF]() {
    var category = artboardSize[this.state.selectedIndex];
    return category.groups.map((group2) => this.makeGroup(group2));
  }
}
function artboard(editor) {
  editor.registerUI("inspector.tab.style", {
    ArtBoardSizeProperty
  });
}
var BackdropFilterProperty$1 = "";
const filter_list$1 = [
  "blur",
  "grayscale",
  "hue-rotate",
  "invert",
  "brightness",
  "contrast",
  "drop-shadow",
  "opacity",
  "saturate",
  "sepia",
  "svg"
];
class BackdropFilterProperty extends BaseProperty {
  getTitle() {
    return this.$i18n("backdrop.filter.property.title");
  }
  getTitleClassName() {
    return "filter";
  }
  getBodyClassName() {
    return "no-padding";
  }
  getBody() {
    return `<div class='full filter-property' ref='$body'></div>`;
  }
  getTools() {
    return `
      <select class="filter-select" ref="$filterSelect"></select>
      <button type="button" ref="$add" title="add Filter">${iconUse("add")}</button>
    `;
  }
  [CLICK("$add")]() {
    var filterType = this.refs.$filterSelect.value;
    this.children.$filterEditor.trigger("add", filterType);
  }
  [LOAD("$filterSelect")]() {
    var list2 = filter_list$1.map((it) => {
      return { title: this.$i18n(`filter.property.${it}`), value: it };
    });
    var svgFilterList = this.getSVGFilterList();
    var totalList = [];
    if (svgFilterList.length) {
      totalList = [...list2, { title: "-------", value: "" }, ...svgFilterList];
    } else {
      totalList = [...list2];
    }
    return totalList.map((it) => {
      var { title: title2, value } = it;
      return `<option value='${value}'>${title2}</option>`;
    });
  }
  getSVGFilterList() {
    var current = this.$context.selection.currentProject;
    var arr = [];
    if (current) {
      arr = current.svgfilters.map((it) => {
        return {
          title: `svg - #${it.id}`,
          value: it.id
        };
      });
    }
    return arr;
  }
  [LOAD("$body")]() {
    var current = this.$context.selection.current || {};
    var value = current.backdropFilter;
    return `
      <div>
        ${createComponent("FilterEditor", {
      ref: "$filterEditor",
      key: "backdropFilter",
      value: clone$1(value),
      hideLabel: true,
      onchange: "changeFilterEditor"
    })}
      </div>
    `;
  }
  [SUBSCRIBE_SELF("changeFilterEditor")](key, filter2) {
    this.$commands.executeCommand("setAttribute", "change backdrop filter", this.$context.selection.packByValue({
      [key]: clone$1(filter2)
    }));
  }
  get editableProperty() {
    return "backdropFilter";
  }
  [SUBSCRIBE(REFRESH_SELECTION) + IF("checkShow") + DEBOUNCE(1e3)]() {
    this.refresh();
  }
}
function backdropFilter(editor) {
  editor.registerUI("inspector.tab.style", {
    BackdropFilterProperty
  });
}
class BackgroundClipProperty extends BaseProperty {
  getTitle() {
    return "Background Clip";
  }
  isFirstShow() {
    return false;
  }
  getTools() {
    return `<div ref='$backgroundClip' style='padding-top: 3px;'></div>`;
  }
  [LOAD("$backgroundClip")]() {
    var current = this.$context.selection.current || {};
    var clip = current.backgroundClip || "";
    return createComponent("SelectEditor", {
      ref: "$1",
      key: "backgroundClip",
      icon: true,
      value: clip,
      options: ["", "paddinb-box", "border-box", "content-box", "text"],
      onchange: "changeSelect"
    });
  }
  [SUBSCRIBE_SELF("changeSelect")](key, value) {
    this.$commands.executeCommand("setAttribute", "change background clip", this.$context.selection.packByValue({
      [key]: value
    }));
  }
  [SUBSCRIBE(REFRESH_SELECTION) + DEBOUNCE(100)]() {
    this.refreshShow(["rect", "circle", "text"]);
  }
}
function backgroundClip(editor) {
  editor.registerElement({
    BackgroundClipProperty
  });
}
var BackgroundImageEditor$1 = "";
const types = {
  image: "image",
  "image-resource": "image",
  url: "image",
  "static-gradient": "gradient",
  "linear-gradient": "gradient",
  "repeating-linear-gradient": "gradient",
  "radial-gradient": "gradient",
  "repeating-radial-gradient": "gradient",
  "conic-gradient": "gradient",
  "repeating-conic-gradient": "gradient"
};
class BackgroundImageEditor extends EditorElement {
  initState() {
    return {
      hideLabel: this.props.hideLabel || false,
      value: this.props.value,
      images: this.parseBackgroundImage(this.props.value)
    };
  }
  parseBackgroundImage(str) {
    if (str === "")
      return [];
    return BackgroundImage.parseStyle(STRING_TO_CSS(str));
  }
  setValue(value) {
    this.setState({
      value,
      images: this.parseBackgroundImage(value)
    });
  }
  template() {
    return `
            <div class='elf--background-image-editor' >
                <div class='fill-list' ref='$fillList'></div>
            </div>
        `;
  }
  [LOAD("$fillList") + DOMDIFF]() {
    const current = this.$context.selection.current || { color: "black" };
    return this.state.images.map((it, index2) => {
      var image2 = it.image;
      var backgroundType = types[image2.type];
      const selectedClass = it.selected ? "selected" : "";
      if (it.selected) {
        this.selectedIndex = index2;
      }
      return `
            <div class='fill-item ${selectedClass}' data-index='${index2}' ref="fillIndex${index2}"  draggable='true' data-fill-type="${backgroundType}" >
                <label draggable="true" data-index="${index2}">${iconUse("drag_indicator")}</label>
                ${createComponentList([
        "BackgroundPositionEditor",
        {
          key: "background-position",
          index: index2,
          ref: `$bp${index2}`,
          x: it.x,
          y: it.y,
          width: it.width,
          height: it.height,
          repeat: it.repeat,
          size: it.size,
          blendMode: it.blendMode,
          onchange: "changePattern"
        }
      ], [
        "GradientSingleEditor",
        {
          index: index2,
          ref: `$gse${index2}`,
          image: it.image,
          color: current.color,
          key: "background-image",
          onchange: "changePattern"
        }
      ])}
                <div class='fill-info'>
                  <div class='gradient-info'>
                    <div class='blend'>
                        ${createComponent("BlendSelectEditor", {
        ref: `$blend_${index2}`,
        key: "blendMode",
        value: it.blendMode,
        params: index2,
        compact: true,
        onchange: "changeRangeEditor"
      })}
                    </div>
                    <div class='tools'>
                      <button type="button" class='visibility' data-index='${index2}' title="Visibility">${iconUse(it.visibility === VisibilityType.HIDDEN ? "visible_off" : "visible")}</button>
                    </div>                                       
                    <div class='tools'>
                      <button type="button" class='copy' data-index='${index2}' title="Copy Item">${iconUse("add")}</button>
                    </div>                    
                    <div class='tools'>
                      <button type="button" class='remove' data-index='${index2}' title="Remove Item">${iconUse("remove2")}</button>
                    </div>
                  </div>
                </div>
            </div>
            `;
    });
  }
  modifyBackgroundImage() {
    var value = CSS_TO_STRING(BackgroundImage.toProperty(this.state.images));
    this.parent.trigger(this.props.onchange, this.props.key, value);
  }
  makeGradient(type) {
    switch (type) {
      case "static-gradient":
        return `static-gradient(black)`;
      case "linear-gradient":
        return `linear-gradient(90deg, white 0%, black 100%)`;
      case "repeating-linear-gradient":
        return `repeating-linear-gradient(90deg, white 2%, black 4%)`;
      case "radial-gradient":
        return `radial-gradient(circle, white 0%, black 100%)`;
      case "repeating-radial-gradient":
        return `repeating-radial-gradient(circle, white 2%, black 4%)`;
      case "conic-gradient":
        return `conic-gradient(white 0%, black 100%)`;
      case "repeating-conic-gradient":
        return `repeating-conic-gradient(white 50%, black 100%)`;
    }
  }
  [SUBSCRIBE("add")](gradientType) {
    this.state.images.unshift(new BackgroundImage({
      image: BackgroundImage.parseImage(this.makeGradient(gradientType))
    }));
    this.refresh();
    this.modifyBackgroundImage();
  }
  [CLICK("$add")]() {
    this.trigger("add");
  }
  [DRAGSTART("$fillList .fill-item > label")](e) {
    this.startIndex = +e.$dt.attr("data-index");
  }
  [DRAGOVER("$fillList .fill-item") + PREVENT]() {
  }
  sortItem(arr, startIndex, targetIndex) {
    arr.splice(targetIndex + (startIndex < targetIndex ? -1 : 0), 0, ...arr.splice(startIndex, 1));
  }
  sortBackgroundImage(startIndex, targetIndex) {
    this.sortItem(this.state.images, startIndex, targetIndex);
  }
  [DROP("$fillList .fill-item") + PREVENT](e) {
    var targetIndex = +e.$dt.attr("data-index");
    this.selectItem(this.startIndex, true);
    this.sortBackgroundImage(this.startIndex, targetIndex);
    this.refresh();
    this.modifyBackgroundImage();
  }
  getCurrentBackgroundImage() {
    return this.state.images[this.selectedIndex];
  }
  [CLICK("$fillList .tools .remove")](e) {
    var removeIndex = +e.$dt.attr("data-index");
    this.state.images.splice(removeIndex, 1);
    this.refresh();
    this.modifyBackgroundImage();
  }
  [CLICK("$fillList .tools .visibility")](e) {
    var index2 = +e.$dt.attr("data-index");
    this.state.images[index2].visibility = this.state.images[index2].visibility === VisibilityType.HIDDEN ? VisibilityType.VISIBLE : VisibilityType.HIDDEN;
    this.refresh();
    this.modifyBackgroundImage();
  }
  [CLICK("$fillList .tools .copy")](e) {
    var index2 = +e.$dt.attr("data-index");
    const current = this.state.images[index2];
    this.state.images.splice(index2, 0, current);
    this.refresh();
    this.modifyBackgroundImage();
  }
  selectItem(selectedIndex, isSelected = true) {
    if (isSelected) {
      this.refs[`fillIndex${selectedIndex}`].addClass("selected");
    } else {
      this.refs[`fillIndex${selectedIndex}`].removeClass("selected");
    }
    this.state.images.forEach((it, index2) => {
      it.selected = index2 === selectedIndex;
    });
  }
  [SUBSCRIBE("selectFillPopupTab")](type) {
    var typeName = types[type];
    var $fillItem = this.refs[`fillIndex${this.selectedIndex}`];
    $fillItem.attr("data-fill-type", typeName);
  }
  [SUBSCRIBE_SELF("changeRangeEditor")](key, value, params) {
    this.trigger("changePattern", key, { [key]: value }, params);
  }
  [SUBSCRIBE_SELF("changePattern")](key, value, params) {
    var index2 = +params;
    var image2 = this.state.images[index2];
    image2.reset(value);
    this.modifyBackgroundImage();
    this.refresh();
  }
}
var BackgroundImagePositionPopup$1 = "";
class BackgroundImagePositionPopup extends BasePopup {
  get localeKey() {
    return "background.image.position.popup";
  }
  getTitle() {
    return this.$i18n("title");
  }
  initState() {
    return {
      size: this.props.size || "auto",
      repeat: this.props.repeat || "repeat",
      x: this.props.x || 0,
      y: this.props.y || 0,
      width: this.props.width || 0,
      height: this.props.height || 0,
      blendMode: this.props.blendMode
    };
  }
  updateData(opt = {}) {
    this.setState(opt, false);
    this.emit(this.state.changeEvent, opt, this.state.params);
  }
  templateForSize() {
    return createComponent("SelectEditor", {
      label: this.$i18n("size"),
      ref: "$size",
      key: "size",
      value: this.state.size,
      options: ["contain", "cover", "auto"],
      onchange: "changeRangeEditor"
    });
  }
  [SUBSCRIBE_SELF("changeRangeEditor")](key, value) {
    this.updateData({ [key]: value });
  }
  templateForX() {
    return createComponent("InputRangeEditor", {
      label: "X",
      compact: true,
      ref: "$x",
      key: "x",
      value: this.state.x,
      min: -1e3,
      max: 1e3,
      step: 1,
      onchange: "changeRangeEditor"
    });
  }
  templateForY() {
    return createComponent("InputRangeEditor", {
      label: "Y",
      compact: true,
      ref: "$y",
      key: "y",
      value: this.state.y,
      min: -1e3,
      max: 1e3,
      step: 1,
      onchange: "changeRangeEditor"
    });
  }
  templateForWidth() {
    return createComponent("InputRangeEditor", {
      label: "W",
      compact: true,
      ref: "$width",
      key: "width",
      value: this.state.width,
      min: 0,
      max: 500,
      step: 1,
      onchange: "changeRangeEditor"
    });
  }
  templateForHeight() {
    return createComponent("InputRangeEditor", {
      label: "H",
      compact: true,
      ref: "$height",
      key: "height",
      value: this.state.height,
      min: 0,
      max: 500,
      step: 1,
      onchange: "changeRangeEditor"
    });
  }
  templateForRepeat() {
    return `
    <div class='grid'>
      <label>${this.$i18n("repeat")}</label>
    </div>
    <div class='repeat-list' ref="$repeat" data-value='${this.state.repeat}'>
        <button type="button" value='no-repeat' title="${this.$i18n("type.no-repeat")}"></button>
        <button type="button" value='repeat' title="${this.$i18n("type.repeat")}"></button>
        <button type="button" value='repeat-x' title="${this.$i18n("type.repeat-x")}"></button>
        <button type="button" value='repeat-y' title="${this.$i18n("type.repeat-y")}"></button>
        <button type="button" value='space' title="${this.$i18n("type.space")}"></button>
        <button type="button" value='round' title="${this.$i18n("type.round")}"></button>
    </div>
    `;
  }
  [CLICK("$repeat button")]({ $dt: $t }) {
    this.refs.$repeat.attr("data-value", $t.value);
    this.updateData({ repeat: $t.value });
  }
  getBody() {
    return `
      <div class="elf--background-image-position-picker" ref='$picker'></div>
    `;
  }
  [LOAD("$picker") + DOMDIFF]() {
    return `
      
      <div class='box'>

        <div class='background-property'>
          ${this.templateForSize()}      
          ${this.templateForX()}
          ${this.templateForY()}
          ${this.templateForWidth()}
          ${this.templateForHeight()}
          ${this.templateForRepeat()}
        </div>
      </div>
    `;
  }
  [SUBSCRIBE("showBackgroundImagePositionPopup")](data, params, rect2) {
    this.state.changeEvent = data.changeEvent || "changeFillPopup";
    this.state.params = params;
    this.setState(data.data);
    this.showByRect(this.makeRect(180, 310, rect2));
  }
}
var BackgroundImageProperty$1 = "";
class BackgroundImageProperty extends BaseProperty {
  getTitle() {
    return this.$i18n("background.image.property.title");
  }
  afterRender() {
    this.show();
  }
  getClassName() {
    return "background-image";
  }
  getBodyClassName() {
    return "no-padding";
  }
  getBody() {
    return /* @__PURE__ */ createElementJsx("div", {
      class: "full",
      ref: "$property"
    });
  }
  getTools() {
    return /* @__PURE__ */ createElementJsx("div", {
      class: "fill-sample-list",
      ref: "$add"
    }, /* @__PURE__ */ createElementJsx("button", {
      type: "button",
      class: "fill",
      "data-value": "static-gradient"
    }, iconUse("add")));
  }
  [CLICK("$add [data-value]")](e) {
    this.children.$backgroundImageEditor.trigger("add", e.$dt.data("value"));
  }
  [LOAD("$property")]() {
    var current = this.$context.selection.current || {};
    var value = current.backgroundImage || "";
    return createComponent("BackgroundImageEditor", {
      ref: "$backgroundImageEditor",
      key: "backgroundImage",
      value,
      onchange: "changeBackgroundImage"
    });
  }
  get editableProperty() {
    return "backgroundImage";
  }
  [SUBSCRIBE(REFRESH_SELECTION) + IF("checkShow")]() {
    this.refresh();
  }
  checkCurrentItem(item) {
    return this.$context.selection.current === item;
  }
  [SUBSCRIBE(UPDATE_CANVAS) + IF("checkCurrentItem") + DEBOUNCE(100)]() {
    if (this.$context.selection.current) {
      if (this.$context.selection.hasChangedField("backgroundImage")) {
        this.refresh();
      }
    }
  }
  [SUBSCRIBE_SELF("changeBackgroundImage")](key, value) {
    this.$commands.executeCommand("setAttribute", "change background image", this.$context.selection.packByValue({
      [key]: value
    }));
  }
}
var BackgroundPositionEditor$1 = "";
class BackgroundPositionEditor extends EditorElement {
  initState() {
    return {
      index: this.props.index,
      x: this.props.x,
      y: this.props.y,
      width: this.props.width,
      height: this.props.height,
      repeat: this.props.repeat,
      size: this.props.size,
      blendMode: this.props.blendMode
    };
  }
  updateData(opt = {}) {
    this.setState(opt, false);
    this.modifyValue(opt);
  }
  modifyValue(value) {
    this.parent.trigger(this.props.onchange, this.props.key, value, this.state.index);
  }
  setValue(obj2) {
    this.setState(__spreadValues({}, obj2));
  }
  [BIND("$miniView")]() {
    return {
      style: {
        "background-image": "linear-gradient(to top right, black, white)",
        "background-repeat": this.state.repeat,
        "background-size": "10px 10px"
      }
    };
  }
  template() {
    return `
            <div class='elf--background-position-editor'>
                <div class='preview' ref='$preview'>
                    <div class='mini-view'>
                        <div class='color-view' ref='$miniView'></div>
                    </div>
                </div>
            </div>
        `;
  }
  [CLICK("$preview")]() {
    this.viewBackgroundPositionPopup();
  }
  viewBackgroundPositionPopup() {
    this.emit("showBackgroundImagePositionPopup", {
      changeEvent: "changeBackgroundPositionPattern",
      data: this.state
    }, {
      id: this.id
    }, this.$el.rect());
  }
  [SUBSCRIBE("changeBackgroundPositionPattern")](pattern, params) {
    if (params.id === this.id) {
      this.updateData(__spreadValues({}, pattern));
    }
  }
}
function backgroundImage(editor) {
  editor.registerElement({
    BackgroundImageEditor,
    BackgroundPositionEditor
  });
  editor.registerUI("inspector.tab.style", {
    BackgroundImageProperty
  });
  editor.registerUI("popup", {
    BackgroundImagePositionPopup
  });
}
var BorderEditor$1 = "";
var BorderStyles = {
  none: true,
  hidden: true,
  dotted: true,
  dashed: true,
  solid: true,
  double: true,
  groove: true,
  ridge: true,
  inset: true,
  outset: true
};
class Border {
  static parseStyle(str) {
    return STRING_TO_CSS(str);
  }
  static parseValue(str = "") {
    var style = "";
    var width2 = "";
    var color2 = "";
    str.split(" ").filter((it) => it.trim()).forEach((value) => {
      if (BorderStyles[value]) {
        style = value;
      } else if (isColor(value)) {
        color2 = value;
      } else {
        width2 = Length.parse(value).value;
      }
    });
    return {
      style,
      color: color2,
      width: width2
    };
  }
  static joinValue(obj2) {
    return `${obj2.width}px ${obj2.style || "solid"} ${obj2.color}`;
  }
  static join(obj2) {
    var arr = [
      obj2["border"] ? `border: ${obj2["border"]}` : "",
      obj2["border-top"] ? `border-top: ${obj2["border-top"]}` : "",
      obj2["border-left"] ? `border-left: ${obj2["border-left"]}` : "",
      obj2["border-right"] ? `border-right: ${obj2["border-right"]}` : "",
      obj2["border-bottom"] ? `border-bottom: ${obj2["border-bottom"]}` : ""
    ].filter((it) => it);
    return arr.join(";");
  }
}
const borderTypeList = [
  "border"
];
const borderTypeTitle = {
  border: "all",
  "border-top": "top",
  "border-right": "right",
  "border-bottom": "bottom",
  "border-left": "left"
};
class BorderEditor extends EditorElement {
  initState() {
    var borders = Border.parseStyle(this.props.value);
    var direction2 = Object.keys(borders)[0] || "border";
    return {
      direction: direction2,
      borders
    };
  }
  updateData(obj2) {
    this.setState(obj2, false);
    this.parent.trigger(this.props.onchange, this.props.key, this.getValue(), this.props.params);
  }
  getValue() {
    return Border.join(this.state.borders);
  }
  setValue(value) {
    this.state.borders = Border.parseStyle(value);
    this.refresh();
  }
  [LOAD("$editorArea")]() {
    return borderTypeList.map((type) => {
      var label = borderTypeTitle[type] || type;
      label = this.$i18n("border.editor." + label);
      return `
      <div>
        ${createComponent("BorderValueEditor", {
        ref: `$${type}`,
        label,
        key: type,
        value: this.state.borders[type],
        onchange: "changeKeyValue"
      })}
      </div>
      `;
    });
  }
  template() {
    return `
      <div class="elf--border-editor">
        <div class='editor-area' ref='$editorArea'>

        </div>
      </div>
    `;
  }
  [SUBSCRIBE_SELF("changeKeyValue")](key, value) {
    var borders = this.state.borders;
    borders[key] = value;
    this.updateData({ borders });
  }
}
var BorderProperty$1 = "";
class BorderProperty extends BaseProperty {
  getTitle() {
    return this.$i18n("border.property.title");
  }
  getBody() {
    return `<div class="property-item full border-item" ref='$body'></div>`;
  }
  [LOAD("$body")]() {
    var current = this.$context.selection.current || {};
    var value = current.border || "";
    return createComponent("BorderEditor", {
      ref: "$1",
      key: "border",
      value,
      onchange: "changeKeyValue"
    });
  }
  get editableProperty() {
    return "border";
  }
  [SUBSCRIBE(REFRESH_SELECTION) + DEBOUNCE(100) + IF("checkShow")]() {
    this.refresh();
  }
  [SUBSCRIBE_SELF("changeKeyValue")](key, value) {
    this.$commands.executeCommand("setAttribute", "change border", this.$context.selection.packByValue({
      [key]: value
    }));
  }
}
var BorderValueEditor$1 = "";
const borderStyleList = [
  BorderStyle.NONE,
  BorderStyle.HIDDEN,
  BorderStyle.SOLID,
  BorderStyle.DASHED,
  BorderStyle.DOTTED,
  BorderStyle.DOUBLE,
  BorderStyle.GROOVE,
  BorderStyle.RIDGE,
  BorderStyle.INSET,
  BorderStyle.OUTSET
].join(",");
class BorderValueEditor extends EditorElement {
  initState() {
    return {
      value: Border.parseValue(this.props.value)
    };
  }
  updateData(obj2) {
    this.setState(obj2, false);
    this.parent.trigger(this.props.onchange, this.props.key, this.getValue(), this.props.params);
  }
  getValue() {
    return Border.joinValue(this.state.value);
  }
  setValue(value) {
    this.state.value = Border.parseValue(value);
    this.refresh();
  }
  refresh() {
    const width2 = Length.parse(this.state.value.width === "undefined" ? 0 : this.state.value.width);
    this.children.$width.setValue(width2.value || 0);
    this.children.$style.setValue(this.state.value.style || "solid");
    this.children.$color.setValue(this.state.value.color || "rgba(0, 0, 0, 1)");
  }
  template() {
    var { width: width2, style, color: color2 } = this.state.value;
    return `
      <div class="elf--border-value-editor">
        <div class='editor-area'>
          ${createComponent("NumberInputEditor", {
      label: iconUse("line_weight"),
      compact: true,
      ref: "$width",
      min: 0,
      max: 100,
      step: 1,
      key: "width",
      value: width2,
      onchange: "changeKeyValue"
    })}
          ${createComponent("SelectEditor", {
      ref: "$style",
      key: "style",
      label: iconUse("line_style"),
      title: "Style",
      compact: true,
      options: borderStyleList,
      value: style || "solid",
      onchange: "changeKeyValue"
    })}
          ${createComponent("ColorViewEditor", {
      ref: "$color",
      key: "color",
      mini: true,
      value: color2 || "rgba(0, 0, 0, 1)",
      onchange: "changeKeyValue"
    })}
        </div>
      </div>
    `;
  }
  [SUBSCRIBE_SELF("changeKeyValue")](key, v) {
    var value = this.state.value;
    value[key] = v;
    this.updateData({ value });
  }
}
function border(editor) {
  editor.registerElement({
    BorderEditor,
    BorderValueEditor
  });
  editor.registerUI("inspector.tab.style", {
    BorderProperty
  });
}
const typeList$1 = [
  { key: "top", title: "Top" },
  { key: "bottom", title: "Bottom" },
  { key: "left", title: "Left" },
  { key: "right", title: "Right" }
];
const keyList$1 = typeList$1.map((it) => it.key);
const names = {
  image: "Image",
  "static-gradient": "Static",
  "linear-gradient": "Linear",
  "repeating-linear-gradient": `${obj$2.repeat} Linear`,
  "radial-gradient": "Radial",
  "repeating-radial-gradient": `${obj$2.repeat} Radial`,
  "conic-gradient": "Conic",
  "repeating-conic-gradient": `${obj$2.repeat} Conic`
};
class BorderImageProperty extends BaseProperty {
  getTitle() {
    return "Border Image";
  }
  [SUBSCRIBE(REFRESH_SELECTION)]() {
    this.refresh();
  }
  getTools() {
    var current = this.$context.selection.current || {};
    var appliedBorderImage = current.appliedBorderImage || false;
    return `
      <label><input type='checkbox' ${appliedBorderImage ? "checked" : ""} ref='$apply' /> Apply</label>
    `;
  }
  [CLICK("$apply")]() {
    var current = this.$context.selection.current;
    if (!current)
      return;
    var applyBorderImage = this.refs.$apply.checked();
    this.$commands.executeCommand("setAttribute", this.$context.selection.packByValue({
      applyBorderImage
    }));
  }
  getColorStepList(image2) {
    switch (image2.type) {
      case "static-gradient":
      case "linear-gradient":
      case "repeating-linear-gradient":
      case "radial-gradient":
      case "repeating-radial-gradient":
      case "conic-gradient":
      case "repeating-conic-gradient":
        return this.getColorStepString(image2.colorsteps);
    }
    return "";
  }
  getColorStepString(colorsteps) {
    return colorsteps.map((step2) => {
      return `<div class='step' data-colorstep-id="${step2.id}" data-selected='${step2.selected}' style='background-color:${step2.color};'></div>`;
    }).join("");
  }
  [LOAD("$borderImageView")]() {
    var current = this.$context.selection.current || {
      borderImage: { image: {} }
    };
    var borderImage2 = current.borderImage;
    var backgroundTypeName = borderImage2.type ? names[borderImage2.type] : "";
    const imageCSS = `background-image: ${borderImage2.image.toString()}; background-size: cover;`;
    return ` 
      <div class='preview' ref="$preview">
        <div class='mini-view'>
          <div class='color-view'  style="${imageCSS}" ref="$miniView"></div>
        </div>
      </div> 
      <div class='fill-info'>
        <div class='gradient-info'>
          <div class='fill-title' ref="$fillTitle">${backgroundTypeName}</div>
          <div class='colorsteps' ref="$colorsteps">
            ${this.getColorStepList(borderImage2.image)}
          </div>
        </div>
      </div>
    `;
  }
  [SUBSCRIBE_SELF("changeBorderImage")](key, value) {
    if (key === "border-image-slice") {
      keyList$1.forEach((type) => {
        this.children[`$${type}Slice`].setValue(value);
      });
    }
    this.setBorderImageProperty();
  }
  getBody() {
    return `
      <div class="property-item border-image-item" ref='$borderImageView'></div>    
      <div class="property-item border-slice-item">
        <div class="slice-selector" data-selected-value="all" ref="$selector">
          <button type="button" data-value="all">${obj$2.border_all}</button>
          <button type="button" data-value="partitial">
            ${obj$2.border_inner}
          </button>
        </div>
        <div class="slice-value">
          ${createComponent("RangeEditor", {
      ref: "$allSlice",
      key: "border-image-slice",
      onchange: "changeBorderImage"
    })}
        </div>
      </div>
      <div
        class="property-item border-slice-item full has-list"
        ref="$partitialSetting"
        style="display: none;"
      >
        <div class="slice-setting-box" ref="$sliceSettingBox">
          ${typeList$1.map((it) => {
      return `
              <div>
                <label class='title'>${it.title}</label>
              </div>
              <div>
                ${createComponent("RangeEditor", {
        ref: `$${it.key}Slice`,
        label: "Slice",
        key: `border-image-slice-${it.key}`,
        onchange: "changeBorderImage"
      })}
              </div>  
              <div>
                ${createComponent("RangeEditor", {
        ref: `$${it.key}Width`,
        label: "Width",
        key: `border-image-width-${it.key}`,
        onchange: "changeBorderImage"
      })}              
              </div>                
            `;
    }).join("")}
        </div>
      </div>
    `;
  }
  [CHANGE("$sliceSettingBox select")]() {
    this.setBorderImageProperty();
  }
  [CLICK("$borderImageView .preview")]() {
    this.viewFillPopup(this.refs.$preview, "");
  }
  [CLICK("$borderImageView .colorsteps .step")](e) {
    this.refs.$colorsteps.$(`[data-selected="true"]`).removeAttr("data-selected");
    var selectColorStepId = e.$dt.attr("data-colorstep-id");
    e.$dt.attr("data-selected", true);
    var $preview = e.$dt.closest("border-image-item").$(".preview");
    this.viewFillPopup($preview, selectColorStepId);
  }
  getFillData(borderImage2) {
    let data = {
      type: borderImage2.type
    };
    switch (data.type) {
      case "image":
        data.url = borderImage2.image ? borderImage2.image.url : "";
        break;
      default:
        if (borderImage2.image) {
          const image2 = borderImage2.image;
          data.type = image2.type;
          data.colorsteps = [...image2.colorsteps];
          data.angle = image2.angle;
          data.radialType = image2.radialType || "ellipse";
          data.radialPosition = image2.radialPosition || Position.CENTER;
        } else {
          data.colorsteps = [];
          data.angle = 0;
          data.radialType = "ellipse";
          data.radialPosition = Position.CENTER;
        }
        break;
    }
    return data;
  }
  viewFillPopup($preview, selectColorStepId) {
    var current = this.$context.selection.current;
    if (!current)
      return;
    this.emit("showFillPopup", __spreadProps(__spreadValues({
      changeEvent: "changeBorderImageFillPopup"
    }, this.getFillData(current.borderImage)), {
      selectColorStepId,
      refresh: true
    }));
  }
  viewChangeImage() {
    var current = this.$context.selection.current;
    if (!current)
      return;
    var borderImage2 = current.borderImage;
    if (!borderImage2)
      return;
    var $el = this.getRef("$miniView");
    if ($el && borderImage2.image) {
      $el.css({
        "background-image": borderImage2.image.toString(),
        "background-size": "cover"
      });
    }
    var $el = this.getRef("$fillTitle");
    if ($el) {
      $el.html(names["image"]);
    }
    var $el = this.getRef("$colorsteps", this.selectedIndex);
    if ($el) {
      $el.empty();
    }
  }
  setImage(data) {
    var current = this.$context.selection.current;
    if (!current)
      return;
    current.borderImage.setImageUrl(data);
    this.viewChangeImage(data);
    this.$commands.executeCommand("setAttribute", this.$context.selection.pack("borderImage"));
  }
  viewChangeGradient(data) {
    var current = this.$context.selection.current;
    if (!current)
      return;
    var borderImage2 = current.borderImage;
    if (!borderImage2)
      return;
    var $el = this.getRef("$miniView");
    if ($el) {
      $el.css({
        "background-image": borderImage2.image.toString(),
        "background-size": "cover"
      });
    }
    var $el = this.getRef("$fillTitle");
    if ($el) {
      $el.html(names[data.type]);
    }
    var $el = this.getRef("$colorsteps", this.selectedIndex);
    if ($el) {
      $el.html(this.getColorStepString(data.colorsteps));
    }
  }
  setGradient(data) {
    var current = this.$context.selection.current;
    if (!current)
      return;
    current.borderImage.setGradient(data);
    this.viewChangeGradient(data);
    this.$commands.executeCommand("setAttribute", this.$context.selection.pack("borderImage"));
  }
  [SUBSCRIBE("changeBorderImageFillPopup")](data) {
    switch (data.type) {
      case "image":
        this.setImage(data);
        break;
      default:
        this.setGradient(data);
        break;
    }
  }
  setBorderImageProperty() {
    var current = this.$context.selection.current;
    if (!current)
      return;
    var borderImage2 = current.borderImage;
    var type = this.refs.$selector.attr("data-selected-value");
    if (type === "all") {
      var len2 = this.children.$allSlice.getValue();
      borderImage2.reset({
        slice: {
          top: len2.clone(),
          right: len2.clone(),
          bottom: len2.clone(),
          left: len2.clone()
        }
      });
    } else {
      keyList$1.forEach((type2) => {
        borderImage2.slice[type2] = this.children[`$${type2}Slice`].getValue();
        borderImage2.width[type2] = this.children[`$${type2}Width`].getValue();
      });
    }
    this.$commands.executeCommand("setAttribute", this.$context.selection.pack("borderImage"));
  }
  [CLICK("$selector button")](e) {
    var type = e.$dt.attr("data-value");
    this.refs.$selector.attr("data-selected-value", type);
    if (type === "all") {
      this.refs.$partitialSetting.hide();
    } else {
      this.refs.$partitialSetting.show("grid");
    }
    this.setBorderImageProperty();
  }
}
function borderImage(editor) {
  editor.registerElement({
    BorderImageProperty
  });
}
var BorderRadiusEditor$1 = "";
class BorderRadius {
  static parseStyle(str = "") {
    var obj2 = {
      isAll: true,
      "border-radius": 0,
      "border-top-left-radius": 0,
      "border-top-right-radius": 0,
      "border-bottom-right-radius": 0,
      "border-bottom-left-radius": 0
    };
    var arr = str.split(" ").map((it) => Length.parse(it));
    if (arr.length === 1) {
      obj2.isAll = true;
      obj2["border-radius"] = arr[0];
    } else {
      obj2.isAll = false;
      obj2["border-top-left-radius"] = arr[0];
      obj2["border-top-right-radius"] = arr[1];
      obj2["border-bottom-right-radius"] = arr[2];
      obj2["border-bottom-left-radius"] = arr[3];
      if (arr[0].equals(arr[1]) && arr[0].equals(arr[2]) && arr[0].equals(arr[3])) {
        obj2.isAll = true;
        obj2["border-radius"] = arr[0];
      }
    }
    return obj2;
  }
}
const typeList = [
  { key: "border-top-left-radius", title: "topLeft", label: "TL" },
  { key: "border-top-right-radius", title: "topRight", label: "TR" },
  { key: "border-bottom-left-radius", title: "bottomLeft", label: "BL" },
  { key: "border-bottom-right-radius", title: "bottomRight", label: "BR" }
];
const keyList = typeList.map((it) => it.key);
const BorderGroup = {
  ALL: "all",
  PARTITIAL: "partial"
};
class BorderRadiusEditor extends EditorElement {
  initState() {
    return __spreadValues({}, BorderRadius.parseStyle(this.props.value));
  }
  template() {
    return `<div class='elf--border-radius-editor' ref='$body'></div>`;
  }
  [SUBSCRIBE_SELF("changeBorderRadius")](key, value) {
    if (key === "border-radius") {
      keyList.forEach((type) => {
        this.children[`$${type}`].setValue(value.clone());
      });
    }
    this.setBorderRadius();
  }
  [LOAD("$body") + DOMDIFF]() {
    var borderRadius2 = this.state["border-radius"];
    return `
      <div class="border-radius-item">
        <div class="radius-value">
          ${createComponent("InputRangeEditor", {
      label: iconUse("outline_rect"),
      ref: "$all",
      compact: "true",
      key: "border-radius",
      value: borderRadius2,
      min: 0,
      onchange: "changeBorderRadius"
    })}
        </div>
        <div></div>
        ${createComponent("ToggleButton", {
      compact: true,
      ref: "$toggle",
      key: "border-all",
      checkedValue: BorderGroup.PARTITIAL,
      value: BorderGroup.ALL,
      toggleLabels: [iconUse("border_inner"), iconUse("border_inner")],
      toggleValues: [BorderGroup.ALL, BorderGroup.PARTITIAL],
      onchange: "changeKeyValue"
    })}
      </div>
      <div
        class="full border-radius-item"
        ref="$partitialSetting"
        style="display: none;"
      >
        <div class="radius-setting-box" ref="$radiusSettingBox">
          <div>
            ${typeList.map((it) => {
      var value = this.state[it.key];
      var title2 = this.$i18n("border.radius.editor." + it.title);
      var label = it.label;
      return `
                <div>
                  ${createComponent("InputRangeEditor", {
        compact: true,
        ref: `$${it.key}`,
        label,
        title: title2,
        key: it.key,
        value,
        min: 0,
        step: 1,
        onchange: "changeBorderRadius"
      })}
                </div>  
              `;
    }).join("")}
          </div>
        </div>
      </div>
    `;
  }
  [INPUT("$radiusSettingBox input")]() {
    this.setBorderRadius();
  }
  [CHANGE("$radiusSettingBox select")]() {
    this.setBorderRadius();
  }
  setBorderRadius() {
    var type = this.selectedValue;
    if (type === BorderGroup.ALL) {
      this.state["border-radius"] = this.children[`$all`].getValue();
    } else {
      keyList.forEach((key) => {
        this.state[key] = this.children[`$${key}`].getValue();
      });
    }
    this.modifyBorderRadius();
  }
  modifyBorderRadius() {
    var value = "";
    if (this.selectedValue === BorderGroup.ALL) {
      value = this.state["border-radius"] + "";
    } else {
      value = keyList.map((key) => `${this.state[key]}`).join(" ");
    }
    this.parent.trigger(this.props.onchange, value);
  }
  [SUBSCRIBE_SELF("changeKeyValue")](key, value) {
    const type = value;
    if (type === BorderGroup.PARTITIAL) {
      this.selectedValue = BorderGroup.PARTITIAL;
      this.refs.$partitialSetting.show();
    } else {
      this.selectedValue = BorderGroup.ALL;
      this.refs.$partitialSetting.hide();
    }
    this.setBorderRadius();
  }
}
class BorderRadiusProperty extends BaseProperty {
  getTitle() {
    return this.$i18n("border.radius.property.title");
  }
  getBody() {
    return `<div class="property-item full border-radius-item" ref='$body'></div>`;
  }
  [LOAD("$body")]() {
    var current = this.$context.selection.current || {};
    var value = current.borderRadius || "0px";
    return createComponent("BorderRadiusEditor", {
      ref: "$1",
      value,
      onchange: "changeBorderRadius"
    });
  }
  get editableProperty() {
    return "borderRadius";
  }
  [SUBSCRIBE(REFRESH_SELECTION) + DEBOUNCE(100) + IF("checkShow")]() {
    if (this.$context.selection.hasChangedField("borderRadius")) {
      this.refresh();
    }
  }
  [SUBSCRIBE_SELF("changeBorderRadius")](value) {
    this.$commands.executeCommand("setAttribute", "change border radius", this.$context.selection.packByValue({
      borderRadius: value
    }));
  }
}
function borderRadius(editor) {
  editor.registerElement({
    BorderRadiusEditor
  });
  editor.registerUI("inspector.tab.style", {
    BorderRadiusProperty
  });
}
var BoxModelProperty$1 = "";
const fields = ["margin", "padding"];
let styleKeys = [];
fields.forEach((field) => {
  styleKeys.push.apply(styleKeys, ["-top", "-bottom", "-left", "-right"].map((it) => field + it));
});
class BoxModelProperty extends BaseProperty {
  getTitle() {
    return this.$i18n("box.model.property.title");
  }
  get editableProperty() {
    return "boxModel";
  }
  [SUBSCRIBE(REFRESH_SELECTION) + DEBOUNCE(100) + IF("checkShow")]() {
    this.refresh();
  }
  checkCurrentItem(item) {
    return this.$context.selection.current === item;
  }
  [SUBSCRIBE(UPDATE_CANVAS) + IF("checkCurrentItem") + DEBOUNCE(100)]() {
    const current = this.$context.selection.current;
    if (current == null ? void 0 : current.hasChangedField("padding-left", "padding-right", "padding-top", "padding-bottom")) {
      this.refresh();
    }
  }
  getBody() {
    return `<div class="property-item elf--box-model-item" ref="$boxModelItem"></div>`;
  }
  templateInput(key, current) {
    var value = Length.parse(current[key] || 0);
    return `<input type="number" ref="$${key}" value="${value.value}" tabIndex="1" />`;
  }
  [LOAD("$boxModelItem") + DOMDIFF]() {
    var current = this.$context.selection.current;
    if (!current)
      return "";
    return `
      <div>
        <div class="margin" data-title="${this.$i18n("box.model.property.margin")}">
          <div data-value="top">
            ${this.templateInput("margin-top", current)}
          </div>
          <div data-value="bottom">
            ${this.templateInput("margin-bottom", current)}
          </div>
          <div data-value="left">
            ${this.templateInput("margin-left", current)}
          </div>
          <div data-value="right">
            ${this.templateInput("margin-right", current)}
          </div>
        </div>
        <div class="padding" data-title="${this.$i18n("box.model.property.padding")}">
          <div data-value="top">
            ${this.templateInput("padding-top", current)}
          </div>
          <div data-value="bottom">
            ${this.templateInput("padding-bottom", current)}
          </div>
          <div data-value="left">
            ${this.templateInput("padding-left", current)}
          </div>
          <div data-value="right">
            ${this.templateInput("padding-right", current)}
          </div>
        </div>
        <div class='content' title='Content'>
        
        </div>
      </div>
    `;
  }
  [INPUT("$boxModelItem input")]() {
    this.resetBoxModel();
  }
  resetBoxModel() {
    var data = {};
    styleKeys.forEach((key) => {
      data[key] = this.refs["$" + key].value;
    });
    this.$commands.executeCommand("setAttribute", "change padding or margin", this.$context.selection.packByValue(data));
  }
}
function boxModel(editor) {
  editor.registerUI("inspector.tab.style", {
    BoxModelProperty
  });
}
var boxShadow$1 = [
  {
    name: "Box",
    shadows: [
      {
        offsetX: 0,
        offsetY: 3,
        blurRadius: 3,
        spreadRadius: 0,
        color: "rgba(0,0,0,0.2)"
      }
    ]
  },
  {
    name: "Shadow-4",
    shadows: [
      {
        offsetX: 0,
        offsetY: 1,
        blurRadius: 1,
        spreadRadius: 0,
        color: "rgba(0,0,0,0.15)"
      },
      {
        offsetX: 0,
        offsetY: 2,
        blurRadius: 2,
        spreadRadius: 0,
        color: "rgba(0,0,0,0.15)"
      },
      {
        offsetX: 0,
        offsetY: 4,
        blurRadius: 4,
        spreadRadius: 0,
        color: "rgba(0,0,0,0.15)"
      },
      {
        offsetX: 0,
        offsetY: 8,
        blurRadius: 8,
        spreadRadius: 0,
        color: "rgba(0,0,0,0.15)"
      }
    ]
  }
];
var BoxShadowProperty$1 = "";
class BoxShadowProperty extends BaseProperty {
  getTitle() {
    return this.$i18n("boxshadow.property.title");
  }
  getBody() {
    return `
      <div class="full box-shadow-item" ref="$shadowList"></div>
    `;
  }
  getTools() {
    return `
      <select class='box-shadow-samples' ref="$select">
      ${boxShadow$1.map((item, index2) => {
      return `
          <option value="${index2}">${item.name}</option>
        `;
    }).join("")}
      </select>
      <button type="button" ref='$add'>${obj$2.add}</button>
    `;
  }
  [CLICK("$add")]() {
    const index2 = +this.refs.$select.value;
    this.children.$boxshadow.trigger("add", boxShadow$1[index2].shadows);
  }
  [LOAD("$shadowList")]() {
    var current = this.$context.selection.current || {};
    return createComponent("BoxShadowEditor", {
      ref: "$boxshadow",
      key: "boxShadow",
      value: clone$1(current.boxShadow),
      onchange: (key, value) => {
        this.$commands.executeCommand("setAttribute", "change box shadow", this.$context.selection.packByValue({
          [key]: clone$1(value)
        }));
      }
    });
  }
  get editableProperty() {
    return "boxShadow";
  }
  [SUBSCRIBE(REFRESH_SELECTION) + DEBOUNCE(100) + IF("checkShow")]() {
    this.refresh();
  }
}
function boxShadow(editor) {
  editor.registerUI("inspector.tab.style", {
    BoxShadowProperty
  });
}
var polygon = {
  key: "polygon",
  title: "Polygon",
  execute: function() {
    return [
      { name: "Triangle", polygon: "50% 0%, 0% 100%, 100% 100%" },
      { name: "Trapezoid", polygon: "20% 0%, 80% 0%, 100% 100%, 0% 100%" },
      {
        name: "Parallelogram",
        polygon: "25% 0%, 100% 0%, 75% 100%, 0% 100%"
      },
      {
        name: "Rhombus",
        polygon: "50% 0%, 100% 50%, 50% 100%, 0% 50%"
      },
      {
        name: "Pentagon",
        polygon: "50% 0%, 100% 38%, 82% 100%, 18% 100%, 0% 38%"
      },
      {
        name: "Hexagon",
        polygon: "50% 0%, 100% 25%, 100% 75%, 50% 100%, 0% 75%, 0% 25%"
      },
      {
        name: "Heptagon",
        polygon: "50% 0%, 90% 20%, 100% 60%, 75% 100%, 25% 100%, 0% 60%, 10% 20%"
      },
      {
        name: "Octagon",
        polygon: "30% 0%, 70% 0%, 100% 30%, 100% 70%, 70% 100%, 30% 100%, 0% 70%, 0% 30%"
      }
    ];
  }
};
var ClipPathProperty$1 = "";
const CLIPPATH_REG = /(content-box|padding-box|border-box|margin-box|view-box|stroke-box|fill-box|none|(inset|circle|ellipse|polygon|path|svg|url)(\(([^)]*)\))?)/gi;
class ClipPath extends PropertyItem {
  getDefaultObject(obj2 = {}) {
    return super.getDefaultObject(__spreadValues({
      itemType: "clip-path",
      type: "none",
      value: ""
    }, obj2));
  }
  toCloneObject() {
    return __spreadValues(__spreadValues({}, super.toCloneObject()), this.attrs("value"));
  }
  toString() {
    var type = this.json.type;
    var value = this.json.value;
    var box = this.json.box;
    var results = "";
    switch (type) {
      case "circle":
      case "inset":
      case "ellipse":
      case "polygon":
      case "path":
        results = `${type}(${value})`;
        break;
      case "svg":
        results = `url(#${value})`;
        break;
      default:
        results = "none";
        break;
    }
    return box ? `${box} ${results}` : results;
  }
  toCSS() {
    return {
      "clip-path": this.toString()
    };
  }
  static toCSS(obj2) {
    return new ClipPath(obj2).toCSS();
  }
  static toString(obj2) {
    return ClipPath.toCSS(obj2)["clip-path"];
  }
  static parse(obj2) {
    return new ClipPath(obj2);
  }
  static parseStyle(str) {
    var clippath = {};
    if (!str)
      return {};
    var matches2 = str.match(CLIPPATH_REG) || [];
    matches2.forEach((value) => {
      if (value.includes("-box")) {
        clippath.box = value;
      } else {
        var [clipPathName, clipPathValue] = value.split("(");
        clipPathValue = clipPathValue || "";
        if (clipPathName === "none") {
          clipPathValue = "";
        } else {
          clipPathValue = clipPathValue.split(")")[0];
        }
        clippath.type = clipPathName;
        clippath.value = clipPathValue;
      }
    });
    return clippath;
  }
  static parseStyleForCircle(str = "50% at 50% 50%") {
    var radius = new Length("", "closest-side"), position2 = "";
    str = str || "50% at 50% 50%";
    if (str.includes("at")) {
      [radius, position2] = str.split("at").map((it) => it.trim());
    } else {
      position2 = str.trim();
    }
    var [x, y] = position2.split(" ");
    if (isUndefined(y)) {
      y = x;
    }
    radius = Length.parse(radius);
    x = Length.parse(x);
    y = Length.parse(y);
    return {
      radius,
      x,
      y
    };
  }
  static parseStyleForEllipse(str = "50% 50%") {
    var radius = `50% 50%`, position2 = "";
    str = str || "50%";
    if (str.includes("at")) {
      [radius, position2] = str.split("at").map((it) => it.trim());
    } else {
      position2 = str.trim();
    }
    var [x, y] = position2.split(" ");
    if (isUndefined(y)) {
      y = x;
    }
    x = Length.parse(x);
    y = Length.parse(y);
    var [radiusX, radiusY] = radius.split(" ");
    if (isUndefined(radiusY)) {
      radiusY = radiusX;
    }
    radiusX = Length.parse(radiusX);
    radiusY = Length.parse(radiusY);
    return {
      radiusX,
      radiusY,
      x,
      y
    };
  }
  static parseStyleForInset(str = "") {
    var [inset, round2] = str.split("round");
    var [_count, top2, right2, bottom2, left2] = DirectionLength.parse(inset);
    if (round2) {
      var [_roundCount, topRadius, rightRadius, bottomRadius, leftRadius] = DirectionLength.parse(round2);
    }
    return {
      isAll: _count === 1,
      top: top2,
      right: right2,
      bottom: bottom2,
      left: left2,
      round: round2,
      isAllRadius: _roundCount === 1,
      topRadius,
      rightRadius,
      bottomRadius,
      leftRadius
    };
  }
  static parseStyleForPolygon(str = "") {
    return str.split(",").filter((it) => it.trim()).map((it) => {
      var [x, y] = it.trim().split(" ");
      return {
        x: Length.parse(x),
        y: Length.parse(y)
      };
    });
  }
}
const ClipPathSample = {
  [ClipPathType.CIRCLE]: "circle(50% at 50% 50%)",
  [ClipPathType.ELLIPSE]: "ellipse(50% 50% at 50% 50%)",
  [ClipPathType.INSET]: "inset(0% 0% 0% 0%)",
  [ClipPathType.POLYGON]: "polygon(0% 0%, 100% 0%, 100% 100%, 0% 100%)",
  [ClipPathType.PATH]: "path()"
};
class ClipPathProperty extends BaseProperty {
  getTitle() {
    return this.$i18n("clippath.property.title");
  }
  getClassName() {
    return "clip-path-property";
  }
  getBody() {
    return `<div class='elf--clip-path-list' ref='$clippathList'></div>`;
  }
  getTools() {
    return `
      <div ref="$tools" class="add-tools">
        <button type="button" data-value='circle' data-tooltip="Circle">${iconUse("outline_circle")}</button>
        <button type="button" data-value='ellipse' data-tooltip="Ellipse">${iconUse("outline_circle", "scale(1 0.7) translate(0 5)")}</button>
        <button type="button" data-value='inset' data-tooltip="Inset">${iconUse("outline_rect")}</button>
        <button type="button" data-value='polygon' data-tooltip="Polygon">${iconUse("polygon")}</button>
        <button type="button" data-value='path' data-tooltip="Path">${iconUse("pentool")}</button>
        <button type="button" data-value='svg' data-tooltip="SVG">${iconUse("image")}</button>
      </div>
    `;
  }
  makeClipPathTemplate(clippath, func) {
    const isPath = clippath === "path";
    const isPolygon = clippath === "polygon";
    let newPathString = "";
    if (isPath) {
      const pathString2 = func.split("(")[1].split(")")[0];
      let pathObject = PathParser.fromSVGString(pathString2);
      const bbox = pathObject.getBBox();
      const rectangle = vertiesToRectangle(bbox);
      const rate = 260 / rectangle.width;
      const hRate = 150 / rectangle.height;
      const lastRate = Math.min(rate, hRate);
      pathObject = pathObject.translate(-bbox[0][0], -bbox[0][1]).scale(lastRate, lastRate);
      const newBBox = pathObject.getBBox();
      const newRectangle = vertiesToRectangle(newBBox);
      newPathString = pathObject.translate(260 / 2 - newRectangle.width / 2, 0).d;
    }
    let polygonSelect = "";
    if (isPolygon) {
      const polygonList = polygon.execute();
      polygonSelect = createComponent("SelectEditor", {
        ref: "$polygonSelect",
        options: ["", ...polygonList.map((it) => it.name)],
        onchange: (key, value) => {
          const polygon2 = polygonList.find((it) => it.name === value);
          if (polygon2) {
            this.updatePathInfo({
              "clip-path": `polygon(${polygon2.polygon})`
            });
          }
        }
      });
    }
    return `
      <div>
        <div class='clippath-item'>
          <label>${iconUse("drag_indicator")}</label>
          <div class='title'>
            <div class='name'>${clippath}</div>
            ${isPolygon ? polygonSelect : ""}
          </div>
          <div class='tools'>
            <button type="button" class="del">${obj$2.remove2}</button>
          </div>        
        </div>
        ${isPath ? `<svg><path d="${newPathString}" fill="transparent" stroke="currentColor" /></svg>` : ""}
      </div>

    `;
  }
  [CLICK("$clippathList .clippath-item .title .name")]() {
    var current = this.$context.selection.current;
    if (!current)
      return;
    this.viewClipPathPicker();
  }
  [CLICK("$clippathList .del") + PREVENT]() {
    var current = this.$context.selection.current;
    if (!current)
      return;
    this.$commands.executeCommand("setAttribute", "delete clip-path", this.$context.selection.packByValue({
      clipPath: ""
    }));
    this.emit("hideClipPathPopup");
    window.setTimeout(() => {
      this.refresh();
    }, 100);
  }
  get editableProperty() {
    return "clipPath";
  }
  [SUBSCRIBE(REFRESH_SELECTION) + IF("checkShow")]() {
    this.refresh();
  }
  [LOAD("$clippathList")]() {
    var current = this.$context.selection.current;
    if (!current)
      return "";
    if (!current.clipPath)
      return "";
    return this.makeClipPathTemplate(current.clipPath.split("(")[0], current.clipPath);
  }
  [CLICK("$tools [data-value]")](e) {
    var current = this.$context.selection.current;
    if (!current)
      return;
    if (current.clipPath) {
      window.alert("clip-path is already exists.");
      return;
    }
    if (current) {
      current.reset({
        clipPath: ClipPathSample[e.$dt.data("value")]
      });
      this.$commands.executeCommand("setAttribute", "change clipPath", this.$context.selection.pack("clipPath"));
    }
    this.refresh();
  }
  viewClipPathPicker() {
    var current = this.$context.selection.current;
    if (!current)
      return;
    var obj2 = ClipPath.parseStyle(current.clipPath);
    switch (obj2.type) {
      case "path":
        var d = current.absolutePath(current.clipPathString).d;
        var mode = d ? "modify" : "path";
        this.emit("showPathEditor", mode, {
          changeEvent: (data) => {
            data.d = current.invertPath(data.d).d;
            this.updatePathInfo({
              clipPath: `path(${data.d})`
            });
          },
          current,
          d
        });
        break;
    }
  }
  updatePathInfo(data) {
    if (!data)
      return;
    var current = this.$context.selection.current;
    if (!current)
      return;
    current.reset(data);
    this.refresh();
    this.$commands.executeCommand("setAttribute", "change clipPath", this.$context.selection.packByValue(data));
  }
}
function clipPath(editor) {
  editor.registerUI("inspector.tab.style", {
    ClipPathProperty
  });
}
var ClippathEditorView$2 = "";
class ClippathPolygonEditorView extends EditorElement {
  initializePolygon() {
    const current = this.$context.selection.current;
    this.state.current = current;
    this.state.width = current.screenWidth;
    this.state.height = current.screenHeight;
    this.state.clippath = ClipPath.parseStyle(current["clip-path"]);
    this.state.clippath.value = ClipPath.parseStyleForPolygon(this.state.clippath.value);
    this.screenPoints = this.$viewport.applyVerties(vertiesMap(this.state.clippath.value.map((point2) => {
      const { x, y } = point2;
      const newX = x.toPx(this.state.width);
      const newY = y.toPx(this.state.height);
      return fromValues(newX, newY, 0);
    }), current.absoluteMatrix));
    this.clonedScreenPoints = clone$1(this.screenPoints);
  }
  [POINTERSTART("$el .polygon .polygon-pointer") + MOVE("movePolygonPointer") + END("moveEndPolygonPointer")](e) {
    this.initializePolygon();
    this.polygonTargetIndex = +e.$dt.data("index");
  }
  movePolygonPointer(dx, dy) {
    this.clonedScreenPoints[this.polygonTargetIndex] = add$1([], this.screenPoints[this.polygonTargetIndex], [dx, dy, 0]);
    this.updatePolygon(this.clonedScreenPoints);
  }
  moveEndPolygonPointer() {
    const value = ClipPath.toCSS(this.state.clippath);
    this.$commands.executeCommand("setAttribute", "change clippath", this.$context.selection.packByValue(value));
  }
  [POINTERSTART("$el .polygon .polygon-line")](e) {
    this.initializePolygon();
    const index2 = +e.$dt.data("index");
    this.polygonTargetIndex = index2;
    const current = this.screenPoints[this.polygonTargetIndex];
    const next = this.screenPoints[(this.polygonTargetIndex + 1) % this.screenPoints.length];
    const newPoint = lerp([], current, next, 0.5);
    this.screenPoints.splice(this.polygonTargetIndex + 1, 0, newPoint);
    this.updatePolygon(this.screenPoints);
  }
  updatePolygon(screenPoints) {
    const newWorldPoints = this.$viewport.applyVertiesInverse(screenPoints);
    const inverseMatrix = this.$context.selection.current.absoluteMatrixInverse;
    const newLocalPoints = vertiesMap(newWorldPoints, inverseMatrix);
    this.state.clippath.value = newLocalPoints.map((p) => {
      return [
        Length.makePercent(p[0], this.state.width),
        Length.makePercent(p[1], this.state.height)
      ].join(" ");
    }).join(",");
    const value = ClipPath.toCSS(this.state.clippath);
    this.$commands.emit("setAttribute", this.$context.selection.packByValue(value));
  }
  [POINTERSTART("$el .polygon .polygon-center") + MOVE("movePolygonCenter") + END("moveEndPolygonCenter")]() {
    this.initializePolygon();
  }
  movePolygonCenter(dx, dy) {
    const newScreenPoints = this.screenPoints.map((p) => {
      return add$1([], p, [dx, dy, 0]);
    });
    this.updatePolygon(newScreenPoints);
  }
  moveEndPolygonCenter(dx, dy) {
    if (dx == 0 && dy == 0) {
      switch (this.state.clippath.type) {
        case ClipPathType.POLYGON:
          const value2 = ClipPath.toCSS({
            type: ClipPathType.CIRCLE,
            value: `50% at 50% 50%`
          });
          this.$commands.executeCommand("setAttribute", "change clippath", this.$context.selection.packByValue(value2));
          break;
      }
      return;
    }
    const value = ClipPath.toCSS(this.state.clippath);
    this.$commands.executeCommand("setAttribute", "change clippath", this.$context.selection.packByValue(value));
  }
  templatePolygon(clippath) {
    const current = this.$context.selection.current;
    const points = ClipPath.parseStyleForPolygon(clippath.value).map((point2) => [
      point2.x.toPx(current.screenWidth).value,
      point2.y.toPx(current.screenHeight).value,
      0
    ]);
    const centerPoint = toRectVerties(points)[4];
    const screenPoints = this.$viewport.applyVerties(vertiesMap(points, current.absoluteMatrix));
    const screenCenter = this.$viewport.applyVerties(vertiesMap([centerPoint], current.absoluteMatrix))[0];
    return /* @__PURE__ */ createElementJsx("div", {
      class: "polygon"
    }, /* @__PURE__ */ createElementJsx("div", {
      class: "polygon-back"
    }, /* @__PURE__ */ createElementJsx("svg", {
      style: "position:absolute;width:100%;height:100%;"
    }, /* @__PURE__ */ createElementJsx("polygon", {
      points: `${screenPoints.map((it) => [it[0], it[1]].join(",")).join(" ")}`
    }), screenPoints.map((it, index2) => {
      const nextIndex = (index2 + 1) % screenPoints.length;
      const nextPoint = screenPoints[nextIndex];
      return /* @__PURE__ */ createElementJsx("line", {
        x1: it[0],
        y1: it[1],
        x2: nextPoint[0],
        y2: nextPoint[1],
        class: "polygon-line",
        "data-index": index2
      });
    }), screenPoints.map((it, index2) => {
      return /* @__PURE__ */ createElementJsx("circle", {
        cx: it[0],
        cy: it[1],
        r: 3,
        class: "polygon-pointer",
        "data-index": index2
      });
    }))), /* @__PURE__ */ createElementJsx("div", {
      class: "polygon-center",
      style: {
        left: Length.px(screenCenter[0]),
        top: Length.px(screenCenter[1])
      }
    }));
  }
}
class ClippathInsetEditorView extends ClippathPolygonEditorView {
  initializeInset() {
    const current = this.$context.selection.current;
    this.state.current;
    this.state.width = current.screenWidth;
    this.state.height = current.screenHeight;
    this.state.clippath = ClipPath.parseStyle(current["clip-path"]);
    this.state.clippath.value = ClipPath.parseStyleForInset(this.state.clippath.value);
    this.state.inset = this.state.clippath.value;
    const inset = this.state.inset;
    const top2 = inset.top.toPx(current.screenHeight);
    const left2 = inset.left.toPx(current.screenWidth);
    const right2 = Length.px(current.screenWidth - inset.right.toPx(current.screenWidth));
    const bottom2 = Length.px(current.screenHeight - inset.bottom.toPx(current.screenHeight));
    const verties = this.$viewport.applyVerties(vertiesMap([
      [left2, top2, 0],
      [right2, top2, 0],
      [right2, bottom2, 0],
      [left2, bottom2, 0]
    ], current.absoluteMatrix));
    const leftPoint = lerp([], verties[0], verties[3], 0.5);
    const topPoint = lerp([], verties[0], verties[1], 0.5);
    const rightPoint = lerp([], verties[1], verties[2], 0.5);
    const bottomPoint = lerp([], verties[2], verties[3], 0.5);
    const centerPoint = lerp([], verties[0], verties[2], 0.5);
    this.screenPoints = [
      leftPoint,
      topPoint,
      rightPoint,
      bottomPoint,
      centerPoint
    ];
  }
  [POINTERSTART("$el .inset .inset-direction") + LEFT_BUTTON + MOVE("moveInsetRadius") + END("moveEndInsetRadius")](e) {
    this.initializeInset();
    this.insetTarget = e.$dt.data("direction");
  }
  moveInsetRadius(dx, dy) {
    const { left: left2, top: top2, right: right2, bottom: bottom2 } = this.state.inset;
    let [leftPoint, topPoint, rightPoint, bottomPoint] = this.screenPoints;
    if (this.insetTarget == "left")
      leftPoint = add$1([], leftPoint, [dx, dy, 0]);
    else if (this.insetTarget == "top")
      topPoint = add$1([], topPoint, [dx, dy, 0]);
    else if (this.insetTarget == "right")
      rightPoint = add$1([], rightPoint, [dx, dy, 0]);
    else if (this.insetTarget == "bottom")
      bottomPoint = add$1([], bottomPoint, [dx, dy, 0]);
    const newLeftPoint = this.$viewport.applyVertexInverse(leftPoint);
    const newTopPoint = this.$viewport.applyVertexInverse(topPoint);
    const newRightPoint = this.$viewport.applyVertexInverse(rightPoint);
    const newBottomPoint = this.$viewport.applyVertexInverse(bottomPoint);
    const inverseMatrix = this.$context.selection.current.absoluteMatrixInverse;
    const [
      relativeLeftPosition,
      relativeTopPosition,
      relativeRightPosition,
      relativeBottomPosition
    ] = vertiesMap([newLeftPoint, newTopPoint, newRightPoint, newBottomPoint], inverseMatrix);
    this.state.clippath.value = [
      top2.isPercent() ? Length.makePercent(relativeTopPosition[1], this.state.height) : Length.px(relativeTopPosition[1]),
      right2.isPercent() ? Length.makePercent(this.state.width - relativeRightPosition[0], this.state.width) : Length.px(this.state.width - relativeRightPosition[0]),
      bottom2.isPercent() ? Length.makePercent(this.state.height - relativeBottomPosition[1], this.state.height) : Length.px(this.state.height - relativeBottomPosition[1]),
      left2.isPercent() ? Length.makePercent(relativeLeftPosition[0], this.state.width) : Length.px(relativeLeftPosition[0])
    ].join(" ");
    const value = ClipPath.toCSS(this.state.clippath);
    this.$commands.emit("setAttribute", this.$context.selection.packByValue(value));
  }
  moveEndInsetRadius() {
    const value = ClipPath.toCSS(this.state.clippath);
    this.$commands.executeCommand("setAttribute", "change clippath", this.$context.selection.packByValue(value));
  }
  [POINTERSTART("$el .inset .inset-center") + LEFT_BUTTON + MOVE("moveInsetCenter") + END("moveEndInsetCenter")]() {
    this.initializeInset();
  }
  moveInsetCenter(dx, dy) {
    const { left: left2, top: top2, right: right2, bottom: bottom2 } = this.state.inset;
    let [leftPoint, topPoint, rightPoint, bottomPoint] = this.screenPoints;
    leftPoint = add$1([], leftPoint, [dx, dy, 0]);
    topPoint = add$1([], topPoint, [dx, dy, 0]);
    rightPoint = add$1([], rightPoint, [dx, dy, 0]);
    bottomPoint = add$1([], bottomPoint, [dx, dy, 0]);
    const newLeftPoint = this.$viewport.applyVertexInverse(leftPoint);
    const newTopPoint = this.$viewport.applyVertexInverse(topPoint);
    const newRightPoint = this.$viewport.applyVertexInverse(rightPoint);
    const newBottomPoint = this.$viewport.applyVertexInverse(bottomPoint);
    const inverseMatrix = this.$context.selection.current.absoluteMatrixInverse;
    const [
      relativeLeftPosition,
      relativeTopPosition,
      relativeRightPosition,
      relativeBottomPosition
    ] = vertiesMap([newLeftPoint, newTopPoint, newRightPoint, newBottomPoint], inverseMatrix);
    this.state.clippath.value = [
      top2.isPercent() ? Length.makePercent(relativeTopPosition[1], this.state.height) : Length.px(relativeTopPosition[1]),
      right2.isPercent() ? Length.makePercent(this.state.width - relativeRightPosition[0], this.state.width) : Length.px(this.state.width - relativeRightPosition[0]),
      bottom2.isPercent() ? Length.makePercent(this.state.height - relativeBottomPosition[1], this.state.height) : Length.px(this.state.height - relativeBottomPosition[1]),
      left2.isPercent() ? Length.makePercent(relativeLeftPosition[0], this.state.width) : Length.px(relativeLeftPosition[0])
    ].join(" ");
    const value = ClipPath.toCSS(this.state.clippath);
    this.$commands.emit("setAttribute", this.$context.selection.packByValue(value));
  }
  moveEndInsetCenter(dx, dy) {
    if (dx == 0 && dy == 0) {
      switch (this.state.clippath.type) {
        case ClipPathType.INSET:
          const value2 = ClipPath.toCSS({
            type: ClipPathType.POLYGON,
            value: `0% 0%, 100% 0%, 100% 100%, 0% 100%`
          });
          this.$commands.executeCommand("setAttribute", "change clippath", this.$context.selection.packByValue(value2));
          break;
      }
      return;
    }
    const value = ClipPath.toCSS(this.state.clippath);
    this.$commands.executeCommand("setAttribute", "change clippath", this.$context.selection.packByValue(value));
  }
  templateInset(clippath) {
    const current = this.$context.selection.current;
    clippath.value = ClipPath.parseStyleForInset(clippath.value);
    const top2 = clippath.value.top.toPx(current.screenHeight);
    const left2 = clippath.value.left.toPx(current.screenWidth);
    const right2 = Length.px(current.screenWidth - clippath.value.right.toPx(current.screenWidth));
    const bottom2 = Length.px(current.screenHeight - clippath.value.bottom.toPx(current.screenHeight));
    const verties = this.$viewport.applyVerties(vertiesMap([
      [left2, top2, 0],
      [right2, top2, 0],
      [right2, bottom2, 0],
      [left2, bottom2, 0]
    ], current.absoluteMatrix));
    const leftPoint = lerp([], verties[0], verties[3], 0.5);
    const topPoint = lerp([], verties[0], verties[1], 0.5);
    const rightPoint = lerp([], verties[1], verties[2], 0.5);
    const bottomPoint = lerp([], verties[2], verties[3], 0.5);
    const centerPoint = lerp([], verties[0], verties[2], 0.5);
    return /* @__PURE__ */ createElementJsx("div", {
      class: "inset"
    }, /* @__PURE__ */ createElementJsx("div", {
      class: "inset-back"
    }, /* @__PURE__ */ createElementJsx("svg", {
      style: "position:absolute;width:100%;height:100%;"
    }, /* @__PURE__ */ createElementJsx("path", {
      d: `
            M ${verties[0][0]} ${verties[0][1]}
            L ${verties[1][0]} ${verties[1][1]}
            L ${verties[2][0]} ${verties[2][1]}
            L ${verties[3][0]} ${verties[3][1]}
            Z
          `
    }))), /* @__PURE__ */ createElementJsx("div", {
      class: "inset-direction",
      "data-direction": "left",
      style: {
        left: Length.px(leftPoint[0]),
        top: Length.px(leftPoint[1])
      }
    }), /* @__PURE__ */ createElementJsx("div", {
      class: "inset-direction",
      "data-direction": "top",
      style: { left: Length.px(topPoint[0]), top: Length.px(topPoint[1]) }
    }), /* @__PURE__ */ createElementJsx("div", {
      class: "inset-direction",
      "data-direction": "right",
      style: {
        left: Length.px(rightPoint[0]),
        top: Length.px(rightPoint[1])
      }
    }), /* @__PURE__ */ createElementJsx("div", {
      class: "inset-direction",
      "data-direction": "bottom",
      style: {
        left: Length.px(bottomPoint[0]),
        top: Length.px(bottomPoint[1])
      }
    }), /* @__PURE__ */ createElementJsx("div", {
      class: "inset-center",
      style: {
        left: Length.px(centerPoint[0]),
        top: Length.px(centerPoint[1])
      }
    }));
  }
}
class ClippathCircleEditorView extends ClippathInsetEditorView {
  [POINTERSTART("$el .circle .circle-radius") + LEFT_BUTTON + MOVE("moveCircleRadius") + END("moveEndCircleRadius")]() {
    const current = this.$context.selection.current;
    this.state.current;
    this.state.width = current.screenWidth;
    this.state.height = current.screenHeight;
    this.state.clippath = ClipPath.parseStyle(current["clip-path"]);
    this.state.circle = ClipPath.parseStyleForCircle(this.state.clippath.value);
  }
  moveCircleRadius(dx, dy) {
    const current = this.$context.selection.current;
    const { radius, x, y } = this.state.circle;
    const oldX = x.toPx(current.screenWidth);
    const oldY = y.toPx(current.screenHeight);
    const r = Math.sqrt(Math.pow(current.screenWidth, 2) + Math.pow(current.screenHeight, 2)) / Math.sqrt(2);
    const oldRadius = radius.toPx(current.screenWidth);
    const verties = this.$viewport.applyVerties(vertiesMap([[oldX.value + oldRadius.value, oldY, 0]], current.absoluteMatrix));
    const newRadius = verties[0];
    const newX = newRadius[0] + dx;
    const newY = newRadius[1] + dy;
    const localPosition = this.$viewport.applyVertexInverse([newX, newY, 0]);
    const relativePosition = vertiesMap([localPosition], this.$context.selection.current.absoluteMatrixInverse)[0];
    const distX = Math.abs(relativePosition[0] - oldX);
    const result = [
      radius.isPercent() ? Length.makePercent(distX, r) : Length.px(distX),
      x,
      y
    ];
    this.state.clippath.value = `${result[0]} at ${result[1]} ${result[2]}`;
    const value = ClipPath.toCSS(this.state.clippath);
    this.$commands.emit("setAttribute", this.$context.selection.packByValue(value));
  }
  moveEndCircleRadius() {
    const value = ClipPath.toCSS(this.state.clippath);
    this.$commands.executeCommand("setAttribute", "change clippath", this.$context.selection.packByValue(value));
  }
  [POINTERSTART("$el .circle .circle-center") + LEFT_BUTTON + MOVE("moveCircleCenter") + END("moveEndCircleCenter")]() {
    const current = this.$context.selection.current;
    this.state.current;
    this.state.width = current.screenWidth;
    this.state.height = current.screenHeight;
    this.state.clippath = ClipPath.parseStyle(current["clip-path"]);
    this.state.circle = ClipPath.parseStyleForCircle(this.state.clippath.value);
  }
  moveCircleCenter(dx, dy) {
    const current = this.$context.selection.current;
    const { radius, x, y } = this.state.circle;
    const oldX = x.toPx(current.screenWidth);
    const oldY = y.toPx(current.screenHeight);
    const verties = this.$viewport.applyVerties(vertiesMap([[oldX, oldY, 0]], current.absoluteMatrix));
    const center2 = verties[0];
    const newX = center2[0] + dx;
    const newY = center2[1] + dy;
    const localPosition = this.$viewport.applyVertexInverse([newX, newY, 0]);
    const relativePosition = vertiesMap([localPosition], this.$context.selection.current.absoluteMatrixInverse)[0];
    const result = [
      radius,
      x.isPercent() ? Length.makePercent(relativePosition[0], this.state.width) : Length.px(relativePosition[0]),
      y.isPercent() ? Length.makePercent(relativePosition[1], this.state.height) : Length.px(relativePosition[1])
    ];
    this.state.clippath.value = `${radius} at ${result[1]} ${result[2]}`;
    const value = ClipPath.toCSS(this.state.clippath);
    this.$commands.emit("setAttribute", this.$context.selection.packByValue(value));
  }
  moveEndCircleCenter(dx, dy) {
    if (dx == 0 && dy == 0) {
      switch (this.state.clippath.type) {
        case ClipPathType.CIRCLE:
          const value2 = ClipPath.toCSS({
            type: ClipPathType.ELLIPSE,
            value: `${this.state.circle.radius} ${this.state.circle.radius} at ${this.state.circle.x} ${this.state.circle.y}`
          });
          this.$commands.executeCommand("setAttribute", "change clippath", this.$context.selection.packByValue(value2));
          break;
      }
      return;
    }
    const value = ClipPath.toCSS(this.state.clippath);
    this.$commands.executeCommand("setAttribute", "change clippath", this.$context.selection.packByValue(value));
  }
  templateCircle(clippath) {
    const current = this.$context.selection.current;
    const r = Math.sqrt(Math.pow(current.screenWidth, 2) + Math.pow(current.screenHeight, 2)) / Math.sqrt(2);
    const radius = clippath.value.radius.toPx(r);
    const x = clippath.value.x.toPx(current.screenWidth);
    const y = clippath.value.y.toPx(current.screenHeight);
    const verties = this.$viewport.applyVerties(vertiesMap([
      [x, y, 0],
      [x.value + radius.value, y, 0]
    ], current.absoluteMatrix));
    const center2 = verties[0];
    const radiusPos = verties[1];
    const dist$1 = dist(center2, radiusPos);
    return /* @__PURE__ */ createElementJsx("div", {
      class: "circle"
    }, /* @__PURE__ */ createElementJsx("div", {
      class: "circle-back",
      style: {
        left: Length.px(center2[0]),
        top: Length.px(center2[1]),
        width: Length.px(dist$1 * 2),
        height: Length.px(dist$1 * 2)
      }
    }), /* @__PURE__ */ createElementJsx("div", {
      class: "circle-center",
      style: {
        left: center2[0] + "px",
        top: center2[1] + "px"
      }
    }), /* @__PURE__ */ createElementJsx("div", {
      class: "circle-radius",
      style: {
        left: radiusPos[0] + "px",
        top: radiusPos[1] + "px"
      }
    }));
  }
}
class ClippathEllipseEditorView extends ClippathCircleEditorView {
  [POINTERSTART("$el .ellipse .ellipse-radius-x") + LEFT_BUTTON + MOVE("moveEllipseRadiusX") + END("moveEndEllipseRadiusX")]() {
    const current = this.$context.selection.current;
    this.state.current;
    this.state.width = current.screenWidth;
    this.state.height = current.screenHeight;
    this.state.clippath = ClipPath.parseStyle(current["clip-path"]);
    this.state.ellipse = ClipPath.parseStyleForEllipse(this.state.clippath.value);
  }
  moveEllipseRadiusX(dx, dy) {
    const current = this.$context.selection.current;
    const { radiusX, radiusY, x, y } = this.state.ellipse;
    const oldX = x.toPx(current.screenWidth);
    const oldY = y.toPx(current.screenHeight);
    const oldRadiusX = radiusX.toPx(current.screenWidth);
    const verties = this.$viewport.applyVerties(vertiesMap([[oldX.value + oldRadiusX.value, oldY, 0]], current.absoluteMatrix));
    const newRadius = verties[0];
    const newX = newRadius[0] + dx;
    const newY = newRadius[1] + dy;
    const localPosition = this.$viewport.applyVertexInverse([newX, newY, 0]);
    const relativePosition = vertiesMap([localPosition], this.$context.selection.current.absoluteMatrixInverse)[0];
    const distX = Math.abs(relativePosition[0] - oldX);
    const result = [
      radiusX.isPercent() ? Length.makePercent(distX, this.state.width) : Length.px(distX),
      x,
      y
    ];
    this.state.clippath.value = `${result[0]} ${radiusY} at ${result[1]} ${result[2]}`;
    const value = ClipPath.toCSS(this.state.clippath);
    this.$commands.emit("setAttribute", this.$context.selection.packByValue(value));
  }
  [POINTERSTART("$el .ellipse .ellipse-radius-y") + LEFT_BUTTON + MOVE("moveEllipseRadiusY") + END("moveEndEllipseRadiusX")]() {
    const current = this.$context.selection.current;
    this.state.current;
    this.state.width = current.screenWidth;
    this.state.height = current.screenHeight;
    this.state.clippath = ClipPath.parseStyle(current["clip-path"]);
    this.state.ellipse = ClipPath.parseStyleForEllipse(this.state.clippath.value);
  }
  moveEllipseRadiusY(dx, dy) {
    const current = this.$context.selection.current;
    const { radiusX, radiusY, x, y } = this.state.ellipse;
    const oldX = x.toPx(current.screenWidth);
    const oldY = y.toPx(current.screenHeight);
    const oldRadiusY = radiusY.toPx(current.screenHeight);
    const verties = this.$viewport.applyVerties(vertiesMap([[oldX.value, oldY.value + oldRadiusY.value, 0]], current.absoluteMatrix));
    const newRadius = verties[0];
    const newX = newRadius[0] + dx;
    const newY = newRadius[1] + dy;
    const localPosition = this.$viewport.applyVertexInverse([newX, newY, 0]);
    const relativePosition = vertiesMap([localPosition], this.$context.selection.current.absoluteMatrixInverse)[0];
    const distY = Math.abs(relativePosition[1] - oldY);
    const result = [
      radiusY.isPercent() ? Length.makePercent(distY, this.state.height) : Length.px(distY),
      x,
      y
    ];
    this.state.clippath.value = `${radiusX} ${result[0]} at ${x} ${y}`;
    const value = ClipPath.toCSS(this.state.clippath);
    this.$commands.emit("setAttribute", this.$context.selection.packByValue(value));
  }
  moveEndEllipseRadiusX() {
    const value = ClipPath.toCSS(this.state.clippath);
    this.$commands.executeCommand("setAttribute", "change clippath", this.$context.selection.packByValue(value));
  }
  [POINTERSTART("$el .ellipse .ellipse-center") + LEFT_BUTTON + MOVE("moveEllipseCenter") + END("moveEndEllipseCenter")](e) {
    const current = this.$context.selection.current;
    this.state.current;
    this.state.width = current.screenWidth;
    this.state.height = current.screenHeight;
    this.state.clippath = ClipPath.parseStyle(current["clip-path"]);
    this.state.ellipse = ClipPath.parseStyleForEllipse(this.state.clippath.value);
    this.state.left = Length.parse(e.$dt.css("left")).value;
    this.state.top = Length.parse(e.$dt.css("top")).value;
  }
  moveEllipseCenter(dx, dy) {
    const { radiusX, radiusY, x, y } = this.state.ellipse;
    const newLeft = this.state.left + dx;
    const newTop = this.state.top + dy;
    const worldPosition = this.$viewport.applyVertexInverse([
      newLeft,
      newTop,
      0
    ]);
    const relativePosition = vertiesMap([worldPosition], this.$context.selection.current.absoluteMatrixInverse)[0];
    const result = [
      radiusX,
      radiusY,
      x.isPercent() ? Length.makePercent(relativePosition[0], this.state.width) : Length.px(relativePosition[0]),
      y.isPercent() ? Length.makePercent(relativePosition[1], this.state.height) : Length.px(relativePosition[1])
    ];
    this.state.clippath.value = `${radiusX} ${radiusY} at ${result[2]} ${result[3]}`;
    const value = ClipPath.toCSS(this.state.clippath);
    this.$commands.emit("setAttribute", this.$context.selection.packByValue(value));
  }
  moveEndEllipseCenter(dx, dy) {
    if (dx == 0 && dy == 0) {
      switch (this.state.clippath.type) {
        case ClipPathType.ELLIPSE:
          const value2 = ClipPath.toCSS({
            type: ClipPathType.INSET,
            value: ""
          });
          this.$commands.executeCommand("setAttribute", "change clippath", this.$context.selection.packByValue(value2));
          break;
      }
      return;
    }
    const value = ClipPath.toCSS(this.state.clippath);
    this.$commands.executeCommand("setAttribute", "change clippath", this.$context.selection.packByValue(value));
  }
  templateEllipse(clippath) {
    const current = this.$context.selection.current;
    const radiusX = clippath.value.radiusX.toPx(current.screenWidth);
    const radiusY = clippath.value.radiusY.toPx(current.screenHeight);
    const x = clippath.value.x.toPx(current.screenWidth);
    const y = clippath.value.y.toPx(current.screenHeight);
    const verties = this.$viewport.applyVerties(vertiesMap([
      [x, y, 0],
      [x.value + radiusX.value, y, 0],
      [x.value, y.value + radiusY.value, 0]
    ], current.absoluteMatrix));
    const center2 = verties[0];
    const radiusXPos = verties[1];
    const radiusYPos = verties[2];
    const distX = dist(center2, radiusXPos);
    const distY = dist(center2, radiusYPos);
    const direction2 = subtract([], radiusXPos, center2);
    const angle = calculateAngle(direction2[0], direction2[1]);
    return /* @__PURE__ */ createElementJsx("div", {
      class: "ellipse"
    }, /* @__PURE__ */ createElementJsx("div", {
      class: "ellipse-back"
    }, /* @__PURE__ */ createElementJsx("svg", {
      style: "position:absolute;width:100%;height:100%;"
    }, /* @__PURE__ */ createElementJsx("ellipse", {
      cx: center2[0],
      cy: center2[1],
      rx: distX,
      ry: distY,
      transform: `rotate(${angle} ${center2[0]} ${center2[1]})`
    }))), /* @__PURE__ */ createElementJsx("div", {
      class: "ellipse-center",
      style: {
        left: center2[0] + "px",
        top: center2[1] + "px"
      }
    }), /* @__PURE__ */ createElementJsx("div", {
      class: "ellipse-radius ellipse-radius-x",
      style: {
        left: radiusXPos[0] + "px",
        top: radiusXPos[1] + "px"
      }
    }), /* @__PURE__ */ createElementJsx("div", {
      class: "ellipse-radius ellipse-radius-y",
      style: {
        left: radiusYPos[0] + "px",
        top: radiusYPos[1] + "px"
      }
    }));
  }
}
class ClippathEditorView$1 extends ClippathEllipseEditorView {
  template() {
    return /* @__PURE__ */ createElementJsx("div", {
      class: "elf--clippath-editor-view "
    });
  }
  [LOAD("$el") + DOMDIFF]() {
    const current = this.$context.selection.current;
    if (!current) {
      return "";
    }
    const clippath = ClipPath.parseStyle(current["clip-path"]);
    switch (clippath.type) {
      case ClipPathType.CIRCLE:
        clippath.value = ClipPath.parseStyleForCircle(clippath.value);
        return this.templateCircle(clippath);
      case ClipPathType.ELLIPSE:
        clippath.value = ClipPath.parseStyleForEllipse(clippath.value);
        return this.templateEllipse(clippath);
      case ClipPathType.POLYGON:
        return this.templatePolygon(clippath);
      case ClipPathType.INSET:
        return this.templateInset(clippath);
    }
    return /* @__PURE__ */ createElementJsx("div", null);
  }
  [SUBSCRIBE(REFRESH_SELECTION) + DEBOUNCE(100)]() {
    this.refresh();
  }
  [SUBSCRIBE(UPDATE_VIEWPORT)]() {
    this.refresh();
  }
  checkClipPath() {
    if (this.$el.isShow() === false)
      return false;
    const current = this.$context.selection.current;
    if (!current)
      return false;
    return this.$context.selection.current.hasChangedField("clip-path", "angle", "x", "y", "width", "height");
  }
  [SUBSCRIBE(UPDATE_CANVAS) + IF("checkClipPath") + DEBOUNCE(10)]() {
    this.refresh();
  }
  [CLICK("$el")](e) {
    if (Dom.create(e.target).isTag("svg") || Dom.create(e.target).hasClass("elf--clippath-editor-view")) {
      this.trigger("hideClippathEditorView");
    }
  }
  [SUBSCRIBE("hideClippathEditorView")]() {
    this.$el.hide();
  }
  [SUBSCRIBE("showClippathEditorView")]() {
    this.$el.show();
    this.refresh();
  }
}
function ClippathEditorView(editor) {
  editor.registerUI("canvas.view", {
    ClippathEditorView: ClippathEditorView$1
  });
}
var CodeViewProperty$1 = "";
class CodeViewProperty extends BaseProperty {
  getTitle() {
    return this.$i18n("code.view.property.title");
  }
  checkConfig() {
    return this.$config.is("inspector.selectedValue", "code");
  }
  [CONFIG("inspector.selectedValue")]() {
    this.refresh();
  }
  [SUBSCRIBE(UPDATE_CANVAS, REFRESH_SELECTION) + IF("checkConfig") + DEBOUNCE(100)]() {
    this.refresh();
  }
  getBody() {
    return `
      <div class="property-item elf--code-view-item" ref='$body'>
        <div class="elf--code-view-item-code" ref='$code'></div>
        <div class="elf--code-view-item-svg" ref='$svg'></div>
      </div>
    `;
  }
  [LOAD("$code") + DOMDIFF]() {
    return [
      this.$editor.renderer("html").codeview(this.$context.selection.current)
    ];
  }
  [LOAD("$svg") + DOMDIFF]() {
    return [
      this.$editor.renderer("svg").codeview(this.$context.selection.current)
    ];
  }
}
function codeview(editor) {
  editor.registerUI("inspector.tab.code", {
    CodeViewProperty
  });
}
function _currentProject(editor, callback) {
  var project2 = editor.context.selection.currentProject;
  if (project2) {
    var timeline = project2.getSelectedTimeline();
    callback && callback(project2, timeline);
  }
}
var __glob_0_0$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": _currentProject
}, Symbol.toStringTag, { value: "Module" }));
function _doForceRefreshSelection(editor) {
  editor.emit("refreshAll");
}
var __glob_0_1$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": _doForceRefreshSelection
}, Symbol.toStringTag, { value: "Module" }));
var addArtBoard = {
  command: "addArtBoard",
  execute: (editor, obj2 = {}, center2 = null) => {
    var project2 = editor.context.selection.currentProject;
    if (!project2) {
      project2 = editor.add(editor.createModel({ itemType: "project" }));
      editor.context.selection.selectProject(project2);
    }
    var artboard2 = project2.appendChild(editor.createModel(__spreadValues({
      itemType: "artboard",
      x: 300,
      y: 200,
      width: 375,
      height: 667
    }, obj2)));
    if (center2) {
      artboard2.reset({
        x: 0,
        y: 0
      });
      artboard2.moveByCenter(center2);
    }
    editor.context.selection.select(artboard2);
    _doForceRefreshSelection(editor);
  }
};
var __glob_0_2$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": addArtBoard
}, Symbol.toStringTag, { value: "Module" }));
var addBackgroundColor = {
  command: "addBackgroundColor",
  execute: function(editor, color2, id = null) {
    editor.context.commands.executeCommand("setAttribute", "add background color", editor.context.selection.packByValue({
      backgroundColor: color2
    }, id));
  }
};
var __glob_0_3$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": addBackgroundColor
}, Symbol.toStringTag, { value: "Module" }));
var addBackgroundImageAsset = {
  command: "addBackgroundImageAsset",
  execute: function(editor, url, id = null) {
    var items = editor.context.selection.itemsByIds(id);
    let itemsMap = {};
    items.forEach((item) => {
      let images = BackgroundImage.parseStyle(STRING_TO_CSS(item.backgroundImage));
      images.unshift(new BackgroundImage({
        image: new URLImageResource({ url })
      }));
      itemsMap[item.id] = {
        "background-image": BackgroundImage.join(images)
      };
    });
    editor.context.commands.emit("history.setAttribute", "add background image", itemsMap);
  }
};
var __glob_0_4$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": addBackgroundImageAsset
}, Symbol.toStringTag, { value: "Module" }));
var addBackgroundImageGradient = {
  command: "addBackgroundImageGradient",
  execute: function(editor, gradient2, id = null) {
    var items = editor.context.selection.itemsByIds(id);
    let itemsMap = {};
    items.forEach((item) => {
      let images = BackgroundImage.parseStyle(STRING_TO_CSS(item.backgroundImage));
      images.unshift(new BackgroundImage({
        image: BackgroundImage.parseImage(gradient2)
      }));
      itemsMap[item.id] = {
        backgroundImage: BackgroundImage.join(images)
      };
    });
    editor.context.commands.emit("history.setAttribute", "add gradient", itemsMap);
  }
};
var __glob_0_5$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": addBackgroundImageGradient
}, Symbol.toStringTag, { value: "Module" }));
const MAX_CACHE_COUNT$1 = 1e3;
const cachedPatternMap = /* @__PURE__ */ new Map();
class PatternCache {
  static has(key) {
    return cachedPatternMap.has(key);
  }
  static get(key) {
    return cachedPatternMap.get(key);
  }
  static set(key, parsedValue) {
    if (cachedPatternMap.size > MAX_CACHE_COUNT$1) {
      cachedPatternMap.clear();
    }
    cachedPatternMap.set(key, parsedValue);
  }
}
const customFuncMap = {
  check: makeGroupFunction("check"),
  grid: makeGroupFunction("grid"),
  dot: makeGroupFunction("dot"),
  "cross-dot": makeGroupFunction("cross-dot"),
  "diagonal-line": makeGroupFunction("diagonal-line"),
  "vertical-line": makeGroupFunction("vertical-line"),
  "horizontal-line": makeGroupFunction("horizontal-line")
};
class Pattern extends PropertyItem {
  getDefaultObject(obj2 = {}) {
    return super.getDefaultObject(__spreadValues({
      itemType: "pattern"
    }, obj2));
  }
  toString() {
    return `${this.json.type}(${this.json.value || ""})`;
  }
  static parse(obj2) {
    var PatternClass = PatternClassName[obj2.type];
    if (PatternClass) {
      return new PatternClass(obj2);
    }
  }
  static parseStyle(pattern) {
    var patterns2 = [];
    if (!pattern || pattern === "undefined")
      return patterns2;
    pattern = pattern.trim();
    if (PatternCache.has(pattern)) {
      return PatternCache.get(pattern);
    }
    const result = parseValue(pattern, {
      customFuncMap
    });
    result.forEach((item, index2) => {
      const [
        size2,
        position2,
        foreColor,
        backColor,
        blendMode = [{ matchedString: "normal" }],
        lineSize = [
          { parsed: Length.parse("1px") },
          { parsed: Length.parse("1px") }
        ]
      ] = item.parameters;
      patterns2[index2] = Pattern.parse({
        type: item.type,
        x: position2[0].parsed,
        y: position2[1].parsed,
        width: size2[0].parsed,
        height: size2[1].parsed,
        foreColor: foreColor[0].matchedString,
        backColor: backColor[0].matchedString,
        blendMode: blendMode[0].matchedString,
        lineWidth: lineSize[0].parsed,
        lineHeight: lineSize[1].parsed
      });
    });
    PatternCache.set(pattern, patterns2);
    return patterns2;
  }
  static join(list2) {
    return list2.map((it) => Pattern.parse(it)).join(" ");
  }
  static toCSS(str) {
    let list2 = [];
    Pattern.parseStyle(str).forEach((it) => {
      list2.push.apply(list2, BackgroundImage.parseStyle(STRING_TO_CSS(it.toCSS())));
    });
    return BackgroundImage.joinCSS(list2);
  }
}
class BasePattern extends Pattern {
  getDefaultObject() {
    return super.getDefaultObject({
      type: "base",
      x: 0,
      y: 0,
      width: 20,
      height: 20,
      lineWidth: 1,
      lineHeight: 1,
      foreColor: "black",
      backColor: "white",
      blendMode: "normal"
    });
  }
  convert(json) {
    json = super.convert(json);
    json.width = Length.parse(json.width);
    json.height = Length.parse(json.height);
    json.lineWidth = Length.parse(json.lineWidth);
    json.lineHeight = Length.parse(json.lineHeight);
    json.x = Length.parse(json.x);
    json.y = Length.parse(json.y);
    return json;
  }
  toString() {
    var {
      type,
      width: width2,
      height: height2,
      x,
      y,
      foreColor,
      backColor,
      blendMode,
      lineWidth,
      lineHeight
    } = this.json;
    return `${type}(${width2} ${height2}, ${x} ${y}, ${foreColor}, ${backColor}, ${blendMode}, ${lineWidth} ${lineHeight})`;
  }
}
class CheckPattern extends BasePattern {
  getDefaultObject() {
    return super.getDefaultObject({
      type: "check"
    });
  }
  toCSS() {
    let { width: width2, height: height2, x, y, backColor, foreColor, blendMode } = this.json;
    backColor = backColor || "transparent";
    foreColor = foreColor || "black";
    return `
      background-image: repeating-linear-gradient(45deg, ${foreColor} 25%, ${backColor} 25%, ${backColor} 75%, ${foreColor} 75%, ${foreColor} 100%),repeating-linear-gradient(45deg, ${foreColor} 25%, ${backColor} 25%, ${backColor} 75%, ${foreColor} 75%, ${foreColor} 100%);
      background-position: 0px 0px, ${x} ${y};
      background-size: ${width2} ${height2}, ${width2} ${height2};
      background-blend-mode: ${blendMode}, ${blendMode};
    `;
  }
}
class GridPattern extends BasePattern {
  getDefaultObject() {
    return super.getDefaultObject({
      type: "grid"
    });
  }
  toCSS() {
    let {
      width: width2,
      height: height2,
      lineWidth,
      lineHeight,
      backColor,
      foreColor,
      blendMode
    } = this.json;
    backColor = backColor || "transparent";
    foreColor = foreColor || "black";
    return `
      background-image: linear-gradient(to bottom,${foreColor} ${lineHeight}, ${backColor} ${lineHeight}),linear-gradient(to right, ${foreColor} ${lineWidth}, ${backColor} ${lineWidth});
      background-size: ${width2 / 2}px ${height2 / 2}px, ${width2 / 2}px ${height2 / 2}px;      
      background-blend-mode: ${blendMode}, ${blendMode};      
    `;
  }
}
class DotPattern extends BasePattern {
  getDefaultObject() {
    return super.getDefaultObject({
      type: "dot"
    });
  }
  toCSS() {
    let { width: width2, height: height2, lineWidth, backColor, foreColor, blendMode } = this.json;
    backColor = backColor || "transparent";
    foreColor = foreColor || "black";
    return `
      background-image: radial-gradient(${foreColor} ${lineWidth}, ${backColor} ${lineWidth});
      background-size: ${width2 / 2}px ${height2 / 2}px;          
      background-blend-mode: ${blendMode};      
    `;
  }
}
class CrossDotPattern extends BasePattern {
  getDefaultObject() {
    return super.getDefaultObject({
      type: "cross-dot"
    });
  }
  toCSS() {
    let { width: width2, height: height2, x, y, lineWidth, backColor, foreColor, blendMode } = this.json;
    backColor = backColor || "transparent";
    foreColor = foreColor || "black";
    return `
      background-image: radial-gradient(${foreColor} ${lineWidth}, ${backColor} ${lineWidth}),radial-gradient(${foreColor} ${lineWidth}, ${backColor} ${lineWidth});
      background-size: ${width2} ${height2},${width2} ${height2};
      background-position: 0px 0px, ${x} ${y};      
      background-blend-mode: multiply, ${blendMode};
    `;
  }
}
class DiagonalLinePattern extends BasePattern {
  getDefaultObject() {
    return super.getDefaultObject({
      type: "diagonal-line"
    });
  }
  toCSS() {
    let { width: width2, height: height2, x, lineWidth, backColor, foreColor, blendMode } = this.json;
    backColor = backColor || "transparent";
    foreColor = foreColor || "black";
    return `
    background-image: repeating-linear-gradient(${x}, ${foreColor} 0px, ${foreColor} ${lineWidth}, ${backColor} 0px, ${backColor} 50%);
    background-size: ${width2} ${height2};      
    background-blend-mode: ${blendMode};
  `;
  }
}
class VerticalLinePattern extends BasePattern {
  getDefaultObject() {
    return super.getDefaultObject({
      type: "vertical-line"
    });
  }
  toCSS() {
    let { width: width2, height: height2, x, y, lineWidth, backColor, foreColor, blendMode } = this.json;
    backColor = backColor || "transparent";
    foreColor = foreColor || "black";
    return `
      background-image: repeating-linear-gradient(to right, ${foreColor} 0px, ${foreColor} ${lineWidth}, ${backColor} ${lineWidth}, ${backColor} 100%);
      background-size: ${width2} ${height2}; 
      background-position: ${x} ${y};        
      background-blend-mode: ${blendMode};
    `;
  }
}
class HorizontalLinePattern extends BasePattern {
  getDefaultObject() {
    return super.getDefaultObject({
      type: "horizontal-line"
    });
  }
  toCSS() {
    let { width: width2, height: height2, x, y, lineWidth, backColor, foreColor, blendMode } = this.json;
    backColor = backColor || "transparent";
    foreColor = foreColor || "black";
    return `
      background-image: repeating-linear-gradient( to bottom, ${foreColor} 0px, ${foreColor} ${lineWidth}, ${backColor} ${lineWidth}, ${backColor} 100%);    
      background-position: ${x} ${y};
      background-size: ${width2} ${height2};   
      background-blend-mode: ${blendMode};
    `;
  }
}
const PatternClassName = {
  check: CheckPattern,
  grid: GridPattern,
  dot: DotPattern,
  "cross-dot": CrossDotPattern,
  "diagonal-line": DiagonalLinePattern,
  "vertical-line": VerticalLinePattern,
  "horizontal-line": HorizontalLinePattern
};
var addBackgroundImagePattern = {
  command: "addBackgroundImagePattern",
  execute: function(editor, pattern, id = null) {
    var items = editor.context.selection.itemsByIds(id);
    let itemsMap = {};
    items.forEach((item) => {
      itemsMap[item.id] = {
        pattern: Pattern.join([
          ...Pattern.parseStyle(pattern),
          ...Pattern.parseStyle(item.pattern)
        ])
      };
    });
    editor.context.commands.emit("history.setAttribute", "add pattern", itemsMap);
  }
};
var __glob_0_6$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": addBackgroundImagePattern
}, Symbol.toStringTag, { value: "Module" }));
function addCustomComponent(editor, obj2 = {}, center2 = null) {
  var project2 = editor.context.selection.currentProject;
  var customComponent = project2.appendChild(editor.createModel(__spreadValues({
    x: 300,
    y: 200,
    width: 375,
    height: 667
  }, obj2)));
  if (center2) {
    customComponent.reset({
      x: 0,
      y: 0
    });
    customComponent.moveByCenter(center2);
  }
  editor.context.selection.select(customComponent);
  _doForceRefreshSelection(editor);
}
var __glob_0_7$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": addCustomComponent
}, Symbol.toStringTag, { value: "Module" }));
function addImage(editor, rect2 = {}, containerItem = void 0) {
  editor.context.commands.emit("newComponent", "image", rect2, true, containerItem);
}
var __glob_0_8$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": addImage
}, Symbol.toStringTag, { value: "Module" }));
function loadOriginalImage(obj2, callback) {
  var img = new window.Image();
  img.onload = () => {
    var info = {
      id: obj2.id,
      local: obj2.local,
      naturalWidth: img.naturalWidth,
      naturalHeight: img.naturalHeight,
      width: img.naturalWidth,
      height: img.naturalHeight
    };
    callback && callback(info, img);
  };
  img.onerror = (e) => {
    console.log(e, e.message);
  };
  img.src = obj2.local;
}
var addImageAssetItem = {
  command: "addImageAssetItem",
  execute: function(editor, imageObject, rect2 = {}, containerItem = void 0) {
    var project2 = editor.context.selection.currentProject;
    if (project2) {
      project2.createImage(imageObject);
      editor.context.commands.emit("addImageAsset");
      loadOriginalImage(imageObject, (info) => {
        const rate = rect2.width / info.width;
        const width2 = rect2.width;
        const height2 = info.height * rate;
        editor.context.commands.emit("addImage", __spreadProps(__spreadValues(__spreadValues({
          src: imageObject.id
        }, info), rect2), {
          width: width2,
          height: height2
        }), containerItem);
      });
    }
  }
};
var __glob_0_9$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": addImageAssetItem
}, Symbol.toStringTag, { value: "Module" }));
function addLayer(editor, layer, isSelected = true, containerItem) {
  if (!containerItem) {
    containerItem = editor.context.selection.current || editor.context.selection.currentProject;
  }
  if (containerItem) {
    if (containerItem.isNot("project") && !containerItem.enableHasChildren()) {
      containerItem = containerItem.parent;
    }
    containerItem.appendChild(layer);
    if (isSelected) {
      editor.context.selection.select(layer);
    }
    _doForceRefreshSelection(editor);
  }
}
var __glob_0_10$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": addLayer
}, Symbol.toStringTag, { value: "Module" }));
var addLayerView = {
  command: "addLayerView",
  execute: async function(editor, type, data = {}) {
    editor.context.selection.empty();
    await editor.emit("hideAddViewLayer");
    await editor.emit("removeGuideLine");
    editor.context.config.set("editing.mode.itemType", type);
    if (type === "select") {
      editor.context.selection.empty();
      editor.context.config.set("editing.mode", EditingMode.SELECT);
    } else if (type === "brush") {
      editor.context.config.set("editing.mode", EditingMode.DRAW);
      await editor.emit("showPathDrawEditor");
    } else if (type === "path") {
      editor.context.config.set("editing.mode", EditingMode.PATH);
      await editor.emit("showPathEditor", "path");
    } else {
      editor.context.config.set("editing.mode", EditingMode.APPEND);
      await editor.emit("showLayerAppendView", type, data);
    }
  }
};
var __glob_0_11$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": addLayerView
}, Symbol.toStringTag, { value: "Module" }));
function addProject(editor, obj2 = {}) {
  var project2 = editor.createModel(__spreadValues({
    itemType: "project"
  }, obj2));
  editor.context.selection.selectProject(project2);
  _doForceRefreshSelection(editor);
}
var __glob_0_12$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": addProject
}, Symbol.toStringTag, { value: "Module" }));
var addSVGFilterAssetItem = {
  command: "addSVGFilterAssetItem",
  execute: function(editor, callback) {
    var project2 = editor.context.selection.currentProject;
    if (project2) {
      var id = uuidShort();
      var index2 = project2.createSVGFilter({ id, filters: [] });
      callback && callback(index2, id);
    }
  }
};
var __glob_0_13$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": addSVGFilterAssetItem
}, Symbol.toStringTag, { value: "Module" }));
function addText(editor, rect2 = {}) {
  editor.context.commands.emit("newComponent", "text", __spreadValues({
    content: "Insert a text",
    width: 300,
    height: 50,
    "font-size": 30
  }, rect2), rect2);
}
var __glob_0_14$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": addText
}, Symbol.toStringTag, { value: "Module" }));
var addTimelineCurrentProperty = {
  command: "addTimelineCurrentProperty",
  execute: function(editor, options2 = { timing: "linear" }) {
    _currentProject(editor, (project2) => {
      var list2 = [];
      editor.context.selection.each((item) => {
        var keyframeObj = {
          layerId: item.id,
          property: options2.property,
          value: item[options2.property] + "",
          timing: options2.timing,
          editor: options2.editor
        };
        var obj2 = project2.addTimelineKeyframe(keyframeObj);
        if (obj2) {
          list2.push(obj2);
        }
      });
      editor.context.timeline.select(...list2);
      editor.emit("refreshTimeline");
      editor.emit("refreshSelectedOffset");
    });
  }
};
var __glob_0_15$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": addTimelineCurrentProperty
}, Symbol.toStringTag, { value: "Module" }));
var addTimelineItem = {
  command: "addTimelineItem",
  execute: function(editor, layerId) {
    _currentProject(editor, (project2) => {
      if (layerId) {
        project2.addTimelineLayer(layerId);
      } else {
        project2.addTimeline();
      }
      editor.emit("refreshTimeline");
      editor.emit("addTimeline");
    });
  }
};
var __glob_0_16$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": addTimelineItem
}, Symbol.toStringTag, { value: "Module" }));
var addTimelineKeyframe = {
  command: "addTimelineKeyframe",
  execute: function(editor, options2 = { timing: "linear" }) {
    _currentProject(editor, (project2) => {
      var item = editor.context.modelManager.get(options2.layerId);
      var keyframeObj = {
        layerId: options2.layerId,
        property: options2.property,
        time: options2.time,
        value: item[options2.property] + "",
        timing: options2.timing,
        editor: options2.editor
      };
      var obj2 = project2.addTimelineKeyframe(keyframeObj);
      editor.timeline.select(obj2);
      editor.emit("refreshTimeline");
      editor.emit("refreshSelectedOffset");
    });
  }
};
var __glob_0_17$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": addTimelineKeyframe
}, Symbol.toStringTag, { value: "Module" }));
var addTimelineProperty = {
  command: "addTimelineProperty",
  execute: function(editor, layerList, options2 = { timing: "linear" }) {
    _currentProject(editor, (project2) => {
      if (Array.isArray(layerList) === false) {
        layerList = [layerList];
      }
      var list2 = [];
      layerList.forEach((layerId) => {
        var keyframeObj = {
          layerId,
          property: options2.property,
          value: options2.value + "",
          timing: options2.timing,
          editor: options2.editor
        };
        var obj2 = project2.addTimelineKeyframe(keyframeObj);
        if (obj2) {
          list2.push(obj2);
        }
      });
      editor.timeline.select(...list2);
      editor.emit("refreshTimeline");
      editor.emit("refreshSelectedOffset");
    });
  }
};
var __glob_0_18$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": addTimelineProperty
}, Symbol.toStringTag, { value: "Module" }));
function addVideo(editor, rect2 = {}, containerItem = void 0) {
  editor.context.commands.emit("newComponent", "video", rect2, true, containerItem);
}
var __glob_0_19$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": addVideo
}, Symbol.toStringTag, { value: "Module" }));
function loadOriginalVideo(obj2, callback) {
  var video2 = document.createElement("video");
  video2.onloadeddata = () => {
    var info = {
      local: obj2.local,
      naturalWidth: video2.videoWidth,
      naturalHeight: video2.videoHeight,
      width: video2.videoWidth,
      height: video2.videoHeight,
      duration: video2.duration,
      playTime: `0:1:${video2.duration}`,
      volume: video2.volume,
      muted: video2.muted,
      placebackRate: video2.playbackRate
    };
    callback && callback(info, video2);
  };
  video2.src = obj2.local;
}
var addVideoAssetItem = {
  command: "addVideoAssetItem",
  execute: function(editor, videoObject, rect2 = {}, containerItem = void 0) {
    var project2 = editor.context.selection.currentProject;
    if (project2) {
      project2.createVideo(videoObject);
      editor.emit("addVideoAsset");
      loadOriginalVideo(videoObject, (info) => {
        editor.context.commands.emit("addVideo", __spreadValues(__spreadValues({ src: videoObject.id }, info), rect2), containerItem);
      });
    }
  }
};
var __glob_0_20$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": addVideoAssetItem
}, Symbol.toStringTag, { value: "Module" }));
var clipboard_copy = {
  command: "clipboard.copy",
  title: "Copy",
  description: "Copy",
  execute: function(editor) {
    editor.context.clipboard.push({
      type: ClipboardActionType.COPY,
      data: editor.context.selection.ids
    });
  }
};
var __glob_0_21$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": clipboard_copy
}, Symbol.toStringTag, { value: "Module" }));
var clipboard_paste = {
  command: "clipboard.paste",
  execute: async function(editor) {
    if (!editor.context.clipboard.isEmpty) {
      editor.context.commands.emit("history.clipboard.paste", "paste");
    } else {
      var text2 = await window.navigator.clipboard.readText();
      if (text2) {
        editor.context.commands.emit("convertPasteText", text2);
      }
    }
  }
};
var __glob_0_22$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": clipboard_paste
}, Symbol.toStringTag, { value: "Module" }));
var convert_flatten_path = {
  command: "convert.flatten.path",
  description: "flatten selected multi path",
  execute: (editor) => {
    const current = editor.context.selection.current;
    if (!current)
      return;
    let newPath;
    if (current.is("boolean-path") || current.isBooleanItem) {
      let parent = current;
      if (current.isBooleanItem) {
        parent = current.parent;
      }
      newPath = parent.absolutePath(parent["boolean-path"]);
      newPath = parent.invertPath(newPath.d);
      const newLayerAttrs = parent.layers[0].toCloneObject();
      delete newLayerAttrs.id;
      delete newLayerAttrs.parentId;
      delete newLayerAttrs.transform;
      delete newLayerAttrs["boolean-path"];
      delete newLayerAttrs["boolean-operation"];
      const parentParent = parent.parent;
      const newRectInfo = parent.updatePath(newPath.d);
      editor.context.commands.executeCommand("removeLayer", "remove selected layers", [parent.id]);
      editor.nextTick(() => {
        editor.context.commands.executeCommand("addLayer", `add layer - path`, editor.createModel(__spreadValues(__spreadValues({}, newLayerAttrs), newRectInfo)), true, parentParent);
      });
    } else {
      newPath = PathParser.fromSVGString();
      editor.context.selection.each((item) => {
        newPath.addPath(item.absolutePath());
      });
      newPath = current.invertPath(newPath.d);
      const parent = current.parent;
      const newPathInfo = current.updatePath(newPath.d);
      const newLayerAttrs = current.toCloneObject();
      delete newLayerAttrs.id;
      editor.context.commands.executeCommand("removeLayer", "remove selected layers");
      editor.nextTick(() => {
        editor.context.commands.executeCommand("addLayer", `add layer - path`, editor.createModel(__spreadValues(__spreadValues({}, newLayerAttrs), newPathInfo)), true, parent);
      });
    }
  }
};
var __glob_0_23$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": convert_flatten_path
}, Symbol.toStringTag, { value: "Module" }));
var convert_no_transform_path = {
  command: "convert.no.transform.path",
  description: "remove transform(rotate, translate, scale) inforation in path layer",
  execute: (editor) => {
    const current = editor.context.selection.current;
    if (!current)
      return;
    const parent = current.parent;
    const childPath = current.absolutePath();
    if (parent.is("project")) {
      const verties = childPath.getBBox();
      const newRect = vertiesToRectangle(verties);
      editor.context.commands.executeCommand("setAttribute", "remove transform for path", editor.context.selection.packByValue(__spreadProps(__spreadValues({}, newRect), {
        rotate: 0,
        d: childPath.d
      })));
    } else {
      childPath.transformMat4(parent.absoluteMatrixInverse);
      const newRect = parent.updatePath(childPath.d);
      editor.context.commands.executeCommand("setAttribute", "remove transform for path", editor.context.selection.packByValue(__spreadProps(__spreadValues({}, newRect), {
        rotate: 0,
        d: childPath.d
      })));
    }
  }
};
var __glob_0_24 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": convert_no_transform_path
}, Symbol.toStringTag, { value: "Module" }));
var convert_normalize_path = {
  command: "convert.normalize.path",
  description: "convert segments to bezier curve",
  execute: (editor) => {
    const current = editor.context.selection.current;
    if (!current)
      return;
    editor.context.commands.executeCommand("setAttribute", "normalize path string", editor.context.selection.packByValue(current.updatePath(PathParser.fromSVGString(current.d).normalize().d)));
  }
};
var __glob_0_25 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": convert_normalize_path
}, Symbol.toStringTag, { value: "Module" }));
var convert_path_operation = {
  command: "convert.path.operation",
  description: "apply path boolean operation",
  execute: (editor, booleanOperation) => {
    var _a;
    const current = editor.context.selection.current;
    if (!current)
      return;
    const changeBooleanOperation = (booleanOperation2) => {
      editor.context.commands.executeCommand("setAttribute", "change boolean operation", editor.context.selection.packByValue({
        booleanOperation: booleanOperation2
      }));
      recoverBooleanPath2();
    };
    const recoverBooleanPath2 = () => {
      editor.nextTick(() => {
        editor.context.commands.emit("recoverBooleanPath");
        editor.nextTick(() => {
          editor.emit(REFRESH_SELECTION);
        });
      });
    };
    if (current.is("boolean-path") || current.isBooleanItem) {
      let parent = current;
      if (current.isBooleanItem) {
        parent = current.parent;
      }
      editor.context.selection.select(parent);
      changeBooleanOperation(booleanOperation);
    } else {
      if ((_a = editor.context.selection.current) == null ? void 0 : _a.isNot("boolean-path")) {
        editor.context.commands.emit("group.item", {
          itemType: "boolean-path",
          title: "Intersection"
        });
      }
      editor.nextTick(() => {
        var _a2;
        if ((_a2 = editor.context.selection.current) == null ? void 0 : _a2.is("boolean-path")) {
          changeBooleanOperation(booleanOperation);
        }
      }, 10);
    }
  }
};
var __glob_0_26 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": convert_path_operation
}, Symbol.toStringTag, { value: "Module" }));
var convert_polygonal_path = {
  command: "convert.polygonal.path",
  description: "convert path to polygonal path",
  execute: (editor) => {
    const current = editor.context.selection.current;
    if (!current)
      return;
    editor.context.commands.executeCommand("setAttribute", "polygonal path string", editor.context.selection.packByValue(current.updatePath(PathParser.fromSVGString(current.d).polygonal().d)));
  }
};
var __glob_0_27 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": convert_polygonal_path
}, Symbol.toStringTag, { value: "Module" }));
var convert_simplify_path = {
  command: "convert.simplify.path",
  execute: (editor) => {
    const current = editor.context.selection.current;
    if (!current)
      return;
    editor.context.commands.executeCommand("setAttribute", "change path string", editor.context.selection.packByValue(current.updatePath(editor.pathKitManager.simplify(current.d))));
  }
};
var __glob_0_28 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": convert_simplify_path
}, Symbol.toStringTag, { value: "Module" }));
var convert_smooth_path = {
  command: "convert.smooth.path",
  description: "convert path to smooth",
  execute: (editor, divideCount = 5, tolerance = 0.1, tension = 0.5) => {
    const current = editor.context.selection.current;
    if (!current)
      return;
    const smoothedPath = PathParser.fromSVGString(current.d).divideSegmentByCount(divideCount).simplify(tolerance).cardinalSplines(tension).d;
    editor.context.commands.executeCommand("setAttribute", "smooth path string", editor.context.selection.packByValue(current.updatePath(smoothedPath)));
  }
};
var __glob_0_29 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": convert_smooth_path
}, Symbol.toStringTag, { value: "Module" }));
var convert_stroke_to_path = {
  command: "convert.stroke.to.path",
  execute: async (editor) => {
    const current = editor.context.selection.current;
    if (!current)
      return;
    const attrs = current.attrs("d", "stroke-width", "stroke-dasharray", "stroke-dashoffset", "stroke-linejoin", "stroke-linecap");
    const pathAttrs = current.convertStrokeToPath();
    let newD = editor.pathKitManager.stroke(current.d || attrs.d, {
      "stroke-width": Length.parse(attrs["stroke-width"]).value,
      "stroke-linejoin": attrs["stroke-linejoin"],
      "stroke-linecap": attrs["stroke-linecap"],
      "stroke-dasharray": attrs["stroke-dasharray"],
      "stroke-dashoffset": attrs["stroke-dashoffset"],
      "fill-rule": "nonezero"
    });
    pathAttrs["fill-rule"] = "nonzero";
    newD = PathParser.fromSVGString(newD).reversePathStringByFunc((_, index2) => index2 % 2 === 0);
    editor.context.commands.executeCommand("addLayer", `add layer - path`, editor.createModel(__spreadValues(__spreadValues({}, pathAttrs), current.updatePath(newD))), true, current.parent);
  }
};
var __glob_0_30 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": convert_stroke_to_path
}, Symbol.toStringTag, { value: "Module" }));
var jsVideoUrlParser = { exports: {} };
(function(module, exports) {
  (function(global2, factory) {
    module.exports = factory();
  })(commonjsGlobal, function() {
    function _typeof(obj2) {
      "@babel/helpers - typeof";
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof = function(obj3) {
          return typeof obj3;
        };
      } else {
        _typeof = function(obj3) {
          return obj3 && typeof Symbol === "function" && obj3.constructor === Symbol && obj3 !== Symbol.prototype ? "symbol" : typeof obj3;
        };
      }
      return _typeof(obj2);
    }
    var getQueryParams = function getQueryParams2(qs) {
      if (typeof qs !== "string") {
        return {};
      }
      qs = qs.split("+").join(" ");
      var params = {};
      var match = qs.match(/(?:[?](?:[^=]+)=(?:[^&#]*)(?:[&](?:[^=]+)=(?:[^&#]*))*(?:[#].*)?)|(?:[#].*)/);
      var split;
      if (match === null) {
        return {};
      }
      split = match[0].substr(1).split(/[&#=]/);
      for (var i = 0; i < split.length; i += 2) {
        params[decodeURIComponent(split[i])] = decodeURIComponent(split[i + 1] || "");
      }
      return params;
    };
    var combineParams = function combineParams2(params, hasParams) {
      if (_typeof(params) !== "object") {
        return "";
      }
      var combined = "";
      var i = 0;
      var keys2 = Object.keys(params);
      if (keys2.length === 0) {
        return "";
      }
      keys2.sort();
      if (!hasParams) {
        combined += "?" + keys2[0] + "=" + params[keys2[0]];
        i += 1;
      }
      for (; i < keys2.length; i += 1) {
        combined += "&" + keys2[i] + "=" + params[keys2[i]];
      }
      return combined;
    };
    function getLetterTime(timeString) {
      var totalSeconds = 0;
      var timeValues = {
        "s": 1,
        "m": 1 * 60,
        "h": 1 * 60 * 60,
        "d": 1 * 60 * 60 * 24,
        "w": 1 * 60 * 60 * 24 * 7
      };
      var timePairs;
      timeString = timeString.replace(/([smhdw])/g, " $1 ").trim();
      timePairs = timeString.split(" ");
      for (var i = 0; i < timePairs.length; i += 2) {
        totalSeconds += parseInt(timePairs[i], 10) * timeValues[timePairs[i + 1] || "s"];
      }
      return totalSeconds;
    }
    function getColonTime(timeString) {
      var totalSeconds = 0;
      var timeValues = [1, 1 * 60, 1 * 60 * 60, 1 * 60 * 60 * 24, 1 * 60 * 60 * 24 * 7];
      var timePairs = timeString.split(":");
      for (var i = 0; i < timePairs.length; i++) {
        totalSeconds += parseInt(timePairs[i], 10) * timeValues[timePairs.length - i - 1];
      }
      return totalSeconds;
    }
    var getTime = function getTime2(timeString) {
      if (typeof timeString === "undefined") {
        return 0;
      }
      if (timeString.match(/^(\d+[smhdw]?)+$/)) {
        return getLetterTime(timeString);
      }
      if (timeString.match(/^(\d+:?)+$/)) {
        return getColonTime(timeString);
      }
      return 0;
    };
    var util = {
      getQueryParams,
      combineParams,
      getTime
    };
    var getQueryParams$1 = util.getQueryParams;
    function UrlParser() {
      for (var _i = 0, _arr = ["parseProvider", "parse", "bind", "create"]; _i < _arr.length; _i++) {
        var key = _arr[_i];
        this[key] = this[key].bind(this);
      }
      this.plugins = {};
    }
    var urlParser2 = UrlParser;
    UrlParser.prototype.parseProvider = function(url) {
      var match = url.match(/(?:(?:https?:)?\/\/)?(?:[^.]+\.)?(\w+)\./i);
      return match ? match[1] : void 0;
    };
    UrlParser.prototype.parse = function(url) {
      if (typeof url === "undefined") {
        return void 0;
      }
      var provider = this.parseProvider(url);
      var result;
      var plugin2 = this.plugins[provider];
      if (!provider || !plugin2 || !plugin2.parse) {
        return void 0;
      }
      result = plugin2.parse.call(plugin2, url, getQueryParams$1(url));
      if (result) {
        result = removeEmptyParameters(result);
        result.provider = plugin2.provider;
      }
      return result;
    };
    UrlParser.prototype.bind = function(plugin2) {
      this.plugins[plugin2.provider] = plugin2;
      if (plugin2.alternatives) {
        for (var i = 0; i < plugin2.alternatives.length; i += 1) {
          this.plugins[plugin2.alternatives[i]] = plugin2;
        }
      }
    };
    UrlParser.prototype.create = function(op) {
      if (_typeof(op) !== "object" || _typeof(op.videoInfo) !== "object") {
        return void 0;
      }
      var vi = op.videoInfo;
      var params = op.params;
      var plugin2 = this.plugins[vi.provider];
      params = params === "internal" ? vi.params : params || {};
      if (plugin2) {
        op.format = op.format || plugin2.defaultFormat;
        if (plugin2.formats.hasOwnProperty(op.format)) {
          return plugin2.formats[op.format].apply(plugin2, [vi, Object.assign({}, params)]);
        }
      }
      return void 0;
    };
    function removeEmptyParameters(result) {
      if (result.params && Object.keys(result.params).length === 0) {
        delete result.params;
      }
      return result;
    }
    var parser = new urlParser2();
    var base = parser;
    var combineParams$1 = util.combineParams;
    function CanalPlus() {
      this.provider = "canalplus";
      this.defaultFormat = "embed";
      this.formats = {
        embed: this.createEmbedUrl
      };
      this.mediaTypes = {
        VIDEO: "video"
      };
    }
    CanalPlus.prototype.parseParameters = function(params) {
      delete params.vid;
      return params;
    };
    CanalPlus.prototype.parse = function(url, params) {
      var _this = this;
      var result = {
        mediaType: this.mediaTypes.VIDEO,
        id: params.vid
      };
      result.params = _this.parseParameters(params);
      if (!result.id) {
        return void 0;
      }
      return result;
    };
    CanalPlus.prototype.createEmbedUrl = function(vi, params) {
      if (!vi.id || vi.mediaType !== this.mediaTypes.VIDEO) {
        return void 0;
      }
      var url = "http://player.canalplus.fr/embed/";
      params.vid = vi.id;
      url += combineParams$1(params);
      return url;
    };
    base.bind(new CanalPlus());
    var combineParams$2 = util.combineParams;
    function Coub() {
      this.provider = "coub";
      this.defaultFormat = "long";
      this.formats = {
        "long": this.createLongUrl,
        embed: this.createEmbedUrl
      };
      this.mediaTypes = {
        VIDEO: "video"
      };
    }
    Coub.prototype.parseUrl = function(url) {
      var match = url.match(/(?:embed|view)\/([a-zA-Z\d]+)/i);
      return match ? match[1] : void 0;
    };
    Coub.prototype.parse = function(url, params) {
      var result = {
        mediaType: this.mediaTypes.VIDEO,
        params,
        id: this.parseUrl(url)
      };
      if (!result.id) {
        return void 0;
      }
      return result;
    };
    Coub.prototype.createUrl = function(baseUrl, vi, params) {
      if (!vi.id || vi.mediaType !== this.mediaTypes.VIDEO) {
        return void 0;
      }
      var url = baseUrl + vi.id;
      url += combineParams$2(params);
      return url;
    };
    Coub.prototype.createLongUrl = function(vi, params) {
      return this.createUrl("https://coub.com/view/", vi, params);
    };
    Coub.prototype.createEmbedUrl = function(vi, params) {
      return this.createUrl("//coub.com/embed/", vi, params);
    };
    base.bind(new Coub());
    var combineParams$3 = util.combineParams, getTime$1 = util.getTime;
    function Dailymotion() {
      this.provider = "dailymotion";
      this.alternatives = ["dai"];
      this.defaultFormat = "long";
      this.formats = {
        "short": this.createShortUrl,
        "long": this.createLongUrl,
        embed: this.createEmbedUrl,
        image: this.createImageUrl
      };
      this.mediaTypes = {
        VIDEO: "video"
      };
    }
    Dailymotion.prototype.parseParameters = function(params) {
      return this.parseTime(params);
    };
    Dailymotion.prototype.parseTime = function(params) {
      if (params.start) {
        params.start = getTime$1(params.start);
      }
      return params;
    };
    Dailymotion.prototype.parseUrl = function(url) {
      var match = url.match(/(?:\/video|ly)\/([A-Za-z0-9]+)/i);
      return match ? match[1] : void 0;
    };
    Dailymotion.prototype.parse = function(url, params) {
      var _this = this;
      var result = {
        mediaType: this.mediaTypes.VIDEO,
        params: _this.parseParameters(params),
        id: _this.parseUrl(url)
      };
      return result.id ? result : void 0;
    };
    Dailymotion.prototype.createUrl = function(base2, vi, params) {
      if (!vi.id || vi.mediaType !== this.mediaTypes.VIDEO) {
        return void 0;
      }
      return base2 + vi.id + combineParams$3(params);
    };
    Dailymotion.prototype.createShortUrl = function(vi, params) {
      return this.createUrl("https://dai.ly/", vi, params);
    };
    Dailymotion.prototype.createLongUrl = function(vi, params) {
      return this.createUrl("https://dailymotion.com/video/", vi, params);
    };
    Dailymotion.prototype.createEmbedUrl = function(vi, params) {
      return this.createUrl("https://www.dailymotion.com/embed/video/", vi, params);
    };
    Dailymotion.prototype.createImageUrl = function(vi, params) {
      delete params.start;
      return this.createUrl("https://www.dailymotion.com/thumbnail/video/", vi, params);
    };
    base.bind(new Dailymotion());
    var combineParams$4 = util.combineParams, getTime$2 = util.getTime;
    function Twitch() {
      this.provider = "twitch";
      this.defaultFormat = "long";
      this.formats = {
        "long": this.createLongUrl,
        embed: this.createEmbedUrl
      };
      this.mediaTypes = {
        VIDEO: "video",
        STREAM: "stream",
        CLIP: "clip"
      };
    }
    Twitch.prototype.seperateId = function(id) {
      return {
        pre: id[0],
        id: id.substr(1)
      };
    };
    Twitch.prototype.parseChannel = function(result, params) {
      var channel = params.channel || params.utm_content || result.channel;
      delete params.utm_content;
      delete params.channel;
      return channel;
    };
    Twitch.prototype.parseUrl = function(url, result, params) {
      var match;
      match = url.match(/(clips\.)?twitch\.tv\/(?:(?:videos\/(\d+))|(\w+)(?:\/clip\/(\w+))?)/i);
      if (match && match[2]) {
        result.id = "v" + match[2];
      } else if (params.video) {
        result.id = params.video;
        delete params.video;
      } else if (params.clip) {
        result.id = params.clip;
        result.isClip = true;
        delete params.clip;
      } else if (match && match[1] && match[3]) {
        result.id = match[3];
        result.isClip = true;
      } else if (match && match[3] && match[4]) {
        result.channel = match[3];
        result.id = match[4];
        result.isClip = true;
      } else if (match && match[3]) {
        result.channel = match[3];
      }
      return result;
    };
    Twitch.prototype.parseMediaType = function(result) {
      var mediaType;
      if (result.id) {
        if (result.isClip) {
          mediaType = this.mediaTypes.CLIP;
          delete result.isClip;
        } else {
          mediaType = this.mediaTypes.VIDEO;
        }
      } else if (result.channel) {
        mediaType = this.mediaTypes.STREAM;
      }
      return mediaType;
    };
    Twitch.prototype.parseParameters = function(params) {
      if (params.t) {
        params.start = getTime$2(params.t);
        delete params.t;
      }
      return params;
    };
    Twitch.prototype.parse = function(url, params) {
      var _this = this;
      var result = {};
      result = _this.parseUrl(url, result, params);
      result.channel = _this.parseChannel(result, params);
      result.mediaType = _this.parseMediaType(result);
      result.params = _this.parseParameters(params);
      return result.channel || result.id ? result : void 0;
    };
    Twitch.prototype.createLongUrl = function(vi, params) {
      var url = "";
      if (vi.mediaType === this.mediaTypes.STREAM && vi.channel) {
        url = "https://twitch.tv/" + vi.channel;
      } else if (vi.mediaType === this.mediaTypes.VIDEO && vi.id) {
        var sep = this.seperateId(vi.id);
        url = "https://twitch.tv/videos/" + sep.id;
        if (params.start) {
          params.t = params.start + "s";
          delete params.start;
        }
      } else if (vi.mediaType === this.mediaTypes.CLIP && vi.id) {
        if (vi.channel) {
          url = "https://www.twitch.tv/" + vi.channel + "/clip/" + vi.id;
        } else {
          url = "https://clips.twitch.tv/" + vi.id;
        }
      } else {
        return void 0;
      }
      url += combineParams$4(params);
      return url;
    };
    Twitch.prototype.createEmbedUrl = function(vi, params) {
      var url = "https://player.twitch.tv/";
      if (vi.mediaType === this.mediaTypes.STREAM && vi.channel) {
        params.channel = vi.channel;
      } else if (vi.mediaType === this.mediaTypes.VIDEO && vi.id) {
        params.video = vi.id;
        if (params.start) {
          params.t = params.start + "s";
          delete params.start;
        }
      } else if (vi.mediaType === this.mediaTypes.CLIP && vi.id) {
        url = "https://clips.twitch.tv/embed";
        params.clip = vi.id;
      } else {
        return void 0;
      }
      url += combineParams$4(params);
      return url;
    };
    base.bind(new Twitch());
    var combineParams$5 = util.combineParams, getTime$3 = util.getTime;
    function Vimeo() {
      this.provider = "vimeo";
      this.alternatives = ["vimeopro"];
      this.defaultFormat = "long";
      this.formats = {
        "long": this.createLongUrl,
        embed: this.createEmbedUrl
      };
      this.mediaTypes = {
        VIDEO: "video"
      };
    }
    Vimeo.prototype.parseUrl = function(url) {
      var match = url.match(/(?:\/(?:channels\/[\w]+|(?:(?:album\/\d+|groups\/[\w]+)\/)?videos?))?\/(\d+)/i);
      return match ? match[1] : void 0;
    };
    Vimeo.prototype.parseParameters = function(params) {
      return this.parseTime(params);
    };
    Vimeo.prototype.parseTime = function(params) {
      if (params.t) {
        params.start = getTime$3(params.t);
        delete params.t;
      }
      return params;
    };
    Vimeo.prototype.parse = function(url, params) {
      var result = {
        mediaType: this.mediaTypes.VIDEO,
        params: this.parseParameters(params),
        id: this.parseUrl(url)
      };
      return result.id ? result : void 0;
    };
    Vimeo.prototype.createUrl = function(baseUrl, vi, params) {
      if (!vi.id || vi.mediaType !== this.mediaTypes.VIDEO) {
        return void 0;
      }
      var url = baseUrl + vi.id;
      var startTime = params.start;
      delete params.start;
      url += combineParams$5(params);
      if (startTime) {
        url += "#t=" + startTime;
      }
      return url;
    };
    Vimeo.prototype.createLongUrl = function(vi, params) {
      return this.createUrl("https://vimeo.com/", vi, params);
    };
    Vimeo.prototype.createEmbedUrl = function(vi, params) {
      return this.createUrl("//player.vimeo.com/video/", vi, params);
    };
    base.bind(new Vimeo());
    var combineParams$6 = util.combineParams, getTime$4 = util.getTime;
    function Wistia() {
      this.provider = "wistia";
      this.alternatives = [];
      this.defaultFormat = "long";
      this.formats = {
        "long": this.createLongUrl,
        embed: this.createEmbedUrl,
        embedjsonp: this.createEmbedJsonpUrl
      };
      this.mediaTypes = {
        VIDEO: "video",
        EMBEDVIDEO: "embedvideo"
      };
    }
    Wistia.prototype.parseUrl = function(url) {
      var match = url.match(/(?:(?:medias|iframe)\/|wvideo=)([\w-]+)/);
      return match ? match[1] : void 0;
    };
    Wistia.prototype.parseChannel = function(url) {
      var match = url.match(/(?:(?:https?:)?\/\/)?([^.]*)\.wistia\./);
      var channel = match ? match[1] : void 0;
      if (channel === "fast" || channel === "content") {
        return void 0;
      }
      return channel;
    };
    Wistia.prototype.parseParameters = function(params, result) {
      if (params.wtime) {
        params.start = getTime$4(params.wtime);
        delete params.wtime;
      }
      if (params.wvideo === result.id) {
        delete params.wvideo;
      }
      return params;
    };
    Wistia.prototype.parseMediaType = function(result) {
      if (result.id && result.channel) {
        return this.mediaTypes.VIDEO;
      } else if (result.id) {
        delete result.channel;
        return this.mediaTypes.EMBEDVIDEO;
      } else {
        return void 0;
      }
    };
    Wistia.prototype.parse = function(url, params) {
      var result = {
        id: this.parseUrl(url),
        channel: this.parseChannel(url)
      };
      result.params = this.parseParameters(params, result);
      result.mediaType = this.parseMediaType(result);
      if (!result.id) {
        return void 0;
      }
      return result;
    };
    Wistia.prototype.createUrl = function(vi, params, url) {
      if (params.start) {
        params.wtime = params.start;
        delete params.start;
      }
      url += combineParams$6(params);
      return url;
    };
    Wistia.prototype.createLongUrl = function(vi, params) {
      if (!vi.id || vi.mediaType !== this.mediaTypes.VIDEO) {
        return void 0;
      }
      var url = "https://" + vi.channel + ".wistia.com/medias/" + vi.id;
      return this.createUrl(vi, params, url);
    };
    Wistia.prototype.createEmbedUrl = function(vi, params) {
      if (!vi.id || !(vi.mediaType === this.mediaTypes.VIDEO || vi.mediaType === this.mediaTypes.EMBEDVIDEO)) {
        return void 0;
      }
      var url = "https://fast.wistia.com/embed/iframe/" + vi.id;
      return this.createUrl(vi, params, url);
    };
    Wistia.prototype.createEmbedJsonpUrl = function(vi) {
      if (!vi.id || !(vi.mediaType === this.mediaTypes.VIDEO || vi.mediaType === this.mediaTypes.EMBEDVIDEO)) {
        return void 0;
      }
      return "https://fast.wistia.com/embed/medias/" + vi.id + ".jsonp";
    };
    base.bind(new Wistia());
    var combineParams$7 = util.combineParams;
    function Youku() {
      this.provider = "youku";
      this.defaultFormat = "long";
      this.formats = {
        embed: this.createEmbedUrl,
        "long": this.createLongUrl,
        flash: this.createFlashUrl,
        "static": this.createStaticUrl
      };
      this.mediaTypes = {
        VIDEO: "video"
      };
    }
    Youku.prototype.parseUrl = function(url) {
      var match = url.match(/(?:(?:embed|sid)\/|v_show\/id_|VideoIDS=)([a-zA-Z0-9]+)/);
      return match ? match[1] : void 0;
    };
    Youku.prototype.parseParameters = function(params) {
      if (params.VideoIDS) {
        delete params.VideoIDS;
      }
      return params;
    };
    Youku.prototype.parse = function(url, params) {
      var _this = this;
      var result = {
        mediaType: this.mediaTypes.VIDEO,
        id: _this.parseUrl(url),
        params: _this.parseParameters(params)
      };
      if (!result.id) {
        return void 0;
      }
      return result;
    };
    Youku.prototype.createUrl = function(baseUrl, vi, params) {
      if (!vi.id || vi.mediaType !== this.mediaTypes.VIDEO) {
        return void 0;
      }
      var url = baseUrl + vi.id;
      url += combineParams$7(params);
      return url;
    };
    Youku.prototype.createEmbedUrl = function(vi, params) {
      return this.createUrl("http://player.youku.com/embed/", vi, params);
    };
    Youku.prototype.createLongUrl = function(vi, params) {
      return this.createUrl("http://v.youku.com/v_show/id_", vi, params);
    };
    Youku.prototype.createStaticUrl = function(vi, params) {
      return this.createUrl("http://static.youku.com/v1.0.0638/v/swf/loader.swf?VideoIDS=", vi, params);
    };
    Youku.prototype.createFlashUrl = function(vi, params) {
      if (!vi.id || vi.mediaType !== this.mediaTypes.VIDEO) {
        return void 0;
      }
      var url = "http://player.youku.com/player.php/sid/" + vi.id + "/v.swf";
      url += combineParams$7(params);
      return url;
    };
    base.bind(new Youku());
    var combineParams$8 = util.combineParams, getTime$5 = util.getTime;
    function YouTube() {
      this.provider = "youtube";
      this.alternatives = ["youtu", "ytimg"];
      this.defaultFormat = "long";
      this.formats = {
        "short": this.createShortUrl,
        "long": this.createLongUrl,
        embed: this.createEmbedUrl,
        shortImage: this.createShortImageUrl,
        longImage: this.createLongImageUrl
      };
      this.imageQualities = {
        "0": "0",
        "1": "1",
        "2": "2",
        "3": "3",
        DEFAULT: "default",
        HQDEFAULT: "hqdefault",
        SDDEFAULT: "sddefault",
        MQDEFAULT: "mqdefault",
        MAXRESDEFAULT: "maxresdefault"
      };
      this.defaultImageQuality = this.imageQualities.HQDEFAULT;
      this.mediaTypes = {
        VIDEO: "video",
        PLAYLIST: "playlist",
        SHARE: "share",
        CHANNEL: "channel"
      };
    }
    YouTube.prototype.parseVideoUrl = function(url) {
      var match = url.match(/(?:(?:v|vi|be|videos|embed)\/(?!videoseries)|(?:v|ci)=)([\w-]{11})/i);
      return match ? match[1] : void 0;
    };
    YouTube.prototype.parseChannelUrl = function(url) {
      var match = url.match(/\/channel\/([\w-]+)/);
      if (match) {
        return {
          id: match[1],
          mediaType: this.mediaTypes.CHANNEL
        };
      }
      match = url.match(/\/(?:c|user)\/([\w-]+)/);
      if (match) {
        return {
          name: match[1],
          mediaType: this.mediaTypes.CHANNEL
        };
      }
    };
    YouTube.prototype.parseParameters = function(params, result) {
      if (params.start || params.t) {
        params.start = getTime$5(params.start || params.t);
        delete params.t;
      }
      if (params.v === result.id) {
        delete params.v;
      }
      if (params.list === result.id) {
        delete params.list;
      }
      return params;
    };
    YouTube.prototype.parseMediaType = function(result) {
      if (result.params.list) {
        result.list = result.params.list;
        delete result.params.list;
      }
      if (result.id && !result.params.ci) {
        result.mediaType = this.mediaTypes.VIDEO;
      } else if (result.list) {
        delete result.id;
        result.mediaType = this.mediaTypes.PLAYLIST;
      } else if (result.params.ci) {
        delete result.params.ci;
        result.mediaType = this.mediaTypes.SHARE;
      } else {
        return void 0;
      }
      return result;
    };
    YouTube.prototype.parse = function(url, params) {
      var channelResult = this.parseChannelUrl(url);
      if (channelResult) {
        return channelResult;
      } else {
        var result = {
          params,
          id: this.parseVideoUrl(url)
        };
        result.params = this.parseParameters(params, result);
        result = this.parseMediaType(result);
        return result;
      }
    };
    YouTube.prototype.createShortUrl = function(vi, params) {
      if (!vi.id || vi.mediaType !== this.mediaTypes.VIDEO) {
        return void 0;
      }
      var url = "https://youtu.be/" + vi.id;
      if (params.start) {
        url += "#t=" + params.start;
      }
      return url;
    };
    YouTube.prototype.createLongUrl = function(vi, params) {
      var url = "";
      var startTime = params.start;
      delete params.start;
      if (vi.mediaType === this.mediaTypes.CHANNEL) {
        if (vi.id) {
          url += "https://www.youtube.com/channel/" + vi.id;
        } else if (vi.name) {
          url += "https://www.youtube.com/c/" + vi.name;
        } else {
          return void 0;
        }
      } else if (vi.mediaType === this.mediaTypes.PLAYLIST && vi.list) {
        params.feature = "share";
        url += "https://www.youtube.com/playlist";
      } else if (vi.mediaType === this.mediaTypes.VIDEO && vi.id) {
        params.v = vi.id;
        url += "https://www.youtube.com/watch";
      } else if (vi.mediaType === this.mediaTypes.SHARE && vi.id) {
        params.ci = vi.id;
        url += "https://www.youtube.com/shared";
      } else {
        return void 0;
      }
      if (vi.list) {
        params.list = vi.list;
      }
      url += combineParams$8(params);
      if (vi.mediaType !== this.mediaTypes.PLAYLIST && startTime) {
        url += "#t=" + startTime;
      }
      return url;
    };
    YouTube.prototype.createEmbedUrl = function(vi, params) {
      var url = "https://www.youtube.com/embed";
      if (vi.mediaType === this.mediaTypes.PLAYLIST && vi.list) {
        params.listType = "playlist";
      } else if (vi.mediaType === this.mediaTypes.VIDEO && vi.id) {
        url += "/" + vi.id;
        if (params.loop === "1") {
          params.playlist = vi.id;
        }
      } else {
        return void 0;
      }
      if (vi.list) {
        params.list = vi.list;
      }
      url += combineParams$8(params);
      return url;
    };
    YouTube.prototype.createImageUrl = function(baseUrl, vi, params) {
      if (!vi.id || vi.mediaType !== this.mediaTypes.VIDEO) {
        return void 0;
      }
      var url = baseUrl + vi.id + "/";
      var quality = params.imageQuality || this.defaultImageQuality;
      return url + quality + ".jpg";
    };
    YouTube.prototype.createShortImageUrl = function(vi, params) {
      return this.createImageUrl("https://i.ytimg.com/vi/", vi, params);
    };
    YouTube.prototype.createLongImageUrl = function(vi, params) {
      return this.createImageUrl("https://img.youtube.com/vi/", vi, params);
    };
    base.bind(new YouTube());
    var combineParams$9 = util.combineParams, getTime$6 = util.getTime;
    function SoundCloud() {
      this.provider = "soundcloud";
      this.defaultFormat = "long";
      this.formats = {
        "long": this.createLongUrl,
        embed: this.createEmbedUrl
      };
      this.mediaTypes = {
        TRACK: "track",
        PLAYLIST: "playlist",
        APITRACK: "apitrack",
        APIPLAYLIST: "apiplaylist"
      };
    }
    SoundCloud.prototype.parseUrl = function(url, result) {
      var match = url.match(/(?:m\.)?soundcloud\.com\/(?:([\w-]+)\/(sets\/)?)([\w-]+)/i);
      if (!match) {
        return result;
      }
      result.channel = match[1];
      if (match[1] === "playlists" || match[2]) {
        result.list = match[3];
      } else {
        result.id = match[3];
      }
      return result;
    };
    SoundCloud.prototype.parseParameters = function(params) {
      if (params.t) {
        params.start = getTime$6(params.t);
        delete params.t;
      }
      return params;
    };
    SoundCloud.prototype.parseMediaType = function(result) {
      if (result.id) {
        if (result.channel === "tracks") {
          delete result.channel;
          delete result.params.url;
          result.mediaType = this.mediaTypes.APITRACK;
        } else {
          result.mediaType = this.mediaTypes.TRACK;
        }
      }
      if (result.list) {
        if (result.channel === "playlists") {
          delete result.channel;
          delete result.params.url;
          result.mediaType = this.mediaTypes.APIPLAYLIST;
        } else {
          result.mediaType = this.mediaTypes.PLAYLIST;
        }
      }
      return result;
    };
    SoundCloud.prototype.parse = function(url, params) {
      var result = {};
      result = this.parseUrl(url, result);
      result.params = this.parseParameters(params);
      result = this.parseMediaType(result);
      if (!result.id && !result.list) {
        return void 0;
      }
      return result;
    };
    SoundCloud.prototype.createLongUrl = function(vi, params) {
      var url = "";
      var startTime = params.start;
      delete params.start;
      if (vi.mediaType === this.mediaTypes.TRACK && vi.id && vi.channel) {
        url = "https://soundcloud.com/" + vi.channel + "/" + vi.id;
      } else if (vi.mediaType === this.mediaTypes.PLAYLIST && vi.list && vi.channel) {
        url = "https://soundcloud.com/" + vi.channel + "/sets/" + vi.list;
      } else if (vi.mediaType === this.mediaTypes.APITRACK && vi.id) {
        url = "https://api.soundcloud.com/tracks/" + vi.id;
      } else if (vi.mediaType === this.mediaTypes.APIPLAYLIST && vi.list) {
        url = "https://api.soundcloud.com/playlists/" + vi.list;
      } else {
        return void 0;
      }
      url += combineParams$9(params);
      if (startTime) {
        url += "#t=" + startTime;
      }
      return url;
    };
    SoundCloud.prototype.createEmbedUrl = function(vi, params) {
      var url = "https://w.soundcloud.com/player/";
      delete params.start;
      if (vi.mediaType === this.mediaTypes.APITRACK && vi.id) {
        params.url = "https%3A//api.soundcloud.com/tracks/" + vi.id;
      } else if (vi.mediaType === this.mediaTypes.APIPLAYLIST && vi.list) {
        params.url = "https%3A//api.soundcloud.com/playlists/" + vi.list;
      } else {
        return void 0;
      }
      url += combineParams$9(params);
      return url;
    };
    base.bind(new SoundCloud());
    var combineParams$a = util.combineParams;
    function TeacherTube() {
      this.provider = "teachertube";
      this.alternatives = [];
      this.defaultFormat = "long";
      this.formats = {
        "long": this.createLongUrl,
        embed: this.createEmbedUrl
      };
      this.mediaTypes = {
        VIDEO: "video",
        AUDIO: "audio",
        DOCUMENT: "document",
        CHANNEL: "channel",
        COLLECTION: "collection",
        GROUP: "group"
      };
    }
    TeacherTube.prototype.parse = function(url, params) {
      var result = {};
      result.list = this.parsePlaylist(params);
      result.params = params;
      var match = url.match(/\/(audio|video|document|user\/channel|collection|group)\/(?:[\w-]+-)?(\w+)/);
      if (!match) {
        return void 0;
      }
      result.mediaType = this.parseMediaType(match[1]);
      result.id = match[2];
      return result;
    };
    TeacherTube.prototype.parsePlaylist = function(params) {
      if (params["playlist-id"]) {
        var list2 = params["playlist-id"];
        delete params["playlist-id"];
        return list2;
      }
      return void 0;
    };
    TeacherTube.prototype.parseMediaType = function(mediaTypeMatch) {
      switch (mediaTypeMatch) {
        case "audio":
          return this.mediaTypes.AUDIO;
        case "video":
          return this.mediaTypes.VIDEO;
        case "document":
          return this.mediaTypes.DOCUMENT;
        case "user/channel":
          return this.mediaTypes.CHANNEL;
        case "collection":
          return this.mediaTypes.COLLECTION;
        case "group":
          return this.mediaTypes.GROUP;
      }
    };
    TeacherTube.prototype.createLongUrl = function(vi, params) {
      if (!vi.id) {
        return void 0;
      }
      var url = "https://www.teachertube.com/";
      if (vi.list) {
        params["playlist-id"] = vi.list;
      }
      if (vi.mediaType === this.mediaTypes.CHANNEL) {
        url += "user/channel/";
      } else {
        url += vi.mediaType + "/";
      }
      url += vi.id;
      url += combineParams$a(params);
      return url;
    };
    TeacherTube.prototype.createEmbedUrl = function(vi, params) {
      if (!vi.id) {
        return void 0;
      }
      var url = "https://www.teachertube.com/embed/";
      if (vi.mediaType === this.mediaTypes.VIDEO || vi.mediaType === this.mediaTypes.AUDIO) {
        url += vi.mediaType + "/" + vi.id;
      } else {
        return void 0;
      }
      url += combineParams$a(params);
      return url;
    };
    base.bind(new TeacherTube());
    var combineParams$b = util.combineParams;
    function TikTok() {
      this.provider = "tiktok";
      this.defaultFormat = "long";
      this.formats = {
        "long": this.createLongUrl
      };
      this.mediaTypes = {
        VIDEO: "video"
      };
    }
    TikTok.prototype.parse = function(url, params) {
      var result = {
        params,
        mediaType: this.mediaTypes.VIDEO
      };
      var match = url.match(/@([^/]+)\/video\/(\d{19})/);
      if (!match) {
        return;
      }
      result.channel = match[1];
      result.id = match[2];
      return result;
    };
    TikTok.prototype.createLongUrl = function(vi, params) {
      var url = "";
      if (vi.mediaType === this.mediaTypes.VIDEO && vi.id && vi.channel) {
        url += "https://www.tiktok.com/@".concat(vi.channel, "/video/").concat(vi.id);
      } else {
        return void 0;
      }
      url += combineParams$b(params);
      return url;
    };
    base.bind(new TikTok());
    var combineParams$c = util.combineParams;
    function Ted() {
      this.provider = "ted";
      this.formats = {
        "long": this.createLongUrl,
        embed: this.createEmbedUrl
      };
      this.mediaTypes = {
        VIDEO: "video",
        PLAYLIST: "playlist"
      };
    }
    Ted.prototype.parseUrl = function(url, result) {
      var match = url.match(/\/(talks|playlists\/(\d+))\/([\w-]+)/);
      var channel = match ? match[1] : void 0;
      if (!channel) {
        return result;
      }
      result.channel = channel.split("/")[0];
      result.id = match[3];
      if (result.channel === "playlists") {
        result.list = match[2];
      }
      return result;
    };
    Ted.prototype.parseMediaType = function(result) {
      if (result.id && result.channel === "playlists") {
        delete result.channel;
        result.mediaType = this.mediaTypes.PLAYLIST;
      }
      if (result.id && result.channel === "talks") {
        delete result.channel;
        result.mediaType = this.mediaTypes.VIDEO;
      }
      return result;
    };
    Ted.prototype.parse = function(url, params) {
      var result = {
        params
      };
      result = this.parseUrl(url, result);
      result = this.parseMediaType(result);
      if (!result.id) {
        return void 0;
      }
      return result;
    };
    Ted.prototype.createLongUrl = function(vi, params) {
      var url = "";
      if (vi.mediaType === this.mediaTypes.VIDEO && vi.id) {
        url += "https://ted.com/talks/" + vi.id;
      } else if (vi.mediaType === this.mediaTypes.PLAYLIST && vi.id) {
        url += "https://ted.com/playlists/" + vi.list + "/" + vi.id;
      } else {
        return void 0;
      }
      url += combineParams$c(params);
      return url;
    };
    Ted.prototype.createEmbedUrl = function(vi, params) {
      var url = "https://embed.ted.com/";
      if (vi.mediaType === this.mediaTypes.PLAYLIST && vi.id) {
        url += "playlists/" + vi.list + "/" + vi.id;
      } else if (vi.mediaType === this.mediaTypes.VIDEO && vi.id) {
        url += "talks/" + vi.id;
      } else {
        return void 0;
      }
      url += combineParams$c(params);
      return url;
    };
    base.bind(new Ted());
    var lib = base;
    return lib;
  });
})(jsVideoUrlParser);
var urlParser = jsVideoUrlParser.exports;
var convertPasteText = {
  command: "convertPasteText",
  execute: async (editor, text2) => {
    const embedUrl = urlParser.create({
      videoInfo: urlParser.parse(text2),
      format: "embed",
      mediaType: "clip"
    });
    if (embedUrl) {
      const center2 = editor.context.viewport.center;
      const width2 = 300;
      const height2 = 200;
      editor.context.commands.emit("newComponent", "iframe", {
        x: center2[0] - width2 / 2,
        y: center2[1] - height2 / 2,
        width: width2,
        height: height2,
        backgroundColor: "transparent",
        url: embedUrl
      });
    }
  }
};
var __glob_0_31 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": convertPasteText
}, Symbol.toStringTag, { value: "Module" }));
function convertPath(editor, pathString2, rect2 = null) {
  var current = editor.context.selection.current;
  if (current) {
    if (current.is("svg-path", "svg-brush", "svg-textpath")) {
      var d = pathString2;
      if (rect2) {
        var parser = new PathParser(pathString2);
        parser.scale(current.width / rect2.width, current.height / rect2.height);
        d = parser.d;
      }
      editor.context.commands.executeCommand("setAttribute", "set attribute -d", editor.context.selection.packByValue({ d }, current.id));
    } else if (current.clipPath.includes("path")) {
      var d = pathString2;
      if (rect2) {
        var parser = new PathParser(pathString2);
        parser.scale(current.width / rect2.width, current.height / rect2.height);
        d = parser.d;
      }
      editor.context.commands.executeCommand("setAttribute", "change clip path", editor.context.selection.packByValue({ clipPath: `path(${d})` }, current.id));
    }
  }
}
var __glob_0_32 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": convertPath
}, Symbol.toStringTag, { value: "Module" }));
var copy_path = {
  command: "copy.path",
  description: "copy as path for item with path string(d attribute)",
  execute: function(editor) {
    const current = editor.context.selection.current;
    if (current) {
      let newPath = PathParser.fromSVGString(current.d);
      try {
        const newLayerAttrs = current.toSVGPath();
        editor.context.commands.executeCommand("addLayer", `copy path`, editor.createModel(__spreadValues(__spreadValues({
          itemType: "svg-path"
        }, newLayerAttrs), current.updatePath(newPath.d))), true, current.parent);
      } catch (e) {
        console.error(e);
      }
    }
  }
};
var __glob_0_33 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": copy_path
}, Symbol.toStringTag, { value: "Module" }));
var copyLayer = {
  command: "history.copyLayer",
  description: "copy in selected items ",
  description_ko: ["\uC120\uD0DD\uB41C \uC544\uC774\uD15C\uC744 \uAE30\uC900\uC73C\uB85C \uBCF5\uC81C\uD55C\uB2E4. "],
  execute: async function(editor, ids = []) {
    let currentIds = ids.map((id) => editor.get(id)).filter(Boolean).map((item) => item.id);
    if (!currentIds.length) {
      currentIds = editor.context.selection.ids;
    }
    if (!currentIds.length)
      return;
    const items = await editor.json.renderAll(currentIds.map((it) => editor.get(it)));
    const newIds = [];
    const itemList = {};
    const parentList = {};
    let updateData = {};
    items.forEach((itemJSON) => {
      const referenceId = itemJSON.referenceId;
      const sourceItem = editor.get(referenceId);
      parentList[sourceItem.parentId] = sourceItem.parent;
      const model = editor.createModel(itemJSON);
      model.renameWithCount();
      sourceItem.insertAfter(model);
      newIds.push(model.id);
      itemList[model.id] = itemJSON;
      updateData[model.id] = model.toCloneObject();
    });
    Object.values(parentList).forEach((parent) => {
      updateData = __spreadValues(__spreadValues({}, updateData), parent.attrsWithId("children"));
    });
    editor.context.commands.emit("setAttribute", updateData);
    editor.nextTick(() => {
      editor.context.selection.select(...newIds);
    });
  }
};
var __glob_0_34 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": copyLayer
}, Symbol.toStringTag, { value: "Module" }));
var copyTimelineProperty = {
  command: "copyTimelineProperty",
  execute: function(editor, layerId, property, newTime = null) {
    _currentProject(editor, (project2) => {
      project2.copyTimelineKeyframe(layerId, property, newTime);
      editor.emit("refreshTimeline");
    });
  }
};
var __glob_0_35 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": copyTimelineProperty
}, Symbol.toStringTag, { value: "Module" }));
var deleteTimelineKeyframe = {
  command: "deleteTimelineKeyframe",
  execute: function(editor) {
    _currentProject(editor, (project2) => {
      editor.timeline.each((item) => {
        project2.deleteTimelineKeyframe(item.layerId, item.property, item.id);
      });
      editor.timeline.empty();
      editor.emit("refreshTimeline");
      editor.emit("refreshSelectedOffset");
    });
  }
};
var __glob_0_36 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": deleteTimelineKeyframe
}, Symbol.toStringTag, { value: "Module" }));
var doubleclick_item = {
  command: "doubleclick.item",
  execute: function(editor, evt, id) {
    const item = editor.get(id);
    if (editor.context.selection.isOne && item) {
      if (editor.context.selection.checkChildren(item.id)) {
        editor.context.selection.select(item);
      } else {
        if (editor.context.selection.check(item)) {
          editor.context.commands.emit("open.editor");
          editor.emit("removeGuideLine");
        } else {
          this.selectInWorldPosition(editor, evt, item);
        }
      }
    } else {
      this.selectInWorldPosition(editor, evt, item);
    }
  },
  selectInWorldPosition: function(editor, evt, item) {
    const point2 = editor.context.viewport.getWorldPosition(evt);
    if (editor.context.selection.hasPoint(point2) || editor.context.selection.hasChildrenPoint(point2)) {
      editor.context.selection.select(item);
      editor.snapManager.clear();
    }
  }
};
var __glob_0_37 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": doubleclick_item
}, Symbol.toStringTag, { value: "Module" }));
function downloadFile(datauri, filename = "elf.json") {
  var a = document.createElement("a");
  a.href = datauri;
  a.download = filename;
  a.click();
}
var downloadJSON = {
  command: "downloadJSON",
  execute: function(editor, filename) {
    var json = JSON.stringify(editor.context.modelManager.toJSON());
    var datauri = "data:application/json;base64," + window.btoa(unescape(encodeURIComponent(json)));
    downloadFile(datauri, filename || "elf.json");
  }
};
var __glob_0_38 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": downloadJSON
}, Symbol.toStringTag, { value: "Module" }));
var ExportManager = {
  makeProjectStyle(item) {
    const keyframeString = item.toKeyframeString();
    const rootVariable = item.toRootVariableCSS();
    return `
      :root {
        ${CSS_TO_STRING(rootVariable)}
      }
      /* keyframe */
      ${keyframeString}
    `;
  },
  makeStyle(item, appendCSS = "") {
    if (item.is("project")) {
      return this.makeProjectStyle(item);
    }
    const cssString = item.generateView(`[data-id='${item.id}']`, appendCSS);
    return `
    ${cssString}
    ` + item.layers.map((it) => {
      return this.makeStyle(it);
    }).join("");
  },
  makeSvg(project2) {
    const SVGString = project2.toSVGString ? project2.toSVGString() : "";
    return `
      ${SVGString ? `<svg width="0" height="0">${SVGString}</svg>` : ""}
    `;
  },
  generateSVG(editor, rootItem) {
    return editor.replaceLocalUrltoRealUrl(editor.svg.render(rootItem));
  }
};
function createImagePng(img, callback, imageType = "image/png") {
  var canvas = Dom.create("canvas");
  var { width: width2, height: height2 } = img;
  canvas.resize({ width: width2, height: height2 });
  canvas.drawImage(img);
  callback && callback(canvas.toDataURL(imageType));
}
var downloadPNG = {
  command: "downloadPNG",
  execute: function(editor) {
    const item = editor.context.selection.current;
    if (item) {
      const svgString = ExportManager.generateSVG(editor, item).trim();
      const datauri = "data:image/svg+xml;base64," + window.btoa(svgString);
      const filename = item.id;
      loadOriginalImage({ local: datauri }, (info, img) => {
        createImagePng(img, (pngDataUri) => {
          downloadFile(pngDataUri, filename);
        });
      });
    }
  }
};
var __glob_0_39 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": downloadPNG
}, Symbol.toStringTag, { value: "Module" }));
var downloadSVG = {
  command: "downloadSVG",
  execute: function(editor) {
    const item = editor.context.selection.current;
    if (item) {
      var svgString = ExportManager.generateSVG(editor, item).trim();
      var datauri = "data:image/svg+xml;base64," + window.btoa(svgString);
      var filename = item.id;
      downloadFile(datauri, filename);
    }
  }
};
var __glob_0_40 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": downloadSVG
}, Symbol.toStringTag, { value: "Module" }));
var drop_asset = {
  command: "drop.asset",
  execute: async function(editor, obj2, id = null) {
    if (obj2.color) {
      editor.context.commands.emit("addBackgroundColor", obj2.color, id);
    } else if (obj2.gradient) {
      editor.context.commands.emit("addBackgroundImageGradient", obj2.gradient, id);
    } else if (obj2.pattern) {
      editor.context.commands.emit("addBackgroundImagePattern", obj2.pattern, id);
    } else if (obj2.imageUrl) {
      editor.context.commands.emit("addBackgroundImageAsset", obj2.imageUrl, id);
    } else if (obj2.asset) {
      const assetData = await editor.storageManager.getCustomAsset(obj2.asset.id);
      if (assetData) {
        editor.context.commands.emit("addArtBoard", assetData, obj2.asset.center);
      }
    }
    _doForceRefreshSelection(editor);
  }
};
var __glob_0_41 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": drop_asset
}, Symbol.toStringTag, { value: "Module" }));
var dropImageUrl = {
  command: "dropImageUrl",
  execute: function(editor, imageUrl) {
    loadOriginalImage({ local: imageUrl }, (info) => {
      editor.context.commands.emit("addImage", __spreadValues({ src: info.local }, info));
    });
  }
};
var __glob_0_42 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": dropImageUrl
}, Symbol.toStringTag, { value: "Module" }));
var editor_config_body_event = {
  command: "change.bodyEvent",
  description: "fire when bodyEvent was set",
  execute: function(editor) {
    const $target = Dom.create(editor.context.config.get("bodyEvent").target);
    editor.context.config.init("onMouseMovepageContainer", $target);
  }
};
var __glob_0_43 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": editor_config_body_event
}, Symbol.toStringTag, { value: "Module" }));
var fileDropItems = {
  command: "fileDropItems",
  execute: function(editor, items = []) {
    editor.context.commands.emit("updateResource", items);
  }
};
var __glob_0_44 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": fileDropItems
}, Symbol.toStringTag, { value: "Module" }));
function timecode(fps, seconds) {
  var h = Math.floor(seconds / 3600);
  var m = Math.floor(seconds / 60 % 60);
  var s = Math.floor(seconds % 60);
  var f = Math.round((seconds - Math.floor(seconds)) * fps);
  if (f === fps) {
    f = 0;
    s += 1;
    if (s === 60) {
      m += 1;
      if (m === 60) {
        h += 1;
      }
    }
  }
  return [h, m, s, f].map((t) => {
    return (t + "").padStart(2, "0");
  }).join(":");
}
function makeTimer(opt) {
  var timer2 = {
    id: 0,
    start: 0,
    speed: opt.speed || 1,
    elapsed: opt.elapsed || 0,
    duration: opt.duration || 0,
    iterationStartCount: 1,
    iterationCount: opt.iterationCount || Number.MAX_SAFE_INTEGER,
    direction: opt.direction || "normal",
    log: [],
    logIndex: 0,
    tick: opt.tick || (() => {
    }),
    startCallback: opt.start || (() => {
    }),
    endCallback: opt.end || (() => {
    }),
    firstCallback: opt.first || (() => {
    }),
    lastCallback: opt.last || (() => {
    })
  };
  const isForward = () => {
    if (timer2.direction === "normal") {
      return true;
    } else if (timer2.direction === "reverse") {
      return false;
    } else if (timer2.direction === "alternate") {
      return timer2.iterationStartCount % 2 === 1;
    } else if (timer2.direction === "alternate-reverse") {
      return timer2.iterationStartCount % 2 === 0;
    }
  };
  const calculateForDirection = (rate) => {
    return isForward() ? rate : 1 - rate;
  };
  const tick = (now) => {
    var isStart = false;
    if (timer2.start === null) {
      timer2.start = now;
      isStart = true;
    }
    const dt = now - timer2.start;
    timer2.elapsed += dt * timer2.speed;
    timer2.start = now;
    if (timer2.elapsed > timer2.duration) {
      timer2.elapsed = timer2.duration;
    }
    var elapsed = calculateForDirection(timer2.elapsed / timer2.duration) * timer2.duration;
    if (isStart)
      timer2.startCallback(elapsed, timer2);
    timer2.log[timer2.logIndex++] = { elapsed, dt: timer2.lastTime - elapsed };
    timer2.lastTime = elapsed;
    timer2.tick(elapsed, timer2);
    if (timer2.elapsed === timer2.duration) {
      end2();
    } else {
      frameStart();
    }
  };
  const frameStart = () => {
    timer2.id = window.requestAnimationFrame(tick);
  };
  const end2 = () => {
    timer2.endCallback(timer2.elapsed, timer2);
    timer2.iterationStartCount++;
    if (timer2.iterationStartCount > timer2.iterationCount) {
      timer2.lastCallback(timer2.elapsed, timer2);
      window.cancelAnimationFrame(timer2.id);
    } else {
      timer2.start = null;
      timer2.elapsed = 0;
      frameStart();
    }
  };
  const play2 = (opt2 = {}) => {
    timer2.start = null;
    timer2.iterationStartCount = 1;
    timer2.log = [];
    timer2.lastTime = 0;
    timer2.logIndex = 0;
    if (isNumber(opt2.elapsed))
      timer2.elapsed = opt2.elapsed;
    if (isNumber(opt2.speed))
      timer2.speed = opt2.speed;
    if (isNumber(opt2.duration))
      timer2.duration = opt2.duration;
    if (isNumber(opt2.iterationCount))
      timer2.iterationCount = opt2.iterationCount || Number.MAX_SAFE_INTEGER;
    if (isString(opt2.direction))
      timer2.direction = opt2.direction;
    if (isFunction(opt2.tick))
      timer2.tick = opt2.tick;
    if (isFunction(opt2.start))
      timer2.startCallback = opt2.start;
    if (isFunction(opt2.end))
      timer2.endCallback = opt2.end;
    if (isFunction(opt2.first))
      timer2.firstCallback = opt2.first;
    if (isFunction(opt2.last))
      timer2.lastCallback = opt2.last;
    if (isFunction(opt2.stop))
      timer2.stopCallback = opt2.stop;
    timer2.firstCallback(timer2.elapsed, timer2);
    frameStart();
  };
  const stop = () => {
    timer2.stopCallback(timer2.elapsed, timer2);
    window.cancelAnimationFrame(timer2.id);
  };
  const seek = (t) => {
    timer2.elapsed = t;
    timer2.tick(timer2.elapsed, timer2);
  };
  const first = () => {
    seek(0);
  };
  const last = () => {
    seek(timer2.duration);
  };
  return {
    play: play2,
    stop,
    tick,
    first,
    last,
    seek,
    timer: timer2
  };
}
var firstTimelineItem = {
  command: "firstTimelineItem",
  execute: function(editor) {
    _currentProject(editor, (project2, timeline) => {
      var firstTime = project2.getSelectedTimelineFirstTime();
      project2.setTimelineCurrentTime(timecode(timeline.fps, firstTime));
      project2.seek();
      editor.emit("playTimeline");
    });
  }
};
var __glob_0_45 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": firstTimelineItem
}, Symbol.toStringTag, { value: "Module" }));
var group_item = {
  command: "group.item",
  execute: function(editor, opt = {}) {
    if (editor.context.selection.length === 0)
      return;
    const project2 = editor.context.selection.currentProject;
    if (project2) {
      project2.generateListNumber();
      const list2 = editor.context.selection.map((item) => {
        return { depth: item.depth, item };
      });
      list2.sort((a, b) => {
        if (a.depth === b.depth) {
          return a.no > b.no ? -1 : 1;
        }
        return a.depth > b.depth ? 1 : -1;
      });
      const groupLayer = editor.createModel(__spreadValues(__spreadValues({
        itemType: "rect"
      }, editor.context.selection.itemRect), opt));
      list2[0].item.insertAfter(groupLayer);
      list2.forEach(({ item }) => {
        groupLayer.appendChild(item);
      });
      editor.context.selection.select(groupLayer);
      editor.emit("refreshAll");
    }
  }
};
var __glob_0_46 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": group_item
}, Symbol.toStringTag, { value: "Module" }));
var history_addLayer = {
  command: "history.addLayer",
  description: "add layer in history ",
  execute: function(editor, message, layer, isSelected = true, containerItem) {
    editor.context.commands.emit("addLayer", layer, isSelected, containerItem);
    editor.nextTick(() => {
      editor.context.history.add(message, this, {
        currentValues: [layer, isSelected, containerItem],
        undoValues: [layer.id]
      });
    });
    editor.nextTick(() => {
      editor.context.history.saveSelection();
    });
  },
  redo: function(editor, { currentValues }) {
    editor.context.commands.emit("addLayer", ...currentValues);
    editor.nextTick(() => {
      editor.emit("refreshAll");
    });
  },
  undo: function(editor, { undoValues }) {
    const ids = undoValues;
    const items = editor.context.selection.itemsByIds(ids);
    items.forEach((item) => {
      if (item) {
        item.remove();
      }
    });
    editor.nextTick(() => {
      editor.context.selection.empty();
      editor.emit("refreshAll");
    });
  }
};
var __glob_0_47 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": history_addLayer
}, Symbol.toStringTag, { value: "Module" }));
var history_bring_forward = {
  command: "history.bring.forward",
  description: "bring forward",
  execute: function(editor, message, layer = editor.context.selection.current) {
    const currentLayer = editor.get(layer);
    const lastValues = currentLayer.hierarchy;
    const oldParentLayer = currentLayer.parent;
    let currentValues = {};
    let nextParentLayer = null;
    if (currentLayer.isLast) {
      nextParentLayer = oldParentLayer.next;
      if (!nextParentLayer) {
        return;
      }
      if (nextParentLayer.enableHasChildren()) {
        nextParentLayer.appendChild(currentLayer);
        currentValues = currentLayer.hierarchy;
      } else {
        nextParentLayer.insertAfter(currentLayer);
        currentValues = currentLayer.hierarchy;
      }
    } else {
      currentLayer.parent.bringForward(currentLayer.id);
      currentValues = currentLayer.hierarchy;
    }
    editor.context.commands.emit("setAttribute", __spreadValues(__spreadValues(__spreadValues({}, oldParentLayer.attrsWithId("children")), currentLayer.attrsWithId("x", "y", "angle")), currentLayer.parent.attrsWithId("children")));
    editor.nextTick(() => {
      editor.context.history.add(message, this, {
        currentValues: [currentValues],
        undoValues: [lastValues]
      });
    });
    editor.nextTick(() => {
      editor.context.history.saveSelection();
    });
  },
  redo: function(editor, { currentValues: [newValues], undoValues: [lastValues] }) {
    const currentLayer = editor.get(newValues.id);
    const currentTarget = editor.get(newValues.parentId);
    const lastParent = editor.get(lastValues.parentId);
    currentTarget.insertChild(currentLayer, newValues.index);
    currentLayer.reset(newValues.attrs);
    editor.context.commands.emit("setAttribute", __spreadValues(__spreadValues(__spreadValues({}, lastParent.attrsWithId("children")), currentLayer.attrsWithId("x", "y", "angle")), currentTarget.attrsWithId("children")));
  },
  undo: function(editor, { currentValues: [newValues], undoValues: [lastValues] }) {
    const currentLayer = lastValues;
    const lastLayer = editor.get(currentLayer.id);
    const lastParent = editor.get(currentLayer.parentId);
    const currentParent = editor.get(newValues.parentId);
    const lastIndex = currentLayer.index;
    lastParent.insertChild(lastLayer, lastIndex);
    lastLayer.reset(lastValues.attrs);
    editor.context.commands.emit("setAttribute", __spreadValues(__spreadValues(__spreadValues({}, lastLayer.attrsWithId("x", "y", "angle")), lastParent.attrsWithId("children")), currentParent.attrsWithId("children")));
  }
};
var __glob_0_48 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": history_bring_forward
}, Symbol.toStringTag, { value: "Module" }));
var history_bring_front = {
  command: "history.bring.front",
  description: "bring front",
  execute: function(editor, message, layer = editor.context.selection.current) {
    const currentLayer = editor.get(layer);
    const lastValues = currentLayer.hierachy;
    const oldParentLayer = currentLayer.parent;
    let currentValues = {};
    if (currentLayer.isLast) {
      return;
    } else {
      currentLayer.parent.bringFront(currentLayer.id);
      currentValues = currentLayer.hierarchy;
    }
    editor.context.commands.emit("setAttribute", __spreadValues(__spreadValues({}, oldParentLayer.attrsWithId("children")), currentLayer.attrsWithId("x", "y", "angle")));
    editor.nextTick(() => {
      editor.context.history.add(message, this, {
        currentValues: [currentValues],
        undoValues: [lastValues]
      });
    });
    editor.nextTick(() => {
      editor.context.history.saveSelection();
    });
  },
  redo: function(editor, { currentValues: [newValues] }) {
    const currentLayer = editor.get(newValues.id);
    const currentTarget = editor.get(newValues.parentId);
    currentTarget.insertChild(currentLayer, newValues.index);
    currentLayer.reset(newValues.attrs);
    editor.context.commands.emit("setAttribute", __spreadValues(__spreadValues({}, currentLayer.attrsWithId("x", "y", "angle")), currentTarget.attrsWithId("children")));
  },
  undo: function(editor, { undoValues: [lastValues] }) {
    const currentLayer = lastValues;
    const lastLayer = editor.get(currentLayer.id);
    const lastParent = editor.get(currentLayer.parentId);
    const lastIndex = currentLayer.index;
    lastParent.insertChild(lastLayer, lastIndex);
    editor.context.commands.emit("setAttribute", __spreadValues(__spreadValues({}, lastLayer.attrsWithId("x", "y", "angle")), lastParent.attrsWithId("children")));
  }
};
var __glob_0_49 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": history_bring_front
}, Symbol.toStringTag, { value: "Module" }));
var history_clipboard_paste = {
  command: "history.clipboard.paste",
  description: "paste in clipboard ",
  description_ko: ["\uD074\uB9BD\uBCF4\uB4DC \uB370\uC774\uD0C0\uB97C \uAE30\uC900\uC73C\uB85C paste \uB97C \uC801\uC6A9\uD55C\uB2E4. "],
  execute: async function(editor, message, clipboardData = void 0, hasHistory = true) {
    const data = clipboardData || editor.context.clipboard.last;
    if (data.type == ClipboardActionType.COPY) {
      const ids = data.data;
      const items = await editor.json.renderAll(ids.map((it) => editor.get(it)));
      const newIds = [];
      const itemList = {};
      const parentList = {};
      let updateData = {};
      items.forEach((itemJSON) => {
        const referenceId = itemJSON.referenceId;
        const sourceItem = editor.get(referenceId);
        parentList[sourceItem.parentId] = sourceItem.parent;
        const model = editor.createModel(itemJSON);
        model.renameWithCount();
        sourceItem.insertAfter(model);
        newIds.push(model.id);
        itemList[model.id] = itemJSON;
        updateData[model.id] = model.toCloneObject();
      });
      Object.values(parentList).forEach((parent) => {
        updateData = __spreadValues(__spreadValues({}, updateData), parent.attrsWithId("children"));
      });
      editor.context.commands.emit("setAttribute", updateData);
      editor.nextTick(() => {
        editor.context.selection.select(...newIds);
        if (hasHistory) {
          editor.context.history.add(message, this, {
            currentValues: [data],
            undoValues: [newIds, editor.context.selection.ids]
          });
        }
        editor.context.history.saveSelection();
      });
    }
  },
  redo: function(editor, { currentValues: [data] }) {
    editor.context.commands.emit("history.clipboard.paste", "paste", data, false);
  },
  undo: function(editor, { currentValues: [data], undoValues: [newIds, selectedIds] }) {
    if (data.type === ClipboardActionType.COPY) {
      const parentList = {};
      newIds.forEach((id) => {
        const item = editor.get(id);
        parentList[item.parentId] = item.parent;
        if (item) {
          item.remove();
        }
      });
      let updateData = {};
      Object.values(parentList).forEach((parent) => {
        updateData = __spreadValues(__spreadValues({}, updateData), parent.attrsWithId("children"));
      });
      editor.context.selection.select(...selectedIds);
      editor.context.commands.emit("setAttribute", updateData);
    }
  }
};
var __glob_0_50 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": history_clipboard_paste
}, Symbol.toStringTag, { value: "Module" }));
var history_copyLayer = {
  command: "history.copyLayer",
  description: "copy in selected items ",
  description_ko: ["\uC120\uD0DD\uB41C \uC544\uC774\uD15C\uC744 \uAE30\uC900\uC73C\uB85C \uBCF5\uC81C\uD55C\uB2E4. "],
  execute: async function(editor, message, ids = []) {
    let currentIds = ids.map((id) => editor.get(id)).filter(Boolean).map((item) => item.id);
    if (!currentIds.length) {
      currentIds = editor.context.selection.ids;
    }
    if (!currentIds.length)
      return;
    const items = await editor.json.renderAll(currentIds.map((it) => editor.get(it)));
    const newIds = [];
    const itemList = {};
    const parentList = {};
    let updateData = {};
    items.forEach((itemJSON) => {
      const referenceId = itemJSON.referenceId;
      const sourceItem = editor.get(referenceId);
      parentList[sourceItem.parentId] = sourceItem.parent;
      const model = editor.createModel(itemJSON);
      model.renameWithCount();
      sourceItem.insertAfter(model);
      newIds.push(model.id);
      itemList[model.id] = itemJSON;
      updateData[model.id] = model.toCloneObject();
    });
    Object.values(parentList).forEach((parent) => {
      updateData = __spreadValues(__spreadValues({}, updateData), parent.attrsWithId("children"));
    });
    editor.context.commands.emit("setAttribute", updateData);
    editor.nextTick(() => {
      editor.context.selection.select(...newIds);
      editor.context.history.add(message, this, {
        currentValues: [currentIds],
        undoValues: [newIds, editor.context.selection.ids]
      });
      editor.context.history.saveSelection();
    });
  },
  redo: function(editor, { currentValues: [currentIds] }) {
    editor.context.commands.emit("copyLayer", currentIds);
  },
  undo: function(editor, { undoValues: [newIds, selectedIds] }) {
    const parentList = {};
    newIds.forEach((id) => {
      const item = editor.get(id);
      parentList[item.parentId] = item.parent;
      if (item) {
        item.remove();
      }
    });
    let updateData = {};
    Object.values(parentList).forEach((parent) => {
      updateData = __spreadValues(__spreadValues({}, updateData), parent.attrsWithId("children"));
    });
    editor.context.selection.select(...selectedIds);
    editor.context.commands.emit("setAttribute", updateData);
  }
};
var __glob_0_51 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": history_copyLayer
}, Symbol.toStringTag, { value: "Module" }));
var history_group_item = {
  command: "history.group.item",
  description: "History Group Item",
  execute: function(editor, message = "selection") {
    var _a;
    const currentValues = editor.context.selection.ids;
    const projectId = (_a = editor.context.selection.currentProject) == null ? void 0 : _a.id;
    const undoValues = editor.context.history.selectedIds;
    if (isArrayEquals(currentValues, undoValues)) {
      return;
    }
    editor.context.history.add(message, this, {
      currentValues: {
        ids: currentValues,
        projectId
      },
      undoValues: {
        ids: undoValues,
        projectId
      }
    });
  },
  redo: function(editor, { currentValues: [ids, projectId] }) {
  },
  undo: function(editor, { undoValues: [ids, projectId] }) {
  }
};
var __glob_0_52 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": history_group_item
}, Symbol.toStringTag, { value: "Module" }));
var history_moveLayer = {
  command: "history.moveLayer",
  description: "move layer in world ",
  execute: function(editor, message, layers2 = [], dist2 = [0, 0, 0]) {
    if (isArray(layers2) === false) {
      layers2 = [layers2];
    }
    const targetItems = editor.context.selection.itemsByIds(layers2);
    const lastValues = {};
    const currentValues = {};
    targetItems.forEach((it) => {
      const oldPosition = it.absoluteMove(dist2);
      const newPosition = it.attrs("x", "y");
      lastValues[it.id] = oldPosition;
      currentValues[it.id] = newPosition;
    });
    editor.context.commands.emit("setAttribute", currentValues);
    editor.nextTick(() => {
      editor.context.history.add(message, this, {
        currentValues: [layers2, dist2],
        undoValues: [lastValues]
      });
    });
    editor.nextTick(() => {
      editor.context.history.saveSelection();
    });
  },
  redo: function(editor, { currentValues: [layers2, dist2] }) {
    const targetItems = editor.context.selection.itemsByIds(layers2);
    const localChanges = {};
    targetItems.forEach((it) => {
      it.absoluteMove(dist2);
      const newPosition = it.attrs("x", "y");
      localChanges[it.id] = newPosition;
    });
    editor.context.commands.emit("setAttribute", localChanges);
  },
  undo: function(editor, { undoValues: [lastValues] }) {
    editor.context.commands.emit("setAttribute", lastValues);
  }
};
var __glob_0_53 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": history_moveLayer
}, Symbol.toStringTag, { value: "Module" }));
var history_moveLayerToTarget = {
  command: "history.moveLayerToTarget",
  description: "move layer to target in world ",
  execute: function(editor, message, layer, target, dist2 = [0, 0, 0], targetAction = TargetActionType.APPEND_CHILD) {
    const currentLayer = editor.get(layer) || layer;
    const currentParentLayer = currentLayer.parent;
    const currentTarget = editor.get(target) || editor.context.selection.currentProject;
    const lastValues = currentLayer.hierachy;
    if (dist2) {
      currentLayer.absoluteMove(dist2);
    }
    let currentValues = {};
    if (targetAction === TargetActionType.APPEND_CHILD) {
      currentTarget.appendChild(currentLayer);
      currentValues = currentTarget.attrsWithId("children");
    } else if (targetAction === TargetActionType.INSERT_BEFORE) {
      currentTarget.insertBefore(currentLayer);
      currentValues = currentTarget.parent.attrsWithId("children");
    } else if (targetAction === TargetActionType.INSERT_AFTER) {
      currentTarget.insertAfter(currentLayer);
      currentValues = currentTarget.parent.attrsWithId("children");
    }
    editor.context.commands.emit("setAttribute", __spreadValues(__spreadValues(__spreadValues({}, currentLayer.attrsWithId("x", "y", "angle", "parentId")), currentValues), currentParentLayer && currentParentLayer.isNot("project") ? currentParentLayer.attrsWithId("children") : {}));
    editor.nextTick(() => {
      editor.context.history.add(message, this, {
        currentValues: [currentLayer.hierachy],
        undoValues: [lastValues, currentLayer.parentId]
      });
    });
    editor.nextTick(() => {
      editor.context.history.saveSelection();
    });
  },
  redo: function(editor, { currentValues: [info] }) {
    const currentLayer = editor.get(info.id);
    const currentTarget = editor.get(info.parentId);
    currentTarget.insertChild(currentLayer, info.index);
    currentLayer.reset(info.attrs);
    editor.context.commands.emit("setAttribute", __spreadValues(__spreadValues({}, currentLayer.attrsWithId("x", "y", "angle", "parentId")), currentTarget.attrsWithId("children")));
  },
  undo: function(editor, { undoValues: [lastValues, currentParentId] }) {
    const currentLayer = lastValues;
    const lastLayer = editor.get(currentLayer.id);
    const lastParent = editor.get(currentLayer.parentId);
    const currentParent = editor.get(currentParentId);
    const lastIndex = currentLayer.index;
    lastParent.insertChild(lastLayer, lastIndex);
    lastLayer.reset(lastValues.attrs);
    editor.context.commands.emit("setAttribute", __spreadValues(__spreadValues(__spreadValues({}, lastLayer.attrsWithId("x", "y", "angle")), lastParent.attrsWithId("children")), currentParent.attrsWithId("children")));
  }
};
var __glob_0_54 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": history_moveLayerToTarget
}, Symbol.toStringTag, { value: "Module" }));
var history_refreshSelection = {
  command: "history.refreshSelection",
  description: `save selection in history `,
  description_ko: "Selection \uC815\uBCF4\uB97C \uAC31\uC2E0\uD558\uBA74\uC11C History \uC5D0 \uC800\uC7A5\uD55C\uB2E4",
  execute: function(editor, message = "selection") {
    var _a;
    const currentValues = editor.context.selection.ids;
    const projectId = (_a = editor.context.selection.currentProject) == null ? void 0 : _a.id;
    const undoValues = editor.context.history.selectedIds;
    if (isArrayEquals(currentValues, undoValues)) {
      return;
    }
    editor.context.history.add(message, this, {
      currentValues: [currentValues, projectId],
      undoValues: [undoValues, projectId]
    });
    this.nextAction(editor);
  },
  nextAction(editor) {
    editor.nextTick(() => {
      editor.context.history.saveSelection();
    });
  },
  redo: function(editor, { currentValues: [ids, projectId] }) {
    editor.context.selection.selectProject(projectId);
    editor.context.selection.select(...ids);
    this.nextAction(editor);
  },
  undo: function(editor, { undoValues: [ids, projectId] }) {
    editor.context.selection.selectProject(projectId);
    editor.context.selection.select(...ids);
    this.nextAction(editor);
  }
};
var __glob_0_55 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": history_refreshSelection
}, Symbol.toStringTag, { value: "Module" }));
var history_refreshSelectionProject = {
  command: "history.refreshSelectionPorject",
  description: `save project selection in history `,
  description_ko: "Project Selection \uC815\uBCF4\uB97C \uAC31\uC2E0\uD558\uBA74\uC11C History \uC5D0 \uC800\uC7A5\uD55C\uB2E4",
  execute: function(editor, message = "selection", projectId) {
    var _a;
    const currentValues = [projectId];
    const undoValues = [(_a = editor.context.selection.currentProject) == null ? void 0 : _a.id];
    if (isArrayEquals(currentValues, undoValues)) {
      return;
    }
    editor.context.selection.selectProject(projectId);
    editor.context.history.add(message, this, {
      currentValues,
      undoValues
    });
    this.nextAction(editor);
  },
  nextAction(editor) {
    editor.nextTick(() => {
      editor.emit("refreshAll");
      editor.emit("refreshProjectList");
    });
  },
  redo: function(editor, { currentValues: [projectId] }) {
    editor.context.selection.selectProject(projectId);
    this.nextAction(editor);
  },
  undo: function(editor, { undoValues: [projectId] }) {
    editor.context.selection.selectProject(projectId);
    this.nextAction(editor);
  }
};
var __glob_0_56 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": history_refreshSelectionProject
}, Symbol.toStringTag, { value: "Module" }));
function filterChildren(items = []) {
  return items.filter((item) => {
    let total = 0;
    item.path.forEach((treeItem) => {
      total += items.filter((it) => it.id === treeItem.id).length ? 1 : 0;
    });
    return total === 1;
  });
}
var history_removeLayer = {
  command: "history.removeLayer",
  description: "remove layer",
  execute: function(editor, message, ids = void 0) {
    let items = editor.context.selection.itemsByIds(ids || editor.context.selection.ids);
    items = filterChildren(items);
    const filtedIds = items.map((it) => it.id);
    editor.context.modelManager.markRemove(filtedIds);
    const parentIds = items.map((it) => it.parentId);
    items.forEach((item) => {
      item.remove();
      editor.context.selection.removeById(item.id);
    });
    editor.context.history.add(message, this, {
      currentValues: [filtedIds, parentIds],
      undoValues: filtedIds
    });
    editor.nextTick(() => {
      editor.context.selection.removeById(filtedIds);
      parentIds.forEach((parentId) => {
        editor.context.commands.emit("update", parentId, {
          changedChildren: true
        });
      });
      editor.emit("refreshAll");
      editor.emit("removeGuideLine");
      editor.nextTick(() => {
        editor.context.history.saveSelection();
      });
    });
  },
  redo: function(editor, { currentValues }) {
    const ids = currentValues[0];
    let items = editor.context.selection.itemsByIds(ids || editor.context.selection.ids);
    items = filterChildren(items);
    editor.context.modelManager.markRemove(items.map((it) => it.id));
    items.forEach((item) => item.remove());
    editor.nextTick(() => {
      editor.emit("refreshAll");
    });
  },
  undo: function(editor, { undoValues: recoverIds }) {
    editor.context.modelManager.unmarkRemove(recoverIds);
    editor.nextTick(() => {
      editor.emit("refreshAll");
    });
  }
};
var __glob_0_57 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": history_removeLayer
}, Symbol.toStringTag, { value: "Module" }));
var history_removeProject = {
  command: "history.removeProject",
  description: "remove project",
  execute: function(editor, message, projectId) {
    const index2 = editor.context.modelManager.markRemoveProject(projectId);
    editor.context.history.add(message, this, {
      currentValues: [projectId],
      undoValues: [projectId, index2]
    });
    editor.nextTick(() => {
      editor.context.selection.selectProject(editor.context.modelManager.projects[0]);
      editor.emit("refreshAll");
      editor.emit("removeGuideLine");
      editor.nextTick(() => {
        editor.context.history.saveSelection();
      });
    });
  },
  redo: function(editor, { currentValues: [projectId] }) {
    editor.context.modelManager.markRemoveProject(projectId);
    editor.nextTick(() => {
      editor.emit("refreshAll");
    });
  },
  undo: function(editor, { undoValues: [projectId, index2] }) {
    editor.context.modelManager.unmarkRemoveProject(projectId, index2);
    editor.nextTick(() => {
      editor.context.selection.selectProject(projectId);
      editor.emit("refreshAll");
    });
  }
};
var __glob_0_58 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": history_removeProject
}, Symbol.toStringTag, { value: "Module" }));
var history_send_back = {
  command: "history.send.back",
  description: "send back",
  execute: function(editor, message, layer = editor.context.selection.current) {
    const currentLayer = editor.get(layer);
    const lastValues = currentLayer.hierarchy;
    const oldParentLayer = currentLayer.parent;
    let currentValues = {};
    if (currentLayer.isFirst()) {
      return;
    } else {
      currentLayer.parent.sendBack(currentLayer.id);
      currentValues = currentLayer.hierarchy;
    }
    editor.context.commands.emit("setAttribute", __spreadValues(__spreadValues({}, oldParentLayer.attrsWithId("children")), currentLayer.attrsWithId("x", "y", "angle", "parentId")));
    editor.nextTick(() => {
      editor.context.history.add(message, this, {
        currentValues: [currentValues],
        undoValues: [lastValues]
      });
    });
    editor.nextTick(() => {
      editor.context.history.saveSelection();
    });
  },
  redo: function(editor, { currentValues: [newValues] }) {
    const currentLayer = editor.get(newValues.id);
    const currentTarget = editor.get(newValues.parentId);
    currentTarget.insertChild(currentLayer, newValues.index);
    currentLayer.reset(newValues.attrs);
    editor.context.commands.emit("setAttribute", __spreadValues(__spreadValues({}, currentLayer.attrsWithId("x", "y", "angle", "parentId")), currentTarget.attrsWithId("children")));
  },
  undo: function(editor, { undoValues: [lastValues] }) {
    const currentLayer = lastValues;
    const lastLayer = editor.get(currentLayer.id);
    const lastParent = editor.get(currentLayer.parentId);
    const lastIndex = currentLayer.index;
    lastParent.insertChild(lastLayer, lastIndex);
    editor.context.commands.emit("setAttribute", __spreadValues(__spreadValues({}, lastLayer.attrsWithId("x", "y", "angle", "parentId")), lastParent.attrsWithId("children")));
  }
};
var __glob_0_59 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": history_send_back
}, Symbol.toStringTag, { value: "Module" }));
var history_send_backward = {
  command: "history.send.backward",
  description: "send backward",
  execute: function(editor, message, layer = editor.context.selection.current) {
    const currentLayer = editor.get(layer);
    const lastValues = currentLayer.hierarchy;
    const oldParentLayer = currentLayer.parent;
    let currentValues = {};
    let prevParentLayer = null;
    if (currentLayer.isFirst) {
      prevParentLayer = oldParentLayer.prev;
      if (!prevParentLayer) {
        return;
      }
      prevParentLayer.insertBefore(currentLayer);
      currentValues = currentLayer.hierarchy;
    } else {
      currentLayer.parent.sendBackward(currentLayer.id);
      currentValues = currentLayer.hierarchy;
    }
    editor.context.commands.emit("setAttribute", __spreadValues(__spreadValues(__spreadValues({}, oldParentLayer.attrsWithId("children")), currentLayer.attrsWithId("x", "y", "angle", "parentId")), currentLayer.parent.attrsWithId("children")));
    editor.nextTick(() => {
      editor.context.history.add(message, this, {
        currentValues: [currentValues],
        undoValues: [lastValues]
      });
    });
    editor.nextTick(() => {
      editor.context.history.saveSelection();
    });
  },
  redo: function(editor, { currentValues: [newValues], undoValues: [lastValues] }) {
    const currentLayer = editor.get(newValues.id);
    const currentTarget = editor.get(newValues.parentId);
    const lastParent = editor.get(lastValues.parentId);
    currentTarget.insertChild(currentLayer, newValues.index);
    currentLayer.reset(newValues.attrs);
    editor.context.commands.emit("setAttribute", __spreadValues(__spreadValues(__spreadValues({}, lastParent.attrsWithId("children")), currentLayer.attrsWithId("x", "y", "angle", "parentId")), currentTarget.attrsWithId("children")));
  },
  undo: function(editor, { currentValues: [newValues], undoValues: [lastValues] }) {
    const currentLayer = lastValues;
    const lastLayer = editor.get(currentLayer.id);
    const lastParent = editor.get(currentLayer.parentId);
    const currentParent = editor.get(newValues.parentId);
    const lastIndex = currentLayer.index;
    lastParent.insertChild(lastLayer, lastIndex);
    lastLayer.reset(lastValues.attrs);
    editor.context.commands.emit("setAttribute", __spreadValues(__spreadValues(__spreadValues({}, lastLayer.attrsWithId("x", "y", "angle")), lastParent.attrsWithId("children")), currentParent.attrsWithId("children")));
  }
};
var __glob_0_60 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": history_send_backward
}, Symbol.toStringTag, { value: "Module" }));
var history_setAttribute = {
  command: "history.setAttribute",
  execute: function(editor, message, multiAttrs = {}, context = { origin: "*" }) {
    editor.context.commands.emit("setAttribute", multiAttrs, context);
    editor.context.history.add(message, this, {
      currentValues: [multiAttrs],
      undoValues: editor.context.history.getUndoValues(multiAttrs)
    });
    editor.nextTick(() => {
      editor.context.history.saveSelection();
    });
  },
  redo: function(editor, { currentValues }) {
    editor.context.commands.emit("setAttribute", ...currentValues);
    editor.nextTick(() => {
      editor.context.selection.reselect();
      editor.emit("refreshAll");
    });
  },
  undo: function(editor, { undoValues }) {
    const ids = Object.keys(undoValues);
    const items = editor.context.selection.itemsByIds(ids);
    items.forEach((item) => {
      item.reset(undoValues[item.id]);
    });
    editor.context.selection.reselect();
    editor.nextTick(() => {
      editor.emit("refreshAll");
    });
  }
};
var __glob_0_61 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": history_setAttribute
}, Symbol.toStringTag, { value: "Module" }));
var item_move_depth_down = {
  command: "item.move.depth.down",
  execute: function(editor) {
    const current = editor.context.selection.current;
    if (current) {
      current.orderPrev();
    }
    _doForceRefreshSelection(editor);
  }
};
var __glob_0_62 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": item_move_depth_down
}, Symbol.toStringTag, { value: "Module" }));
var item_move_depth_first = {
  command: "item.move.depth.first",
  execute: function(editor) {
    const current = editor.context.selection.current;
    if (current) {
      current.orderFirst();
    }
    _doForceRefreshSelection(editor);
  }
};
var __glob_0_63 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": item_move_depth_first
}, Symbol.toStringTag, { value: "Module" }));
var item_move_depth_last = {
  command: "item.move.depth.last",
  execute: function(editor) {
    const current = editor.context.selection.current;
    if (current) {
      current.orderLast();
    }
    _doForceRefreshSelection(editor);
  }
};
var __glob_0_64 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": item_move_depth_last
}, Symbol.toStringTag, { value: "Module" }));
var item_move_depth_up = {
  command: "item.move.depth.up",
  execute: function(editor) {
    const current = editor.context.selection.current;
    if (current) {
      current.orderNext();
    }
    _doForceRefreshSelection(editor);
  }
};
var __glob_0_65 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": item_move_depth_up
}, Symbol.toStringTag, { value: "Module" }));
var keymap_keydown = {
  command: "keymap.keydown",
  execute: function(editor, e) {
    editor.context.keyboardManager.add(e.code, e.keyCode, e);
    if (editor.context.shortcuts) {
      editor.context.shortcuts.execute(e, "keydown");
    }
  }
};
var __glob_0_66 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": keymap_keydown
}, Symbol.toStringTag, { value: "Module" }));
var lastTimelineItem = {
  command: "lastTimelineItem",
  execute: function(editor) {
    _currentProject(editor, (project2, timeline) => {
      var lastTime = project2.getSelectedTimelineLastTime();
      project2.setTimelineCurrentTime(timecode(timeline.fps, lastTime));
      project2.seek();
      editor.emit("playTimeline");
    });
  }
};
var __glob_0_67 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": lastTimelineItem
}, Symbol.toStringTag, { value: "Module" }));
var load_json = {
  command: "load.json",
  execute: function(editor, json, context = { origin: "*" }) {
    editor.context.modelManager.load(json, context);
    _doForceRefreshSelection(editor);
  }
};
var __glob_0_68 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": load_json
}, Symbol.toStringTag, { value: "Module" }));
var moveLayer = {
  command: "moveLayer",
  description: "move layer by keydown with matrix ",
  execute: function(editor, dx = 0, dy = 0) {
    const absoluteDist = [dx, dy, 0];
    editor.context.selection.items.forEach((it) => {
      it.absoluteMove(absoluteDist);
    });
    editor.context.commands.executeCommand("setAttribute", "item move down", editor.context.selection.pack("x", "y"));
    editor.nextTick(() => {
      editor.context.selection.reselect();
    });
  }
};
var __glob_0_69 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": moveLayer
}, Symbol.toStringTag, { value: "Module" }));
var moveLayerForItems = {
  command: "moveLayerForItems",
  description: "mova layer by multi items ",
  execute: function(editor, moveItems = []) {
    const itemsMap = {};
    moveItems.forEach((it) => {
      it.item.absoluteMove(it.dist);
      itemsMap[it.item.id] = it.item.attrs("x", "y");
    });
    editor.context.commands.emit("history.setAttribute", "item move", itemsMap);
    editor.nextTick(() => {
      editor.context.selection.reselect();
    });
  }
};
var __glob_0_70 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": moveLayerForItems
}, Symbol.toStringTag, { value: "Module" }));
var moveSelectionToCenter = {
  command: "moveSelectionToCenter",
  description: "Move selection project or artboards to center on Viewport",
  execute: function(editor, withScale = true) {
    var _a, _b, _c, _d, _e;
    let areaVerties = [];
    if ((_a = editor.context.selection) == null ? void 0 : _a.isEmpty) {
      if (((_c = (_b = editor.context.selection) == null ? void 0 : _b.currentProject) == null ? void 0 : _c.layers.length) > 0) {
        areaVerties = itemsToRectVerties((_d = editor.context.selection) == null ? void 0 : _d.currentProject.layers);
      } else {
        areaVerties = rectToVerties(0, 0, 100, 100);
      }
    } else {
      areaVerties = itemsToRectVerties((_e = editor.context.selection) == null ? void 0 : _e.items);
    }
    editor.context.commands.emit("moveToCenter", areaVerties, withScale);
  }
};
var __glob_0_71 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": moveSelectionToCenter
}, Symbol.toStringTag, { value: "Module" }));
function newComponent(editor, itemType, obj2, isSelected = true, containerItem = void 0) {
  if (itemType === "svg-textpath") {
    obj2 = __spreadProps(__spreadValues({}, obj2), {
      fontSize: obj2.height,
      textLength: "100%",
      d: PathParser.makeLine(0, obj2.height, obj2.width, obj2.height).d
    });
  } else if (itemType === "svg-circle") {
    itemType = "svg-path";
    obj2 = __spreadProps(__spreadValues({}, obj2), {
      backgroundColor: void 0,
      fill: `#C4C4C4`,
      d: PathParser.makeCircle(0, 0, obj2.width, obj2.height).d
    });
  } else if (itemType === "svg-rect") {
    itemType = "svg-path";
    obj2 = __spreadProps(__spreadValues({}, obj2), {
      backgroundColor: void 0,
      fill: `#C4C4C4`,
      d: PathParser.makeRect(0, 0, obj2.width, obj2.height).d
    });
  } else if (itemType === "text") {
    obj2 = __spreadValues({
      width: 300,
      height: 50
    }, obj2);
  } else if (itemType === "artboard") {
    obj2 = __spreadProps(__spreadValues({}, obj2), {
      backgroundColor: "white"
    });
  }
  const newObjAttrs = __spreadValues({ itemType }, obj2);
  const item = editor.createModel(newObjAttrs);
  editor.context.commands.executeCommand("moveLayerToTarget", `add layer - ${itemType}`, item, containerItem);
  editor.nextTick(() => {
    editor.emit("appendLayer", item);
    if (isSelected) {
      editor.context.selection.select(item);
    }
  });
}
var __glob_0_72 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": newComponent
}, Symbol.toStringTag, { value: "Module" }));
var nextTimelineItem = {
  command: "nextTimelineItem",
  execute: function(editor) {
    _currentProject(editor, (project2, timeline) => {
      var nextTime = project2.getSelectedTimelineNextTime();
      project2.setTimelineCurrentTime(timecode(timeline.fps, nextTime));
      project2.seek();
      editor.emit("playTimeline");
    });
  }
};
var __glob_0_73 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": nextTimelineItem
}, Symbol.toStringTag, { value: "Module" }));
var open_editor = {
  command: "open.editor",
  description: "Open custom editor for item  when doubleclick is fired",
  execute: function(editor, current) {
    if (!current && editor.context.selection.isOne === false)
      return;
    current = current || editor.context.selection.current;
    if (current) {
      if (current.editablePath) {
        editor.emit("showPathEditor", "modify", {
          box: "canvas",
          current,
          matrix: current.matrix,
          isControl: true,
          disableCurve: true,
          d: current.editablePath,
          changeEvent: (data) => {
            editor.context.commands.executeCommand("setAttribute", "change editable path", editor.context.selection.packByValue(__spreadValues({}, current.recoverEditablePath(data.d)), [current.id]));
            editor.nextTick(() => {
              if (editor.context.stateManager.isPointerUp) {
                editor.context.commands.emit("recoverBooleanPath");
              }
            });
          }
        });
        editor.emit("hideSelectionToolView");
      } else if (current.d) {
        editor.emit("showPathEditor", "modify", {
          box: "canvas",
          current,
          matrix: current.matrix,
          d: current.absolutePath().d,
          changeEvent: (data) => {
            const newCurrent = editor.context.selection.current;
            if (newCurrent.isSVG() && newCurrent.isNot("svg-path")) {
              const newPathData = newCurrent.toSVGPath();
              const newPath = editor.createModel(__spreadValues({
                itemType: "svg-path"
              }, newPathData));
              editor.context.selection.select(newPath);
              newCurrent.insertAfter(newPath);
              editor.nextTick(() => {
                editor.context.commands.emit("removeLayer", [newCurrent.id]);
                editor.context.commands.emit("updatePathItem", data);
              });
            } else {
              editor.context.commands.emit("updatePathItem", data);
              editor.nextTick(() => {
                if (editor.context.stateManager.isPointerUp) {
                  editor.context.commands.emit("recoverBooleanPath");
                }
              });
            }
          }
        });
        editor.emit("hideSelectionToolView");
      } else if (current.clipPath) {
        var obj2 = ClipPath.parseStyle(current.clipPath);
        if (obj2.type === "path") {
          var d = current.absolutePath(current.clipPathString).d;
          var mode = d ? "modify" : "path";
          editor.emit("showPathEditor", mode, {
            changeEvent: (data) => {
              const resultPath = current.invertPath(data.d).d;
              editor.context.commands.executeCommand("setAttribute", "change clip-path", editor.context.selection.packByValue({
                clipPath: `path(${resultPath})`
              }));
            },
            current,
            d
          });
          editor.emit("hideSelectionToolView");
        } else if (obj2.type === "svg")
          ;
        else {
          editor.emit("showClippathEditorView");
        }
      } else
        ;
    }
  }
};
var __glob_0_74 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": open_editor
}, Symbol.toStringTag, { value: "Module" }));
var pauseTimelineItem = {
  command: "pauseTimelineItem",
  execute: function(editor) {
    if (editor.timer) {
      editor.timer.stop();
    }
  }
};
var __glob_0_75 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": pauseTimelineItem
}, Symbol.toStringTag, { value: "Module" }));
var playTimelineItem = {
  command: "playTimelineItem",
  description: "Play button action",
  execute: function(editor, speed2 = 1, iterationCount = 1, direction2 = "normal") {
    editor.context.selection.empty();
    _currentProject(editor, (project2, timeline) => {
      var lastTime = project2.getSelectedTimelineLastTime();
      if (editor.timer) {
        editor.timer.stop();
      } else {
        editor.timer = makeTimer({
          elapsed: timeline.currentTime * 1e3,
          speed: speed2,
          duration: lastTime * 1e3,
          iterationCount,
          direction: direction2
        });
      }
      editor.timer.play({
        duration: lastTime * 1e3,
        elapsed: timeline.currentTime * 1e3,
        speed: speed2,
        iterationCount,
        direction: direction2,
        tick: (elapsed) => {
          project2.seek(timecode(timeline.fps, elapsed / 1e3));
          editor.emit("playTimeline");
        },
        last: (elapsed) => {
          project2.seek(timecode(timeline.fps, elapsed / 1e3));
          editor.emit("playTimeline");
          editor.nextTick(() => {
            editor.emit("stopTimeline");
          });
        },
        stop: (elapsed) => {
          project2.stop(timecode(timeline.fps, elapsed / 1e3));
          editor.emit("stopTimeline");
        }
      });
    });
  }
};
var __glob_0_76 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": playTimelineItem
}, Symbol.toStringTag, { value: "Module" }));
var prevTimelineItem = {
  command: "prevTimelineItem",
  execute: function(editor) {
    _currentProject(editor, (project2, timeline) => {
      var prevTime = project2.getSelectedTimelinePrevTime();
      project2.setTimelineCurrentTime(timecode(timeline.fps, prevTime));
      project2.seek();
      editor.emit("playTimeline");
    });
  }
};
var __glob_0_77 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": prevTimelineItem
}, Symbol.toStringTag, { value: "Module" }));
var recoverBooleanPath = {
  command: "recoverBooleanPath",
  description: "recover box rectangle for boolean path result",
  execute: function(editor) {
    const current = editor.context.selection.current;
    let booleanContainer;
    if (current && current.isBooleanItem) {
      booleanContainer = current.parent;
    } else if (current && current.is("boolean-path")) {
      booleanContainer = current;
    }
    if (booleanContainer) {
      const isBooleanItem = typeof current.isBooleanItem === "boolean" && current.isBooleanItem;
      const booleanPath = booleanContainer.d;
      if (!booleanPath) {
        return;
      }
      const layersCache = booleanContainer.layers.map((it) => {
        return {
          item: it,
          matrix: it.matrix
        };
      });
      const newBooleanContainerRect = booleanContainer.updatePath(booleanPath);
      delete newBooleanContainerRect.d;
      booleanContainer.reset(newBooleanContainerRect);
      layersCache.forEach((it) => {
        booleanContainer.resetMatrix(it.item);
      });
      const ids = [...layersCache.map((it) => it.item.id), booleanContainer.id];
      const data = editor.context.selection.packByIds(ids, "x", "y", "width", "height");
      editor.context.commands.executeCommand("setAttribute", "fit boolean path", data, {
        origin: "*",
        doNotChildrenScale: isBooleanItem
      });
    }
  }
};
var __glob_0_78 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": recoverBooleanPath
}, Symbol.toStringTag, { value: "Module" }));
var refreshArtboard = {
  command: "refreshArtboard",
  execute: function(editor) {
    const command = editor.createCommandMaker();
    command.emit("refreshLayerTreeView");
    command.emit("refreshAllCanvas");
    command.emit(UPDATE_CANVAS);
    command.emit("refreshAllElementBoundSize");
    command.emit(REFRESH_SELECTION);
    command.run();
  }
};
var __glob_0_79 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": refreshArtboard
}, Symbol.toStringTag, { value: "Module" }));
function makeEmitList(maker, current) {
  var _a;
  if (current.hasLayout()) {
    maker.emit("refreshElementBoundSize", current);
  } else {
    if (current && (current.isLayoutItem() || ((_a = current.parent) == null ? void 0 : _a.is("boolean-path")))) {
      maker.emit("refreshElementBoundSize", current.parent);
    } else {
      maker.emit("refreshElementBoundSize", current);
    }
  }
}
var refreshElement = {
  command: "refreshElement",
  execute: function(editor, current, checkRefreshCanvas = true) {
    const maker = editor.createCommandMaker();
    if (isArray(current)) {
      if (checkRefreshCanvas) {
        maker.emit("refreshAllCanvas");
      }
      maker.emit(UPDATE_CANVAS, current);
      current.forEach((item) => {
        makeEmitList(maker, item);
      });
    } else {
      if (checkRefreshCanvas) {
        if (current && current.hasChangedField("children", "changedChildren", "parentId")) {
          maker.emit("refreshAllCanvas");
        }
      }
      maker.emit(UPDATE_CANVAS, current);
      makeEmitList(maker, current);
    }
    maker.run();
  }
};
var __glob_0_80 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": refreshElement
}, Symbol.toStringTag, { value: "Module" }));
function refreshHistory(editor) {
  editor.context.commands.emit("saveJSON");
}
var __glob_0_81 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": refreshHistory
}, Symbol.toStringTag, { value: "Module" }));
var refreshSelectedOffset = {
  command: "refreshSelectedOffset",
  execute: function(editor) {
    var offset = editor.timeline.items[0];
    if (offset) {
      editor.emit("refreshOffsetValue", offset);
    }
  }
};
var __glob_0_82 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": refreshSelectedOffset
}, Symbol.toStringTag, { value: "Module" }));
var removeAnimationItem = {
  command: "removeAnimationItem",
  execute: function(editor, id) {
    const project2 = editor.context.selection.currentProject;
    if (project2) {
      project2.removeAnimationItem(id);
      editor.timeline.empty();
      editor.emit("refreshTimeline");
      editor.emit("removeAnimation");
    }
  }
};
var __glob_0_83 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": removeAnimationItem
}, Symbol.toStringTag, { value: "Module" }));
var removeLayer = {
  command: "removeLayer",
  execute: function(editor, ids = void 0) {
    const currentIds = ids || editor.context.selection.ids;
    const removedIds = [];
    editor.context.selection.itemsByIds(currentIds).forEach((item) => {
      removedIds.push(item.id);
      item.remove();
    });
    editor.context.selection.removeById(removedIds);
    editor.nextTick(() => {
      editor.emit("refreshAll");
    });
  }
};
var __glob_0_84 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": removeLayer
}, Symbol.toStringTag, { value: "Module" }));
var removeTimeline = {
  command: "removeTimeline",
  execute: function(editor, layerId) {
    const project2 = editor.context.selection.currentProject;
    if (project2) {
      project2.removeTimeline(layerId);
      editor.timeline.empty();
      editor.emit("refreshTimeline");
      editor.emit("refreshSelectedOffset");
    }
  }
};
var __glob_0_85 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": removeTimeline
}, Symbol.toStringTag, { value: "Module" }));
var removeTimelineProperty = {
  command: "removeTimelineProperty",
  execute: function(editor, layerId, property) {
    const project2 = editor.context.selection.currentProject;
    if (project2) {
      project2.removeTimelineProperty(layerId, property);
      editor.timeline.empty();
      editor.emit("refreshTimeline");
      editor.emit("refreshSelectedOffset");
    }
  }
};
var __glob_0_86 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": removeTimelineProperty
}, Symbol.toStringTag, { value: "Module" }));
function resizeArtBoard(editor, size2 = "") {
  var current = editor.context.selection.current;
  if (current && current.is("artboard")) {
    if (!size2.trim())
      return;
    var [width2, height2] = size2.split("x");
    width2 = +width2;
    height2 = +height2;
    current.resize(width2, height2);
    editor.context.selection.select(current);
    _doForceRefreshSelection(editor);
  }
}
var __glob_0_87 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": resizeArtBoard
}, Symbol.toStringTag, { value: "Module" }));
var rotateLayer = {
  command: "rotateLayer",
  description: "rotate layer by keydown with matrix ",
  execute: function(editor, distAngle = 0) {
    editor.context.commands.executeCommand("setAttribute", "change rotate", editor.context.selection.packByValue({
      angle: editor.context.selection.current.angle + distAngle
    }));
  }
};
var __glob_0_88 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": rotateLayer
}, Symbol.toStringTag, { value: "Module" }));
var same_height = {
  command: "same.height",
  description: "fit at the same height",
  execute: function(editor) {
    var len2 = editor.context.selection.length;
    if (len2 == 1)
      ;
    else if (len2 > 1) {
      const rect2 = vertiesToRectangle(editor.context.selection.verties);
      editor.context.commands.executeCommand("setAttribute", "fit at the same height", editor.context.selection.packByValue({
        y: rect2.y,
        height: rect2.height
      }));
    }
  }
};
var __glob_0_89 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": same_height
}, Symbol.toStringTag, { value: "Module" }));
var same_width = {
  command: "same.width",
  description: "fit at the same width",
  execute: function(editor) {
    if (editor.context.selection.isMany) {
      const rect2 = vertiesToRectangle(editor.context.selection.verties);
      editor.context.commands.executeCommand("setAttribute", "fit at the same width", editor.context.selection.packByValue({
        x: rect2.x,
        width: rect2.width
      }));
    }
  }
};
var __glob_0_90 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": same_width
}, Symbol.toStringTag, { value: "Module" }));
var saveJSON = {
  command: "saveJSON",
  execute: function(editor) {
    editor.saveItem("model", editor.context.modelManager.toJSON());
  }
};
var __glob_0_91 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": saveJSON
}, Symbol.toStringTag, { value: "Module" }));
var savePNG = {
  command: "savePNG",
  execute: function(editor, callbackCommand = "") {
    const item = editor.context.selection.current;
    if (item) {
      const svgString = ExportManager.generateSVG(editor, item).trim();
      const datauri = "data:image/svg+xml;base64," + window.btoa(svgString);
      loadOriginalImage({ local: datauri }, (info, img) => {
        createImagePng(img, (pngDataUri) => {
          if (callbackCommand) {
            editor.emit(callbackCommand, pngDataUri);
          }
        });
      });
    }
  }
};
var __glob_0_92 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": savePNG
}, Symbol.toStringTag, { value: "Module" }));
var segment_delete = {
  command: "segment.delete",
  execute: function(editor) {
    editor.emit("deleteSegment");
  }
};
var __glob_0_93 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": segment_delete
}, Symbol.toStringTag, { value: "Module" }));
var segment_move_down = {
  command: "segment.move.down",
  execute: function(editor, obj2 = { dy: 1 }) {
    const dy = +obj2.dy;
    editor.emit("moveSegment", 0, dy);
  }
};
var __glob_0_94 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": segment_move_down
}, Symbol.toStringTag, { value: "Module" }));
var segment_move_left = {
  command: "segment.move.left",
  execute: function(editor, obj2 = { dx: 1 }) {
    const dx = +obj2.dx;
    editor.emit("moveSegment", -1 * dx, 0);
  }
};
var __glob_0_95 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": segment_move_left
}, Symbol.toStringTag, { value: "Module" }));
var segment_move_right = {
  command: "segment.move.right",
  execute: function(editor, obj2 = { dx: 1 }) {
    const dx = +obj2.dx;
    editor.emit("moveSegment", dx, 0);
  }
};
var __glob_0_96 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": segment_move_right
}, Symbol.toStringTag, { value: "Module" }));
var segment_move_up = {
  command: "segment.move.up",
  execute: function(editor, obj2 = { dy: 1 }) {
    const dy = +obj2.dy;
    editor.emit("moveSegment", 0, -1 * dy);
  }
};
var __glob_0_97 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": segment_move_up
}, Symbol.toStringTag, { value: "Module" }));
var select_all = {
  command: "select.all",
  execute: function(editor) {
    var project2 = editor.context.selection.currentProject;
    if (project2) {
      editor.context.selection.select(...project2.layers);
      editor.context.commands.emit("history.refreshSelection");
    }
  }
};
var __glob_0_98 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": select_all
}, Symbol.toStringTag, { value: "Module" }));
var select_none = {
  command: "select.none",
  execute: function(editor) {
    editor.context.selection.empty();
    editor.context.commands.emit("history.refreshSelection");
  }
};
var __glob_0_99 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": select_none
}, Symbol.toStringTag, { value: "Module" }));
var selectTimelineItem = {
  command: "selectTimelineItem",
  execute: function(editor, selectedId) {
    const project2 = editor.context.selection.currentProject;
    if (project2) {
      project2.selectTimeline(selectedId);
      editor.emit("refreshTimeline");
      editor.emit("selectTimeline");
    }
  }
};
var __glob_0_100 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": selectTimelineItem
}, Symbol.toStringTag, { value: "Module" }));
var setAttribute = {
  command: "setAttribute",
  execute: function(editor, multiAttrs = {}, context = { origin: "*" }) {
    const messages = [];
    Object.entries(multiAttrs).forEach(([id, attrs]) => {
      const item = editor.get(id);
      const newAttrs = {};
      Object.entries(attrs).forEach(([key, value]) => {
        newAttrs[key] = isFunction(value) ? value(item) : value;
      });
      messages.push({ id: item.id, parentId: item.parentId, attrs: newAttrs });
    });
    if (messages.length == 0) {
      return;
    }
    let hasRefreshCanvas = false;
    const children2 = [];
    messages.forEach((message) => {
      const item = editor.get(message.id);
      if (item) {
        item.reset(message.attrs, context);
        if (item.hasChangedField("layout")) {
          item.layers.forEach((child) => {
            if (child.isLayout(Layout.DEFAULT))
              ;
            else if (child.isLayout(Layout.FLEX))
              ;
            else if (child.isLayout(Layout.GRID))
              ;
            editor.context.commands.emit("refreshElement", child);
          });
        }
        children2.push(item);
        if (item.hasChangedHirachy) {
          hasRefreshCanvas = true;
        }
      }
      if (item.is("project")) {
        return;
      }
      if (item.parent && item.parent.is("project")) {
        return;
      }
      if (item.isLayoutItem() || item.isBooleanItem) {
        const parent = editor.get(message.parentId);
        if (message.parentId && (parent == null ? void 0 : parent.isNot("project"))) {
          parent.reset({ changedChildren: true }, context);
          hasRefreshCanvas = true;
        }
      }
    });
    if (children2.length) {
      editor.context.commands.emit("refreshElement", children2, false);
    }
    if (hasRefreshCanvas) {
      editor.emit("refreshAllCanvas");
    }
  }
};
var __glob_0_101 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": setAttribute
}, Symbol.toStringTag, { value: "Module" }));
var setTimelineOffset = {
  command: "setTimelineOffset",
  debounce: 100,
  execute: function(editor, obj2) {
    const project2 = editor.context.selection.currentProject;
    if (project2) {
      project2.setTimelineKeyframeOffsetValue(obj2.layerId, obj2.property, obj2.id, obj2.value, obj2.timing, obj2.time);
      editor.emit("refreshTimeline");
    }
  }
};
var __glob_0_102 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": setTimelineOffset
}, Symbol.toStringTag, { value: "Module" }));
var showExportView = {
  command: "showExportView",
  execute: function(editor) {
    editor.emit("showExportWindow");
  }
};
var __glob_0_103 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": showExportView
}, Symbol.toStringTag, { value: "Module" }));
var sort_bottom = {
  command: "sort.bottom",
  execute: function(editor) {
    if (editor.context.selection.isOne) {
      const current = editor.context.selection.current;
      if (current.parent.is("project"))
        ;
      else {
        const parent = current.parent;
        const distY = getVertiesMaxY(parent.verties) - getVertiesMaxY(editor.context.selection.verties);
        editor.context.commands.emit("moveLayer", 0, distY);
      }
    } else if (editor.context.selection.isMany) {
      let maxRightY = getVertiesMaxY(editor.context.selection.verties);
      editor.context.commands.emit("moveLayerForItems", editor.context.selection.map((item) => {
        let itemRightY = getVertiesMaxY(item.verties);
        return { item, dist: [0, maxRightY - itemRightY, 0, 0] };
      }));
    }
  }
};
var __glob_0_104 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": sort_bottom
}, Symbol.toStringTag, { value: "Module" }));
var sort_center = {
  command: "sort.center",
  execute: function(editor) {
    if (editor.context.selection.isOne) {
      const current = editor.context.selection.current;
      if (current.parent.is("project"))
        ;
      else if (current.artboard) {
        const distX = getVertiesCenterX(current.artboard.verties) - getVertiesCenterX(editor.context.selection.verties);
        editor.context.commands.emit("moveLayer", distX, 0);
      }
    } else if (editor.context.selection.isMany) {
      let maxRightX = getVertiesCenterX(editor.context.selection.verties);
      editor.context.commands.emit("moveLayerForItems", editor.context.selection.map((item) => {
        let itemRightX = getVertiesCenterX(item.verties);
        return { item, dist: [maxRightX - itemRightX, 0, 0] };
      }));
    }
  }
};
var __glob_0_105 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": sort_center
}, Symbol.toStringTag, { value: "Module" }));
var sort_left = {
  command: "sort.left",
  execute: function(editor) {
    if (editor.context.selection.isOne) {
      const current = editor.context.selection.current;
      if (current.parent.is("project"))
        ;
      else {
        const parent = current.parent;
        const distX = getVertiesMinX(parent.verties) - getVertiesMinX(editor.context.selection.verties);
        editor.context.commands.emit("moveLayer", distX, 0);
      }
    } else if (editor.context.selection.isMany) {
      let maxRightX = getVertiesMinX(editor.context.selection.verties);
      editor.context.commands.emit("moveLayerForItems", editor.context.selection.map((item) => {
        let itemRightX = getVertiesMinX(item.verties);
        return { item, dist: [maxRightX - itemRightX, 0, 0] };
      }));
    }
  }
};
var __glob_0_106 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": sort_left
}, Symbol.toStringTag, { value: "Module" }));
var sort_middle = {
  command: "sort.middle",
  execute: function(editor) {
    if (editor.context.selection.isOne) {
      const current = editor.context.selection.current;
      if (current.parent.is("project"))
        ;
      else if (current.artboard) {
        const distY = getVertiesCenterY(current.artboard.verties) - getVertiesCenterY(editor.context.selection.verties);
        editor.context.commands.emit("moveLayer", 0, distY);
      }
    } else if (editor.context.selection.isMany) {
      let maxRightY = getVertiesCenterY(editor.context.selection.verties);
      editor.context.commands.emit("moveLayerForItems", editor.context.selection.map((item) => {
        let itemRightY = getVertiesCenterY(item.verties);
        return { item, dist: [0, maxRightY - itemRightY, 0, 0] };
      }));
    }
  }
};
var __glob_0_107 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": sort_middle
}, Symbol.toStringTag, { value: "Module" }));
var sort_right = {
  command: "sort.right",
  execute: function(editor) {
    if (editor.context.selection.isOne) {
      const current = editor.context.selection.current;
      if (current.parent.is("project"))
        ;
      else {
        const parent = current.parent;
        const distX = getVertiesMaxX(parent.verties) - getVertiesMaxX(editor.context.selection.verties);
        editor.context.commands.emit("moveLayer", distX, 0);
      }
    } else if (editor.context.selection.isMany) {
      let maxRightX = getVertiesMaxX(editor.context.selection.verties);
      editor.context.commands.emit("moveLayerForItems", editor.context.selection.map((item) => {
        let itemRightX = getVertiesMaxX(item.verties);
        return { item, dist: [maxRightX - itemRightX, 0, 0] };
      }));
    }
  }
};
var __glob_0_108 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": sort_right
}, Symbol.toStringTag, { value: "Module" }));
var sort_top = {
  command: "sort.top",
  execute: function(editor) {
    if (editor.context.selection.isOne) {
      const current = editor.context.selection.current;
      if (current.parent.is("project"))
        ;
      else {
        const parent = current.parent;
        const distY = getVertiesMinY(parent.verties) - getVertiesMinY(editor.context.selection.verties);
        editor.context.commands.emit("moveLayer", 0, distY);
      }
    } else if (editor.context.selection.isMany) {
      let maxRightY = getVertiesMinY(editor.context.selection.verties);
      editor.context.commands.emit("moveLayerForItems", editor.context.selection.map((item) => {
        let itemRightY = getVertiesMinY(item.verties);
        return { item, dist: [0, maxRightY - itemRightY, 0, 0] };
      }));
    }
  }
};
var __glob_0_109 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": sort_top
}, Symbol.toStringTag, { value: "Module" }));
var switch_path = {
  command: "switch.path",
  execute: async (editor) => {
    const current = editor.context.selection.current;
    if (!current)
      return;
    if (current.is("boolean-path") || current.isBooleanItem) {
      let parent = current;
      if (current.isBooleanItem) {
        parent = current.parent;
      }
      editor.context.selection.select(parent);
      editor.context.commands.executeCommand("setAttribute", "change boolean operation", editor.context.selection.packByValue({
        booleanOperation: parent["boolean-operation"],
        children: parent.children.reverse()
      }));
      editor.nextTick(() => {
        editor.context.commands.emit("recoverBooleanPath");
        editor.context.selection.select(current);
      });
    }
  }
};
var __glob_0_110 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": switch_path
}, Symbol.toStringTag, { value: "Module" }));
var ungroup_item = {
  command: "ungroup.item",
  execute: function(editor) {
    if (editor.context.selection.length === 0)
      return;
    const current = editor.context.selection.current;
    if (current) {
      let groupLayer = current;
      let layers2 = [...groupLayer.layers];
      layers2.reverse();
      layers2.forEach((child) => {
        groupLayer.insertBefore(child);
      });
      editor.context.selection.select(...layers2);
      editor.emit("refreshAll");
    }
  }
};
var __glob_0_111 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": ungroup_item
}, Symbol.toStringTag, { value: "Module" }));
var updateClipPath = {
  command: "updateClipPath",
  description: "update clip-path property ",
  execute: function(editor, pathObject) {
    editor.context.commands.executeCommand("setAttribute", "change clip-path", editor.context.selection.packByValue({
      clipPath: `path(${pathObject.d})`
    }));
  }
};
var __glob_0_112 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": updateClipPath
}, Symbol.toStringTag, { value: "Module" }));
var updateImage = {
  command: "updateImage",
  execute: function(editor, imageFileOrBlob, rect2, containerItem) {
    var reader = new window.FileReader();
    reader.onload = (e) => {
      var datauri = e.target.result;
      var local = window.URL.createObjectURL(imageFileOrBlob);
      editor.context.commands.emit("addImageAssetItem", {
        id: uuidShort(),
        type: imageFileOrBlob.type,
        name: imageFileOrBlob.name,
        original: datauri,
        local
      }, rect2, containerItem);
    };
    reader.readAsDataURL(imageFileOrBlob);
  }
};
var __glob_0_113 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": updateImage
}, Symbol.toStringTag, { value: "Module" }));
var updateImageAssetItem = {
  command: "updateImageAssetItem",
  execute: function(editor, item, callback) {
    var reader = new window.FileReader();
    reader.onload = (e) => {
      var datauri = e.target.result;
      var local = window.URL.createObjectURL(item);
      var project2 = editor.context.selection.currentProject;
      if (project2) {
        const image2 = project2.createImage({
          id: uuidShort(),
          type: item.type,
          name: item.name,
          original: datauri,
          local
        });
        editor.context.commands.emit("addImageAsset");
        isFunction(callback) && callback(image2.id);
      }
    };
    reader.readAsDataURL(item);
  }
};
var __glob_0_114 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": updateImageAssetItem
}, Symbol.toStringTag, { value: "Module" }));
const MAX_CACHE_COUNT = 1e3;
const cachedTransformMap = /* @__PURE__ */ new Map();
class TransformCache {
  static has(key) {
    return cachedTransformMap.has(key);
  }
  static get(key) {
    return cachedTransformMap.get(key);
  }
  static set(key, parsedValue) {
    if (cachedTransformMap.size > MAX_CACHE_COUNT) {
      cachedTransformMap.clear();
    }
    cachedTransformMap.set(key, parsedValue);
  }
}
const TRANSFORM_REG = /((matrix|translate(X|Y|Z|3d)?|scale(X|Y|Z|3d)?|rotate(X|Y|Z|3d)?|skew(X|Y)?|matrix(3d)?|perspective)\(([^)]*)\))/gi;
class Transform extends PropertyItem {
  getDefaultObject() {
    return {
      itemType: "transform",
      value: []
    };
  }
  toCloneObject() {
    return __spreadValues({}, this.attrs("itemType", "type", "value"));
  }
  toString() {
    return `${this.json.type}(${this.json.value.join(", ") || ""})`;
  }
  static join(list2) {
    var firstType = "perspective";
    var lastType = "matrix3d";
    var arr = list2.filter((it) => it.type === firstType);
    var last = list2.filter((it) => it.type === lastType);
    var arr2 = list2.filter((it) => it.type !== firstType && it.type !== lastType);
    return [...arr, ...arr2, ...last].map((it) => new Transform(it).toString()).join(" ");
  }
  hasNumberValue() {
    var type = this.json.type;
    return type.includes("matrix") || type.includes("scale");
  }
  static parse(transform2) {
    return new Transform(transform2);
  }
  static remove(transform2, type = []) {
    if (typeof type === "string") {
      type = [type];
    }
    return Transform.filter(transform2, (it) => {
      return type.includes(it.type) === false;
    });
  }
  static filter(transform2, filterFunction) {
    return Transform.join(Transform.parseStyle(transform2, false).filter((it) => filterFunction(it)));
  }
  static replace(transform2, valueObject) {
    var obj2 = Transform.parseStyle(transform2, false);
    var tObject = obj2.find((t) => t.type === valueObject.type);
    if (tObject) {
      tObject.value = valueObject.value;
    } else {
      obj2.push(valueObject);
    }
    return Transform.join(obj2);
  }
  static replaceAll(oldTransform, newTransform) {
    var oldT = Transform.parseStyle(oldTransform, false);
    var newT = Transform.parseStyle(newTransform);
    for (var i = 0, len2 = newT.length; i < len2; i++) {
      var newObject = newT[i];
      var oldObject = oldT.find((t) => t.type === newObject.type);
      if (oldObject) {
        oldObject.value = newObject.value;
      } else {
        oldT.push(newObject);
      }
    }
    return Transform.join(oldT);
  }
  static addTransform(oldTransform, newTransform) {
    var oldT = Transform.parseStyle(oldTransform, false);
    var newT = Transform.parseStyle(newTransform);
    for (var i = 0, len2 = newT.length; i < len2; i++) {
      var newObject = newT[i];
      var oldObject = oldT.find((t) => t.type === newObject.type);
      if (oldObject) {
        newObject.value.forEach((v, i2) => {
          oldObject.value[i2].value += v.value;
        });
      } else {
        oldT.push(newObject);
      }
    }
    return Transform.join(oldT);
  }
  static get(transform2, type) {
    var arr = Transform.parseStyle(transform2, true);
    if (typeof type === "function") {
      arr = arr.find(type);
    } else {
      arr = arr.find((it) => it.type === type);
    }
    if (arr) {
      return arr.value;
    }
    return void 0;
  }
  static createRotateKey(transform2, angle, field) {
    return `${transform2}:::${field}(${angle})`;
  }
  static rotate(transform2, angle, field = "rotate") {
    const key = Transform.createRotateKey(transform2, angle, field);
    if (TransformCache.has(key))
      return TransformCache.get(key);
    TransformCache.set(key, Transform.replace(transform2, { type: field, value: [angle] }));
    return TransformCache.get(key);
  }
  static rotateZ(transform2, angle) {
    return Transform.rotate(transform2, angle, "rotateZ");
  }
  static rotateX(transform2, angle) {
    return Transform.rotate(transform2, angle, "rotateX");
  }
  static rotateY(transform2, angle) {
    return Transform.rotate(transform2, angle, "rotateY");
  }
  static parseStyle(transform2, doCache = true) {
    var transforms = [];
    if (!transform2)
      return transforms;
    if (doCache && TransformCache.has(transform2)) {
      return TransformCache.get(transform2);
    }
    var matches2 = transform2.match(TRANSFORM_REG) || [];
    matches2.forEach((value, index2) => {
      var [transformName, transformValue] = value.split("(");
      transformValue = transformValue.split(")")[0];
      var arr = transformValue.split(",");
      if (transformValue.includes("matrix") || transformValue.includes("scale")) {
        arr = arr.map((it) => Length.number(it.trim()));
      } else {
        arr = arr.map((it) => Length.parse(it.trim()));
      }
      transforms[index2] = Transform.parse({
        type: transformName,
        value: arr
      });
    });
    if (doCache) {
      TransformCache.set(transform2, transforms);
    }
    return transforms;
  }
  static createTransformMatrix(parsedTransformList, width2, height2) {
    const view = create$4();
    for (let i = 0, len2 = parsedTransformList.length; i < len2; i++) {
      const it = parsedTransformList[i];
      switch (it.type) {
        case "translate":
        case "translateX":
        case "translateY":
        case "translateZ":
          var values = it.value;
          if (it.type === "translate") {
            values = [
              values[0].toPx(width2).value,
              values[1].toPx(height2).value,
              0
            ];
          } else if (it.type === "translateX") {
            values = [values[0].toPx(width2).value, 0, 0];
          } else if (it.type === "translateY") {
            values = [0, values[0].toPx(height2).value, 0];
          } else if (it.type === "translateZ") {
            values = [0, 0, values[0].toPx().value];
          }
          translate(view, view, values);
          break;
        case "rotate":
        case "rotateZ":
          rotateZ(view, view, degreeToRadian(it.value[0].value));
          break;
        case "rotateX":
          rotateX(view, view, degreeToRadian(it.value[0].value));
          break;
        case "rotateY":
          rotateY(view, view, degreeToRadian(it.value[0].value));
          break;
        case "rotate3d":
          var values = it.value;
          rotate$1(view, view, degreeToRadian(it.value[3].value), [
            values[0].value,
            values[1].value,
            values[2].value
          ]);
          break;
        case "scale":
          scale$1(view, view, [it.value[0].value, it.value[1].value, 1]);
          break;
        case "scaleX":
          scale$1(view, view, [it.value[0].value, 1, 1]);
          break;
        case "scaleY":
          scale$1(view, view, [1, it.value[0].value, 1]);
          break;
        case "scaleZ":
          scale$1(view, view, [1, 1, it.value[0].value]);
          break;
        case "skewX":
          var rad = it.value[0].toDeg().toRad();
          multiply$1(view, view, fromValues$1(1, 0, 0, 0, Math.tan(rad.value), 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1));
          break;
        case "skewY":
          var rad = it.value[0].toDeg().toRad();
          multiply$1(view, view, fromValues$1(1, Math.tan(rad.value), 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1));
          break;
        case "skew":
          const skewX = it.value[0].toDeg().toRad();
          const skewY = it.value.length > 1 ? it.value[1].toDeg().toRad() : skewX;
          multiply$1(view, view, fromValues$1(1, Math.tan(skewY.value), 0, 0, Math.tan(skewX.value), 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1));
          break;
        case "matrix":
          var values = it.value;
          values = [
            values[0].value,
            values[1].value,
            0,
            0,
            values[2].value,
            values[3].value,
            0,
            0,
            0,
            0,
            1,
            0,
            values[4].value,
            values[5].value,
            0,
            1
          ];
          multiply$1(view, view, values);
          break;
        case "matrix3d":
          var values = it.value.map((it2) => it2.value);
          multiply$1(view, view, values);
          break;
        case "perspective":
          var values = it.value;
          perspective(view, Math.PI * 0.5, width2 / height2, 1, values[0].value);
          break;
      }
    }
    return view;
  }
  static fromScale(scale2) {
    if (scale2[0] === 1 && scale2[1] === 1) {
      return "";
    }
    const list2 = [];
    if (scale2[0] != 1)
      list2.push(`scaleX(${scale2[0]})`);
    if (scale2[1] != 1)
      list2.push(`scaleY(${scale2[1]})`);
    if (scale2[2] != 1)
      list2.push(`scaleZ(${scale2[2]})`);
    return list2.join(" ");
  }
}
var updatePathItem = {
  command: "updatePathItem",
  description: "Update path string for selected svg path item",
  execute: function(editor, pathObject) {
    const current = editor.context.selection.current;
    if (current) {
      if (pathObject.box === "box") {
        const newPath = current.invertPath(pathObject.d);
        editor.context.commands.executeCommand("setAttribute", "change local path", editor.context.selection.packByValue({
          d: newPath.d
        }));
      } else {
        const newPath = new PathParser(pathObject.d);
        newPath.transformMat4(pathObject.matrix.absoluteMatrixInverse);
        let bbox = newPath.getBBox();
        const newWidth = distance$1(bbox[1], bbox[0]);
        const newHeight = distance$1(bbox[3], bbox[0]);
        let oldBBox = vertiesMap(rectToVerties(bbox[0][0], bbox[0][1], newWidth, newHeight), pathObject.matrix.absoluteMatrix);
        let newBBox = vertiesMap(oldBBox, calculateMatrixInverse(fromTranslation([], oldBBox[4]), Transform.createTransformMatrix(Transform.parseStyle(pathObject.matrix.transform), newWidth, newHeight), fromTranslation([], negate([], oldBBox[4]))));
        const worldMatrix = calculateMatrix(fromTranslation([], newBBox[0]), current.getLocalTransformMatrix(newWidth, newHeight));
        const realXY = getTranslation([], calculateMatrix(pathObject.matrix.parentMatrixInverse, worldMatrix, invert([], current.getLocalTransformMatrix(newWidth, newHeight))));
        editor.context.commands.executeCommand("setAttribute", "change path", editor.context.selection.packByValue({
          d: newPath.translate(-bbox[0][0], -bbox[0][1]).d,
          x: realXY[0],
          y: realXY[1],
          width: newWidth,
          height: newHeight
        }));
      }
    }
  }
};
var __glob_0_115 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": updatePathItem
}, Symbol.toStringTag, { value: "Module" }));
var updateResource = {
  command: "updateResource",
  execute: function(editor, items) {
    items.forEach((item) => {
      switch (item.type) {
        case "image/svg+xml":
        case "image/png":
        case "image/gif":
        case "image/jpg":
        case "image/jpeg":
          editor.context.commands.emit("updateImage", item);
          break;
        case "text/plain":
        case "text/html":
          editor.context.commands.emit("addText", {
            content: item.data
          });
          break;
        case "text/uri-list":
          editor.context.commands.emit("updateUriList", item);
          break;
      }
    });
  }
};
var __glob_0_116 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": updateResource
}, Symbol.toStringTag, { value: "Module" }));
var updateUriList = {
  command: "updateUriList",
  execute: function(editor, item) {
    var datauri = item.data;
    if (datauri.indexOf("data:") > -1) {
      var info = AssetParser.parse(datauri, true);
      switch (info.mimeType) {
        case "image/png":
        case "image/gif":
        case "image/jpg":
        case "image/jpeg":
          editor.context.commands.emit("addImageAssetItem", {
            id: uuidShort(),
            type: info.mimeType,
            name: "",
            original: datauri,
            local: info.local
          });
          break;
      }
    } else {
      var ext = item.data.split(".").pop();
      var name = item.data.split("/").pop();
      switch (ext) {
        case "png":
        case "jpg":
        case "gif":
        case "svg":
          editor.context.commands.emit("addImageAssetItem", {
            id: uuidShort(),
            type: "image/" + ext,
            name,
            original: item.data,
            local: item.data
          });
          break;
      }
    }
  }
};
var __glob_0_117 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": updateUriList
}, Symbol.toStringTag, { value: "Module" }));
var updateVideo = {
  command: "updateVideo",
  execute: function(editor, item, rect2, containerItem = void 0) {
    var reader = new window.FileReader();
    reader.onload = (e) => {
      var datauri = e.target.result;
      var local = window.URL.createObjectURL(item);
      editor.context.commands.emit("addVideoAssetItem", {
        id: uuidShort(),
        type: item.type,
        name: item.name,
        original: datauri,
        local
      }, rect2, containerItem);
    };
    reader.readAsDataURL(item);
  }
};
var __glob_0_118 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": updateVideo
}, Symbol.toStringTag, { value: "Module" }));
var updateVideoAssetItem = {
  command: "updateVideoAssetItem",
  execute: function(editor, item, callback) {
    var reader = new window.FileReader();
    reader.onload = (e) => {
      var datauri = e.target.result;
      var local = window.URL.createObjectURL(item);
      var project2 = editor.context.selection.currentProject;
      if (project2) {
        project2.createVideo({
          id: uuidShort(),
          type: item.type,
          name: item.name,
          original: datauri,
          local
        });
        editor.emit("addVideoAsset");
        isFunction(callback) && callback(local);
      }
    };
    reader.readAsDataURL(item);
  }
};
var __glob_0_119 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": updateVideoAssetItem
}, Symbol.toStringTag, { value: "Module" }));
var update = {
  command: "update",
  description: "Update the model",
  execute: function(editor, id = null, attrs = {}, context = { origin: "*" }) {
    const item = editor.get(id);
    if (item) {
      const isChanged = item.reset(attrs, context);
      if (isChanged) {
        editor.context.commands.emit("refreshElement", item);
      }
    }
  }
};
var __glob_0_120 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": update
}, Symbol.toStringTag, { value: "Module" }));
const modules$1 = { "./command_list/_currentProject.js": __glob_0_0$1, "./command_list/_doForceRefreshSelection.js": __glob_0_1$1, "./command_list/addArtBoard.js": __glob_0_2$1, "./command_list/addBackgroundColor.js": __glob_0_3$1, "./command_list/addBackgroundImageAsset.js": __glob_0_4$1, "./command_list/addBackgroundImageGradient.js": __glob_0_5$1, "./command_list/addBackgroundImagePattern.js": __glob_0_6$1, "./command_list/addCustomComponent.js": __glob_0_7$1, "./command_list/addImage.js": __glob_0_8$1, "./command_list/addImageAssetItem.js": __glob_0_9$1, "./command_list/addLayer.js": __glob_0_10$1, "./command_list/addLayerView.js": __glob_0_11$1, "./command_list/addProject.js": __glob_0_12$1, "./command_list/addSVGFilterAssetItem.js": __glob_0_13$1, "./command_list/addText.js": __glob_0_14$1, "./command_list/addTimelineCurrentProperty.js": __glob_0_15$1, "./command_list/addTimelineItem.js": __glob_0_16$1, "./command_list/addTimelineKeyframe.js": __glob_0_17$1, "./command_list/addTimelineProperty.js": __glob_0_18$1, "./command_list/addVideo.js": __glob_0_19$1, "./command_list/addVideoAssetItem.js": __glob_0_20$1, "./command_list/clipboard.copy.js": __glob_0_21$1, "./command_list/clipboard.paste.js": __glob_0_22$1, "./command_list/convert.flatten.path.js": __glob_0_23$1, "./command_list/convert.no.transform.path.js": __glob_0_24, "./command_list/convert.normalize.path.js": __glob_0_25, "./command_list/convert.path.operation.js": __glob_0_26, "./command_list/convert.polygonal.path.js": __glob_0_27, "./command_list/convert.simplify.path.js": __glob_0_28, "./command_list/convert.smooth.path.js": __glob_0_29, "./command_list/convert.stroke.to.path.js": __glob_0_30, "./command_list/convertPasteText.js": __glob_0_31, "./command_list/convertPath.js": __glob_0_32, "./command_list/copy.path.js": __glob_0_33, "./command_list/copyLayer.js": __glob_0_34, "./command_list/copyTimelineProperty.js": __glob_0_35, "./command_list/deleteTimelineKeyframe.js": __glob_0_36, "./command_list/doubleclick.item.js": __glob_0_37, "./command_list/downloadJSON.js": __glob_0_38, "./command_list/downloadPNG.js": __glob_0_39, "./command_list/downloadSVG.js": __glob_0_40, "./command_list/drop.asset.js": __glob_0_41, "./command_list/dropImageUrl.js": __glob_0_42, "./command_list/editor.config.body.event.js": __glob_0_43, "./command_list/fileDropItems.js": __glob_0_44, "./command_list/firstTimelineItem.js": __glob_0_45, "./command_list/group.item.js": __glob_0_46, "./command_list/history.addLayer.js": __glob_0_47, "./command_list/history.bring.forward.js": __glob_0_48, "./command_list/history.bring.front.js": __glob_0_49, "./command_list/history.clipboard.paste.js": __glob_0_50, "./command_list/history.copyLayer.js": __glob_0_51, "./command_list/history.group.item.js": __glob_0_52, "./command_list/history.moveLayer.js": __glob_0_53, "./command_list/history.moveLayerToTarget.js": __glob_0_54, "./command_list/history.refreshSelection.js": __glob_0_55, "./command_list/history.refreshSelectionProject.js": __glob_0_56, "./command_list/history.removeLayer.js": __glob_0_57, "./command_list/history.removeProject.js": __glob_0_58, "./command_list/history.send.back.js": __glob_0_59, "./command_list/history.send.backward.js": __glob_0_60, "./command_list/history.setAttribute.js": __glob_0_61, "./command_list/item.move.depth.down.js": __glob_0_62, "./command_list/item.move.depth.first.js": __glob_0_63, "./command_list/item.move.depth.last.js": __glob_0_64, "./command_list/item.move.depth.up.js": __glob_0_65, "./command_list/keymap.keydown.js": __glob_0_66, "./command_list/lastTimelineItem.js": __glob_0_67, "./command_list/load.json.js": __glob_0_68, "./command_list/moveLayer.js": __glob_0_69, "./command_list/moveLayerForItems.js": __glob_0_70, "./command_list/moveSelectionToCenter.js": __glob_0_71, "./command_list/newComponent.js": __glob_0_72, "./command_list/nextTimelineItem.js": __glob_0_73, "./command_list/open.editor.js": __glob_0_74, "./command_list/pauseTimelineItem.js": __glob_0_75, "./command_list/playTimelineItem.js": __glob_0_76, "./command_list/prevTimelineItem.js": __glob_0_77, "./command_list/recoverBooleanPath.js": __glob_0_78, "./command_list/refreshArtboard.js": __glob_0_79, "./command_list/refreshElement.js": __glob_0_80, "./command_list/refreshHistory.js": __glob_0_81, "./command_list/refreshSelectedOffset.js": __glob_0_82, "./command_list/removeAnimationItem.js": __glob_0_83, "./command_list/removeLayer.js": __glob_0_84, "./command_list/removeTimeline.js": __glob_0_85, "./command_list/removeTimelineProperty.js": __glob_0_86, "./command_list/resizeArtBoard.js": __glob_0_87, "./command_list/rotateLayer.js": __glob_0_88, "./command_list/same.height.js": __glob_0_89, "./command_list/same.width.js": __glob_0_90, "./command_list/saveJSON.js": __glob_0_91, "./command_list/savePNG.js": __glob_0_92, "./command_list/segment.delete.js": __glob_0_93, "./command_list/segment.move.down.js": __glob_0_94, "./command_list/segment.move.left.js": __glob_0_95, "./command_list/segment.move.right.js": __glob_0_96, "./command_list/segment.move.up.js": __glob_0_97, "./command_list/select.all.js": __glob_0_98, "./command_list/select.none.js": __glob_0_99, "./command_list/selectTimelineItem.js": __glob_0_100, "./command_list/setAttribute.js": __glob_0_101, "./command_list/setTimelineOffset.js": __glob_0_102, "./command_list/showExportView.js": __glob_0_103, "./command_list/sort.bottom.js": __glob_0_104, "./command_list/sort.center.js": __glob_0_105, "./command_list/sort.left.js": __glob_0_106, "./command_list/sort.middle.js": __glob_0_107, "./command_list/sort.right.js": __glob_0_108, "./command_list/sort.top.js": __glob_0_109, "./command_list/switch.path.js": __glob_0_110, "./command_list/ungroup.item.js": __glob_0_111, "./command_list/updateClipPath.js": __glob_0_112, "./command_list/updateImage.js": __glob_0_113, "./command_list/updateImageAssetItem.js": __glob_0_114, "./command_list/updatePathItem.js": __glob_0_115, "./command_list/updateResource.js": __glob_0_116, "./command_list/updateUriList.js": __glob_0_117, "./command_list/updateVideo.js": __glob_0_118, "./command_list/updateVideoAssetItem.js": __glob_0_119, "./command_list/model/update.js": __glob_0_120 };
const obj = {};
Object.entries(modules$1).forEach(([key, value]) => {
  key = key.replace("./command_list/", "").replace(".js", "");
  obj[key] = value.default;
});
function commands(editor) {
  editor.loadCommands(obj);
}
var area_width = {
  key: "area.width",
  defaultValue: 100,
  title: "Area Width to find layers fastly",
  description: "Set area width/height",
  type: "number"
};
var __glob_0_0 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": area_width
}, Symbol.toStringTag, { value: "Module" }));
var debug_mode = {
  key: "debug.mode",
  defaultValue: false,
  title: "debug mode",
  description: "Set debug mode to on ",
  type: "boolean"
};
var __glob_0_1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": debug_mode
}, Symbol.toStringTag, { value: "Module" }));
var editing_css_itemType = {
  key: "editing.css.itemType",
  defaultValue: "rect",
  title: "set item type for  editing css",
  description: "set item type for  editing css",
  type: "string"
};
var __glob_0_2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": editing_css_itemType
}, Symbol.toStringTag, { value: "Module" }));
var editing_draw_itemType = {
  key: "editing.draw.itemType",
  defaultValue: "path",
  title: "set item type for  editing draw",
  description: "set item type for  editing draw",
  type: "string"
};
var __glob_0_3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": editing_draw_itemType
}, Symbol.toStringTag, { value: "Module" }));
var editing_mode_itemType = {
  key: "editing.mode.itemType",
  defaultValue: "select",
  title: "set item type for  editing mode",
  description: "set item type for  editing mode",
  type: "string"
};
var __glob_0_4 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": editing_mode_itemType
}, Symbol.toStringTag, { value: "Module" }));
var editing_mode = {
  key: "editing.mode",
  defaultValue: EditingMode.SELECT,
  title: "set editing mode for Editor",
  description: "set editing mode (select, append, draw, path)",
  type: "string"
};
var __glob_0_5 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": editing_mode
}, Symbol.toStringTag, { value: "Module" }));
var editing_svg_itemType = {
  key: "editing.svg.itemType",
  defaultValue: "svg-rect",
  title: "set item type for  editing svg",
  description: "set item type for  editing svg",
  type: "string"
};
var __glob_0_6 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": editing_svg_itemType
}, Symbol.toStringTag, { value: "Module" }));
var editor_design_mode = {
  key: "editor.design.mode",
  defaultValue: "design",
  title: "Editor Design Mode ",
  description: "Set editor's design mode",
  options: ["design", "item"],
  type: "select"
};
var __glob_0_7 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": editor_design_mode
}, Symbol.toStringTag, { value: "Module" }));
var editor_layout_mode = {
  key: "editor.layout.mode",
  defaultValue: "all",
  title: "Editor Layout Mode ",
  description: "Set editor's layout mode",
  type: "string"
};
var __glob_0_8 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": editor_layout_mode
}, Symbol.toStringTag, { value: "Module" }));
var fixed_angle = {
  key: "fixed.angle",
  defaultValue: 15,
  title: "fixed angle count",
  description: "Set fixed angle",
  type: "number"
};
var __glob_0_9 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": fixed_angle
}, Symbol.toStringTag, { value: "Module" }));
var fixed_gradient_angle = {
  key: "fixed.gradient.angle",
  defaultValue: 1,
  title: "fixed gradient angle count",
  description: "Set fixed gradient angle",
  type: "number"
};
var __glob_0_10 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": fixed_gradient_angle
}, Symbol.toStringTag, { value: "Module" }));
var history_delay_ms = {
  key: "history.delay.ms",
  defaultValue: 500,
  title: "history delay milliseconds",
  description: "Set history delay time",
  type: "number"
};
var __glob_0_11 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": history_delay_ms
}, Symbol.toStringTag, { value: "Module" }));
var horizontal_line = {
  key: "horizontal.line",
  defaultValue: [],
  title: "horizontal guide line for snap ",
  description: "horizontal guide line for snap",
  type: "array"
};
var __glob_0_12 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": horizontal_line
}, Symbol.toStringTag, { value: "Module" }));
var horizontal_line_selected_index = {
  key: "horizontal.line.selected.index",
  defaultValue: -1,
  title: "selected horizontal guide line index",
  description: "selected horizontal guide line index",
  type: "number"
};
var __glob_0_13 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": horizontal_line_selected_index
}, Symbol.toStringTag, { value: "Module" }));
var set_drag_path_area = {
  key: "set.drag.path.area",
  defaultValue: false,
  title: "Drag path area",
  description: "Drag path area",
  type: "boolean",
  storage: "none"
};
var __glob_0_14 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": set_drag_path_area
}, Symbol.toStringTag, { value: "Module" }));
var set_move_control_point = {
  key: "set.move.control.point",
  defaultValue: false,
  title: "Moving Control Point",
  description: "Moving Control Point",
  type: "boolean",
  storage: "none"
};
var __glob_0_15 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": set_move_control_point
}, Symbol.toStringTag, { value: "Module" }));
var show_left_panel = {
  key: "show.left.panel",
  defaultValue: true,
  title: "Show left panel",
  description: "Set left panel visibility to on",
  type: "boolean"
};
var __glob_0_16 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": show_left_panel
}, Symbol.toStringTag, { value: "Module" }));
var show_outline = {
  key: "show.outline",
  defaultValue: false,
  title: "Show outline",
  description: "Set outline visibility to on",
  type: "boolean"
};
var __glob_0_17 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": show_outline
}, Symbol.toStringTag, { value: "Module" }));
var show_right_panel = {
  key: "show.right.panel",
  defaultValue: true,
  title: "Show right panel",
  description: "Set right panel visibility to on",
  type: "boolean"
};
var __glob_0_18 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": show_right_panel
}, Symbol.toStringTag, { value: "Module" }));
var show_ruler = {
  key: "show.ruler",
  defaultValue: true,
  title: "Show ruler",
  description: "Set ruler visibility to on",
  type: "boolean"
};
var __glob_0_19 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": show_ruler
}, Symbol.toStringTag, { value: "Module" }));
var snap_distance = {
  key: "snap.distance",
  defaultValue: 3,
  title: "Snap distance between objects",
  description: "Set snap distance",
  type: "number"
};
var __glob_0_20 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": snap_distance
}, Symbol.toStringTag, { value: "Module" }));
var snap_grid = {
  key: "snap.grid",
  defaultValue: 50,
  title: "Snap grid size between objects",
  description: "Set snap grid size",
  type: "number"
};
var __glob_0_21 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": snap_grid
}, Symbol.toStringTag, { value: "Module" }));
var vertical_line = {
  key: "vertical.line",
  defaultValue: [],
  title: "vertical guide line for snap ",
  description: "vertical guide line for snap",
  type: "array"
};
var __glob_0_22 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": vertical_line
}, Symbol.toStringTag, { value: "Module" }));
var vertical_line_selected_index = {
  key: "vertical.line.selected.index",
  defaultValue: -1,
  title: "selected vertical guide line index",
  description: "selected vertical guide line index",
  type: "number"
};
var __glob_0_23 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": vertical_line_selected_index
}, Symbol.toStringTag, { value: "Module" }));
const modules = { "./config_list/area.width.js": __glob_0_0, "./config_list/debug.mode.js": __glob_0_1, "./config_list/editing.css.itemType.js": __glob_0_2, "./config_list/editing.draw.itemType.js": __glob_0_3, "./config_list/editing.mode.itemType.js": __glob_0_4, "./config_list/editing.mode.js": __glob_0_5, "./config_list/editing.svg.itemType.js": __glob_0_6, "./config_list/editor.design.mode.js": __glob_0_7, "./config_list/editor.layout.mode.js": __glob_0_8, "./config_list/fixed.angle.js": __glob_0_9, "./config_list/fixed.gradient.angle.js": __glob_0_10, "./config_list/history.delay.ms.js": __glob_0_11, "./config_list/horizontal.line.js": __glob_0_12, "./config_list/horizontal.line.selected.index.js": __glob_0_13, "./config_list/set.drag.path.area.js": __glob_0_14, "./config_list/set.move.control.point.js": __glob_0_15, "./config_list/show.left.panel.js": __glob_0_16, "./config_list/show.outline.js": __glob_0_17, "./config_list/show.right.panel.js": __glob_0_18, "./config_list/show.ruler.js": __glob_0_19, "./config_list/snap.distance.js": __glob_0_20, "./config_list/snap.grid.js": __glob_0_21, "./config_list/vertical.line.js": __glob_0_22, "./config_list/vertical.line.selected.index.js": __glob_0_23 };
var configs$1 = Object.values(modules).map((it) => it.default);
function configs(editor) {
  configs$1.forEach((config) => {
    editor.registerConfig(config);
  });
}
class Selector extends PropertyItem {
  static parse(obj2) {
    return new Selector(obj2);
  }
  getDefaultObject(obj2) {
    return super.getDefaultObject(__spreadValues({
      itemType: "selector",
      selector: "",
      properties: []
    }, obj2));
  }
  toCloneObject() {
    return __spreadValues(__spreadValues({}, super.toCloneObject()), this.attrs("selector", "properties"));
  }
  isMultiStyle(key) {
    switch (key) {
      case "background-image":
      case "var":
        return true;
    }
    return false;
  }
  getMultiStyleString(p) {
    switch (p.key) {
      case "background-image":
        return p.value.toString() + ";";
    }
    return p.value.toString() + " !important;";
  }
  toPropertyString() {
    return this.json.properties.map((p) => {
      if (this.isMultiStyle(p.key)) {
        return this.getMultiStyleString(p);
      } else {
        var value = p.value.toString();
        if (value) {
          var key = p.key;
          if (key === "x")
            key = "left";
          else if (key === "y")
            key = "top";
          return `${key}: ${value} !important;`;
        } else {
          return "";
        }
      }
    }).join("\n");
  }
  toCSSText(prefix = "") {
    return `${prefix}${this.json.selector} {
    ${this.toPropertyString()}
}`;
  }
  toCSS() {
    return {};
  }
  toString(prefix = "") {
    return this.toCSSText(prefix);
  }
}
var DefaultLayoutEngine = {
  startCache(container) {
    container.addCache("cachedSize", {
      width: container.width,
      height: container.height
    });
    container.addCache("cachedLayerMatrix", container.layers.map((child) => {
      child.startToCacheChildren();
      const { x, y, width: width2, height: height2 } = child.attrs("x", "y", "width", "height");
      return {
        id: child.id,
        matrix: { x, y, width: width2, height: height2 },
        constraints: {
          horizontal: child[ConstraintsDirection.HORIZONTAL],
          vertical: child[ConstraintsDirection.VERTICAL]
        }
      };
    }));
  },
  recover(container) {
    const obj2 = {
      width: container.width,
      height: container.height
    };
    const currentContainerWidth = obj2.width;
    const currentContainerHeight = obj2.height;
    const cachedSize = container.getCache("cachedSize");
    const oldContainerWidth = cachedSize.width;
    const oldContainerHeight = cachedSize.height;
    const scaleX = currentContainerWidth / oldContainerWidth;
    const scaleY = currentContainerHeight / oldContainerHeight;
    const cachedLayerMatrix = container.getCache("cachedLayerMatrix");
    cachedLayerMatrix.forEach(({ id, matrix, constraints }) => {
      const item = container.find(id);
      const { x, y, width: width2, height: height2 } = matrix;
      const left2 = x;
      const right2 = oldContainerWidth - x - width2;
      const top2 = y;
      const bottom2 = oldContainerHeight - y - height2;
      const localObj = {};
      switch (constraints.horizontal) {
        case Constraints.MIN:
          localObj.x = left2;
          break;
        case Constraints.MAX:
          localObj.x = currentContainerWidth - right2 - width2;
          break;
        case Constraints.STRETCH:
          localObj.x = left2;
          localObj.width = currentContainerWidth - left2 - right2;
          break;
        case Constraints.SCALE:
          localObj.x = left2 * scaleX;
          localObj.width = width2 * scaleX;
          break;
        case Constraints.CENTER:
          const halfWidth = width2 / 2;
          const scaleNew = (x + halfWidth) / oldContainerWidth;
          localObj.x = scaleNew * currentContainerWidth - halfWidth;
          break;
      }
      switch (constraints.vertical) {
        case Constraints.MIN:
          localObj.y = top2;
          break;
        case Constraints.MAX:
          localObj.y = currentContainerHeight - bottom2 - height2;
          break;
        case Constraints.STRETCH:
          localObj.y = top2;
          localObj.height = currentContainerHeight - top2 - bottom2;
          break;
        case Constraints.SCALE:
          localObj.y = top2 * scaleY;
          localObj.height = height2 * scaleY;
          break;
        case Constraints.CENTER:
          const halfHeight = height2 / 2;
          const scaleNew = (y + halfHeight) / oldContainerHeight;
          localObj.y = scaleNew * currentContainerHeight - halfHeight;
          break;
      }
      item.reset(localObj);
      item.recoverChildren();
    });
  }
};
var GridLayoutEngine = {
  startCache() {
  },
  recover() {
  },
  updateGridArea(currentItem, gridInformation, scale2 = 1) {
    if (currentItem.isInGrid() === false)
      return;
    const lastVerties = currentItem.originVerties;
    const targetRect = vertiesToRectangle(lastVerties);
    const { items } = gridInformation;
    const epsilon = IntersectEpsilonNumberType.RECT / scale2;
    const checkedGridRowColumnList = items.filter((it) => {
      return polyPoly(lastVerties, it.originVerties);
    }).filter((it) => {
      const intersect = intersectRectRect(it.originRect, targetRect);
      return Math.floor(intersect.width) > epsilon && Math.floor(intersect.height) > epsilon;
    });
    if (checkedGridRowColumnList.length === 0)
      return;
    const rows = checkedGridRowColumnList.map((it) => it.row);
    rows.sort((a, b) => a - b);
    const columns = checkedGridRowColumnList.map((it) => it.column);
    columns.sort((a, b) => a - b);
    const gridColumnStart = columns[0];
    const gridColumnEnd = columns[columns.length - 1];
    const gridRowStart = rows[0];
    const gridRowEnd = rows[rows.length - 1];
    const gridArea = {
      "grid-column-start": gridColumnStart,
      "grid-column-end": gridColumnEnd + 1,
      "grid-row-start": gridRowStart,
      "grid-row-end": gridRowEnd + 1
    };
    currentItem.reset(gridArea);
    return gridArea;
  }
};
class Offset extends PropertyItem {
  static parse(obj2) {
    return new Offset(obj2);
  }
  getDefaultObject() {
    return super.getDefaultObject({
      itemType: "offset",
      offset: Length.percent(0),
      color: "rgba(255, 255, 255, 1)",
      properties: []
    });
  }
  toCloneObject() {
    return __spreadValues(__spreadValues({}, super.toCloneObject()), this.attrs("offset", "color", "properties"));
  }
  convert(json) {
    json = super.convert(json);
    json.offset = Length.parse(json.offset);
    return json;
  }
  toCSSText() {
    return `${this.json.offset} ${CSS_TO_STRING(this.toCSS())}`;
  }
  createProperty(data = {}) {
    return this.addProperty(__spreadValues({
      checked: true,
      value: 0
    }, data));
  }
  addProperty(property) {
    this.json.properties.push(property);
  }
  removeProperty(removeIndex) {
    this.json.properties.splice(removeIndex, 1);
  }
  sortItem(arr, startIndex, targetIndex) {
    arr.splice(targetIndex + (startIndex < targetIndex ? -1 : 0), 0, ...arr.splice(startIndex, 1));
  }
  sortProperty(startIndex, targetIndex) {
    this.sortItem(this.json.properties, startIndex, targetIndex);
  }
  updateProperty(index2, data = {}) {
    Object.assign(this.json.properties[+index2], __spreadValues({}, data));
  }
  updatePropertyByKey(key, data = {}) {
    var arr = this.json.properties;
    var index2 = -1;
    for (var i = 0, len2 = arr.length; i < len2; i++) {
      if (this.json.properties[i].key === key) {
        index2 = i;
        break;
      }
    }
    Object.assign(this.json.properties[+index2], __spreadValues({}, data));
  }
  toCSS() {
    var obj2 = {};
    this.json.properties.forEach((it) => {
      obj2 = __spreadValues(__spreadValues({}, obj2), it.toCSS());
    });
    return obj2;
  }
  toString() {
    return this.toCSSText();
  }
}
class Keyframe extends PropertyItem {
  static parse(obj2) {
    return new Keyframe(obj2);
  }
  static parseStyle(style) {
    var keyframes = [];
    var keyframeKeys = {};
    if (style["keyframe"]) {
      var results = convertMatches(style["keyframe"]);
      results.str.split("|").map((it) => it.trim()).forEach((frameInfo, index2) => {
        var [name, offset, property, ...values] = frameInfo.split(" ");
        var propertyValue = values.join(" ");
        if (!keyframeKeys[name]) {
          keyframeKeys[name] = new Keyframe({
            name
          });
          keyframes[index2] = name;
        }
        var filteredOffset = keyframeKeys[name].offsets.filter((it) => {
          return it.offset.equals(Length.parse(offset));
        });
        var offsetObj = null;
        if (filteredOffset.length) {
          offsetObj = filteredOffset[0];
        } else {
          offsetObj = new Offset({
            offset: Length.parse(offset)
          });
          keyframeKeys[name].offsets.push(offsetObj);
        }
        offsetObj.addProperty({
          key: property,
          value: reverseMatches(propertyValue, results.matches)
        });
      });
    }
    return keyframes.map((name) => {
      keyframeKeys[name].offsets.forEach((offset) => {
        var vars = [];
        var properties = [];
        offset.properties.forEach((p) => {
          if (p.key.includes("--")) {
            vars.push(p);
          } else {
            properties.push(p);
          }
        });
        let varValue = vars.map((it) => `${it.key}:${it.value}`).join(";");
        if (vars.length) {
          properties.push({ key: "var", value: varValue });
        }
        offset.properties = properties;
      });
      return keyframeKeys[name];
    });
  }
  getDefaultObject() {
    return super.getDefaultObject({
      itemType: "keyframe",
      name: "sample",
      selectedType: "list",
      offsets: []
    });
  }
  toCloneObject() {
    var { offsets } = this.json;
    return __spreadProps(__spreadValues(__spreadValues({}, super.toCloneObject()), this.attrs("name", "selectedType")), {
      offsets: offsets.map((offset) => offset.clone())
    });
  }
  isMultiStyle(key) {
    switch (key) {
      case "background-image":
      case "var":
        return true;
    }
    return false;
  }
  getMultiStyleString(p) {
    switch (p.key) {
      case "background-image":
        return p.value.toString() + ";";
      case "var":
        var value = (p.value + "").split(";").map((str) => {
          return `--` + str;
        }).join(";");
        return value + ";";
    }
    return p.value.toString() + ";";
  }
  toOffsetString(it) {
    var tabString = "      ";
    return `${it.offset.toString()} {
${tabString}${it.properties.map((p) => {
      if (this.isMultiStyle(p.key)) {
        return this.getMultiStyleString(p);
      } else {
        var value = (p.value || "").toString();
        if (value) {
          var key = p.key;
          if (key === "x")
            key = "left";
          else if (key === "y")
            key = "top";
          return `${key}: ${value};`;
        } else {
          return "";
        }
      }
    }).join("").replace(/;/g, ";\n" + tabString).trim()}
  }`;
  }
  toOffsetText() {
    var offsets = this.json.offsets.map((it) => {
      return it;
    });
    offsets.sort((a, b) => {
      return a.offset.value > b.offset.value ? 1 : -1;
    });
    return offsets.map((it) => {
      if (it.properties.length === 0)
        return "";
      return this.toOffsetString(it);
    }).join("\n");
  }
  toCSSText() {
    var offsets = this.json.offsets.map((it) => {
      return it;
    });
    offsets.sort((a, b) => {
      return a.offset.value > b.offset.value ? 1 : -1;
    });
    return `
@keyframes ${this.json.name} {

  ${this.toOffsetText()}

}
`;
  }
  createOffset(data = {}) {
    return this.addOffset(new Offset(__spreadValues({
      checked: true
    }, data)));
  }
  addOffset(offset) {
    this.json.offsets.push(offset);
  }
  removeOffset(removeIndex) {
    this.json.offsets.splice(removeIndex, 1);
  }
  sortItem(arr, startIndex, targetIndex) {
    arr.splice(targetIndex + (startIndex < targetIndex ? -1 : 0), 0, ...arr.splice(startIndex, 1));
  }
  sortOffset(startIndex, targetIndex) {
    this.sortItem(this.json.offsets, startIndex, targetIndex);
  }
  updateOffset(index2, data = {}) {
    this.json.offsets[+index2].reset(data);
  }
  toCSS() {
    return {};
  }
  toString() {
    return this.toCSSText();
  }
}
class BaseModel {
  constructor(json = {}, modelManager) {
    __privateAdd(this, _modelManager, null);
    __privateAdd(this, _json, {});
    __privateAdd(this, _cachedValue, {});
    __privateAdd(this, _timestamp2, 0);
    __privateAdd(this, _lastChangedField, {});
    __privateAdd(this, _collapsed, false);
    this.setModelManager(modelManager);
    this.initializeModel(json);
  }
  initializeModel(json) {
    __privateSet(this, _json, this.convert(Object.assign(this.getDefaultObject(), json)));
  }
  get manager() {
    return __privateGet(this, _modelManager);
  }
  setModelManager(modelManager) {
    __privateSet(this, _modelManager, modelManager);
  }
  getDefaultTitle() {
    return "Item";
  }
  getIcon() {
    return "";
  }
  isChanged(timestamp) {
    console.log("isChanged", timestamp);
    return this.timestamp != Number(timestamp);
  }
  changed() {
    __privateSet(this, _timestamp2, __privateGet(this, _timestamp2) + Date.now());
  }
  get timestamp() {
    return __privateGet(this, _timestamp2);
  }
  get title() {
    return this.name || this.getDefaultTitle();
  }
  get itemType() {
    return this.get("itemType");
  }
  get name() {
    return this.get("name");
  }
  get children() {
    return this.get("children");
  }
  get collapsed() {
    return __privateGet(this, _collapsed);
  }
  set collapsed(value) {
    __privateSet(this, _collapsed, value);
  }
  get visibility() {
    return this.get("visibility");
  }
  set visibility(value) {
    this.set("visibility", value);
  }
  renameWithCount() {
    let arr = __privateGet(this, _json).name.split(" ");
    if (arr.length < 2) {
      return;
    }
    let last = arr.pop();
    let lastNumber = +last;
    if (isNumber(lastNumber) && isNaN(lastNumber) === false) {
      lastNumber++;
    } else {
      lastNumber = last;
    }
    const nextName = [...arr, lastNumber].join(" ");
    this.reset({
      name: nextName
    });
  }
  get allLayers() {
    return this.manager.getAllLayers(this.id);
  }
  get layers() {
    return this.manager.getLayers(this.id) || [];
  }
  filteredAllLayers(filterCallback) {
    return this.manager.getAllLayers(this.id, filterCallback);
  }
  get id() {
    return __privateGet(this, _json).id;
  }
  get parentId() {
    const parentId = __privateGet(this, _json).parentId;
    if (parentId === this.id)
      return void 0;
    return parentId;
  }
  get parent() {
    if (!this.parentId)
      return void 0;
    return this.manager.get(this.parentId);
  }
  get depth() {
    return this.path.length;
  }
  get top() {
    return this.path.filter((it) => it.isNot("project")).shift();
  }
  get project() {
    return this.path.find((it) => it.is("project"));
  }
  get artboard() {
    return this.path.find((it) => it.is("artboard"));
  }
  get path() {
    const path = [this];
    let parent;
    while (parent = path[0].parent) {
      path.unshift(parent);
    }
    return path;
  }
  get pathIds() {
    return this.path.map((it) => it.id);
  }
  setParentId(parentId) {
    this.reset({ parentId });
    this.manager.setChanged("setParentId", this.id, { parentId });
  }
  get childrenLength() {
    return __privateGet(this, _json).children.length;
  }
  get index() {
    var _a;
    return (_a = this.parent) == null ? void 0 : _a.findIndex(this);
  }
  get isFirst() {
    return this.index === 0;
  }
  get isLast() {
    return this.index === this.parent.childrenLength - 1;
  }
  get first() {
    return this.parent.layers[0];
  }
  get last() {
    const parent = this.parent;
    return parent.layers[parent.childrenLength - 1];
  }
  get prev() {
    var _a;
    const index2 = this.index;
    if (this.isFirst) {
      return this;
    }
    return (_a = this.parent) == null ? void 0 : _a.layers[index2 - 1];
  }
  get next() {
    var _a;
    const index2 = this.index;
    if (this.isLast) {
      return this;
    }
    return (_a = this.parent) == null ? void 0 : _a.layers[index2 + 1];
  }
  get hierarchy() {
    return this.getInformationForHierarchy("x", "y", "angle");
  }
  getInformationForHierarchy(...args2) {
    const parent = this.parent;
    const index2 = this.index;
    return {
      id: this.id,
      index: index2,
      parentId: this.parentId,
      prev: index2 === 0 ? void 0 : parent.children[index2 - 1],
      next: index2 === parent.childrenLength - 1 ? void 0 : parent.children[index2 + 1],
      attrs: this.attrs(...args2)
    };
  }
  getInnerId(postfix = "") {
    return __privateGet(this, _json).id + postfix;
  }
  is(checkItemType) {
    return __privateGet(this, _json).itemType === checkItemType;
  }
  isNot(checkItemType) {
    return this.is(checkItemType) === false;
  }
  get(key) {
    return __privateGet(this, _json)[key];
  }
  removeField(key) {
    delete __privateGet(this, _json)[key];
  }
  set(key, value) {
    this.reset({ [key]: value });
  }
  isSVG() {
    return false;
  }
  addCache(key, value) {
    __privateGet(this, _cachedValue)[key] = value;
  }
  getCache(key) {
    return __privateGet(this, _cachedValue)[key];
  }
  hasCache(key) {
    return Boolean(__privateGet(this, _cachedValue)[key]);
  }
  computed(key, newValueCallback, isForce = false) {
    const cachedKey = `__cachedKey_${key}`;
    const parsedKey = `${cachedKey}__parseValue`;
    const value = __privateGet(this, _json)[key];
    if (isForce)
      ;
    else {
      if (this.getCache(cachedKey) === value && this.getCache(parsedKey)) {
        return this.getCache(parsedKey);
      }
    }
    this.addCache(cachedKey, value);
    this.addCache(parsedKey, newValueCallback(value, this));
    return this.getCache(parsedKey);
  }
  computedValue(key) {
    const cachedKey = `__cachedKey_${key}`;
    const parsedKey = `${cachedKey}__parseValue`;
    return this.getCache(parsedKey);
  }
  editable() {
    return true;
  }
  generateListNumber() {
    this.layers.forEach((it, index2) => {
      it.no = index2;
      it.generateListNumber();
    });
  }
  convert(json = {}) {
    return json;
  }
  setCache() {
  }
  toCloneObject(isDeep = true) {
    const json = {};
    Object.keys(__privateGet(this, _json)).forEach((field) => {
      if (isNotUndefined(this.get(field))) {
        json[field] = clone$1(this.get(field));
      }
    });
    if (isDeep) {
      json.layers = this.layers.map((layer) => {
        return layer.clone(isDeep);
      });
    }
    return json;
  }
  clone(isDeep = true) {
    return __privateGet(this, _modelManager).clone(this.id, isDeep);
  }
  reset(obj2, context = { origin: "*" }) {
    var _a;
    __privateSet(this, _json, this.convert(Object.assign(__privateGet(this, _json), obj2)));
    __privateSet(this, _lastChangedField, obj2);
    if (context.origin === "*") {
      (_a = __privateGet(this, _modelManager)) == null ? void 0 : _a.setChanged("reset", this.id, obj2);
    }
    this.changed();
    return true;
  }
  hasChangedField(...args2) {
    return args2.some((it) => __privateGet(this, _lastChangedField)[it] !== void 0);
  }
  get hasChangedHirachy() {
    return this.hasChangedField("children", "parentId");
  }
  getDefaultObject(obj2 = {}) {
    var id = obj2.id || uuid();
    return __spreadValues({
      id,
      name: "",
      itemType: "base",
      children: [],
      parentId: "",
      visibility: "visible"
    }, obj2);
  }
  attrs(...args2) {
    const result = {};
    args2.forEach((field) => {
      if (isNotUndefined(this.get(field))) {
        result[field] = clone$1(this.get(field));
      }
    });
    return result;
  }
  attrsWithId(...args2) {
    return {
      [this.id]: this.attrs(...args2)
    };
  }
  hasChildren() {
    return this.children.length > 0;
  }
  appendChild(layer) {
    if (layer.parentId === this.id) {
      const hasId = this.children.find((it) => it === layer.id);
      if (Boolean(hasId) === false) {
        this.children.push(layer.id);
        __privateGet(this, _modelManager).setChanged("appendChild", this.id, {
          child: layer.id,
          oldParentId: layer.parentId
        });
      }
      return layer;
    }
    this.resetMatrix(layer);
    if (layer.parent) {
      layer.remove();
    }
    layer.setParentId(this.id);
    this.children.push(layer.id);
    return layer;
  }
  resetMatrix() {
  }
  refreshMatrixCache() {
  }
  insertChild(layer, index2 = 0) {
    var _a;
    this.resetMatrix(layer);
    if (layer.parent && ((_a = layer.parent) == null ? void 0 : _a.id) !== this.id) {
      layer.remove();
    }
    layer.setParentId(this.id);
    let list2 = this.children.map((id, childIndex) => {
      return { id, index: childIndex };
    });
    const childItem = list2.find((it) => it.id === layer.id);
    const targetIndex = index2 - 0.5;
    if (childItem) {
      childItem.index = targetIndex;
    } else {
      list2.push({ id: layer.id, index: targetIndex });
    }
    list2.sort((a, b) => {
      return a.index - b.index;
    });
    this.reset({
      children: list2.map((it) => it.id)
    });
    __privateGet(this, _modelManager).setChanged("insertChild", this.id, {
      childId: layer.id,
      index: 0
    });
    return layer;
  }
  insertAfter(layer) {
    this.parent.insertChild(layer, this.index + 1);
    return layer;
  }
  insertBefore(layer) {
    this.parent.insertChild(layer, this.index);
    return layer;
  }
  toggle(field, toggleValue) {
    if (isUndefined(toggleValue)) {
      this.reset({
        [field]: !this.get(field)
      });
    } else {
      this.reset({
        [field]: !!toggleValue
      });
    }
  }
  isTreeItemHide() {
    let currentParent = this.parent;
    let collapsedList = [];
    do {
      if (currentParent.is("project"))
        break;
      collapsedList.push(Boolean(currentParent.collapsed));
      currentParent = currentParent.parent;
    } while (currentParent);
    return Boolean(collapsedList.filter(Boolean).length);
  }
  expectJSON(key) {
    if (isUndefined(this.get(key)))
      return false;
    return true;
  }
  toJSON() {
    const json = __privateGet(this, _json);
    let newJSON = {};
    Object.keys(json).filter((key) => this.expectJSON(key)).forEach((key) => {
      newJSON[key] = json[key];
    });
    if (this.hasChildren()) {
      newJSON.layers = this.layers.map((layer) => {
        return layer.toJSON();
      });
    }
    return newJSON;
  }
  resize() {
  }
  copy(dist2 = 0) {
    return this.parent.copyItem(this.id, dist2);
  }
  findIndex(child) {
    return this.children.indexOf(child.id);
  }
  find(id) {
    return __privateGet(this, _modelManager).get(id);
  }
  copyItem(childItemId, dist2 = 10) {
    const childItem = this.find(childItemId);
    var child = childItem.clone();
    child.renameWithCount();
    child.absoluteMove([dist2, dist2, 0]);
    var childIndex = this.findIndex(childItem);
    if (childIndex > -1) {
      this.children.push(child.id);
    }
    return child;
  }
  remove() {
    this.parent.removeChild(this.id);
  }
  removeChild(childItemId) {
    return __privateGet(this, _modelManager).removeChild(this.id, childItemId);
  }
  hasParent(findParentId) {
    return this.parentId === findParentId;
  }
  hasPathOf(targetItems = []) {
    const path = this.path;
    return targetItems.filter((it) => it.id !== this.id).some((target) => {
      return path.find((it) => it.id === target.id);
    });
  }
  hasChild(childId) {
    return this.children.includes(childId);
  }
  to() {
  }
  sendBackward(targetId) {
    const siblings = this.children;
    const result = {};
    let selectedIndex = -1;
    siblings.forEach((id, index2) => {
      result[id] = { id, index: index2 };
      if (id === targetId) {
        selectedIndex = index2;
      }
    });
    result[targetId].index = selectedIndex - 1.5;
    const children2 = Object.values(result).sort((a, b) => a.index - b.index).map((it) => it.id);
    this.reset({
      children: children2
    });
  }
  sendBack(targetId) {
    const siblings = this.children;
    const result = {};
    siblings.forEach((id, index2) => {
      result[id] = { id, index: index2 };
    });
    result[targetId].index = -1;
    const children2 = Object.values(result).sort((a, b) => a.index - b.index).map((it) => it.id);
    this.reset({
      children: children2
    });
  }
  bringForward(targetId) {
    const siblings = this.children;
    const result = {};
    let selectedIndex = -1;
    siblings.forEach((id, index2) => {
      result[id] = { id, index: index2 };
      if (id === targetId) {
        selectedIndex = index2;
      }
    });
    result[targetId].index = selectedIndex + 1.5;
    const children2 = Object.values(result).sort((a, b) => a.index - b.index).map((it) => it.id);
    this.reset({
      children: children2
    });
  }
  bringFront(targetId) {
    const siblings = this.children;
    const result = {};
    siblings.forEach((id, index2) => {
      result[id] = { id, index: index2 };
    });
    result[targetId].index = Number.MAX_SAFE_INTEGER;
    const children2 = Object.values(result).sort((a, b) => a.index - b.index).map((it) => it.id);
    this.reset({
      children: children2
    });
  }
}
_modelManager = new WeakMap();
_json = new WeakMap();
_cachedValue = new WeakMap();
_timestamp2 = new WeakMap();
_lastChangedField = new WeakMap();
_collapsed = new WeakMap();
class BaseAssetModel extends BaseModel {
  getDefaultObject(obj2 = {}) {
    return super.getDefaultObject(__spreadValues({
      svgfilters: [],
      keyframes: []
    }, obj2));
  }
  get keyframes() {
    return this.get("keyframes");
  }
  get svgfilters() {
    return this.get("svgfilters");
  }
  addKeyframe(keyframe2) {
    this.keyframes.push(keyframe2);
    return keyframe2;
  }
  createKeyframe(data = {}) {
    return this.addKeyframe(new Keyframe(__spreadValues({
      checked: true
    }, data)));
  }
  removeKeyframe(removeIndex) {
    this.removePropertyList(this.keyframes, removeIndex);
  }
  sortItem(arr, startIndex, targetIndex) {
    arr.splice(targetIndex + (startIndex < targetIndex ? -1 : 0), 0, ...arr.splice(startIndex, 1));
  }
  sortKeyframe(startIndex, targetIndex) {
    this.sortItem(this.keyframes, startIndex, targetIndex);
  }
  updateKeyframe(index2, data = {}) {
    this.keyframes[+index2].reset(data);
  }
  toKeyframeString(isAnimate = false) {
    return this.keyframes.map((keyframe2) => keyframe2.toString(isAnimate)).join("\n\n");
  }
  copyPropertyList(arr, index2) {
    var copyObject = __spreadValues({}, arr[index2]);
    arr.splice(index2, 0, copyObject);
  }
  removePropertyList(arr, removeIndex) {
    arr.splice(removeIndex, 1);
  }
  getSVGFilterIndex(id) {
    var _a;
    var filter2 = this.svgfilters.map((it, index2) => {
      return { id: it.id, index: index2 };
    }).filter((it) => {
      return it.id === id;
    });
    return filter2.length ? (_a = filter2 == null ? void 0 : filter2[0]) == null ? void 0 : _a.index : -1;
  }
  removeSVGFilter(removeIndex) {
    this.removePropertyList(this.svgfilters, removeIndex);
  }
  copySVGFilter(index2) {
    this.copyPropertyList(this.svgfilters, index2);
  }
  sortSVGFilter(startIndex, targetIndex) {
    this.sortItem(this.svgfilters, startIndex, targetIndex);
  }
  setSVGFilterValue(index2, value) {
    this.svgfilters[index2] = __spreadValues(__spreadValues({}, this.svgfilters[index2]), value);
  }
  addSVGFilter(obj2 = {}) {
    this.svgfilters.push(obj2);
    var index2 = this.svgfilters.length - 1;
    return index2;
  }
  createSVGFilter(data = {}) {
    return this.addSVGFilter(__spreadValues({
      id: uuidShort()
    }, data));
  }
}
class MovableModel extends BaseAssetModel {
  getDefaultObject(obj2 = {}) {
    return super.getDefaultObject(__spreadValues({
      angle: 0,
      x: 0,
      y: 0,
      width: 300,
      height: 300,
      position: "absolute",
      perspective: "",
      perspectiveOrigin: "",
      transformOrigin: "50% 50% 0px"
    }, obj2));
  }
  get isAbsolute() {
    return this.position === "absolute";
  }
  get isDragSelectable() {
    return true;
  }
  get isBooleanItem() {
    return void 0;
  }
  get resizableWitChildren() {
    return false;
  }
  get perspective() {
    return this.get("perspective");
  }
  get perspectiveOrigin() {
    return this.get("perspectiveOrigin");
  }
  get transform() {
    return `rotateZ(${Length.deg(this.angle)})`;
  }
  get localMatrix() {
    if (!this.hasCache("localTransform")) {
      this.addCache("localTransform", this.getLocalTransformMatrix());
    }
    return this.getCache("localTransform") || this.getLocalTransformMatrix();
  }
  get localMatrixInverse() {
    if (!this.hasCache("localTransformInverse")) {
      this.addCache("localTransformInverse", this.getLocalTransformMatrixInverse());
    }
    return this.getCache("localTransformInverse") || this.getLocalTransformMatrixInverse();
  }
  get transformWithTranslate() {
    if (!this.hasCache("transformWithTranslate")) {
      this.addCache("transformWithTranslate", this.getTransformWithTranslate(this));
    }
    return this.getCache("transformWithTranslate") || this.getTransformWithTranslate(this);
  }
  get transformWithTranslateToTranspose() {
    if (!this.hasCache("transformWithTranslateTranspose")) {
      this.addCache("transformWithTranslateTranspose", this.getTransformWithTranslate(this));
    }
    return this.getCache("transformWithTranslateTranspose") || transpose([], this.getTransformWithTranslate(this));
  }
  get transformWithTranslateInverse() {
    if (!this.hasCache("transformWithTranslateInverse")) {
      this.addCache("transformWithTranslateInverse", this.getTransformWithTranslate(this));
    }
    return this.getCache("transformWithTranslateInverse") || invert([], this.getTransformWithTranslate(this));
  }
  get itemMatrix() {
    if (!this.hasCache("itemTransform")) {
      this.addCache("itemTransform", this.getItemTransformMatrix());
    }
    return this.getCache("itemTransform") || this.getItemTransformMatrix();
  }
  get itemMatrixInverse() {
    if (!this.hasCache("itemTransformInverse")) {
      this.addCache("itemTransformInverse", this.getItemTransformMatrixInverse());
    }
    return this.getCache("itemTransformInverse") || this.getItemTransformMatrixInverse();
  }
  get absoluteMatrix() {
    if (!this.hasCache("absoluteMatrix")) {
      this.addCache("absoluteMatrix", this.getAbsoluteMatrix());
    }
    return this.getCache("absoluteMatrix") || this.getAbsoluteMatrix();
  }
  get absoluteMatrixInverse() {
    if (!this.hasCache("absoluteMatrixInverse")) {
      this.addCache("absoluteMatrixInverse", this.getAbsoluteMatrixInverse());
    }
    return this.getCache("absoluteMatrixInverse") || this.getAbsoluteMatrixInverse();
  }
  get relativeMatrix() {
    if (!this.hasCache("relativeMatrix")) {
      this.addCache("relativeMatrix", this.getRelativeMatrix());
    }
    return this.getCache("relativeMatrix") || this.getRelativeMatrix();
  }
  get relativeMatrixInverse() {
    if (!this.hasCache("relativeMatrixInverse")) {
      this.addCache("relativeMatrixInverse", this.getRelativeMatrixInverse());
    }
    return this.getCache("relativeMatrixInverse") || this.getRelativeMatrixInverse();
  }
  get verties() {
    if (!this.hasCache("verties")) {
      this.addCache("verties", this.getVerties());
    }
    return this.getCache("verties") || this.getVerties();
  }
  get contentVerties() {
    if (!this.hasCache("contentVerties")) {
      this.addCache("contentVerties", this.getContentVerties());
    }
    return this.getCache("contentVerties") || this.getContentVerties();
  }
  get originVerties() {
    if (!this.hasCache("vertiesWithoutTransformOrigin")) {
      this.addCache("vertiesWithoutTransformOrigin", this.rectVerties());
    }
    return this.getCache("vertiesWithoutTransformOrigin") || this.rectVerties();
  }
  get localVerties() {
    if (!this.hasCache("localVerties")) {
      this.addCache("localVerties", this.getLocalVerties());
    }
    return this.getCache("localVerties") || this.getLocalVerties();
  }
  get guideVerties() {
    if (!this.hasCache("guideVerties")) {
      this.addCache("guideVerties", this.getGuideVerties());
    }
    return this.getCache("guideVerties") || this.getGuideVerties();
  }
  get xList() {
    if (!this.hasCache("xList")) {
      this.addCache("xList", this.getXList());
    }
    return this.getCache("xList") || this.getXList();
  }
  get yList() {
    if (!this.hasCache("yList")) {
      this.addCache("yList", this.getYList());
    }
    return this.getCache("yList") || this.getYList();
  }
  get areaPosition() {
    if (!this.hasCache("areaPosition")) {
      this.addCache("areaPosition", this.getAreaPosition(100));
    }
    return this.getCache("areaPosition") || this.getAreaPosition(100);
  }
  get offsetX() {
    return this.x;
  }
  get offsetY() {
    return this.y;
  }
  get screenWidth() {
    return this.width;
  }
  get screenHeight() {
    return this.height;
  }
  get y() {
    return this.get("y");
  }
  set y(value) {
    this.set("y", value);
  }
  get x() {
    return this.get("x");
  }
  set x(value) {
    this.set("x", value);
  }
  get width() {
    return this.get("width");
  }
  set width(value) {
    this.set("width", value);
  }
  get height() {
    return this.get("height");
  }
  set height(value) {
    this.set("height", value);
  }
  get angle() {
    return this.get("angle");
  }
  set angle(value) {
    this.set("angle", value);
  }
  get position() {
    return this.get("position");
  }
  set position(value) {
    this.set("position", value);
  }
  get transformOrigin() {
    return this.get("transformOrigin");
  }
  set transformOrigin(value) {
    this.reset({
      transformOrigin: value
    });
  }
  get translate() {
    return [0, 0, 0];
  }
  get scale() {
    return [1, 1, 1];
  }
  get rotate() {
    return [0, 0, degreeToRadian(this.angle)];
  }
  get origin() {
    return TransformOrigin.scale(this.transformOrigin || "50% 50% 0px", this.screenWidth, this.screenHeight);
  }
  get absoluteOrigin() {
    return vertiesMap([this.origin], this.absoluteMatrix)[0];
  }
  get quat() {
    return fromEuler(create$1(), 0, 0, this.angle);
  }
  getAreaPosition(areaSize = 100) {
    const verties = this.getVerties();
    const rect2 = toRectVerties(verties);
    const [startRow, startColumn] = area(rect2[0][0], rect2[0][1], areaSize);
    const [endRow, endColumn] = area(rect2[2][0], rect2[2][1], areaSize);
    return {
      column: [startColumn, endColumn],
      row: [startRow, endRow]
    };
  }
  reset(obj2, context = { origin: "*" }) {
    const isChanged = super.reset(obj2, context);
    if (this.hasChangedField("children", "x", "y", "width", "height", "boxModel", "angle", "transformOrigin", "resizingVertical", "resizingHorizontal", "contraintsVertical", "contraintsHorizontal") || this.changedLayout) {
      this.refreshMatrixCache();
    }
    return isChanged;
  }
  changed() {
    super.changed();
    this.changedRect = this.hasChangedField("children", "x", "y", "width", "height", "angle", "transformOrigin", "resizingVertical", "resizingHorizontal", "contraintsVertical", "contraintsHorizontal");
  }
  setParentId(otherParentId) {
    super.setParentId(otherParentId);
    this.refreshMatrixCache();
  }
  refreshMatrixCache() {
    this.setCacheItemTransformMatrix();
    this.setCacheLocalTransformMatrix();
    this.setCacheAbsoluteMatrix();
    this.setCacheLocalVerties();
    this.setCacheVerties();
    this.setCacheGuideVerties();
    this.setCacheAreaPosition();
    this.layers.forEach((it) => {
      it.refreshMatrixCache();
    });
  }
  setCacheItemTransformMatrix() {
    this.addCache("itemTransform", this.getItemTransformMatrix());
    this.addCache("itemTransformInverse", invert([], this.getCache("itemTransform")));
  }
  setCacheLocalTransformMatrix() {
    this.addCache("localTransform", this.getLocalTransformMatrix());
    this.addCache("localTransformInverse", invert([], this.getCache("localTransform")));
    this.addCache("transformWithTranslate", this.getTransformWithTranslate(this));
    this.addCache("transformWithTranslateInverse", invert([], this.getCache("transformWithTranslate")));
    this.addCache("transformWithTranslateTranspose", transpose([], this.getCache("transformWithTranslate")));
  }
  setCacheAbsoluteMatrix() {
    this.addCache("absoluteMatrix", this.getAbsoluteMatrix());
    this.addCache("absoluteMatrixInverse", invert([], this.getCache("absoluteMatrix")));
    this.addCache("relativeMatrix", this.getRelativeMatrix());
    this.addCache("relativeMatrixInverse", invert([], this.getCache("relativeMatrix")));
  }
  setCacheVerties() {
    this.addCache("verties", this.getVerties());
    this.addCache("contentVerties", this.getContentVerties());
    this.addCache("vertiesWithoutTransformOrigin", this.rectVerties());
  }
  setCacheLocalVerties() {
    this.addCache("localVerties", this.getLocalVerties());
  }
  setCacheGuideVerties() {
    this.addCache("guideVerties", this.getGuideVerties());
    this.addCache("xList", this.getXList());
    this.addCache("yList", this.getYList());
  }
  setCacheAreaPosition() {
    this.addCache("areaPosition", this.getAreaPosition(100));
  }
  move(distVector = [0, 0, 0]) {
    this.reset({
      x: round(this.offsetX + distVector[0]),
      y: round(this.offsetY + distVector[1])
    });
  }
  moveByCenter(newCenter = [0, 0, 0]) {
    this.reset({
      x: newCenter[0] - this.screenWidth / 2,
      y: newCenter[1] - this.screenHeight / 2
    });
  }
  absoluteMove(absoluteDist = [0, 0, 0]) {
    var _a;
    const oldVertex = this.verties[4];
    const newVertex = add$1([], oldVertex, absoluteDist);
    const newVerties = vertiesMap([oldVertex, newVertex], ((_a = this.parent) == null ? void 0 : _a.absoluteMatrixInverse) || identity$3([]));
    const newDist = subtract([], newVerties[1], newVerties[0]);
    const oldPosition = this.attrs("x", "y");
    this.move(newDist);
    return oldPosition;
  }
  startToCacheChildren() {
  }
  recoverChildren() {
  }
  resize(width2, height2) {
    this.startToCacheChildren();
    this.reset({ width: width2, height: height2 });
    this.recoverChildren();
  }
  setAngle(angle = 0) {
    this.reset({
      angle
    });
  }
  addAngle(angle = 0) {
    this.setAngle(this.angle + angle);
  }
  checkInArea(areaVerties) {
    return polyPoly(areaVerties, this.originVerties);
  }
  hasPoint(x, y) {
    return this.isPointInRect(x, y);
  }
  isPointInRect(x, y) {
    return polyPoint(this.originVerties, x, y);
  }
  isIncludeByArea(areaVerties) {
    return this.originVerties.map((vector) => {
      return polyPoint(areaVerties, ...vector);
    }).filter(Boolean).length === 4;
  }
  getPerspectiveMatrix() {
    const hasPerspective = this.perspective;
    if (!hasPerspective) {
      return void 0;
    }
    let [
      perspectiveOriginX = Length.percent(50),
      perspectiveOriginY = Length.percent(50)
    ] = TransformOrigin.parseStyle(this.perspectiveOrigin);
    const width2 = this.screenWidth;
    const height2 = this.screenHeight;
    perspectiveOriginX = perspectiveOriginX.toPx(width2).value;
    perspectiveOriginY = perspectiveOriginY.toPx(height2).value;
    const view = create$4();
    translate(view, view, [perspectiveOriginX, perspectiveOriginY, 0]);
    if (this.perspective && this.perspective != "none") {
      multiply$1(view, view, fromValues$1(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, -1 / Length.parse(this.perspective).value, 1));
    } else {
      return void 0;
    }
    translate(view, view, [-perspectiveOriginX, -perspectiveOriginY, 0]);
    return view;
  }
  getItemTransformMatrix() {
    const list2 = Transform.parseStyle(this.transform);
    const width2 = this.screenWidth;
    const height2 = this.screenHeight;
    return Transform.createTransformMatrix(list2, width2, height2);
  }
  getItemTransformMatrixInverse() {
    return invert([], this.getItemTransformMatrix());
  }
  getLocalTransformMatrix(width2, height2) {
    const origin = TransformOrigin.scale(this.transformOrigin || "50% 50% 0px", isUndefined(width2) ? this.screenWidth : width2, isUndefined(height2) ? this.screenHeight : height2);
    const view = create$4();
    translate(view, view, origin);
    multiply$1(view, view, this.itemMatrix);
    translate(view, view, negate([], origin));
    return view;
  }
  getLocalTransformMatrixInverse(width2, height2) {
    return invert([], this.getLocalTransformMatrix(width2, height2));
  }
  getDirectionTransformMatrix(vertexOffset, width2, height2) {
    const x = this.offsetX;
    const y = this.offsetY;
    const center2 = add$1([], TransformOrigin.scale(this.transformOrigin || "50% 50% 0px", width2, height2), negate([], vertexOffset));
    const view = create$4();
    translate(view, view, [x, y, 0]);
    translate(view, view, vertexOffset);
    translate(view, view, center2);
    multiply$1(view, view, this.itemMatrix);
    translate(view, view, negate([], center2));
    return view;
  }
  getDirectionTopLeftMatrix(width2, height2) {
    return this.getDirectionTransformMatrix([0, 0, 0], width2, height2);
  }
  getDirectionLeftMatrix(width2, height2) {
    return this.getDirectionTransformMatrix([0, height2 / 2, 0], width2, height2);
  }
  getDirectionTopMatrix(width2, height2) {
    return this.getDirectionTransformMatrix([width2 / 2, 0, 0], width2, height2);
  }
  getDirectionBottomLeftMatrix(width2, height2) {
    return this.getDirectionTransformMatrix([0, height2, 0], width2, height2);
  }
  getDirectionTopRightMatrix(width2, height2) {
    return this.getDirectionTransformMatrix([width2, 0, 0], width2, height2);
  }
  getDirectionRightMatrix(width2, height2) {
    return this.getDirectionTransformMatrix([width2, height2 / 2, 0], width2, height2);
  }
  getDirectionBottomRightMatrix(width2, height2) {
    return this.getDirectionTransformMatrix([width2, height2, 0], width2, height2);
  }
  getDirectionBottomMatrix(width2, height2) {
    return this.getDirectionTransformMatrix([width2 / 2, height2, 0], width2, height2);
  }
  getAbsoluteMatrix() {
    let transform2 = create$4();
    if (this.parent) {
      multiply$1(transform2, transform2, this.parent.absoluteMatrix);
      if (isFunction(this.parent.getPerspectiveMatrix)) {
        const perspectiveMatrix = this.parent.getPerspectiveMatrix();
        if (perspectiveMatrix) {
          multiply$1(transform2, transform2, perspectiveMatrix);
        }
      }
    }
    multiply$1(transform2, transform2, this.getRelativeMatrix());
    if (transform2.filter((it) => !isNaN(it)).length === 0) {
      return create$4();
    }
    return transform2;
  }
  getRelativeMatrix() {
    let transform2 = create$4();
    const offsetX = this.offsetX;
    const offsetY = this.offsetY;
    translate(transform2, transform2, [offsetX, offsetY, 0]);
    multiply$1(transform2, transform2, this.localMatrix);
    return transform2;
  }
  getRelativeMatrixInverse() {
    return invert([], this.getRelativeMatrix());
  }
  getTransformWithTranslate(item) {
    item = item || this;
    let view = create$4();
    const offsetX = item.offsetX;
    const offsetY = item.offsetY;
    translate(view, view, [offsetX, offsetY, 0]);
    multiply$1(view, view, item.localMatrix);
    return view;
  }
  getAbsoluteMatrixInverse() {
    return invert([], this.getAbsoluteMatrix());
  }
  getLocalVerties(width2, height2) {
    width2 = isNotUndefined(width2) ? width2 : this.screenWidth;
    height2 = isNotUndefined(height2) ? height2 : this.screenHeight;
    let model = rectToVerties(0, 0, width2, height2, this.transformOrigin);
    return model;
  }
  getVerties(width2, height2) {
    width2 = isNotUndefined(width2) ? width2 : this.screenWidth;
    height2 = isNotUndefined(height2) ? height2 : this.screenHeight;
    let x = 0;
    let y = 0;
    if (this.parent && this.parent.is("project") === false) {
      const contentBox = this.parent.contentBox;
      x = contentBox.x;
      y = contentBox.y;
    }
    let model = rectToVerties(x, y, width2, height2, this.transformOrigin);
    return vertiesMap(model, this.absoluteMatrix);
  }
  getContentVerties(width2, height2) {
    width2 = isNotUndefined(width2) ? width2 : this.screenWidth;
    height2 = isNotUndefined(height2) ? height2 : this.screenHeight;
    const center2 = TransformOrigin.scale(this.transformOrigin, width2, height2);
    const paddingTop = this.get("padding-top") || 0;
    const paddingRight = this.get("padding-right") || 0;
    const paddingBottom = this.get("padding-bottom") || 0;
    const paddingLeft = this.get("padding-left") || 0;
    const model = rectToVerties(0 + paddingLeft, 0 + paddingTop, width2 - paddingLeft - paddingRight, height2 - paddingTop - paddingBottom, this.transformOrigin);
    model[4] = center2;
    return vertiesMap(model, this.absoluteMatrix);
  }
  rectVerties() {
    return this.verties.filter((_, index2) => index2 < 4);
  }
  getGuideVerties() {
    const verties = this.originVerties;
    return [
      ...verties,
      lerp([], verties[0], verties[1], 0.5),
      lerp([], verties[1], verties[2], 0.5),
      lerp([], verties[2], verties[3], 0.5),
      lerp([], verties[3], verties[0], 0.5)
    ];
  }
  getXList() {
    return [...new Set(this.guideVerties.map((it) => it[0]))];
  }
  getYList() {
    return [...new Set(this.guideVerties.map((it) => it[1]))];
  }
  get nestedAngle() {
    if (this.parent) {
      return this.parent.nestedAngle + this.angle;
    }
    return this.angle || 0;
  }
  get toRectVerties() {
    return itemsToRectVerties([this]);
  }
  get matrix() {
    const id = this.id;
    const x = this.offsetX;
    const y = this.offsetY;
    const width2 = this.screenWidth;
    const height2 = this.screenHeight;
    const originalTransform = this.transform;
    const originalTransformOrigin = this.transformOrigin || "50% 50% 0px";
    const transformOriginMatrix = this.getTransformOriginMatrix();
    const transformOriginMatrixInverse = this.getTransformOriginMatrixInverse();
    const parentMatrix = this.parent.absoluteMatrix;
    const parentMatrixInverse = this.parent.absoluteMatrixInverse;
    const localMatrix = this.localMatrix;
    const localMatrixInverse = this.localMatrixInverse;
    const itemMatrix = this.itemMatrix;
    const itemMatrixInverse = this.itemMatrixInverse;
    const absoluteMatrix = this.absoluteMatrix;
    const absoluteMatrixInverse = this.absoluteMatrixInverse;
    const relativeMatrix = this.relativeMatrix;
    const relativeMatrixInverse = this.relativeMatrixInverse;
    const directionMatrix = {
      "to top left": this.getDirectionTopLeftMatrix(width2, height2),
      "to top": this.getDirectionTopMatrix(width2, height2),
      "to top right": this.getDirectionTopRightMatrix(width2, height2),
      "to right": this.getDirectionRightMatrix(width2, height2),
      "to bottom left": this.getDirectionBottomLeftMatrix(width2, height2),
      "to bottom": this.getDirectionBottomMatrix(width2, height2),
      "to bottom right": this.getDirectionBottomRightMatrix(width2, height2),
      "to left": this.getDirectionLeftMatrix(width2, height2)
    };
    const verties = this.verties;
    const xList = verties.map((it) => it[0]);
    const yList = verties.map((it) => it[1]);
    return {
      id,
      x,
      y,
      width: width2,
      height: height2,
      transform: originalTransform,
      originalTransformOrigin,
      verties,
      originVerties: this.originVerties,
      xList,
      yList,
      directionMatrix,
      parentMatrix,
      parentMatrixInverse,
      localMatrix,
      localMatrixInverse,
      itemMatrix,
      itemMatrixInverse,
      absoluteMatrix,
      absoluteMatrixInverse,
      relativeMatrix,
      relativeMatrixInverse,
      transformOriginMatrix,
      transformOriginMatrixInverse
    };
  }
  absolutePath(pathString2 = "") {
    const d = pathString2 || this.d;
    const pathParser = new PathParser(d);
    pathParser.transformMat4(this.absoluteMatrix);
    return pathParser;
  }
  invertPath(pathString2 = "") {
    const path = new PathParser(pathString2);
    path.transformMat4(this.absoluteMatrixInverse);
    return path;
  }
  invertPoint(point2) {
    return transformMat4([], point2, this.absoluteMatrixInverse);
  }
  invertPathString(pathString2 = "") {
    return this.invertPath(pathString2).d;
  }
  updatePath(d) {
    const matrix = this.matrix;
    const newPath = new PathParser(d);
    let bbox = newPath.getBBox();
    const newWidth = distance$1(bbox[1], bbox[0]);
    const newHeight = distance$1(bbox[3], bbox[0]);
    let oldBBox = vertiesMap(rectToVerties(bbox[0][0], bbox[0][1], newWidth, newHeight), matrix.absoluteMatrix);
    let newBBox = vertiesMap(oldBBox, calculateMatrixInverse(fromTranslation([], oldBBox[4]), Transform.createTransformMatrix(Transform.parseStyle(matrix.transform), newWidth, newHeight), fromTranslation([], negate([], oldBBox[4]))));
    const worldMatrix = calculateMatrix(fromTranslation([], newBBox[0]), this.getLocalTransformMatrix(newWidth, newHeight));
    const realXY = getTranslation([], calculateMatrix(matrix.parentMatrixInverse, worldMatrix, invert([], this.getLocalTransformMatrix(newWidth, newHeight))));
    return {
      d: newPath.translate(-bbox[0][0], -bbox[0][1]).d,
      x: realXY[0],
      y: realXY[1],
      width: newWidth,
      height: newHeight
    };
  }
  checkInAreaForAll(areaVerties) {
    const items = [...this.checkInAreaForLayers(areaVerties)];
    if (this.is("artboard"))
      return items;
    if (this.is("project"))
      return items;
    if (this.checkInArea(areaVerties)) {
      items.push(this);
    }
    return items;
  }
  checkInAreaForLayers(areaVerties) {
    var items = [];
    this.layers.forEach((layer) => {
      items.push.apply(items, layer.checkInAreaForLayers(areaVerties));
      if (layer.checkInArea(areaVerties)) {
        items.push(layer);
      }
    });
    return items;
  }
  getTransformOriginMatrix() {
    return fromTranslation([], TransformOrigin.scale(this.transformOrigin || "50% 50% 0px", this.screenWidth, this.screenHeight));
  }
  getTransformOriginMatrixInverse() {
    return invert([], this.getTransformOriginMatrix());
  }
  recoverMatrix(newChildMatrix) {
    const matrix = calculateMatrix(this.absoluteMatrixInverse, newChildMatrix.absoluteMatrix);
    const q = getRotation([], matrix);
    const axis = [];
    const rad = getAxisAngle(axis, q);
    const angle = axis[2] ? radianToDegree(rad * axis[2]) : 0;
    const newTransformMatrix = create$4();
    fromRotation(newTransformMatrix, rad, axis);
    const [x, y] = getTranslation([], calculateMatrix(matrix, calculateMatrixInverse(newChildMatrix.transformOriginMatrix, newTransformMatrix, newChildMatrix.transformOriginMatrixInverse)));
    return { x, y, angle };
  }
  resetMatrix(childItem) {
    const matrix = calculateMatrix(this.absoluteMatrixInverse, childItem.absoluteMatrix);
    const q = getRotation([], matrix);
    const axis = [];
    const rad = getAxisAngle(axis, q);
    const angle = axis[2] ? radianToDegree(rad * axis[2]) : 0;
    const newTransformMatrix = create$4();
    fromRotation(newTransformMatrix, rad, axis);
    const [x, y] = getTranslation([], calculateMatrix(matrix, calculateMatrixInverse(childItem.getTransformOriginMatrix(), newTransformMatrix, childItem.getTransformOriginMatrixInverse())));
    childItem.reset({ x, y, angle });
    this.manager.setChanged("resetMatrix", this.id, {
      end: true,
      childItemId: childItem == null ? void 0 : childItem.id
    });
  }
  setOrder(targetIndex) {
    var parent = this.parent;
    var startIndex = this.index;
    if (startIndex > -1) {
      parent.children[startIndex] = parent.children[targetIndex];
      parent.children[targetIndex] = this.id;
      this.manager.setChanged("setOrder", this.id, {
        targetIndex,
        startIndex,
        parentId: parent.id
      });
    }
  }
  orderNext() {
    if (this.isLast) {
      if (this.parent.next) {
        let next = this.parent.next;
        if (next.enableHasChildren()) {
          next.appendChild(this);
        } else {
          next.insertAfter(this);
        }
      }
      return;
    }
    var startIndex = this.index;
    if (startIndex > -1) {
      this.setOrder(startIndex + 1);
    }
  }
  orderPrev() {
    if (this.isFirst) {
      const prev = this.parent.prev;
      if (prev) {
        prev.insertBefore(this);
      }
      return;
    }
    var startIndex = this.index;
    if (startIndex > 0) {
      this.setOrder(startIndex - 1);
    }
  }
  orderFirst() {
    this.setOrder(0);
  }
  orderLast() {
    this.setOrder(this.parent.childrenLength - 1);
  }
  orderTop() {
  }
  orderBottom() {
  }
}
const LayoutEngine = {
  [Layout.DEFAULT]: DefaultLayoutEngine,
  [Layout.GRID]: GridLayoutEngine
};
class GroupModel extends MovableModel {
  getDefaultObject(obj2 = {}) {
    return super.getDefaultObject(__spreadValues({
      layout: Layout.DEFAULT,
      constraintsHorizontal: Constraints.NONE,
      constraintsVertical: Constraints.NONE,
      flexDirection: FlexDirection.ROW,
      flexWrap: FlexWrap.NOWRAP,
      justifyContent: JustifyContent.FLEX_START,
      alignItems: AlignItems.FLEX_START,
      alignContent: AlignContent.FLEX_START,
      order: 0,
      flexGrow: 0,
      flexShrink: 0,
      flexBasis: "auto",
      gap: 0,
      resizingHorizontal: ResizingMode.FIXED,
      resizingVertical: ResizingMode.FIXED,
      gridTemplateRows: "auto",
      gridColumnGap: "0px",
      gridTemplateColumns: "auto",
      gridRowGap: "0px",
      gridTemplateAreas: "",
      gridAutoRows: "auto",
      gridAutoColumns: "auto",
      gridAutoFlow: "row"
    }, obj2));
  }
  reset(obj2, context = { origin: "*" }) {
    const isChanged = super.reset(obj2, context);
    if (this.hasChangedField("resizingVertical", "resizingHorizontal", "contraintsVertical", "contraintsHorizontal") || this.changedLayout) {
      this.refreshResizableCache();
    }
    return isChanged;
  }
  refreshResizableCache() {
    this.addCache("resizable", this.getAutoResizable());
  }
  get autoResizable() {
    return this.getCache("resizable");
  }
  getAutoResizable() {
    if (this.parent.is("project")) {
      return false;
    }
    if (this.resizingHorizontal === ResizingMode.FIXED && this.resizingVertical === ResizingMode.FIXED) {
      if (this.constraintsHorizontal === Constraints.NONE && this.constraintsVertical === Constraints.NONE) {
        return false;
      }
    }
    return true;
  }
  get layout() {
    return this.get("layout");
  }
  get constraintsHorizontal() {
    return this.get("constraintsHorizontal");
  }
  set constraintsHorizontal(value) {
    this.reset({
      constraintsHorizontal: value
    });
  }
  get constraintsVertical() {
    return this.get("constraintsVertical");
  }
  set constraintsVertical(value) {
    this.reset({
      constraintsVertical: value
    });
  }
  get flexDirection() {
    return this.get("flexDirection");
  }
  set flexDirection(value) {
    this.reset({
      flexDirection: value
    });
  }
  get flexWrap() {
    return this.get("flexWrap");
  }
  set flexWrap(value) {
    this.reset({
      flexWrap: value
    });
  }
  get justifyContent() {
    return this.get("justifyContent");
  }
  set justifyContent(value) {
    this.reset({
      justifyContent: value
    });
  }
  get alignItems() {
    return this.get("alignItems");
  }
  set alignItems(value) {
    this.reset({
      alignItems: value
    });
  }
  get alignContent() {
    return this.get("alignContent");
  }
  set alignContent(value) {
    this.reset({
      alignContent: value
    });
  }
  get order() {
    return this.get("order");
  }
  set order(value) {
    this.reset({
      order: value
    });
  }
  get flexGrow() {
    return this.get("flexGrow");
  }
  set flexGrow(value) {
    this.reset({
      flexGrow: value
    });
  }
  get flexShrink() {
    return this.get("flexShrink");
  }
  set flexShrink(value) {
    this.reset({
      flexShrink: value
    });
  }
  get flexBasis() {
    return this.get("flexBasis");
  }
  set flexBasis(value) {
    this.reset({
      flexBasis: value
    });
  }
  get gap() {
    return this.get("gap");
  }
  set gap(value) {
    this.reset({
      gap: value
    });
  }
  get resizingHorizontal() {
    return this.get("resizingHorizontal");
  }
  set resizingHorizontal(value) {
    this.reset({
      resizingHorizontal: value
    });
  }
  get resizingVertical() {
    return this.get("resizingVertical");
  }
  set resizingVertical(value) {
    this.reset({
      resizingVertical: value
    });
  }
  get gridTemplateRows() {
    return this.get("gridTemplateRows");
  }
  set gridTemplateRows(value) {
    this.reset({
      gridTemplateRows: value
    });
  }
  get gridColumnGap() {
    return this.get("gridColumnGap");
  }
  set gridColumnGap(value) {
    this.reset({
      gridColumnGap: value
    });
  }
  get gridTemplateColumns() {
    return this.get("gridTemplateColumns");
  }
  set gridTemplateColumns(value) {
    this.reset({
      gridTemplateColumns: value
    });
  }
  get gridRowGap() {
    return this.get("gridRowGap");
  }
  set gridRowGap(value) {
    this.reset({
      gridRowGap: value
    });
  }
  get gridTemplateAreas() {
    return this.get("gridTemplateAreas");
  }
  set gridTemplateAreas(value) {
    this.reset({
      gridTemplateAreas: value
    });
  }
  get gridAutoRows() {
    return this.get("gridAutoRows");
  }
  set gridAutoRows(value) {
    this.reset({
      gridAutoRows: value
    });
  }
  get gridAutoColumns() {
    return this.get("gridAutoColumns");
  }
  set gridAutoColumns(value) {
    this.reset({
      gridAutoColumns: value
    });
  }
  get gridAutoFlow() {
    return this.get("gridAutoFlow");
  }
  set gridAutoFlow(value) {
    this.reset({
      gridAutoFlow: value
    });
  }
  isLayoutItem() {
    var _a;
    return !!((_a = this.parent) == null ? void 0 : _a.hasLayout());
  }
  hasConstraints() {
    return this.isLayout(Layout.DEFAULT);
  }
  hasLayout() {
    return !this.hasConstraints() || Boolean(this.layout) === false;
  }
  isLayout(layout2) {
    return this.layout === layout2;
  }
  isInDefault() {
    var _a;
    const parentLayout = ((_a = this.parent) == null ? void 0 : _a.layout) || "default";
    return Layout.DEFAULT === parentLayout;
  }
  isInGrid() {
    return this.isInLayout(Layout.GRID);
  }
  isInFlex() {
    return this.isInLayout(Layout.FLEX);
  }
  isInLayout(layout2) {
    var _a;
    return ((_a = this.parent) == null ? void 0 : _a.layout) === layout2;
  }
  changeConstraints(direction2, value, shiftKey = false) {
    const h = this.get(direction2);
    let newConstraints = value;
    if (h === Constraints.MAX) {
      if (value === Constraints.MAX) {
        newConstraints = Constraints.SCALE;
      }
      if (shiftKey && value === Constraints.MIN) {
        newConstraints = Constraints.STRETCH;
      }
    } else if (h === Constraints.MIN) {
      if (value === Constraints.MIN) {
        newConstraints = Constraints.SCALE;
      } else if (shiftKey && value === Constraints.MAX) {
        newConstraints = Constraints.STRETCH;
      }
    } else if (h === Constraints.STRETCH) {
      if (value === Constraints.MIN) {
        newConstraints = Constraints.MAX;
      } else if (value === Constraints.MAX) {
        newConstraints = Constraints.MIN;
      }
    }
    this.reset({
      [direction2]: newConstraints
    });
  }
  startToCacheChildren() {
    var _a;
    (_a = LayoutEngine[this.layout]) == null ? void 0 : _a.startCache(this);
  }
  recoverChildren() {
    var _a;
    (_a = LayoutEngine[this.layout]) == null ? void 0 : _a.recover(this);
  }
}
const editableList = [
  "appearance",
  "position",
  "right",
  "bottom",
  "rootVariable",
  "variable",
  "transform",
  "filter",
  "backdropFilter",
  "backgroundColor",
  "backgroundImage",
  "borderRadius",
  "border",
  "boxShadow",
  "clipPath",
  "color",
  "perspectiveOrigin",
  "transformOrigin",
  "transformStyle",
  "perspective",
  "mixBlendMode",
  "overflow",
  "opacity",
  "box-model",
  "layout",
  "flex-layout",
  "grid-layout",
  "animation",
  "transition",
  "pattern",
  "boolean-operation"
];
const editableKeys = {};
editableList.forEach(function(key) {
  editableKeys[key] = true;
});
class DomModel extends GroupModel {
  getDefaultObject(obj2 = {}) {
    return super.getDefaultObject(__spreadValues({
      rootVariable: "",
      variable: "",
      color: "black",
      overflow: "visible",
      opacity: 1,
      pattern: "",
      selectors: [],
      svg: [],
      filter: [],
      backdropFilter: [],
      gridColumnStart: "",
      gridColumnEnd: "",
      gridRowStart: "",
      gridRowEnd: "",
      gridColumnGap: "",
      gridRowGap: ""
    }, obj2));
  }
  get gridColumnStart() {
    return this.get("gridColumnStart");
  }
  set gridColumnStart(value) {
    this.set("gridColumnStart", value);
  }
  get gridColumnEnd() {
    return this.get("gridColumnEnd");
  }
  set gridColumnEnd(value) {
    this.set("gridColumnEnd", value);
  }
  get gridRowStart() {
    return this.get("gridRowStart");
  }
  set gridRowStart(value) {
    this.set("gridRowStart", value);
  }
  get gridRowEnd() {
    return this.get("gridRowEnd");
  }
  set gridRowEnd(value) {
    this.set("gridRowEnd", value);
  }
  get gridColumnGap() {
    return this.get("gridColumnGap");
  }
  set gridColumnGap(value) {
    this.set("gridColumnGap", value);
  }
  get gridRowGap() {
    return this.get("gridRowGap");
  }
  set gridRowGap(value) {
    this.set("gridRowGap", value);
  }
  get pattern() {
    return this.get("pattern");
  }
  set pattern(value) {
    this.reset({
      pattern: value
    });
  }
  get selectors() {
    return this.get("selectors");
  }
  set selectors(value) {
    this.reset({
      selectors: value
    });
  }
  get svg() {
    return this.get("svg");
  }
  set svg(value) {
    this.reset({ svg: value });
  }
  get rootVariable() {
    return this.get("rootVariable");
  }
  set rootVariable(value) {
    this.reset({
      rootVariable: value
    });
  }
  get variable() {
    return this.get("variable");
  }
  set variable(value) {
    this.reset({
      variable: value
    });
  }
  get filter() {
    return this.get("filter");
  }
  set filter(value) {
    this.reset({
      filter: value
    });
  }
  get backdropFilter() {
    return this.get("backdropFilter");
  }
  set backdropFilter(value) {
    this.reset({
      backdropFilter: value
    });
  }
  get backgroundColor() {
    return this.get("backgroundColor");
  }
  set backgroundColor(value) {
    this.reset({
      backgroundColor: value
    });
  }
  get backgroundImage() {
    return this.get("backgroundImage");
  }
  set backgroundImage(value) {
    this.reset({
      backgroundImage: value
    });
  }
  get textClip() {
    return this.get("textClip");
  }
  set textClip(value) {
    this.reset({
      textClip: value
    });
  }
  get borderRadius() {
    return this.get("borderRadius");
  }
  set borderRadius(value) {
    this.reset({
      borderRadius: value
    });
  }
  get border() {
    return this.get("border");
  }
  set border(value) {
    this.reset({
      border: value
    });
  }
  get boxShadow() {
    return this.get("boxShadow");
  }
  set boxShadow(value) {
    this.reset({
      boxShadow: value
    });
  }
  get textShadow() {
    return this.get("textShadow");
  }
  set textShadow(value) {
    this.reset({
      textShadow: value
    });
  }
  get clipPath() {
    return this.get("clipPath");
  }
  set clipPath(value) {
    this.reset({
      clipPath: value
    });
  }
  get color() {
    return this.get("color");
  }
  set color(value) {
    this.reset({
      color: value
    });
  }
  get opacity() {
    return this.get("opacity");
  }
  set opacity(value) {
    this.reset({
      opacity: value
    });
  }
  get transformStyle() {
    return this.get("transformStyle");
  }
  set transformStyle(value) {
    this.reset({
      transformStyle: value
    });
  }
  get fontSize() {
    return this.get("fontSize");
  }
  set fontSize(value) {
    this.reset({
      fontSize: value
    });
  }
  get fontFamily() {
    return this.get("fontFamily");
  }
  set fontFamily(value) {
    this.reset({
      fontFamily: value
    });
  }
  get fontWeight() {
    return this.get("fontWeight");
  }
  set fontWeight(value) {
    this.reset({
      fontWeight: value
    });
  }
  get fontStyle() {
    return this.get("fontStyle");
  }
  set fontStyle(value) {
    this.reset({
      fontStyle: value
    });
  }
  get fontVariant() {
    return this.get("fontVariant");
  }
  set fontVariant(value) {
    this.reset({
      fontVariant: value
    });
  }
  get fontStretch() {
    return this.get("fontStretch");
  }
  set fontStretch(value) {
    this.reset({
      fontStretch: value
    });
  }
  get lineHeight() {
    return this.get("lineHeight");
  }
  set lineHeight(value) {
    this.reset({
      lineHeight: value
    });
  }
  get letterSpacing() {
    return this.get("letterSpacing");
  }
  set letterSpacing(value) {
    this.reset({
      letterSpacing: value
    });
  }
  get wordSpacing() {
    return this.get("wordSpacing");
  }
  set wordSpacing(value) {
    this.reset({
      wordSpacing: value
    });
  }
  get textDecoration() {
    return this.get("textDecoration");
  }
  set textDecoration(value) {
    this.reset({
      textDecoration: value
    });
  }
  get textAlign() {
    return this.get("textAlign");
  }
  set textAlign(value) {
    this.reset({
      textAlign: value
    });
  }
  get textTransform() {
    return this.get("textTransform");
  }
  set textTransform(value) {
    this.reset({
      textTransform: value
    });
  }
  get textOverflow() {
    return this.get("text-overflow");
  }
  set textOverflow(value) {
    this.reset({
      "text-overflow": value
    });
  }
  get textIndent() {
    return this.get("textIndent");
  }
  set textIndent(value) {
    this.reset({
      textIndent: value
    });
  }
  get mixBlendMode() {
    return this.get("mixBlendMode");
  }
  set mixBlendMode(value) {
    this.reset({
      mixBlendMode: value
    });
  }
  get visibility() {
    return this.get("visibility");
  }
  set visibility(value) {
    this.reset({
      visibility: value
    });
  }
  get zIndex() {
    return this.get("z-index");
  }
  set zIndex(value) {
    this.reset({
      "z-index": value
    });
  }
  get overflow() {
    return this.get("overflow");
  }
  set overflow(value) {
    this.reset({
      overflow: value
    });
  }
  get animation() {
    return this.get("animation");
  }
  set animation(value) {
    this.reset({
      animation: value
    });
  }
  get transition() {
    return this.get("transition");
  }
  set transition(value) {
    this.reset({
      transition: value
    });
  }
  get marginTop() {
    return this.get("marginTop");
  }
  set marginTop(value) {
    this.reset({
      marginTop: value
    });
  }
  get marginRight() {
    return this.get("marginRight");
  }
  set marginRight(value) {
    this.reset({
      marginRight: value
    });
  }
  get marginBottom() {
    return this.get("marginBottom");
  }
  set marginBottom(value) {
    this.reset({
      marginBottom: value
    });
  }
  get marginLeft() {
    return this.get("marginLeft");
  }
  set marginLeft(value) {
    this.reset({
      marginLeft: value
    });
  }
  get paddingTop() {
    return this.get("paddingTop");
  }
  set paddingTop(value) {
    this.reset({
      paddingTop: value
    });
  }
  get paddingRight() {
    return this.get("paddingRight");
  }
  set paddingRight(value) {
    this.reset({
      paddingRight: value
    });
  }
  get paddingBottom() {
    return this.get("paddingBottom");
  }
  set paddingBottom(value) {
    this.reset({
      paddingBottom: value
    });
  }
  get paddingLeft() {
    return this.get("paddingLeft");
  }
  set paddingLeft(value) {
    this.reset({
      paddingLeft: value
    });
  }
  editable(editablePropertyName) {
    switch (editablePropertyName) {
      case "svg-item":
      case "transformOrigin":
      case "perspective":
      case "perspectiveOrigin":
        return false;
    }
    return Boolean(editableKeys[editablePropertyName]);
  }
  get changedBoxModel() {
    return this.hasChangedField("marginTop", "marginLeft", "marginBottom", "marginRight", "paddingTop", "paddingLeft", "paddingRight", "paddingBottom");
  }
  get changedFlexLayout() {
    return this.hasChangedField("flexDirection", "flexWrap", "justifyContent", "alignItems", "alignContent", "order", "flexBasis", "flexGrow", "flexShrink", "flexFlow");
  }
  get changedGridLayout() {
    return this.hasChangedField("gridTemplateRows", "gridTemplateColumns", "gridTemplateAreas", "gridAutoRows", "gridAutoColumns", "gridAutoFlow", "gridRowGap", "gridColumnGap", "gridRowStart", "gridRowEnd", "gridColumnStart", "gridColumnEnd", "gridArea");
  }
  get changedLayoutItem() {
    return this.hasChangedField("resizingHorizontal", "resizingVertical");
  }
  get changedLayout() {
    return this.hasChangedField("layout") || this.changedBoxModel || this.changedFlexLayout || this.changedGridLayout || this.changedLayoutItem;
  }
  addSelector(selector2) {
    this.selectors.push(selector2);
    return selector2;
  }
  createSelector(data = {}) {
    return this.addSelector(new Selector(__spreadValues({
      checked: true
    }, data)));
  }
  removePropertyList(arr, removeIndex) {
    arr.splice(removeIndex, 1);
  }
  removeSelector(removeIndex) {
    this.removePropertyList(this.selectors, removeIndex);
  }
  enableHasChildren() {
    return true;
  }
  sortItem(arr, startIndex, targetIndex) {
    arr.splice(targetIndex + (startIndex < targetIndex ? -1 : 0), 0, ...arr.splice(startIndex, 1));
  }
  updateSelector(index2, data = {}) {
    this.selectors[+index2].reset(data);
  }
  traverse(item, results, hasLayoutItem) {
    if (item.isAttribute())
      return;
    if (!hasLayoutItem && item.isLayoutItem() && !item.isRootItem())
      return;
    results.push(item);
    item.children.forEach((child) => {
      this.traverse(child, results);
    });
  }
  tree(hasLayoutItem) {
    var results = [];
    this.children.forEach((item) => {
      this.traverse(item, results, hasLayoutItem);
    });
    return results;
  }
  convert(json) {
    json = super.convert(json);
    if (json.padding) {
      json["paddingTop"] = Length.parse(json.padding);
      json["paddingRight"] = Length.parse(json.padding);
      json["paddingBottom"] = Length.parse(json.padding);
      json["paddingLeft"] = Length.parse(json.padding);
      delete json.padding;
    }
    return json;
  }
  reset(obj2, context = { origin: "*" }) {
    const isChanged = super.reset(obj2, context);
    if (this.hasChangedField("clipPath")) {
      this.setClipPathCache();
    }
    if (this.hasChangedField("width", "height")) {
      if (this.cacheClipPath) {
        const d = this.cacheClipPath.clone().scale(this.width / this.cacheClipPathWidth, this.height / this.cacheClipPathHeight).d;
        this.clipPath = `path(${d})`;
        this.modelManager.setChanged("reset", this.id, {
          clipPath: this.clipPath
        });
      }
    }
    if (this.hasChangedField("backgroundImage", "pattern")) {
      this.setBackgroundImageCache();
    }
    return isChanged;
  }
  setBackgroundImageCache() {
    let list2 = [];
    if (this.pattern) {
      const patternList = this.computed("pattern", (pattern) => {
        return Pattern.parseStyle(pattern).map((it) => {
          return BackgroundImage.parseStyle(STRING_TO_CSS(it.toCSS()));
        });
      });
      for (var i = 0, len2 = patternList.length; i < len2; i++) {
        list2.push.apply(list2, patternList[i]);
      }
    }
    if (this.backgroundImage) {
      const backgroundList = this.computed("backgroundImage", (backgroundImage2) => {
        return BackgroundImage.parseStyle(STRING_TO_CSS(backgroundImage2));
      });
      list2.push.apply(list2, backgroundList.filter((it) => it.visibility !== VisibilityType.HIDDEN));
    }
    if (list2.length) {
      const project2 = this.top;
      this.cacheBackgroundImage = BackgroundImage.joinCSS(list2);
      const cacheList = list2.filter((it) => it.type === GradientType.URL).map((it) => it.image.url);
      let cacheImage = this.cacheBackgroundImage["background-image"];
      cacheList.forEach((url) => {
        const imageUrl = project2.getImageValueById(url);
        cacheImage = cacheImage.replace(url, `"${imageUrl}"`);
      });
      this.cacheBackgroundImage["background-image"] = cacheImage;
    } else {
      this.cacheBackgroundImage = {};
      this.cacheBackgroundImageOriginal = [];
    }
  }
  setClipPathCache() {
    var obj2 = ClipPath.parseStyle(this.clipPath);
    this.cacheClipPathObject = obj2;
    if (obj2.type === "path") {
      this.cacheClipPath = new PathParser(obj2.value.trim());
      this.cacheClipPathWidth = this.width;
      this.cacheClipPathHeight = this.height;
    }
  }
  setCache() {
    super.setCache();
    this.setClipPathCache();
  }
  get clipPathString() {
    if (!this.cacheClipPath) {
      this.setClipPathCache();
    }
    if (this.cacheClipPath) {
      return this.cacheClipPath.clone().scale(this.width / this.cacheClipPathWidth, this.height / this.cacheClipPathHeight).d;
    }
  }
  getBackgroundImage(index2) {
    const backgroundImages = BackgroundImage.parseStyle(STRING_TO_CSS(this.backgroundImage));
    return backgroundImages[index2 || 0];
  }
  get borderWidth() {
    const border2 = Border.parseStyle(this.border);
    const borderObject = Border.parseValue(border2.border);
    if (borderObject == null ? void 0 : borderObject.width) {
      return {
        borderLeftWidth: borderObject == null ? void 0 : borderObject.width,
        borderRightWidth: borderObject == null ? void 0 : borderObject.width,
        borderTopWidth: borderObject == null ? void 0 : borderObject.width,
        borderBottomWidth: borderObject == null ? void 0 : borderObject.width
      };
    }
    return {
      borderLeftWidth: 0,
      borderRightWidth: 0,
      borderTopWidth: 0,
      borderBottomWidth: 0
    };
  }
  get contentBox() {
    const x = 0;
    const y = 0;
    const width2 = this.screenWidth;
    const height2 = this.screenHeight;
    {
      const borderWidth = this.borderWidth;
      return {
        x: x + borderWidth.borderLeftWidth,
        y: y + borderWidth.borderTopWidth,
        width: width2 - borderWidth.borderLeftWidth - borderWidth.borderRightWidth,
        height: height2 - borderWidth.borderTopWidth - borderWidth.borderBottomWidth
      };
    }
  }
  getGradientLineLength(width2, height2, angle) {
    return Math.abs(width2 * Math.sin(degreeToRadian(angle))) + Math.abs(height2 * Math.cos(degreeToRadian(angle)));
  }
  createBackgroundImageMatrix(index2) {
    const contentBox = this.contentBox;
    const backgroundImage2 = this.getBackgroundImage(index2);
    const { image: image2 } = backgroundImage2;
    const backRect = backgroundImage2.getOffset(contentBox);
    const backVerties = vertiesMap(rectToVerties(backRect.x, backRect.y, backRect.width, backRect.height), this.absoluteMatrix);
    const result = {
      backRect,
      backVerties,
      absoluteMatrix: this.absoluteMatrix,
      backgroundImage: backgroundImage2
    };
    switch (image2.type) {
      case GradientType.RADIAL:
      case GradientType.REPEATING_RADIAL:
      case GradientType.CONIC:
      case GradientType.REPEATING_CONIC:
        let [rx, ry] = image2.radialPosition;
        if (rx == "center")
          rx = Length.percent(50);
        if (ry == "center")
          ry = Length.percent(50);
        const newRx = rx.toPx(backRect.width);
        const newRy = ry.toPx(backRect.height);
        const centerVerties = vertiesMap([
          [newRx.value + backRect.x, newRy.value + backRect.y, 0],
          [newRx.value + backRect.x, newRy.value + backRect.y - 1, 0]
        ], this.absoluteMatrix);
        result.radialCenterPosition = centerVerties[0];
        result.radialCenterStick = centerVerties[1];
        result.radialCenterPoint = [newRx.value, newRy.value, 0];
        if (image2.type === GradientType.RADIAL || image2.type === GradientType.REPEATING_RADIAL) {
          const { startPoint: startPoint2, endPoint: endPoint2, shapePoint } = image2.getStartEndPoint(result);
          const [newStartPoint2, newEndPoint2, newShapePoint] = vertiesMap([startPoint2, endPoint2, shapePoint], this.absoluteMatrix);
          result.radialCenterPosition = newStartPoint2;
          result.startPoint = newStartPoint2;
          result.endPoint = newEndPoint2;
          result.shapePoint = newShapePoint;
          result.colorsteps = image2.colorsteps.map((it) => {
            const offset = it.toLength();
            return {
              id: it.id,
              cut: it.cut,
              color: it.color,
              timing: it.timing,
              timingCount: it.timingCount,
              pos: lerp([], result.startPoint, result.endPoint, offset.value / 100)
            };
          });
        } else if (image2.type === GradientType.CONIC || image2.type === GradientType.REPEATING_CONIC) {
          const { startPoint: startPoint2, endPoint: endPoint2, shapePoint } = image2.getStartEndPoint(result);
          const [newStartPoint2, newEndPoint2, newShapePoint] = vertiesMap([startPoint2, endPoint2, shapePoint], this.absoluteMatrix);
          result.radialCenterPosition = newStartPoint2;
          result.startPoint = newStartPoint2;
          result.endPoint = newEndPoint2;
          result.shapePoint = newShapePoint;
          [result.startPoint, result.endPoint, result.shapePoint] = vertiesMap([result.startPoint, result.endPoint, result.shapePoint], calculateRotationOriginMat4(image2.angle, result.radialCenterPosition));
          const targetPoint = result.shapePoint;
          result.colorsteps = image2.colorsteps.map((it) => {
            const angle = it.percent * 3.6;
            const [newPos] = vertiesMap([targetPoint], calculateRotationOriginMat4(angle, result.radialCenterPosition));
            return {
              id: it.id,
              cut: it.cut,
              color: it.color,
              timing: it.timing,
              timingCount: it.timingCount,
              pos: newPos
            };
          });
        }
        break;
      case GradientType.LINEAR:
      case GradientType.REPEATING_LINEAR:
        result.gradientLineLength = this.getGradientLineLength(backRect.width, backRect.height, image2.angle);
        result.centerPosition = lerp([], backVerties[0], backVerties[2], 0.5);
        const startPoint = add$1([], result.centerPosition, [
          0,
          result.gradientLineLength / 2,
          0
        ]);
        const endPoint = subtract([], result.centerPosition, [
          0,
          result.gradientLineLength / 2,
          0
        ]);
        const areaStartPoint = clone(startPoint);
        const areaEndPoint = clone(endPoint);
        const [newStartPoint, newEndPoint, newAreaStartPoint, newAreaEndPoint] = vertiesMap([startPoint, endPoint, areaStartPoint, areaEndPoint], calculateRotationOriginMat4(image2.angle, result.centerPosition));
        result.endPoint = newEndPoint;
        result.startPoint = newStartPoint;
        result.areaStartPoint = newAreaStartPoint;
        result.areaEndPoint = newAreaEndPoint;
        result.colorsteps = image2.colorsteps.map((it) => {
          const offset = it.toLength();
          return {
            id: it.id,
            cut: it.cut,
            color: it.color,
            timing: it.timing,
            timingCount: it.timingCount,
            pos: lerp([], result.startPoint, result.endPoint, offset.value / 100)
          };
        });
        break;
    }
    return result;
  }
}
class LayerModel extends DomModel {
  getDefaultObject(obj2 = {}) {
    return super.getDefaultObject(__spreadValues({
      itemType: "layer",
      name: "New Layer",
      tagName: "div"
    }, obj2));
  }
  getDefaultTitle() {
    return "Layer";
  }
}
class ArtBoard extends LayerModel {
  getDefaultObject(obj2 = {}) {
    return super.getDefaultObject(__spreadValues({
      itemType: "artboard",
      name: "New ArtBoard",
      width: 1e3,
      height: 1e3,
      backgroundColor: "white",
      transformStyle: "flat"
    }, obj2));
  }
  getDefaultTitle() {
    return "ArtBoard";
  }
  getIcon() {
    return obj$2.artboard;
  }
  editable(editablePropertyName) {
    switch (editablePropertyName) {
      case "border":
      case "borderRadius":
        return false;
      case "artboardSize":
      case "layout":
        return true;
    }
    return super.editable(editablePropertyName);
  }
}
const IMAGE_LIST = ["jpg", "jpeg", "png", "gif", "svg"];
class SVGImageResource extends ImageResource {
  getDefaultObject(obj2 = {}) {
    return super.getDefaultObject(__spreadValues({
      type: "url",
      url: "",
      datauri: "",
      patternUnits: "userSpaceOnUse",
      patternWidth: "100%",
      patternHeight: "100%",
      imageX: "0%",
      imageY: "0%",
      imageWidth: "100%",
      imageHeight: "100%"
    }, obj2));
  }
  toCloneObject() {
    return __spreadValues(__spreadValues({}, super.toCloneObject()), this.attrs("url", "datauri", "patternUnits", "patternWidth", "patternHeight", "imageX", "imageY", "imageWidth", "imageHeight"));
  }
  static parse(str) {
    var content2 = str.split("(")[1].split(")")[0];
    var [url, props] = content2.trim().split("#");
    if (!props) {
      return new SVGImageResource({ url });
    }
    var [
      patternUnits,
      patternWidth,
      patternHeight,
      imageX,
      imageY,
      imageWidth,
      imageHeight
    ] = props.split(",");
    return new SVGImageResource({
      patternUnits,
      patternWidth,
      patternHeight,
      imageX,
      imageY,
      imageWidth,
      imageHeight,
      url
    });
  }
  isUrl() {
    return true;
  }
  static isImageFile(fileExt) {
    return IMAGE_LIST.includes(fileExt);
  }
  toString() {
    var json = this.json;
    var {
      patternUnits,
      patternWidth,
      patternHeight,
      imageX,
      imageY,
      imageWidth,
      imageHeight,
      url
    } = json;
    var string = [
      patternUnits,
      patternWidth,
      patternHeight,
      imageX,
      imageY,
      imageWidth,
      imageHeight
    ].join(",").trim();
    return `url(${url}#${string})`;
  }
  toSVGString(id, item = {}) {
    var {
      patternUnits,
      patternWidth,
      patternHeight,
      imageX,
      imageY,
      imageWidth,
      imageHeight
    } = this.json;
    const localPatternWidth = Length.parse(patternWidth);
    const localPatternHeight = Length.parse(patternHeight);
    const localImageX = Length.parse(imageX);
    const localImageY = Length.parse(imageY);
    const localImageWidth = Length.parse(imageWidth);
    const localImageHeight = Length.parse(imageHeight);
    const width2 = item.width ? localPatternWidth.toPx(item.width).value : localPatternWidth;
    const height2 = item.height ? localPatternHeight.toPx(item.height).value : localPatternHeight;
    return `
  <pattern ${OBJECT_TO_PROPERTY({ id, patternUnits, width: width2, height: height2 })} >
    <image xlink:href="${this.json.datauri || this.json.url}" ${OBJECT_TO_PROPERTY({
      x: localImageX.toPx(item.width).value,
      y: localImageY.toPx(item.height).value,
      width: localImageWidth.toPx(item.width).value,
      height: localImageHeight.toPx(item.height).value,
      preserveAspectRatio: "none"
    })} />
  </pattern>
      `;
  }
  toFillValue(id) {
    return `url(#${id})`;
  }
}
class SVGGradient extends Gradient {
  toString() {
    return "";
  }
  toSVGString() {
    return "";
  }
  toFillValue() {
    return "";
  }
}
const SpreadMethodList$1 = [
  SpreadMethodType.PAD,
  SpreadMethodType.REFLECT,
  SpreadMethodType.REPEAT
];
class SVGLinearGradient extends SVGGradient {
  convert(json) {
    json.spreadMethod = SpreadMethodList$1.includes(json.spreadMethod) ? json.spreadMethod : SpreadMethodType.PAD;
    return json;
  }
  getDefaultObject(obj2) {
    return super.getDefaultObject(__spreadValues({
      type: GradientType.LINEAR,
      x1: Length.parse("0%"),
      y1: Length.parse("50%"),
      x2: Length.parse("100%"),
      y2: Length.parse("50%"),
      spreadMethod: SpreadMethodType.PAD
    }, obj2));
  }
  toCloneObject() {
    return __spreadValues(__spreadValues({}, super.toCloneObject()), this.attrs("x1", "y1", "x2", "y2", "spreadMethod"));
  }
  toString() {
    if (this.colorsteps.length === 0)
      return "";
    var colorString = this.getColorString();
    var { x1, y1, x2, y2, spreadMethod } = this.json;
    var opt = [x1, y1, x2, y2, spreadMethod].join(" ");
    var result = `${this.json.type}(${opt}, ${colorString})`;
    return result;
  }
  toSVGString(id) {
    var { x1, y1, x2, y2, spreadMethod } = this.json;
    return `
      <linearGradient 
        id="${id}"
        x1="${x1}"
        x2="${x2}"
        y1="${y1}"
        y2="${y2}"
        spreadMethod="${spreadMethod}"
      >
        ${SVGLinearGradient.makeColorStepList(this.colorsteps).map((it) => `
        <stop offset="${it.percent}%" stop-color="${it.color}"/>
      `).join("")}
      </linearGradient>
    `;
  }
  toFillValue(id) {
    return `url(#${id})`;
  }
  static parse(str) {
    const result = parseOneValue(str);
    var opt = {};
    const [options2, ...colors2] = result.parameters;
    const list2 = [];
    options2.forEach((it) => {
      if (it.func === FuncType.KEYWORD) {
        if (SpreadMethodList$1.includes(it.matchedString)) {
          opt.spreadMethod = it.matchedString;
        }
      } else {
        list2.push(it);
      }
    });
    var [
      x1 = Length.percent(0),
      y1 = Length.percent(50),
      x2 = Length.percent(100),
      y2 = Length.percent(50)
    ] = list2.map((it) => it.parsed);
    opt = __spreadProps(__spreadValues({}, opt), {
      x1,
      y1,
      x2,
      y2
    });
    const colorsteps = SVGLinearGradient.parseColorSteps(colors2);
    return new SVGLinearGradient(__spreadProps(__spreadValues({}, opt), { colorsteps }));
  }
}
const RadialTypeList = [RadialGradientType.CIRCLE, RadialGradientType.ELLIPSE];
const SpreadMethodList = [
  SpreadMethodType.PAD,
  SpreadMethodType.REFLECT,
  SpreadMethodType.REPEAT
];
class SVGRadialGradient extends SVGGradient {
  convert(json) {
    json.spreadMethod = SpreadMethodList.includes(json.spreadMethod) ? json.spreadMethod : SpreadMethodType.PAD;
    return json;
  }
  getDefaultObject(obj2 = {}) {
    return super.getDefaultObject(__spreadValues({
      type: GradientType.RADIAL,
      radialType: RadialGradientType.CIRCLE,
      x1: Length.parse("50%"),
      y1: Length.parse("50%"),
      x2: Length.parse("100%"),
      y2: Length.parse("50%"),
      x3: Length.parse("50%"),
      y3: Length.parse("100%"),
      spreadMethod: SpreadMethodType.PAD
    }, obj2));
  }
  toCloneObject() {
    return __spreadValues(__spreadValues({}, super.toCloneObject()), this.attrs("radialType", "x1", "y1", "x2", "y2", "x3", "y3", "spreadMethod"));
  }
  toString() {
    if (this.colorsteps.length === 0)
      return "";
    var colorString = this.getColorString();
    var { radialType, x1, y1, x2, y2, x3, y3, spreadMethod } = this.json;
    var opt = [radialType, x1, y1, x2, y2, x3, y3, spreadMethod].join(" ").trim();
    var result = `${this.json.type}(${opt}, ${colorString})`;
    return result;
  }
  getGradientAngle(contentBox = {}) {
    var { x1, y1, x2, y2 } = this.json;
    const newX1 = x1.toPx(contentBox.width);
    const newY1 = y1.toPx(contentBox.height);
    const newX2 = x2.toPx(contentBox.width);
    const newY2 = y2.toPx(contentBox.height);
    const angle = calculateAngle360(newX2.value - newX1.value, newY2.value - newY1.value) + 180;
    return angle % 360;
  }
  toSVGString(id, contentBox = {}) {
    var {
      x1: cx,
      y1: cy,
      x2,
      y2,
      x3,
      y3,
      spreadMethod,
      radialType
    } = this.json;
    const newX1 = cx.toPx(contentBox.width);
    const newY1 = cy.toPx(contentBox.height);
    const newX2 = x2.toPx(contentBox.width);
    const newY2 = y2.toPx(contentBox.height);
    var dist$1 = dist([newX1.value, newY1.value, 0], [newX2.value, newY2.value, 0]);
    var angle = this.getGradientAngle(contentBox);
    const view = create$5();
    multiply$2(view, view, fromTranslation$1([], [newX1.value, newY1.value]));
    multiply$2(view, view, fromRotation$1([], degreeToRadian(angle)));
    if (radialType === RadialGradientType.ELLIPSE) {
      const newX3 = x3.toPx(contentBox.width);
      const newY3 = y3.toPx(contentBox.height);
      var dist2 = dist([newX1.value, newY1.value, 0], [newX3.value, newY3.value, 0]);
      multiply$2(view, view, fromScaling$1([], [1, dist2 / dist$1]));
    }
    const gradientTransform = `matrix(${view[0]}, ${view[1]}, ${view[3]}, ${view[4]}, ${view[6]}, ${view[7]})`;
    return `
<radialGradient ${OBJECT_TO_PROPERTY({
      id,
      cx: 0,
      cy: 0,
      r: dist$1,
      spreadMethod,
      gradientUnits: "userSpaceOnUse",
      gradientTransform
    })} >
    ${SVGRadialGradient.makeColorStepList(this.colorsteps).map((it) => `
      <stop offset="${it.percent}%" stop-color="${it.color}"/>
    `).join("")}
</radialGradient>
`;
  }
  toFillValue(id) {
    return `url(#${id})`;
  }
  static parse(str) {
    const result = parseOneValue(str);
    var opt = {};
    const [options2, ...colors2] = result.parameters;
    const list2 = [];
    options2.forEach((it) => {
      if (it.func === FuncType.KEYWORD) {
        if (RadialTypeList.includes(it.matchedString)) {
          opt.radialType = it.matchedString;
        } else if (SpreadMethodList.includes(it.matchedString)) {
          opt.spreadMethod = it.matchedString;
        }
      } else {
        list2.push(it);
      }
    });
    var [
      x1 = Length.percent(50),
      y1 = Length.percent(50),
      x2 = Length.percent(100),
      y2 = Length.percent(50),
      x3 = Length.percent(50),
      y3 = Length.percent(100)
    ] = list2.map((it) => it.parsed);
    opt = __spreadProps(__spreadValues({}, opt), {
      x1,
      y1,
      x2,
      y2,
      x3,
      y3
    });
    const colorsteps = SVGRadialGradient.parseColorSteps(colors2);
    return new SVGRadialGradient(__spreadProps(__spreadValues({}, opt), { colorsteps }));
  }
}
class SVGStaticGradient extends SVGGradient {
  getDefaultObject() {
    return super.getDefaultObject({
      type: "static-gradient",
      colorsteps: [
        new ColorStep({ color: "red", percent: 0, index: 0 }),
        new ColorStep({ color: "red", percent: 100, index: 1 })
      ]
    });
  }
  toCloneObject() {
    return __spreadProps(__spreadValues({}, super.toCloneObject()), {
      static: true
    });
  }
  static create(color2 = "transparent") {
    return new SVGStaticGradient({
      colorsteps: [
        new ColorStep({ color: color2, percent: 0, index: 0 }),
        new ColorStep({ color: color2, percent: 100, index: 0 })
      ]
    });
  }
  setColor(color2) {
    this.colorsteps.forEach((it) => {
      it.color = color2;
    });
  }
  toString() {
    var color2 = this.json.colorsteps[0].color;
    return color2;
  }
  toSVGString() {
    return "";
  }
  toFillValue() {
    return this.toString();
  }
}
class SVGFill extends PropertyItem {
  addImageResource(imageResource) {
    this.clear("image-resource");
    return this.addItem("image-resource", imageResource);
  }
  addGradient(gradient2) {
    return this.addImageResource(gradient2);
  }
  setImageUrl(data) {
    if (!data.images)
      return;
    if (!data.images.length)
      return;
    this.reset({
      type: "image",
      image: SVGFill.createImage(data.images[0])
    });
  }
  static createImage(url) {
    return new SVGLImageResource({ url });
  }
  setGradient(data) {
    this.reset({
      type: data.type,
      image: SVGFill.createGradient(data, this.json.image)
    });
  }
  static createGradient(data, gradient2) {
    const colorsteps = data.colorsteps || gradient2.colorsteps;
    let json = gradient2.toJSON();
    delete json.itemType;
    delete json.type;
    switch (data.type) {
      case GradientType.LINEAR:
        return new SVGLinearGradient(__spreadProps(__spreadValues({}, json), { colorsteps }));
      case GradientType.RADIAL:
        return new SVGRadialGradient(__spreadProps(__spreadValues({}, json), { colorsteps }));
      default:
        return new SVGStaticGradient(__spreadProps(__spreadValues({}, json), { colorsteps }));
    }
  }
  get image() {
    return this.json.image;
  }
  set image(image2) {
    this.json.image = image2;
  }
  static parse(obj2) {
    return new SVGFill(obj2);
  }
  static parseImage(str = "") {
    const result = parseOneValue(str);
    let image2 = null;
    if (!result) {
      return SVGStaticGradient.create(str || "transparent");
    }
    switch (result.func) {
      case GradientType.LINEAR:
        image2 = SVGLinearGradient.parse(result.matchedString);
        break;
      case GradientType.RADIAL:
        image2 = SVGRadialGradient.parse(result.matchedString);
        break;
      case GradientType.URL:
        image2 = SVGImageResource.parse(result.matchedString);
        break;
      default:
        image2 = SVGStaticGradient.create(result.matchedString);
        break;
    }
    return image2;
  }
  static changeImageType(options2) {
    switch (options2.type) {
      case GradientType.LINEAR:
        return new SVGLinearGradient(options2);
      case GradientType.RADIAL:
        return new SVGRadialGradient(options2);
      case "image-resource":
      case GradientType.URL:
        return new SVGImageResource(options2);
      default:
        return new SVGStaticGradient(options2);
    }
  }
}
const expectedProperties = [
  "appearance",
  "border",
  "borderRadius",
  "backgroundImage",
  "backdropFilter",
  "clipPath",
  "pattern",
  "boxShadow",
  "layout",
  "transform",
  "transformOrigin",
  "perspective",
  "perspectiveOrigin",
  "backdropFilter",
  "boxModel"
];
const expectedPropertiesKeys = {};
expectedProperties.forEach((key) => {
  expectedPropertiesKeys[key] = true;
});
class SVGModel extends LayerModel {
  getDefaultObject(obj2 = {}) {
    return super.getDefaultObject(__spreadValues({
      itemType: "svg",
      name: "New SVG",
      elementType: "svg",
      overflow: "visible",
      stroke: "black",
      strokeWidth: 1,
      fill: "transparent",
      fillOpacity: 1,
      fillRule: "nonzero",
      textAnchor: "start",
      strokeLinecap: "",
      strokeLinejoin: "",
      strokeDasharray: [],
      strokeDashoffset: 0
    }, obj2));
  }
  get stroke() {
    return this.get("stroke");
  }
  set stroke(value) {
    this.set("stroke", value);
  }
  get strokeWidth() {
    return this.get("strokeWidth");
  }
  set strokeWidth(value) {
    this.set("strokeWidth", value);
  }
  get fill() {
    return this.get("fill");
  }
  set fill(value) {
    this.set("fill", value);
  }
  get fillOpacity() {
    return this.get("fillOpacity");
  }
  set fillOpacity(value) {
    this.set("fillOpacity", value);
  }
  get fillRule() {
    return this.get("fillRule");
  }
  set fillRule(value) {
    this.set("fillRule", value);
  }
  get textAnchor() {
    return this.get("textAnchor");
  }
  set textAnchor(value) {
    this.set("textAnchor", value);
  }
  get strokeDasharray() {
    return this.get("strokeDasharray");
  }
  set strokeDasharray(value) {
    this.set("strokeDasharray", value);
  }
  get strokeDashoffset() {
    return this.get("strokeDashoffset");
  }
  set strokeDashoffset(value) {
    this.set("strokeDashoffset", value);
  }
  get strokeLinejoin() {
    return this.get("strokeLinejoin");
  }
  set strokeLinejoin(value) {
    this.set("strokeLinejoin", value);
  }
  get strokeLinecap() {
    return this.get("strokeLinecap");
  }
  set strokeLinecap(value) {
    this.set("strokeLinecap", value);
  }
  get isDragSelectable() {
    return this.isBooleanItem === false;
  }
  get isBooleanItem() {
    return Boolean(this.parent.is("boolean-path"));
  }
  editable(editablePropertyName) {
    if (expectedPropertiesKeys[editablePropertyName]) {
      return false;
    }
    switch (editablePropertyName) {
      case "svg-item":
        return true;
    }
    return super.editable(editablePropertyName);
  }
  getDefaultTitle() {
    return "SVG";
  }
  isSVG() {
    return true;
  }
  hasPoint(x, y) {
    const fill = this.fill;
    const fillOpacity = this.fillOpacity;
    const strokeWidth = this.strokeWidth;
    const isTransparent = fill === "transparent" || fillOpacity === 0 || parse(fill).a === 0;
    const isZeroStroke = strokeWidth === 0;
    if (isTransparent) {
      return this.isPointInStroke(x, y);
    } else if (!isTransparent && !isZeroStroke) {
      return this.isPointInStroke(x, y) || this.isPointInFill(x, y);
    } else if (!isTransparent && isZeroStroke) {
      return this.isPointInFill(x, y);
    }
    return false;
  }
  isPointInFill(x, y) {
    const svgEl = this.getCache("svgElement");
    const pathEl = this.getCache("pathElement");
    if (pathEl) {
      const [localX, localY] = this.invertPoint([x, y, 0]);
      const point2 = svgEl.createSVGPoint();
      Object.assign(point2, { x: localX, y: localY });
      return pathEl.isPointInFill(point2);
    }
    return false;
  }
  isPointInStroke(x, y) {
    const svgEl = this.getCache("svgElement");
    const pathEl = this.getCache("pathElement");
    if (pathEl) {
      const [localX, localY] = this.invertPoint([x, y, 0]);
      const point2 = svgEl.createSVGPoint();
      Object.assign(point2, { x: localX, y: localY });
      return pathEl.isPointInStroke(point2);
    }
    return false;
  }
  convertStrokeToPath(distX = 10, distY = 10) {
    const attrs = this.attrs("name", "width", "parentId", "height", "x", "y", "transform", "stroke");
    attrs.fill = attrs.stroke;
    delete attrs.stroke;
    return __spreadProps(__spreadValues({
      itemType: "svg-path",
      "fill-rule": "evenodd"
    }, attrs), {
      x: Length.parse(attrs.x).add(distX),
      y: Length.parse(attrs.y).add(distY)
    });
  }
  toSVGPath() {
    const attrs = this.toCloneObject();
    delete attrs.id;
    delete attrs.itemType;
    return __spreadProps(__spreadValues({}, attrs), {
      d: this.d
    });
  }
  createFragmentMatrix(field) {
    const value = this.get(field);
    const image2 = SVGFill.parseImage(value);
    const backRect = {
      x: 0,
      y: 0,
      width: this.screenWidth,
      height: this.screenHeight
    };
    const backVerties = vertiesMap(rectToVerties(backRect.x, backRect.y, backRect.width, backRect.height), this.absoluteMatrix);
    const result = {
      backRect,
      backVerties,
      absoluteMatrix: this.absoluteMatrix,
      image: image2
    };
    let newX1, newY1, newX2, newY2, newX3, newY3;
    switch (image2.type) {
      case GradientType.RADIAL:
        newX1 = image2.x1.toPx(backRect.width);
        newY1 = image2.y1.toPx(backRect.height);
        newX2 = image2.x2.toPx(backRect.width);
        newY2 = image2.y2.toPx(backRect.height);
        newX3 = image2.x3.toPx(backRect.width);
        newY3 = image2.y3.toPx(backRect.height);
        const tempStartPoint = [newX1.value, newY1.value, 0];
        const tempEndPoint = [newX2.value, newY2.value, 0];
        const tempShapePoint = [newX3.value, newY3.value, 0];
        var [newStartPoint, newEndPoint, newShapePoint] = vertiesMap([tempStartPoint, tempEndPoint, tempShapePoint], this.absoluteMatrix);
        result.endPoint = newEndPoint;
        result.startPoint = newStartPoint;
        result.shapePoint = newShapePoint;
        result.colorsteps = image2.colorsteps.map((it) => {
          const offset = it.toLength();
          return {
            id: it.id,
            cut: it.cut,
            color: it.color,
            timing: it.timing,
            timingCount: it.timingCount,
            pos: lerp([], result.startPoint, result.endPoint, offset.value / 100)
          };
        });
        break;
      case GradientType.LINEAR:
        newX1 = image2.x1.toPx(backRect.width);
        newY1 = image2.y1.toPx(backRect.height);
        newX2 = image2.x2.toPx(backRect.width);
        newY2 = image2.y2.toPx(backRect.height);
        var [newStartPoint, newEndPoint] = vertiesMap([
          [newX1.value, newY1.value, 0],
          [newX2.value, newY2.value, 0]
        ], this.absoluteMatrix);
        result.endPoint = newEndPoint;
        result.startPoint = newStartPoint;
        result.areaStartPoint = clone(newStartPoint);
        result.areaEndPoint = clone(newEndPoint);
        result.colorsteps = image2.colorsteps.map((it) => {
          const offset = it.toLength();
          return {
            id: it.id,
            cut: it.cut,
            color: it.color,
            timing: it.timing,
            timingCount: it.timingCount,
            pos: lerp([], result.startPoint, result.endPoint, offset.value / 100)
          };
        });
        break;
    }
    return result;
  }
}
class PathModel extends SVGModel {
  getIcon() {
    return obj$2.edit;
  }
  getDefaultObject(obj2 = {}) {
    return super.getDefaultObject(__spreadValues({
      itemType: "svg-path",
      name: "New Path",
      strokeWidth: 1,
      d: "",
      totalLength: 0
    }, obj2));
  }
  enableHasChildren() {
    return false;
  }
  reset(json, context = { origin: "*" }) {
    const isChanged = super.reset(json, context);
    if (this.hasChangedField("d")) {
      this.cachePath = new PathParser(this.d);
      this.cacheWidth = this.width;
      this.cacheHeight = this.height;
    }
    return isChanged;
  }
  refreshMatrixCache() {
    super.refreshMatrixCache();
    if (this.hasChangedField("d")) {
      this.addCache("pathString", new PathParser(this.get("d")));
      this.addCache("pathWidth", this.width);
      this.addCache("pathHeight", this.height);
    } else if (this.hasChangedField("width", "height")) {
      this.d = this.getCache("pathString").clone().scale(this.width / this.cacheWidth, this.height / this.cacheHeight).d;
      this.manager.setChanged("reset", this.id, { d: this.d });
    }
  }
  setCache() {
    super.setCache();
    this.addCache("pathString", new PathParser(this.get("d")));
    this.addCache("pathWidth", this.width);
    this.addCache("pathHeight", this.height);
  }
  get d() {
    if (!this.get("d")) {
      return null;
    }
    if (!this.hasCache("pathString")) {
      this.addCache("pathString", new PathParser(this.get("d")));
      this.addCache("pathWidth", this.width);
      this.addCache("pathHeight", this.height);
    }
    return this.getCache("pathString").clone().scale(this.width / this.getCache("pathWidth"), this.height / this.getCache("pathHeight")).d;
  }
  set d(value) {
    this.set("d", value);
  }
  getDefaultTitle() {
    return "Path";
  }
}
class BooleanPathModel extends PathModel {
  getIcon() {
    return obj$2.edit;
  }
  getDefaultObject(obj2 = {}) {
    return super.getDefaultObject(__spreadValues({
      itemType: "boolean-path",
      name: "New Boolean Path",
      strokeWidth: 1,
      d: "",
      booleanOperation: "none"
    }, obj2));
  }
  get booleanOperation() {
    return this.get("booleanOperation");
  }
  set booleanOperation(value) {
    this.set("booleanOperation", value);
  }
  enableHasChildren() {
    return true;
  }
  reset(json, context = { origin: "*" }) {
    var _a;
    const isChanged = super.reset(json, context);
    if (!this.cachePath) {
      this.setCache();
    }
    if (this.hasChangedField("changedChildren", "booleanOperation")) {
      if (this.children.length === 1) {
        const newPath = this.layers[0].absolutePath().d;
        this.d = this.invertPath(newPath).d;
        this.setCache();
        this.modelManager.setChanged("reset", this.id, { d: newPath });
      } else if (this.booleanOperation !== "none") {
        if (((_a = this.children) == null ? void 0 : _a.length) >= 2) {
          if (this.modelManager.editor.pathKitManager.has()) {
            const paths = this.layers.filter((it) => it.d);
            if (paths.length >= 2) {
              const newPath = this.doBooleanOperation();
              this.d = newPath;
              this.setCache();
              this.modelManager.setChanged("reset", this.id, { d: newPath });
            } else {
              this.d = void 0;
              this.removeCache();
              this.modelManager.setChanged("reset", this.id, { d: void 0 });
            }
          }
        }
      }
    }
    return isChanged;
  }
  get resizableWitChildren() {
    return true;
  }
  startToCacheChildren() {
    this.cachedSize = {
      width: this.width,
      height: this.height
    };
    this.cachedLayerMatrix = this.layers.map((item) => {
      item.startToCacheChildren();
      return {
        item,
        matrix: item.matrix
      };
    });
  }
  recoverChildren() {
    const obj2 = {
      width: this.width,
      height: this.height
    };
    const scaleX = obj2.width / this.cachedSize.width;
    const scaleY = obj2.height / this.cachedSize.height;
    this.cachedLayerMatrix.forEach(({ item, matrix }) => {
      item.reset({
        x: item.x.changeUnitValue(matrix.x * scaleX, obj2.width),
        y: item.y.changeUnitValue(matrix.y * scaleY, obj2.height),
        width: item.width.changeUnitValue(matrix.width * scaleX, obj2.width),
        height: item.height.changeUnitValue(matrix.height * scaleY, obj2.height)
      });
      item.recoverChildren();
    });
  }
  getFieldValueByBooleanOperation(field) {
    const layers2 = this.layers;
    if (layers2.length === 0) {
      return;
    } else if (layers2.length === 1) {
      return layers2[0][field];
    }
    const op = this.booleanOperation;
    switch (op) {
      case BooleanOperation.DIFFERENCE:
        return layers2[1][field];
    }
    return layers2[0][field];
  }
  get fill() {
    return this.getFieldValueByBooleanOperation("fill");
  }
  get stroke() {
    return this.getFieldValueByBooleanOperation("stroke");
  }
  setCache() {
    super.setCache();
    this.cachePath = new PathParser(this.d);
    this.cacheWidth = this.width;
    this.cacheHeight = this.height;
  }
  removeCache() {
    super.removeCache();
    this.cachePath = void 0;
    this.cacheWidth = void 0;
    this.cacheHeight = void 0;
  }
  getDefaultTitle() {
    return "Path";
  }
  doBooleanOperation() {
    const op = this.booleanOperation;
    switch (op) {
      case BooleanOperation.INTERSECTION:
        return this.intersection();
      case BooleanOperation.UNION:
        return this.union();
      case BooleanOperation.DIFFERENCE:
        return this.difference();
      case BooleanOperation.REVERSE_DIFFERENCE:
        return this.reverseDifference();
      case BooleanOperation.XOR:
        return this.xor();
    }
    return "";
  }
  getPathList() {
    return this.layers.map((it) => it.absolutePath().d);
  }
  intersection() {
    const [first, ...rest] = this.getPathList();
    const newPath = rest.reduce((path1, path2) => {
      return this.modelManager.editor.pathKitManager.intersection(path1, path2);
    }, first);
    return this.invertPath(newPath).d;
  }
  union() {
    const [first, ...rest] = this.getPathList();
    const newPath = rest.reduce((path1, path2) => {
      return this.modelManager.editor.pathKitManager.union(path1, path2);
    }, first);
    return this.invertPath(newPath).d;
  }
  difference() {
    const [first, ...rest] = this.getPathList();
    const newPath = rest.reduce((path1, path2) => {
      return this.modelManager.editor.pathKitManager.difference(path1, path2);
    }, first);
    return this.invertPath(newPath).d;
  }
  reverseDifference() {
    const [first, ...rest] = this.getPathList();
    const newPath = rest.reduce((path1, path2) => {
      return this.modelManager.editor.pathKitManager.reverseDifference(path1, path2);
    }, first);
    return this.invertPath(newPath).d;
  }
  xor() {
    const [first, ...rest] = this.getPathList();
    const newPath = rest.reduce((path1, path2) => {
      return this.modelManager.editor.pathKitManager.xor(path1, path2);
    }, first);
    return this.invertPath(newPath).d;
  }
}
class CircleLayer extends LayerModel {
  getIcon() {
    return obj$2.lens;
  }
  getDefaultObject(obj2 = {}) {
    return super.getDefaultObject(__spreadValues({
      itemType: "circle",
      name: "New Circle",
      borderRadius: "100%"
    }, obj2));
  }
  getDefaultTitle() {
    return "Circle";
  }
}
class ImageLayer extends LayerModel {
  getIcon() {
    return obj$2.image;
  }
  getDefaultObject(obj2 = {}) {
    return super.getDefaultObject(__spreadValues({
      itemType: "image",
      name: "New Image",
      elementType: "image",
      src: ""
    }, obj2));
  }
  get src() {
    return this.get("src");
  }
  set src(value) {
    this.set("src", value);
  }
  get naturalWidth() {
    return this.get("naturalWidth");
  }
  set naturalWidth(value) {
    this.set("naturalWidth", value);
  }
  get naturalHeight() {
    return this.get("naturalHeight");
  }
  set naturalHeight(value) {
    this.set("naturalHeight", value);
  }
  enableHasChildren() {
    return false;
  }
  getDefaultTitle() {
    return "Image";
  }
  resize() {
    this.reset({
      width: this.naturalWidth.clone(),
      height: this.naturalHeight.clone()
    });
  }
}
class PolygonModel extends SVGModel {
  getIcon() {
    return obj$2.edit;
  }
  getDefaultObject(obj2 = {}) {
    return super.getDefaultObject(__spreadValues({
      itemType: "polygon",
      name: "New Polygon",
      strokeWidth: 1,
      count: 3
    }, obj2));
  }
  get count() {
    return this.get("count");
  }
  set count(value) {
    this.set("count", value);
  }
  convert(json) {
    json = super.convert(json);
    if (json.count)
      json.count = +json.count;
    return json;
  }
  enableHasChildren() {
    return false;
  }
  get editablePath() {
    return false;
  }
  get d() {
    const { width: width2, height: height2, count } = this;
    return PathParser.makePolygon(width2, height2, count).d;
  }
  getDefaultTitle() {
    return "Polygon";
  }
  isPointInPath(point2) {
    const localPoint = transformMat4([], point2, this.absoluteMatrixInverse);
    return this.cachePath.isPointInPath({ x: localPoint[0], y: localPoint[1] }, this.strokeWidth || 0);
  }
}
class AssetModel extends BaseModel {
  getDefaultObject(obj2 = {}) {
    return super.getDefaultObject(__spreadValues({
      comments: [],
      colors: [],
      gradients: [],
      svgfilters: [],
      svgimages: [],
      keyframes: [],
      images: [],
      imageKeys: [],
      videos: [],
      videoKeys: [],
      audios: []
    }, obj2));
  }
  get comments() {
    return this.get("comments");
  }
  get colors() {
    return this.get("colors");
  }
  get gradients() {
    return this.get("gradients");
  }
  get svgfilters() {
    return this.get("svgfilters");
  }
  get svgimages() {
    return this.get("svgimages");
  }
  get keyframes() {
    return this.get("keyframes");
  }
  get videos() {
    return this.get("videos");
  }
  get images() {
    return this.get("images");
  }
  set images(value) {
    this.set("images", value);
  }
  get imageKeys() {
    return this.get("imageKeys");
  }
  get videoKeys() {
    return this.get("videoKeys");
  }
  addKeyframe(keyframe2) {
    this.keyframes.push(keyframe2);
    return keyframe2;
  }
  createKeyframe(data = {}) {
    return this.addKeyframe(new Keyframe(__spreadValues({
      checked: true
    }, data)));
  }
  removeKeyframe(removeIndex) {
    this.removePropertyList(this.keyframes, removeIndex);
  }
  sortItem(arr, startIndex, targetIndex) {
    arr.splice(targetIndex + (startIndex < targetIndex ? -1 : 0), 0, ...arr.splice(startIndex, 1));
  }
  sortKeyframe(startIndex, targetIndex) {
    this.sortItem(this.keyframes, startIndex, targetIndex);
  }
  updateKeyframe(index2, data = {}) {
    this.keyframes[+index2].reset(data);
  }
  toKeyframeString(isAnimate = false) {
    return this.keyframes.map((keyframe2) => keyframe2.toString(isAnimate)).join("\n\n");
  }
  copyPropertyList(arr, index2) {
    var copyObject = __spreadValues({}, arr[index2]);
    arr.splice(index2, 0, copyObject);
  }
  removePropertyList(arr, removeIndex) {
    arr.splice(removeIndex, 1);
  }
  removeColor(removeIndex) {
    this.removePropertyList(this.colors, removeIndex);
  }
  copyColor(index2) {
    this.copyPropertyList(this.colors, index2);
  }
  sortColor(startIndex, targetIndex) {
    this.sortItem(this.colors, startIndex, targetIndex);
  }
  setColorValue(index2, value = {}) {
    this.colors[index2] = __spreadValues(__spreadValues({}, this.colors[index2]), value);
  }
  getColorIndex(index2) {
    return this.colors[index2];
  }
  getColor(name) {
    return this.colors.filter((item) => item.name === name)[0];
  }
  addColor(obj2) {
    this.colors.push(obj2);
    return obj2;
  }
  createColor(data = {}) {
    return this.addColor(data);
  }
  removeImage(removeIndex) {
    this.removePropertyList(this.images, removeIndex);
    this.refreshImageKeys();
  }
  copyImage(index2) {
    this.copyPropertyList(this.images, index2);
    this.refreshImageKeys();
  }
  sortImage(startIndex, targetIndex) {
    this.sortItem(this.images, startIndex, targetIndex);
  }
  setImageValue(index2, value = {}) {
    this.images[index2] = __spreadValues(__spreadValues({}, this.images[index2]), value);
    this.refreshImageKeys();
  }
  getImageValueById(id, defaultValue2 = "") {
    const image2 = this.imageKeys[id];
    if (!image2)
      return id || defaultValue2;
    return image2.local;
  }
  getImageDataURIById(id) {
    const image2 = this.imageKeys[id];
    if (!image2)
      return void 0;
    return image2.original;
  }
  refreshImageKeys() {
    let imageKeys = {};
    this.images.forEach((it) => {
      imageKeys[it.id] = it;
    });
    this.reset({
      imageKeys
    });
  }
  addImage(obj2) {
    this.images.push(obj2);
    this.refreshImageKeys();
    return obj2;
  }
  createImage(data = {}) {
    return this.addImage(data);
  }
  removeVideo(removeIndex) {
    this.removePropertyList(this.videos, removeIndex);
    this.refreshVideoKeys();
  }
  copyVideo(index2) {
    this.copyPropertyList(this.videos, index2);
    this.refreshVideoKeys();
  }
  sortVideo(startIndex, targetIndex) {
    this.sortItem(this.videos, startIndex, targetIndex);
  }
  setVideoValue(index2, value = {}) {
    this.videos[index2] = __spreadValues(__spreadValues({}, this.videos[index2]), value);
  }
  getVideoValueById(id) {
    const video2 = this.videoKeys[id];
    if (!video2)
      return void 0;
    return video2.local;
  }
  refreshVideoKeys() {
    let videoKeys = {};
    this.videos.forEach((it) => {
      videoKeys[it.id] = it;
    });
    this.reset({
      videoKeys
    });
  }
  addVideo(obj2) {
    this.videos.push(obj2);
    this.refreshVideoKeys();
    return obj2;
  }
  createVideo(data = {}) {
    return this.addVideo(data);
  }
  removeGradient(removeIndex) {
    this.removePropertyList(this.gradients, removeIndex);
  }
  copyGradient(index2) {
    this.copyPropertyList(this.gradients, index2);
  }
  sortGradient(startIndex, targetIndex) {
    this.sortItem(this.gradients, startIndex, targetIndex);
  }
  setGradientValue(index2, value) {
    this.gradients[index2] = __spreadValues(__spreadValues({}, this.gradients[index2]), value);
  }
  getGradientIndex(index2) {
    return this.gradients[index2];
  }
  getGradient(name) {
    return this.gradients.filter((item) => item.name === name)[0];
  }
  addGradient(obj2 = {}) {
    this.gradients.push(obj2);
    return obj2;
  }
  createGradient(data = {}) {
    return this.addGradient(data);
  }
  getSVGFilterIndex(id) {
    var _a;
    var filter2 = this.svgfilters.map((it, index2) => {
      return { id: it.id, index: index2 };
    }).filter((it) => {
      return it.id === id;
    });
    return filter2.length ? (_a = filter2 == null ? void 0 : filter2[0]) == null ? void 0 : _a.index : -1;
  }
  removeSVGFilter(removeIndex) {
    this.removePropertyList(this.svgfilters, removeIndex);
  }
  copySVGFilter(index2) {
    this.copyPropertyList(this.svgfilters, index2);
  }
  sortSVGFilter(startIndex, targetIndex) {
    this.sortItem(this.svgfilters, startIndex, targetIndex);
  }
  setSVGFilterValue(index2, value) {
    this.svgfilters[index2] = __spreadValues(__spreadValues({}, this.svgfilters[index2]), value);
  }
  addSVGFilter(obj2 = {}) {
    this.svgfilters.push(obj2);
    var index2 = this.svgfilters.length - 1;
    return index2;
  }
  createSVGFilter(data = {}) {
    return this.addSVGFilter(data);
  }
  getSVGImageIndex(id) {
    var filter2 = this.svgimages.map((it, index2) => {
      return { id: it.id, index: index2 };
    }).filter((it) => {
      return it.id === id;
    })[0];
    return filter2 ? filter2.index : -1;
  }
  removeSVGImage(removeIndex) {
    this.removePropertyList(this.svgimages, removeIndex);
  }
  copySVGImage(index2) {
    this.copyPropertyList(this.svgimages, index2);
  }
  sortSVGImage(startIndex, targetIndex) {
    this.sortItem(this.svgimages, startIndex, targetIndex);
  }
  setSVGImageValue(index2, value) {
    this.svgimages[index2] = __spreadValues(__spreadValues({}, this.svgimages[index2]), value);
  }
  addSVGImage(obj2 = {}) {
    this.svgimages.push(obj2);
    var index2 = this.svgimages.length - 1;
    return index2;
  }
  createSVGImage(data = {}) {
    return this.addSVGImage(data);
  }
}
const identity = create$4();
class Project extends AssetModel {
  getDefaultTitle() {
    return "New Project";
  }
  get isAbsolute() {
    return false;
  }
  get parent() {
    return null;
  }
  get nestedAngle() {
    return 0;
  }
  toRootVariableCSS() {
    var obj2 = {};
    this.rootVariable.split(";").filter((it) => it.trim()).forEach((it) => {
      var [key, value] = it.split(":");
      obj2[`--${key}`] = value;
    });
    return obj2;
  }
  getDefaultObject(obj2 = {}) {
    return super.getDefaultObject(__spreadValues({
      itemType: "project",
      name: "new Project",
      description: "",
      rootVariable: ""
    }, obj2));
  }
  get description() {
    return this.get("description");
  }
  set description(value) {
    this.set("description", value);
  }
  get rootVariable() {
    return this.get("rootVariable");
  }
  set rootVariable(value) {
    this.set("rootVariable", value);
  }
  get artboards() {
    return (this.layers || []).filter((it) => it.is("artboard"));
  }
  get offsetX() {
    return 0;
  }
  get offsetY() {
    return 0;
  }
  get screenWidth() {
    return 0;
  }
  get screenHeight() {
    return 0;
  }
  isLayoutItem() {
    return false;
  }
  hasLayout() {
    return false;
  }
  getAbsoluteMatrix() {
    return create$4();
  }
  getTransformMatrix() {
    return create$4();
  }
  resetMatrix(childItem) {
    const [x, y] = getTranslation([], calculateMatrix(childItem.absoluteMatrix, childItem.localMatrixInverse));
    childItem.reset({
      x,
      y
    });
  }
  get rectVerties() {
    var _a;
    return ((_a = this.layers) == null ? void 0 : _a.length) ? itemsToRectVerties(this.layers) : null;
  }
  get absoluteMatrix() {
    return identity;
  }
  get absoluteMatrixInverse() {
    return identity;
  }
  get contentBox() {
    return {
      left: 0,
      top: 0,
      width: 0,
      height: 0
    };
  }
}
class RectLayer extends LayerModel {
  getIcon() {
    return obj$2.rect;
  }
  getDefaultObject(obj2 = {}) {
    return super.getDefaultObject(__spreadValues({
      itemType: "rect",
      name: "New Rect"
    }, obj2));
  }
  getDefaultTitle() {
    return "Rect";
  }
}
var isNdarray$2 = function(arr) {
  if (!arr)
    return false;
  if (!arr.dtype)
    return false;
  var re = new RegExp("function View[0-9]+d(:?" + arr.dtype + ")+");
  return re.test(String(arr.constructor));
};
var isNdarrayLike$3 = function(arr) {
  if (!arr)
    return false;
  return arr.data !== void 0 && Array.isArray(arr.shape) && arr.offset !== void 0 && arr.stride !== void 0;
};
var isArrayLike$5 = function isArrayLike(data) {
  return Array.isArray(data) || ArrayBuffer.isView(data);
};
var isNdarray$1 = isNdarray$2;
var isNdarrayLike$2 = isNdarrayLike$3;
var isArrayLike$4 = isArrayLike$5;
function inferType$5(x) {
  if (!x) {
    return void 0;
  }
  if (isNdarray$1(x) || isNdarrayLike$2(x)) {
    if (x.dtype === "generic") {
      return inferType$5.GENERIC_NDARRAY;
    }
    return inferType$5.NDARRAY;
  } else {
    if (isArrayLike$4(x)) {
      return inferType$5.ARRAY_OF_ARRAYS;
    }
    throw new Error("Unhandled data type. Got type: " + typeof x);
  }
}
inferType$5.ARRAY_OF_ARRAYS = "Arr";
inferType$5.NDARRAY = "Nd";
inferType$5.GENERIC_NDARRAY = "GenNd";
inferType$5.PACKED = "PackArr";
var inferType_1 = inferType$5;
var isArrayLike$3 = isArrayLike$5;
function capitalize(str) {
  return str[0].toUpperCase() + str.slice(1);
}
var cacheKey = function(nurbs2, debug, checkBounds, pointType, weightType, knotType) {
  var d;
  var degreeParts = [];
  var hasAnyKnots = false;
  for (d = 0; d < nurbs2.splineDimension; d++) {
    var hasKnots = isArrayLike$3(nurbs2.knots) && isArrayLike$3(nurbs2.knots[d]);
    if (hasKnots)
      hasAnyKnots = true;
    degreeParts.push("Deg" + nurbs2.degree[d] + (hasKnots ? "" : "Uniform") + capitalize(nurbs2.boundary[d]));
  }
  var parts = [
    [
      hasAnyKnots ? "NU" : "",
      nurbs2.weights ? "RBS" : "BS"
    ].join("") + nurbs2.dimension + "D",
    degreeParts.join("_")
  ];
  if (pointType) {
    parts.push(pointType + "Pts");
  }
  if (weightType) {
    parts.push(weightType + "Wts");
  }
  if (knotType) {
    parts.push(knotType + "Kts");
  }
  if (debug) {
    parts.push("debug");
  }
  if (checkBounds) {
    parts.push("chk");
  }
  return parts.join("_");
};
var createVariable$1 = function createVariable(name, nurbs2) {
  return function(i, period) {
    if (i !== void 0 && !Array.isArray(i))
      i = [i];
    var dimAccessors = [];
    for (var j = 0; j < i.length; j++) {
      dimAccessors.push(createVariable.sum(i[j]));
    }
    if (period) {
      for (i = 0; i < dimAccessors.length; i++) {
        if (period[i] === void 0)
          continue;
        dimAccessors[i] = "(" + dimAccessors[i] + " + " + period[i] + ") % " + period[i];
      }
    }
    return name + dimAccessors.join("_");
  };
};
createVariable$1.sum = function(parts) {
  parts = Array.isArray(parts) ? parts : [parts];
  parts = parts.filter(function(part) {
    return part !== void 0 && part !== 0;
  });
  if (parts.length === 0)
    parts.push(0);
  return parts.join(" + ");
};
var variable$3 = createVariable$1;
var inferType$4 = inferType_1;
var createVariable2 = variable$3;
function wrapAccessor(callback) {
  return function(i, period) {
    if (i !== void 0 && !Array.isArray(i))
      i = [i];
    var dimAccessors = [];
    for (var j = 0; j < i.length; j++) {
      dimAccessors.push(createVariable2.sum(i[j]));
    }
    if (period) {
      for (i = 0; i < dimAccessors.length; i++) {
        if (period[i] === void 0)
          continue;
        dimAccessors[i] = "(" + dimAccessors[i] + " + " + period[i] + ") % " + period[i];
      }
    }
    return callback(dimAccessors);
  };
}
function createAccessor(name, data) {
  var i;
  if (!data)
    return void 0;
  switch (inferType$4(data)) {
    case inferType$4.ARRAY_OF_ARRAYS:
      return wrapAccessor(function(accessors) {
        return name + "[" + accessors.join("][") + "]";
      });
    case inferType$4.GENERIC_NDARRAY:
      return wrapAccessor(function(accessors) {
        return name + ".get(" + accessors.join(",") + ")";
      });
    case inferType$4.NDARRAY:
      return wrapAccessor(function(accessors) {
        var code2 = [name + "Offset"];
        for (i = 0; i < accessors.length; i++) {
          code2.push(name + "Stride" + i + " * (" + accessors[i] + ")");
        }
        return name + "[" + code2.join(" + ") + "]";
      });
    case inferType$4.PACKED:
    default:
      return void 0;
  }
}
var createAccessors$1 = function(nurbs2) {
  var accessors = {};
  var accessor;
  accessor = createAccessor("x", nurbs2.points);
  if (accessor)
    accessors.point = accessor;
  accessor = createAccessor("w", nurbs2.weights);
  if (accessor)
    accessors.weight = accessor;
  accessor = createAccessor("k", nurbs2.knots);
  if (accessor)
    accessors.knot = accessor;
  return accessors;
};
var args = [];
var tmp = [];
var numericalDerivative$1 = function numericalDerivative(out, order, dimension) {
  if (order !== 1) {
    throw new Error("Numerical derivative not implemented for order n = " + order + ".");
  }
  var i;
  var h = arguments[this.splineDimension + 3] === void 0 ? 1e-4 : arguments[this.splineDimension + 3];
  args.length = this.splineDimension;
  for (i = 0; i < this.splineDimension; i++) {
    args[i + 1] = arguments[i + 3];
  }
  var domain = this.domain;
  var k0 = domain[dimension][0];
  var k1 = domain[dimension][1];
  var tm, tp, T;
  var t0 = args[dimension + 1];
  var dt = (k1 - k0) * h;
  if (this.boundary[dimension] === "closed") {
    T = k1 - k0;
    tm = k0 + (t0 - k0 - dt + T) % T;
    tp = k0 + (t0 - k0 + dt + T) % T;
    dt *= 2;
  } else {
    tm = Math.min(k1, Math.max(k0, t0 - dt));
    tp = Math.min(k1, Math.max(k0, t0 + dt));
    dt = tp - tm;
  }
  args[dimension + 1] = tm;
  args[0] = tmp;
  this.evaluate.apply(null, args);
  args[dimension + 1] = tp;
  args[0] = out;
  this.evaluate.apply(null, args);
  for (i = 0; i < this.dimension; i++) {
    out[i] = (out[i] - tmp[i]) / dt;
  }
  return out;
};
var ndloop$2 = function ndloop(n, callback) {
  for (var m = 1, k = 0, i = []; k < n.length; k++) {
    m *= Array.isArray(n[k]) ? n[k][1] - n[k][0] : n[k];
    i[k] = Array.isArray(n[k]) ? n[k][0] : 0;
  }
  for (var ptr = 0; ptr < m; ptr++) {
    callback(i.slice());
    for (k = n.length - 1; k >= 0; k--) {
      if (i[k] === (Array.isArray(n[k]) ? n[k][1] : n[k]) - 1) {
        i[k] = Array.isArray(n[k]) ? n[k][0] : 0;
      } else {
        i[k]++;
        break;
      }
    }
  }
};
var inferType$3 = inferType_1;
var accessorPreamble$3 = function(nurbs2, variableName, propertyName, data) {
  var i;
  var code2 = [];
  switch (inferType$3(data)) {
    case inferType$3.NDARRAY:
      code2.push("  var " + variableName + " = " + propertyName + ".data;");
      code2.push("  var " + variableName + "Offset = " + propertyName + ".offset;");
      for (i = 0; i < data.dimension; i++) {
        code2.push("  var " + variableName + "Stride" + i + " = " + propertyName + ".stride[" + i + "];");
      }
      break;
    case inferType$3.ARRAY_OF_ARRAYS:
      code2.push("  var " + variableName + " = " + propertyName + ";");
  }
  return code2.join("\n");
};
var isNdarrayLike$1 = isNdarrayLike$3;
var sizeGetter$3 = function(data, dataVariableName, dimension) {
  if (!data) {
    return "this.size[" + dimension + "]";
  } else if (isNdarrayLike$1(data)) {
    return dataVariableName + ".shape[" + dimension + "]";
  } else {
    var str = dataVariableName;
    for (var i = 0; i < dimension; i++) {
      str += "[0]";
    }
    return str + ".length";
  }
};
var ndloop$1 = ndloop$2;
var variable$2 = variable$3;
var accessorPreamble$2 = accessorPreamble$3;
var inferType$2 = inferType_1;
var isArrayLike$2 = isArrayLike$5;
var sizeGetter$2 = sizeGetter$3;
var evaluatorCache = {};
var codeCache = {};
var evaluate = function(cacheKey2, nurbs2, accessors, debug, checkBounds, isBasis, derivative) {
  var splineDimension = nurbs2.splineDimension;
  var i, j, n, m, d, kvar;
  var points = nurbs2.points;
  var degree = nurbs2.degree;
  var weights = nurbs2.weights;
  var hasWeights = weights !== void 0;
  var knots = nurbs2.knots;
  var spaceDimension = nurbs2.dimension;
  var boundary = nurbs2.boundary;
  if (derivative !== void 0 && derivative !== null) {
    if (!Array.isArray(derivative)) {
      derivative = [derivative];
    }
    var totalDerivativeOrder = 0;
    for (i = 0; i < splineDimension; i++) {
      if (derivative[i] === void 0)
        derivative[i] = 0;
      totalDerivativeOrder += derivative[i];
    }
    if (hasWeights && totalDerivativeOrder > 1) {
      throw new Error("Analytical derivative not implemented for rational b-splines with order n = " + totalDerivativeOrder + ".");
    }
  }
  if (isBasis)
    cacheKey2 = "Basis" + cacheKey2;
  if (derivative)
    cacheKey2 = "Der" + derivative.join("_") + "_" + cacheKey2;
  var cachedEvaluator = evaluatorCache[cacheKey2];
  if (debug) {
    var logger = typeof debug === "function" ? debug : console.log;
  }
  if (cachedEvaluator) {
    if (debug) {
      logger(codeCache[cacheKey2]);
    }
    return cachedEvaluator.bind(nurbs2);
  }
  var code2 = [];
  var functionName = "evaluate" + cacheKey2;
  var pointAccessor = accessors.point;
  if (isBasis) {
    pointAccessor = function(src, period) {
      var terms = [];
      for (var i2 = 0; i2 < src.length; i2++) {
        var accessor = src[i2];
        var terms2 = [];
        for (var j2 = 0; j2 < accessor.length; j2++) {
          if (accessor[j2] !== 0)
            terms2.push(accessor[j2]);
        }
        accessor = terms2.join(" + ");
        if (period[i2]) {
          accessor = "(" + accessor + " + " + period[i2] + ") % " + period[i2];
        }
        terms.push(accessor + " === " + indexVar(i2));
      }
      return "((" + terms.join(" && ") + ") ? 1 : 0)";
    };
  }
  var weightAccessor = accessors.weight;
  var knotAccessor = accessors.knot;
  var knotVar = variable$2("k");
  var pointVar = variable$2("x");
  var weightVar = variable$2("w");
  var indexVar = variable$2("i");
  var tVar = variable$2("t");
  var domainVar = debug ? "domain" : "d";
  var sizeVar = variable$2(debug ? "size" : "s");
  var knotIndex = variable$2(debug ? "knotIndex" : "j");
  var allDimensionUniform = true;
  for (d = 0; d < splineDimension; d++) {
    if (isArrayLike$2(knots) && isArrayLike$2(knots[d])) {
      allDimensionUniform = false;
    }
  }
  function line2(str) {
    code2.push("  " + (str || ""));
  }
  function debugLine(str) {
    if (debug)
      line2(str);
  }
  if (isBasis) {
    var indexArgs = [];
  }
  var parameterArgs = [];
  for (i = 0; i < splineDimension; i++) {
    if (isBasis) {
      indexArgs.push(indexVar([i]));
    }
    parameterArgs.push(tVar([i]));
  }
  code2.push("function " + functionName + " (" + (isBasis ? "" : "out, ") + parameterArgs.join(", ") + (isBasis ? ", " + indexArgs.join(", ") : "") + ") {");
  line2("var h, m, a, b;");
  if (checkBounds) {
    line2("var " + domainVar + " = this.domain;");
    line2("for (var i = 0; i < this.splineDimension; i++) {");
    line2("  a = arguments[i + 1];");
    line2("  if (a < " + domainVar + "[i][0] || a > " + domainVar + "[i][1] || a === undefined || isNaN(a)) {");
    line2("    throw new Error('Invalid Spline parameter in dimension '+i+'. Valid domain is ['+" + domainVar + "[i][0]+', '+" + domainVar + "[i][1]+']. but got t'+i+' = '+arguments[i + 1]+'.');");
    line2("  }");
    line2("}");
  }
  for (d = 0; d < splineDimension; d++) {
    line2("var " + sizeVar(d) + " = " + sizeGetter$2(points, "this.points", d) + ";");
  }
  code2.push(accessorPreamble$2(nurbs2, "x", "this.points", points));
  if (hasWeights) {
    code2.push(accessorPreamble$2(nurbs2, "w", "this.weights", weights));
  }
  if (!allDimensionUniform) {
    code2.push(accessorPreamble$2(nurbs2, "k", "this.knots", knots));
  }
  function ternary(cond, a, b) {
    return "(" + cond + ") ? (" + a + ") : (" + b + ")";
  }
  var hasKnots = [];
  for (d = 0; d < splineDimension; d++) {
    switch (inferType$2(knots)) {
      case inferType$2.NDARRAY:
        hasKnots[d] = true;
        break;
      case inferType$2.ARRAY_OF_ARRAYS:
        hasKnots[d] = isArrayLike$2(knots[d]);
        break;
    }
  }
  for (d = 0; d < splineDimension; d++) {
    if (hasKnots[d]) {
      debugLine("\n  // Bisect to locate the knot interval in dimension " + d + "\n");
      line2("var " + knotIndex(d) + " = 0;");
      line2("h = " + sizeVar(d) + ";");
      line2("while(h > " + knotIndex(d) + " + 1) {");
      line2("  m = 0.5 * (h + " + knotIndex(d) + ") | 0;");
      line2("  if (" + knotAccessor([d, "m"]) + " > " + tVar(d) + ") h = m;");
      line2("  else " + knotIndex(d) + " = m;");
      line2("}");
      debugLine("\n  // Fetch knots for dimension " + d + "\n");
      for (i = -degree[d] + 1; i <= degree[d]; i++) {
        if (boundary[d] === "closed") {
          if (i < 0) {
            line2("var " + knotVar([d, i + degree[d] - 1]) + " = " + ternary(knotIndex(d) + " < " + -i, knotAccessor([d, 0]) + " + " + knotAccessor([d, [sizeVar(d), knotIndex(d), i]]) + " - " + knotAccessor([d, [sizeVar(d)]]), knotAccessor([d, [knotIndex(d), i]])) + ";");
          } else if (i > 0) {
            line2("var " + knotVar([d, i + degree[d] - 1]) + " = " + ternary(knotIndex(d) + " + " + i + " > " + sizeVar(d), knotAccessor([d, sizeVar(d)]) + " + " + knotAccessor([d, i + " + " + knotIndex(d) + " - " + sizeVar(d)]) + " - " + knotAccessor([d, 0]), knotAccessor([d, [knotIndex(d), i]])) + ";");
          } else {
            line2("var " + knotVar([d, i + degree[d] - 1]) + " = " + knotAccessor([d, [knotIndex(d), i]]) + ";");
          }
        } else {
          line2("var " + knotVar([d, i + degree[d] - 1]) + " = " + knotAccessor([d, [knotIndex(d), i]]) + ";");
        }
      }
    } else {
      debugLine("\n  // Directly compute knot interval for dimension " + d + "\n");
      if (boundary[d] === "closed") {
        line2(knotIndex(d) + " = (" + tVar(d) + " | 0) % " + sizeVar(d) + ";");
      } else {
        line2(knotIndex(d) + " = (" + tVar(d) + " | 0);");
        line2("if (" + knotIndex(d) + " < " + degree[d] + ") " + knotIndex(d) + " = " + degree[d] + ";");
        line2("if (" + knotIndex(d) + " > " + sizeVar(d) + " - 1) " + knotIndex(d) + " = " + sizeVar(d) + " - 1;");
      }
      debugLine("\n  // Compute and clamp knots for dimension " + d + "\n");
      for (i = -degree[d] + 1; i <= degree[d]; i++) {
        kvar = knotVar([d, i + degree[d] - 1]);
        line2("var " + kvar + " = " + knotIndex(d) + " + " + i + ";");
      }
      if (boundary[d] === "clamped") {
        for (i = -degree[d] + 1; i <= degree[d]; i++) {
          kvar = knotVar([d, i + degree[d] - 1]);
          if (i < 0) {
            line2("if (" + kvar + " < " + degree[d] + ") " + kvar + " = " + degree[d] + ";");
          }
          if (i > 0) {
            line2("if (" + kvar + " > " + sizeVar(d) + ") " + kvar + " = " + sizeVar(d) + ";");
          }
        }
      }
      if (boundary[d] === "closed") {
        debugLine("\n  // Wrap the B-Spline parameter for closed boundary");
        line2(tVar(d) + " %= " + sizeVar(d) + ";");
      }
    }
  }
  for (d = 0, n = []; d < splineDimension; d++) {
    n[d] = degree[d] + 1;
  }
  if (hasWeights) {
    debugLine("\n  // Fetch weights\n");
    ndloop$1(n, function(dst) {
      var readIdx = [];
      var period = [];
      for (var d2 = 0; d2 < splineDimension; d2++) {
        readIdx[d2] = [knotIndex(d2), dst[d2] - degree[d2]];
        if (boundary[d2] === "closed" && dst[d2] - degree[d2] < 0)
          period[d2] = sizeVar(d2);
      }
      line2("var " + weightVar(dst) + " = " + weightAccessor(readIdx, period) + ";");
    });
  }
  if (debug) {
    if (hasWeights) {
      line2("\n  // Fetch points and project into homogeneous (weighted) coordinates\n");
    } else {
      line2("\n  // Fetch points\n");
    }
  }
  ndloop$1(n, function(dst) {
    var readIdx = [];
    var period = [];
    for (var d2 = 0; d2 < splineDimension; d2++) {
      readIdx[d2] = [knotIndex(d2), dst[d2] - degree[d2]];
      if (boundary[d2] === "closed" && dst[d2] - degree[d2] < 0)
        period[d2] = sizeVar(d2);
    }
    if (isBasis) {
      if (hasWeights) {
        line2("var " + pointVar(dst) + " = " + pointAccessor(readIdx, period) + " * " + weightVar(dst) + ";");
      } else {
        line2("var " + pointVar(dst) + " = " + pointAccessor(readIdx, period) + ";");
      }
    } else {
      for (d2 = 0; d2 < spaceDimension; d2++) {
        var dstWithDim = dst.concat(d2);
        readIdx[splineDimension] = d2;
        if (hasWeights) {
          line2("var " + pointVar(dstWithDim) + " = " + pointAccessor(readIdx, period) + " * " + weightVar(dst) + ";");
        } else {
          line2("var " + pointVar(dstWithDim) + " = " + pointAccessor(readIdx, period) + ";");
        }
      }
    }
  });
  debugLine("\n");
  debugLine("// Perform De Boor's algorithm");
  for (d = n.length - 1; d >= 0; d--) {
    n[d] = [degree[d], degree[d] + 1];
    for (i = 0; i < degree[d]; i++) {
      debugLine("\n  // Degree " + degree[d] + " evaluation in dimension " + d + ", step " + (i + 1) + "\n");
      for (j = degree[d]; j > i; j--) {
        var isDerivative = derivative && degree[d] - i - derivative[d] <= 0;
        if (isDerivative) {
          line2("m = 1 / (" + knotVar([d, j - i + degree[d] - 1]) + " - " + knotVar([d, j - 1]) + ");");
          if (hasWeights) {
            line2("a = (" + tVar(d) + " - " + knotVar([d, j - 1]) + ") * m;");
            line2("b = 1 - a;");
          }
        } else {
          line2("a = (" + tVar(d) + " - " + knotVar([d, j - 1]) + ") / (" + knotVar([d, j - i + degree[d] - 1]) + " - " + knotVar([d, j - 1]) + ");");
          line2("b = 1 - a;");
        }
        if (hasWeights) {
          ndloop$1(n, function(ii) {
            var ij = ii.slice();
            var ij1 = ii.slice();
            ij[d] = j;
            ij1[d] = j - 1;
            if (isDerivative && hasWeights)
              line2("h = " + weightVar(ij) + ";");
            line2(weightVar(ij) + " = b * " + weightVar(ij1) + " + a * " + weightVar(ij) + ";");
          });
        }
        ndloop$1(n, function(ii) {
          var weightFactor, pt1, pt2;
          var ij = ii.slice();
          var ij1 = ii.slice();
          ij[d] = j;
          ij1[d] = j - 1;
          if (isDerivative) {
            var derivCoeff = i + 1;
            if (isBasis) {
              weightFactor = hasWeights ? "h * " + weightVar(ij1) + " / " + weightVar(ij) + " * " : "";
              pt1 = pointVar(ij) + (hasWeights ? " / h" : "");
              pt2 = pointVar(ij1) + (hasWeights ? " / " + weightVar(ij1) : "");
              line2(pointVar(ij) + " = " + derivCoeff + " * " + weightFactor + "(" + pt1 + " - " + pt2 + ") * m;");
            } else {
              var ijWithDimension = ij.slice();
              var ij1WithDimension = ij1.slice();
              for (m = 0; m < spaceDimension; m++) {
                ijWithDimension[splineDimension] = ij1WithDimension[splineDimension] = m;
                weightFactor = hasWeights ? "h * " + weightVar(ij1) + " / " + weightVar(ij) + " * " : "";
                pt1 = pointVar(ijWithDimension) + (hasWeights ? " / h" : "");
                pt2 = pointVar(ij1WithDimension) + (hasWeights ? " / " + weightVar(ij1) : "");
                line2(pointVar(ijWithDimension) + " = " + derivCoeff + " * " + weightFactor + "(" + pt1 + " - " + pt2 + ") * m;");
              }
            }
          } else {
            if (isBasis) {
              line2(pointVar(ij) + " = b * " + pointVar(ij1) + " + a * " + pointVar(ij) + ";");
            } else {
              for (m = 0; m < spaceDimension; m++) {
                ij[splineDimension] = ij1[splineDimension] = m;
                line2(pointVar(ij) + " = b * " + pointVar(ij1) + " + a * " + pointVar(ij) + ";");
              }
            }
          }
        });
        debugLine("\n");
      }
    }
  }
  if (debug) {
    if (hasWeights) {
      line2("\n  // Project back from homogeneous coordinates and return final output\n");
    } else {
      line2("\n  // Return final output\n");
    }
  }
  if (isBasis) {
    if (hasWeights) {
      line2("return " + pointVar(degree) + " / " + weightVar(degree) + ";");
    } else {
      line2("return " + pointVar(degree) + ";");
    }
  } else {
    for (d = 0; d < spaceDimension; d++) {
      if (hasWeights) {
        line2("out[" + d + "] = " + pointVar(degree.concat([d])) + " / " + weightVar(degree) + ";");
      } else {
        line2("out[" + d + "] = " + pointVar(degree.concat([d])) + ";");
      }
    }
  }
  if (!isBasis) {
    line2("return out;");
  }
  code2.push("}");
  if (debug) {
    var codeStr = code2.join("\n");
    logger(codeStr);
    codeCache[cacheKey2] = codeStr;
  }
  var evaluator = new Function([code2.join("\n"), "; return ", functionName].join(""))();
  evaluatorCache[cacheKey2] = evaluator;
  return evaluator.bind(nurbs2);
};
var transformerCache = {};
var accessorPreamble$1 = accessorPreamble$3;
var sizeGetter$1 = sizeGetter$3;
var variable$1 = variable$3;
var transform = function createTransform(cacheKey2, nurbs2, accessors, debug) {
  var i, j, iterator, iterators, terms, n, rvalue, lvalue;
  var cachedTransformer = transformerCache[cacheKey2];
  if (cachedTransformer) {
    return cachedTransformer.bind(nurbs2);
  }
  var code2 = [];
  var functionName = "transform" + cacheKey2;
  code2.push("function " + functionName + "(m) {");
  code2.push("var i, w;");
  code2.push(accessorPreamble$1(nurbs2, "x", "this.points", nurbs2.points));
  var sizeVar = variable$1(debug ? "size" : "s");
  for (i = 0; i < nurbs2.splineDimension; i++) {
    code2.push("var " + sizeVar(i) + " = " + sizeGetter$1(nurbs2.points, "this.points", i) + ";");
  }
  iterators = [];
  for (i = 0; i < nurbs2.splineDimension; i++) {
    iterator = "i" + i;
    iterators.push(iterator);
    code2.push("for (" + iterator + " = " + sizeVar(i) + "- 1; " + iterator + " >= 0; " + iterator + "--) {");
  }
  for (i = 0; i < nurbs2.dimension; i++) {
    code2.push("x" + i + " = " + accessors.point(iterators.concat([i])));
  }
  terms = [];
  for (i = 0; i < nurbs2.dimension; i++) {
    terms.push("m[" + ((nurbs2.dimension + 1) * (i + 1) - 1) + "] * x" + i);
  }
  terms.push("m[" + ((nurbs2.dimension + 1) * (nurbs2.dimension + 1) - 1) + "]");
  code2.push("var w = (" + terms.join(" + ") + ") || 1.0;");
  for (i = 0; i < nurbs2.dimension; i++) {
    terms = [];
    n = nurbs2.dimension;
    for (j = 0; j < n; j++) {
      terms.push("m[" + (j * (n + 1) + i) + "] * x" + j);
    }
    terms.push("m[" + (j * (n + 1) + i) + "]");
    lvalue = accessors.point(iterators.concat([i]));
    rvalue = "(" + terms.join(" + ") + ") / w";
    code2.push(lvalue + " = " + rvalue + ";");
  }
  for (i = nurbs2.splineDimension - 1; i >= 0; i--) {
    code2.push("}");
  }
  code2.push("return this;");
  code2.push("}");
  var transform2 = new Function([code2.join("\n"), "; return ", functionName].join(""))();
  if (debug)
    console.log(code2.join("\n"));
  transformerCache[cacheKey2] = transform2;
  return transform2.bind(nurbs2);
};
var ndloop2 = ndloop$2;
var variable = variable$3;
var accessorPreamble = accessorPreamble$3;
var inferType$1 = inferType_1;
var isArrayLike$1 = isArrayLike$5;
var sizeGetter = sizeGetter$3;
var supportCache = {};
var support = function(cacheKey2, nurbs2, accessors, debug, checkBounds) {
  var cachedSupport = supportCache[cacheKey2];
  if (cachedSupport) {
    return cachedSupport.bind(nurbs2);
  }
  var degree = nurbs2.degree;
  var knots = nurbs2.knots;
  var splineDimension = nurbs2.splineDimension;
  var boundary = nurbs2.boundary;
  var i, n, d;
  var code2 = [];
  var functionName = "support" + cacheKey2;
  var knotAccessor = accessors.knot;
  var tVar = variable("t");
  var domainVar = debug ? "domain" : "d";
  var sizeVar = variable(debug ? "size" : "s");
  var knotIndex = variable(debug ? "knotIndex" : "i");
  var allDimensionUniform = true;
  for (d = 0; d < splineDimension; d++) {
    if (isArrayLike$1(knots) && isArrayLike$1(knots[d])) {
      allDimensionUniform = false;
    }
  }
  function line2(str) {
    code2.push("  " + (str || ""));
  }
  var parameterArgs = [];
  for (i = 0; i < splineDimension; i++) {
    parameterArgs.push(tVar([i]));
  }
  code2.push("function " + functionName + " (out, " + parameterArgs.join(", ") + ") {");
  var c2 = 0;
  function pushSupport(args2, period) {
    if (period === void 0) {
      line2("out[" + c2++ + "] = " + args2.join(" + ") + ";");
    } else {
      line2("out[" + c2++ + "] = (" + args2.join(" + ") + " + " + period + ") % " + period + ";");
    }
  }
  line2("var h, m;");
  line2("var c = 0;");
  if (checkBounds) {
    line2("var " + domainVar + " = this.domain;");
    line2("for (var i = 0; i < this.splineDimension; i++) {");
    line2("  a = arguments[i + 1];");
    line2("  if (a < " + domainVar + "[i][0] || a > " + domainVar + "[i][1] || a === undefined || isNaN(a)) {");
    line2("    throw new Error('Invalid Spline parameter in dimension '+i+'. Valid domain is ['+" + domainVar + "[i][0]+', '+" + domainVar + "[i][1]+']. but got t'+i+' = '+arguments[i + 1]+'.');");
    line2("  }");
    line2("}");
  }
  for (d = 0; d < splineDimension; d++) {
    line2("var " + sizeVar(d) + " = " + sizeGetter(nurbs2.points, "this.points", d) + ";");
  }
  if (!allDimensionUniform) {
    code2.push(accessorPreamble(nurbs2, "k", "this.knots", knots));
  }
  var hasKnots = [];
  for (d = 0; d < splineDimension; d++) {
    switch (inferType$1(knots)) {
      case inferType$1.NDARRAY:
        hasKnots[d] = true;
        break;
      case inferType$1.ARRAY_OF_ARRAYS:
        hasKnots[d] = isArrayLike$1(knots[d]);
        break;
    }
  }
  for (d = 0; d < splineDimension; d++) {
    if (hasKnots[d]) {
      line2("var " + knotIndex(d) + " = 0;");
      line2("h = " + sizeVar(d) + ";");
      line2("while(h > " + knotIndex(d) + " + 1) {");
      line2("  m = 0.5 * (h + " + knotIndex(d) + ") | 0;");
      line2("  if (" + knotAccessor([d, "m"]) + " > " + tVar(d) + ") h = m;");
      line2("  else " + knotIndex(d) + " = m;");
      line2("}");
    } else {
      if (boundary[d] === "closed") {
        line2(knotIndex(d) + " = (" + tVar(d) + " | 0) % " + sizeVar(d) + ";");
      } else {
        line2(knotIndex(d) + " = (" + tVar(d) + " | 0);");
        line2("if (" + knotIndex(d) + " < " + degree[d] + ") " + knotIndex(d) + " = " + degree[d] + ";");
        line2("if (" + knotIndex(d) + " > " + sizeVar(d) + " - 1) " + knotIndex(d) + " = " + sizeVar(d) + " - 1;");
      }
    }
  }
  for (d = 0, n = []; d < splineDimension; d++) {
    n[d] = degree[d] + 1;
  }
  ndloop2(n, function(dst) {
    var readIdx = [];
    var period = [];
    for (var d2 = 0; d2 < splineDimension; d2++) {
      readIdx[d2] = [knotIndex(d2), dst[d2] - degree[d2]];
      if (boundary[d2] === "closed" && dst[d2] - degree[d2] < 0)
        period[d2] = sizeVar(d2);
    }
    for (d2 = 0; d2 < splineDimension; d2++) {
      pushSupport(readIdx[d2], period[d2]);
    }
  });
  line2("out.length = " + c2 + ";");
  line2("return out;");
  code2.push("}");
  if (debug)
    console.log(code2.join("\n"));
  var evaluator = new Function([code2.join("\n"), "; return ", functionName].join(""))();
  supportCache[cacheKey2] = evaluator;
  return evaluator.bind(nurbs2);
};
var inferType = inferType_1;
var computeCacheKey = cacheKey;
var isNdarray = isNdarray$2;
var isNdarrayLike = isNdarrayLike$3;
var createAccessors = createAccessors$1;
var numericalDerivative2 = numericalDerivative$1;
var isArrayLike2 = isArrayLike$5;
var createEvaluator = evaluate;
var createTransform2 = transform;
var createSupport = support;
var BOUNDARY_TYPES = {
  open: "open",
  closed: "closed",
  clamped: "clamped"
};
function isBlank(x) {
  return x === void 0 || x === null;
}
function parseNURBS(points, degree, knots, weights, boundary, opts) {
  var i, dflt;
  if (points && !isArrayLike2(points) && !isNdarray(points)) {
    opts = points;
    this.debug = points.debug;
    this.checkBounds = !!points.checkBounds;
    this.weights = points.weights;
    this.knots = points.knots;
    this.degree = points.degree;
    this.boundary = points.boundary;
    this.points = points.points;
    Object.defineProperty(this, "size", { value: opts.size, writable: true, configurable: true });
  } else {
    opts = opts || {};
    this.weights = weights;
    this.knots = knots;
    this.degree = degree;
    this.points = points;
    this.boundary = boundary;
    this.debug = opts.debug;
    this.checkBounds = !!opts.checkBounds;
    Object.defineProperty(this, "size", { value: opts.size, writable: true, configurable: true });
  }
  var pointType = inferType(this.points);
  var weightType = inferType(this.weights);
  var knotType = inferType(this.knots);
  if (this.points) {
    switch (pointType) {
      case inferType.GENERIC_NDARRAY:
      case inferType.NDARRAY:
        Object.defineProperties(this, {
          splineDimension: {
            value: this.points.shape.length - 1,
            writable: false,
            configurable: true
          },
          dimension: {
            value: this.points.shape[this.points.shape.length - 1],
            writable: false,
            configurable: true
          },
          size: {
            get: function() {
              return this.points.shape.slice(0, this.points.shape.length - 1);
            },
            set: function() {
              throw new Error("Cannot assign to read only property 'size'");
            },
            configurable: true
          }
        });
        break;
      case inferType.ARRAY_OF_ARRAYS:
        var splineDimension = 0;
        var size2 = this.size || [];
        size2.length = 0;
        for (var ptr = this.points; isArrayLike2(ptr[0]); ptr = ptr[0]) {
          splineDimension++;
          size2.push(ptr.length);
        }
        if (splineDimension === 0) {
          throw new Error("Expected an array of points");
        }
        Object.defineProperties(this, {
          splineDimension: {
            value: splineDimension,
            writable: false,
            configurable: true
          },
          dimension: {
            value: ptr.length,
            writable: false,
            configurable: true
          },
          size: {
            get: function() {
              var size3 = [];
              size3.length = 0;
              for (var i2 = 0, ptr2 = this.points; i2 < this.splineDimension; i2++, ptr2 = ptr2[0]) {
                size3[i2] = ptr2.length;
              }
              return size3;
            },
            set: function() {
              throw new Error("Cannot assign to read only property 'size'");
            },
            configurable: true
          }
        });
        break;
      case inferType.PACKED:
      default:
        throw new Error("Expected either a packed array, array of arrays, or ndarray of points");
    }
  } else {
    if (this.size === void 0 || this.size === null) {
      throw new Error("Either points or a control hull size must be provided.");
    }
    if (!isArrayLike2(this.size)) {
      Object.defineProperty(this, "size", {
        value: [this.size],
        writable: true,
        configurable: true
      });
    }
    if (this.size.length === 0) {
      throw new Error("`size` must be a number or an array of length at least one.");
    }
    Object.defineProperties(this, {
      splineDimension: {
        value: this.size.length,
        writable: false,
        configurable: true
      },
      dimension: {
        value: 0,
        writable: false,
        configurable: true
      }
    });
  }
  if (isArrayLike2(this.degree)) {
    for (i = 0; i < this.splineDimension; i++) {
      if (isBlank(this.degree[i])) {
        throw new Error("Missing degree in dimension " + (i + 1));
      }
    }
  } else {
    var hasBaseDegree = !isBlank(this.degree);
    var baseDegree = isBlank(this.degree) ? 2 : this.degree;
    this.degree = [];
    for (i = 0; i < this.splineDimension; i++) {
      if (this.size[i] <= baseDegree) {
        if (hasBaseDegree) {
          throw new Error("Expected at least " + (baseDegree + 1) + " points for degree " + baseDegree + " spline in dimension " + (i + 1) + " but got only " + this.size[i]);
        } else {
          this.degree[i] = this.size[i] - 1;
        }
      } else {
        this.degree[i] = baseDegree;
      }
    }
  }
  dflt = typeof this.boundary !== "string" ? "open" : this.boundary;
  if (!BOUNDARY_TYPES[dflt]) {
    throw new Error("Boundary type must be one of " + Object.keys(BOUNDARY_TYPES) + ". Got " + dflt);
  }
  this.boundary = isArrayLike2(this.boundary) ? this.boundary : [];
  this.boundary.length = this.splineDimension;
  for (i = 0; i < this.splineDimension; i++) {
    this.boundary[i] = isBlank(this.boundary[i]) ? dflt : this.boundary[i];
    if (!BOUNDARY_TYPES[dflt]) {
      throw new Error("Boundary type must be one of " + Object.keys(BOUNDARY_TYPES) + ". Got " + dflt + " for dimension " + (i + 1));
    }
  }
  switch (knotType) {
    case inferType.ARRAY_OF_ARRAYS:
      if (isArrayLike2(this.knots) && this.knots.length > 0 && !isArrayLike2(this.knots[0])) {
        this.knots = [this.knots];
      }
      for (i = 0; i < this.splineDimension; i++) {
        if (this.size[i] <= this.degree[i]) {
          throw new Error("Expected at least " + (this.degree[i] + 1) + " points in dimension " + (i + 1) + " but got " + this.size[i] + ".");
        }
        if (isArrayLike2(this.knots[i])) {
          if (this.boundary[i] !== "closed" && this.knots[i].length !== this.degree[i] + this.size[i] + 1) {
            throw new Error("Expected " + (this.degree[i] + this.size[i] + 1) + " knots in dimension " + (i + 1) + " but got " + this.knots[i].length + ".");
          } else if (this.boundary[i] === "closed" && this.knots[i].length !== this.size[i] + 1) {
            var canBeFudged = this.knots[i].length === this.size[i] + this.degree[i] + 1;
            if (!canBeFudged) {
              throw new Error("Expected " + (this.size[i] + 1) + " knots for closed spline in dimension " + (i + 1) + " but got " + this.knots[i].length + ".");
            }
          }
        }
      }
      break;
  }
  var newCacheKey = computeCacheKey(this, this.debug, this.checkBounds, pointType, weightType, knotType);
  if (newCacheKey !== this.__cacheKey) {
    this.__cacheKey = newCacheKey;
    var accessors = createAccessors(this);
    this.evaluate = createEvaluator(this.__cacheKey, this, accessors, this.debug, this.checkBounds, false);
    this.transform = createTransform2(this.__cacheKey, this, accessors, this.debug);
    this.support = createSupport(this.__cacheKey, this, accessors, this.debug, this.checkBounds);
    this.evaluator = function(derivativeOrder, isBasis) {
      return createEvaluator(this.__cacheKey, this, accessors, this.debug, this.checkBounds, isBasis, derivativeOrder);
    };
  }
  this.numericalDerivative = numericalDerivative2.bind(this);
  return this;
}
function domainGetter() {
  var sizeArray;
  var ret = [];
  var ptr = this.points;
  if (!ptr) {
    sizeArray = this.size;
  } else if (isNdarrayLike(ptr)) {
    sizeArray = ptr.shape;
  }
  for (var d = 0; d < this.splineDimension; d++) {
    var size2 = sizeArray ? sizeArray[d] : ptr.length;
    var p = this.degree[d];
    var isClosed = this.boundary[d] === "closed";
    if (this.knots && this.knots[d]) {
      var k = this.knots[d];
      ret[d] = [k[isClosed ? 0 : p], k[size2]];
    } else {
      ret[d] = [isClosed ? 0 : p, size2];
    }
    if (ptr)
      ptr = ptr[0];
  }
  return ret;
}
function nurbs(points, degree, knots, weights, boundary, opts) {
  var ctor = function(points2, degree2, knots2, weights2, boundary2, opts2) {
    parseFcn(points2, degree2, knots2, weights2, boundary2, opts2);
    return ctor;
  };
  var parseFcn = parseNURBS.bind(ctor);
  Object.defineProperty(ctor, "domain", {
    get: domainGetter
  });
  parseFcn(points, degree, knots, weights, boundary, opts);
  return ctor;
}
var nurbs_1 = nurbs;
class SplineModel extends SVGModel {
  getIcon() {
    return obj$2.star;
  }
  getDefaultObject(obj2 = {}) {
    return super.getDefaultObject(__spreadValues({
      itemType: "spline",
      name: "New Spline",
      strokeWidth: 1,
      points: [],
      traceCount: 100,
      degree: 2,
      boundary: "clamped"
    }, obj2));
  }
  get points() {
    return this.get("points");
  }
  set points(value) {
    this.set("points", value);
  }
  get degree() {
    return this.get("degree");
  }
  set degree(value) {
    this.set("degree", value);
  }
  get traceCount() {
    return this.get("traceCount");
  }
  set traceCount(value) {
    this.set("traceCount", value);
  }
  get boundary() {
    return this.get("boundary");
  }
  set boundary(value) {
    this.set("boundary", value);
  }
  enableHasChildren() {
    return false;
  }
  refreshMatrixCache() {
    super.refreshMatrixCache();
    if (this.hasChangedField("points", "boundary")) {
      this.setCache();
    } else if (this.hasChangedField("width", "height")) {
      if (!this.cachePath) {
        this.setCache();
      }
      this.points = this.cachePath.clone().scale(this.width / this.cacheWidth, this.height / this.cacheHeight).verties;
      this.modelManager.setChanged("reset", this.id, {
        points: this.points
      });
    }
  }
  setCache() {
    super.setCache();
    this.cachePath = PathParser.makePathByVerties(this.points);
    this.cacheWidth = this.width;
    this.cacheHeight = this.height;
  }
  get editablePath() {
    let { width: width2, height: height2, points } = this;
    if (!points || points.length == 0) {
      points = [
        [0, height2],
        [0, 0],
        [width2, 0],
        [width2, height2]
      ];
    }
    return this.absolutePath(PathParser.makePathByVerties(points).d).d;
  }
  recoverEditablePath(d) {
    const points = this.invertPath(d).verties;
    const pathData = this.updatePath(this.getPath(points));
    delete pathData.d;
    return __spreadValues({
      points
    }, pathData);
  }
  get d() {
    return this.getPath(this.points, this.boundary);
  }
  getPath(points, boundary) {
    let { width: width2, height: height2 } = this;
    if (!points) {
      points = this.points;
    }
    if (!boundary) {
      boundary = this.boundary;
    }
    if (!points || points.length == 0) {
      points = [
        [0, height2],
        [0, 0],
        [width2, 0],
        [width2, height2]
      ];
    }
    const curve = nurbs_1({
      points,
      degree: points.length - 2,
      boundary
    });
    const pt = [];
    const verties = [];
    const traceCount = (points.length - 1) * 100;
    const unit = 1 / traceCount;
    const d0 = curve.domain[0][0];
    const d1 = curve.domain[0][1];
    for (var t = 0; t <= 1; t += unit) {
      curve.evaluate(pt, d0 + (d1 - d0) * t);
      verties.push(clone(pt));
    }
    return PathParser.makePathByVerties(verties, false).round(1e3).d;
  }
  getDefaultTitle() {
    return "BSpline";
  }
}
class StarModel extends SVGModel {
  getIcon() {
    return obj$2.star;
  }
  getDefaultObject(obj2 = {}) {
    return super.getDefaultObject(__spreadValues({
      itemType: "star",
      name: "New Star",
      strokeWidth: 1,
      isCurve: false,
      count: 5,
      radius: 0.5,
      tension: 0.5
    }, obj2));
  }
  get count() {
    return this.get("count");
  }
  set count(value) {
    this.set("count", value);
  }
  get radius() {
    return this.get("radius");
  }
  set radius(value) {
    this.set("radius", value);
  }
  get tension() {
    return this.get("tension");
  }
  set tension(value) {
    this.set("tension", value);
  }
  get isCurve() {
    return this.get("isCurve");
  }
  convert(json) {
    json = super.convert(json);
    if (json.count)
      json.count = +json.count;
    if (json.radius)
      json.radius = +json.radius;
    if (json.tension)
      json.tension = +json.tension;
    return json;
  }
  enableHasChildren() {
    return false;
  }
  get d() {
    const { width: width2, height: height2, count, radius, tension, isCurve } = this;
    let newPath = "";
    if (isCurve) {
      newPath = PathParser.makeCurvedStar(width2, height2, count, radius, tension).d;
    } else {
      newPath = PathParser.makeStar(width2, height2, count, radius).d;
    }
    return newPath;
  }
  getDefaultTitle() {
    return "Star";
  }
}
class SVGTextItem extends SVGModel {
  getIcon() {
    return obj$2.title;
  }
  getDefaultObject(obj2 = {}) {
    return super.getDefaultObject(__spreadValues({
      itemType: "svg-text",
      name: "New Text",
      totalLength: 0,
      fill: "rgba(0, 0, 0, 1)",
      text: "Insert a text",
      fontWeight: Length.number(100),
      textLength: Length.em(0),
      lengthAdjust: "spacingAndGlyphs"
    }, obj2));
  }
  get text() {
    return this.get("text");
  }
  set text(value) {
    this.set("text", value);
  }
  get textLength() {
    return this.get("textLength");
  }
  set textLength(value) {
    this.set("textLength", value);
  }
  get lengthAdjust() {
    return this.get("lengthAdjust");
  }
  set lengthAdjust(value) {
    this.set("lengthAdjust", value);
  }
  enableHasChildren() {
    return false;
  }
  convert(json) {
    json = super.convert(json);
    json.textLength = Length.parse(json.textLength);
    return json;
  }
  getDefaultTitle() {
    return "Text";
  }
}
class SVGTextPathItem extends SVGModel {
  getIcon() {
    return obj$2.text_rotate;
  }
  getDefaultObject(obj2 = {}) {
    return super.getDefaultObject(__spreadValues({
      itemType: "svg-textpath",
      name: "New TextPath",
      d: "",
      totalLength: 0,
      fill: "rgba(0, 0, 0, 1)",
      text: "Insert a text",
      textLength: Length.em(0),
      lengthAdjust: "spacingAndGlyphs",
      startOffset: Length.em(0)
    }, obj2));
  }
  get d() {
    if (!this.get("d")) {
      return null;
    }
    if (!this.cachePath) {
      this.cachePath = new PathParser(this.get("d"));
      this.cacheWidth = this.width;
      this.cacheHeight = this.height;
    }
    return this.cachePath.clone().scale(this.width / this.cacheWidth, this.height / this.cacheHeight).d;
  }
  set d(value) {
    this.set("d", value);
  }
  get text() {
    return this.get("text");
  }
  set text(value) {
    this.set("text", value);
  }
  get textLength() {
    return this.get("textLength");
  }
  set textLength(value) {
    this.set("textLength", value);
  }
  get lengthAdjust() {
    return this.get("lengthAdjust");
  }
  set lengthAdjust(value) {
    this.set("lengthAdjust", value);
  }
  get startOffset() {
    return this.get("startOffset");
  }
  set startOffset(value) {
    this.set("startOffset", value);
  }
  enableHasChildren() {
    return false;
  }
  refreshMatrixCache() {
    super.refreshMatrixCache();
    if (this.hasChangedField("d")) {
      this.cachePath = new PathParser(this.get("d"));
      this.cacheWidth = this.width;
      this.cacheHeight = this.height;
    } else if (this.hasChangedField("width", "height")) {
      this.d = this.cachePath.clone().scale(this.width / this.cacheWidth, this.height / this.cacheHeight).d;
      this.modelManager.setChanged("reset", this.id, { d: this.d });
    }
  }
  convert(json) {
    json = super.convert(json);
    json.textLength = Length.parse(json.textLength);
    json.startOffset = Length.parse(json.startOffset);
    return json;
  }
  getDefaultTitle() {
    return "TextPath";
  }
}
class Component extends LayerModel {
  is(...itemType) {
    if (itemType.includes("component")) {
      return true;
    }
    return super.is(...itemType);
  }
  getProps() {
    return [];
  }
  static createComponent({
    iconString,
    title: title2 = "Unknown Title",
    attrs = {},
    enableHasChildren = false
  }) {
    return class extends Component {
      getIcon() {
        return iconString || iconUse("add");
      }
      getDefaultObject() {
        return super.getDefaultObject(__spreadValues({
          itemType: "NewComponent",
          name: "New Component"
        }, attrs));
      }
      enableHasChildren() {
        return enableHasChildren || false;
      }
      getDefaultTitle() {
        return title2;
      }
    };
  }
}
const DEFAULT_TEMPLATE = `
  <svg>
    <rect width="100%" height="100%" fill="black" />
  </svg>
`;
class TemplateModel extends Component {
  getIcon() {
    return obj$2.auto_awesome;
  }
  getDefaultObject(obj2 = {}) {
    return super.getDefaultObject(__spreadValues({
      itemType: "template",
      name: "New Template",
      engine: "dom",
      template: DEFAULT_TEMPLATE,
      params: []
    }, obj2));
  }
  get template() {
    return this.get("template");
  }
  set template(value) {
    this.set("template", value);
  }
  get params() {
    return this.get("params");
  }
  set params(value) {
    this.set("params", value);
  }
  get engine() {
    return this.get("engine");
  }
  set engine(value) {
    this.set("engine", value);
  }
  enableHasChildren() {
    return false;
  }
  getDefaultTitle() {
    return "Template";
  }
  editable(editablePropertyName) {
    switch (editablePropertyName) {
      case "font":
        return true;
    }
    return super.editable(editablePropertyName);
  }
}
class TextModel extends LayerModel {
  getIcon() {
    return obj$2.title;
  }
  getDefaultObject(obj2 = {}) {
    return super.getDefaultObject(__spreadValues({
      itemType: "text",
      name: "New Text",
      elementType: "p",
      content: ""
    }, obj2));
  }
  get content() {
    return this.get("content");
  }
  set content(value) {
    this.set("content", value);
  }
  enableHasChildren() {
    return false;
  }
  getDefaultTitle() {
    return "Text";
  }
  editable(editablePropertyName) {
    switch (editablePropertyName) {
      case "svg-item":
      case "transform":
      case "transformOrigin":
      case "perspective":
      case "perspectiveOrigin":
      case "layout":
        return false;
      case "font":
      case "fontSpacing":
      case "textStyle":
      case "textShadow":
      case "textFill":
      case "textClip":
      case "backgroundImage":
      case "box-model":
      case "border":
      case "borderRadius":
      case "backdropFilter":
      case "pattern":
        return true;
    }
    return super.editable(editablePropertyName);
  }
}
function defaultItems(editor) {
  editor.registerItem("project", Project);
  editor.registerItem("artboard", ArtBoard);
  editor.registerItem("rect", RectLayer);
  editor.registerItem("circle", CircleLayer);
  editor.registerItem("image", ImageLayer);
  editor.registerItem("text", TextModel);
  editor.registerItem("boolean-path", BooleanPathModel);
  editor.registerItem("svg-path", PathModel);
  editor.registerItem("svg-text", SVGTextItem);
  editor.registerItem("svg-textpath", SVGTextPathItem);
  editor.registerItem("template", TemplateModel);
  editor.registerItem("polygon", PolygonModel);
  editor.registerItem("star", StarModel);
  editor.registerItem("spline", SplineModel);
}
var texture = `
<svg xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 0 24 24" width="24px" fill="#000000">
    <path d="M19.51 3.08L3.08 19.51c.09.34.27.65.51.9.25.24.56.42.9.51L20.93 4.49c-.19-.69-.73-1.23-1.42-1.41zM11.88 3L3 11.88v2.83L14.71 3h-2.83zM5 3c-1.1 0-2 .9-2 2v2l4-4H5zm14 18c.55 0 1.05-.22 1.41-.59.37-.36.59-.86.59-1.41v-2l-4 4h2zm-9.71 0h2.83L21 12.12V9.29L9.29 21z"/>
</svg>
`;
var TextureView$1 = "";
const cssPatterns = [
  {
    itemType: "circle",
    name: "base",
    attrs: {
      backgroundColor: "#ececec"
    }
  },
  {
    itemType: "circle",
    name: "base",
    attrs: {
      backgroundColor: "black"
    }
  },
  {
    itemType: "circle",
    name: "base",
    attrs: {
      backgroundColor: "red"
    }
  },
  {
    itemType: "circle",
    name: "base",
    attrs: {
      backgroundImage: `
      background-image: linear-gradient(to right, #ececec, black 100%);
    `
    }
  },
  {
    itemType: "circle",
    name: "base",
    attrs: {
      backgroundImage: `
      background-image: linear-gradient(to right, #ececec, black 100%);
    `,
      border: `
      border:10px solid black;
    `
    }
  }
];
class CSSTextureView extends EditorElement {
  template() {
    return `
      <div class="pattern-list css-pattern-list" ref="$css-list"></div>
    `;
  }
  [LOAD("$css-list")]() {
    return cssPatterns.map((it, index2) => {
      const svg = this.$editor.renderer("svg").render(this.$model.createModel(__spreadValues({
        itemType: it.itemType,
        width: 70,
        height: 70
      }, it.attrs), false));
      return `<div class="pattern-item" data-index="${index2}"><div class="preview">${svg}</div></div>`;
    });
  }
  [CLICK("$css-list .pattern-item")](e) {
    const index2 = +e.$dt.data("index");
    const pattern = cssPatterns[index2];
    e.$dt.onlyOneClass("selected");
    this.$commands.emit("addLayerView", pattern.itemType, pattern.attrs);
  }
}
const svgPatterns = [
  {
    itemType: "svg-path",
    name: "path",
    attrs: {
      backgroundColor: "transparent",
      stroke: "black",
      "stroke-width": 2,
      d: PathParser.makeRect(0, 0, 80, 80).d
    }
  },
  {
    itemType: "svg-path",
    name: "line",
    attrs: {
      backgroundColor: "transparent",
      stroke: "black",
      "stroke-width": 2,
      d: PathParser.makeLine(0, 0, 80, 80).d
    }
  },
  {
    itemType: "svg-path",
    name: "line 2",
    attrs: {
      backgroundColor: "transparent",
      stroke: "black",
      "stroke-width": 2,
      fill: "#ececec",
      d: PathParser.makeLine(0, 80, 80, 0).d
    }
  },
  {
    itemType: "svg-path",
    name: "circle",
    attrs: {
      backgroundColor: "transparent",
      stroke: "black",
      "stroke-width": 2,
      fill: "#ececec",
      originWidth: 80,
      originHeight: 80,
      d: PathParser.makeCircle(0, 0, 80, 80).d
    }
  },
  {
    itemType: "polygon",
    name: "polygon - 3",
    attrs: {
      backgroundColor: "transparent",
      stroke: "black",
      "stroke-width": 2,
      fill: "#ececec",
      count: 3,
      originWidth: 80,
      originHeight: 80,
      d: PathParser.makePolygon(80, 80, 3).d
    }
  },
  {
    itemType: "polygon",
    name: "polygon - 4",
    attrs: {
      backgroundColor: "transparent",
      stroke: "black",
      "stroke-width": 2,
      fill: "#ececec",
      count: 4,
      originWidth: 80,
      originHeight: 80,
      d: PathParser.makePolygon(80, 80, 4).d
    }
  },
  {
    itemType: "polygon",
    name: "polygon - 4",
    attrs: {
      backgroundColor: "transparent",
      stroke: "black",
      "stroke-width": 2,
      fill: "#ececec",
      count: 5,
      originWidth: 80,
      originHeight: 80,
      d: PathParser.makePolygon(80, 80, 5).d
    }
  },
  {
    itemType: "polygon",
    name: "polygon - 4",
    attrs: {
      backgroundColor: "transparent",
      stroke: "black",
      "stroke-width": 2,
      fill: "#ececec",
      count: 6,
      originWidth: 80,
      originHeight: 80,
      d: PathParser.makePolygon(80, 80, 6).d
    }
  },
  {
    itemType: "polygon",
    name: "polygon - 4",
    attrs: {
      backgroundColor: "transparent",
      stroke: "black",
      "stroke-width": 2,
      fill: "#ececec",
      count: 7,
      originWidth: 80,
      originHeight: 80,
      d: PathParser.makePolygon(80, 80, 7).d
    }
  },
  {
    itemType: "polygon",
    name: "polygon - 4",
    attrs: {
      backgroundColor: "transparent",
      stroke: "black",
      "stroke-width": 2,
      fill: "#ececec",
      count: 12,
      originWidth: 80,
      originHeight: 80,
      d: PathParser.makePolygon(80, 80, 12).d
    }
  },
  {
    itemType: "star",
    name: "star - 5",
    attrs: {
      backgroundColor: "transparent",
      stroke: "black",
      "stroke-width": 2,
      fill: "#ececec",
      originWidth: 80,
      originHeight: 80,
      count: 5,
      radius: 0.5,
      d: PathParser.makeStar(80, 80, 5, 0.5).d
    }
  },
  {
    itemType: "star",
    name: "curved star - 5",
    attrs: {
      backgroundColor: "transparent",
      stroke: "black",
      "stroke-width": 2,
      fill: "#ececec",
      originWidth: 80,
      originHeight: 80,
      count: 5,
      radius: 0.5,
      d: PathParser.makeCurvedStar(80, 80, 5, 0.5).d
    }
  }
];
class SVGTextureView extends EditorElement {
  template() {
    return `
      <div class="pattern-list svg-pattern-list" ref="$svg-list"></div>
    `;
  }
  [LOAD("$svg-list")]() {
    return svgPatterns.map((it, index2) => {
      let d = it.attrs.d;
      if (d) {
        const path = PathParser.fromSVGString(d);
        if (it.attrs.originWidth) {
          path.scale(60 / it.attrs.originWidth, 60 / it.attrs.originHeight);
        } else {
          const rect2 = path.rect();
          path.scale(70 / rect2.width, 70 / rect2.height);
        }
        d = path.d;
      }
      const svg = this.$editor.renderer("svg").render(this.$model.createModel(__spreadProps(__spreadValues({
        itemType: it.itemType,
        width: 80,
        height: 80
      }, it.attrs), {
        d
      }), false));
      return `<div class="pattern-item" data-index="${index2}"><div class="preview">${svg}</div></div>`;
    });
  }
  [CLICK("$svg-list .pattern-item")](e) {
    const index2 = +e.$dt.data("index");
    const pattern = svgPatterns[index2];
    e.$dt.onlyOneClass("selected");
    this.$commands.emit("addLayerView", pattern.itemType, pattern.attrs);
  }
}
class TextureView extends EditorElement {
  template() {
    const isItemMode = this.$config.get("editor.design.mode") === "item";
    return /* @__PURE__ */ createElementJsx("div", {
      class: "elf--texture"
    }, /* @__PURE__ */ createElementJsx(Tabs, {
      ref: "$tab",
      selectedValue: isItemMode ? "svg" : "css",
      onchange: (value) => {
        this.$config.set("inspector.selectedValue", value);
      }
    }, isItemMode ? "" : /* @__PURE__ */ createElementJsx(TabPanel, {
      value: "css",
      title: "CSS"
    }, /* @__PURE__ */ createElementJsx("object", {
      refClass: "CSSTextureView",
      ref: "$css"
    })), /* @__PURE__ */ createElementJsx(TabPanel, {
      value: "svg",
      title: "SVG"
    }, /* @__PURE__ */ createElementJsx("object", {
      refClass: "SVGTextureView",
      ref: "$svg"
    }))));
  }
}
function defaultPatterns(editor) {
  editor.registerElement({
    TextureView,
    CSSTextureView,
    SVGTextureView
  });
  editor.registerUI("leftbar.tab", {
    TextureView: {
      value: "texture",
      title: "Texture",
      icon: texture,
      designMode: ["design", "item"]
    }
  });
  editor.registerUI("leftbar.tab.texture", {
    TextureView
  });
}
var DepthProperty$1 = "";
class OrderDown extends MenuItem {
  getIconString() {
    return "to_back";
  }
  getTitle() {
    return "To Back";
  }
  clickButton() {
    this.commands.executeCommand("send.backward", "send backward", this.$context.selection.current);
  }
}
class OrderFirst extends MenuItem {
  getIconString() {
    return "to_front";
  }
  getTitle() {
    return "To First";
  }
  clickButton() {
    this.$commands.executeCommand("send.back", "send back", this.$context.selection.current);
  }
}
class OrderLast extends MenuItem {
  getIconString() {
    return "to_back";
  }
  getTitle() {
    return "To Last";
  }
  clickButton() {
    this.$commands.executeCommand("bring.front", "bring front", this.$context.selection.current);
  }
}
class OrderTop extends MenuItem {
  getIconString() {
    return "to_front";
  }
  getTitle() {
    return "To Front";
  }
  clickButton() {
    this.commands.executeCommand("bring.forward", "bring forward", this.$context.selection.current);
  }
}
class DepthProperty extends BaseProperty {
  components() {
    return {
      OrderTop,
      OrderDown,
      OrderFirst,
      OrderLast
    };
  }
  getTitle() {
    return this.$i18n("alignment.property.title");
  }
  isHideHeader() {
    return true;
  }
  getBody() {
    return `
      <div class="elf--depth-item">
        ${createComponent("OrderTop")}
        ${createComponent("OrderDown")}
        ${createComponent("OrderFirst")}
        ${createComponent("OrderLast")}
      </div>
    `;
  }
}
function depth(editor) {
  editor.registerUI("inspector.tab.style", {
    DepthProperty
  });
}
var ExportProperty$1 = "";
class ExportProperty extends BaseProperty {
  getTitle() {
    return this.$i18n("export.property.title");
  }
  isFirstShow() {
    return true;
  }
  getClassName() {
    return "elf--export-property";
  }
  getBody() {
    return `
        <div class='export-item svg'>
          <label>SVG</label>
          <button ref='$svg'>${iconUse("archive")} ${this.$i18n("export.property.download")}</button>
        </div>
        <div class='export-item png'>
          <label>PNG</label>
          <button ref='$png'>${iconUse("archive")} ${this.$i18n("export.property.download")}</button>
        </div> 
      `;
  }
  [CLICK("$svg")]() {
    this.$commands.emit("downloadSVG");
  }
  [CLICK("$png")]() {
    this.$commands.emit("downloadPNG");
  }
}
function exportResource(editor) {
  editor.registerUI("inspector.tab.style", {
    ExportProperty
  });
}
var FillEditorView$1 = "";
const spreadMethodList = [
  SpreadMethodType.PAD,
  SpreadMethodType.REFLECT,
  SpreadMethodType.REPEAT
];
const TOOL_SIZE$1 = 20;
class FillBaseEditor extends EditorElement {
  initializeData() {
    const current = this.$context.selection.current;
    this.state.currentMatrix = current.matrix;
    this.state.imageResult = current.createFragmentMatrix(this.state.key);
    this.state.originalResult = current.createFragmentMatrix(this.state.key);
  }
}
class FillTimingStepEditor extends FillBaseEditor {
  [POINTERSTART("$el .step-point") + MOVE("moveStepPoint") + END("moveEndStepPoint")](e) {
    this.$el.toggleClass("dragging", true);
    this.initializeData();
    const colorStepIndex = +e.$dt.data("colorstep-index");
    this.localColorStep = this.state.imageResult.image.colorsteps[colorStepIndex];
    this.localColorStepTimingCount = this.localColorStep.timing.count;
    this.localColorCubicBezierTimingCount = this.localColorStep.timingCount;
  }
  moveStepPoint(dx, dy) {
    const dist$1 = (dx < 0 ? -1 : 1) * Math.ceil(dist([0, 0, 0], [dx, dy, 0]) / 10);
    switch (this.localColorStep.timing.name) {
      case TimingFunction.LINEAR:
        break;
      case TimingFunction.STEPS:
        this.localColorStep.timing.count = Math.max(this.localColorStepTimingCount + dist$1, 1);
        break;
      default:
        this.localColorStep.timingCount = Math.max(this.localColorCubicBezierTimingCount + dist$1, 1);
        break;
    }
    this.$commands.executeCommand("setAttribute", `change ${this.state.key} fragment`, this.$context.selection.packByValue({
      [this.state.key]: `${this.state.imageResult.image}`
    }));
  }
  makeTimingString(timing) {
    switch (timing.name) {
      case TimingFunction.LINEAR:
        return ``;
      case TimingFunction.EASE:
      case TimingFunction.EASE_IN:
      case TimingFunction.EASE_OUT:
      case TimingFunction.EASE_IN_OUT:
        return `${timing.name}`;
      default:
        return `cubic-bezier(${timing.x1}, ${timing.y1}, ${timing.x2}, ${timing.y2})`;
    }
  }
  moveEndStepPoint(dx, dy) {
    if (dx === 0 && dy === 0) {
      const { timing } = this.localColorStep;
      switch (timing.name) {
        case TimingFunction.STEPS:
          this.localColorStep.timing.direction = this.localColorStep.timing.direction === "start" ? "end" : "start";
          this.$commands.executeCommand("setAttribute", `change ${this.state.key} fragment`, this.$context.selection.packByValue({
            [this.state.key]: `${this.state.imageResult.image}`
          }));
          break;
        case TimingFunction.LINEAR:
          break;
        case TimingFunction.PATH:
          this.emit("showComponentPopup", {
            title: "Path Editor",
            width: 400,
            inspector: [
              {
                key: "path",
                editor: "path",
                editorOptions: {
                  height: 160
                },
                defaultValue: timing.d
              }
            ],
            changeEvent: (key, value) => {
              this.localColorStep.timing = parseOneValue(`path(${value})`).parsed;
              this.$commands.executeCommand("setAttribute", `change ${this.state.key} fragment`, this.$context.selection.packByValue({
                [this.state.key]: `${this.state.imageResult.image}`
              }));
            }
          });
          break;
        default:
          this.emit("showComponentPopup", {
            title: "Cubic Bezier",
            width: 220,
            inspector: [
              {
                key: "timing",
                editor: "cubic-bezier",
                editorOptions: {
                  isAnimating: false
                },
                defaultValue: this.makeTimingString(timing)
              }
            ],
            changeEvent: (key, value) => {
              this.localColorStep.timing = parseOneValue(value).parsed;
              this.$commands.executeCommand("setAttribute", `change ${this.state.key} fragment`, this.$context.selection.packByValue({
                [this.state.key]: `${this.state.imageResult.image}`
              }));
            }
          });
          this.$el.toggleClass("dragging", false);
          return;
      }
    }
    this.$commands.executeCommand("setAttribute", `change ${this.state.key} fragment`, this.$context.selection.packByValue({
      [this.state.key]: `${this.state.imageResult.image}`
    }));
    this.$el.toggleClass("dragging", false);
  }
}
class FillColorstepEditor extends FillTimingStepEditor {
  [KEYUP("$el .colorstep")](e) {
    const index2 = +e.$dt.data("index");
    switch (e.code) {
      case "Delete":
      case "Backspace":
        this.removeStep(index2);
        break;
      case "BracketRight":
        this.sortToRight(index2);
        break;
      case "BracketLeft":
        this.sortToLeft(index2);
        break;
      case "Equal":
        this.appendColorStep(index2);
        break;
      case "Minus":
        this.prependColorStep(index2);
        break;
    }
  }
  removeStep(currentIndex) {
    const image2 = this.state.imageResult.image;
    image2.removeColorStepByIndex(currentIndex);
    this.updateColorStepStatus(image2, -1);
  }
  sortToRight() {
    const image2 = this.state.imageResult.image;
    image2.sortToRight();
    this.updateColorStepStatus(image2, -1);
  }
  sortToLeft() {
    const image2 = this.state.imageResult.image;
    image2.sortToLeft();
    this.updateColorStepStatus(image2, -1);
  }
  appendColorStep(currentIndex) {
    const nextIndex = currentIndex + 1;
    const image2 = this.state.imageResult.image;
    const currentColorStep = image2.colorsteps[currentIndex];
    const nextColorStep = image2.colorsteps[nextIndex];
    let newIndex = -1;
    if (!nextColorStep) {
      if (currentColorStep.percent !== 100) {
        newIndex = image2.insertColorStep(currentColorStep.percent + (100 - currentColorStep.percent) / 2);
      }
    } else {
      newIndex = image2.insertColorStep(currentColorStep.percent + (nextColorStep.percent - currentColorStep.percent) / 2);
    }
    this.updateColorStepStatus(image2, newIndex);
  }
  prependColorStep(currentIndex) {
    const prevIndex = currentIndex - 1;
    const image2 = this.state.imageResult.image;
    const currentColorStep = image2.colorsteps[currentIndex];
    const prevColorStep = image2.colorsteps[prevIndex];
    let newIndex = -1;
    if (!prevColorStep) {
      if (currentColorStep.percent !== 0) {
        newIndex = image2.insertColorStep(currentColorStep.percent);
      }
    } else {
      newIndex = image2.insertColorStep(prevColorStep.percent + (currentColorStep.percent - prevColorStep.percent) / 2);
    }
    this.updateColorStepStatus(image2, newIndex);
  }
  [POINTERSTART("$el .point") + MOVE("movePoint") + END("moveEndPoint")](e) {
    this.$el.toggleClass("dragging", true);
    this.initializeData();
    const result = this.state.imageResult;
    this.pointTarget = e.$dt.data("type");
    this.startPoint = this.$viewport.applyVertex(result.startPoint);
    this.endPoint = this.$viewport.applyVertex(result.endPoint);
    this.dist = dist(this.startPoint, this.endPoint);
    if (result.shapePoint) {
      this.shapePoint = this.$viewport.applyVertex(result.shapePoint);
      this.shapeDist = dist(this.startPoint, this.shapePoint);
    }
  }
  calculateNextPoint(nextPoint) {
    if (this.$config.get("bodyEvent").shiftKey) {
      let tempStartPoint, tempEndPoint;
      if (this.pointTarget === "start") {
        tempStartPoint = this.endPoint;
        tempEndPoint = nextPoint;
      } else {
        tempStartPoint = this.startPoint;
        tempEndPoint = nextPoint;
      }
      const newDist = subtract([], tempEndPoint, tempStartPoint);
      let newAngle = calculateAngle360(newDist[0], newDist[1]) - 90;
      newAngle = (newAngle + 360) % 360;
      newAngle -= newAngle % this.$config.get("fixed.gradient.angle");
      nextPoint = vertiesMap([add$1([], tempStartPoint, [0, -this.dist, 0])], calculateRotationOriginMat4(newAngle, tempStartPoint))[0];
    }
    return nextPoint;
  }
  moveShapePoint(dx, dy) {
    const targetPoint = this.shapePoint;
    const nextPoint = this.calculateNextPoint(add$1([], targetPoint, [dx, dy, 0]));
    const width2 = this.state.currentMatrix.width;
    const height2 = this.state.currentMatrix.height;
    const image2 = this.state.imageResult.image;
    let newX, newY;
    switch (image2.type) {
      case GradientType.RADIAL:
        const dist$1 = dist(this.startPoint, nextPoint);
        const lastPoint = lerp([], this.startPoint, this.shapePoint, dist$1 / this.shapeDist);
        const [worldPosition] = vertiesMap([this.$viewport.applyVertexInverse(lastPoint)], this.state.currentMatrix.absoluteMatrixInverse);
        newX = Length.makePercent(worldPosition[0], width2);
        newY = Length.makePercent(worldPosition[1], height2);
        image2.reset({
          x3: newX,
          y3: newY
        });
        break;
    }
    this.$commands.executeCommand("setAttribute", `change ${this.state.key} fragment`, this.$context.selection.packByValue({
      [this.state.key]: `${this.state.imageResult.image}`
    }));
  }
  movePoint(dx, dy) {
    if (this.pointTarget === "shape") {
      return this.moveShapePoint(dx, dy);
    }
    const targetPoint = this.pointTarget === "start" ? this.startPoint : this.endPoint;
    let nextPoint = this.calculateNextPoint(add$1([], targetPoint, [dx, dy, 0]));
    var [worldPosition] = vertiesMap([this.$viewport.applyVertexInverse(nextPoint)], this.state.currentMatrix.absoluteMatrixInverse);
    const width2 = this.state.currentMatrix.width;
    const height2 = this.state.currentMatrix.height;
    const image2 = this.state.imageResult.image;
    switch (image2.type) {
      case GradientType.RADIAL:
        var newX, newY, newX2, newY2, newX3, newY3;
        if (this.pointTarget === "start") {
          newX = image2.x1.isPercent() ? Length.makePercent(worldPosition[0], width2) : Length.px(worldPosition[0]);
          newY = image2.y1.isPercent() ? Length.makePercent(worldPosition[1], height2) : Length.px(worldPosition[1]);
          const nextEndPoint = this.calculateNextPoint(add$1([], this.endPoint, [dx, dy, 0]));
          const [newEndPosition] = vertiesMap([this.$viewport.applyVertexInverse(nextEndPoint)], this.state.currentMatrix.absoluteMatrixInverse);
          newX2 = image2.x2.isPercent() ? Length.makePercent(newEndPosition[0], width2) : Length.px(newEndPosition[0]);
          newY2 = image2.y2.isPercent() ? Length.makePercent(newEndPosition[1], height2) : Length.px(newEndPosition[1]);
          const nextShapePoint = this.calculateNextPoint(add$1([], this.shapePoint, [dx, dy, 0]));
          const [newShapePosition] = vertiesMap([this.$viewport.applyVertexInverse(nextShapePoint)], this.state.currentMatrix.absoluteMatrixInverse);
          newX3 = image2.x3.isPercent() ? Length.makePercent(newShapePosition[0], width2) : Length.px(newShapePosition[0]);
          newY3 = image2.y3.isPercent() ? Length.makePercent(newShapePosition[1], height2) : Length.px(newShapePosition[1]);
          image2.reset({
            x1: newX,
            y1: newY,
            x2: newX2,
            y2: newY2,
            x3: newX3,
            y3: newY3
          });
        } else if (this.pointTarget === "end") {
          if (this.$config.get("bodyEvent").altKey) {
            const dist$1 = dist(this.startPoint, nextPoint);
            nextPoint = lerp([], this.startPoint, this.endPoint, dist$1 / this.dist);
            var [worldPosition] = vertiesMap([this.$viewport.applyVertexInverse(nextPoint)], this.state.currentMatrix.absoluteMatrixInverse);
          }
          newX = Length.makePercent(worldPosition[0], width2);
          newY = Length.makePercent(worldPosition[1], height2);
          image2.reset({
            x2: newX,
            y2: newY
          });
          const lastDist = dist(this.startPoint, nextPoint);
          const unitVector = lerp([], this.startPoint, nextPoint, 1 / lastDist);
          const nextShapePoint = lerp([], this.startPoint, vertiesMap([unitVector], calculateRotationOriginMat4(90, this.startPoint))[0], image2.radialType === RadialGradientType.CIRCLE ? lastDist : this.shapeDist);
          const [newShapePosition] = vertiesMap([this.$viewport.applyVertexInverse(nextShapePoint)], this.state.currentMatrix.absoluteMatrixInverse);
          newX3 = Length.makePercent(newShapePosition[0], width2);
          newY3 = Length.makePercent(newShapePosition[1], height2);
          image2.reset({
            x3: newX3,
            y3: newY3
          });
        }
        break;
      case GradientType.LINEAR:
        var newX, newY;
        if (this.pointTarget === "start") {
          newX = image2.x1.isPercent() ? Length.makePercent(worldPosition[0], width2) : Length.px(worldPosition[0]);
          newY = image2.y1.isPercent() ? Length.makePercent(worldPosition[1], height2) : Length.px(worldPosition[1]);
          image2.reset({
            x1: newX,
            y1: newY
          });
        } else if (this.pointTarget === "end") {
          newX = image2.x2.isPercent() ? Length.makePercent(worldPosition[0], width2) : Length.px(worldPosition[0]);
          newY = image2.y2.isPercent() ? Length.makePercent(worldPosition[1], height2) : Length.px(worldPosition[1]);
          image2.reset({
            x2: newX,
            y2: newY
          });
        }
        break;
    }
    this.$commands.executeCommand("setAttribute", `change ${this.state.key} fragment`, this.$context.selection.packByValue({
      [this.state.key]: `${this.state.imageResult.image}`
    }));
  }
  moveEndPoint(dx, dy) {
    const image2 = this.state.imageResult.image;
    const width2 = this.state.currentMatrix.width;
    const height2 = this.state.currentMatrix.height;
    if (dx === 0 && dy === 0) {
      switch (image2.type) {
        case GradientType.RADIAL:
          if (this.pointTarget === "start") {
            switch (image2.radialType) {
              case RadialGradientType.CIRCLE:
                image2.reset({
                  radialType: RadialGradientType.ELLIPSE
                });
                break;
              case RadialGradientType.ELLIPSE:
                const lastDist = dist(this.startPoint, this.endPoint);
                const unitVector = lerp([], this.startPoint, this.endPoint, 1 / lastDist);
                const nextShapePoint = lerp([], this.startPoint, vertiesMap([unitVector], calculateRotationOriginMat4(90, this.startPoint))[0], lastDist);
                const [newShapePosition] = vertiesMap([this.$viewport.applyVertexInverse(nextShapePoint)], this.state.currentMatrix.absoluteMatrixInverse);
                const x3 = Length.makePercent(newShapePosition[0], width2);
                const y3 = Length.makePercent(newShapePosition[1], height2);
                image2.reset({
                  radialType: RadialGradientType.CIRCLE,
                  x3,
                  y3
                });
                break;
            }
            break;
          }
        default:
          const index2 = spreadMethodList.findIndex((it) => image2.spreadMethod === it);
          const nextIndex = (index2 + 1) % spreadMethodList.length;
          image2.reset({
            spreadMethod: spreadMethodList[nextIndex]
          });
          break;
      }
    }
    this.emit("updateFillEditor", image2);
    this.$commands.executeCommand("setAttribute", `change ${this.state.key} fragment`, this.$context.selection.packByValue({
      [this.state.key]: `${image2}`
    }));
  }
  [POINTERSTART("$el .colorstep") + MOVE("moveColorStep") + END("moveEndColorStep")](e) {
    this.$el.toggleClass("dragging", true);
    this.state.hoverColorStep = null;
    this.initializeData();
    const $colorstep = e.$dt;
    this.$targetIndex = +$colorstep.data("index");
    if (e.altKey) {
      this.removeStep(this.$targetIndex);
      this.state.altKey = true;
      return;
    }
    const result = this.state.imageResult;
    switch (result.image.type) {
      case GradientType.RADIAL:
      case GradientType.LINEAR:
        this.startPoint = this.$viewport.applyVertex(result.startPoint);
        this.endPoint = this.$viewport.applyVertex(result.endPoint);
        const x = +$colorstep.data("x");
        const y = +$colorstep.data("y");
        this.screenXY = [x, y, 0];
        const dist2 = subtract([], this.endPoint, this.startPoint);
        const angle = calculateAngle360(dist2[0], dist2[1]) - 180;
        this.rotateInverse = calculateRotationOriginMat4(-angle, this.startPoint);
        break;
    }
  }
  moveColorStep(dx, dy) {
    if (this.state.altKey)
      return;
    const nextPoint = add$1([], this.screenXY, [dx, dy, 0]);
    const [baseStartPoint, baseEndPoint, baseNextPoint] = vertiesMap([this.startPoint, this.endPoint, nextPoint], this.rotateInverse);
    const result = this.state.imageResult;
    let newDist = 0;
    let baseDist = 0;
    switch (result.image.type) {
      case GradientType.RADIAL:
      case GradientType.LINEAR:
        var [s, e, n] = [baseStartPoint[0], baseEndPoint[0], baseNextPoint[0]];
        var baseDefaultDist = Math.abs(s - e);
        if (n < s) {
          newDist = -1 * Math.abs(n - s) / baseDefaultDist * 100;
        } else if (n > e) {
          newDist = Math.abs(n - s) / baseDefaultDist * 100;
        } else {
          newDist = (n - s) / baseDefaultDist * 100;
        }
        newDist = Math.max(0, Math.min(100, newDist));
        baseDist = baseDefaultDist;
        break;
    }
    const image2 = this.state.imageResult.image;
    image2.colorsteps[this.$targetIndex].setValue(newDist, baseDist);
    const targetColorStep = {
      color: image2.colorsteps[this.$targetIndex].color,
      percent: image2.colorsteps[this.$targetIndex].percent
    };
    const nextImage = this.state.originalResult.image;
    nextImage.colorsteps = image2.colorsteps.map((it) => {
      return it;
    });
    nextImage.sortColorStep();
    this.emit("updateFillEditor", nextImage, targetColorStep);
    this.$commands.executeCommand("setAttribute", `change ${this.state.key} fragment`, this.$context.selection.packByValue({
      [this.state.key]: `${nextImage}`
    }));
  }
  moveEndColorStep(dx, dy) {
    if (this.state.altKey) {
      this.state.altKey = false;
      return;
    }
    if (dx === 0 && dy === 0) {
      const image2 = this.state.imageResult.image;
      image2.colorsteps[this.$targetIndex].toggleTiming();
      const targetColorStep = {
        color: image2.colorsteps[this.$targetIndex].color,
        percent: image2.colorsteps[this.$targetIndex].percent
      };
      this.emit("updateFillEditor", image2, targetColorStep);
      this.$commands.executeCommand("setAttribute", "change background image", this.$context.selection.packByValue({
        [this.state.key]: `${image2}`
      }));
    }
    this.$el.toggleClass("dragging", false);
  }
  updateColorStepStatus(image2, index2) {
    this.initializeData();
    const { color: color2, percent } = image2.colorsteps[index2] || {};
    this.emit("updateFillEditor", image2, { color: color2, percent });
    this.$commands.executeCommand("setAttribute", "change background image", this.$context.selection.packByValue({
      [this.state.key]: `${image2}`
    }));
    this.state.hoverColorStep = null;
  }
  [POINTERSTART("$el .area-line")]() {
    const image2 = this.state.originalResult.image;
    const index2 = image2.insertColorStep(this.state.hoverColorStep.percent);
    this.updateColorStepStatus(image2, index2);
  }
  [POINTEROUT("$el .area-line")]() {
    if (this.state.hoverColorStep) {
      this.state.hoverColorStep = null;
      this.refresh();
    }
  }
  [POINTERMOVE("$el .area-line")](evt) {
    const nextPoint = this.$viewport.applyVertex(this.$viewport.getWorldPosition(evt));
    const image2 = this.state.originalResult.image;
    let baseStartPoint, baseEndPoint, baseNextPoint;
    switch (image2.type) {
      case GradientType.LINEAR:
      case GradientType.RADIAL:
        [baseStartPoint, baseEndPoint, baseNextPoint] = vertiesMap([this.state.startPoint, this.state.endPoint, nextPoint], this.state.rotateInverse);
        var [s, e, n] = [baseStartPoint[0], baseEndPoint[0], baseNextPoint[0]];
        var baseDefaultDist = Math.abs(s - e);
        var newDist;
        if (n < s) {
          newDist = -1 * Math.abs(n - s) / baseDefaultDist * 100;
        } else if (n > e) {
          newDist = Math.abs(n - s) / baseDefaultDist * 100;
        } else {
          newDist = (n - s) / baseDefaultDist * 100;
        }
        this.state.hoverColorStep = image2.pickColorStep(newDist);
        break;
    }
    this.refresh();
  }
}
class FillEditorView extends FillColorstepEditor {
  initState() {
    return {
      key: "",
      value: "",
      isShow: false
    };
  }
  template() {
    return /* @__PURE__ */ createElementJsx("div", {
      class: "elf--fill-editor-view"
    });
  }
  updateData() {
    this.trigger(this.state.onchange, this.state.key, this.state.value);
  }
  refresh() {
    if (this.state.isShow) {
      this.load();
    }
  }
  [SUBSCRIBE(UPDATE_VIEWPORT)]() {
    this.refresh();
  }
  [SUBSCRIBE(UPDATE_CANVAS) + DEBOUNCE(100)]() {
    if (this.$context.selection.current) {
      if (this.$context.selection.hasChangedField("x", "y", "width", "height", "angle", "fill", "stroke")) {
        this.refresh();
      }
    }
  }
  [SUBSCRIBE("showFillEditorView")](params = {}) {
    this.setState({
      key: params.key,
      isShow: true,
      onchange: params.onchange
    });
    this.$el.show();
    this.$context.commands.emit("push.mode.view", "FillEditorView");
  }
  [SUBSCRIBE("hideFillEditorView")]() {
    this.setState({
      key: "",
      isShow: false,
      onchange: null
    });
    this.$el.hide();
    this.$commands.emit("pop.mode.view", "FillEditorView");
  }
  makeTimingLine(timing, width2 = 10, startX = 0, startY = 0) {
    switch (timing.name) {
      case TimingFunction.LINEAR:
        return ``;
      case TimingFunction.STEPS:
        return /* @__PURE__ */ createElementJsx("path", {
          class: "timing",
          d: `
          M${startX + 0} ${startY + width2} 
          L${startX + width2 * 1 / 3} ${startY + width2} 
          L${startX + width2 * 1 / 3} ${startY + width2 * 2 / 3} 
          L${startX + width2 * 2 / 3} ${startY + width2 * 2 / 3} 
          L${startX + width2 * 2 / 3} ${startY + width2 * 1 / 3} 
          L${startX + width2} ${startY + width2 * 1 / 3} 
          L${startX + width2} ${startY + 0}           
        `
        });
      case TimingFunction.PATH:
        return /* @__PURE__ */ createElementJsx("path", {
          class: "timing",
          d: PathParser.fromSVGString(timing.d).scale(width2, width2).flipX().translate(0, width2).translate(startX, startY).d
        });
      default:
        return /* @__PURE__ */ createElementJsx("path", {
          class: "timing",
          d: `
          M${startX + 0} ${startY + width2} 
          C 
            ${startX + timing.x1 * width2} ${startY + width2 - timing.y1 * width2} 
            ${startX + timing.x2 * width2} ${startY + width2 - timing.y2 * width2}  
            ${startX + width2} ${startY + 0}
        `
        });
    }
  }
  makeTimingCircle(colorstepIndex, current, prev) {
    const prevStickScreenXY = prev.stickScreenXYInEnd;
    const stickScreenXY = current.stickScreenXYInStart;
    const { timing, timingCount } = current;
    let pos;
    switch (timing.name) {
      case TimingFunction.LINEAR:
        return ``;
      case TimingFunction.STEPS:
        pos = lerp([], prevStickScreenXY, stickScreenXY, 0.5);
        return /* @__PURE__ */ createElementJsx(FragmentInstance, null, /* @__PURE__ */ createElementJsx("circle", {
          class: "step-point",
          "data-colorstep-index": colorstepIndex,
          cx: pos[0],
          cy: pos[1],
          r: 7
        }), /* @__PURE__ */ createElementJsx("text", {
          x: pos[0],
          y: pos[1],
          dy: 4,
          "text-anchor": "middle"
        }, timing.count));
      default:
        pos = lerp([], prevStickScreenXY, stickScreenXY, 0.5);
        return /* @__PURE__ */ createElementJsx(FragmentInstance, null, /* @__PURE__ */ createElementJsx("circle", {
          class: "step-point",
          "data-colorstep-index": colorstepIndex,
          cx: pos[0],
          cy: pos[1],
          r: 7
        }), /* @__PURE__ */ createElementJsx("text", {
          x: pos[0],
          y: pos[1],
          dy: 4,
          "text-anchor": "middle"
        }, timingCount));
    }
  }
  makeTimingArea(colorstepIndex, current, prev, size2) {
    const prevStickScreenXY = prev.stickScreenXYInEnd;
    const stickScreenXY = current.stickScreenXYInStart;
    return /* @__PURE__ */ createElementJsx("g", {
      class: "timing-area"
    }, current.timing.name === TimingFunction.LINEAR ? `` : /* @__PURE__ */ createElementJsx("path", {
      class: "timing-path",
      d: `
              M ${prevStickScreenXY[0]} ${prevStickScreenXY[1]}
              L ${stickScreenXY[0]} ${stickScreenXY[1]}
            `
    }), this.makeTimingCircle(colorstepIndex, current, prev, size2));
  }
  makeGradientPoint(colorsteps, startPoint, endPoint, shapePoint, newHoverColorStepPoint) {
    const size2 = TOOL_SIZE$1;
    const dist2 = subtract([], endPoint, startPoint);
    const angle = calculateAngle360(dist2[0], dist2[1]) - 180;
    return /* @__PURE__ */ createElementJsx(FragmentInstance, null, colorsteps.map((it, index2) => {
      if (index2 === 0)
        return "";
      return this.makeTimingArea(index2, it, colorsteps[index2 - 1], TOOL_SIZE$1);
    }), colorsteps.map((it, index2) => {
      return /* @__PURE__ */ createElementJsx("g", {
        transform: `rotate(${angle} ${it.stickScreenXY[0]} ${it.stickScreenXY[1]})`
      }, /* @__PURE__ */ createElementJsx("rect", {
        id: it.id,
        "data-index": index2,
        class: "colorstep",
        x: it.stickScreenXY[0],
        y: it.stickScreenXY[1],
        width: size2,
        height: size2,
        fill: it.color,
        tabIndex: -1,
        "data-x": it.screenXY[0],
        "data-y": it.screenXY[1]
      }), this.makeTimingLine(it.timing, size2, it.stickScreenXY[0], it.stickScreenXY[1]));
    }), /* @__PURE__ */ createElementJsx("circle", {
      class: "point",
      "data-type": "start",
      cx: startPoint[0],
      cy: startPoint[1]
    }), /* @__PURE__ */ createElementJsx("circle", {
      class: "point",
      "data-type": "end",
      cx: endPoint[0],
      cy: endPoint[1]
    }), shapePoint && /* @__PURE__ */ createElementJsx("circle", {
      class: "point",
      "data-type": "shape",
      cx: shapePoint[0],
      cy: shapePoint[1]
    }), newHoverColorStepPoint && /* @__PURE__ */ createElementJsx("circle", {
      class: "hover-colorstep",
      r: "5",
      cx: newHoverColorStepPoint[0],
      cy: newHoverColorStepPoint[1],
      fill: this.state.hoverColorStep.color
    }));
  }
  makeStickPoint(colorsteps, startPoint, endPoint) {
    const size2 = TOOL_SIZE$1;
    const dist2 = subtract([], endPoint, startPoint);
    const angle = calculateAngle360(dist2[0], dist2[1]) - 180;
    const rotateInverse = calculateRotationOriginMat4(-angle, startPoint);
    const rotateInverseInverse = invert([], rotateInverse);
    return colorsteps.map((it) => {
      it.screenXY = this.$viewport.applyVertex(it.pos);
      const [newScreenXY] = vertiesMap([it.screenXY], rotateInverse);
      [it.stickScreenXY, it.stickScreenXYInStart, it.stickScreenXYInEnd] = vertiesMap([
        [newScreenXY[0] - size2 / 2, newScreenXY[1] - size2 * 1.5, 0],
        [
          newScreenXY[0] - size2 / 2,
          newScreenXY[1] - size2 * 1.5 + size2 / 2,
          0
        ],
        [
          newScreenXY[0] + size2 / 2,
          newScreenXY[1] - size2 * 1.5 + size2 / 2,
          0
        ]
      ], rotateInverseInverse);
      return it;
    });
  }
  makeRadialCenterPoint(result) {
    let startPoint, endPoint, shapePoint, colorsteps;
    startPoint = this.$viewport.applyVertex(result.startPoint);
    endPoint = this.$viewport.applyVertex(result.endPoint);
    shapePoint = this.$viewport.applyVertex(result.shapePoint);
    colorsteps = this.makeStickPoint(result.colorsteps, startPoint, endPoint);
    let newHoverColorStepPoint = null;
    if (this.state.hoverColorStep) {
      newHoverColorStepPoint = lerp([], startPoint, endPoint, this.state.hoverColorStep.percent / 100);
    }
    return /* @__PURE__ */ createElementJsx("svg", {
      class: "gradient-editor-area"
    }, /* @__PURE__ */ createElementJsx("path", {
      d: `
              M ${startPoint[0]} ${startPoint[1]}
              L ${endPoint[0]} ${endPoint[1]}
          `,
      class: "area-line"
    }), /* @__PURE__ */ createElementJsx("path", {
      d: `
              M ${startPoint[0]} ${startPoint[1]}
              L ${endPoint[0]} ${endPoint[1]}
          `,
      class: "start-end-line"
    }), /* @__PURE__ */ createElementJsx("path", {
      d: `
              M ${startPoint[0]} ${startPoint[1]}
              L ${shapePoint[0]} ${shapePoint[1]}
          `,
      class: "normal-line"
    }), this.makeGradientPoint(colorsteps, startPoint, endPoint, shapePoint, newHoverColorStepPoint));
  }
  makeLinearCenterPoint(result) {
    let startPoint, endPoint, colorsteps;
    startPoint = this.$viewport.applyVertex(result.startPoint);
    endPoint = this.$viewport.applyVertex(result.endPoint);
    colorsteps = this.makeStickPoint(result.colorsteps, startPoint, endPoint);
    let newHoverColorStepPoint = null;
    if (this.state.hoverColorStep) {
      newHoverColorStepPoint = lerp([], startPoint, endPoint, this.state.hoverColorStep.percent / 100);
    }
    return /* @__PURE__ */ createElementJsx("svg", {
      class: "gradient-editor-area"
    }, /* @__PURE__ */ createElementJsx("path", {
      d: `
            M ${startPoint[0]} ${startPoint[1]}
            L ${endPoint[0]} ${endPoint[1]}
          `,
      class: "area-line"
    }), /* @__PURE__ */ createElementJsx("path", {
      d: `
              M ${startPoint[0]} ${startPoint[1]}
              L ${endPoint[0]} ${endPoint[1]}
          `,
      class: "start-end-line"
    }), this.makeGradientPoint(colorsteps, startPoint, endPoint, null, newHoverColorStepPoint));
  }
  makeCenterPoint(result) {
    const { image: image2 } = result;
    switch (image2.type) {
      case GradientType.LINEAR:
        return this.makeLinearCenterPoint(result);
      case GradientType.RADIAL:
        return this.makeRadialCenterPoint(result);
    }
    return "";
  }
  [LOAD("$el") + DOMDIFF]() {
    if (!this.state.isShow)
      return "";
    const current = this.$context.selection.current;
    if (!current)
      return "";
    const result = current.createFragmentMatrix(this.state.key);
    this.state.result = result;
    this.state.originalResult = current.createFragmentMatrix(this.state.key);
    const image2 = result.image;
    let angle, dist2;
    switch (image2.type) {
      case GradientType.LINEAR:
        this.state.startPoint = this.$viewport.applyVertex(result.startPoint);
        this.state.endPoint = this.$viewport.applyVertex(result.endPoint);
        dist2 = subtract([], this.state.endPoint, this.state.startPoint);
        angle = calculateAngle360(dist2[0], dist2[1]) - 180;
        this.state.rotateInverse = calculateRotationOriginMat4(-angle, this.state.startPoint);
        break;
      case GradientType.RADIAL:
        this.state.startPoint = this.$viewport.applyVertex(result.startPoint);
        this.state.endPoint = this.$viewport.applyVertex(result.endPoint);
        this.state.shapePoint = this.$viewport.applyVertex(result.shapePoint);
        dist2 = subtract([], this.state.endPoint, this.state.startPoint);
        angle = calculateAngle360(dist2[0], dist2[1]) - 180;
        this.state.rotateInverse = calculateRotationOriginMat4(-angle, this.state.startPoint);
        break;
    }
    return /* @__PURE__ */ createElementJsx("div", null, this.makeCenterPoint(result));
  }
}
function fillEditorView(editor) {
  editor.registerUI("canvas.view", {
    FillEditorView
  });
}
var FilterProperty$1 = "";
const filter_list = [
  "blur",
  "grayscale",
  "hue-rotate",
  "invert",
  "brightness",
  "contrast",
  "drop-shadow",
  "opacity",
  "saturate",
  "sepia",
  "svg"
];
class FilterProperty extends BaseProperty {
  getTitle() {
    return this.$i18n("filter.property.title");
  }
  hasKeyframe() {
    return true;
  }
  isFirstShow() {
    return true;
  }
  afterRender() {
    this.show();
  }
  getKeyframeProperty() {
    return "filter";
  }
  getTitleClassName() {
    return "filter";
  }
  getBodyClassName() {
    return "no-padding";
  }
  getBody() {
    return `<div class='full filter-property' ref='$body'></div>`;
  }
  getTools() {
    return `
      <select class='filter-select' ref="$filterSelect">      
      </select>
      <button type="button" ref="$add" title="add Filter">${iconUse("add")}</button>
    `;
  }
  [CLICK("$add")]() {
    var filterType = this.refs.$filterSelect.value;
    this.children.$filterEditor.trigger("add", filterType);
  }
  [LOAD("$filterSelect")]() {
    var list2 = filter_list.map((it) => {
      return { title: this.$i18n(`filter.property.${it}`), value: it };
    });
    var svgFilterList = this.getSVGFilterList();
    var totalList = [];
    if (svgFilterList.length) {
      totalList = [...list2, { title: "-------", value: "" }, ...svgFilterList];
    } else {
      totalList = [...list2];
    }
    return totalList.map((it) => {
      var { title: title2, value } = it;
      return `<option value='${value}'>${title2}</option>`;
    });
  }
  getSVGFilterList() {
    var current = this.$context.selection.currentProject;
    var arr = [];
    if (current) {
      arr = current.svgfilters.map((it) => {
        var id = it.id;
        return {
          title: `svg - #${id}`,
          value: id
        };
      });
    }
    return arr;
  }
  [LOAD("$body") + DOMDIFF]() {
    var current = this.$context.selection.current || {};
    var value = current.filter;
    return createComponent("FilterEditor", {
      ref: "$filterEditor",
      key: "filter",
      value: clone$1(value),
      onchange: "changeFilterEditor"
    });
  }
  [SUBSCRIBE_SELF("changeFilterEditor")](key, filter2) {
    this.$commands.executeCommand("setAttribute", "change filter", this.$context.selection.packByValue({
      [key]: clone$1(filter2)
    }));
  }
  get editableProperty() {
    return "filter";
  }
  [SUBSCRIBE(REFRESH_SELECTION) + IF("checkShow") + DEBOUNCE(100)]() {
    this.refresh();
  }
  [SUBSCRIBE("refreshSVGArea") + DEBOUNCE(100)]() {
    this.load("$filterSelect");
  }
}
function filter(editor) {
  editor.registerUI("inspector.tab.style", {
    FilterProperty
  });
}
function font(editor) {
  editor.registerUI("inspector.tab.style", {
    FontProperty: ObjectProperty.create({
      title: editor.$i18n("font.property.title"),
      editableProperty: "font",
      preventUpdate: true
    })
  });
  editor.registerInspector("font", (current) => {
    return [
      {
        key: "font-family",
        editor: "SelectEditor",
        editorOptions: {
          compact: true,
          label: "font_download",
          options: [
            "",
            "Arial",
            "Arial Black",
            "Times New Roman",
            "Times",
            "Courier New",
            "Courier",
            "Verdana",
            "Georgia",
            "Palatino",
            "Garamond",
            "Bookman",
            "Tahoma",
            "Trebuchet MS",
            "Impact",
            "Comic Sans MS",
            "serif",
            "sans-serif",
            "monospace",
            "cursive",
            "fantasy",
            "system-ui"
          ]
        },
        defaultValue: current.fontFamily || ""
      },
      {
        type: "column",
        size: [1, 1],
        gap: 10,
        columns: [
          {
            key: "font-size",
            editor: "NumberInputEditor",
            editorOptions: {
              label: "format_size",
              compact: true,
              min: 8,
              max: 1e3,
              step: 1
            },
            defaultValue: Length.parse(current.fontSize).value,
            convert: (key, value) => Length.px(value)
          },
          {
            key: "padding",
            editor: "NumberInputEditor",
            editorOptions: {
              label: "padding",
              compact: true,
              min: 8,
              max: 1e3,
              step: 1
            },
            defaultValue: Length.parse(current.paddingTop).value,
            convert: (key, value) => Length.px(value)
          }
        ]
      },
      {
        type: "column",
        size: [1, 1],
        columns: [
          {
            key: "color",
            editor: "ColorViewEditor",
            editorOptions: {
              compact: true
            },
            defaultValue: current.color || "#000"
          },
          {
            key: "font-weight",
            editor: "NumberInputEditor",
            editorOptions: {
              label: "format_bold",
              compact: true,
              min: 100,
              max: 900,
              step: 100
            },
            defaultValue: current.fontWeight || 400
          }
        ]
      },
      {
        type: "column",
        size: [1, 1, 1],
        gap: 10,
        columns: [
          {
            key: "text-indent",
            editor: "NumberInputEditor",
            editorOptions: {
              label: "format_indent",
              min: -100,
              max: 100,
              step: 1,
              compact: true
            },
            defaultValue: Length.parse(current.textIndent).value,
            convert: (key, value) => Length.px(value)
          },
          {
            key: "line-height",
            editor: "NumberInputEditor",
            editorOptions: {
              label: "format_line_spacing",
              min: 0,
              max: 10,
              step: 0.01,
              compact: true
            },
            defaultValue: current.lineHeight || 1.2
          },
          {
            key: "letter-spacing",
            editor: "NumberInputEditor",
            editorOptions: {
              label: "space",
              min: -100,
              max: 100,
              step: 1,
              compact: true
            },
            defaultValue: Length.parse(current.letterSpacing).value,
            convert: (key, value) => Length.px(value)
          }
        ]
      }
    ];
  });
}
var FillEditor$1 = "";
class FillEditor extends EditorElement {
  initState() {
    var _a;
    const image2 = SVGFill.parseImage(this.props.value || "transparent") || SVGStaticGradient.create();
    const id = (_a = image2.colorsteps[this.props.index]) == null ? void 0 : _a.id;
    this.$context.selection.selectColorStep(id);
    if (id) {
      this.currentStep = image2.colorsteps.find((it) => this.$context.selection.isSelectedColorStep(it.id));
    }
    return {
      cachedRect: null,
      index: +(this.props.index || 0),
      value: this.props.value,
      image: image2
    };
  }
  setValue(value) {
    this.setState({
      cachedRect: null,
      image: SVGFill.parseImage(value)
    }, false);
    this.refresh();
  }
  template() {
    return `
        <div class='elf--fill-editor'>
            <div class='gradient-steps' data-editor='gradient'>
                <div class="hue-container" ref="$back"></div>            
                <div class="hue" ref="$steps">
                    <div class='step-list' ref="$stepList" ></div>
                </div>
            </div>               
            <div class='sub-editor' ref='$subEditor'> 
                <div data-editor='patternUnits'>
                  ${createComponent("SelectEditor", {
      label: "Pattern",
      ref: "$patternUnits",
      options: ["userSpaceOnUse"],
      key: "patternUnits",
      onchange: "changeKeyValue"
    })}
                </div>                  
                                                                                                                                
            </div>            
        </div>
      `;
  }
  getImageFieldValue(image2, field) {
    var value = image2[field];
    if (isUndefined(value)) {
      switch (field) {
        case "cx":
        case "cy":
        case "r":
        case "fx":
        case "fy":
          return "50%";
        case "x1":
        case "y1":
        case "y2":
        case "fr":
        case "imageX":
        case "imageY":
          return "0%";
        case "x2":
        case "patternWidth":
        case "patternHeight":
        case "imageWidth":
        case "imageHeight":
          return "100%";
      }
    }
    return value;
  }
  [CHANGE("$file")](e) {
    var project2 = this.$context.selection.currentProject;
    if (project2) {
      [...e.target.files].forEach((item) => {
        this.$commands.emit("updateImageAssetItem", item, (local) => {
          this.trigger("setImageUrl", local);
        });
      });
    }
  }
  refreshFieldValue() {
    this.children.$cx.setValue(this.state.image.cx);
    this.children.$cy.setValue(this.state.image.cy);
    this.children.$r.setValue(this.state.image.r);
    this.children.$fx.setValue(this.state.image.fx);
    this.children.$fy.setValue(this.state.image.fy);
    this.children.$fr.setValue(this.state.image.fr);
    this.children.$patternUnits.setValue(this.state.image.patternUnits);
    this.children.$patternWidth.setValue(this.state.image.patternWidth);
    this.children.$patternHeight.setValue(this.state.image.patternHeight);
    this.children.$imageX.setValue(this.state.image.imageX);
    this.children.$imageY.setValue(this.state.image.imageY);
    this.children.$imageWidth.setValue(this.state.image.imageWidth);
    this.children.$imagenHeight.setValue(this.state.image.imageHeight);
  }
  getFieldValue(field) {
    return Length.parse(this.getImageFieldValue(this.state.image, field));
  }
  getRectRate(rect2, x, y) {
    var { width: width2, height: height2, x: rx, y: ry } = rect2;
    if (rx > x) {
      x = rx;
    } else if (rx + width2 < x) {
      x = rx + width2;
    }
    if (ry > y) {
      y = ry;
    } else if (ry + height2 < y) {
      y = ry + height2;
    }
    var left2 = Length.makePercent(x - rx, width2);
    var top2 = Length.makePercent(y - ry, height2);
    return { left: left2, top: top2 };
  }
  [SUBSCRIBE_SELF("changeTabType")](type) {
    var _a, _b;
    const oldType = (_a = this.state.image) == null ? void 0 : _a.type;
    const colorsteps = ((_b = this.state.image) == null ? void 0 : _b.colorsteps) || [];
    if (colorsteps.length === 1) {
      colorsteps.push(colorsteps[0]);
    }
    if (oldType === GradientType.STATIC) {
      if (colorsteps.length === 0) {
        colorsteps.push(colorsteps[0], colorsteps[0]);
      } else if (colorsteps.length === 1) {
        colorsteps.push(colorsteps[0]);
      }
    }
    var url = type === "image-resource" ? this.state.image.url : this.state.url;
    this.state.image = SVGFill.changeImageType({
      type,
      url,
      colorsteps,
      spreadMethod: this.state.image.spreadMethod
    });
    this.refresh();
    this.updateData();
  }
  [SUBSCRIBE_SELF("changeKeyValue")](key, value) {
    this.state.image.reset({
      [key]: value
    });
    this.updateData();
  }
  [SUBSCRIBE("changeColorStepOffset")](key, value) {
    if (this.currentStep) {
      this.currentStep.percent = value.value;
      this.state.image.sortColorStep();
      this.refresh();
      this.updateData();
    }
  }
  [CLICK("$back")](e) {
    var rect2 = this.refs.$stepList.rect();
    var minX = rect2.x;
    var maxX = rect2.right;
    var x = e.xy.x;
    if (x < minX)
      x = minX;
    else if (x > maxX)
      x = maxX;
    var percent = (x - minX) / rect2.width * 100;
    this.state.image.insertColorStep(percent);
    this.state.image.sortColorStep();
    this.refresh();
    this.updateData();
  }
  [BIND("$el")]() {
    var type = this.state.image.type;
    if (type === "url") {
      type = "image-resource";
    }
    return {
      "data-selected-editor": type
    };
  }
  [BIND("$stepList")]() {
    return {
      style: {
        "background-image": this.getLinearGradient()
      }
    };
  }
  [LOAD("$stepList")]() {
    var colorsteps = this.state.image.colorsteps || [];
    return colorsteps.map((it) => {
      var selected = this.$context.selection.isSelectedColorStep(it.id) ? "selected" : "";
      return `
      <div class='step ${selected}' data-id='${it.id}' data-cut='${it.cut}' tabindex="-1" style='left: ${it.toLength()};'>
        <div class='color-view' style="background-color: ${it.color}">
          <span>${Math.floor(it.percent * 10) / 10}</span>
        </div>
        <div class='arrow'></div>
      </div>`;
    });
  }
  removeStep(id) {
    this.state.image.removeColorStep(id);
    this.refresh();
    this.updateData();
  }
  selectStep(id) {
    this.state.id = id;
    this.$context.selection.selectColorStep(id);
    if (this.state.image.colorsteps) {
      this.currentStep = this.state.image.colorsteps.find((it) => this.$context.selection.isSelectedColorStep(it.id));
      this.parent.trigger("selectColorStep", this.currentStep.color);
    }
    this.refresh();
  }
  [KEYUP("$el .step")](e) {
    const id = e.$dt.data("id");
    switch (e.code) {
      case "Delete":
      case "Backspace":
        this.removeStep(id);
        break;
      case "BracketRight":
        this.sortToRight(id);
        break;
      case "BracketLeft":
        this.sortToLeft(id);
        break;
      case "Equal":
        this.appendColorStep(id);
        break;
      case "Minus":
        this.prependColorStep(id);
        break;
    }
  }
  sortToRight(id) {
    this.state.image.sortToRight();
    this.refresh();
    this.updateData();
    this.doFocus(id);
  }
  sortToLeft(id) {
    this.state.image.sortToLeft();
    this.refresh();
    this.updateData();
    this.doFocus(id);
  }
  appendColorStep(id) {
    const currentIndex = this.state.image.colorsteps.findIndex((it) => it.id === id);
    const nextIndex = currentIndex + 1;
    const currentColorStep = this.state.image.colorsteps[currentIndex];
    const nextColorStep = this.state.image.colorsteps[nextIndex];
    if (!nextColorStep) {
      if (currentColorStep.percent !== 100) {
        this.state.image.insertColorStep(currentColorStep.percent + (100 - currentColorStep.percent) / 2);
      }
    } else {
      this.state.image.insertColorStep(currentColorStep.percent + (nextColorStep.percent - currentColorStep.percent) / 2);
    }
    this.refresh();
    this.updateData();
    this.doFocus(id);
  }
  doFocus(id) {
    this.nextTick(() => {
      this.refs.$stepList.$(".step[data-id='" + id + "']").focus();
    }, 100);
  }
  prependColorStep(id) {
    const currentIndex = this.state.image.colorsteps.findIndex((it) => it.id === id);
    const prevIndex = currentIndex - 1;
    const currentColorStep = this.state.image.colorsteps[currentIndex];
    const prevColorStep = this.state.image.colorsteps[prevIndex];
    if (!prevColorStep) {
      if (currentColorStep.percent !== 0) {
        this.state.image.insertColorStep(currentColorStep.percent);
      }
    } else {
      this.state.image.insertColorStep(prevColorStep.percent + (currentColorStep.percent - prevColorStep.percent) / 2);
    }
    this.refresh();
    this.updateData();
    this.doFocus(id);
  }
  [POINTERSTART("$stepList .step") + MOVE() + END()](e) {
    var id = e.$dt.attr("data-id");
    if (e.altKey) {
      this.removeStep(id);
      return false;
    } else {
      e.$dt.focus();
      this.isSelectedColorStep = this.$context.selection.isSelectedColorStep(id);
      this.selectStep(id);
      this.startXY = e.xy;
      this.cachedStepListRect = this.refs.$stepList.rect();
    }
  }
  getStepListRect() {
    return this.cachedStepListRect;
  }
  move(dx) {
    var rect2 = this.getStepListRect();
    var minX = rect2.x;
    var maxX = rect2.right;
    var x = this.startXY.x + dx;
    if (x < minX)
      x = minX;
    else if (x > maxX)
      x = maxX;
    var percent = (x - minX) / rect2.width * 100;
    if (this.$config.get("bodyEvent").shiftKey) {
      percent = Math.floor(percent);
    }
    this.currentStep.percent = percent;
    this.state.image.sortColorStep();
    this.refresh();
    this.updateData();
  }
  end(dx, dy) {
    if (dx === 0 && dy === 0) {
      if (this.isSelectedColorStep) {
        if (this.currentStep) {
          this.currentStep.cut = !this.currentStep.cut;
          this.refresh();
          this.updateData();
        }
      }
    }
    this.doFocus(this.state.id);
  }
  getLinearGradient() {
    var { image: image2 } = this.state;
    return `linear-gradient(to right, ${Gradient.toCSSColorString(image2.colorsteps)})`;
  }
  [SUBSCRIBE_SELF("setColorStepColor")](color2) {
    if (this.state.image.type === "static-gradient") {
      this.state.image.setColor(color2);
      this.refresh();
      this.updateData();
    } else {
      if (this.currentStep) {
        this.currentStep.color = color2;
        this.refresh();
        this.updateData();
      }
    }
  }
  [SUBSCRIBE("setImageUrl")](url, datauri) {
    if (this.state.image) {
      this.state.url = url;
      this.state.image.reset({ url, datauri });
      this.refresh();
      this.updateData();
    }
  }
  updateData(data = {}) {
    this.setState(data, false);
    this.parent.trigger(this.props.onchange, this.state.image.toString());
  }
}
var GradientPickerPopup$1 = "";
class GradientPickerPopup extends BasePopup {
  getTitle() {
    var _a;
    return createComponent("SelectEditor", {
      ref: "$select",
      value: ((_a = this.state.image) == null ? void 0 : _a.type) || GradientType.STATIC,
      onchange: "changeTabType",
      options: [
        {
          value: GradientType.STATIC,
          text: "Static"
        },
        {
          value: GradientType.LINEAR,
          text: "Linear Gradient"
        },
        {
          value: GradientType.RADIAL,
          text: "Radial Gradient"
        },
        {
          value: GradientType.CONIC,
          text: "Conic Gradient"
        },
        {
          value: GradientType.REPEATING_LINEAR,
          text: "Repeating Linear Gradient"
        },
        {
          value: GradientType.REPEATING_RADIAL,
          text: "Repeating Radial Gradient"
        },
        {
          value: GradientType.REPEATING_CONIC,
          text: "Repeating Conic Gradient"
        },
        {
          value: GradientType.URL,
          text: "Image"
        }
      ]
    });
  }
  initialize() {
    super.initialize();
    this.selectedTab = "static-gradient";
  }
  getClassName() {
    return "fill-picker-popup";
  }
  getBody() {
    var _a, _b;
    return `
      <div class="elf--gradient-picker-popup" ref='$body' data-selected-editor='${(_a = this.state.image) == null ? void 0 : _a.type}'>
        <div class='box'>
          <div ref='$gradientEditor'></div>
        </div>
        <div class='box'>
          <div class='colorpicker'>
            ${createComponent("EmbedColorPicker", {
      ref: "$color",
      onchange: "changeColor"
    })}
          </div>
          <div class='assetpicker'>
            ${createComponent("ImageSelectEditor", {
      ref: "$image",
      key: "image",
      value: (_b = this.state.image) == null ? void 0 : _b.url,
      onchange: "changeImageUrl"
    })}
            ${createComponent("ImageAssetPicker", {
      ref: "$asset",
      onchange: "changeImageUrl"
    })}
          </div>
        </div>
      </div>
     
    `;
  }
  getColorString() {
    var value = "";
    if (this.state.image instanceof Gradient) {
      value = this.state.image.getColorString();
    }
    return value;
  }
  getCurrentColor() {
    return this.state.image.colorsteps[this.state.selectColorStepIndex || 0].color;
  }
  [BIND("$body")]() {
    var _a;
    return {
      "data-selected-editor": (_a = this.state.image) == null ? void 0 : _a.type
    };
  }
  [LOAD("$gradientEditor") + DOMDIFF]() {
    var _a;
    if (((_a = this.state.image) == null ? void 0 : _a.type) === GradientType.URL) {
      return "";
    }
    return createComponent("GradientEditor", {
      ref: "$g",
      value: `${this.state.image ? this.state.image.toString() : ""}`,
      index: this.state.selectColorStepIndex,
      onchange: "changeGradientEditor"
    });
  }
  [SUBSCRIBE("updateGradientEditor")](data, targetColorStep) {
    this.state.image = isString(data) ? BackgroundImage.parseImage(data) : data;
    this.state.selectColorStepIndex = this.state.image.colorsteps.findIndex((it) => it.color === targetColorStep.color && it.percent === targetColorStep.percent);
    this.children.$color.setValue(targetColorStep.color);
    this.refresh();
  }
  [SUBSCRIBE_SELF("changeGradientEditor")](data) {
    this.state.image = isString(data) ? BackgroundImage.parseImage(data) : data;
    this.updateTitle();
    this.updateData();
  }
  [SUBSCRIBE_SELF("changeTabType")](key, type) {
    this.children.$g.trigger("changeTabType", type);
    this.refs.$body.attr("data-selected-editor", type);
  }
  [SUBSCRIBE_SELF("changeColor")](color2) {
    this.children.$g.trigger("setColorStepColor", color2);
  }
  [SUBSCRIBE_SELF("changeImageUrl")](key, url) {
    if (this.state.image) {
      this.state.image.reset({
        url
      });
      this.trigger("changeGradientEditor", this.state.image);
    }
  }
  updateTitle() {
    this.children.$select.setValue(this.state.image.type);
  }
  [SUBSCRIBE("showGradientPickerPopup")](data, params, rect2) {
    data.changeEvent = data.changeEvent || "changeFillPopup";
    data.image = data.gradient;
    data.params = params;
    this.showByRect(this.makeRect(248, 560, rect2));
    this.setState(data);
    this.updateTitle();
    this.emit("showGradientEditorView", {
      index: data.index
    });
  }
  [SUBSCRIBE("hideGradientickerPopup")]() {
    this.hide();
    this.emit("hideGradientEditorView");
  }
  onClose() {
    this.emit("hideGradientEditorView");
  }
  [SUBSCRIBE("selectColorStep")](color2) {
    this.children.$color.setValue(color2);
  }
  [SUBSCRIBE("changeColorStep")](data = {}) {
    this.state.image.reset(__spreadValues({}, data));
    this.updateData();
  }
  load(...args2) {
    if (this.$el.isShow()) {
      super.load(...args2);
    }
  }
  getValue() {
    return `${this.state.image}`;
  }
  updateData() {
    this.state.instance.trigger(this.state.changeEvent, this.getValue(), this.state.params);
  }
}
class FillPickerPopup extends BasePopup {
  getTitle() {
    var _a;
    return createComponent("SelectEditor", {
      ref: "$select",
      value: ((_a = this.state.image) == null ? void 0 : _a.type) || GradientType.STATIC,
      onchange: "changeTabType",
      options: [
        {
          value: GradientType.STATIC,
          text: "Static"
        },
        {
          value: GradientType.LINEAR,
          text: "Linear Gradient"
        },
        {
          value: GradientType.RADIAL,
          text: "Radial Gradient"
        },
        {
          value: GradientType.URL,
          text: "Image"
        }
      ]
    });
  }
  initState() {
    return {
      image: SVGStaticGradient.create()
    };
  }
  initialize() {
    super.initialize();
    this.selectedTab = "static-gradient";
  }
  getClassName() {
    return "fill-picker-popup";
  }
  getBody() {
    var _a, _b;
    return `
      <div class="elf--gradient-picker-popup" ref='$body' data-selected-editor='${(_a = this.state.image) == null ? void 0 : _a.type}'>
        <div class='box'>
          <div ref='$gradientEditor'></div>
        </div>
        <div class='box'>
          <div class='colorpicker'>
            ${createComponent("EmbedColorPicker", {
      ref: "$color",
      onchange: "changeColor"
    })}    
          </div>
          <div class='assetpicker'>
            ${createComponent("ImageSelectEditor", {
      ref: "$image",
      key: "image",
      value: (_b = this.state.image) == null ? void 0 : _b.url,
      onchange: "changeImageUrl"
    })}
            ${createComponent("ImageAssetPicker", {
      ref: "$asset",
      onchange: "changeImageUrl"
    })}
          </div>
        </div>
      </div>
     
    `;
  }
  [BIND("$body")]() {
    var _a;
    return {
      "data-selected-editor": (_a = this.state.image) == null ? void 0 : _a.type
    };
  }
  getColorString() {
    var value = "";
    if (this.state.image instanceof Gradient) {
      value = this.state.image.getColorString();
    }
    return value;
  }
  getCurrentColor() {
    return this.state.image.colorsteps[this.state.selectColorStepIndex || 0].color;
  }
  [LOAD("$gradientEditor")]() {
    var _a;
    if (((_a = this.state.image) == null ? void 0 : _a.type) === GradientType.URL) {
      return "";
    }
    return createComponent("FillEditor", {
      ref: "$g",
      value: `${this.state.image}`,
      index: this.state.selectColorStepIndex,
      onchange: "changeFillEditor"
    });
  }
  [SUBSCRIBE("updateFillEditor")](data, targetColorStep = void 0) {
    this.state.image = isString(data) ? SVGFill.parseImage(data) : data;
    if (targetColorStep) {
      this.state.selectColorStepIndex = this.state.image.colorsteps.findIndex((it) => it.color === targetColorStep.color && it.percent === targetColorStep.percent);
      this.children.$color.setValue(targetColorStep.color);
    }
    this.refresh();
  }
  [SUBSCRIBE_SELF("changeFillEditor")](data) {
    this.state.image = isString(data) ? SVGFill.parseImage(data) : data;
    this.updateTitle();
    this.updateData();
  }
  [SUBSCRIBE_SELF("changeTabType")](key, type) {
    this.children.$g.trigger("changeTabType", type);
    this.refs.$body.attr("data-selected-editor", type);
  }
  [SUBSCRIBE_SELF("changeColor")](color2) {
    this.children.$g.trigger("setColorStepColor", color2);
  }
  [SUBSCRIBE_SELF("changeImageUrl")](url) {
    if (this.state.image) {
      this.state.image.reset({
        url
      });
      this.trigger("changeFillEditor", this.state.image);
    }
  }
  updateTitle() {
    this.children.$select.setValue(this.state.image.type);
  }
  [SUBSCRIBE("showFillPickerPopup")](data, params, rect2) {
    data.changeEvent = data.changeEvent || "changeFillPopup";
    data.params = params;
    this.showByRect(this.makeRect(248, 560, rect2));
    this.setState(data);
    this.updateTitle();
    if (data.image.isGradient()) {
      this.trigger("selectColorStep", data.image.colorsteps[0].color);
    }
    this.emit("showFillEditorView", {
      key: data.key
    });
  }
  [SUBSCRIBE("hideFillPickerPopup")]() {
    this.hide();
    this.emit("hideFillEditorView");
  }
  onClose() {
    this.emit("hideFillEditorView");
  }
  [SUBSCRIBE("selectColorStep")](color2) {
    this.children.$color.setValue(color2);
  }
  [SUBSCRIBE("changeColorStep")](data = {}) {
    this.state.image.reset(__spreadValues({}, data));
    this.updateData();
  }
  load(...args2) {
    if (this.$el.isShow()) {
      super.load(...args2);
    }
  }
  getValue() {
    return `${this.state.image}`;
  }
  updateData() {
    this.state.instance.trigger(this.state.changeEvent, this.getValue(), this.state.params);
  }
}
var FillSingleEditor$1 = "";
class FillSingleEditor extends EditorElement {
  initState() {
    return {
      index: this.props.index,
      label: this.props.label,
      simple: this.props.simple === "true" ? true : false,
      image: SVGFill.parseImage(this.props.value || this.props.image || "transparent")
    };
  }
  get fillId() {
    return this.id + "fill";
  }
  updateData(opt = {}) {
    this.setState(opt, false);
    this.modifyValue(opt);
  }
  modifyValue() {
    this.parent.trigger(this.props.onchange, this.props.key, this.getValue(), this.state.index);
  }
  getValue() {
    return this.state.image.toString();
  }
  setValue(value) {
    this.setState({
      image: SVGFill.parseImage(value)
    });
  }
  [BIND("$fillView")]() {
    var image2 = this.state.image;
    if (!image2)
      return { innerHTML: "" };
    return {
      innerHTML: image2.toSVGString(this.fillId, {
        width: 20,
        height: 20,
        sizeType: "percent"
      })
    };
  }
  [BIND("$fillColor")]() {
    var image2 = this.state.image;
    if (!image2)
      return { fill: "transparent" };
    return {
      fill: image2.toFillValue(this.fillId)
    };
  }
  [BIND("$colors")]() {
    var image2 = this.state.image;
    if (!image2)
      return { fill: "transparent" };
    var colors2 = image2.type != "url" ? `${image2.colorsteps[0].color}` : "transparent";
    if ([GradientType.LINEAR, GradientType.RADIAL].includes(image2.type)) {
      colors2 = image2.colorsteps.map((it) => {
        return `<span class='color' style='background-color: ${it.color}' title='${it.color}'></span>`;
      }).join("");
    }
    return {
      innerHTML: `<div> ${colors2} </div>`
    };
  }
  template() {
    var { label, simple } = this.state;
    var hasLabel = label ? "has-label" : "";
    return `
            <div class='elf--fill-single-editor ${hasLabel}'>
                ${label ? `<label>${label}</label>` : ""}            
                <div class="area">
                    <div class='preview' ref='$preview'>
                        <div class='mini-view'>

                            <svg class='color-view' ref='$miniView'>
                                <defs ref='$fillView'></defs>
                                <rect x="0" y="0" width="100%" height="100%" ref='$fillColor' fill='url(#${this.fillId})' />
                            </svg>
                        </div>
                    </div>
                    <div class='colors ${simple ? "simple" : ""}' ref='$colors'></div>
                </div>
            </div>
        `;
  }
  [CLICK()]() {
    this.viewGradientPopup();
  }
  viewGradientPopup() {
    this.emit("showFillPickerPopup", {
      instance: this,
      key: this.props.key,
      changeEvent: "changeFillSingle",
      image: this.state.image
    }, null, this.$el.rect());
  }
  [SUBSCRIBE("changeFillSingle")](image2) {
    this.updateData({ image: SVGFill.parseImage(image2) });
    this.refresh();
  }
}
var GradientSingleEditor$1 = "";
class GradientSingleEditor extends EditorElement {
  initState() {
    return {
      index: this.props.index,
      image: this.props.image,
      color: "rgba(0, 0, 0, 1)"
    };
  }
  updateData(opt = {}) {
    this.setState(opt, false);
    this.modifyValue(opt);
  }
  modifyValue(value) {
    this.parent.trigger(this.props.onchange, this.props.key, value, this.state.index);
  }
  setValue(obj2) {
    this.setState(__spreadValues({}, obj2));
  }
  [BIND("$miniView")]() {
    const project2 = this.$context.selection.currentProject;
    let image2;
    if (this.state.image.type === GradientType.URL) {
      const imageUrl = project2.getImageValueById(this.state.image.url);
      image2 = this.state.image.toString(imageUrl);
    } else {
      image2 = this.state.image.toCSSString();
    }
    return {
      style: {
        "background-image": image2
      }
    };
  }
  template() {
    return `
            <div class='elf--gradient-single-editor'>
                <div class='preview' ref='$preview'>
                    <div class='mini-view'>
                        <div class='color-view' ref='$miniView'></div>
                    </div>
                </div>
            </div>
        `;
  }
  [CLICK("$preview")]() {
    this.viewGradientPopup();
  }
  viewGradientPopup() {
    this.emit("showGradientPickerPopup", {
      instance: this,
      changeEvent: "changeGradientSingle",
      index: this.state.index,
      gradient: this.state.image
    }, null, this.$el.rect());
  }
  [SUBSCRIBE("changeGradientSingle")](image2) {
    var _a;
    image2 = BackgroundImage.parseImage(image2);
    const currentImage = (_a = this.$context.selection.current.getBackgroundImage(this.state.index)) == null ? void 0 : _a.image;
    switch (currentImage.type) {
      case GradientType.RADIAL:
      case GradientType.REPEATING_RADIAL:
        image2.reset({
          radialPosition: currentImage.radialPosition || ["50%", "50%"],
          radialType: currentImage.radialType || RadialGradientType.CIRCLE
        });
        break;
      case GradientType.CONIC:
      case GradientType.REPEATING_CONIC:
        image2.reset({
          angle: currentImage.angle || 0,
          radialPosition: currentImage.radialPosition || ["50%", "50%"]
        });
        break;
      case GradientType.LINEAR:
      case GradientType.REPEATING_LINEAR:
      case GradientType.STATIC:
        image2.reset({
          angle: currentImage.angle || 0
        });
        break;
    }
    this.updateData({ image: image2 });
    this.refresh();
  }
}
function gradient(editor) {
  editor.registerElement({
    FillSingleEditor,
    FillEditor,
    GradientSingleEditor
  });
  editor.registerAlias({
    "fill-single": "FillSingleEditor",
    fill: "FillEditor",
    "gradient-single": "GradientSingleEditor"
  });
  editor.registerUI("popup", {
    FillPickerPopup,
    GradientPickerPopup
  });
}
var GradientEditorView$1 = "";
var radialTypeList = [
  "circle",
  "circle farthest-corner",
  "circle closest-side",
  "circle closest-corner",
  "circle farthest-side",
  "ellipse",
  "ellipse farthest-corner",
  "ellipse closest-side",
  "ellipse closest-corner",
  "ellipse farthest-side"
];
var repeatTypeList = [
  "no-repeat",
  "repeat",
  "repeat-x",
  "repeat-y",
  "space",
  "round"
];
const TOOL_SIZE = 20;
class GradientBaseEditor extends EditorElement {
  initializeData() {
    const value = this.$context.selection.current.backgroundImage;
    const cssValue = STRING_TO_CSS(value);
    this.state.backgroundImages = BackgroundImage.parseStyle(cssValue);
    this.state.backImages = BackgroundImage.parseStyle(cssValue);
    const current = this.$context.selection.current;
    this.state.gradient = this.state.backImages[this.state.index];
    this.state.contentBox = current.contentBox;
    this.state.backgroundImageMatrix = current.createBackgroundImageMatrix(this.state.index);
  }
  updateData() {
    var value = CSS_TO_STRING(BackgroundImage.toProperty(this.state.backgroundImages));
    this.$commands.executeCommand("setAttribute", "change background image", this.$context.selection.packByValue({
      backgroundImage: value
    }));
  }
}
class GradientTimingStepEditor extends GradientBaseEditor {
  [POINTERSTART("$el .step-point") + MOVE("moveStepPoint") + END("moveEndStepPoint")](e) {
    this.$el.toggleClass("dragging", true);
    this.initializeData();
    const colorStepIndex = +e.$dt.data("colorstep-index");
    this.localColorStep = this.state.backgroundImages[this.state.index].image.colorsteps[colorStepIndex];
    this.localColorStepTimingCount = this.localColorStep.timing.count;
    this.localColorCubicBezierTimingCount = this.localColorStep.timingCount;
  }
  moveStepPoint(dx, dy) {
    const dist$1 = (dx < 0 ? -1 : 1) * Math.ceil(dist([0, 0, 0], [dx, dy, 0]) / 10);
    switch (this.localColorStep.timing.name) {
      case TimingFunction.LINEAR:
        break;
      case TimingFunction.STEPS:
        this.localColorStep.timing.count = Math.max(this.localColorStepTimingCount + dist$1, 1);
        break;
      default:
        this.localColorStep.timingCount = Math.max(this.localColorCubicBezierTimingCount + dist$1, 1);
        break;
    }
    this.updateData();
  }
  makeTimingString(timing) {
    switch (timing.name) {
      case TimingFunction.LINEAR:
        return ``;
      case TimingFunction.EASE:
      case TimingFunction.EASE_IN:
      case TimingFunction.EASE_OUT:
      case TimingFunction.EASE_IN_OUT:
        return `${timing.name}`;
      default:
        return `cubic-bezier(${timing.x1}, ${timing.y1}, ${timing.x2}, ${timing.y2})`;
    }
  }
  moveEndStepPoint(dx, dy) {
    if (dx === 0 && dy === 0) {
      const { timing } = this.localColorStep;
      switch (timing.name) {
        case TimingFunction.STEPS:
          this.localColorStep.timing.direction = this.localColorStep.timing.direction === "start" ? "end" : "start";
          break;
        case TimingFunction.LINEAR:
          break;
        case TimingFunction.PATH:
          this.emit("showComponentPopup", {
            title: "Path Editor",
            width: 400,
            inspector: [
              {
                key: "path",
                editor: "path",
                editorOptions: {
                  height: 160
                },
                defaultValue: timing.d
              }
            ],
            changeEvent: (key, value) => {
              this.localColorStep.timing = parseOneValue(`path(${value})`).parsed;
              this.updateData();
            }
          });
          break;
        default:
          this.emit("showComponentPopup", {
            title: "Cubic Bezier",
            width: 220,
            inspector: [
              {
                key: "timing",
                editor: "cubic-bezier",
                editorOptions: {
                  isAnimating: false
                },
                defaultValue: this.makeTimingString(timing)
              }
            ],
            changeEvent: (key, value) => {
              this.localColorStep.timing = parseOneValue(value).parsed;
              this.updateData();
            }
          });
          this.$el.toggleClass("dragging", false);
          return;
      }
    }
    this.updateData();
    this.$el.toggleClass("dragging", false);
  }
}
class GradientResizer extends GradientTimingStepEditor {
  [POINTERSTART("$el .resizer") + LEFT_BUTTON + MOVE("calculateMovedResizer") + END("calculateMovedEndResizer") + PREVENT](e) {
    this.state.$target = e.$dt;
    this.$el.toggleClass("dragging", true);
    this.initializeData();
    this.initMousePoint = this.$viewport.getWorldPosition(e);
    this.isShiftKey = e.shiftKey;
  }
  calculateMovedResizer() {
    const targetMousePoint = this.$viewport.getWorldPosition();
    const currentVertex = clone(this.initMousePoint);
    const nextVertex = targetMousePoint;
    const reverseMatrix = this.$context.selection.current.absoluteMatrixInverse;
    const [currentResult, nextResult] = vertiesMap([currentVertex, nextVertex], reverseMatrix);
    const realDist = subtract([], nextResult, currentResult);
    const { backRect: rect2 } = this.state.backgroundImageMatrix;
    const backgroundImage2 = this.state.gradient;
    const backRect = backgroundImage2.recoverOffset(rect2.x, rect2.y, this.state.contentBox, realDist[0], realDist[1], {
      shiftKey: this.$config.get("bodyEvent").shiftKey
    });
    this.state.backgroundImages[this.state.index].reset({
      x: backRect.x,
      y: backRect.y,
      width: backRect.width,
      height: backRect.height
    });
    this.updateData();
  }
  calculateMovedEndResizer() {
    this.updateData();
    this.$el.toggleClass("dragging", false);
  }
  [POINTERSTART("$el .back-rect") + LEFT_BUTTON + MOVE("calculateMovedRect") + END("calculateMovedEndRect") + PREVENT](e) {
    this.state.$target = e.$dt;
    this.initializeData();
    this.initMousePoint = this.$viewport.getWorldPosition(e);
  }
  calculateMovedRect() {
    const targetMousePoint = this.$viewport.getWorldPosition();
    const currentVertex = clone(this.initMousePoint);
    const nextVertex = targetMousePoint;
    const reverseMatrix = this.$context.selection.current.absoluteMatrixInverse;
    const [currentResult, nextResult] = vertiesMap([currentVertex, nextVertex], reverseMatrix);
    const realDist = subtract([], nextResult, currentResult);
    const { backRect: rect2 } = this.state.backgroundImageMatrix;
    const backgroundImage2 = this.state.gradient;
    const backRect = backgroundImage2.recoverOffset(rect2.x + realDist[0], rect2.y + realDist[1], this.state.contentBox);
    this.state.backgroundImages[this.state.index].reset({
      x: backRect.x,
      y: backRect.y
    });
    this.updateData();
  }
  calculateMovedEndRect(dx, dy) {
    if (dx == 0 && dy === 0) {
      const index2 = repeatTypeList.indexOf(this.state.gradient.repeat);
      this.state.backgroundImages[this.state.index].repeat = repeatTypeList[(index2 + 1) % repeatTypeList.length];
    }
    this.updateData();
  }
}
class GradientRotateEditor extends GradientResizer {
  [POINTERSTART("$el .gradient-angle .rotate") + LEFT_BUTTON + MOVE("calculateMovedAngle") + END("calculatedMovedEndAngle") + PREVENT](e) {
    this.state.$target = e.$dt;
    this.initializeData();
    this.$el.toggleClass("dragging", true);
    this.state.centerX = +this.state.$target.data("center-x");
    this.state.centerY = +this.state.$target.data("center-y");
    this.state.startX = +this.state.$target.attr("cx");
    this.state.startY = +this.state.$target.attr("cy");
    this.state.$target.toggleClass("moved");
  }
  calculateMovedAngle(dx, dy) {
    const center2 = [this.state.centerX, this.state.centerY, 0];
    const point2 = [this.state.startX, this.state.startY, 0];
    const dist2 = [dx, dy, 0];
    const distAngle = calculateAngleForVec3(point2, center2, dist2);
    let newAngle = Math.floor(this.state.gradient.image.angle + distAngle);
    if (this.$config.get("bodyEvent").shiftKey) {
      newAngle -= newAngle % this.$config.get("fixed.gradient.angle");
    }
    this.state.backgroundImages[this.state.index].image.angle = newAngle;
    this.updateData();
  }
  calculatedMovedEndAngle() {
    this.state.$target.toggleClass("moved");
    this.$el.toggleClass("dragging", false);
    this.updateData();
  }
}
class GradientColorstepEditor extends GradientRotateEditor {
  [KEYUP("$el .colorstep")](e) {
    const index2 = +e.$dt.data("index");
    switch (e.code) {
      case "Delete":
      case "Backspace":
        this.removeStep(index2);
        break;
      case "BracketRight":
        this.sortToRight(index2);
        break;
      case "BracketLeft":
        this.sortToLeft(index2);
        break;
      case "Equal":
        this.appendColorStep(index2);
        break;
      case "Minus":
        this.prependColorStep(index2);
        break;
    }
  }
  removeStep(currentIndex) {
    const image2 = this.state.lastBackgroundMatrix.backgroundImage.image;
    image2.removeColorStepByIndex(currentIndex);
    this.updateColorStepStatus(image2, -1);
  }
  sortToRight() {
    const image2 = this.state.lastBackgroundMatrix.backgroundImage.image;
    image2.sortToRight();
    this.updateColorStepStatus(image2, -1);
  }
  sortToLeft() {
    const image2 = this.state.lastBackgroundMatrix.backgroundImage.image;
    image2.sortToLeft();
    this.updateColorStepStatus(image2, -1);
  }
  appendColorStep(currentIndex) {
    const nextIndex = currentIndex + 1;
    const image2 = this.state.lastBackgroundMatrix.backgroundImage.image;
    const currentColorStep = image2.colorsteps[currentIndex];
    const nextColorStep = image2.colorsteps[nextIndex];
    let newIndex = -1;
    if (!nextColorStep) {
      if (currentColorStep.percent !== 100) {
        newIndex = image2.insertColorStep(currentColorStep.percent + (100 - currentColorStep.percent) / 2);
      }
    } else {
      newIndex = image2.insertColorStep(currentColorStep.percent + (nextColorStep.percent - currentColorStep.percent) / 2);
    }
    this.updateColorStepStatus(image2, newIndex);
  }
  prependColorStep(currentIndex) {
    const prevIndex = currentIndex - 1;
    const image2 = this.state.lastBackgroundMatrix.backgroundImage.image;
    const currentColorStep = image2.colorsteps[currentIndex];
    const prevColorStep = image2.colorsteps[prevIndex];
    let newIndex = -1;
    if (!prevColorStep) {
      if (currentColorStep.percent !== 0) {
        newIndex = image2.insertColorStep(currentColorStep.percent);
      }
    } else {
      newIndex = image2.insertColorStep(prevColorStep.percent + (currentColorStep.percent - prevColorStep.percent) / 2);
    }
    this.updateColorStepStatus(image2, newIndex);
  }
  [POINTERSTART("$el .colorstep") + MOVE("moveColorStep") + END("moveEndColorStep")](e) {
    this.$el.toggleClass("dragging", true);
    this.state.hoverColorStep = null;
    this.initializeData();
    const $colorstep = e.$dt;
    this.$targetIndex = +$colorstep.data("index");
    if (e.altKey) {
      this.removeStep(this.$targetIndex);
      this.state.altKey = true;
      return;
    }
    const result = this.state.backgroundImageMatrix;
    switch (result.backgroundImage.image.type) {
      case GradientType.LINEAR:
      case GradientType.REPEATING_LINEAR:
        this.centerPosition = this.$viewport.applyVertex(result.centerPosition);
        this.startPoint = this.$viewport.applyVertex(result.startPoint);
        this.endPoint = this.$viewport.applyVertex(result.endPoint);
        this.screenXY = this.$viewport.applyVertex(result.colorsteps[this.$targetIndex].pos);
        this.rotateInverse = calculateRotationOriginMat4(-this.state.gradient.image.angle, this.centerPosition);
        break;
      case GradientType.RADIAL:
      case GradientType.REPEATING_RADIAL:
        this.centerPosition = this.$viewport.applyVertex(result.radialCenterPosition);
        this.startPoint = this.$viewport.applyVertex(result.startPoint);
        this.endPoint = this.$viewport.applyVertex(result.endPoint);
        this.screenXY = this.$viewport.applyVertex(result.colorsteps[this.$targetIndex].pos);
        const dist2 = subtract([], this.endPoint, this.startPoint);
        const angle = calculateAngle360(dist2[0], dist2[1]) - 180;
        this.rotateInverse = calculateRotationOriginMat4(-angle, this.centerPosition);
        break;
      case GradientType.CONIC:
      case GradientType.REPEATING_CONIC:
        this.centerPosition = this.$viewport.applyVertex(result.radialCenterPosition);
        this.startPoint = this.$viewport.applyVertex(result.shapePoint);
        this.newStartPoint = subtract([], this.startPoint, this.centerPosition);
        this.newStartAngle = calculateAngle360(this.newStartPoint[0], this.newStartPoint[1]);
        const x = +$colorstep.data("x");
        const y = +$colorstep.data("y");
        this.screenXY = [x, y, 0];
        this.endPoint = this.$viewport.applyVertex(result.endPoint);
        this.rotateInverse = create$4();
        break;
    }
  }
  moveColorStep(dx, dy) {
    if (this.state.altKey)
      return;
    const nextPoint = add$1([], this.screenXY, [dx, dy, 0]);
    const [baseStartPoint, baseEndPoint, baseNextPoint] = vertiesMap([this.startPoint, this.endPoint, nextPoint], this.rotateInverse);
    const result = this.state.backgroundImageMatrix;
    let newDist = 0;
    let baseDist = 0;
    switch (result.backgroundImage.image.type) {
      case GradientType.LINEAR:
      case GradientType.REPEATING_LINEAR:
        var [s, e, n] = [baseStartPoint[1], baseEndPoint[1], baseNextPoint[1]];
        var baseDefaultDist = Math.abs(s - e);
        if (s < n) {
          newDist = -1 * Math.abs(n - s) / baseDefaultDist * 100;
        } else if (e > n) {
          newDist = Math.abs(n - s) / baseDefaultDist * 100;
        } else {
          var distStart = Math.abs(s - n);
          var distEnd = Math.abs(e - n);
          newDist = distStart / (distEnd + distStart) * 100;
        }
        newDist = Math.max(0, Math.min(100, newDist));
        baseDist = dist(this.startPoint, this.endPoint);
        break;
      case GradientType.RADIAL:
      case GradientType.REPEATING_RADIAL:
        var [s, e, n] = [baseStartPoint[0], baseEndPoint[0], baseNextPoint[0]];
        var baseDefaultDist = Math.abs(s - e);
        if (n < s) {
          newDist = -1 * Math.abs(n - s) / baseDefaultDist * 100;
        } else if (n > e) {
          newDist = Math.abs(n - s) / baseDefaultDist * 100;
        } else {
          newDist = (n - s) / baseDefaultDist * 100;
        }
        newDist = Math.max(0, Math.min(100, newDist));
        baseDist = dist(this.startPoint, this.endPoint);
        break;
      case GradientType.CONIC:
      case GradientType.REPEATING_CONIC:
        const newNextPoint = subtract([], nextPoint, this.centerPosition);
        let nextAngle = calculateAngle360(newNextPoint[0], newNextPoint[1]);
        if (this.$config.get("bodyEvent").shiftKey) {
          nextAngle -= nextAngle % this.$config.get("fixed.gradient.angle");
        }
        let newAngle = nextAngle - this.newStartAngle;
        newDist = newAngle / 360 * 100;
        newDist = (newDist + 100) % 100;
        baseDist = 100;
        break;
    }
    const image2 = this.state.gradient.image;
    image2.colorsteps[this.$targetIndex].setValue(newDist, baseDist);
    const targetColorStep = {
      color: image2.colorsteps[this.$targetIndex].color,
      percent: image2.colorsteps[this.$targetIndex].percent
    };
    const nextImage = this.state.backgroundImages[this.state.index].image;
    nextImage.colorsteps = image2.colorsteps.map((it) => {
      return it;
    });
    nextImage.sortColorStep();
    this.emit("updateGradientEditor", nextImage, targetColorStep);
    var value = CSS_TO_STRING(BackgroundImage.toProperty(this.state.backgroundImages));
    this.$commands.executeCommand("setAttribute", "change background image", this.$context.selection.packByValue({
      backgroundImage: value
    }));
  }
  moveEndColorStep(dx, dy) {
    if (this.state.altKey) {
      this.state.altKey = false;
      return;
    }
    if (dx === 0 && dy === 0) {
      const image2 = this.state.backgroundImages[this.state.index].image;
      image2.colorsteps[this.$targetIndex].toggleTiming();
      const targetColorStep = {
        color: image2.colorsteps[this.$targetIndex].color,
        percent: image2.colorsteps[this.$targetIndex].percent
      };
      this.emit("updateGradientEditor", image2, targetColorStep);
      var value = CSS_TO_STRING(BackgroundImage.toProperty(this.state.backgroundImages));
      this.$commands.executeCommand("setAttribute", "change background image", this.$context.selection.packByValue({
        backgroundImage: value
      }));
    }
    this.$el.toggleClass("dragging", false);
  }
  updateColorStepStatus(image2, index2) {
    this.initializeData();
    const { color: color2, percent } = image2.colorsteps[index2] || {};
    this.emit("updateGradientEditor", image2, { color: color2, percent });
    this.state.backgroundImages[this.state.index].image = image2;
    var value = CSS_TO_STRING(BackgroundImage.toProperty(this.state.backgroundImages));
    this.$commands.executeCommand("setAttribute", "change background image", this.$context.selection.packByValue({
      backgroundImage: value
    }));
    this.state.hoverColorStep = null;
  }
  [POINTERSTART("$el .area-line")]() {
    const image2 = this.state.lastBackgroundMatrix.backgroundImage.image;
    const index2 = image2.insertColorStep(this.state.hoverColorStep.percent);
    this.updateColorStepStatus(image2, index2);
  }
  [POINTEROUT("$el .area-line")]() {
    if (this.state.hoverColorStep) {
      this.state.hoverColorStep = null;
      this.refresh();
    }
  }
  [POINTERMOVE("$el .area-line")](evt) {
    const nextPoint = this.$viewport.applyVertex(this.$viewport.getWorldPosition(evt));
    const image2 = this.state.lastBackgroundMatrix.backgroundImage.image;
    let baseStartPoint, baseEndPoint, baseNextPoint;
    switch (image2.type) {
      case GradientType.LINEAR:
      case GradientType.REPEATING_LINEAR:
        [baseStartPoint, baseEndPoint, baseNextPoint] = vertiesMap([this.state.startPoint, this.state.endPoint, nextPoint], this.state.rotateInverse);
        var newDist = 0;
        var [s, e, n] = [baseStartPoint[1], baseEndPoint[1], baseNextPoint[1]];
        var baseDefaultDist = Math.abs(s - e);
        if (s < n) {
          newDist = -1 * Math.abs(n - s) / baseDefaultDist * 100;
        } else if (e > n) {
          newDist = Math.abs(n - s) / baseDefaultDist * 100;
        } else {
          const distStart = Math.abs(s - n);
          const distEnd = Math.abs(e - n);
          newDist = distStart / (distEnd + distStart) * 100;
        }
        this.state.hoverColorStep = this.state.lastBackgroundMatrix.backgroundImage.image.pickColorStep(newDist);
        break;
      case GradientType.RADIAL:
      case GradientType.REPEATING_RADIAL:
        [baseStartPoint, baseEndPoint, baseNextPoint] = [
          this.state.startPoint,
          this.state.endPoint,
          nextPoint
        ];
        var newDist = 0;
        var [s, e, n] = [baseStartPoint[0], baseEndPoint[0], baseNextPoint[0]];
        var baseDefaultDist = Math.abs(s - e);
        if (n < s) {
          newDist = -1 * Math.abs(n - s) / baseDefaultDist * 100;
        } else {
          newDist = Math.abs(n - s) / baseDefaultDist * 100;
        }
        this.state.hoverColorStep = this.state.lastBackgroundMatrix.backgroundImage.image.pickColorStep(newDist);
        break;
      case GradientType.CONIC:
      case GradientType.REPEATING_CONIC:
        const newStartPoint = subtract([], this.state.startPoint, this.state.centerPosition);
        const newNextPoint = subtract([], nextPoint, this.state.centerPosition);
        const startAngle = calculateAngle360(newStartPoint[0], newStartPoint[1]);
        const nextAngle = calculateAngle360(newNextPoint[0], newNextPoint[1]);
        var newDist = (nextAngle - startAngle) / 360 * 100;
        this.state.hoverColorStep = this.state.lastBackgroundMatrix.backgroundImage.image.pickColorStep(newDist);
        break;
    }
    this.refresh();
  }
}
class GradientEditorView extends GradientColorstepEditor {
  template() {
    return /* @__PURE__ */ createElementJsx("div", {
      class: "elf--gradient-editor-view"
    });
  }
  [POINTERSTART("$el .point") + LEFT_BUTTON + MOVE("calculateMovedElement") + END("calculateMovedEndElement") + PREVENT](e) {
    this.$el.toggleClass("dragging", true);
    this.initializeData();
    const result = this.state.backgroundImageMatrix;
    this.pointTarget = e.$dt.data("type");
    this.startPoint = this.$viewport.applyVertex(result.startPoint);
    this.endPoint = this.$viewport.applyVertex(result.endPoint);
    if (result.shapePoint) {
      this.shapePoint = this.$viewport.applyVertex(result.shapePoint);
    }
  }
  calculateMovedElement(dx, dy) {
    const targetPoint = this.pointTarget === "start" ? this.startPoint : this.endPoint;
    let nextPoint = add$1([], targetPoint, [dx, dy, 0]);
    var [localPosition] = vertiesMap([this.$viewport.applyVertexInverse(nextPoint)], this.$context.selection.current.absoluteMatrixInverse);
    const backgroundImage2 = this.state.gradient;
    const backRect = backgroundImage2.getOffset(this.state.contentBox);
    const image2 = this.state.gradient.image;
    switch (image2.type) {
      case GradientType.RADIAL:
      case GradientType.REPEATING_RADIAL:
        if (this.pointTarget === "start") {
          const newX = localPosition[0] - backRect.x;
          const newY = localPosition[1] - backRect.y;
          this.state.backgroundImages[this.state.index].image.radialPosition = [
            Length.makePercent(newX, backRect.width),
            Length.makePercent(newY, backRect.height)
          ];
          this.updateData();
        } else if (this.pointTarget === "end") {
          var [localStartPosition] = vertiesMap([this.$viewport.applyVertexInverse(this.startPoint)], this.$context.selection.current.absoluteMatrixInverse);
          var [localEndPosition] = vertiesMap([
            this.$viewport.applyVertexInverse(add$1([], this.endPoint, [dx, 0, 0]))
          ], this.$context.selection.current.absoluteMatrixInverse);
          var [localShapePosition] = vertiesMap([this.$viewport.applyVertexInverse(this.shapePoint)], this.$context.selection.current.absoluteMatrixInverse);
          const newEndX = localEndPosition[0] - backRect.x - localStartPosition[0];
          const newShapeY = localShapePosition[1] - backRect.y - localStartPosition[1];
          if (this.state.gradient.image.radialType === RadialGradientType.CIRCLE) {
            this.state.backgroundImages[this.state.index].image.radialSize = [
              Length.px(Math.abs(newEndX))
            ];
          } else if (this.state.gradient.image.radialType === RadialGradientType.ELLIPSE) {
            this.state.backgroundImages[this.state.index].image.radialSize = [
              Length.makePercent(Math.abs(newEndX), backRect.width),
              Length.makePercent(Math.abs(newShapeY), backRect.height)
            ];
          }
          this.updateData();
        } else if (this.pointTarget === "shape") {
          var [localStartPosition] = vertiesMap([this.$viewport.applyVertexInverse(this.startPoint)], this.$context.selection.current.absoluteMatrixInverse);
          var [localShapePosition] = vertiesMap([
            this.$viewport.applyVertexInverse(add$1([], this.shapePoint, [0, dy, 0]))
          ], this.$context.selection.current.absoluteMatrixInverse);
          var [localEndPosition] = vertiesMap([this.$viewport.applyVertexInverse(this.endPoint)], this.$context.selection.current.absoluteMatrixInverse);
          const newEndX = localEndPosition[0] - backRect.x - localStartPosition[0];
          const newShapeY = localShapePosition[1] - backRect.y - localStartPosition[1];
          if (this.state.gradient.image.radialType === RadialGradientType.CIRCLE) {
            this.state.backgroundImages[this.state.index].image.radialSize = [
              Length.px(Math.abs(newShapeY))
            ];
          } else if (this.state.gradient.image.radialType === RadialGradientType.ELLIPSE) {
            this.state.backgroundImages[this.state.index].image.radialSize = [
              Length.makePercent(Math.abs(newEndX), backRect.width),
              Length.makePercent(Math.abs(newShapeY), backRect.height)
            ];
          }
          this.updateData();
        }
        break;
      case GradientType.CONIC:
      case GradientType.REPEATING_CONIC:
        if (this.pointTarget === "start") {
          const newX = localPosition[0] - backRect.x;
          const newY = localPosition[1] - backRect.y;
          this.state.backgroundImages[this.state.index].image.radialPosition = [
            Length.makePercent(newX, backRect.width),
            Length.makePercent(newY, backRect.height)
          ];
          this.updateData();
        }
        break;
    }
  }
  calculateMovedEndElement(dx, dy) {
    if (dx == 0 && dy === 0) {
      if (this.pointTarget === "start") {
        switch (this.state.gradient.type) {
          case GradientType.RADIAL:
          case GradientType.REPEATING_RADIAL:
            const findKey = `${this.state.gradient.image.radialType} ${this.state.gradient.image.radialSize}`.trim();
            const index2 = radialTypeList.indexOf(findKey);
            const [radialType, radialSize] = radialTypeList[(index2 + 1) % radialTypeList.length].split(" ");
            const image2 = this.state.backgroundImages[this.state.index].image;
            image2.radialType = radialType;
            image2.radialSize = radialSize;
            break;
        }
      }
    }
    this.updateData();
    this.$el.toggleClass("dragging", false);
  }
  refresh() {
    if (this.state.isShow) {
      this.load();
    }
  }
  [SUBSCRIBE(UPDATE_VIEWPORT)]() {
    this.refresh();
  }
  [SUBSCRIBE(UPDATE_CANVAS) + DEBOUNCE(10)]() {
    if (this.$context.selection.current) {
      if (this.$context.selection.hasChangedField("x", "y", "width", "height", "angle", "backgroundImage", "border", "padding", "paddingTop", "paddingLeft", "paddingRight", "paddingBottom")) {
        this.refresh();
      }
    }
  }
  [SUBSCRIBE("showGradientEditorView")]({ index: index2 }) {
    this.state.index = index2;
    this.$el.show();
    this.state.isShow = true;
    this.refresh();
    this.$commands.emit("recoverCursor");
    this.$context.commands.emit("push.mode.view", "GradientEditorView");
  }
  [SUBSCRIBE("hideGradientEditorView")]() {
    this.$el.hide();
    this.state.isShow = false;
    this.$commands.emit("pop.mode.view", "GradientEditorView");
  }
  makeTimingLine(timing, width2 = 10, startX = 0, startY = 0) {
    switch (timing.name) {
      case TimingFunction.LINEAR:
        return ``;
      case TimingFunction.STEPS:
        return /* @__PURE__ */ createElementJsx("path", {
          class: "timing",
          d: `
          M${startX + 0} ${startY + width2} 
          L${startX + width2 * 1 / 3} ${startY + width2} 
          L${startX + width2 * 1 / 3} ${startY + width2 * 2 / 3} 
          L${startX + width2 * 2 / 3} ${startY + width2 * 2 / 3} 
          L${startX + width2 * 2 / 3} ${startY + width2 * 1 / 3} 
          L${startX + width2} ${startY + width2 * 1 / 3} 
          L${startX + width2} ${startY + 0}           
        `
        });
      case TimingFunction.PATH:
        return /* @__PURE__ */ createElementJsx("path", {
          class: "timing",
          d: PathParser.fromSVGString(timing.d).scale(width2, width2).flipX().translate(0, width2).d
        });
      default:
        return /* @__PURE__ */ createElementJsx("path", {
          class: "timing",
          d: `
          M${startX + 0} ${startY + width2} 
          C 
            ${startX + timing.x1 * width2} ${startY + width2 - timing.y1 * width2} 
            ${startX + timing.x2 * width2} ${startY + width2 - timing.y2 * width2}  
            ${startX + width2} ${startY + 0}
        `
        });
    }
  }
  makeConicTimingLine(timing, width2 = 10, startX = 0, startY = 0) {
    const half = width2 / 2;
    switch (timing.name) {
      case TimingFunction.LINEAR:
        return ``;
      case TimingFunction.STEPS:
        return /* @__PURE__ */ createElementJsx("path", {
          class: "timing",
          d: `
          M${startX + 0 - half} ${startY + width2 - half} 
          L${startX + width2 * 1 / 3 - half} ${startY + width2 - half} 
          L${startX + width2 * 1 / 3 - half} ${startY + width2 * 2 / 3 - half} 
          L${startX + width2 * 2 / 3 - half} ${startY + width2 * 2 / 3 - half} 
          L${startX + width2 * 2 / 3 - half} ${startY + width2 * 1 / 3 - half} 
          L${startX + width2 - half} ${startY + width2 * 1 / 3 - half} 
          L${startX + width2 - half} ${startY + 0 - half}           
        `
        });
      case TimingFunction.PATH:
        return /* @__PURE__ */ createElementJsx("path", {
          class: "timing",
          d: PathParser.fromSVGString(timing.d).scale(width2, width2).flipX().translate(-half, width2).d
        });
      default:
        return /* @__PURE__ */ createElementJsx("path", {
          class: "timing",
          d: `
          M${startX + 0 - half} ${startY + width2 - half} 
          C 
            ${startX + timing.x1 * width2 - half} ${startY + width2 - timing.y1 * width2 - half} 
            ${startX + timing.x2 * width2 - half} ${startY + width2 - timing.y2 * width2 - half}  
            ${startX + width2 - half} ${startY + 0 - half}
        `
        });
    }
  }
  makeTimingCircle(colorstepIndex, current, prev) {
    const prevStickScreenXY = prev.stickScreenXYInEnd;
    const stickScreenXY = current.stickScreenXYInStart;
    const { timing, timingCount } = current;
    let pos;
    switch (timing.name) {
      case TimingFunction.LINEAR:
        return ``;
      case TimingFunction.STEPS:
        pos = lerp([], prevStickScreenXY, stickScreenXY, 0.5);
        return /* @__PURE__ */ createElementJsx(FragmentInstance, null, /* @__PURE__ */ createElementJsx("circle", {
          class: "step-point",
          "data-colorstep-index": colorstepIndex,
          cx: pos[0],
          cy: pos[1],
          r: 7
        }), /* @__PURE__ */ createElementJsx("text", {
          x: pos[0],
          y: pos[1],
          dy: 4,
          "text-anchor": "middle"
        }, timing.count));
      default:
        pos = lerp([], prevStickScreenXY, stickScreenXY, 0.5);
        return /* @__PURE__ */ createElementJsx(FragmentInstance, null, /* @__PURE__ */ createElementJsx("circle", {
          class: "step-point",
          "data-colorstep-index": colorstepIndex,
          cx: pos[0],
          cy: pos[1],
          r: 7
        }), /* @__PURE__ */ createElementJsx("text", {
          x: pos[0],
          y: pos[1],
          dy: 4,
          "text-anchor": "middle"
        }, timingCount));
    }
  }
  makeConicTimingCircle(startPoint, colorstepIndex, current, prev) {
    const prevStickScreenXY = prev.stickScreenXY;
    const stickScreenXY = current.stickScreenXY;
    const { timing, timingCount } = current;
    const dist$1 = dist(prevStickScreenXY, startPoint);
    const prevAngle = calculateAngle360(...subtract([], prevStickScreenXY, startPoint));
    const angle = calculateAngle360(...subtract([], stickScreenXY, startPoint));
    let nextAngle = this.getRealAngle(prevAngle + (angle - prevAngle) / 2);
    const bigArc = Math.abs(angle - prevAngle) % 360 >= 180 ? 1 : 0;
    if (bigArc) {
      nextAngle -= 180;
    }
    var [pos] = vertiesMap([lerp([], startPoint, add$1([], startPoint, [-1, 0, 0]), dist$1)], calculateRotationOriginMat4(nextAngle, startPoint));
    switch (timing.name) {
      case TimingFunction.LINEAR:
        return ``;
      case TimingFunction.STEPS:
        return /* @__PURE__ */ createElementJsx(FragmentInstance, null, /* @__PURE__ */ createElementJsx("circle", {
          class: "step-point",
          "data-colorstep-index": colorstepIndex,
          cx: pos[0],
          cy: pos[1],
          r: 7
        }), /* @__PURE__ */ createElementJsx("text", {
          x: pos[0],
          y: pos[1],
          dy: 4,
          "text-anchor": "middle"
        }, timing.count));
      default:
        return /* @__PURE__ */ createElementJsx(FragmentInstance, null, /* @__PURE__ */ createElementJsx("circle", {
          class: "step-point",
          "data-colorstep-index": colorstepIndex,
          cx: pos[0],
          cy: pos[1],
          r: 7
        }), /* @__PURE__ */ createElementJsx("text", {
          x: pos[0],
          y: pos[1],
          dy: 4,
          "text-anchor": "middle"
        }, timingCount));
    }
  }
  makeTimingArea(colorstepIndex, current, prev, size2) {
    const prevStickScreenXY = prev.stickScreenXYInEnd;
    const stickScreenXY = current.stickScreenXYInStart;
    return /* @__PURE__ */ createElementJsx("g", {
      class: "timing-area"
    }, current.timing.name === TimingFunction.LINEAR ? `` : /* @__PURE__ */ createElementJsx("path", {
      class: "timing-path",
      d: `
              M ${prevStickScreenXY[0]} ${prevStickScreenXY[1]}
              L ${stickScreenXY[0]} ${stickScreenXY[1]}
            `
    }), this.makeTimingCircle(colorstepIndex, current, prev, size2));
  }
  getRealAngle(angle) {
    return angle < 0 ? 360 + angle : angle;
  }
  makeConicTimingArea(startPoint, colorstepIndex, current, prev, size2, dist2, startAngle) {
    const prevStickScreenXY = prev.stickScreenXY;
    const stickScreenXY = current.stickScreenXY;
    const prevAngle = calculateAngle360(...subtract([], prevStickScreenXY, startPoint)) + startAngle;
    const angle = calculateAngle360(...subtract([], stickScreenXY, startPoint)) + startAngle;
    const nextAngle = 360 - prevAngle;
    const nextAngle2 = angle;
    const bigArc = Math.abs(nextAngle + nextAngle2) % 360 >= 180 ? 1 : 0;
    return /* @__PURE__ */ createElementJsx("g", {
      class: "timing-area"
    }, current.timing.name === TimingFunction.LINEAR ? `` : /* @__PURE__ */ createElementJsx(FragmentInstance, null, /* @__PURE__ */ createElementJsx("path", {
      class: "timing-path",
      d: `
              M ${prevStickScreenXY[0]} ${prevStickScreenXY[1]}
              A ${dist2} ${dist2} 0 ${bigArc} 1 ${stickScreenXY[0]} ${stickScreenXY[1]}
            `
    })), this.makeConicTimingCircle(startPoint, colorstepIndex, current, prev, dist2));
  }
  makeGradientPoint(colorsteps, startPoint, endPoint, shapePoint, newHoverColorStepPoint) {
    const size2 = TOOL_SIZE;
    const dist2 = subtract([], endPoint, startPoint);
    const angle = calculateAngle360(dist2[0], dist2[1]) - 180;
    return /* @__PURE__ */ createElementJsx(FragmentInstance, null, colorsteps.map((it, index2) => {
      if (index2 === 0)
        return "";
      return this.makeTimingArea(index2, it, colorsteps[index2 - 1], TOOL_SIZE);
    }), colorsteps.map((it, index2) => {
      return /* @__PURE__ */ createElementJsx("g", {
        transform: `rotate(${angle} ${it.stickScreenXY[0]} ${it.stickScreenXY[1]})`
      }, /* @__PURE__ */ createElementJsx("rect", {
        id: it.id,
        "data-index": index2,
        class: "colorstep",
        x: it.stickScreenXY[0],
        y: it.stickScreenXY[1],
        width: size2,
        height: size2,
        fill: it.color,
        tabIndex: -1,
        "data-x": it.screenXY[0],
        "data-y": it.screenXY[1]
      }), this.makeTimingLine(it.timing, size2, it.stickScreenXY[0], it.stickScreenXY[1]));
    }), /* @__PURE__ */ createElementJsx("circle", {
      class: "point",
      "data-type": "start",
      cx: startPoint[0],
      cy: startPoint[1]
    }), /* @__PURE__ */ createElementJsx("circle", {
      class: "point",
      "data-type": "end",
      cx: endPoint[0],
      cy: endPoint[1]
    }), shapePoint && /* @__PURE__ */ createElementJsx("circle", {
      class: "point",
      "data-type": "shape",
      cx: shapePoint[0],
      cy: shapePoint[1]
    }), newHoverColorStepPoint && /* @__PURE__ */ createElementJsx("circle", {
      class: "hover-colorstep",
      r: "5",
      cx: newHoverColorStepPoint[0],
      cy: newHoverColorStepPoint[1],
      fill: this.state.hoverColorStep.color
    }));
  }
  makeConicGradientPoint(colorsteps, startPoint, endPoint, shapePoint, newHoverColorStepPoint, dist2, startAngle) {
    const size2 = TOOL_SIZE;
    return /* @__PURE__ */ createElementJsx(FragmentInstance, null, colorsteps.map((it, index2) => {
      if (index2 === 0)
        return "";
      return this.makeConicTimingArea(startPoint, index2, it, colorsteps[index2 - 1], TOOL_SIZE, dist2, startAngle);
    }), colorsteps.map((it, index2) => {
      const angle = calculateAngle360(...subtract([], it.screenXY, startPoint)) - 180;
      return /* @__PURE__ */ createElementJsx("g", {
        transform: `rotate(${angle} ${it.screenXY[0]} ${it.screenXY[1]})`
      }, /* @__PURE__ */ createElementJsx("rect", {
        id: it.id,
        "data-index": index2,
        class: "colorstep",
        x: it.screenXY[0] - size2 / 2,
        y: it.screenXY[1] - size2 / 2,
        width: size2,
        height: size2,
        fill: it.color,
        tabIndex: -1,
        "data-x": it.screenXY[0],
        "data-y": it.screenXY[1]
      }), this.makeConicTimingLine(it.timing, size2, it.screenXY[0], it.screenXY[1], startAngle));
    }), /* @__PURE__ */ createElementJsx("circle", {
      class: "point",
      "data-type": "start",
      cx: startPoint[0],
      cy: startPoint[1]
    }), /* @__PURE__ */ createElementJsx("circle", {
      class: "point",
      "data-type": "end",
      cx: endPoint[0],
      cy: endPoint[1]
    }), shapePoint && /* @__PURE__ */ createElementJsx("circle", {
      class: "point",
      "data-type": "shape",
      cx: shapePoint[0],
      cy: shapePoint[1]
    }), newHoverColorStepPoint && /* @__PURE__ */ createElementJsx("circle", {
      class: "hover-colorstep",
      r: "5",
      cx: newHoverColorStepPoint[0],
      cy: newHoverColorStepPoint[1],
      fill: this.state.hoverColorStep.color
    }));
  }
  makeGradientRect(result) {
    const boxPosition = this.$viewport.applyVerties(result.backVerties);
    return /* @__PURE__ */ createElementJsx(FragmentInstance, null, /* @__PURE__ */ createElementJsx("div", {
      class: "gradient-rect"
    }, /* @__PURE__ */ createElementJsx("svg", null, /* @__PURE__ */ createElementJsx("path", {
      class: "back-rect",
      d: `
                    M ${boxPosition[0][0]} ${boxPosition[0][1]}
                    L ${boxPosition[1][0]} ${boxPosition[1][1]}
                    L ${boxPosition[2][0]} ${boxPosition[2][1]}
                    L ${boxPosition[3][0]} ${boxPosition[3][1]}
                    Z
                `
    }))), /* @__PURE__ */ createElementJsx("div", {
      class: "resizer",
      "data-direction": "bottom-right",
      style: {
        left: Length.px(boxPosition[2][0]),
        top: Length.px(boxPosition[2][1])
      }
    }));
  }
  makeCenterPoint(result) {
    const { image: image2 } = result.backgroundImage;
    switch (image2.type) {
      case GradientType.LINEAR:
      case GradientType.REPEATING_LINEAR:
        return this.makeLinearCenterPoint(result);
      case GradientType.RADIAL:
      case GradientType.REPEATING_RADIAL:
        return this.makeRadialCenterPoint(result);
      case GradientType.CONIC:
      case GradientType.REPEATING_CONIC:
        return this.makeConicCenterPoint(result);
    }
    return "";
  }
  makeConicCenterPoint(result) {
    const { image: image2 } = result.backgroundImage;
    let centerPosition, centerStick;
    let startPoint, endPoint, shapePoint, colorsteps;
    centerPosition = this.$viewport.applyVertex(result.radialCenterPosition);
    startPoint = this.$viewport.applyVertex(result.startPoint);
    endPoint = this.$viewport.applyVertex(result.endPoint);
    shapePoint = this.$viewport.applyVertex(result.shapePoint);
    let lastDist = dist(startPoint, endPoint) / 2;
    if (lastDist < 50) {
      lastDist = 50;
    }
    colorsteps = result.colorsteps.map((it) => {
      it.screenXY = this.$viewport.applyVertex(it.pos);
      const pointDist = dist(it.screenXY, startPoint);
      if (pointDist < lastDist) {
        it.screenXY = lerp([], startPoint, lerp([], startPoint, it.screenXY, 1 / pointDist), lastDist + 20);
      } else if (pointDist > lastDist) {
        it.screenXY = lerp([], startPoint, it.screenXY, (lastDist + 20) / pointDist);
      }
      it.stickScreenXY = clone(it.screenXY);
      const dist$1 = subtract([], it.screenXY, startPoint);
      it.angle = calculateAngle360(dist$1[0], dist$1[1]);
      return it;
    });
    centerPosition = this.$viewport.applyVertex(result.radialCenterPosition);
    const stickPoint = this.$viewport.applyVertex(result.shapePoint);
    centerStick = lerp([], centerPosition, lerp([], centerPosition, stickPoint, 1 / dist(centerPosition, stickPoint)), lastDist + 50);
    const targetStick = lerp([], centerStick, centerPosition, 1);
    let newHoverColorStepPoint = null;
    if (this.state.hoverColorStep) {
      const hoverAngle = this.state.hoverColorStep.percent * 3.6;
      const originDist = dist(centerPosition, shapePoint);
      [newHoverColorStepPoint] = vertiesMap([
        lerp([], centerPosition, shapePoint, (lastDist + 20) / originDist)
      ], calculateRotationOriginMat4(hoverAngle, centerPosition));
    }
    return /* @__PURE__ */ createElementJsx(FragmentInstance, null, /* @__PURE__ */ createElementJsx("div", {
      class: "gradient-position center",
      "data-radial-type": image2.radialType,
      style: {
        left: Length.px(centerPosition[0]),
        top: Length.px(centerPosition[1])
      }
    }), /* @__PURE__ */ createElementJsx("svg", {
      class: "gradient-angle"
    }, /* @__PURE__ */ createElementJsx("circle", {
      class: "size",
      cx: startPoint[0],
      cy: startPoint[1],
      r: lastDist
    }), /* @__PURE__ */ createElementJsx("circle", {
      class: "area-line",
      cx: startPoint[0],
      cy: startPoint[1],
      r: lastDist
    }), /* @__PURE__ */ createElementJsx("path", {
      class: "stick",
      d: `
                M ${targetStick[0]} ${targetStick[1]}
                L ${centerStick[0]} ${centerStick[1]}
            `
    }), /* @__PURE__ */ createElementJsx("circle", {
      class: "rotate",
      cx: centerStick[0],
      cy: centerStick[1],
      r: "7",
      "data-center-x": centerPosition[0],
      "data-center-y": centerPosition[1]
    }), this.makeConicGradientPoint(colorsteps, startPoint, endPoint, shapePoint, newHoverColorStepPoint, lastDist + 20, image2.angle)));
  }
  makeRadialCenterPoint(result) {
    let colorsteps, startPoint, endPoint, shapePoint;
    startPoint = this.$viewport.applyVertex(result.startPoint);
    endPoint = this.$viewport.applyVertex(result.endPoint);
    shapePoint = this.$viewport.applyVertex(result.shapePoint);
    colorsteps = this.makeStickPoint(result.colorsteps, startPoint, endPoint);
    let newHoverColorStepPoint = null;
    if (this.state.hoverColorStep) {
      newHoverColorStepPoint = lerp([], startPoint, endPoint, this.state.hoverColorStep.percent / 100);
    }
    return /* @__PURE__ */ createElementJsx(FragmentInstance, null, /* @__PURE__ */ createElementJsx("svg", {
      class: "gradient-radial-line"
    }, /* @__PURE__ */ createElementJsx("path", {
      d: `
              M ${startPoint[0]} ${startPoint[1]}
              L ${endPoint[0]} ${endPoint[1]}
          `,
      class: "area-line"
    }), /* @__PURE__ */ createElementJsx("path", {
      d: `
              M ${startPoint[0]} ${startPoint[1]}
              L ${endPoint[0]} ${endPoint[1]}
          `,
      class: "start-end-line"
    }), /* @__PURE__ */ createElementJsx("path", {
      d: `
              M ${startPoint[0]} ${startPoint[1]}
              L ${shapePoint[0]} ${shapePoint[1]}
          `,
      class: "shape-line"
    }), this.makeGradientPoint(colorsteps, startPoint, endPoint, shapePoint, newHoverColorStepPoint)));
  }
  makeStickPoint(colorsteps, startPoint, endPoint) {
    const size2 = TOOL_SIZE;
    const dist2 = subtract([], endPoint, startPoint);
    const angle = calculateAngle360(dist2[0], dist2[1]) - 180;
    const rotateInverse = calculateRotationOriginMat4(-angle, startPoint);
    const rotateInverseInverse = invert([], rotateInverse);
    return colorsteps.map((it) => {
      it.screenXY = this.$viewport.applyVertex(it.pos);
      const [newScreenXY] = vertiesMap([it.screenXY], rotateInverse);
      [it.stickScreenXY, it.stickScreenXYInStart, it.stickScreenXYInEnd] = vertiesMap([
        [newScreenXY[0] - size2 / 2, newScreenXY[1] - size2 * 1.5, 0],
        [
          newScreenXY[0] - size2 / 2,
          newScreenXY[1] - size2 * 1.5 + size2 / 2,
          0
        ],
        [
          newScreenXY[0] + size2 / 2,
          newScreenXY[1] - size2 * 1.5 + size2 / 2,
          0
        ]
      ], rotateInverseInverse);
      return it;
    });
  }
  makeLinearCenterPoint(result) {
    let centerPosition, centerStick, startPoint, endPoint, areaStartPoint, areaEndPoint, colorsteps;
    startPoint = this.$viewport.applyVertex(result.startPoint);
    endPoint = this.$viewport.applyVertex(result.endPoint);
    areaStartPoint = this.$viewport.applyVertex(result.areaStartPoint);
    areaEndPoint = this.$viewport.applyVertex(result.areaEndPoint);
    centerPosition = this.$viewport.applyVertex(result.centerPosition);
    colorsteps = this.makeStickPoint(result.colorsteps, startPoint, endPoint);
    const lastDist = dist(centerPosition, endPoint);
    const [stickPoint] = vertiesMap([endPoint], calculateRotationOriginMat4(90, lerp([], startPoint, endPoint, 0.5)));
    centerStick = lerp([], centerPosition, lerp([], centerPosition, stickPoint, 1 / dist(centerPosition, stickPoint)), lastDist + 20);
    const targetStick = lerp([], centerStick, centerPosition, 20 / (lastDist + 20));
    let newHoverColorStepPoint = null;
    if (this.state.hoverColorStep) {
      newHoverColorStepPoint = lerp([], startPoint, endPoint, this.state.hoverColorStep.percent / 100);
    }
    return /* @__PURE__ */ createElementJsx("svg", {
      class: "gradient-angle"
    }, /* @__PURE__ */ createElementJsx("path", {
      class: "stick",
      d: `
              M ${targetStick[0]} ${targetStick[1]}
              L ${centerStick[0]} ${centerStick[1]}
          `
    }), /* @__PURE__ */ createElementJsx("circle", {
      class: "size",
      cx: centerPosition[0],
      cy: centerPosition[1],
      r: dist(centerPosition, startPoint)
    }), /* @__PURE__ */ createElementJsx("circle", {
      class: "rotate",
      cx: centerStick[0],
      cy: centerStick[1],
      r: "7",
      "data-center-x": centerPosition[0],
      "data-center-y": centerPosition[1]
    }), /* @__PURE__ */ createElementJsx("path", {
      d: `
              M ${areaStartPoint[0]} ${areaStartPoint[1]}
              L ${areaEndPoint[0]} ${areaEndPoint[1]}
          `,
      class: "area-line"
    }), /* @__PURE__ */ createElementJsx("path", {
      d: `
              M ${startPoint[0]} ${startPoint[1]}
              L ${endPoint[0]} ${endPoint[1]}
          `,
      class: "start-end-line"
    }), this.makeGradientPoint(colorsteps, startPoint, endPoint, null, newHoverColorStepPoint));
  }
  [LOAD("$el") + DOMDIFF]() {
    const current = this.$context.selection.current;
    if (!current)
      return "";
    const result = current.createBackgroundImageMatrix(this.state.index);
    this.state.lastBackgroundMatrix = result;
    const image2 = result.backgroundImage.image;
    switch (image2.type) {
      case GradientType.LINEAR:
      case GradientType.REPEATING_LINEAR:
        this.state.centerPosition = this.$viewport.applyVertex(result.centerPosition);
        this.state.startPoint = this.$viewport.applyVertex(result.startPoint);
        this.state.endPoint = this.$viewport.applyVertex(result.endPoint);
        this.state.rotateInverse = calculateRotationOriginMat4(-1 * result.backgroundImage.image.angle, this.state.centerPosition);
        break;
      case GradientType.RADIAL:
      case GradientType.REPEATING_RADIAL:
        this.state.centerPosition = this.$viewport.applyVertex(result.radialCenterPosition);
        this.state.startPoint = this.$viewport.applyVertex(result.startPoint);
        this.state.endPoint = this.$viewport.applyVertex(result.endPoint);
        break;
      case GradientType.CONIC:
      case GradientType.REPEATING_CONIC:
        this.state.centerPosition = this.$viewport.applyVertex(result.radialCenterPosition);
        this.state.startPoint = this.$viewport.applyVertex(result.shapePoint);
        break;
    }
    return /* @__PURE__ */ createElementJsx("div", null, this.makeGradientRect(result), image2.type === GradientType.STATIC || image2.type === GradientType.IMAGE ? null : this.makeCenterPoint(result));
  }
}
function gradientEditorView(editor) {
  editor.registerUI("canvas.view", {
    GradientEditorView
  });
}
var GuideLineView$1 = "";
const line = (source2, target, className = "base-line") => {
  return `<line x1="${source2[0]}" y1="${source2[1]}" x2="${target[0]}" y2="${target[1]}" class='${className}' />`;
};
const hLineByPoint = (target, source2) => {
  return line(target, source2);
};
const vLineByPoint = (target, source2) => {
  return line(target, source2);
};
const rect = (rectVerties) => {
  return `<path class="base-rect" fill="none" stroke-width="1" stroke="red" stroke-dasharray="2 2" d="${PathParser.makeRect(rectVerties[0][0], rectVerties[0][1], dist(rectVerties[0], rectVerties[1]), dist(rectVerties[0], rectVerties[3])).d}" />`;
};
const point = (target, dist2 = 3, direction2 = "left") => {
  if (direction2 === "left") {
    return `<path class="arrow" d="M ${target[0] + dist2} ${target[1] - dist2} L ${target[0]} ${target[1]} L ${target[0] + dist2} ${target[1] + dist2} "/>`;
  }
  if (direction2 === "right") {
    return `<path class="arrow" d=" M ${target[0] - dist2} ${target[1] - dist2} L ${target[0]} ${target[1]} L ${target[0] - dist2} ${target[1] + dist2}" />`;
  }
  if (direction2 === "up") {
    return `<path class="arrow" d=" M ${target[0] - dist2} ${target[1] + dist2} L ${target[0]} ${target[1]} L ${target[0] + dist2} ${target[1] + dist2}" />`;
  }
  if (direction2 === "down") {
    return `<path class="arrow" d=" M ${target[0] - dist2} ${target[1] - dist2} L ${target[0]} ${target[1]} L ${target[0] + dist2} ${target[1] - dist2}" />`;
  }
  return `<path stroke-width="1" d=" M ${target[0] - dist2} ${target[1] - dist2} L ${target[0] + dist2} ${target[1] + dist2} M ${target[0] - dist2} ${target[1] + dist2} L ${target[0] + dist2} ${target[1] - dist2}" />`;
};
class GuideLineView extends EditorElement {
  template() {
    return `<svg class='elf--guide-line-view' ref="$guide" width="100%" height="100%" ></svg>`;
  }
  initState() {
    return {
      list: []
    };
  }
  [BIND("$guide")]() {
    const line2 = this.createGuideLine(this.state.list);
    return {
      svgDiff: `<svg>${line2}</svg>`
    };
  }
  createLayerLine() {
    return "";
  }
  filterGuideLine(list2) {
    list2 = list2.filter(Boolean);
    return list2;
  }
  createGuideLine(list2) {
    var images = [];
    var texts = [];
    list2 = this.filterGuideLine(list2);
    for (var i = 0, len2 = list2.length; i < len2; i++) {
      const [
        source2,
        target,
        axis,
        dist$1,
        newTarget,
        sourceVerties,
        targetVerties
      ] = list2[i];
      const localDist = dist(source2, target);
      const localSourceVertex = this.$viewport.applyVertex(source2);
      const localTargetVertex = this.$viewport.applyVertex(target);
      let localNewTargetVertex;
      if (newTarget) {
        localNewTargetVertex = this.$viewport.applyVerties([newTarget])[0];
      }
      if (axis === "x") {
        if (localDist > 0) {
          images.push(line(localSourceVertex, localTargetVertex, "dash-line"));
        }
        if (localNewTargetVertex) {
          images.push(line(localTargetVertex, localNewTargetVertex, "dash-line"));
        }
      }
      if (axis === "y") {
        if (localDist > 0) {
          images.push(line(localSourceVertex, localTargetVertex, "dash-line"));
        }
        if (localNewTargetVertex) {
          images.push(line(localTargetVertex, localNewTargetVertex, "dash-line"));
        }
      }
      if (axis === "x") {
        images.push(hLineByPoint(localTargetVertex, localSourceVertex));
      }
      if (axis === "y") {
        images.push(vLineByPoint(localTargetVertex, localSourceVertex));
      }
      if (this.state.hasVerties) {
        images.push(point(localSourceVertex, 3, "vertex"));
        images.push(point(localTargetVertex, 3, "vertex"));
      }
      if (sourceVerties) {
        if (this.$context.selection.isOne && this.$editor.isPointerDown || this.$context.selection.isMany && !this.$editor.isPointerMove) {
          images.push(rect(this.$viewport.applyVerties(sourceVerties)));
        }
      }
      if (targetVerties) {
        images.push(rect(this.$viewport.applyVerties(targetVerties)));
      }
    }
    return [...images, ...texts].join("");
  }
  removeGuideLine() {
    this.setState({
      list: []
    });
  }
  setGuideLine(list2, hasVerties = false) {
    this.setState({
      list: list2,
      hasVerties
    });
  }
  refreshSmartGuides(targetVertiesList) {
    if (this.$context.selection.isEmpty)
      return;
    const sourceVerties = toRectVerties(this.$context.selection.verties);
    let targetList;
    if (targetVertiesList) {
      targetList = targetVertiesList.map((it) => toRectVerties(it));
    } else {
      const targets = this.$context.snapManager.snapTargetLayers.map((target) => {
        const rectVerties = toRectVerties(target.verties);
        return {
          targetVerties: rectVerties,
          dist: dist(rectVerties[4], sourceVerties[4])
        };
      });
      targets.sort((a, b) => {
        return a.dist - b.dist;
      });
      targetList = targets.map((target) => target.targetVerties);
    }
    const xList = targetList.map((targetVerties) => makeGuidePoint(sourceVerties, targetVerties));
    xList.sort((a, b) => {
      return a[3] - b[3];
    });
    const list2 = [xList[0], xList[1]].filter(Boolean);
    this.setGuideLine(list2);
  }
  refreshSmartGuidesForVerties(dist2 = 0) {
    let verties = this.$context.selection.verties;
    if (verties.length) {
      verties = [
        ...verties,
        lerp([], verties[0], verties[1], 0.5),
        lerp([], verties[1], verties[2], 0.5),
        lerp([], verties[2], verties[3], 0.5),
        lerp([], verties[3], verties[0], 0.5)
      ];
    }
    const guides = this.$context.snapManager.findGuide(verties, dist2);
    this.setGuideLine(guides, true);
  }
  [SUBSCRIBE("removeGuideLine", REFRESH_SELECTION)]() {
    this.removeGuideLine();
  }
  [SUBSCRIBE("refreshGuideLineByTarget")](targetVertiesList = []) {
    return this.refreshSmartGuides(targetVertiesList);
  }
  get currentDistWithScale() {
    return 1 / this.$viewport.scale;
  }
  [SUBSCRIBE(UPDATE_VIEWPORT, REFRESH_SELECTION_TOOL)]() {
    this.refreshSmartGuidesForVerties(this.currentDistWithScale);
  }
  [SUBSCRIBE(UPDATE_CANVAS)]() {
    const expect = this.$context.selection.hasChangedField("d", "clip-path");
    if (!expect) {
      this.refreshSmartGuidesForVerties(this.currentDistWithScale);
    }
  }
}
function guideLineView(editor) {
  editor.registerUI("canvas.view", {
    GuideLineView
  });
}
var HistoryProperty$1 = "";
class HistoryProperty extends BaseProperty {
  afterRender() {
    this.show();
  }
  getTitle() {
    return "History";
  }
  getBody() {
    return `
      <div class="elf--history-list-view" ref='$body'></div>
    `;
  }
  [LOAD("$body") + DOMDIFF]() {
    return this.$editor.context.history.map((it, index2) => {
      if (it === "-") {
        return `<div class='divider'>-</div>`;
      }
      return `
        <div class='history-item'>
          <span>${index2 === this.$editor.context.history.currentIndex ? obj$2.arrowRight : ""}</span>
          <span>${it.message}</span>
        </div>
      `;
    });
  }
  [SUBSCRIBE("refreshHistoryList")]() {
    this.refresh();
  }
}
function history(editor) {
  editor.registerUI("inspector.tab.history", {
    HistoryProperty
  });
}
var HoverView$1 = "";
class HoverView extends EditorElement {
  template() {
    return /* @__PURE__ */ createElementJsx("div", {
      class: "elf--hover-view sepia(0.2)"
    }, /* @__PURE__ */ createElementJsx("div", {
      class: "elf--hover-rect",
      ref: "$hoverRect"
    }));
  }
  checkModeView() {
    const e = this.$config.get("bodyEvent");
    if (!this.$viewport.checkInViewport(this.$viewport.getWorldPosition(e))) {
      return false;
    }
    const canvas = Dom.create(e.target).closest("elf--page-container");
    if (!canvas)
      return false;
    return this.$modeView.isCurrentMode(ViewModeType.CanvasView) && this.$stateManager.isPointerUp;
  }
  [CONFIG("bodyEvent") + IF("checkModeView")]() {
    var _a, _b, _c;
    if (this.$config.true("set.move.control.point")) {
      this.$context.selection.setHoverId("");
      this.renderHoverLayer();
      return;
    }
    const filteredList = this.$context.selection.filteredLayers;
    const point2 = this.$viewport.getWorldPosition(this.$config.get("bodyEvent"));
    const items = filteredList.filter((it) => it.hasPoint(point2[0], point2[1])).filter((it) => it.isNot("artboard"));
    let hoverItems = items;
    let id = (_a = hoverItems[0]) == null ? void 0 : _a.id;
    if (this.$context.selection.isEmpty) {
      id = (_b = hoverItems[0]) == null ? void 0 : _b.id;
    } else if (this.$context.selection.isOne) {
      const pathIds = this.$context.selection.current.pathIds;
      hoverItems = hoverItems.filter((it) => pathIds.includes(it.id) === false || it.id === this.$context.selection.current.id);
      id = (_c = hoverItems[0]) == null ? void 0 : _c.id;
    }
    if (!id) {
      this.$context.selection.setHoverId("");
      this.renderHoverLayer();
    } else {
      if (this.$context.selection.setHoverId(id)) {
        this.renderHoverLayer();
      }
    }
  }
  [CONFIG("set.move.control.point")]() {
    this.renderHoverLayer();
  }
  [SUBSCRIBE("refreshHoverView")](id) {
    if (this.$context.selection.setHoverId(id)) {
      this.renderHoverLayer();
    }
  }
  [SUBSCRIBE(UPDATE_VIEWPORT, UPDATE_CANVAS)]() {
    this.$context.selection.setHoverId("");
    this.renderHoverLayer();
  }
  createVisiblePath(current) {
    if (!current.is("boolean-path")) {
      return "";
    }
    const newPath = current.absolutePath();
    newPath.transformMat4(this.$viewport.matrix);
    return `
        <svg overflow="visible">
            <path
                d="${newPath.d}"
                stroke="red"
                stroke-width="2"
                fill="none"
                />
        </svg>
        `;
  }
  renderHoverLayer() {
    const items = this.$context.selection.hoverItems;
    if (items.length === 0) {
      this.refs.$hoverRect.updateDiff("");
    } else {
      const verties = items[0].verties;
      const line2 = this.createPointerLine(this.$viewport.applyVerties(verties));
      const offsetLine = this.createOffsetLine();
      this.refs.$hoverRect.updateDiff(line2 + offsetLine);
    }
  }
  getOffsetVerties(current, parent) {
    const currentVerties = current.verties;
    const parentVerties = parent.verties;
    const result = {};
    const left2 = this.$viewport.applyVerties([
      [
        currentVerties[0][0],
        lerp([], currentVerties[0], currentVerties[3], 0.5)[1],
        0
      ],
      [
        parentVerties[0][0],
        lerp([], currentVerties[0], currentVerties[3], 0.5)[1],
        0
      ]
    ]);
    var dist$1 = dist(...left2);
    if (dist$1 > 0) {
      result.left = left2;
    }
    const top2 = this.$viewport.applyVerties([
      [
        lerp([], currentVerties[0], currentVerties[1], 0.5)[0],
        currentVerties[1][1],
        0
      ],
      [
        lerp([], currentVerties[0], currentVerties[1], 0.5)[0],
        parentVerties[1][1],
        0
      ]
    ]);
    var dist$1 = dist(...top2);
    if (dist$1 > 0) {
      result.top = top2;
    }
    return result;
  }
  createOffsetLine() {
    const item = this.$context.selection.hoverItems[0] || this.$context.selection.current;
    if (!item || !item.parent) {
      return "";
    }
    if (item.parent && item.parent.is("project")) {
      return "";
    }
    if (this.$context.selection.isEmpty) {
      const offsetVerties = this.getOffsetVerties(item, item.parent);
      return `
            <svg overflow="visible">
                <path
                    class="offset-line"
                    d="
                        ${vertiesToPath(offsetVerties.left)}
                        ${vertiesToPath(offsetVerties.right)}
                        ${vertiesToPath(offsetVerties.top)}
                        ${vertiesToPath(offsetVerties.bottom)}
                    "
                    />
            </svg>
            `;
    } else {
      const offsetVerties = this.getOffsetVerties(item, this.$context.selection.current);
      return `
            <svg overflow="visible">
                <path
                    d="
                        ${vertiesToPath(offsetVerties.left)}
                        ${vertiesToPath(offsetVerties.top)}
                    "
                    stroke="red"
                    stroke-width="1"
                    stroke-dasharray="5, 10"
                    fill="none"
                    />
            </svg>
            `;
    }
  }
  createPointerLine(pointers) {
    if (pointers.length === 0)
      return "";
    pointers = pointers.filter((_, index2) => index2 < 4);
    return `<svg overflow="visible"><path class='line' d="${vertiesToPath(pointers)}" /></svg>`;
  }
}
function hoverView(editor) {
  editor.registerUI("canvas.view", {
    HoverView
  });
}
const image_size = [
  "",
  "100x100",
  "200x200",
  "300x300",
  "400x300",
  "900x600",
  "1024x762"
];
class ImageProperty extends BaseProperty {
  getClassName() {
    return "item";
  }
  getTitle() {
    return this.$i18n("image.property.title");
  }
  getBody() {
    return `<div ref='$body' style='padding-top: 3px;'></div>`;
  }
  getFooter() {
    return `
      <div>
        <label> ${this.$i18n("image.property.origin")} </label> 
        <span ref='$sizeInfo'></span> 
        <button type="button" ref='$resize'>${iconUse("size")}</button>
      </div>
      <div>
        ${createComponent("SelectEditor", {
      ref: "$select",
      label: this.$i18n("image.property.size"),
      key: "size",
      value: "",
      options: image_size,
      onchange: "changeImageSize"
    })}

      </div>
    `;
  }
  [SUBSCRIBE_SELF("changeImageSize")](key, value) {
    var [width2, height2] = value.split("x").map((it) => it);
    this.$commands.executeCommand("setAttribute", "resize image", this.$context.selection.packByValue({
      width: width2,
      height: height2
    }));
  }
  [CLICK("$resize")]() {
    var current = this.$context.selection.current;
    if (current) {
      this.$commands.executeCommand("setAttribute", "resize image", this.$context.selection.packByValue({
        width: (item) => item.naturalWidth,
        height: (item) => item.naturalHeight
      }));
    }
  }
  [BIND("$sizeInfo")]() {
    var current = this.$context.selection.current || {};
    return {
      innerHTML: `${this.$i18n("image.property.width")}: ${current.naturalWidth}, ${this.$i18n("image.property.height")}: ${current.naturalHeight}`
    };
  }
  [LOAD("$body")]() {
    var current = this.$context.selection.current || {};
    var src = current.src || "";
    return createComponent("ImageSelectEditor", {
      ref: "$1",
      key: "src",
      value: src,
      onchange: "changeSelect"
    });
  }
  [SUBSCRIBE_SELF("changeSelect")](key, value, info) {
    var current = this.$context.selection.current;
    if (current) {
      current.reset(__spreadValues({
        src: value
      }, info));
      this.bindData("$sizeInfo");
      this.$commands.executeCommand("setAttribute", "change image", this.$context.selection.packByValue(__spreadValues({
        src: value
      }, info)));
    }
  }
  [SUBSCRIBE(REFRESH_SELECTION) + DEBOUNCE(100)]() {
    this.refreshShow(["image"]);
  }
}
var ImageSelectEditor$1 = "";
class ImageSelectEditor extends EditorElement {
  initState() {
    return {
      key: this.props.key,
      value: this.props.value
    };
  }
  template() {
    return /* @__PURE__ */ createElementJsx("div", {
      class: "elf--image-select-editor",
      ref: "$body"
    });
  }
  getValue() {
    return this.state.value;
  }
  setValue(value) {
    this.setState({ value });
  }
  [LOAD("$body")]() {
    const project2 = this.$context.selection.currentProject;
    if (!project2)
      return;
    const imageUrl = project2.getImageValueById(this.state.value);
    return /* @__PURE__ */ createElementJsx(FragmentInstance, null, /* @__PURE__ */ createElementJsx("div", {
      class: "preview-container"
    }, imageUrl ? /* @__PURE__ */ createElementJsx("img", {
      src: imageUrl
    }) : null, /* @__PURE__ */ createElementJsx("input", {
      type: "file",
      ref: "$file",
      accept: "image/*"
    })), /* @__PURE__ */ createElementJsx("div", {
      class: "select-container"
    }, /* @__PURE__ */ createElementJsx("button", {
      type: "button",
      ref: "$select"
    }, this.$i18n("image.select.editor.button"))));
  }
  [CHANGE("$file")](e) {
    var files = [...e.target.files];
    if (files.length) {
      this.$commands.emit("updateImageAssetItem", files[0], (imageId) => {
        this.trigger("changeImageSelectEditor", imageId);
      });
    }
  }
  [CLICK("$select")]() {
    this.emit("showImageSelectPopup", {
      context: this,
      changeEvent: "changeImageSelectEditor",
      value: this.state.value
    });
  }
  [SUBSCRIBE("changeImageSelectEditor")](value) {
    this.updateData({ value });
    this.refresh();
  }
  updateData(data) {
    this.setState(data, false);
    this.parent.trigger(this.props.onchange, this.props.key, this.state.value, this.props.params);
  }
}
var ImageSelectPopup$1 = "";
class ImageSelectPopup extends BasePopup {
  getTitle() {
    return "Select a image";
  }
  getClassName() {
    return "compact";
  }
  initState() {
    return {
      value: ""
    };
  }
  updateData(opt = {}) {
    this.setState(opt, false);
    this.state.context.trigger(this.state.changeEvent, this.state.value, {
      width: this.state.width,
      height: this.state.height,
      naturalWidth: this.state.naturalWidth,
      naturalHeight: this.state.naturalHeight
    });
  }
  getBody() {
    return `<div class="elf--image-select-popup"><div class='box' ref='$imageBox'></div></div>`;
  }
  [LOAD("$imageBox") + DOMDIFF]() {
    return "";
  }
  [CLICK("$imageBox .image-item")](e) {
    var $img = e.$dt.$("img");
    this.updateData({
      value: $img.attr("data-id"),
      naturalWidth: $img.naturalWidth,
      naturalHeight: $img.naturalHeight,
      width: $img.naturalWidth,
      height: $img.naturalHeight
    });
    this.trigger("hideImageSelectPopup");
  }
  [SUBSCRIBE("showImageSelectPopup")](data, params) {
    this.setState({
      context: data.context,
      changeEvent: data.changeEvent,
      value: data.value,
      params
    }, false);
    this.refresh();
    this.show(500);
  }
  [SUBSCRIBE("hideImageSelectPopup")]() {
    this.hide();
  }
}
function image(editor) {
  editor.registerElement({
    ImageSelectEditor
  });
  editor.registerUI("inspector.tab.style", {
    ImageProperty
  });
  editor.registerUI("popup", {
    ImageSelectPopup
  });
}
class ImageAssetPicker extends EditorElement {
  initState() {
    return {
      mode: "grid"
    };
  }
  template() {
    return `
      <div class='image-asset-picker'>
        <div class='image-list' ref='$imageList' data-view-mode='${this.state.mode}'></div>
      </div>
    `;
  }
  [LOAD("$imageList") + DOMDIFF]() {
    var current = this.$context.selection.currentProject || { images: [] };
    var images = current.images;
    var results = images.map((image2) => {
      return `
        <div class='image-item'>
          <div class='preview'>
            <img src="${image2.local}" />
          </div>
        </div>
      `;
    });
    return results;
  }
  [CLICK("$imageList .image-item")](e) {
    var $img = e.$dt.$("img");
    this.updateData($img.attr("src"));
  }
  updateData(localUrl) {
    this.parent.trigger(this.props.onchange, localUrl);
  }
  [SUBSCRIBE("addImageAsset")]() {
    this.refresh();
  }
}
function imageAsset(editor) {
  editor.registerElement({
    ImageAssetPicker
  });
}
function inspector(editor) {
  editor.context.config.set("inspector.selectedValue", "style");
  editor.registerUI("inspector.tab", {
    Style: {
      title: editor.$i18n("inspector.tab.title.design"),
      value: "style"
    },
    Transition: {
      title: editor.$i18n("inspector.tab.title.transition"),
      value: "transition"
    },
    Code: {
      title: editor.$i18n("inspector.tab.title.code"),
      value: "code"
    }
  });
}
var KeyframePopup$1 = "";
class KeyframePopup extends BasePopup {
  getTitle() {
    return this.$i18n("keyframe.popup.title");
  }
  initState() {
    return {
      name: "none",
      offsets: []
    };
  }
  updateData(opt) {
    this.setState(opt, false);
    this.emit("changeKeyframePopup", this.state);
  }
  getBody() {
    return `
    <div class='elf--keyframe-popup' ref='$popup'>
      <div class="box">
        ${this.templateForName()}
        ${this.templateForOffset()}
      </div>
    </div>`;
  }
  templateForOffset() {
    return `
      <div>
        ${createComponent("OffsetEditor", { ref: "$offsetEditor" })}
      </div>
    `;
  }
  templateForName() {
    return `
      <div class='name'>
        <label>Name</label>
        <div class='input grid-1'>
          <input type='text' value='${this.state.name}' ref='$name'/>
        </div>
      </div>
    `;
  }
  [INPUT("$name")](e) {
    if (this.refs.$name.value.match(/^[a-zA-Z0-9\b]+$/)) {
      this.updateData({ name: this.refs.$name.value });
    } else {
      e.preventDefault();
      e.stopPropagation();
      return false;
    }
  }
  getOffsetData() {
    var offsets = this.state.offsets.map((it) => it);
    return { offsets };
  }
  refresh() {
    this.refs.$name.val(this.state.name);
    this.emit("showOffsetEditor", this.getOffsetData());
  }
  [SUBSCRIBE("changeOffsetEditor")](data) {
    this.updateData(data);
  }
  [SUBSCRIBE("showKeyframePopup")](data) {
    this.setState(data);
    this.refresh();
    this.show(240);
  }
  [SUBSCRIBE("hideKeyframePopup")]() {
    this.$el.hide();
  }
}
var KeyframeProperty$1 = "";
class KeyframeProperty extends BaseProperty {
  getTitle() {
    return this.$i18n("keyframe.property.title");
  }
  getBody() {
    return `<div class='elf--keyframe-list' ref='$keyframeList'></div>`;
  }
  getTools() {
    return `
      <button type="button" ref="$add" title="add Filter">${obj$2.add}</button>
    `;
  }
  makeProperty(property) {
    var key = property.key;
    if (key === "x")
      key = "left";
    else if (key === "y")
      key = "top";
    return `
      <div class='offset-property-item'>
        <label>${key}:</label>
        <div class='value'>${property.value}</div>
      </div>
    `;
  }
  makeOffset(offset) {
    return `
      <div class='offset'>
        <label>${offset.offset}</label>
        <div class='properties'>
          ${offset.properties.map((p) => {
      return this.makeProperty(p);
    }).join("")}
        </div>        
      </div>
    `;
  }
  makeKeyframeTemplate(keyframe2, index2) {
    index2 = index2.toString();
    return `
      <div class='keyframe-item' data-selected-value='${keyframe2.selectedType}' ref='$keyframeIndex${index2}' data-index='${index2}'>
        <div class='title'>
          <div class='name'>${keyframe2.name}</div>
          <div class='tools'>
            <div class='group'>
              <button type="button" data-type='list'>${obj$2.list}</button>
              <button type="button" data-type='code'>${obj$2.code}</button>
            </div>
            <button type="button" class="del" data-index="${index2}">${obj$2.remove2}</button>
          </div>
        </div>
        <div class='offset-list'>
          <div class='container'>
            ${keyframe2.offsets.map((o) => {
      return `
              <div class='offset' style='left: ${o.offset}; background-color: ${o.color}'></div>
              `;
    }).join("")}
          </div>
        </div>
        <div class='keyframe-code' data-type='list'>
          ${keyframe2.offsets.map((offset) => {
      return this.makeOffset(offset);
    }).join("")}
        </div>
        <div class='keyframe-code' data-type='code'>
          <pre>${keyframe2.toString().trim()}</pre>
        </div>        
      </div>
    `;
  }
  [CLICK("$keyframeList .keyframe-item .title .group button[data-type]")](e) {
    var $keyframeItem = e.$dt.closest("keyframe-item");
    var index2 = +$keyframeItem.attr("data-index");
    var type = e.$dt.attr("data-type");
    var current = this.$context.selection.currentProject;
    if (!current)
      return;
    var currentKeyframe = current.keyframes[index2];
    if (currentKeyframe) {
      currentKeyframe.reset({
        selectedType: type
      });
    }
    $keyframeItem.attr("data-selected-value", type);
  }
  [CLICK("$keyframeList .keyframe-item .offset-list")](e) {
    var index2 = +e.$dt.closest("keyframe-item").attr("data-index");
    var current = this.$context.selection.currentProject;
    if (!current)
      return;
    this.viewKeyframePicker(index2);
  }
  [CLICK("$keyframeList .del") + PREVENT](e) {
    var removeIndex = e.$dt.attr("data-index");
    var current = this.$context.selection.currentProject;
    if (!current)
      return;
    current.removeKeyframe(removeIndex);
    this.$commands.emit("refreshProject", current);
    this.refresh();
  }
  [SUBSCRIBE(REFRESH_SELECTION) + DEBOUNCE(100)]() {
    const current = this.$context.selection.current;
    if (current && current.hasChangedField("keyframes")) {
      this.refresh();
    }
  }
  [LOAD("$keyframeList")]() {
    var current = this.$context.selection.currentProject;
    if (!current)
      return "";
    var keyframes = current.keyframes || [];
    return keyframes.map((keyframe2, index2) => {
      return this.makeKeyframeTemplate(keyframe2, index2);
    });
  }
  [CLICK("$add")]() {
    var current = this.$context.selection.currentProject;
    if (current) {
      current.createKeyframe();
      this.refresh();
      this.$commands.emit("refreshProject", current);
    } else {
      window.alert("Please select a project.");
    }
  }
  viewKeyframePicker(index2) {
    if (typeof this.selectedIndex === "number") {
      this.selectItem(this.selectedIndex, false);
    }
    this.selectedIndex = +index2;
    this.selectItem(this.selectedIndex, true);
    this.current = this.$context.selection.currentProject;
    if (!this.current)
      return;
    this.currentKeyframe = this.current.keyframes[this.selectedIndex];
    this.viewKeyframePropertyPopup();
  }
  selectItem(selectedIndex, isSelected = true) {
    if (isSelected) {
      this.getRef("$keyframeIndex", selectedIndex).addClass("selected");
    } else {
      this.getRef("$keyframeIndex", selectedIndex).removeClass("selected");
    }
    if (this.current) {
      this.current.keyframes.forEach((it, index2) => {
        it.selected = index2 === selectedIndex;
      });
    }
  }
  viewKeyframePropertyPopup(position2) {
    this.current = this.$context.selection.currentProject;
    if (!this.current)
      return;
    this.currentKeyframe = this.current.keyframes[this.selectedIndex];
    const back = this.currentKeyframe;
    const name = back.name;
    const offsets = back.offsets;
    this.emit("showKeyframePopup", {
      position: position2,
      name,
      offsets
    });
  }
  [SUBSCRIBE("changeKeyframePopup")](data) {
    var project2 = this.$context.selection.currentProject;
    if (!project2)
      return;
    this.currentKeyframe = project2.keyframes[this.selectedIndex];
    if (this.currentKeyframe) {
      this.currentKeyframe.reset(data);
    }
    this.refresh();
    this.$commands.emit("refreshProject", project2);
  }
}
class OffsetEditor extends EditorElement {
  initState() {
    return {
      offsets: []
    };
  }
  updateData(opt) {
    this.setState(opt, false);
    this.modifyOffset();
  }
  modifyOffset() {
    this.emit("changeOffsetEditor", this.state);
  }
  template() {
    return `
    <div class='editor offset-editor' ref='$editor'>
        ${this.templateForOffset()}
        ${this.templateForOffsetInput()}
        ${this.templateForProperty()}        
    </div>`;
  }
  templateForOffsetInput() {
    return `
      <div class='offset-input' >
        <div class='title'>
          <label>Offset</label>
          <div class='tools'>
            ${createComponent("InputRangeEditor", {
      key: "offset",
      min: 0,
      max: 100,
      step: 0.01,
      value: Length.percent(0),
      ref: "$offsetInput",
      units: "%",
      onchange: "changeRangeEditor"
    })}
          </div>
        </div>
      </div>
    `;
  }
  [SUBSCRIBE("changeRangeEditor")](key, value) {
    var offset = this.state.offsets[this.selectedIndex];
    if (offset) {
      offset.offset = value.clone();
      this.refresh();
      this.modifyOffset();
    }
  }
  templateForProperty() {
    return createComponent("CSSPropertyEditor", {
      ref: "$offsetPropertyEditor",
      "hide-refresh": true,
      onchange: "changeCSSPropertyEditor"
    });
  }
  templateForOffset() {
    return `<div class='offset' ref='$offset' data-selected-value="-1"></div>`;
  }
  makeOffset(offset, index2) {
    return `<div class='offset-item' style='left: ${offset.offset};' data-offset-index='${index2.toString()}'></div>`;
  }
  selectItem(selectedIndex) {
    if (isUndefined(selectedIndex)) {
      selectedIndex = -1;
      for (var i = 0, len2 = this.state.offsets.length; i < len2; i++) {
        if (this.state.offsets[i].selected) {
          selectedIndex = i;
          break;
        }
      }
      if (selectedIndex === -1) {
        selectedIndex = 0;
      }
    }
    this.getRef("$offset").attr("data-selected-value", selectedIndex);
    this.selectedIndex = selectedIndex;
    this.state.offsets.forEach((it, index2) => {
      it.selected = index2 === selectedIndex;
    });
    var selectedList = this.state.offsets.filter((it) => it.selected);
    this.selectedOffsetItem = selectedList.length ? selectedList[0] : {};
    this.refreshOffsetInput();
  }
  refreshOffsetInput() {
    var offset = this.state.offsets[this.selectedIndex];
    if (offset) {
      this.children.$offsetInput.setValue(offset.offset);
    }
  }
  [LOAD("$offset")]() {
    return this.state.offsets.map((it, index2) => {
      return this.makeOffset(it, index2);
    });
  }
  isNotOffsetItem(e) {
    return !Dom.create(e.target).hasClass("offset-item") && !this.currentOffset;
  }
  [CLICK("$offset") + IF("isNotOffsetItem") + PREVENT](e) {
    this.baseOffsetWidth = this.refs.$offset.width();
    this.baseOffsetArea = this.refs.$offset.offset();
    var currentX = e.xy.x;
    var newOffset = Length.percent((currentX - this.baseOffsetArea.left) / this.baseOffsetWidth * 100).round(100);
    this.state.offsets.push(new Offset({
      offset: newOffset
    }));
    this.selectItem(this.state.offsets.length - 1, true);
    this.refresh();
    this.modifyOffset();
  }
  refreshOffsetProperty() {
    this.emit("showCSSPropertyEditor", this.selectedOffsetItem.properties);
  }
  [POINTERSTART("$offset .offset-item") + MOVE("moveOffset") + END("endOffset")](e) {
    this.baseOffsetWidth = this.refs.$offset.width();
    this.baseOffsetArea = this.refs.$offset.offset();
    this.currentOffsetleft = Length.parse(e.$dt.css("left"));
    this.currentOffset = e.$dt;
    this.currentOffsetIndex = +e.$dt.attr("data-offset-index");
    this.currentOffsetXY = e.xy;
    this.baseOffsetMin = this.baseOffsetArea.left;
    this.baseOffsetMax = this.baseOffsetArea.left + this.baseOffsetWidth;
    this.isRemoveOffset = false;
    if (e.altKey) {
      this.isRemoveOffset = true;
    } else {
      this.selectItem(this.currentOffsetIndex, true);
      this.refreshOffsetInput();
    }
  }
  moveOffset(dx) {
    if (this.isRemoveOffset)
      return;
    var currentX = this.currentOffsetXY.x + dx;
    if (currentX < this.baseOffsetMin) {
      currentX = this.baseOffsetMin;
    }
    if (currentX > this.baseOffsetMax) {
      currentX = this.baseOffsetMax;
    }
    var newOffset = Length.percent((currentX - this.baseOffsetMin) / this.baseOffsetWidth * 100).round(100);
    this.state.offsets[this.currentOffsetIndex].offset.set(newOffset.value);
    this.currentOffset.css("left", newOffset);
    this.refreshOffsetInput();
    this.modifyOffset();
  }
  removeOffset(index2) {
    this.state.offsets.splice(index2, 1);
    this.selectItem(0);
    this.refresh();
    this.modifyOffset();
  }
  endOffset() {
    if (this.isRemoveOffset) {
      window.setTimeout(() => {
        this.currentOffset = null;
        this.removeOffset(this.currentOffsetIndex);
      }, 10);
    } else {
      window.setTimeout(() => {
        this.currentOffset = null;
        this.refreshOffsetInput();
        this.refreshOffsetProperty();
        this.modifyOffset();
      }, 10);
    }
  }
  refresh() {
    this.load();
    this.refreshOffsetProperty();
  }
  [SUBSCRIBE("showOffsetEditor")](data) {
    this.setState(data);
    this.selectItem();
    this.refresh();
  }
  [SUBSCRIBE("changeCSSPropertyEditor")](properties = []) {
    var offset = this.state.offsets[this.selectedIndex];
    if (offset) {
      offset.properties = [...properties];
    }
    this.modifyOffset();
  }
}
function keyframe(editor) {
  editor.registerElement({
    OffsetEditor
  });
  editor.registerUI("inspector.tab.transition", {
    KeyframeProperty
  });
  editor.registerUI("popup", {
    KeyframePopup
  });
}
var LayerAppendView$1 = "";
class LayerAppendView extends EditorElement {
  template() {
    return `
        <div class='elf--layer-append-view'>
            <div class='area' ref='$area'></div>
            <div class='area-rect' ref='$areaRect'></div>
            <div class='area-pointer' ref='$mousePointer'></div>
            <div class='area-pointer-view' ref='$mousePointerView'></div>            
            <input type='file' accept='image/*' multiple="true" ref='$file' class='embed-file-input'/>
            <input type='file' accept='video/*' multiple="true" ref='$video' class='embed-video-input'/>            
        </div>
        `;
  }
  initState() {
    return {
      dragStart: false,
      width: 0,
      height: 0,
      color: "black",
      fontSize: 30,
      showRectInfo: false,
      areaVerties: rectToVerties(0, 0, 0, 0),
      content: "Insert a text",
      pathManager: new PathStringManager(),
      rect: {},
      options: {},
      containerItem: void 0,
      patternInfo: {}
    };
  }
  get scale() {
    return this.$viewport.scale;
  }
  checkNotDragStart() {
    return Boolean(this.state.dragStart) === false;
  }
  [POINTERMOVE("$el") + IF("checkNotDragStart")](e) {
    const vertex = this.$viewport.getWorldPosition(e);
    const newVertex = this.$context.snapManager.checkPoint(vertex);
    if (equals$1(newVertex, vertex) === false) {
      this.state.target = newVertex;
      this.state.targetVertex = this.$viewport.applyVertex(this.state.target);
      this.state.targetPositionVertex = clone(this.state.target);
      this.state.targetGuides = this.$context.snapManager.findGuideOne([
        this.state.target
      ]);
    } else {
      this.state.target = floor([], vertex);
      this.state.targetVertex = floor([], this.$viewport.applyVertex(this.state.target));
      this.state.targetGuides = [];
      this.state.targetPositionVertex = null;
    }
    this.bindData("$mousePointer");
    this.bindData("$mousePointerView");
  }
  [POINTERSTART("$el") + MOVE() + END() + PREVENT + STOP](e) {
    this.initMousePoint = this.state.targetPositionVertex ? this.state.targetPositionVertex : this.$viewport.getWorldPosition(e);
    this.state.dragStart = true;
    this.state.color = "#C4C4C4";
    this.state.text = "";
    const minX = this.initMousePoint[0];
    const minY = this.initMousePoint[1];
    const verties = rectToVerties(minX, minY, 0, 0);
    this.state.areaVerties = this.$viewport.applyVerties(verties);
    this.bindData("$area");
    this.bindData("$areaRect");
  }
  createLayerTemplate(width2, height2) {
    const { type, text: text2, color: color2, inlineStyle } = this.state;
    switch (type) {
      case "artboard":
        return `<div class='draw-item' style='background-color: white; ${inlineStyle}'></div>`;
      case "rect":
        return `<div class='draw-item' style='background-color: ${color2}; ${inlineStyle}'></div>`;
      case "circle":
        return `<div class='draw-item' style='background-color: ${color2}; border-radius: 100%; ${inlineStyle}'></div>`;
      case "text":
      case "svg-text":
        return `
                <div 
                    class='draw-item' 
                    
                    style='font-size: 30px;outline: 1px solid blue;white-space:nowrap'
                >
                    <p contenteditable="true" style="margin:0px;display: inline-block;outline:none;" ></p>
                </div>`;
      case "svg-rect":
        return `
            <div class='draw-item'>
                <svg width="${width2}" height="${height2}" style="width:100%; height:100%;" overflow="visible">
                    <path d="${PathParser.makeRect(0, 0, width2, height2).d}" stroke-width="1" stroke="black" fill="transparent" />
                </svg>
            </div>
            `;
      case "svg-circle":
        return `
            <div class='draw-item'>
                <svg width="${width2}" height="${height2}" style="width:100%; height:100%;" overflow="visible">
                    <path d="${PathParser.makeCircle(0, 0, width2, height2).d}" stroke-width="1" stroke="black" fill="transparent" />
                </svg>
            </div>
            `;
      case "svg-path":
        const newD = this.state.d.clone().scale(width2 / this.state.bboxRect.width, height2 / this.state.bboxRect.height).d;
        const options2 = this.state.options;
        return `
            <div class='draw-item'>
                <svg width="${width2}" height="${height2}" style="width:100%; height:100%;" overflow="visible">
                    <path   d="${newD}" 
                            stroke-width="${options2["stroke-width"] || 1}" 
                            stroke="${options2["stroke"] || "black"}" 
                            fill="${options2["fill"] || "transparent"}" 
                    />
                </svg>
            </div>
            `;
      case "polygon":
        const options22 = this.state.options;
        return `
                <div class='draw-item'>
                    <svg width="${width2}" height="${height2}" style="width:100%; height:100%;" overflow="visible">
                        <path   d="${PathParser.makePolygon(width2, height2, options22.count).d}" 
                                stroke-width="${options22["stroke-width"] || 1}" 
                                stroke="${options22["stroke"] || "black"}" 
                                fill="${options22["fill"] || "transparent"}" 
                        />
                    </svg>
                </div>
                `;
      case "star":
        const options3 = this.state.options;
        return `
                    <div class='draw-item'>
                        <svg width="${width2}" height="${height2}" style="width:100%; height:100%;" overflow="visible">
                            <path   d="${PathParser.makeStar(width2, height2, options3.count, options3.radius, options3.tension).d}" 
                                    stroke-width="${options3["stroke-width"] || 1}" 
                                    stroke="${options3["stroke"] || "black"}" 
                                    fill="${options3["fill"] || "transparent"}" 
                            />
                        </svg>
                    </div>
                    `;
      case "svg-textpath":
        return `
            <div class='draw-item' style='outline: 1px solid blue;'>
                <svg width="${width2}" height="${height2}" style="width:100%; height:100%;font-size: ${height2}px;" overflow="visible">
                    <defs>
                        <path id='layer-add-path' d="${PathStringManager.makeLine(0, height2, width2, height2)}" />
                    </defs>
                    <text>
                        <textPath 
                          xlink:href="#layer-add-path"
                          textLength="100%"
                          lengthAdjust="spacingAndGlyphs"
                          startOffset="0em"
                        >${text2}</textPath>
                    </text>
                </svg>
            </div>
            `;
      default:
        return `<div class='draw-item' style='outline: 1px solid blue; ${inlineStyle}'></div>`;
    }
  }
  [BIND("$area")]() {
    const { areaVerties } = this.state;
    const { left: left2, top: top2, width: width2, height: height2 } = vertiesToRectangle(areaVerties);
    return {
      style: {
        left: left2,
        top: top2,
        width: width2,
        height: height2
      },
      innerHTML: this.createLayerTemplate(width2, height2)
    };
  }
  [BIND("$areaRect")]() {
    const { areaVerties, showRectInfo } = this.state;
    const newVerties = this.$viewport.applyVertiesInverse(areaVerties);
    const { width: width2, height: height2 } = vertiesToRectangle(newVerties);
    return {
      style: {
        display: showRectInfo ? "inline-block" : "none",
        left: areaVerties[2][0],
        top: areaVerties[2][1]
      },
      innerHTML: `x: ${Math.round(newVerties[0][0])}, y: ${Math.round(newVerties[0][1])}, ${Math.round(width2)} x ${Math.round(height2)}`
    };
  }
  [BIND("$mousePointerView")]() {
    const { showRectInfo } = this.state;
    const { target = create$3(), targetVertex = create$3() } = this.state;
    return {
      style: {
        display: !showRectInfo ? "inline-block" : "none",
        left: targetVertex[0] || -1e4,
        top: targetVertex[1] || -1e4
      },
      innerHTML: `x: ${Math.round(target[0])}, y: ${Math.round(target[1])}`
    };
  }
  makeMousePointer() {
    if (this.state.dragStart)
      return "";
    const { target } = this.state;
    if (!target)
      return "";
    const guides = (this.state.targetGuides || []).filter(Boolean);
    return `
        <svg width="100%" height="100%">
            ${guides.map((guide) => {
      this.state.pathManager.reset();
      guide = this.$viewport.applyVerties([guide[0], guide[1]]);
      return this.state.pathManager.M({ x: guide[0][0], y: guide[0][1] }).L({ x: guide[1][0], y: guide[1][1] }).X({ x: guide[0][0], y: guide[0][1] }).X({ x: guide[1][0], y: guide[1][1] }).toString("layer-add-snap-pointer");
    }).join("\n")}
        </svg>
    `;
  }
  [BIND("$mousePointer")]() {
    const html = this.makeMousePointer();
    return {
      innerHTML: html
    };
  }
  move() {
    const e = this.$config.get("bodyEvent");
    const targetMousePoint = this.$viewport.getWorldPosition();
    const newMousePoint = this.$context.snapManager.checkPoint(targetMousePoint);
    if (equals$1(newMousePoint, targetMousePoint) === false) {
      this.state.target = newMousePoint;
      this.state.targetVertex = this.$viewport.applyVertex(newMousePoint);
      this.state.targetGuides = this.$context.snapManager.findGuideOne([newMousePoint]).filter(Boolean);
    } else {
      this.state.target = void 0;
      this.state.targetGuides = [];
    }
    const isShiftKey = e.shiftKey;
    const minX = Math.min(newMousePoint[0], this.initMousePoint[0]);
    const minY = Math.min(newMousePoint[1], this.initMousePoint[1]);
    const maxX = Math.max(newMousePoint[0], this.initMousePoint[0]);
    const maxY = Math.max(newMousePoint[1], this.initMousePoint[1]);
    let dx = maxX - minX;
    let dy = maxY - minY;
    if (isShiftKey) {
      dy = dx;
    }
    const verties = rectToVerties(minX, minY, dx, dy);
    this.state.areaVerties = this.$viewport.applyVerties(verties);
    this.state.showRectInfo = true;
    this.bindData("$area");
    this.bindData("$areaRect");
    this.bindData("$mousePointer");
    this.bindData("$mousePointerView");
  }
  end() {
    const isAltKey = this.$config.get("bodyEvent").altKey;
    let { color: color2, content: content2, fontSize, areaVerties, patternInfo } = this.state;
    const rectVerties = this.$viewport.applyVertiesInverse(areaVerties);
    const parentArtBoard = this.$context.selection.getArtboardByPoint(rectVerties[0]);
    let { x, y, width: width2, height: height2 } = vertiesToRectangle(rectVerties);
    let hasArea = true;
    if (width2 === 0 && height2 === 0) {
      switch (this.state.type) {
        case "text":
          content2 = "";
          height2.set(this.state.fontSize);
          hasArea = false;
          break;
        default:
          width2 = 100;
          height2 = 100;
          break;
      }
    }
    var rect2 = __spreadValues(__spreadValues({
      x: Math.floor(x),
      y: Math.floor(y),
      width: Math.floor(width2),
      height: Math.floor(height2),
      backgroundColor: color2,
      content: content2,
      fontSize
    }, patternInfo.attrs), this.state.options);
    switch (this.state.type) {
      case "text":
      case "svg-text":
      case "svg-textpath":
        delete rect2.backgroundColor;
        break;
      case "svg-path":
        rect2["d"] = this.state.d.clone().scale(width2 / this.state.bboxRect.width, height2 / this.state.bboxRect.height).d;
        break;
      default:
        delete rect2["content"];
        break;
    }
    switch (this.state.type) {
      case "image":
        this.trigger("openImage", rect2, parentArtBoard);
        break;
      case "video":
        this.trigger("openVideo", rect2, parentArtBoard);
        break;
      case "audio":
        this.trigger("openAudio", rect2, parentArtBoard);
        break;
      case "text":
        if (hasArea) {
          rect2.fontSize = Length.px(this.state.fontSize).floor();
        } else {
          const scaledFontSize = this.state.fontSize / this.$viewport.scale;
          const $drawItem = this.refs.$area.$(".draw-item > p");
          $drawItem.parent().css("height", `${scaledFontSize}px`);
          $drawItem.parent().css("font-size", `${scaledFontSize}px`);
          $drawItem.select();
          $drawItem.focus();
          return;
        }
        this.$commands.emit("newComponent", this.state.type, rect2, true, parentArtBoard || this.$context.selection.currentProject);
        break;
      default:
        this.$commands.emit("newComponent", this.state.type, rect2, true, parentArtBoard || this.$context.selection.currentProject);
        this.$config.set("editing.mode.itemType", "select");
        break;
    }
    if (!isAltKey) {
      this.trigger("hideLayerAppendView");
    }
    this.state.dragStart = false;
    this.state.showRectInfo = false;
    this.state.target = void 0;
    this.bindData("$areaRect");
  }
  [SUBSCRIBE("showLayerAppendView")](type, options2 = {}) {
    this.state.type = type;
    this.state.options = options2;
    this.state.isShow = true;
    this.refs.$area.empty();
    this.$el.show();
    this.$el.focus();
    this.$context.snapManager.clear();
    const model = this.$model.createModel(__spreadValues({
      itemType: type
    }, options2), false);
    this.state.inlineStyle = CSS_TO_STRING(this.$editor.renderer("html").toCSS(model, {
      top: true,
      left: true,
      width: true,
      height: true,
      transform: true,
      transformOrigin: true
    }));
    if (options2.d) {
      this.state.d = new PathParser(options2.d);
      this.state.bboxRect = this.state.d.rect();
    }
    this.$context.commands.emit("push.mode.view", "LayerAppendView");
  }
  [SUBSCRIBE("hideLayerAppendView")]() {
    if (this.$el.isShow()) {
      this.state.isShow = false;
      this.$el.hide();
      this.$commands.emit("pop.mode.view", "LayerAppendView");
    }
  }
  [SUBSCRIBE("hideAddViewLayer")]() {
    this.state.isShow = false;
    this.$el.hide();
  }
  isShow() {
    return this.state.isShow;
  }
  [KEYDOWN("document") + IF("isShow") + ESCAPE + ENTER]() {
  }
  [KEYUP("document") + IF("isShow") + ESCAPE + ENTER](e) {
    switch (this.state.type) {
      case "text":
        const $t = Dom.create(e.target);
        let { fontSize, areaVerties } = this.state;
        const rectVerties = this.$viewport.applyVertiesInverse(areaVerties);
        const { x, y } = vertiesToRectangle(rectVerties);
        const { width: width2, height: height2 } = $t.rect();
        const text2 = $t.text();
        if (text2.length === 0) {
          break;
        }
        const [[newWidth, newHeight, newFontSize]] = this.$viewport.applyScaleVertiesInverse([[width2, height2, fontSize]]);
        const rect2 = {
          x,
          y,
          width: newWidth,
          height: newHeight,
          content: text2.trim(),
          "font-size": newFontSize
        };
        const parentArtBoard = this.$context.selection.getArtboardByPoint(rectVerties[0]);
        this.$commands.emit("newComponent", this.state.type, rect2, true, parentArtBoard || this.$context.selection.currentProject);
        break;
    }
    this.state.dragStart = false;
    this.state.showRectInfo = false;
    this.state.target = null;
    this.bindData("$areaRect");
    this.trigger("hideLayerAppendView");
  }
  [CHANGE("$file")]() {
    this.refs.$file.files.forEach((item) => {
      this.$commands.emit("updateImage", item, this.state.rect, this.state.containerItem);
    });
  }
  [CHANGE("$video")]() {
    this.refs.$video.files.forEach((item) => {
      this.$commands.emit("updateVideo", item, this.state.rect, this.state.containerItem);
    });
  }
  [SUBSCRIBE("openImage")](rect2, containerItem) {
    this.state.rect = rect2;
    this.state.containerItem = containerItem;
    this.refs.$file.click();
  }
  [SUBSCRIBE("openVideo")](rect2, containerItem) {
    this.state.rect = rect2;
    this.state.containerItem = containerItem;
    this.refs.$video.click();
  }
  [SUBSCRIBE("setPatternInfo")](patternInfo) {
    this.state.patternInfo = patternInfo;
  }
  [SUBSCRIBE(UPDATE_VIEWPORT)]() {
    this.$context.snapManager.clear();
    this.bindData("$mousePointer");
    this.bindData("$mousePointerView");
  }
}
function layerAppendView(editor) {
  editor.registerUI("canvas.view", {
    LayerAppendView
  });
}
var LayerTreeProperty$1 = "";
const DRAG_START_CLASS = "drag-start";
class LayerTreeProperty extends BaseProperty {
  getTitle() {
    return this.$i18n("layer.tree.property.title");
  }
  getClassName() {
    return "full";
  }
  initState() {
    return {
      hideDragPointer: true,
      lastDragOverPosition: 0,
      lastDragOverOffset: 0,
      rootRect: { top: 0 },
      itemRect: { height: 0 }
    };
  }
  getBody() {
    return `
      <div class="elf--layer-list scrollbar" ref="$layerList"></div>
      <div class='drag-point' ref='$dragPointer'></div>
    `;
  }
  [BIND("$dragPointer")]() {
    var offset = this.state.lastDragOverOffset;
    var dist2 = this.state.itemRect.height / 3;
    var bound = {};
    if (this.state.lastDragOverOffset < dist2) {
      offset = 0;
      var top2 = this.state.lastDragOverPosition + offset - this.state.rootRect.top;
      bound = {
        top: top2,
        height: "1px",
        width: "100%",
        left: "0px"
      };
      this.state.lastDragOverItemDirection = "before";
    } else if (this.state.lastDragOverOffset > this.state.itemRect.height - dist2) {
      offset = this.state.itemRect.height;
      var top2 = this.state.lastDragOverPosition + offset - this.state.rootRect.top;
      bound = {
        top: top2,
        height: "1px",
        width: "100%",
        left: "0px"
      };
      this.state.lastDragOverItemDirection = "after";
    } else {
      const targetItem = this.$model.get(this.state.lastDragOverItemId);
      if (targetItem == null ? void 0 : targetItem.enableHasChildren()) {
        offset = 0;
        var top2 = this.state.lastDragOverPosition + offset - this.state.rootRect.top;
        bound = {
          top: top2,
          height: this.state.itemRect.height,
          width: "100%",
          left: "0px"
        };
        this.state.lastDragOverItemDirection = "self";
      }
    }
    bound.display = this.state.hideDragPointer ? "none" : "block";
    return {
      style: bound
    };
  }
  getIcon(item) {
    if (item.d) {
      return iconUseForPath(item.d, {
        width: item.screenWidth,
        height: item.screenHeight,
        fill: "currentColor",
        stroke: "currentColor"
      });
    }
    if (item.hasLayout() || item.hasChildren() || item.is("artboard")) {
      if (item.isLayout("flex")) {
        return iconUse("layout_flex");
      } else if (item.isLayout("grid")) {
        return iconUse("layout_grid");
      }
      return iconUse("layout_default");
    }
    return this.$icon.get(item.itemType, item);
  }
  makeLayerList(parentObject, depth2 = 0) {
    if (!parentObject.layers)
      return "";
    const layers2 = parentObject.layers;
    const data = [];
    for (var last = layers2.length - 1; last > -1; last--) {
      var layer = layers2[last];
      var selectedPathClass = this.$context.selection.hasPathOf(layer) ? "selected-path" : "";
      var selectedClass = this.$context.selection.check(layer) ? "selected" : "";
      var hovered = this.$context.selection.checkHover(layer) ? "hovered" : "";
      var name = layer.is("boolean-path") ? layer["boolean-operation"] : layer.name;
      if (layer.is("text")) {
        name = layer.text || layer.name;
      }
      var title2 = "";
      if (layer.hasLayout()) {
        title2 = this.$i18n("layer.tree.property.layout.title." + layer.layout);
      }
      const isHide = layer.isTreeItemHide();
      const depthPadding = depth2 * 20;
      const hasChildren = layer.hasChildren();
      const lock2 = this.$lockManager.get(layer.id);
      const visible2 = this.$visibleManager.get(layer.id);
      data[data.length] = `<div class='layer-item ${selectedClass} ${selectedPathClass} ${hovered}' data-is-group="${hasChildren}" data-depth="${depth2}" data-layout='${layer.layout}' data-layer-id='${layer.id}' data-is-hide="${isHide}"  draggable="true"><div class='detail'><label data-layout-title='${title2}' style='padding-left: ${Length.px(depthPadding)}' ><div class='folder ${layer.collapsed ? "collapsed" : ""}'>${hasChildren ? iconUse("arrow_right") : ""}</div><span class='icon' data-item-type="${layer.itemType}">${this.getIcon(layer)}</span><span class='name'>${name}</span></label><div class="tools"><button type="button" class="lock" data-lock="${lock2}" title='Lock'>${lock2 ? iconUse("lock") : iconUse("lock_open")}</button><button type="button" class="visible" data-visible="${visible2}" title='Visible'>${iconUse("visible")}</button><button type="button" class="remove" title='Remove'>${iconUse("remove2")}</button></div></div></div>${this.makeLayerList(layer, depth2 + 1)}`;
    }
    return data.join("");
  }
  [SUBSCRIBE("refreshContent")]() {
    this.refresh();
  }
  [LOAD("$layerList") + DOMDIFF]() {
    var project2 = this.$context.selection.currentProject;
    if (!project2)
      return "";
    return [
      this.makeLayerList(project2, 0),
      `
        <div class='layer-item ' data-depth="0" data-is-last="true">
        </div>
      `
    ];
  }
  [DRAGSTART("$layerList .layer-item")](e) {
    var layerId = e.$dt.attr("data-layer-id");
    e.$dt.addClass(DRAG_START_CLASS);
    e.dataTransfer.setData("layer/id", layerId);
    this.state.rootRect = this.refs.$layerList.rect();
    this.state.itemRect = e.$dt.rect();
    this.setState({
      hideDragPointer: false
    }, false);
    this.bindData("$dragPointer");
  }
  [DRAGEND("$layerList .layer-item")]() {
    this.setState({
      hideDragPointer: true
    }, false);
    this.bindData("$dragPointer");
    this.refs.$layerList.$$(`.${DRAG_START_CLASS}`).forEach((it) => {
      it.removeClass(DRAG_START_CLASS);
    });
  }
  [DRAGOVER(`$layerList .layer-item:not(.${DRAG_START_CLASS})`) + PREVENT](e) {
    var targetLayerId = e.$dt.attr("data-layer-id");
    this.state.lastDragOverItemId = targetLayerId;
    this.state.lastDragOverPosition = e.$dt.rect().top;
    this.state.lastDragOverOffset = e.offsetY;
    this.bindData("$dragPointer");
  }
  [DROP(`$layerList .layer-item:not(.${DRAG_START_CLASS})`)](e) {
    var targetLayerId = e.$dt.attr("data-layer-id");
    var sourceLayerId = e.dataTransfer.getData("layer/id");
    if (targetLayerId === sourceLayerId)
      return;
    var targetItem = this.$model.get(targetLayerId);
    var sourceItem = this.$model.get(sourceLayerId);
    if ((targetItem == null ? void 0 : targetItem.enableHasChildren()) === false)
      return;
    if (targetItem && targetItem.hasParent(sourceItem.id))
      return;
    switch (this.state.lastDragOverItemDirection) {
      case "self":
        this.$commands.emit("history.moveLayerToTarget", "change target with move", sourceItem, targetItem, void 0, TargetActionType.APPEND_CHILD);
        break;
      case "before":
        this.$commands.emit("history.moveLayerToTarget", "change target with move", sourceItem, targetItem, void 0, TargetActionType.INSERT_BEFORE);
        break;
      case "after":
        this.$commands.emit("history.moveLayerToTarget", "change target with move", sourceItem, targetItem, void 0, TargetActionType.INSERT_AFTER);
        break;
    }
    this.nextTick(() => {
      this.$commands.emit("recoverBooleanPath");
      this.$context.selection.select(sourceItem);
      this.setState({
        hideDragPointer: true
      });
    }, 10);
  }
  [DOUBLECLICK("$layerList .layer-item")](e) {
    this.startInputEditing(e.$dt.$(".name"));
  }
  modifyDoneInputEditing(input2, event) {
    if (KEY_CODE.enter === event.keyCode) {
      this.endInputEditing(input2, () => {
        var id2 = input2.closest("layer-item").attr("data-layer-id");
        var text3 = input2.text();
        this.$commands.executeCommand("setAttribute", "change name", {
          [id2]: {
            name: text3
          }
        });
      });
    } else {
      var id = input2.closest("layer-item").attr("data-layer-id");
      var text2 = input2.text();
      this.$commands.executeCommand("setAttribute", "change name", {
        [id]: {
          name: text2
        }
      });
    }
  }
  [KEYDOWN("$layerList .layer-item .name") + STOP](e) {
    this.modifyDoneInputEditing(e.$dt, e);
  }
  [FOCUSOUT("$layerList .layer-item .name") + PREVENT + STOP](e) {
    this.modifyDoneInputEditing(e.$dt, { keyCode: KEY_CODE.enter });
  }
  selectLayer(layer) {
    if (layer) {
      this.$context.selection.select(layer);
    }
    this.refresh();
  }
  addLayer(layer) {
    if (layer) {
      this.$context.selection.select(layer);
      this.$commands.emit("refreshArtboard");
    }
  }
  [CLICK("$add")]() {
    this.$commands.emit("newComponent", "rect", {
      backgroundColor: "#ececec",
      width: 200,
      height: 100
    });
  }
  [CLICK("$layerList .layer-item label .name")](e) {
    var $item = e.$dt.closest("layer-item");
    $item.onlyOneClass("selected");
    var id = $item.attr("data-layer-id");
    this.$context.selection.select(id);
    this.$commands.emit("history.refreshSelection");
  }
  [CLICK("$layerList .layer-item label .folder")](e) {
    var $item = e.$dt.closest("layer-item");
    var id = $item.attr("data-layer-id");
    var item = this.$model.get(id);
    item.reset({
      collapsed: !item.collapsed
    });
    this.refresh();
  }
  [CLICK("$layerList .layer-item .visible")](e) {
    var $item = e.$dt.closest("layer-item");
    var id = $item.attr("data-layer-id");
    this.$visibleManager.toggle(id);
    var visible2 = this.$visibleManager.get(id);
    e.$dt.attr("data-visible", visible2);
    this.emit("refreshVisibleView");
  }
  [CLICK("$layerList .layer-item .remove")](e) {
    var $item = e.$dt.closest("layer-item");
    var id = $item.attr("data-layer-id");
    this.$commands.executeCommand("removeLayer", "remove a layer", [id]);
    this.nextTick(() => {
      this.refresh();
    }, 1e3);
  }
  [CLICK("$layerList .layer-item .lock")](e) {
    var $item = e.$dt.closest("layer-item");
    var id = $item.attr("data-layer-id");
    this.$lockManager.toggle(id);
    var lastLock = this.$lockManager.get(id);
    e.$dt.attr("data-lock", lastLock);
    if (lastLock) {
      this.$context.selection.removeById(id);
    }
  }
  [SUBSCRIBE("changeHoverItem")]() {
    this.refs.$layerList.$$(".hovered").forEach((it) => {
      it.removeClass("hovered");
    });
    if (this.$context.selection.hoverItems.length) {
      var selector2 = this.$context.selection.hoverItems.map((it) => {
        return `[data-layer-id="${it.id}"]`;
      }).join(",");
      this.refs.$layerList.$$(selector2).forEach((it) => {
        it.addClass("hovered");
      });
    }
  }
  [SUBSCRIBE_SELF("changeSelection")](isSelection = false) {
    if (isSelection && this.refs.$layerList) {
      this.refs.$layerList.$$(".selected").forEach((it) => {
        it.removeClass("selected");
      });
      this.refs.$layerList.$$(".selected-path").forEach((it) => {
        it.removeClass("selected-path");
      });
      var selector2 = this.$context.selection.items.map((it) => {
        return `[data-layer-id="${it.id}"]`;
      }).join(",");
      if (selector2) {
        this.refs.$layerList.$$(selector2).forEach((it) => {
          it.addClass("selected");
          var item = this.$context.selection.itemKeys[it.attr("data-layer-id")];
          if (item.is("svg-path", "svg-polygon")) {
            it.$(".icon").html(this.getIcon(item));
          }
        });
      }
    }
  }
  [SUBSCRIBE(REFRESH_SELECTION, "refreshAllCanvas")]() {
    this.refresh();
  }
  [SUBSCRIBE("refreshLayerTreeView") + THROTTLE(100)]() {
    this.refresh();
  }
  [SUBSCRIBE("changeItemLayout")]() {
    this.refresh();
  }
  [CONFIG("bodyEvent")]() {
    const $target = Dom.create(this.$config.get("bodyEvent").target);
    const $layerItem = $target.closest("layer-item");
    if ($layerItem) {
      this.emit("refreshHoverView", $layerItem.data("layer-id"));
    }
  }
}
function layerTree(editor) {
  editor.registerElement({
    LayerTreeProperty
  });
}
var conic = {
  title: "Conic",
  key: "conic",
  execute: function(count = 42) {
    return repeat(count).map(() => {
      var x = randomNumber(45, 55);
      var y = randomNumber(45, 55);
      var angle = randomNumber(0, 360);
      return {
        gradient: `conic-gradient(from ${angle}deg at ${x}% ${y}%, ${ColorStep.createColorStep(2, 360, "deg")})`
      };
    });
  }
};
const angle_list$2 = ["0deg", "45deg", "90deg"];
var linear = {
  title: "Linear",
  key: "linear",
  execute: function(count = 42) {
    return repeat(count).map(() => {
      return {
        gradient: `linear-gradient(${randomItem(...angle_list$2)}, ${ColorStep.createColorStep(2)})`
      };
    });
  }
};
var radial = {
  title: "Radial",
  key: "radial",
  execute: function(count = 42) {
    return repeat(count).map(() => {
      var shape2 = "circle";
      return {
        gradient: `radial-gradient(${shape2}, ${ColorStep.createColorStep(2)})`
      };
    });
  }
};
var randomConic = {
  title: "Random Conic",
  key: "random-conic",
  execute: function(count = 42) {
    return repeat(count).map(() => {
      return {
        gradient: `conic-gradient(from 0deg at 50% 50%, ${ColorStep.createColorStep(10, 360, "deg")})`
      };
    });
  }
};
const angle_list$1 = ["0deg", "45deg", "90deg"];
var randomLinear = {
  title: "Random Linear",
  key: "random-linear",
  execute: function(count = 42) {
    return repeat(count).map(() => {
      return {
        gradient: `linear-gradient(${randomItem(...angle_list$1)}, ${ColorStep.createColorStep(10)})`
      };
    });
  }
};
var randomRadial = {
  title: "Random Radial",
  key: "random-radial",
  execute: function(count = 42) {
    return repeat(count).map(() => {
      return {
        gradient: `radial-gradient(circle, ${ColorStep.createColorStep(10)})`
      };
    });
  }
};
var repeatConic = {
  title: "Repeat Conic",
  key: "repeat-conic",
  execute: function(count = 42) {
    return repeat(count).map(() => {
      return {
        gradient: `repeating-conic-gradient(from 0deg at 0% 50%, ${ColorStep.createRepeatColorStep(10, "10deg")})`
      };
    });
  }
};
const angle_list = ["0deg", "45deg", "90deg"];
var repeatLinear = {
  title: "Repeat Linear",
  key: "repeat-linear",
  execute: function(count = 42) {
    return repeat(count).map(() => {
      return {
        gradient: `repeating-linear-gradient(${randomItem(...angle_list)}, ${ColorStep.createRepeatColorStep(2, "10px")})`
      };
    });
  }
};
var repeatRadial = {
  title: "Repeat Radial",
  key: "repeat-radial",
  execute: function(count = 42) {
    return repeat(count).map(() => {
      var shape2 = "circle";
      return {
        gradient: `repeating-radial-gradient(${shape2}, ${ColorStep.createRepeatColorStep(3, "6px")})`
      };
    });
  }
};
var gradients = [
  linear,
  randomLinear,
  repeatLinear,
  radial,
  randomRadial,
  repeatRadial,
  conic,
  randomConic,
  repeatConic
];
var GradientAssetsProperty$1 = "";
const options = gradients.map((it) => {
  return { value: it.key, text: it.title };
});
class GradientAssetsProperty extends BaseProperty {
  getTitle() {
    return this.$i18n("gradient.asset.property.title");
  }
  initState() {
    return {
      mode: "grid",
      preset: "linear"
    };
  }
  getTools() {
    return `<div ref="$tools"></div>`;
  }
  [LOAD("$tools")]() {
    return createComponent("SelectEditor", {
      ref: "$preset",
      key: "preset",
      value: this.state.preset,
      options,
      onchange: "changePreset"
    });
  }
  [SUBSCRIBE_SELF("changePreset")](key, value) {
    this.setState({
      [key]: value
    });
  }
  getClassName() {
    return "elf--gradient-assets-property";
  }
  [SUBSCRIBE(REFRESH_SELECTION) + DEBOUNCE(100)]() {
    this.show();
  }
  getBody() {
    return `
      <div class='property-item gradient-assets'>
        <div class='gradient-list' ref='$gradientList' data-view-mode='${this.state.mode}'></div>
      </div>
    `;
  }
  [DRAGSTART("$gradientList .gradient-item")](e) {
    const gradient2 = e.$dt.attr("data-gradient");
    e.dataTransfer.effectAllowed = "copy";
    e.dataTransfer.setData("text/gradient", gradient2);
  }
  [LOAD("$gradientList")]() {
    var preset = gradients.find((it) => it.key === this.state.preset);
    if (!preset) {
      return "";
    }
    var results = preset.execute().map((item, index2) => {
      return `<div class='gradient-item' data-index="${index2}" data-gradient='${item.gradient}' data-custom="${item.custom}">
          <div class='preview' title="${item.gradient}" draggable="true">
            <div class='gradient-view' style='background-image: ${item.gradient};'></div>
          </div>
        </div>`;
    });
    if (preset.edit) {
      results.push(`<div class='add-gradient-item'><butto type="button">${iconUse("add")}</button></div>`);
    }
    return results;
  }
  executeGradient(callback, isRefresh = true, isEmit = true) {
    var project2 = this.$context.selection.currentProject;
    if (project2) {
      callback && callback(project2);
      if (isRefresh)
        this.refresh();
      if (isEmit)
        this.emit("refreshGradientAssets");
    } else {
      window.alert("Please select a project.");
    }
  }
  [CLICK("$gradientList .add-gradient-item")]() {
    this.executeGradient((project2) => {
      project2.createGradient({
        gradient: Gradient.random(),
        name: "",
        variable: ""
      });
    });
  }
  [CLICK("$gradientList .preview")](e) {
    var $item = e.$dt.closest("gradient-item");
    var gradient2 = $item.attr("data-gradient");
    this.$commands.emit("drop.asset", { gradient: gradient2 });
  }
}
var ImageAssetsProperty$1 = "";
function revokeObjectUrl(url) {
  window.URL.revokeObjectURL(url);
}
class ImageAssetsProperty extends BaseProperty {
  getTitle() {
    return this.$i18n("image.asset.property.title");
  }
  initState() {
    return {
      mode: "grid"
    };
  }
  getClassNamef() {
    return "elf--image-assets-property";
  }
  afterRender() {
    this.show();
  }
  getBody() {
    return `
      <div class='property-item image-assets'>
        <div class='image-list' ref='$imageList' data-view-mode='${this.state.mode}'></div>
      </div>
    `;
  }
  [LOAD("$imageList") + DOMDIFF]() {
    var current = this.$context.selection.currentProject || { images: [] };
    var images = current.images;
    var results = images.map((image2, index2) => {
      return `
        <div class='image-item' data-index="${index2}">
          <div class='preview' draggable="true">
            <img src="${image2.local}" />
          </div>
          <div class='tools'>
            <button type="button" class='copy'>${obj$2.copy}</button>          
            <button type="button" class='remove'>${obj$2.remove}</button>
          </div>
        </div>
      `;
    });
    return `
      <div class='loaded-list'>
        ${results.join("")}
        <div class='add-image-item'>
          <input type='file' accept='image/*' ref='$file' />
          <button type="button">${obj$2.add}</button>
        </div>        
      </div>

    `;
  }
  executeImage(callback, isRefresh = true, isEmit = true) {
    var project2 = this.$context.selection.currentProject;
    if (project2) {
      callback && callback(project2);
      if (isRefresh)
        this.refresh();
      if (isEmit)
        this.emit("refreshImageAssets");
    } else {
      window.alert("Please select a project.");
    }
  }
  [DRAGSTART("$imageList .preview img")](e) {
    var index2 = +e.$dt.closest("image-item").attr("data-index");
    var project2 = this.$context.selection.currentProject;
    if (project2) {
      var imageInfo = project2.images[index2];
      e.dataTransfer.setData("image/info", imageInfo.local);
    }
  }
  [CHANGE("$imageList .add-image-item input[type=file]")](e) {
    this.executeImage(() => {
      [...e.target.files].forEach((item) => {
        this.$commands.emit("updateImageAssetItem", item);
      });
    });
  }
  [CLICK("$imageList .remove")](e) {
    var $item = e.$dt.closest("image-item");
    var index2 = +$item.attr("data-index");
    this.executeImage((project2) => {
      project2.removeImage(index2);
      revokeObjectUrl($item.$(".preview img").attr("src"));
    });
  }
  [CLICK("$imageList .copy")](e) {
    var $item = e.$dt.closest("image-item");
    var index2 = +$item.attr("data-index");
    this.executeImage((project2) => {
      project2.copyImage(index2);
    });
  }
  [SUBSCRIBE("addImageAsset")]() {
    this.refresh();
  }
}
var check = {
  key: "check",
  title: "Check",
  execute: function() {
    return [
      { pattern: `check(20px 20px, 10px 10px, black, transparent)` },
      { pattern: `check(40px 40px, 20px 20px, black, transparent)` },
      { pattern: `check(60px 60px, 30px 30px, #DDB104, rgba(254,240,188,0))` },
      { pattern: `check(80px 80px, 40px 40px, #DDB104, rgba(254,240,188,0))` },
      { pattern: `check(100px 100px, 50px 50px, #DCF3DC, transparent)` },
      { pattern: `check(200px 200px, 100px 100px, #102C45, transparent)` }
    ];
  }
};
var crossdot = {
  key: "cross-dot",
  title: "Cross Dot",
  execute: function() {
    return [
      {
        pattern: `cross-dot(20px 20px, 10px 10px, #B7C4CD, white, normal, 1px)`
      },
      {
        pattern: `cross-dot(40px 40px, 20px 20px, #DDB104, #FEF0BC, normal, 4px)`
      },
      {
        pattern: `cross-dot(60px 60px, 30px 30px, #35DB92, #DCF9EC, normal, 6px)`
      }
    ];
  }
};
var diagonalLine = {
  key: "diagonal-line",
  title: "Diagonal Line",
  execute: function() {
    return [
      {
        pattern: `diagonal-line(10px 10px, 45deg, #B7C4CD, white, normal, 1px)`
      },
      {
        pattern: `diagonal-line(25px 25px, 90deg, #DDB104, #FEF0BC, normal, 2px)`
      },
      {
        pattern: `diagonal-line(50px 50px, 135deg, #35DB92, #DCF9EC, normal, 3px)`
      }
    ];
  }
};
var dot = {
  key: "dot",
  title: "Dot",
  execute: function() {
    return [
      { pattern: `dot(20px 20px, 10px 10px, #B7C4CD, white, normal, 1px)` },
      { pattern: `dot(40px 40px, 20px 20px, #E7393F, #FEF0BC, normal, 2px)` },
      { pattern: `dot(60px 60px, 30px 30px, #E7393F, black, normal, 3px)` },
      { pattern: `dot(80px 80px, 40px 40px, #B7C4CD, white, normal, 4px)` }
    ];
  }
};
var grid = {
  key: "grid",
  title: "Grid",
  execute: function() {
    return [
      { pattern: `grid(20px 20px, 10px 10px, black, transparent)` },
      { pattern: `grid(40px 40px, 20px 20px, black, transparent)` },
      { pattern: `grid(60px 60px, 30px 30px, #DDB104, rgba(254,240,188,0))` },
      { pattern: `grid(80px 80px, 40px 40px, #DDB104, rgba(254,240,188,0))` },
      { pattern: `grid(100px 100px, 50px 50px, #DCF3DC, transparent)` },
      { pattern: `grid(200px 200px, 100px 100px, #102C45, transparent)` }
    ];
  }
};
var horizontalLine = {
  key: "horizontal-line",
  title: "Horizontal Line",
  execute: function() {
    return [
      { pattern: `horizontal-line(10px 10px, 0, #B7C4CD, white, normal, 1px)` },
      {
        pattern: `horizontal-line(25px 25px, 0, #DDB104, #FEF0BC, normal, 2px)`
      },
      {
        pattern: `horizontal-line(50px 50px, 0, #35DB92, #DCF9EC, normal, 3px)`
      }
    ];
  }
};
var verticalLine = {
  key: "vertical-line",
  title: "Vertical Line",
  execute: function() {
    return [
      { pattern: `vertical-line(10px 10px, 0px, #B7C4CD, white, normal, 1px)` },
      {
        pattern: `vertical-line(25px 25px, 0px, #DDB104, #FEF0BC, normal, 2px)`
      },
      {
        pattern: `vertical-line(50px 50px, 0px, black, rgba(231,57,63,0.9), normal, 1px)`
      }
    ];
  }
};
var patterns = [
  check,
  grid,
  dot,
  crossdot,
  diagonalLine,
  verticalLine,
  horizontalLine
];
var PatternAssetsProperty$1 = "";
class PatternAssetsProperty extends BaseProperty {
  getTitle() {
    return this.$i18n("pattern.asset.property.title");
  }
  initState() {
    return {
      mode: "grid",
      preset: "check"
    };
  }
  getTools() {
    const options2 = variable$4(patterns.map((it) => {
      return { value: it.key, text: it.title };
    }));
    return createComponent("SelectEditor", {
      ref: "$assets",
      key: "preset",
      value: this.state.preset,
      options: options2,
      onchange: "changePreset"
    });
  }
  [SUBSCRIBE_SELF("changePreset")](key, value) {
    this.setState({
      [key]: value
    });
  }
  getClassName() {
    return "elf--pattern-assets-property";
  }
  get editableProperty() {
    return "pattern";
  }
  [SUBSCRIBE(REFRESH_SELECTION) + DEBOUNCE(100) + IF("checkShow")]() {
  }
  getBody() {
    return `
      <div class='property-item pattern-assets'>
        <div class='pattern-list' ref='$patternList' data-view-mode='${this.state.mode}'></div>
      </div>
    `;
  }
  [DRAGSTART("$patternList .pattern-item")](e) {
    const pattern = e.$dt.attr("data-pattern");
    e.dataTransfer.effectAllowed = "copy";
    e.dataTransfer.setData("text/pattern", pattern);
  }
  [LOAD("$patternList")]() {
    var preset = patterns.find((it) => it.key === this.state.preset);
    if (!preset) {
      return "";
    }
    var results = preset.execute().map((item, index2) => {
      const cssText = CSS_TO_STRING(Pattern.toCSS(item.pattern));
      return `<div class='pattern-item' data-index="${index2}" data-pattern="${item.pattern}">
          <div class='preview' title="${item.title}" draggable="true">
            <div class='pattern-view' style='${cssText}'></div>
          </div>
        </div>`;
    });
    return results;
  }
  [CLICK("$patternList .pattern-item")](e) {
    const pattern = e.$dt.attr("data-pattern");
    if (this.$modeView.isCurrentMode(ViewModeType.CanvasView)) {
      this.$commands.emit("addBackgroundImagePattern", pattern);
    } else {
      this.emit("setPatternAsset", pattern);
    }
  }
}
var VideoAssetsProperty$1 = "";
class VideoAssetsProperty extends BaseProperty {
  getTitle() {
    return this.$i18n("video.asset.property.title");
  }
  initState() {
    return {
      mode: "grid"
    };
  }
  getClassName() {
    return "elf--video-assets-property";
  }
  afterRender() {
    this.show();
  }
  getBody() {
    return `
      <div class='property-item video-assets'>
        <div class='video-list' ref='$videoList' data-view-mode='${this.state.mode}'></div>
      </div>
    `;
  }
  [LOAD("$videoList") + DOMDIFF]() {
    var current = this.$context.selection.currentProject || { videos: [] };
    var videos = current.videos;
    var results = videos.map((video2, index2) => {
      return `
        <div class='video-item' data-index="${index2}">
          <div class='preview' draggable="true">
            <img src="${video2.local}" />
          </div>
          <div class='tools'>
            <button type="button" class='copy'>${obj$2.copy}</button>          
            <button type="button" class='remove'>${obj$2.remove}</button>
          </div>
        </div>
      `;
    });
    return `
      <div class='loaded-list'>
        ${results.join("")}
        <div class='add-video-item'>
          <input type='file' accept='video/*' ref='$file' />
          <button type="button">${obj$2.add}</button>
        </div>        
      </div>

    `;
  }
  executeVideo(callback, isRefresh = true, isEmit = true) {
    var project2 = this.$context.selection.currentProject;
    if (project2) {
      callback && callback(project2);
      if (isRefresh)
        this.refresh();
      if (isEmit)
        this.emit("refreshVideoAssets");
    } else {
      window.alert("Please select a project.");
    }
  }
  [DRAGSTART("$videoList .preview img")](e) {
    var index2 = +e.$dt.closest("video-item").attr("data-index");
    var project2 = this.$context.selection.currentProject;
    if (project2) {
      var videoInfo = project2.videos[index2];
      e.dataTransfer.setData("video/info", videoInfo.local);
    }
  }
  [CHANGE("$videoList .add-video-item input[type=file]")](e) {
    this.executeVideo(() => {
      [...e.target.files].forEach((item) => {
        this.emit("updateVideoAssetItem", item);
      });
    });
  }
  [CLICK("$videoList .remove")](e) {
    var $item = e.$dt.closest("video-item");
    var index2 = +$item.attr("data-index");
    this.executeVideo((project2) => {
      project2.removeVideo(index2);
      revokeObjectUrl($item.$(".preview img").attr("src"));
    });
  }
  [CLICK("$videoList .copy")](e) {
    var $item = e.$dt.closest("video-item");
    var index2 = +$item.attr("data-index");
    this.executeVideo((project2) => {
      project2.copyVideo(index2);
    });
  }
  [SUBSCRIBE("addVideoAsset")]() {
    this.refresh();
  }
}
registElement({ VideoAssetsProperty });
class AssetItems extends EditorElement {
  template() {
    return `
      <div class='asset-items'>
        ${this.$injectManager.generate("asset")}
      </div>
    `;
  }
}
var CustomAssets$1 = "";
class CustomAssets extends EditorElement {
  template() {
    return `
      <div class='elf--custom-assets'>
        <div class='custom-assets-tools'>
          <div class='title'><label>Custom Assets</label></div>
          <div class='tools'>
            <button type="button" ref='$addCustomAsset'>${iconUse("add")}</button>
          </div>
        </div>
        <div class='elf--asset-list' ref='$list'></div>
      </div>
    `;
  }
  async [LOAD("$list")]() {
    const data = await this.$storageManager.getCustomAssetList();
    return data.map((it) => {
      return `
        <div class='asset-preview' draggable="true" data-preview-id="${it.id}">
          <div class='thumbnail'><img src='${it.preview}' /></div>
          <div class='tools'>
            <div class='title'>${it.component.name}</div>
            <div class='buttons'>
              <button type="button" class='remove-asset-preview' title="remove asset" data-preview-id="${it.id}">${iconUse("remove")}</button>
            </div>
          </div>
        </div>
      `;
    });
  }
  async [CLICK("$list .remove-asset-preview")](e) {
    if (window.confirm(this.$i18n("app.confirm.message.artboard.items.removeCustomAsset"))) {
      const id = e.$dt.data("preview-id");
      await this.$storageManager.removeCustomAsset(id);
      this.refresh();
    }
  }
  [DRAGSTART("$list .asset-preview")](e) {
    const id = e.$dt.data("preview-id");
    e.dataTransfer.effectAllowed = "copy";
    e.dataTransfer.setData("text/asset", id);
  }
  [CLICK("$addCustomAsset")]() {
    this.$commands.emit("savePNG", async (datauri) => {
      await this.$storageManager.saveCustomAsset(datauri);
      this.refresh();
    });
  }
}
var LibraryItems$1 = "";
class LibraryItems extends EditorElement {
  template() {
    return `
      <div class='elf--library-items'>
        <div>
          ${createComponent("TextEditor", {
      label: "Search",
      key: "search",
      onchange: this.subscribe((key, value) => {
        this.broadcast("search", value);
      }, 300)
    })}
        </div>
        ${this.$injectManager.generate("library")}
      </div>
    `;
  }
}
var ObjectItems$1 = "";
class ObjectItems extends EditorElement {
  template() {
    return `
        <div class="object-items">
          <div>
            ${createComponent("ProjectProperty")}
          </div>
          <div>
            ${createComponent("LayerTreeProperty")}
          </div>
        </div>
    `;
  }
}
function layertab(editor) {
  editor.context.config.set("layertab.selectedValue", "layer");
  editor.registerUI("layertab.tab", {
    Layer: {
      title: editor.$i18n("app.tab.title.layers"),
      icon: iconUse("layers"),
      value: "layer"
    },
    Library: {
      title: editor.$i18n("app.tab.title.libraries"),
      icon: iconUse("auto_awesome"),
      value: "library"
    },
    Asset: {
      title: editor.$i18n("app.tab.title.assets"),
      icon: iconUse("apps"),
      value: "asset"
    },
    Component: {
      title: editor.$i18n("app.tab.title.components"),
      icon: iconUse("plugin"),
      value: "component"
    }
  });
  editor.registerUI("layertab.tab.layer", {
    ObjectItems
  });
  editor.registerUI("layertab.tab.library", {
    LibraryItems
  });
  editor.registerUI("layertab.tab.asset", {
    AssetItems
  });
  editor.registerUI("layertab.tab.component", {
    CustomAssets
  });
  editor.registerUI("asset", {
    GradientAssetsProperty,
    PatternAssetsProperty,
    ImageAssetsProperty,
    VideoAssetsProperty
  });
}
var DefaultLayoutItemProperty$1 = "";
class DefaultLayoutItemProperty extends BaseProperty {
  getTitle() {
    return this.$i18n("default.layout.item.property.title.constraints");
  }
  getClassName() {
    return "elf--default-layout-item-property";
  }
  getBody() {
    return `
        <div class='property-item' ref='$body'>
          <div class="constraints">
            <div ref="$constraintsInfo"></div>
            <div ref="$constraintsInfoInput"></div>
          </div>
        </div>
      `;
  }
  [LOAD("$constraintsInfo") + DOMDIFF]() {
    var current = this.$context.selection.current;
    const h = (current == null ? void 0 : current["constraints-horizontal"]) || Constraints.MIN;
    const v = (current == null ? void 0 : current["constraints-vertical"]) || Constraints.MIN;
    return `
      <div class="constraints-box">

        <!-- Horizontal -->
        <div class='item' data-value='min' data-selected="${h === Constraints.MIN || h === Constraints.STRETCH}" data-key='${ConstraintsDirection.HORIZONTAL}'></div>
        <div class='item' data-value='max' data-selected="${h === Constraints.MAX || h === Constraints.STRETCH}" data-key='${ConstraintsDirection.HORIZONTAL}'></div>
        <div class='item' data-value='center' data-selected="${h === Constraints.CENTER}" data-key='${ConstraintsDirection.HORIZONTAL}'></div>

        <!-- Vertical -->
        <div class='item' data-value='min' data-selected="${v === Constraints.MIN || v === Constraints.STRETCH}" data-key='${ConstraintsDirection.VERTICAL}'></div>
        <div class='item' data-value='max' data-selected="${v === Constraints.MAX || v === Constraints.STRETCH}" data-key='${ConstraintsDirection.VERTICAL}'></div>
        <div class='item' data-value='center' data-selected="${v === Constraints.CENTER}" data-key='${ConstraintsDirection.VERTICAL}'></div>            
        <div class="rect"></div>
      </div>
    `;
  }
  [LOAD("$constraintsInfoInput")]() {
    var current = this.$context.selection.current;
    const hasLayout = current == null ? void 0 : current.hasLayout();
    return `
      <div>
        ${createComponent("SelectEditor", {
      ref: "$constraintsHorizontal",
      key: "constraints-horizontal",
      value: (current == null ? void 0 : current["constraints-horizontal"]) || "min",
      label: iconUse("width"),
      compact: true,
      options: [
        { value: "min", text: "Left" },
        { value: "max", text: "Right" },
        { value: "stretch", text: "Left and Right", disabled: hasLayout },
        { value: "center", text: "Center" },
        { value: "scale", text: "Scale", disabled: hasLayout }
      ],
      onchange: "changeConstraints"
    })}
      </div>

      <div>
        ${createComponent("SelectEditor", {
      ref: "$constraintsVertical",
      key: "constraints-vertical",
      value: (current == null ? void 0 : current["constraints-vertical"]) || "min",
      label: iconUse("height"),
      compact: true,
      options: [
        { value: "min", text: "Top" },
        { value: "max", text: "Bottom" },
        { value: "stretch", text: "Top and Bottom", disabled: hasLayout },
        { value: "center", text: "Center" },
        { value: "scale", text: "Scale", disabled: hasLayout }
      ],
      onchange: "changeConstraints"
    })}
      </div>
    `;
  }
  [CLICK("$constraintsInfo .item")](e) {
    const [value, key] = e.$dt.attrs("data-value", "data-key");
    const current = this.$context.selection.current;
    if (!current)
      return;
    current.changeConstraints(key, value, e.shiftKey);
    this.trigger("changeConstraints", key, current[key]);
  }
  [SUBSCRIBE_SELF("changeConstraints")](key, value) {
    this.$commands.executeCommand("setAttribute", "apply constraints", this.$context.selection.packByValue({
      [key]: value
    }));
    this.nextTick(() => {
      this.refresh();
    }, 100);
  }
  [SUBSCRIBE(REFRESH_SELECTION) + DEBOUNCE(100)]() {
    this.refreshShow(() => {
      var current = this.$context.selection.current;
      return current && current.isInDefault() && current.parent.isNot("project");
    });
  }
}
var FlexGrowToolView$1 = "";
class FlexGrowToolView extends EditorElement {
  template() {
    return /* @__PURE__ */ createElementJsx("div", {
      class: "elf--flex-grow-tool-view"
    });
  }
  [LOAD("$el") + DOMDIFF]() {
    return this.$context.selection.map((item) => {
      const parentItem = item.parent;
      if (!parentItem)
        return;
      if (parentItem.is("project"))
        return;
      if (parentItem.isLayout(Layout.FLEX) === false)
        return;
      return parentItem.layers.map((child) => {
        const verties = this.$viewport.applyVerties(child.verties);
        const center2 = verties[4];
        let flexGrow = 0;
        let size2 = child.screenWidth || 0;
        const parentLayoutDirection = parentItem == null ? void 0 : parentItem.flexDirection;
        if (parentLayoutDirection === FlexDirection.ROW) {
          if (child.resizingHorizontal === ResizingMode.FILL_CONTAINER) {
            flexGrow = child.flexGrow || 1;
          }
          size2 = child.screenWidth;
        } else if (parentLayoutDirection === FlexDirection.COLUMN) {
          if (child.resizingVertical === ResizingMode.FILL_CONTAINER) {
            flexGrow = child.flexGrow || 1;
          }
          size2 = child.screenHeight;
        }
        return /* @__PURE__ */ createElementJsx("div", {
          class: "flex-grow-item",
          style: {
            left: Length.px(center2[0]),
            top: Length.px(center2[1])
          },
          "data-flex-item-id": child.id,
          "data-parent-direction": parentLayoutDirection,
          "data-flex-grow": flexGrow
        }, /* @__PURE__ */ createElementJsx("span", {
          class: "size"
        }, Math.floor(size2)), " ", /* @__PURE__ */ createElementJsx("span", {
          class: "grow"
        }, flexGrow || "x"));
      }).join("");
    });
  }
  [POINTERSTART("$el .flex-grow-item") + MOVE() + END()](e) {
    const [id, grow] = e.$dt.attrs("data-flex-item-id", "data-flex-grow");
    this.setState({
      id,
      grow: +grow
    }, false);
  }
  getFlexGrow(parentLayoutDirection, item, grow, dx, dy) {
    let flexGrow = grow;
    if (parentLayoutDirection === FlexDirection.ROW && item.resizingHorizontal === ResizingMode.FILL_CONTAINER) {
      flexGrow = grow + Math.floor(dx / 10);
    } else if (parentLayoutDirection === FlexDirection.COLUMN && item.resizingVertical === ResizingMode.FILL_CONTAINER) {
      flexGrow = grow + Math.floor(dy / 10);
    }
    flexGrow = Math.max(1, flexGrow);
    return flexGrow;
  }
  move(dx, dy) {
    const { id, grow } = this.state;
    const item = this.$editor.get(id);
    if (!item)
      return;
    const parentItem = item.parent;
    if (!parentItem)
      return;
    const parentLayoutDirection = parentItem.flexDirection;
    let flexGrow = this.getFlexGrow(parentLayoutDirection, item, grow, dx, dy);
    this.$commands.emit("setAttribute", {
      [id]: {
        flexGrow
      }
    });
  }
  end(dx, dy) {
    const { id, grow } = this.state;
    const item = this.$editor.get(id);
    if (!item)
      return;
    const parentItem = item.parent;
    if (!parentItem)
      return;
    const parentLayoutDirection = parentItem.flexDirection;
    let flexGrow = this.getFlexGrow(parentLayoutDirection, item, grow, dx, dy);
    if (dx === 0 && dy === 0) {
      if (parentLayoutDirection === FlexDirection.ROW && item.resizingHorizontal !== ResizingMode.FILL_CONTAINER) {
        this.$commands.executeCommand("setAttribute", "change self resizing", {
          [id]: {
            flexGrow: 1,
            resizingHorizontal: ResizingMode.FILL_CONTAINER
          }
        });
      } else if (parentLayoutDirection === FlexDirection.COLUMN && item.resizingVertical !== ResizingMode.FILL_CONTAINER) {
        this.$commands.executeCommand("setAttribute", "change self resizing", {
          [id]: {
            flexGrow: 1,
            resizingVertical: ResizingMode.FILL_CONTAINER
          }
        });
      }
    } else {
      this.$commands.executeCommand("setAttribute", "change self resizing", {
        [id]: {
          flexGrow
        }
      });
    }
    this.nextTick(() => {
      this.refresh();
    }, 10);
  }
  [SUBSCRIBE(UPDATE_VIEWPORT)]() {
    this.refresh();
  }
  [SUBSCRIBE(REFRESH_SELECTION) + THROTTLE(100)]() {
    this.refresh();
  }
  [SUBSCRIBE(UPDATE_CANVAS) + THROTTLE(1)]() {
    this.refresh();
  }
  [CONFIG("set.move.control.point")]() {
    this.refresh();
  }
}
var FlexLayoutEditor$1 = "";
class FlexLayoutEditor extends EditorElement {
  initialize() {
    super.initialize();
    this.directionOptions = this.getDirectionOptions();
    this.wrapOptions = this.getWrapOptions();
    this.justifyContentOptions = this.getJustifyContentOptions();
    this.alignItemsOptions = this.getAlignItemsOptions();
  }
  getDirectionOptions() {
    return this.makeOptionsFunction("row,column");
  }
  getWrapOptions() {
    return this.makeOptionsFunction("nowrap,wrap");
  }
  getJustifyContentOptions() {
    return this.makeOptionsFunction("flex-start,flex-end,center,space-between,space-around");
  }
  getAlignItemsOptions() {
    return this.makeOptionsFunction("flex-start,flex-end,center,baseline,stretch");
  }
  getAlignContentOptions() {
    return this.makeOptionsFunction("flex-start,flex-end,center,space-between,space-around,stretch");
  }
  makeOptionsFunction(options2) {
    return options2.split(",").map((it) => {
      return { value: it, text: this.$i18n("flex.layout.editor." + it) };
    });
  }
  initState() {
    return __spreadValues({}, this.props.value);
  }
  setValue(value) {
    this.setState(__spreadValues({}, value));
  }
  getValue() {
    return this.state;
  }
  modifyData(key, value) {
    this.parent.trigger(this.props.onchange, key, value);
  }
  [LOAD("$body") + DOMDIFF]() {
    const current = this.$context.selection.current;
    if (!current)
      return "";
    const realPaddingTop = Math.min(current.paddingTop || 0, 50);
    const realPaddingLeft = Math.min(current.paddingLeft || 0, 50);
    const realPaddingRight = Math.min(current.paddingRight || 0, 50);
    const realPaddingBottom = Math.min(current.paddingBottom || 0, 50);
    const padding2 = `padding-top:${realPaddingTop}px;padding-left: ${realPaddingLeft}px;padding-right:${realPaddingRight}px;padding-bottom: ${realPaddingBottom}px;`;
    return `<div class='flex-layout-item'><div class="grid-2"><div>${createComponent("SelectIconEditor", {
      key: "flexDirection",
      ref: "$flexDirection",
      value: this.state.flexDirection || FlexDirection.ROW,
      options: this.directionOptions,
      icons: ["east", "south"],
      onchange: "changeKeyValue"
    })}</div><div>${createComponent("NumberInputEditor", {
      compact: true,
      ref: "$flex-gap",
      label: iconUse("space"),
      key: "gap",
      value: this.state.gap,
      min: 0,
      max: 100,
      step: 1,
      onchange: "changeKeyValue"
    })}</div><div>${createComponent("NumberInputEditor", {
      compact: true,
      label: iconUse("padding"),
      key: "padding",
      ref: "$padding",
      value: current.paddingTop,
      min: 0,
      max: 100,
      step: 1,
      onchange: "changePadding"
    })}</div><div>${createComponent("ToggleButton", {
      compact: true,
      key: "flexWrap",
      ref: "$wrap",
      size: 30,
      checkedValue: "wrap",
      value: this.state.flexWrap || FlexWrap.NOWRAP,
      toggleLabels: [iconUse("wrap"), iconUse("wrap")],
      toggleValues: [FlexWrap.NOWRAP, FlexWrap.WRAP],
      onchange: "changeKeyValue"
    })}</div></div></div>
  <div class="select-flex-direction">
      <div>
          <div class="flex-group-padding">            
              <div class="padding-top" style="height: ${current.paddingTop}px"></div>
              <div class="padding-left" style="width: ${current.paddingLeft}px"></div>
              <div class="padding-right" style="width: ${current.paddingRight}px"></div>
              <div class="padding-bottom" style="height: ${current.paddingBottom}px"></div>
          </div>
          <div class="flex-group" style="
                  --flex-group-gap: ${Math.floor(this.state.gap / 10)}px;
                  --flex-group-padding: ${realPaddingTop}px;
                  ${padding2};
                  flex-direction: ${this.state.flexDirection};
                  flex-wrap: ${this.state.flexWrap};
                  justify-content:${this.state.justifyContent};
                  align-items: ${this.state.alignItems};
                  align-content:${this.state.alignContent};
          ">
              ${[1, 2, 3].map(() => {
      return `
                      <div class="flex-direction" data-value="${this.state.flexDirection}" style="flex-direction: ${this.state.flexDirection};align-items: ${this.state.alignItem};">
                          <div class="flex-direction-item" data-index="1"></div>
                          <div class="flex-direction-item" data-index="2"></div>
                          <div class="flex-direction-item" data-index="3"></div>
                      </div>
                  `;
    }).join("\n")}
          </div>
          <div class="flex-group-tool"  style="${padding2};">
              <div class="tool-area"  
                  data-direction="${this.state.flexDirection}"  
                  data-justify-content="${this.state.justifyContent}"
                  data-align-items="${this.state.alignItems}"
                  data-align-content="${this.state.alignContent}"                            
                  style="
                      --flex-group-gap: ${Math.floor(this.state["gap"] / 10)}px;
                      --flex-group-padding: ${realPaddingTop}px;
                  "
              >
                  <div class="tool-area-item" data-index="1" data-justify-content="flex-start" data-align-items="flex-start"></div>
                  <div class="tool-area-item" data-index="2"  data-justify-content="center" data-align-items="flex-start"></div>
                  <div class="tool-area-item" data-index="3"  data-justify-content="flex-end" data-align-items="flex-start"></div>
                  <div class="tool-area-item" data-index="4"  data-justify-content="flex-start" data-align-items="center"></div>
                  <div class="tool-area-item" data-index="5"  data-justify-content="center" data-align-items="center"></div>
                  <div class="tool-area-item" data-index="6"  data-justify-content="flex-end" data-align-items="center"></div>
                  <div class="tool-area-item" data-index="7"  data-justify-content="flex-start" data-align-items="flex-end"></div>
                  <div class="tool-area-item" data-index="8"  data-justify-content="center" data-align-items="flex-end"></div>
                  <div class="tool-area-item" data-index="9"  data-justify-content="flex-end" data-align-items="flex-end"></div>                            
              </div>
          </div>
      </div>
  </div>

  <div class='flex-layout-item'>
      <div class="title">${this.$i18n("flex.layout.editor.justify-content")}</div>
      ${createComponent("SelectIconEditor", {
      key: "justifyContent",
      ref: "$justify",
      value: this.state.justifyContent || JustifyContent.FLEX_START,
      options: this.justifyContentOptions,
      icons: [
        "start",
        "end",
        "horizontal_align_center",
        "horizontal_distribute",
        "justify_content_space_around"
      ],
      onchange: "changeKeyValue"
    })}
  </div>
  <div class='flex-layout-item'>
      <div class="title">${this.$i18n("flex.layout.editor.align-items")}</div>            
      ${createComponent("SelectIconEditor", {
      key: "alignItems",
      ref: "$alignItems",
      value: this.state.alignItems || AlignItems.FLEX_START,
      options: this.alignItemsOptions,
      icons: [
        "vertical_align_top",
        "vertical_align_bottom",
        "vertical_align_center",
        "vertical_align_baseline",
        "vertical_align_stretch"
      ],
      onchange: "changeKeyValue"
    })}
  </div>
        `;
  }
  template() {
    return `
            <div class='flex-layout-editor' ref='$body' ></div>
        `;
  }
  [SUBSCRIBE_SELF("changeKeyValue")](key, value) {
    this.setState({
      [key]: value
    }, false);
    this.modifyData(key, value);
    this.refresh();
  }
  [SUBSCRIBE_SELF("changePadding")](key, value) {
    this.setState({
      [key]: value
    }, false);
    this.modifyData(key, {
      paddingTop: value,
      paddingLeft: value,
      paddingRight: value,
      paddingBottom: value
    });
    this.refresh();
  }
  [CLICK("$body .tool-area-item")](e) {
    const $target = e.$dt;
    const [justifyContent, alignItems] = $target.attrs("data-justify-content", "data-align-items", "data-align-content");
    if (this.state.justifyContent === JustifyContent.SPACE_BETWEEN) {
      this.setState({
        alignItems
      }, false);
      this.modifyData("alignItems", alignItems);
    } else if (this.state.justifyContent === JustifyContent.SPACE_AROUND) {
      this.setState({
        alignItems
      }, false);
      this.modifyData("align-item", alignItems);
    } else {
      this.setState({
        justifyContent,
        alignItems
      }, false);
      this.modifyData("justifyContent", justifyContent);
      this.modifyData("alignItems", alignItems);
    }
    this.refresh();
  }
}
var GridBoxEditor$1 = "";
const REG_CSS_UNIT = /(auto)|(repeat\([^)]*\))|(([\d.]+)(px|pt|fr|r?em|deg|vh|vw|%))/gi;
class GridBoxEditor extends EditorElement {
  getLayoutItemOptions() {
    return "none,auto,repeat,length".split(",").map((it) => {
      return { value: it, text: this.$i18n(`grid.box.editor.${it}`) };
    });
  }
  initState() {
    return {
      label: this.props.label,
      list: this.parseValue(this.props.value)
    };
  }
  setValue(value) {
    this.setState({
      list: this.parseValue(value)
    });
  }
  parseValue(value) {
    let arr = null;
    var target = [];
    while ((arr = REG_CSS_UNIT.exec(value)) !== null) {
      var text2 = arr[0];
      if (text2 === "auto") {
        target.push({ type: "auto", count: 0, value: "0px" });
      } else if (text2.includes("repeat")) {
        var tempArray = text2.split("repeat(")[1].split(")");
        tempArray.pop();
        let [count, ...size2] = tempArray.join("").split(",");
        target.push({ type: "repeat", count, value: size2.join(", ") });
      } else {
        target.push({ type: "length", count: 1, value: text2 });
      }
    }
    return target;
  }
  getValue() {
    return this.state.list.map((it) => {
      if (it.type === "repeat") {
        return `repeat(${it.count}, ${it.value})`;
      } else if (it.type === "auto" || it.type === "none") {
        return it.type;
      } else {
        return it.value;
      }
    }).join(" ");
  }
  modifyData() {
    this.parent.trigger(this.props.onchange, this.props.key, this.getValue());
  }
  makeItem(it, index2) {
    return `
            <div class='item' data-repeat-type='${it.type}' data-index='${index2}' >
                <div class='repeat'>
                    ${createComponent("SelectEditor", {
      ref: `$${index2}-type`,
      compact: true,
      options: this.getLayoutItemOptions(),
      key: "type",
      value: it.type || "auto",
      params: index2,
      onchange: "changeKeyValue"
    })}
                </div>
                <div class='count'>
                    ${createComponent("NumberInputEditor", {
      compact: true,
      ref: `$${index2}-count`,
      key: "count",
      value: it.count,
      params: index2,
      max: 1e3,
      onchange: "changeKeyValue"
    })}
                </div>                
                <div class='value'>
                    ${createComponent("InputRangeEditor", {
      ref: `$${index2}-value`,
      compact: true,
      key: "value",
      value: it.value,
      params: index2,
      units: ["auto", "fr", "px", "em", "%"],
      onchange: "changeKeyValue"
    })}
                </div>
                <div class='tools'>
                    <button type="button" class='copy'>${iconUse("copy")}</button>                
                    <button type="button" class='remove'>${iconUse("remove2")}</button>
                </div>
            </div>
        `;
  }
  [LOAD("$list")]() {
    return this.state.list.map((it, index2) => {
      return this.makeItem(it, index2);
    });
  }
  template() {
    return `
            <div class='elf--grid-box-editor' ref='$body' >
                <div class='grid-box-editor-item'>
                    <div class='item header'>
                        <div class='repeat'>
                            <label>${this.state.label} </label>
                            <button type='button' ref='$add'>${obj$2.add}</button>
                        </div>
                        <div class='count'>${this.$i18n("grid.box.editor.count")}</div>
                        <div class='value'>${this.$i18n("grid.box.editor.value")}</div>
                        <div class='tools'></div>
                    </div>
                    <div ref='$list'></div>
                </div>
            </div>
        `;
  }
  [CLICK("$list .remove")](e) {
    var index2 = +e.$dt.closest("item").attr("data-index");
    this.state.list.splice(index2, 1);
    this.refresh();
    this.modifyData();
  }
  [CLICK("$list .copy")](e) {
    var index2 = +e.$dt.closest("item").attr("data-index");
    var newObj = clone$1(this.state.list[index2]);
    this.state.list.splice(index2, 0, newObj);
    this.refresh();
    this.modifyData();
  }
  [CLICK("$add")]() {
    this.trigger("add");
  }
  [SUBSCRIBE("add")]() {
    this.state.list.push({ type: "auto", count: 0, value: "0px" });
    this.refresh();
    this.modifyData();
  }
  [SUBSCRIBE_SELF("changeKeyValue")](key, value, params) {
    var index2 = +params;
    var item = this.state.list[index2];
    if (item) {
      if (key === "type") {
        this.refs.$list.$(`[data-index="${index2}"]`).attr("data-repeat-type", value);
      }
      item[key] = value;
    }
    this.modifyData();
  }
}
class GridGapEditor extends EditorElement {
  initState() {
    return {
      label: this.props.label,
      value: this.parseValue(this.props.value)
    };
  }
  setValue(value) {
    this.setState({
      list: this.parseValue(value)
    });
  }
  parseValue(value) {
    return Length.parse(value);
  }
  getValue() {
    return this.state.value;
  }
  modifyData() {
    this.parent.trigger(this.props.onchange, this.props.key, this.getValue());
  }
  makeItem() {
    return `
            <div class='item'>
                <div class='value'>
                    ${createComponent("InputRangeEditor", {
      label: this.state.label,
      wide: true,
      ref: "$value",
      key: "value",
      value: this.state.value,
      max: 500,
      units: ["px", "em", "%"],
      onchange: "changeKeyValue"
    })}
                </div>
            </div>
        `;
  }
  [LOAD("$list")]() {
    return this.makeItem();
  }
  template() {
    return `
            <div class='grid-gap-editor' ref='$body' >
                <div class='grid-gap-editor-item'>
                    <div ref='$list'></div>
                </div>
            </div>
        `;
  }
  [SUBSCRIBE_SELF("changeKeyValue")](key, value) {
    this.state.value = value;
    this.modifyData();
  }
}
var GridGrowToolView$1 = "";
class Grid {
  static parseStyle(value) {
    const units = [];
    parseValue(value).forEach((it) => {
      switch (it.func) {
        case FuncType.REPEAT:
          for (var i = 0, len2 = it.parsed.count; i < len2; i++) {
            units.push(it.parsed.length);
          }
          break;
        case FuncType.LENGTH:
          units.push(it.parsed);
          break;
        case FuncType.KEYWORD:
          units.push(it.matchedString);
          break;
      }
    });
    return units;
  }
  static join(values = []) {
    return values.join(" ");
  }
}
class GridGrowBaseView extends EditorElement {
  updateRows(current, newRows) {
    const data = {};
    current.layers.forEach((it) => {
      data[it.id] = {
        gridRowStart: Math.max(1, Math.min(newRows.length, it.gridRowStart)),
        gridRowEnd: Math.min(newRows.length + 1, it.gridRowEnd)
      };
    });
    this.$commands.executeCommand("setAttribute", "change grid rows", __spreadProps(__spreadValues({}, data), {
      [current.id]: {
        gridTemplateRows: Grid.join(newRows)
      }
    }));
  }
  updateColumns(current, newColumns) {
    const data = {};
    current.layers.forEach((it) => {
      data[it.id] = {
        gridColumnStart: Math.max(1, Math.min(newColumns.length, it.gridColumnStart)),
        gridColumnEnd: Math.min(newColumns.length + 1, it.gridColumnEnd)
      };
    });
    this.$commands.executeCommand("setAttribute", "change grid columns", __spreadProps(__spreadValues({}, data), {
      [current.id]: {
        gridTemplateColumns: Grid.join(newColumns)
      }
    }));
  }
  updateColumnGap(current, columnGap) {
    this.$commands.executeCommand("setAttribute", "change grid column gap", {
      [current.id]: {
        gridColumnGap: `${columnGap}`
      }
    });
  }
  updateRowGap(current, rowGap) {
    this.$commands.executeCommand("setAttribute", "change grid row gap", {
      [current.id]: {
        gridRowGap: `${rowGap}`
      }
    });
  }
  createNewGridItems(arr) {
    let newArr = [];
    if (arr.length === 0) {
      newArr = [Length.fr(1)];
    } else {
      newArr = [...arr, arr[arr.length - 1]];
    }
    return newArr;
  }
  copyNewGridItems(arr, index2) {
    return [...arr.slice(0, index2 + 1), ...arr.slice(index2)];
  }
  getScaleDist(num) {
    return num / this.$viewport.scale;
  }
}
class GridGrowClickEventView extends GridGrowBaseView {
  checkTargetLayer() {
    const current = this.getGridTargetLayer();
    if (!current)
      return false;
    if (current.isLayout(Layout.GRID) === false)
      return false;
    return true;
  }
  [CLICK("$grid .column-plus") + IF("checkTargetLayer")]() {
    const info = this.getGridLayoutInformation();
    this.updateColumns(info.current, this.createNewGridItems(info.columns));
  }
  [CLICK("$grid .row-plus") + IF("checkTargetLayer")]() {
    const info = this.getGridLayoutInformation();
    this.updateRows(info.current, this.createNewGridItems(info.rows));
  }
  [CLICK("$grid .column-delete") + IF("checkTargetLayer")](e) {
    const info = this.getGridLayoutInformation();
    if (info.columns.length < 2) {
      this.alert("Alert", "Columns can not be less than one.", 2e3);
      return;
    }
    const index2 = +e.$dt.data("index");
    const newColumns = [
      ...info.columns.slice(0, index2),
      ...info.columns.slice(index2 + 1)
    ];
    this.updateColumns(info.current, newColumns);
  }
  [CLICK("$grid .column-add") + IF("checkTargetLayer")](e) {
    const info = this.getGridLayoutInformation();
    const index2 = +e.$dt.data("index");
    this.updateColumns(info.current, this.copyNewGridItems(info.columns, index2), index2 + 1);
  }
  [CLICK("$grid .row-add") + IF("checkTargetLayer")](e) {
    const info = this.getGridLayoutInformation();
    const index2 = +e.$dt.data("index");
    this.updateRows(info.current, this.copyNewGridItems(info.rows, index2));
  }
  [CLICK("$grid .row-delete") + IF("checkTargetLayer")](e) {
    const info = this.getGridLayoutInformation();
    if (info.rows.length < 2) {
      this.alert("Alert", "Rows can not be less than one.", 2e3);
      return;
    }
    const index2 = +e.$dt.data("index");
    const newRows = [
      ...info.rows.slice(0, index2),
      ...info.rows.slice(index2 + 1)
    ];
    this.updateRows(info.current, newRows);
  }
}
class GridGrowDragEventView extends GridGrowClickEventView {
  [POINTERSTART("$gridGap .gap-tool.column-gap") + IF("checkTargetLayer") + FIRSTMOVE("moveFirstColumnGap") + MOVE("moveColumnGap") + END("moveEndColumnGap")](e) {
    const info = this.getGridLayoutInformation();
    this.current = info.current;
    this.columnGap = info.columnGap;
    this.lastColumnGap = info.columnGap;
    this.initMousePosition = this.$viewport.getWorldPosition(e);
  }
  updateGapPointer(gap) {
    const screenPosition = this.$viewport.applyVertex(this.$viewport.getWorldPosition());
    this.refs.$pointer.text(`${gap}`);
    this.refs.$pointer.css({
      left: Length.px(screenPosition[0]),
      top: Length.px(screenPosition[1] + 20)
    });
  }
  moveFirstColumnGap() {
    this.refs.$pointer.show();
    this.updateGapPointer(this.columnGap);
  }
  moveColumnGap() {
    const targetPosition = this.$viewport.getWorldPosition();
    const newDist = subtract([], targetPosition, this.initMousePosition);
    const stepRate = newDist[0] / this.getScaleDist(100);
    const columnGap = this.columnGap;
    let newColumnGap = columnGap;
    if (columnGap instanceof Length) {
      if (columnGap.isPercent()) {
        newColumnGap = Length.percent(Math.max(columnGap.value + stepRate * this.getScaleDist(5), 0)).round(1e3);
      } else if (columnGap.isPx() || columnGap.isEm()) {
        newColumnGap = Length.px(Math.max(columnGap.value + stepRate * this.getScaleDist(100), 0)).floor();
      }
    }
    this.lastColumnGap = newColumnGap;
    this.updateColumnGap(this.current, newColumnGap);
    this.updateGapPointer(this.lastColumnGap);
  }
  moveEndColumnGap() {
    const targetPosition = this.$viewport.getWorldPosition();
    const realDistance = dist(targetPosition, this.initMousePosition);
    if (realDistance < 1) {
      if (this.lastColumnGap.isPx() || this.lastColumnGap.isEm()) {
        this.lastColumnGap = Length.makePercent(this.lastColumnGap.value, this.current.screenWidth);
      } else {
        this.lastColumnGap = this.lastColumnGap.toPx(this.current.screenWidth);
      }
    }
    this.updateColumnGap(this.current, this.lastColumnGap);
    this.refs.$pointer.hide();
  }
  [POINTERSTART("$gridGap .gap-tool.row-gap") + IF("checkTargetLayer") + FIRSTMOVE("moveFirstColumnGap") + MOVE("moveRowGap") + END("moveEndRowGap")](e) {
    const info = this.getGridLayoutInformation();
    this.current = info.current;
    this.rowGap = info.rowGap;
    this.lastColumnGap = info.rowGap;
    this.initMousePosition = this.$viewport.getWorldPosition(e);
  }
  moveRowGap() {
    const targetPosition = this.$viewport.getWorldPosition();
    const newDist = subtract([], targetPosition, this.initMousePosition);
    const stepRate = newDist[1] / this.getScaleDist(100);
    const rowGap = this.rowGap;
    let newRowGap = rowGap;
    console.log(rowGap);
    if (rowGap instanceof Length) {
      if (rowGap.isPercent()) {
        newRowGap = Length.percent(Math.max(rowGap.value + stepRate * this.getScaleDist(5), 0)).round(1e3);
      } else if (rowGap.isPx() || rowGap.isNumber()) {
        newRowGap = Length.px(Math.max(rowGap.value + stepRate * this.getScaleDist(100), 0)).floor();
      }
    }
    this.lastRowGap = newRowGap;
    this.updateRowGap(this.current, newRowGap);
    this.updateGapPointer(this.lastRowGap);
  }
  moveEndRowGap() {
    const targetPosition = this.$viewport.getWorldPosition();
    const realDistance = dist(targetPosition, this.initMousePosition);
    if (realDistance < 1) {
      if (!this.lastRowGap) {
        this.lastRowGap = Length.px(0);
      }
      if (this.lastRowGap.isPx() || this.lastRowGap.isNumber()) {
        this.lastRowGap = Length.makePercent(this.lastRowGap.value, this.current.screenHeight);
      } else {
        this.lastRowGap = this.lastRowGap.toPx(this.current.screenHeight);
      }
    }
    this.updateRowGap(this.current, this.lastRowGap);
    this.refs.$pointer.hide();
  }
  [POINTERSTART("$grid .grid-item-tool.column .item") + MOVE("moveColumn") + END("moveEndColumn")](e) {
    const index2 = +e.$dt.data("index");
    const info = this.getGridLayoutInformation();
    this.current = info.current;
    this.columns = info.columns;
    this.selectedColumnIndex = index2;
    this.selectedColumnWidth = info.columns[index2];
    this.initMousePosition = this.$viewport.getWorldPosition(e);
  }
  moveColumn() {
    const targetPosition = this.$viewport.getWorldPosition();
    const newDist = subtract([], targetPosition, this.initMousePosition);
    const stepRate = newDist[0] / this.getScaleDist(100);
    const columnWidth = this.selectedColumnWidth;
    if (columnWidth instanceof Length) {
      if (columnWidth.isPercent()) {
        var newWidth = Math.max(columnWidth.value + stepRate * this.getScaleDist(5), 1);
        this.columns[this.selectedColumnIndex] = Length.percent(newWidth).round(1e3);
      } else if (columnWidth.isPx() || columnWidth.isNumber()) {
        var newWidth = Math.max(10, columnWidth.value + stepRate * this.getScaleDist(100));
        this.columns[this.selectedColumnIndex] = Length.px(newWidth).floor();
      } else if (columnWidth.isFr()) {
        var newWidth = Math.max(columnWidth.value + Math.floor(newDist[0] / this.getScaleDist(20)) * 0.25, 0.25);
        this.columns[this.selectedColumnIndex] = Length.fr(newWidth);
      } else {
        var newWidth = Math.max(columnWidth.value + stepRate * 1, 10);
        this.columns[this.selectedColumnIndex] = new Length(newWidth, columnWidth.unit);
      }
      this.updateColumns(this.current, this.columns);
    }
  }
  changedColumnSize() {
    const info = this.getGridLayoutInformation();
    const index2 = this.selectedColumnIndex;
    const width2 = this.selectedColumnWidth;
    if (width2 instanceof Length) {
      if (width2.isPercent()) {
        this.columns[index2] = Length.fr(1);
      } else if (width2.isPx() || width2.isNumber()) {
        this.columns[index2] = Length.makePercent(width2.value, info.current.screenWidth).round(1e3);
      } else if (width2.isFr()) {
        this.columns[index2] = "auto";
      }
    } else if (width2 === "auto") {
      const { items } = this.state.lastGridInfo;
      const column = items.find((it) => it.column === index2 + 1);
      this.columns[index2] = Length.px(column.rect.width).floor();
    }
  }
  moveEndColumn() {
    const targetPosition = this.$viewport.getWorldPosition();
    const realDistance = dist(targetPosition, this.initMousePosition);
    if (realDistance < 1) {
      this.changedColumnSize();
    }
    this.updateColumns(this.current, this.columns);
  }
  [POINTERSTART("$grid .grid-item-tool.row .item") + MOVE("moveRow") + END("moveEndRow")](e) {
    const index2 = +e.$dt.data("index");
    const info = this.getGridLayoutInformation();
    this.current = info.current;
    this.rows = info.rows;
    this.selectedRowIndex = index2;
    this.selectedRowHeight = info.rows[index2];
    this.initMousePosition = this.$viewport.getWorldPosition(e);
  }
  moveRow() {
    const targetPosition = this.$viewport.getWorldPosition();
    const newDist = subtract([], targetPosition, this.initMousePosition);
    const stepRate = newDist[1] / this.getScaleDist(30);
    const rowHeight = this.selectedRowHeight;
    if (rowHeight instanceof Length) {
      if (rowHeight.isPercent()) {
        var newHeight = Math.max(rowHeight.value - stepRate * this.getScaleDist(5), 1);
        this.rows[this.selectedRowIndex] = Length.percent(newHeight).round(1e3);
      } else if (rowHeight.isPx() || rowHeight.isNumber()) {
        var newHeight = Math.max(10, rowHeight.value - stepRate * this.getScaleDist(100));
        this.rows[this.selectedRowIndex] = Length.px(newHeight).floor();
      } else if (rowHeight.isFr()) {
        var newHeight = Math.max(rowHeight.value + Math.floor(newDist[1] / this.getScaleDist(20)) * 0.25, 0.25);
        this.rows[this.selectedRowIndex] = Length.fr(newHeight);
      } else {
        var newHeight = Math.max(rowHeight.value - stepRate * 1, 10);
        this.rows[this.selectedRowIndex] = new Length(newHeight, rowHeight.unit);
      }
      this.updateRows(this.current, this.rows);
    }
  }
  changedRowSize() {
    const info = this.getGridLayoutInformation();
    const index2 = this.selectedRowIndex;
    const height2 = this.selectedRowHeight;
    if (height2 instanceof Length) {
      if (height2.isPercent()) {
        this.rows[index2] = Length.fr(1);
      } else if (height2.isPx() || height2.isNumber()) {
        this.rows[index2] = Length.makePercent(height2.value, info.current.screenHeight).round(1e3);
      } else if (height2.isFr()) {
        this.rows[index2] = "auto";
      }
    } else if (height2 === "auto") {
      const { items } = this.state.lastGridInfo;
      const row = items.find((it) => it.row === index2 + 1);
      this.rows[index2] = Length.px(row.rect.height).floor();
    }
  }
  moveEndRow() {
    const targetPosition = this.$viewport.getWorldPosition();
    const realDistance = dist(targetPosition, this.initMousePosition);
    if (realDistance < 1) {
      this.changedRowSize();
    }
    this.updateRows(this.current, this.rows);
  }
}
class GridGrowToolView extends GridGrowDragEventView {
  template() {
    return /* @__PURE__ */ createElementJsx("div", {
      class: "elf--grid-grow-tool-view"
    }, /* @__PURE__ */ createElementJsx("div", {
      class: "layout-rect",
      ref: "$grid"
    }), /* @__PURE__ */ createElementJsx("div", {
      class: "layout-rect blank-tool",
      ref: "$gridGap"
    }), /* @__PURE__ */ createElementJsx("div", {
      class: "layout-pointer",
      ref: "$pointer"
    }));
  }
  [BIND("$el")]() {
    var _a;
    const current = this.getGridTargetLayer();
    return {
      "data-drag-target-item": Boolean(this.$context.selection.dragTargetItem),
      "data-grid-layout-own": ((_a = this.$context.selection.current) == null ? void 0 : _a.id) === (current == null ? void 0 : current.id),
      style: {
        display: current ? "block" : "none"
      }
    };
  }
  [BIND("$grid")]() {
    const current = this.getGridTargetLayer();
    if (!current)
      return "";
    if (current.isLayout(Layout.GRID) === false)
      return "";
    const rect2 = vertiesToRectangle(this.$viewport.applyVerties(current.verties));
    const info = this.getGridLayoutInformation();
    const [paddingTop, paddingRight, paddingBottom, paddingLeft] = this.getScaledInformation([
      Length.px(info.current.paddingTop),
      Length.px(info.current.paddingRight),
      Length.px(info.current.paddingBottom),
      Length.px(info.current.paddingLeft)
    ]);
    const columns = this.getScaledInformation(info.columns);
    const rows = this.getScaledInformation(info.rows);
    const columnGap = this.getScaledLength(info.columnGap);
    const rowGap = this.getScaledLength(info.rowGap);
    const origin = subtract([], current.verties[1], current.verties[0]);
    const angle = calculateAngle360(origin[0], origin[1]) - 180;
    return {
      style: {
        display: "grid",
        "grid-template-columns": Grid.join(columns),
        "grid-template-rows": Grid.join(rows),
        "grid-column-gap": columnGap,
        "grid-row-gap": rowGap,
        left: Length.px(rect2.left),
        top: Length.px(rect2.top),
        width: Length.px(rect2.width),
        height: Length.px(rect2.height),
        "padding-top": paddingTop,
        "padding-right": paddingRight,
        "padding-bottom": paddingBottom,
        "padding-left": paddingLeft,
        "transform-origin": "left top",
        transform: `rotate(${angle}deg)`
      }
    };
  }
  [BIND("$gridGap")]() {
    const current = this.getGridTargetLayer();
    if (!current)
      return "";
    if (current.isLayout(Layout.GRID) === false)
      return "";
    const rect2 = vertiesToRectangle(this.$viewport.applyVerties(current.verties));
    const origin = subtract([], current.verties[1], current.verties[0]);
    const angle = calculateAngle360(origin[0], origin[1]) - 180;
    return {
      style: {
        left: Length.px(rect2.left),
        top: Length.px(rect2.top),
        width: Length.px(rect2.width),
        height: Length.px(rect2.height),
        "transform-origin": "left top",
        transform: `rotate(${angle}deg)`
      }
    };
  }
  getScaledInformation(arr) {
    return arr.map((it) => this.getScaledLength(it));
  }
  getScaledLength(it) {
    if (isString(it)) {
      return it;
    } else if (it instanceof Length) {
      if (it.isPx() || it.isNumber()) {
        return it.clone().mul(this.$viewport.scale);
      }
    }
    return it;
  }
  getGridTargetLayer() {
    if (this.$context.selection.dragTargetItem) {
      return this.$context.selection.dragTargetItem;
    }
    const current = this.$context.selection.current;
    if (!current)
      return null;
    if (current.isLayout(Layout.GRID))
      return current;
    const parent = current.parent;
    if (parent && parent.is("project"))
      return null;
    if (parent && parent.isLayout(Layout.GRID))
      return parent;
    return null;
  }
  getParsedValue(it) {
    if (it === "auto") {
      return it;
    }
    return Length.parse(it);
  }
  getGridLayoutInformation() {
    const current = this.getGridTargetLayer();
    const columns = Grid.parseStyle(current.gridTemplateColumns);
    const rows = Grid.parseStyle(current.gridTemplateRows);
    return {
      current,
      columns,
      columnGap: this.getParsedValue(current.gridColumnGap),
      rows,
      rowGap: this.getParsedValue(current.gridRowGap)
    };
  }
  afterLoadRendering(targetRef, refName) {
    this.trigger("refreshGridInformation", targetRef, refName);
  }
  [SUBSCRIBE_SELF("refreshGridInformation") + DEBOUNCE(10)](targetRef, refName) {
    const current = this.getGridTargetLayer();
    if (!current)
      return;
    if (current.isLayout(Layout.GRID) === false)
      return;
    if (refName !== "$grid")
      return;
    const info = this.getGridLayoutInformation();
    const scale2 = this.$viewport.scale;
    const items = targetRef.$$(".grid-item").map((it) => {
      const [row, column] = it.attrs("data-row", "data-column").map((it2) => +it2);
      const { x, y, width: width2, height: height2 } = it.offsetRect();
      const rect2 = {
        x: x / scale2,
        y: y / scale2,
        width: width2 / scale2,
        height: height2 / scale2
      };
      const verties = vertiesMap(rectToVerties(rect2.x, rect2.y, rect2.width, rect2.height), info.current.absoluteMatrix);
      const originVerties = verties.filter((_, index2) => index2 < 4);
      return {
        row,
        column,
        rect: rect2,
        info,
        verties,
        originVerties,
        originRect: vertiesToRectangle(originVerties)
      };
    });
    this.state.lastGridInfo = { info, items };
    this.load("$gridGap");
    this.$context.selection.updateGridInformation({
      info,
      items
    });
  }
  [LOAD("$gridGap") + DOMDIFF]() {
    const current = this.getGridTargetLayer();
    if (!current)
      return "";
    if (this.$config.true("set.move.control.point"))
      return "";
    if (!this.$context.selection.current)
      return "";
    const last = this.state.lastGridInfo;
    const scale2 = this.$viewport.scale;
    if (!last)
      return "";
    const { info, items } = last;
    const { columns, rows } = info;
    const result = [];
    const rowItems = items.filter((it) => it.column === 1);
    const columnItems = items.filter((it) => it.row === 1);
    const minY = Math.min(...rowItems.map((it) => it.verties[0][1]));
    const maxY = Math.max(...rowItems.map((it) => it.verties[2][1]));
    const h = maxY - minY;
    for (var columnIndex = 1, len2 = columns.length; columnIndex < len2 && columnItems.length; columnIndex++) {
      const prevCell = columnItems[columnIndex - 1];
      const cell = columnItems[columnIndex];
      const x = prevCell.rect.x + prevCell.rect.width;
      const w2 = cell.rect.x - x;
      const y = prevCell.rect.y;
      result.push({
        type: "column-gap",
        index: columnIndex,
        x,
        y,
        width: w2,
        height: h
      });
    }
    const minX = Math.min(...columnItems.map((it) => it.verties[0][0]));
    const maxX = Math.max(...columnItems.map((it) => it.verties[2][0]));
    const w = maxX - minX;
    for (var rowIndex = 1, len2 = rows.length; rowIndex < len2; rowIndex++) {
      const prevCell = rowItems[rowIndex - 1];
      const cell = rowItems[rowIndex];
      const y = prevCell.rect.y + prevCell.rect.height;
      const h2 = cell.rect.y - y;
      const x = prevCell.rect.x;
      result.push({
        type: "row-gap",
        index: rowIndex,
        x,
        y,
        width: w,
        height: h2
      });
    }
    return result.map((it) => {
      if (it.type === "column-gap") {
        return /* @__PURE__ */ createElementJsx("div", {
          class: "gap-tool column-gap",
          style: {
            left: Length.px(it.x * scale2),
            top: Length.px(it.y * scale2),
            width: Length.px(Math.max(it.width * scale2, 5)),
            height: Length.px(it.height * scale2)
          }
        });
      } else if (it.type === "row-gap") {
        return /* @__PURE__ */ createElementJsx("div", {
          class: "gap-tool row-gap",
          style: {
            left: Length.px(it.x * scale2),
            top: Length.px(it.y * scale2),
            height: Length.px(Math.max(it.height * scale2, 5)),
            width: Length.px(it.width * scale2)
          }
        });
      }
      return "";
    });
  }
  isSelectedColumn(index2) {
    const current = this.$context.selection.current;
    return current.gridColumnStart <= index2 && index2 < current.gridColumnEnd;
  }
  isSelectedRow(index2) {
    const current = this.$context.selection.current;
    return current.gridRowStart <= index2 && index2 < current.gridRowEnd;
  }
  [LOAD("$grid") + DOMDIFF]() {
    var _a;
    const current = this.getGridTargetLayer();
    if (!current)
      return "";
    if (current.isLayout(Layout.GRID) === false)
      return "";
    const info = this.getGridLayoutInformation();
    const totalCount = info.columns.length * info.rows.length;
    const isChild = ((_a = this.$context.selection.current) == null ? void 0 : _a.id) !== info.current.id;
    return /* @__PURE__ */ createElementJsx(FragmentInstance, null, Array.from(Array(info.columns.length).keys()).map((index2) => {
      const selected = isChild && this.isSelectedColumn(index2 + 1) ? "selected" : "";
      return /* @__PURE__ */ createElementJsx("div", {
        class: `grid-item-tool column ${selected}`,
        "data-index": index2,
        style: {
          "grid-column": `${index2 + 1} / span 1`,
          "grid-row": `1 / span 1`
        }
      }, /* @__PURE__ */ createElementJsx("div", {
        class: "grid-item-tool-inner"
      }, /* @__PURE__ */ createElementJsx("div", {
        class: "item",
        "data-index": index2
      }, /* @__PURE__ */ createElementJsx("span", null, info.columns[index2])), /* @__PURE__ */ createElementJsx("div", {
        class: "drag-handle right"
      }, /* @__PURE__ */ createElementJsx("div", {
        class: "column-delete",
        "data-index": index2,
        title: `Delete ${info.columns[index2]}`
      }, iconUse("close")), /* @__PURE__ */ createElementJsx("div", {
        class: "column-add",
        "data-index": index2,
        title: `Add ${info.columns[index2]}`
      }, iconUse("add")))));
    }), /* @__PURE__ */ createElementJsx("div", {
      class: "grid-item-tool append column-plus",
      style: {
        "grid-column": `${info.columns.length} / span 1`,
        "grid-row": `1 / span 1`
      }
    }, iconUse("add")), Array.from(Array(info.rows.length).keys()).map((index2) => {
      const selected = isChild && this.isSelectedRow(index2 + 1) ? "selected" : "";
      return /* @__PURE__ */ createElementJsx(FragmentInstance, null, /* @__PURE__ */ createElementJsx("div", {
        class: `grid-item-tool row ${selected}`,
        style: {
          "grid-row": `${index2 + 1} / span 1`,
          "grid-column": `1 / span 1`
        }
      }, /* @__PURE__ */ createElementJsx("div", {
        class: "grid-item-tool-inner"
      }, /* @__PURE__ */ createElementJsx("div", {
        class: "item",
        "data-index": index2
      }, /* @__PURE__ */ createElementJsx("span", null, info.rows[index2])), /* @__PURE__ */ createElementJsx("div", {
        class: "drag-handle bottom"
      }, /* @__PURE__ */ createElementJsx("div", {
        class: "row-delete",
        "data-index": index2,
        title: `Delete ${info.rows[index2]}`
      }, iconUse("close")), /* @__PURE__ */ createElementJsx("div", {
        class: "row-add",
        "data-index": index2,
        title: `Add ${info.rows[index2]}`
      }, iconUse("add"))))));
    }), /* @__PURE__ */ createElementJsx("div", {
      class: "grid-item-tool append row-plus",
      style: {
        "grid-row": `${info.rows.length} / span 1`,
        "grid-column": `1 / span 1`
      }
    }, iconUse("add")), Array.from(Array(totalCount).keys()).map((i) => {
      const column = i % info.columns.length;
      const row = Math.floor(i / info.columns.length);
      return /* @__PURE__ */ createElementJsx(FragmentInstance, null, /* @__PURE__ */ createElementJsx("div", {
        class: "grid-item",
        "data-row": row + 1,
        "data-column": column + 1,
        style: {
          "grid-column": `${column + 1} / span 1`,
          "grid-row": `${row + 1} / span 1`
        }
      }));
    }));
  }
  [SUBSCRIBE("refreshGridToolInfo")]() {
    this.refresh();
  }
  [SUBSCRIBE(UPDATE_VIEWPORT)]() {
    this.refresh();
  }
  [SUBSCRIBE(REFRESH_SELECTION) + DEBOUNCE(100)]() {
    this.refresh();
  }
  [SUBSCRIBE(UPDATE_CANVAS)]() {
    this.refresh();
  }
}
var GridLayoutEditor$1 = "";
class GridLayoutEditor extends EditorElement {
  modifyData(key, value) {
    this.parent.trigger(this.props.onchange, key, value);
  }
  template() {
    return `
            <div class='elf--grid-layout-editor' ref='$body' ></div>
        `;
  }
  [LOAD("$body") + DOMDIFF]() {
    const current = this.$context.selection.current;
    if (!current)
      return "";
    if (current.isLayout(Layout.GRID) === false)
      return "";
    return `
            <div class="grid-layout-item">
            ${createComponent("NumberInputEditor", {
      wide: true,
      label: "grid padding",
      key: "padding",
      ref: "$padding",
      value: current.paddingTop,
      min: 0,
      max: 300,
      step: 1,
      onchange: "changePadding"
    })}
            </div>
            <div class='grid-layout-item'>
                ${createComponent("GridGapEditor", {
      label: this.$i18n("grid.layout.editor.column.gap"),
      ref: "$columnGap",
      key: "gridColumnGap",
      value: current.gridColumnGap || "",
      onchange: "changeKeyValue"
    })}
            </div>              
            <div class='grid-layout-item'>
                ${createComponent("GridGapEditor", {
      label: this.$i18n("grid.layout.editor.row.gap"),
      ref: "$rowGap",
      key: "gridRowGap",
      value: current.gridRowGap || "",
      onchange: "changeKeyValue"
    })}
            </div>
        `;
  }
  [SUBSCRIBE_SELF("changePadding")](key, value) {
    this.modifyData(key, {
      paddingTop: value,
      paddingLeft: value,
      paddingRight: value,
      paddingBottom: value
    });
  }
  [SUBSCRIBE_SELF("changeKeyValue")](key, value, params) {
    this.modifyData(key, value, params);
  }
}
var LayoutProperty$1 = "";
class LayoutProperty extends BaseProperty {
  getTitle() {
    return this.$i18n("layout.property.title");
  }
  getClassName() {
    return "elf--layout-property";
  }
  getBody() {
    return `
        <div ref='$layoutProperty'></div>
      `;
  }
  getTools() {
    return `
      <div ref='$layoutType'></div>
    `;
  }
  [LOAD("$layoutType")]() {
    const current = this.$context.selection.current;
    if (!current)
      return "";
    return createComponent("SelectIconEditor", {
      ref: "$layout",
      key: "layout",
      height: 24,
      value: current.layout,
      options: [Layout.DEFAULT, Layout.FLEX, Layout.GRID],
      icons: ["layout_default", "layout_flex", "layout_grid"],
      onchange: "changeLayoutType"
    });
  }
  [LOAD("$layoutProperty") + DOMDIFF]() {
    var current = this.$context.selection.current || { layout: "default" };
    return `
      <div class='layout-list' ref='$layoutList'>
        <div data-value='default' class='${current.layout === "default" ? "selected" : ""}'></div>
        <div data-value='flex' class='${current.layout === "flex" ? "selected" : ""}'>
          ${createComponent("FlexLayoutEditor", {
      ref: "$flex",
      key: "flex-layout",
      value: {
        flexDirection: current.flexDirection,
        flexWrap: current.flexWrap,
        justifyContent: current.justifyContent,
        alignItems: current.alignItems,
        alignContent: current.alignContent,
        gap: current.gap
      },
      onchange: "changeLayoutInfo"
    })}
        </div>
        <div data-value='grid' class='${current.layout === "grid" ? "selected" : ""}'>
          ${createComponent("GridLayoutEditor", {
      ref: "$grid",
      key: "grid-layout",
      value: current["grid-layout"] || "",
      onchange: "changeLayoutInfo"
    })}
        </div>
      </div>
    `;
  }
  [SUBSCRIBE_SELF("changeLayoutInfo")](key, value) {
    if (key === "padding") {
      this.$commands.executeCommand("setAttribute", "change padding", this.$context.selection.packByValue(value));
    } else {
      this.$commands.executeCommand("setAttribute", "change layout info", this.$context.selection.packByValue({
        [key]: value
      }));
    }
    this.nextTick(() => {
      this.emit("refreshAllElementBoundSize");
    });
  }
  [SUBSCRIBE_SELF("changeLayoutType")](key, value) {
    this.$context.selection.reset(this.$context.selection.packByValue({
      [key]: value
    }));
    this.updateTitle();
    this.$commands.executeCommand("setAttribute", "change layout type", this.$context.selection.packByValue({
      [key]: value
    }));
    this.nextTick(() => {
      this.refresh();
    });
  }
  get editableProperty() {
    return "layout";
  }
  enableHasChildren() {
    return this.$context.selection.current.enableHasChildren();
  }
  updateTitle() {
    this.setTitle(this.$context.selection.current.layout + " Layout");
  }
  [SUBSCRIBE(REFRESH_SELECTION) + IF("checkShow") + IF("enableHasChildren")]() {
    this.updateTitle();
    this.refresh();
  }
}
var ResizingItemProperty$1 = "";
class ResizingItemProperty extends BaseProperty {
  getTitle() {
    return this.$i18n("layout.property.resizing.self.title");
  }
  getClassName() {
    return "elf--resizing-item-property";
  }
  getBody() {
    return `
        <div ref='$body'>
          <div class="resizing-mode">
            <div class="resizing-box" ref="$resizingModeInfo"></div>
            <div ref="$resizingModeInfoInput"></div>
          </div>
        </div>
      `;
  }
  [LOAD("$resizingModeInfo") + DOMDIFF]() {
    var current = this.$context.selection.current || {};
    const h = current.resizingHorizontal || ResizingMode.FIXED;
    const v = current.resizingVertical || ResizingMode.FIXED;
    return `
      <div class="resizing-mode-box" data-horizontal="${h}" data-vertical="${v}">
        <div class="rect">
          <div class="tool">
            <div class="vertical">
              <div class="vertical-top" data-key="resizingVertical">${iconUse("keyboard_arrow_up")}</div>
              <div class="vertical-bottom" data-key="resizingVertical">${iconUse("keyboard_arrow_down")}</div>
            </div>
            <div class="horizontal">
              <div class="horizontal-left" data-key="resizingHorizontal">${iconUse("keyboard_arrow_left")}</div>
              <div class="horizontal-right" data-key="resizingHorizontal">${iconUse("keyboard_arrow_right")}</div>
            </div>
          </div>         
          <div class="inner-rect"></div>
        </div>

      </div>
    `;
  }
  makeOptionsForHorizontal() {
    const options2 = [
      { value: ResizingMode.FIXED, text: "Fixed Width" },
      { value: ResizingMode.FILL_CONTAINER, text: "Fill Container" }
    ];
    return options2;
  }
  makeOptionsForVertical() {
    const options2 = [
      { value: ResizingMode.FIXED, text: "Fixed Height" },
      { value: ResizingMode.FILL_CONTAINER, text: "Fill Container" }
    ];
    return options2;
  }
  [LOAD("$resizingModeInfoInput") + DOMDIFF]() {
    var current = this.$context.selection.current || {};
    this.setState({
      resizingHorizontal: (current == null ? void 0 : current.resizingHorizontal) || ResizingMode.FIXED,
      resizingVertical: (current == null ? void 0 : current.resizingVertical) || ResizingMode.FIXED
    }, false);
    return `
      <div class="has-label-grid">
        <label data-direction="horizontal"></label>
        ${createComponent("SelectEditor", {
      ref: "$resizingHorizontal",
      key: "resizingHorizontal",
      value: this.state.resizingHorizontal,
      options: this.makeOptionsForHorizontal(),
      onchange: "changeResizingMode"
    })}
      </div>

      <div class="has-label-grid">
      <label data-direction="vertical"></label>
        ${createComponent("SelectEditor", {
      ref: "$resizingVertical",
      key: "resizingVertical",
      value: this.state.resizingVertical,
      options: this.makeOptionsForVertical(),
      onchange: "changeResizingMode"
    })}
      </div>
    `;
  }
  [CLICK("$resizingModeInfo [data-key]")](e) {
    const key = e.$dt.data("key");
    const current = this.$context.selection.current;
    if (current[key] === ResizingMode.FIXED) {
      this.trigger("changeResizingMode", key, ResizingMode.FILL_CONTAINER);
    } else {
      this.trigger("changeResizingMode", key, ResizingMode.FIXED);
    }
  }
  [SUBSCRIBE_SELF("changeResizingMode")](key, value) {
    this.$commands.executeCommand("setAttribute", "apply self resizing", this.$context.selection.packByValue({
      [key]: value,
      flexGrow: 1
    }));
    this.nextTick(() => {
      this.refresh();
    }, 100);
  }
  [SUBSCRIBE(REFRESH_SELECTION) + DEBOUNCE(100)]() {
    this.refreshShow(() => {
      var _a, _b;
      var current = this.$context.selection.current;
      return ((_a = current == null ? void 0 : current.parent) == null ? void 0 : _a.hasLayout()) && ((_b = current == null ? void 0 : current.parent) == null ? void 0 : _b.isLayout(Layout.GRID)) === false;
    });
  }
  [SUBSCRIBE(UPDATE_CANVAS)]() {
    const current = this.$context.selection.current;
    if (current && current.changedLayoutItem) {
      if (current.resizingHorizontal !== this.state.resizingHorizontal || current.resizingVertical !== this.state.resizingVertical) {
        this.refresh();
      }
    }
  }
}
var ResizingProperty$1 = "";
class ResizingProperty extends BaseProperty {
  getTitle() {
    return this.$i18n("layout.property.resizing.title");
  }
  getClassName() {
    return "elf--resizing-property";
  }
  getBody() {
    return `
        <div ref='$body'>
          <div class="resizing-mode">
            <div class="resizing-box" ref="$resizingModeInfo"></div>
            <div ref="$resizingModeInfoInput"></div>
          </div>
        </div>
      `;
  }
  [LOAD("$resizingModeInfo") + DOMDIFF]() {
    var current = this.$context.selection.current || {};
    const h = current.resizingHorizontal || ResizingMode.FIXED;
    const v = current.resizingVertical || ResizingMode.FIXED;
    return `
      <div class="resizing-mode-box" data-horizontal="${h}" data-vertical="${v}">
        <div class="rect">
          <div class="vertical" data-key="resizingVertical">
            <div class="vertical-top">${iconUse("keyboard_arrow_down")}</div>
            <div class="vertical-bottom">${iconUse("keyboard_arrow_up")}</div>
          </div>
          <div class="horizontal" data-key="resizingHorizontal">
            <div class="horizontal-left">${iconUse("keyboard_arrow_right")}</div>
            <div class="horizontal-right">${iconUse("keyboard_arrow_left")}</div>
          </div>
          <div class="inner-rect"></div>
          <div class="inner-horizontal-rect"></div>
          <div class="inner-vertical-rect"></div>
        </div>
      </div>
    `;
  }
  makeOptionsForHorizontal() {
    const options2 = [
      { value: ResizingMode.FIXED, text: "Fixed Width" },
      { value: ResizingMode.HUG_CONTENT, text: "Hug Content" }
    ];
    return options2;
  }
  makeOptionsForVertical() {
    const options2 = [
      { value: ResizingMode.FIXED, text: "Fixed Height" },
      { value: ResizingMode.HUG_CONTENT, text: "Hug Content" }
    ];
    return options2;
  }
  [LOAD("$resizingModeInfoInput")]() {
    var current = this.$context.selection.current || {};
    return `
      <div class="has-label-grid">
        <label data-direction="horizontal"></label>
        ${createComponent("SelectEditor", {
      ref: "$resizingHorizontal",
      key: "resizingHorizontal",
      value: (current == null ? void 0 : current.resizingHorizontal) || ResizingMode.FIXED,
      options: this.makeOptionsForHorizontal(),
      onchange: "changeResizingMode"
    })}
      </div>

      <div class="has-label-grid">
      <label data-direction="vertical"></label>
        ${createComponent("SelectEditor", {
      ref: "$resizingVertical",
      key: "resizingVertical",
      value: (current == null ? void 0 : current.resizingVertical) || ResizingMode.FIXED,
      options: this.makeOptionsForVertical(),
      onchange: "changeResizingMode"
    })}
      </div>
    `;
  }
  [CLICK("$resizingModeInfo [data-key]")](e) {
    const key = e.$dt.data("key");
    const current = this.$context.selection.current;
    if (current[key] === ResizingMode.FIXED) {
      this.trigger("changeResizingMode", key, ResizingMode.HUG_CONTENT);
    } else {
      this.trigger("changeResizingMode", key, ResizingMode.FIXED);
    }
  }
  [SUBSCRIBE_SELF("changeResizingMode")](key, value) {
    this.$commands.executeCommand("setAttribute", "apply constraints", this.$context.selection.packByValue({
      [key]: value
    }));
    this.nextTick(() => {
      this.refresh();
    }, 100);
  }
  [SUBSCRIBE(REFRESH_SELECTION) + DEBOUNCE(100)]() {
    this.refreshShow(() => {
      var current = this.$context.selection.current;
      return current && current.hasLayout();
    });
  }
}
function layout(editor) {
  editor.registerElement({
    FlexLayoutEditor,
    GridLayoutEditor,
    GridBoxEditor,
    GridGapEditor
  });
  editor.registerUI("inspector.tab.style", {
    LayoutProperty,
    ResizingProperty,
    ResizingItemProperty,
    DefaultLayoutItemProperty
  });
  editor.registerUI("canvas.view", {
    FlexGrowToolView,
    GridGrowToolView
  }, CanvasViewToolLevel.LAYOUT_TOOL);
}
var LineView$1 = "";
class LineView extends EditorElement {
  template() {
    return /* @__PURE__ */ createElementJsx("div", {
      class: "elf--line-view sepia(0.2)"
    });
  }
  [CONFIG("vertical.line")]() {
    this.refresh();
  }
  [CONFIG("horizontal.line")]() {
    this.refresh();
  }
  [SUBSCRIBE(UPDATE_VIEWPORT, UPDATE_CANVAS)]() {
    this.refresh();
  }
  [LOAD("$el") + DOMDIFF]() {
    return [
      ...this.$config.get("vertical.line").map((it, index2) => {
        const screen2 = this.$viewport.applyVertex([0, it, 0]);
        return /* @__PURE__ */ createElementJsx("div", {
          class: "vertical-line",
          "data-index": index2,
          style: `transform: translate3d(0px, ${screen2[1]}px, 0px);`
        });
      }),
      ...this.$config.get("horizontal.line").map((it, index2) => {
        const screen2 = this.$viewport.applyVertex([it, 0, 0]);
        return /* @__PURE__ */ createElementJsx("div", {
          class: "horizontal-line",
          "data-index": index2,
          style: `transform: translate3d(${screen2[0]}px, 0px, 0px);`
        });
      })
    ];
  }
  [POINTERSTART("$el .horizontal-line") + MOVE("moveHorizontalLine") + END("moveEndHorizontalLine")](e) {
    this.startIndex = +e.$dt.data("index");
    this.$context.snapManager.clear();
  }
  moveHorizontalLine() {
    const newPos = this.$context.snapManager.getWorldPosition();
    this.$config.setIndexValue("horizontal.line", this.startIndex, newPos[0]);
  }
  moveEndHorizontalLine() {
    this.$commands.emit("recoverCursor");
  }
  [POINTERSTART("$el .vertical-line") + MOVE("moveVerticalLine") + END("moveEndVerticalLine")](e) {
    this.startIndex = +e.$dt.data("index");
    this.$context.snapManager.clear();
  }
  moveVerticalLine() {
    const newPos = this.$context.snapManager.getWorldPosition();
    this.$config.setIndexValue("vertical.line", this.startIndex, newPos[1]);
  }
  moveEndVerticalLine() {
    this.$commands.emit("recoverCursor");
  }
}
function lineView(editor) {
  editor.registerUI("canvas.view", {
    LineView
  });
}
function menus(editor) {
  editor.registerMenu("toolbar.logo", [
    {
      type: "dropdown",
      style: {
        padding: "12px 0px 12px 12px"
      },
      icon: `<div class="logo-item"><label class='logo'></label></div>`,
      items: [
        {
          title: "menu.item.fullscreen.title",
          command: "toggle.fullscreen",
          shortcut: "ALT+/"
        },
        {
          title: "menu.item.shortcuts.title",
          command: "showShortcutWindow"
        },
        "-",
        { title: "menu.item.export.title", command: "showExportView" },
        {
          title: "menu.item.export.title",
          command: "showEmbedEditorWindow"
        },
        { title: "menu.item.download.title", command: "downloadJSON" },
        {
          title: "menu.item.save.title",
          command: "saveJSON",
          nextTick: () => {
            this.emit("notify", "alert", "Save", "Save the content on localStorage", 2e3);
          }
        },
        {
          title: "menu.item.language.title",
          items: [
            {
              title: "English",
              command: "setLocale",
              args: [Language.EN],
              checked: (editor2) => editor2.locale === Language.EN
            },
            {
              title: "Fran\xE7ais",
              command: "setLocale",
              args: [Language.FR],
              checked: (editor2) => editor2.locale === Language.FR
            },
            {
              title: "Korean",
              command: "setLocale",
              args: [Language.KO],
              checked: (editor2) => editor2.locale === Language.KO
            }
          ]
        },
        "-",
        {
          title: "elf document",
          items: [
            {
              type: "link",
              title: "Github",
              href: "https://github.com/easylogic/editor"
            },
            {
              type: "link",
              title: "Learn",
              href: "https://www.easylogic.studio"
            }
          ]
        }
      ]
    }
  ]);
  editor.registerMenu("toolbar.left", [
    {
      type: "button",
      icon: "navigation",
      events: ["config:editing.mode"],
      selected: (editor2) => {
        return editor2.context.config.is("editing.mode", EditingMode.SELECT);
      },
      action: (editor2) => {
        editor2.context.commands.emit("addLayerView", "select");
        editor2.context.config.is("editing.mode.itemType", EditingMode.SELECT);
      }
    },
    {
      type: "button",
      icon: "artboard",
      events: ["config:editing.mode", "config:editing.mode.itemType"],
      selected: (editor2) => {
        return editor2.context.config.is("editing.mode", EditingMode.APPEND) && editor2.context.config.is("editing.mode.itemType", "artboard");
      },
      action: (editor2) => {
        editor2.context.commands.emit("addLayerView", "artboard");
      }
    },
    {
      type: "dropdown",
      icon: (editor2, dropdown) => {
        var _a;
        return ((_a = dropdown.findItem(editor2.context.config.get("editing.css.itemType"))) == null ? void 0 : _a.icon) || iconUse("rect");
      },
      items: [
        {
          icon: iconUse("rect"),
          title: "Rect Layer",
          key: "rect",
          command: "addLayerView",
          args: [
            "rect",
            {
              backgroundColor: "#ececec"
            }
          ],
          closable: true,
          nextTick: (editor2) => {
            editor2.context.config.set("editing.css.itemType", "rect");
          },
          shortcut: KeyStringMaker({ key: "R" })
        },
        {
          icon: iconUse("lens"),
          title: "Circle Layer",
          key: "circle",
          command: "addLayerView",
          args: ["circle"],
          closable: true,
          nextTick: (editor2) => {
            editor2.context.config.set("editing.css.itemType", "circle");
          },
          shortcut: KeyStringMaker({ key: "O" })
        },
        {
          icon: iconUse("image"),
          title: "Image",
          key: "image",
          command: "addLayerView",
          args: ["image"],
          closable: true,
          nextTick: (editor2) => {
            editor2.context.config.set("editing.css.itemType", "image");
          },
          shortcut: KeyStringMaker({ key: "I" })
        },
        "-",
        {
          icon: iconUse("video"),
          title: "Video",
          key: "video",
          command: "addLayerView",
          args: ["video"],
          closable: true,
          nextTick: (editor2) => {
            editor2.context.config.set("editing.css.itemType", "video");
          },
          shortcut: KeyStringMaker({ key: "V" })
        },
        {
          icon: iconUse("iframe"),
          title: "IFrame",
          key: "iframe",
          command: "addLayerView",
          args: ["iframe"],
          closable: true,
          nextTick: (editor2) => {
            editor2.context.config.set("editing.css.itemType", "iframe");
          },
          shortcut: KeyStringMaker({ key: "F" })
        },
        {
          icon: iconUse("rect"),
          title: "SampleLayer",
          key: "sample",
          command: "addLayerView",
          args: ["sample"],
          closable: true,
          nextTick: (editor2) => {
            editor2.context.config.set("editing.css.itemType", "sample");
          }
        }
      ],
      events: [
        "config:editing.mode",
        "config:editing.mode.itemType",
        "config:editing.css.itemType"
      ],
      selected: (editor2) => {
        return editor2.context.config.is("editing.mode", EditingMode.APPEND) && (editor2.context.config.is("editing.mode.itemType", "rect") || editor2.context.config.is("editing.mode.itemType", "circle") || editor2.context.config.is("editing.mode.itemType", "image") || editor2.context.config.is("editing.mode.itemType", "video") || editor2.context.config.is("editing.mode.itemType", "iframe"));
      },
      selectedKey: (editor2) => {
        return editor2.context.config.get("editing.css.itemType");
      }
    },
    {
      type: "dropdown",
      icon: (editor2, dropdown) => {
        var _a;
        return ((_a = dropdown.findItem(editor2.context.config.get("editing.draw.itemType"))) == null ? void 0 : _a.icon) || iconUse("pentool");
      },
      items: [
        {
          icon: iconUse("pentool"),
          title: "Pen",
          key: "path",
          command: "addLayerView",
          args: ["path"],
          closable: true,
          nextTick: (editor2) => {
            editor2.context.config.set("editing.draw.itemType", "path");
          },
          shortcut: KeyStringMaker({ key: "P" })
        },
        {
          icon: iconUse("brush"),
          title: "Pencil",
          key: "brush",
          command: "addLayerView",
          args: ["brush"],
          closable: true,
          nextTick: (editor2) => {
            editor2.context.config.set("editing.draw.itemType", "brush");
          },
          shortcut: KeyStringMaker({ key: "B" })
        }
      ],
      events: [
        "config:editing.mode",
        "config:editing.mode.itemType",
        "config:editing.draw.itemType"
      ],
      selected: (editor2) => {
        return editor2.context.config.is("editing.mode.itemType", "path") || editor2.context.config.is("editing.mode.itemType", "draw");
      },
      selectedKey: (editor2) => {
        return editor2.context.config.get("editing.draw.itemType");
      }
    },
    {
      type: "dropdown",
      icon: (editor2, dropdown) => {
        var _a;
        return ((_a = dropdown.findItem(editor2.context.config.get("editing.svg.itemType"))) == null ? void 0 : _a.icon) || iconUse("outline_rect");
      },
      items: [
        {
          icon: iconUse("outline_rect"),
          title: "Rectangle",
          key: "svg-rect",
          command: "addLayerView",
          args: ["svg-rect"],
          closable: true,
          nextTick: (editor2) => {
            editor2.context.config.set("editing.svg.itemType", "svg-rect");
          },
          shortcut: KeyStringMaker({ key: "Shift+R" })
        },
        {
          icon: iconUse("outline_circle"),
          title: "Circle",
          key: "svg-circle",
          command: "addLayerView",
          args: ["svg-circle"],
          closable: true,
          nextTick: (editor2) => {
            editor2.context.config.set("editing.svg.itemType", "svg-circle");
          },
          shortcut: KeyStringMaker({ key: "Shift+O" })
        },
        {
          icon: iconUse("polygon"),
          title: "Polygon",
          key: "svg-polygon",
          command: "addLayerView",
          args: [
            "polygon",
            {
              backgroundColor: "transparent"
            }
          ],
          closable: true,
          nextTick: (editor2) => {
            editor2.context.config.set("editing.svg.itemType", "polygon");
          },
          shortcut: KeyStringMaker({ key: "Shift+P" })
        },
        {
          icon: iconUse("star"),
          title: "Star",
          key: "star",
          command: "addLayerView",
          args: [
            "star",
            {
              backgroundColor: "transparent"
            }
          ],
          closable: true,
          nextTick: (editor2) => {
            editor2.context.config.set("editing.svg.itemType", "star");
          },
          shortcut: KeyStringMaker({ key: "Shift+S" })
        },
        "-",
        {
          icon: iconUse("smooth"),
          title: "Spline",
          key: "spline",
          command: "addLayerView",
          args: [
            "spline",
            {
              backgroundColor: "transparent"
            }
          ],
          closable: true,
          nextTick: (editor2) => {
            editor2.context.config.set("editing.svg.itemType", "spline");
          },
          shortcut: KeyStringMaker({ key: "Shift+L" })
        },
        {
          icon: iconUse("text_rotate"),
          title: "TextPath",
          key: "svg-texpath",
          command: "addLayerView",
          args: [
            "svg-textpath",
            {
              backgroundColor: "transparent"
            }
          ],
          closable: true,
          nextTick: (editor2) => {
            editor2.context.config.set("editing.svg.itemType", "svg-textpath");
          },
          shortcut: KeyStringMaker({ key: "Shift+T" })
        }
      ],
      events: [
        "config:editing.mode",
        "config:editing.mode.itemType",
        "config:editing.svg.itemType"
      ],
      selected: (editor2) => {
        return editor2.context.config.is("editing.mode", EditingMode.APPEND) && (editor2.context.config.is("editing.mode.itemType", "svg-rect") || editor2.context.config.is("editing.mode.itemType", "svg-circle") || editor2.context.config.is("editing.mode.itemType", "polygon") || editor2.context.config.is("editing.mode.itemType", "star") || editor2.context.config.is("editing.mode.itemType", "spline") || editor2.context.config.is("editing.mode.itemType", "svg-textpath"));
      },
      selectedKey: (editor2) => {
        return editor2.context.config.get("editing.svg.itemType");
      }
    },
    {
      type: "button",
      icon: "title",
      events: ["config:editing.mode", "config:editing.mode.itemType"],
      selected: (editor2) => {
        return editor2.context.config.is("editing.mode", EditingMode.APPEND) && editor2.context.config.is("editing.mode.itemType", "text");
      },
      action: (editor2) => {
        editor2.context.commands.emit("addLayerView", "text");
      }
    },
    {
      type: "button",
      tooltip: "Handle",
      icon: "pantool",
      events: ["config:editing.mode"],
      selected: (editor2) => {
        return editor2.context.config.is("editing.mode", EditingMode.HAND);
      },
      action: (editor2) => {
        editor2.context.commands.emit("toggleHandTool");
      }
    }
  ]);
  editor.registerMenu("toolbar.right", [
    {
      type: "button",
      icon: (editor2) => {
        if (editor2.context.config.is("editor.theme", "dark")) {
          return "dark";
        } else {
          return "light";
        }
      },
      events: ["config:editor.theme"],
      action: (editor2) => {
        editor2.context.config.toggleWith("editor.theme", "light", "dark");
      }
    }
  ]);
}
var DrawManager$1 = "";
class DrawManager extends EditorElement {
  initState() {
    return {
      tolerance: 1,
      stroke: "black",
      "stroke-width": 2,
      "stroke-linecap": "round",
      "stroke-linejoin": "round",
      msg: this.$i18n("path.manager.msg")
    };
  }
  [SUBSCRIBE(REFRESH_SELECTION)]() {
    var _a, _b;
    var current = this.$context.selection.current;
    if (current) {
      (_a = this.children.$stroke) == null ? void 0 : _a.setValue(current.stroke || "rgba(0, 0, 0, 1)");
      (_b = this.children.$strokeWidth) == null ? void 0 : _b.setValue(current.strokeWidth || Length.number(1));
    }
  }
  [SUBSCRIBE("setColorAsset")]({ color: color2 }) {
    if (this.$el.isShow()) {
      this.setState({
        stroke: color2
      }, false);
      this.children.$stroke.setValue(color2);
      this.updateData({
        stroke: color2
      });
    }
  }
  template() {
    return `
      <div class='elf--draw-manager'>
        <div class="tools left" ref="$left">
            <button type="button" class="primary" data-value='DrawEditorDone' title='${this.$i18n("draw.manager.mode.modify")}' >Done</button>
        </div>      
        <div class='tools'>   
          <div >        
            <label data-tooltip="${this.$i18n("draw.manager.tolerance")}">Tolerance</label>       
            ${createComponent("NumberInputEditor", {
      ref: "$tolerance",
      key: "tolerance",
      value: 1,
      min: 0,
      max: 100,
      step: 0.01,
      unit: "number",
      onchange: "changeValue"
    })}
          </div>              
          <div >
            <label>${this.$i18n("svg.item.property.stroke")}</label>          
            ${createComponent("FillSingleEditor", {
      ref: "$stroke",
      simple: true,
      value: this.state.stroke,
      key: "stroke",
      onchange: "changeValue"
    })}
          </div>

          <div >
            <label>${this.$i18n("svg.item.property.strokeWidth")}</label>          
            ${createComponent("NumberInputEditor", {
      ref: "$strokeWidth",
      key: "strokeWidth",
      value: this.state["strokeWidth"],
      onchange: "changeValue"
    })}
          </div>      
          

          <div>
            <label data-tooltip="${this.$i18n("svg.item.property.lineCap")}">Cap</label>          
            ${createComponent("SelectEditor", {
      ref: "$strokeLineCap",
      key: "strokeLinecap",
      value: this.state["strokeLinecap"],
      options: ["butt", "round", "square"],
      onchange: "changeValue"
    })}
          </div> 
          <div>
            <label data-tooltip="${this.$i18n("svg.item.property.lineJoin")}">Join</label>          
            ${createComponent("SelectEditor", {
      ref: "$strokeLineJoin",
      key: "strokeLinejoin",
      value: this.state["strokeLinejoin"],
      options: ["miter", "bevel", "round"],
      onchange: "changeValue"
    })}
          </div>
        </div>
      </div>    
    `;
  }
  [SUBSCRIBE_SELF("changeValue")](key, value) {
    this.updateData({
      [key]: value
    });
  }
  updateData(obj2 = {}) {
    this.setState(obj2, false);
    this.state.instance.trigger(this.state.changeEvent, obj2);
  }
  [SUBSCRIBE("changePathManager")](mode) {
    this.setState({ mode });
  }
  [SUBSCRIBE("showDrawManager")](obj2 = {}) {
    obj2.changeEvent = obj2.changeEvent || "changeDrawManager";
    this.setState(obj2);
    this.$el.show();
    this.emit("hidePathManager");
  }
  [SUBSCRIBE("hideDrawManager")]() {
    this.$el.hide();
  }
  [CLICK("$left button")](e) {
    var message = e.$dt.attr("data-value");
    this.emit(message);
  }
}
var PathDrawView$1 = "";
const FIELDS$1 = [
  "fill",
  "fill-opacity",
  "stroke",
  "stroke-width",
  "stroke-linecap",
  "stroke-linejoin"
];
class PathDrawView extends EditorElement {
  initialize() {
    super.initialize();
    this.pathParser = new PathParser();
  }
  initState() {
    return {
      points: [],
      $target: null,
      fill: "transparent",
      stroke: "black",
      "fill-opacity": null,
      "stroke-width": 2,
      "stroke-linecap": "round",
      "stroke-linejoin": "round",
      tolerance: 1
    };
  }
  [SUBSCRIBE("changeDrawManager")](obj2) {
    this.setState(__spreadValues({}, obj2), false);
  }
  get scale() {
    return this.$viewport.scale;
  }
  template() {
    return `
        <div class='elf--path-draw-view' tabIndex="-1">
            <div class='path-draw-container' ref='$view'></div>
        </div>`;
  }
  initRect(isForce = false) {
    if (!this.state.rect || isForce) {
      this.state.rect = this.$el.rect();
    }
  }
  [KEYUP("document") + IF("isShow") + ESCAPE + ENTER]() {
    this.trigger("hidePathDrawEditor");
  }
  [SUBSCRIBE("DrawEditorDone")]() {
    this.trigger("hidePathDrawEditor");
  }
  get totalPathLength() {
    if (!this.refs.$view)
      return 0;
    var $obj = this.refs.$view.$("path.object");
    if (!$obj)
      return 0;
    return $obj.totalLength;
  }
  makePathLayer() {
    var layer;
    const newPath = PathParser.makePathByPoints(this.state.points).simplify(this.state.tolerance).smooth(30);
    newPath.transformMat4(this.$viewport.matrixInverse);
    const bbox = newPath.getBBox();
    const newWidth = distance$1(bbox[1], bbox[0]);
    const newHeight = distance$1(bbox[3], bbox[0]);
    newPath.translate(-bbox[0][0], -bbox[0][1]);
    const pathItem = {
      itemType: "svg-path",
      x: bbox[0][0],
      y: bbox[0][1],
      width: newWidth,
      height: newHeight,
      d: newPath.d,
      totalLength: this.totalPathLength
    };
    FIELDS$1.forEach((key) => {
      if (this.state[key])
        Object.assign(pathItem, { [key]: this.state[key] });
    });
    const containerItem = this.$context.selection.currentProject;
    layer = containerItem.appendChild(this.$editor.createModel(pathItem));
    return layer;
  }
  addPathLayer() {
    var pathRect = this.getPathRect();
    if (pathRect.width !== 0 && pathRect.height !== 0) {
      var layer = this.makePathLayer(pathRect);
      if (layer) {
        this.emit("refreshAll");
      }
    }
  }
  changeMode(obj2) {
    this.setState(__spreadValues(__spreadValues({}, this.initState()), obj2), false);
  }
  getCurrentObject() {
    var current = this.state.current;
    if (!current) {
      return null;
    }
    return {
      current,
      d: current.d
    };
  }
  [SUBSCRIBE("showPathDrawEditor")](obj2 = {}) {
    this.changeMode(obj2);
    this.$el.show();
    this.$el.focus();
    this.emit("showDrawManager", {
      instance: this,
      fill: this.state.fill,
      stroke: this.state.stroke,
      "fill-opacity": this.state["fill-opacity"],
      "stroke-width": this.state["stroke-width"],
      "stroke-linecap": this.state["stroke-linecap"],
      "stroke-linejoin": this.state["stroke-linejoin"]
    });
    this.emit("hidePathEditor");
    this.$context.commands.emit("push.mode.view", "PathDrawView");
  }
  [SUBSCRIBE("initPathDrawEditor")]() {
    this.pathParser.reset("");
    this.refs.$view.empty();
  }
  [SUBSCRIBE("hidePathDrawEditor")]() {
    if (this.$el.isShow()) {
      this.trigger("initPathDrawEditor");
      this.$el.hide();
      this.emit("hideDrawManager");
      this.$commands.emit("pop.mode.view", "PathDrawView");
    }
  }
  [SUBSCRIBE("hideAddViewLayer")]() {
    this.$el.hide();
    this.emit("hideDrawManager");
  }
  getInnerId(postfix = "") {
    return "draw-manager-" + postfix;
  }
  get toFillSVG() {
    return SVGFill.parseImage(this.state.fill || "transparent").toSVGString(this.fillId);
  }
  get toStrokeSVG() {
    return SVGFill.parseImage(this.state.stroke || "black").toSVGString(this.strokeId);
  }
  get toDefInnerString() {
    return `
            ${this.toFillSVG}
            ${this.toStrokeSVG}
        `;
  }
  get toDefString() {
    var str = this.toDefInnerString.trim();
    return `
            <defs>
            ${str}
            </defs>
        `;
  }
  get fillId() {
    return this.getInnerId("fill");
  }
  get strokeId() {
    return this.getInnerId("stroke");
  }
  get toFillValue() {
    return SVGFill.parseImage(this.state.fill || "transparent").toFillValue(this.fillId);
  }
  get toStrokeValue() {
    return SVGFill.parseImage(this.state.stroke || "black").toFillValue(this.strokeId);
  }
  [BIND("$view")]() {
    const newPath = PathParser.makePathByPoints(this.state.points).simplify(this.state.tolerance);
    return {
      innerHTML: `
            <svg width="100%" height="100%" class='svg-editor-canvas'>
                ${this.toDefString}
                <path 
                    class='object' 
                    fill="${this.toFillValue}"
                    stroke="${this.toStrokeValue}"
                    fill-opacity="${this.state["fill-opacity"]}"
                    stroke-width="${this.state["stroke-width"]}"
                    stroke-linecap="${this.state["stroke-linecap"]}"
                    stroke-linejoin="${this.state["stroke-linejoin"]}"
                    d="${newPath.d}" 
                />
            </svg>
            `
    };
  }
  renderPath() {
    this.bindData("$view");
  }
  [SUBSCRIBE("resizeEditor")]() {
    this.initRect(true);
  }
  getPathRect() {
    this.initRect(true);
    var $obj = this.refs.$view.$("path.object");
    var pathRect = { x: 0, y: 0, width: 0, height: 0 };
    if ($obj) {
      pathRect = $obj.rect();
      pathRect.x -= this.state.rect.x;
      pathRect.y -= this.state.rect.y;
    }
    return pathRect;
  }
  [POINTERSTART("$view") + MOVE() + END()](e) {
    this.initRect();
    this.state.altKey = false;
    this.state.startXY = {
      x: e.xy.x - this.state.rect.x,
      y: e.xy.y - this.state.rect.y
    };
    this.state.points = [this.state.startXY];
  }
  move(dx, dy, eventType, pressure) {
    this.state.points.push({
      x: this.state.startXY.x + dx,
      y: this.state.startXY.y + dy,
      pressure
    });
    this.renderPath();
  }
  end() {
    this.addPathLayer();
    this.trigger("initPathDrawEditor");
  }
}
function pathDrawView(editor) {
  editor.registerUI("canvas.view", {
    PathDrawView
  });
  editor.registerUI("page.subeditor.view", {
    DrawManager
  });
}
var PathEditorView$1 = "";
const SEGMENT_DIRECTION = ["startPoint", "endPoint", "reversePoint"];
function calculateSnapPoint(points, sourceKey, target, distanceValue, dist2) {
  var checkedPointList = points.filter((p) => {
    if (!p)
      return false;
    return Math.abs(p[sourceKey] - target) <= dist2;
  }).map((p) => {
    return { dist: Math.abs(p[sourceKey] - target), point: p };
  });
  checkedPointList.sort((a, b) => {
    return a.dist < b.dist ? -1 : 1;
  });
  var point2 = null;
  if (checkedPointList.length) {
    point2 = checkedPointList[0].point;
    distanceValue += point2[sourceKey] - target;
  }
  return { point: point2, distanceValue };
}
function calculateMovePointSnap(points, moveXY, dist2 = 1) {
  var snapPointX = calculatePointDist(points, "x", moveXY.x, dist2);
  var snapPointY = calculatePointDist(points, "y", moveXY.y, dist2);
  var snapEndPoint = __spreadValues({}, moveXY);
  if (snapPointX) {
    snapEndPoint.x = snapPointX.x;
  }
  if (snapPointY) {
    snapEndPoint.y = snapPointY.y;
  }
  var snapPointList = [];
  if (snapPointX) {
    snapPointList.push({ startPoint: snapPointX, endPoint: snapEndPoint });
  }
  if (snapPointY) {
    snapPointList.push({ startPoint: snapPointY, endPoint: snapEndPoint });
  }
  return { snapPointList, moveXY: snapEndPoint };
}
function calculatePointDist(points, sourceKey, target, dist2) {
  var checkedPointList = [];
  var arr = SEGMENT_DIRECTION;
  points.filter((p) => p).forEach((p) => {
    arr.filter((key) => p[key]).forEach((key) => {
      var point2 = p[key];
      var tempDist = Math.abs(point2[sourceKey] - target);
      if (tempDist <= dist2) {
        checkedPointList.push({ dist: tempDist, point: point2 });
      }
    });
  });
  checkedPointList.sort((a, b) => {
    return a.dist > b.dist ? 1 : -1;
  });
  return checkedPointList.length ? checkedPointList[0].point : null;
}
function toPath(points, minX, minY, scale2 = 1) {
  var d = [];
  for (var index2 = 0, len2 = points.length; index2 < len2; index2++) {
    var currentIndex = index2;
    var current = points[currentIndex];
    if (!current)
      continue;
    if (current.command === "M") {
      d.push({ command: "M", values: [current.startPoint] });
    } else {
      var prevPoint = Point.getPrevPoint(points, index2);
      if (current.curve === false) {
        if (prevPoint.curve === false) {
          d.push({ command: "L", values: [current.startPoint] });
        } else {
          d.push({
            command: "Q",
            values: [prevPoint.endPoint, current.startPoint]
          });
        }
      } else {
        if (prevPoint.curve === false) {
          if (Point.isEqual(current.reversePoint, current.startPoint)) {
            d.push({ command: "L", values: [current.startPoint] });
          } else {
            d.push({
              command: "Q",
              values: [current.reversePoint, current.startPoint]
            });
          }
        } else {
          d.push({
            command: "C",
            values: [
              prevPoint.endPoint,
              current.reversePoint,
              current.startPoint
            ]
          });
        }
      }
    }
    if (current.close) {
      d.push({ command: "Z" });
    }
  }
  var dString = d.map((segment) => {
    return calculateRelativePosition(minX, minY, segment, scale2);
  }).join(" ");
  return {
    d: dString
  };
}
function calculateRelativePosition(minX, minY, segment, scale2 = 1) {
  var { command, values } = segment;
  switch (command) {
    case "Z":
      return "Z";
    default:
      var str = values.map((v) => {
        var tx = v.x - minX === 0 ? 0 : (v.x - minX) / scale2;
        var ty = v.y - minY === 0 ? 0 : (v.y - minY) / scale2;
        return `${tx} ${ty}`;
      }).join(" ");
      return `${command} ${str}`;
  }
}
function checkInArea(area2, point2) {
  if (area2.x2.value < point2.x) {
    return false;
  }
  if (area2.y2.value < point2.y) {
    return false;
  }
  if (area2.x.value > point2.x) {
    return false;
  }
  if (area2.y.value > point2.y) {
    return false;
  }
  return true;
}
class PathGenerator {
  static generatorPathString(points, minX = 0, minY = 0, scale2 = 1) {
    return toPath(points, minX, minY, scale2).d;
  }
  constructor(pathEditor) {
    this.pathEditor = pathEditor;
    this.pathStringManager = new PathStringManager();
    this.guideLineManager = new PathStringManager();
    this.segmentManager = new SegmentManager(this.pathEditor.$viewport);
    this.points = [];
    this.cachedSegmentKeys = {};
    this.initialize();
    this.initializeSelect();
  }
  initialize() {
    this.splitLines = [];
    this.guideLineManager.reset();
    this.segmentManager.reset();
    this.pathStringManager.reset();
  }
  initializeSelect(initPointList = []) {
    this.selectedPointKeys = {};
    this.selectedPointList = [];
    if (initPointList.length) {
      this.select(...initPointList.map((p) => {
        const checkedPoint = this.points[p.index][p.key];
        if (!checkedPoint)
          return void 0;
        return {
          x: checkedPoint.x,
          y: checkedPoint.y,
          key: p.key,
          index: checkedPoint.index
        };
      }).filter(Boolean));
    }
  }
  get state() {
    return this.pathEditor.state;
  }
  get clonePoints() {
    return [...this.points];
  }
  get length() {
    return this.points.length;
  }
  setPoints(points = []) {
    this.points = points;
    this.snapPointList = [];
    if (this.points.length === 0) {
      this.select();
      this.selectGroup(-1);
    }
  }
  selectInBox(box, isToggle = false) {
    var list2 = [];
    this.points.forEach((point2, index2) => {
      SEGMENT_DIRECTION.forEach((key) => {
        const p = point2[key];
        if (checkInArea(box, p)) {
          list2.push({ x: p.x, y: p.y, key, index: index2 });
        }
      });
    });
    if (isToggle) {
      list2 = list2.map((it) => {
        const selectedKey = this.makeSegmentKey(it);
        return __spreadProps(__spreadValues({}, it), {
          included: Boolean(this.selectedPointKeys[selectedKey])
        });
      });
      const includedList = list2.filter((it) => it.included);
      const notIncludedList = list2.filter((it) => !it.included);
      let uniqueList = [...this.selectedPointList];
      if (includedList.length) {
        uniqueList = this.selectedPointList.filter((it) => {
          const oldKey = this.makeSegmentKey(it);
          return Boolean(includedList.find((includeNode) => {
            return oldKey === this.makeSegmentKey(includeNode);
          })) === false;
        });
      }
      this.select(...uniqueList, ...notIncludedList);
    } else {
      this.select(...list2);
    }
  }
  makeSegmentKey(p) {
    return `${p.key}_${p.index}`;
  }
  select(...list2) {
    this.selectedPointKeys = {};
    this.selectedPointList = list2.map(({ x, y, key, index: index2 }) => ({
      x,
      y,
      key,
      index: +index2
    }));
    list2.forEach((it) => {
      var key = this.makeSegmentKey(it);
      this.selectedPointKeys[key] = true;
    });
  }
  convertPointsToSelectionList(points) {
    var list2 = [];
    points.forEach((point2) => {
      SEGMENT_DIRECTION.forEach((key) => {
        const { x, y } = point2[key];
        list2.push({ x, y, key, index: point2.index });
      });
    });
    return list2;
  }
  selectGroup(groupIndex) {
    const group2 = this.splitedGroupList[groupIndex];
    if (group2) {
      this.select(...this.convertPointsToSelectionList(group2.points));
    } else {
      this.select();
    }
  }
  getCacheSegmentKey(segmentKey, index2) {
    if (!this.cachedSegmentKeys[segmentKey]) {
      this.cachedSegmentKeys[segmentKey] = {};
    }
    if (!this.cachedSegmentKeys[segmentKey][index2]) {
      this.cachedSegmentKeys[segmentKey][index2] = this.makeSegmentKey({
        key: segmentKey,
        index: index2
      });
    }
    return this.cachedSegmentKeys[segmentKey][index2];
  }
  toggleSelect(key, index2) {
    if (this.points[index2]) {
      var point2 = this.points[index2][key];
      if (point2 && !this.isSelectedSegment(key, index2)) {
        this.select(...this.selectedPointList, {
          x: point2.x,
          y: point2.y,
          key,
          index: index2
        });
      } else {
        this.select(...this.selectedPointList.filter((it) => {
          return it.key !== key || it.index !== index2;
        }));
      }
    }
  }
  selectKeyIndex(key, index2) {
    if (this.points[index2]) {
      var point2 = this.points[index2][key];
      if (point2 && !this.isSelectedSegment(key, index2)) {
        this.select({ x: point2.x, y: point2.y, key, index: index2 });
      }
    }
  }
  reselect() {
    this.selectedPointList.filter(Boolean).forEach((it) => {
      var _a;
      var point2 = (_a = this.points[it.index]) == null ? void 0 : _a[it.key];
      if (point2) {
        it.x = point2.x;
        it.y = point2.y;
      }
    });
  }
  isSelectedSegment(segment, index2) {
    var key = this.getCacheSegmentKey(segment, index2);
    return this.selectedPointKeys[key];
  }
  commitTransformMatrix(point2, transformMatrix) {
    var result = transformMat4([], [point2.x, point2.y, 0], transformMatrix);
    return { x: result[0], y: result[1] };
  }
  transformMat4(transformMatrix) {
    this.transformPoints.forEach((p, index2) => {
      var realPoint = this.points[index2];
      Object.assign(realPoint.startPoint, this.commitTransformMatrix(p.startPoint, transformMatrix));
      Object.assign(realPoint.endPoint, this.commitTransformMatrix(p.endPoint, transformMatrix));
      Object.assign(realPoint.reversePoint, this.commitTransformMatrix(p.reversePoint, transformMatrix));
    });
  }
  transform(type) {
    var { x, y, width: width2, height: height2 } = this.transformRect;
    var view = create$4();
    translate(view, view, [x, y, 0]);
    switch (type) {
      case "flipX":
        scale$1(view, view, [-1, 1, 1]);
        translate(view, view, [-width2, 0, 0]);
        break;
      case "flipY":
        scale$1(view, view, [1, -1, 1]);
        translate(view, view, [0, -height2, 0]);
        break;
      case "flip":
        scale$1(view, view, [-1, -1, 1]);
        translate(view, view, [-width2, -height2, 0]);
        break;
    }
    translate(view, view, [-x, -y, 0]);
    this.transformMat4(view);
  }
  initTransform(rect2) {
    this.transformRect = clone$1(rect2);
    this.transformPoints = this.clonePoints.map((p) => {
      return {
        startPoint: clone$1(p.startPoint),
        endPoint: clone$1(p.endPoint),
        reversePoint: clone$1(p.reversePoint)
      };
    });
  }
  setConnectedPoint(dx, dy) {
    var state = this.state;
    var x = state.dragXY.x + dx;
    var y = state.dragXY.y + dy;
    var endPoint = { x, y };
    var reversePoint = { x, y };
    if (state.dragPoints) {
      state.reversePoint = Point.getReversePoint(state.startPoint, endPoint);
    }
    var point2 = {
      startPoint: state.startPoint,
      endPoint,
      curve: !!state.dragPoints,
      reversePoint,
      connected: true,
      close: true
    };
    this.points.push(point2);
  }
  setLastPoint(startPoint) {
    var endPoint = clone$1(startPoint);
    var reversePoint = clone$1(startPoint);
    var point2 = {
      startPoint,
      endPoint,
      curve: false,
      reversePoint,
      connected: false,
      close: false
    };
    this.points.push(point2);
  }
  getPrevPoint(index2) {
    return Point.getPrevPoint(this.points, index2);
  }
  getIndexPoint(index2) {
    return Point.getIndexPoint(this.points, index2);
  }
  getNextPoint(index2) {
    return Point.getNextPoint(this.points, index2);
  }
  getConnectedPointList(index2) {
    return Point.getConnectedPointList(this.points, index2);
  }
  isFirst(segment) {
    return Point.isFirst(segment);
  }
  getLastPoint(index2) {
    return Point.getLastPoint(this.points, index2);
  }
  setCachePoint(index2, segmentKey) {
    var state = this.state;
    this.snapPointList = [];
    this.selectedIndex = index2;
    state.connectedPoint = this.getPrevPoint(index2);
    state.connectedPointList = clone$1(Point.getConnectedPointList(this.points, this.selectedIndex));
    if (state.connectedPoint && !state.connectedPoint.connected) {
      state.connectedPoint = null;
    }
    state.segment = this.getIndexPoint(index2);
    if (state.segment.connected) {
      state.connectedPoint = this.getNextPoint(index2);
    }
    var isFirstSegment = this.isFirst(state.segment);
    if (isFirstSegment) {
      var lastPoint = this.getLastPoint(index2);
      if (lastPoint.connected) {
        state.connectedPoint = lastPoint;
      }
    }
    state.segmentKey = segmentKey;
    state.isCurveSegment = state.segment.curve && state.segmentKey != "startPoint";
    state.originalSegment = clone$1(state.segment);
    if (state.connectedPoint) {
      state.originalConnectedPoint = clone$1(state.connectedPoint);
    }
    state.cachedPoints = [];
    this.points.filter((p) => p && p != state.segment).forEach((p) => {
      state.cachedPoints.push(p.startPoint, p.reversePoint, p.endPoint);
    });
  }
  moveSegment(segmentKey, dx, dy, originSegment = void 0) {
    if (originSegment) {
      const segment = this.points[originSegment.index][segmentKey];
      segment.x = originSegment[segmentKey].x + dx;
      segment.y = originSegment[segmentKey].y + dy;
    } else {
      var state = this.state;
      var originPoint = state.originalSegment[segmentKey];
      var targetPoint = state.segment[segmentKey];
      if (originPoint) {
        targetPoint.x = originPoint.x + dx;
        targetPoint.y = originPoint.y + dy;
      }
    }
  }
  calculateToCurve(point2, nextPoint, prevPoint) {
    var centerX = (nextPoint.startPoint.x + prevPoint.startPoint.x) / 2;
    var centerY = (nextPoint.startPoint.y + prevPoint.startPoint.y) / 2;
    var dx = (nextPoint.startPoint.x - centerX) / 2;
    var dy = (nextPoint.startPoint.y - centerY) / 2;
    point2.endPoint = {
      x: point2.startPoint.x + dx,
      y: point2.startPoint.y + dy
    };
    point2.reversePoint = {
      x: point2.startPoint.x - dx,
      y: point2.startPoint.y - dy
    };
    return { dx, dy };
  }
  convertToCurve(index2) {
    var point2 = this.points[index2];
    if (point2.curve) {
      point2.curve = false;
      point2.reversePoint = clone$1(point2.startPoint);
      point2.endPoint = clone$1(point2.startPoint);
      if (point2.command === "M") {
        var lastPoint = Point.getPrevPoint(this.points, point2.index);
        if (lastPoint.connected) {
          lastPoint.curve = false;
          lastPoint.reversePoint = clone$1(lastPoint.startPoint);
          lastPoint.endPoint = clone$1(lastPoint.startPoint);
        }
      } else {
        var nextPoint = this.getNextPoint(index2);
        if (nextPoint && nextPoint.command === "M") {
          var firstPoint = nextPoint;
          firstPoint.curve = false;
          firstPoint.reversePoint = clone$1(firstPoint.startPoint);
          firstPoint.endPoint = clone$1(firstPoint.startPoint);
        }
      }
    } else {
      point2.curve = true;
      var prevPoint = this.getPrevPoint(index2);
      var nextPoint = this.getNextPoint(index2);
      if (nextPoint && nextPoint.index < index2 && nextPoint.command === "M") {
        var firstPoint = nextPoint;
        nextPoint = this.getNextPoint(firstPoint.index);
        this.calculateToCurve(point2, nextPoint, prevPoint);
        firstPoint.curve = true;
        firstPoint.endPoint = clone$1(point2.endPoint);
        firstPoint.reversePoint = clone$1(point2.reversePoint);
      } else if (nextPoint && nextPoint.index > index2 && nextPoint.command !== "M") {
        this.calculateToCurve(point2, nextPoint, prevPoint);
      } else if (!nextPoint && prevPoint) {
        var centerX = (point2.startPoint.x - prevPoint.startPoint.x) / 3;
        var centerY = (point2.startPoint.y - prevPoint.startPoint.y) / 3;
        point2.endPoint = {
          x: point2.startPoint.x + centerX,
          y: point2.startPoint.y + centerY
        };
        point2.reversePoint = Point.getReversePoint(point2.startPoint, point2.endPoint);
      } else if (!prevPoint && nextPoint) {
        var centerX = (point2.startPoint.x - nextPoint.startPoint.x) / 3;
        var centerY = (point2.startPoint.y - nextPoint.startPoint.y) / 3;
        point2.endPoint = {
          x: point2.startPoint.x + centerX,
          y: point2.startPoint.y + centerY
        };
        point2.reverse = Point.getReversePoint(point2.startPoint, point2.endPoint);
      }
    }
  }
  moveCurveSegment(segmentKey, dx, dy) {
    var state = this.state;
    this.moveSegment(segmentKey, dx, dy);
    var targetSegmentKey = segmentKey === "endPoint" ? "reversePoint" : "endPoint";
    state.segment[targetSegmentKey] = Point.getReversePoint(state.segment.startPoint, state.segment[segmentKey]);
  }
  rotateSegmentTarget(segmentKey, target) {
    var state = this.state;
    if (state.originalSegment && state.segment) {
      var { x: cx, y: cy } = state.originalSegment.startPoint;
      var { x: rx, y: ry } = state.segment[segmentKey];
      var { x: tx, y: ty } = state.originalSegment[target];
      var { x, y } = getXYInCircle(calculateAngle360(rx - cx, ry - cy), getDist(tx, ty, cx, cy), cx, cy);
      state.segment[target] = { x, y };
    }
  }
  rotateSegment(segmentKey) {
    this.rotateSegmentTarget(segmentKey, segmentKey === "endPoint" ? "reversePoint" : "endPoint");
  }
  calculateSnap(segmentKey, dx, dy, dist2 = 1) {
    var state = this.state;
    var cachedPoints = state.cachedPoints;
    var original = state.originalSegment[segmentKey];
    if (!segmentKey) {
      return { dx, dy, snapPointList: [] };
    }
    var realX = original.x + dx;
    var realY = original.y + dy;
    var { point: snapPointX, distanceValue: dx } = calculateSnapPoint(cachedPoints, "x", realX, dx, dist2);
    var { point: snapPointY, distanceValue: dy } = calculateSnapPoint(cachedPoints, "y", realY, dy, dist2);
    var snapEndPoint = {
      x: original.x + dx,
      y: original.y + dy
    };
    var snapPointList = [];
    if (snapPointX) {
      snapPointList.push({ startPoint: snapPointX, endPoint: snapEndPoint });
    }
    if (snapPointY) {
      snapPointList.push({ startPoint: snapPointY, endPoint: snapEndPoint });
    }
    return { dx, dy, snapPointList };
  }
  copySegment(from, to) {
    to.startPoint = clone$1(from.startPoint);
    to.endPoint = clone$1(from.endPoint);
    to.reversePoint = clone$1(from.reversePoint);
  }
  get selectedLength() {
    return this.selectedPointList.length;
  }
  moveSelectedSegment(dx, dy) {
    if (this.selectedPointList.length > 0) {
      this.selectedPointList.forEach((it) => {
        var target = this.points[it.index][it.key];
        target.x = it.x + dx;
        target.y = it.y + dy;
      });
    } else if (this.selectedGroup) {
      this.moveSelectedGroup(dx, dy);
    }
  }
  moveSelectedGroup(dx, dy) {
    this.selectedGroup.points.forEach((it) => {
      const target = this.points[it.index];
      target.startPoint.x = it.startPoint.x + dx;
      target.startPoint.y = it.startPoint.y + dy;
      target.endPoint.x = it.endPoint.x + dx;
      target.endPoint.y = it.endPoint.y + dy;
      target.reversePoint.x = it.reversePoint.x + dx;
      target.reversePoint.y = it.reversePoint.y + dy;
    });
  }
  get selectedGroup() {
    return this.splitedGroupList[this.state.selectedGroupIndex];
  }
  get splitedGroupList() {
    return Point.getSplitedGroupList(this.points);
  }
  get groupList() {
    return Point.getGroupList(this.points);
  }
  getGroup(groupList, pointIndex) {
    return Point.getGroup(groupList, pointIndex);
  }
  get selectedGroupIndexList() {
    const groupIndexList = /* @__PURE__ */ new Set();
    const groupList = this.groupList;
    if (this.selectedPointList.length === 0 && this.state.selectedGroupIndex < 0) {
      return groupList.map((group2) => group2.groupIndex);
    }
    const points = this.selectedPointList;
    points.forEach((it) => {
      const group2 = this.getGroup(groupList, it.index);
      if (group2) {
        groupIndexList.add(group2.groupIndex);
      }
    });
    return [.../* @__PURE__ */ new Set([...groupIndexList, this.state.selectedGroupIndex])];
  }
  removeSelectedSegment() {
    this.selectedPointList.forEach((it) => {
      var target = this.points[it.index][it.key];
      target.removed = true;
    });
    const pointGroup = Point.splitPoints(this.points);
    const newPoints = Point.recoverPoints(pointGroup.map((points) => {
      return points.filter((p) => !p.startPoint.removed).map((p) => {
        if (p.endPoint.removed) {
          p.endPoint = clone$1(p.startPoint);
        }
        if (p.reversePoint.removed) {
          p.reversePoint = clone$1(p.startPoint);
        }
        if (Point.isEqual(p.endPoint, p.startPoint, p.reversePoint)) {
          p.command = "L";
          p.curve = false;
        }
        return p;
      });
    }));
    this.points = newPoints;
    this.select();
  }
  move(dx, dy, e) {
    var state = this.state;
    var { isCurveSegment, segmentKey, connectedPoint } = state;
    if (this.selectedPointList.length > 1) {
      this.moveSelectedSegment(dx, dy);
    } else if (this.selectedPointList.length === 1) {
      var { dx, dy, snapPointList } = this.calculateSnap(segmentKey, dx, dy, 3);
      this.snapPointList = snapPointList || [];
      if (isCurveSegment) {
        if (e.shiftKey) {
          this.moveSegment(segmentKey, dx, dy);
          var targetSegmentKey = segmentKey === "endPoint" ? "reversePoint" : "endPoint";
          state.segment[targetSegmentKey] = Point.getReversePoint(state.segment.startPoint, state.segment[segmentKey]);
        } else if (e.altKey) {
          this.moveSegment(segmentKey, dx, dy);
          this.rotateSegment(segmentKey);
        } else {
          this.moveSegment(segmentKey, dx, dy);
        }
      } else {
        this.moveSegment("startPoint", dx, dy);
        this.moveSegment("endPoint", dx, dy);
        this.moveSegment("reversePoint", dx, dy);
        if (!e.altKey) {
          state.connectedPointList.forEach((it) => {
            this.moveSegment("startPoint", dx, dy, it);
            this.moveSegment("endPoint", dx, dy, it);
            this.moveSegment("reversePoint", dx, dy, it);
          });
        }
      }
      connectedPoint && this.copySegment(state.segment, state.connectedPoint);
    } else if (this.state.selectedGroupIndex > -1) {
      this.moveSelectedGroup(dx, dy);
    }
  }
  moveEnd(dx, dy) {
    var state = this.state;
    var points = this.points;
    var x = state.dragXY.x + dx;
    var y = state.dragXY.y + dy;
    var endPoint = { x, y };
    var reversePoint = { x, y };
    if (state.dragPoints) {
      reversePoint = Point.getReversePoint(state.startPoint, endPoint);
    }
    points.push({
      command: state.clickCount === 0 ? "M" : "",
      startPoint: state.startPoint,
      endPoint,
      curve: !!state.dragPoints,
      reversePoint
    });
    state.startPoint = null;
    state.dragPoints = false;
    state.moveXY = null;
  }
  setPoint(obj2) {
    var p0 = obj2.first[0];
    var p1 = obj2.second[obj2.second.length - 1];
    var allPoints = this.clonePoints;
    var firstItem = Point.getPoint(allPoints, p0);
    var secondItem = Point.getPoint(allPoints, p1);
    var newPoints = [
      __spreadProps(__spreadValues({}, firstItem), { endPoint: obj2.first[1] }),
      {
        startPoint: obj2.first[3],
        reversePoint: obj2.first[2],
        curve: true,
        endPoint: obj2.second[1]
      },
      __spreadProps(__spreadValues({}, secondItem), { reversePoint: obj2.second[2] })
    ];
    var firstIndex = Point.getIndex(allPoints, p0);
    allPoints.splice(firstIndex, 2, ...newPoints);
    this.points = allPoints;
    return firstIndex + 1;
  }
  setPointQuard(obj2) {
    var p0 = obj2.first[0];
    var p1 = obj2.second[obj2.second.length - 1];
    var allPoints = this.clonePoints;
    var firstItem = Point.getPoint(allPoints, p0);
    var secondItem = Point.getPoint(allPoints, p1);
    if (firstItem.curve && secondItem.curve === false) {
      var newPoints = [
        __spreadProps(__spreadValues({}, firstItem), { endPoint: firstItem.startPoint }),
        {
          startPoint: obj2.first[2],
          reversePoint: obj2.first[1],
          curve: true,
          endPoint: obj2.second[1]
        }
      ];
      var firstIndex = Point.getIndex(allPoints, p0);
      allPoints.splice(firstIndex, 1, ...newPoints);
    } else {
      var newPoints = [
        __spreadValues({}, firstItem),
        {
          startPoint: obj2.first[2],
          reversePoint: obj2.first[1],
          curve: true,
          endPoint: obj2.second[1]
        },
        __spreadProps(__spreadValues({}, secondItem), { reversePoint: obj2.second[1], curve: true })
      ];
      var firstIndex = Point.getIndex(allPoints, p0);
      allPoints.splice(firstIndex, 2, ...newPoints);
    }
    this.points = allPoints;
    return firstIndex + 1;
  }
  setPointLine(obj2) {
    var p0 = obj2.first[0];
    var allPoints = this.clonePoints;
    var newPoints = [
      {
        command: "L",
        startPoint: obj2.first[1],
        curve: false,
        endPoint: obj2.first[1],
        reversePoint: obj2.first[1]
      }
    ];
    var firstIndex = Point.getIndex(allPoints, p0);
    allPoints.splice(firstIndex + 1, 0, ...newPoints);
    this.points = allPoints;
    return firstIndex + 1;
  }
  toPath(minX = 0, minY = 0, scale2 = 1) {
    return toPath(this.clonePoints, minX, minY, scale2);
  }
  makeSVGPath() {
    this.initialize();
    this.makePointGuide(this.points);
    this.makeMovePositionGuide();
    return this.toSVGString();
  }
  makeTriangleDistancePointGuide(first, second) {
    var minX = Math.min(first.startPoint.x, second.startPoint.x);
    var maxX = Math.max(first.startPoint.x, second.startPoint.x);
    var minY = Math.min(first.startPoint.y, second.startPoint.y);
    var maxY = Math.max(first.startPoint.y, second.startPoint.y);
    if (first.startPoint.x < second.startPoint.x && first.startPoint.y < second.startPoint.y) {
      this.segmentManager.addDistanceLine({ x: minX, y: minY }, { x: maxX, y: minY }).addDistanceLine({ x: maxX, y: minY }, { x: maxX, y: maxY });
      var centerX = minX;
      var centerY = minY;
      var angle = calculateAngle360(maxX - minX, maxY - minY) - 180;
      var dist2 = 20;
      var { x, y } = getXYInCircle(0, dist2, centerX, centerY);
      var last = getXYInCircle(angle, dist2, centerX, centerY);
      this.segmentManager.addDistanceAngle(last, dist2, dist2, angle, { x, y }, { x: x - dist2, y });
    } else if (first.startPoint.x < second.startPoint.x && first.startPoint.y > second.startPoint.y) {
      this.segmentManager.addDistanceLine({ x: minX, y: maxY }, { x: maxX, y: maxY }).addDistanceLine({ x: maxX, y: minY }, { x: maxX, y: maxY });
    } else if (first.startPoint.x > second.startPoint.x && first.startPoint.y > second.startPoint.y) {
      this.segmentManager.addDistanceLine({ x: minX, y: minY }, { x: minX, y: maxY }).addDistanceLine({ x: minX, y: maxY }, { x: maxX, y: maxY });
    } else if (first.startPoint.x > second.startPoint.x && first.startPoint.y < second.startPoint.y) {
      this.segmentManager.addDistanceLine({ x: minX, y: maxY }, { x: maxX, y: maxY }).addDistanceLine({ x: maxX, y: minY }, { x: maxX, y: maxY });
    }
  }
  makeDistancePointGuide(prevPoint, current, nextPoint) {
    if (current.selected) {
      if (prevPoint) {
        this.makeTriangleDistancePointGuide(prevPoint, current);
      }
      if (nextPoint) {
        this.makeTriangleDistancePointGuide(current, nextPoint);
      }
    }
  }
  makeStartPointGuide(prevPoint, current, nextPoint, index2) {
    current.startPoint.isFirst = true;
    if (current.curve === false) {
      this.segmentManager.addPoint({}, current.startPoint, index2, "startPoint", this.isSelectedSegment("startPoint", index2));
    } else {
      this.segmentManager.addPoint({}, current.startPoint, index2, "startPoint", this.isSelectedSegment("startPoint", index2)).addGuideLine(current.startPoint, current.endPoint);
      if (Point.isEqual(current.startPoint, current.endPoint) === false) {
        this.segmentManager.addCurvePoint(current.endPoint, index2, "endPoint", this.isSelectedSegment("endPoint", index2));
      }
    }
  }
  makeMiddlePointGuideSegment(prevPoint, current, nextPoint, index2, isSiblingSelected) {
    var mng = this.segmentManager;
    if (current.curve === false) {
      if (prevPoint.curve === false) {
        mng.addPoint({}, current.startPoint, index2, "startPoint", this.isSelectedSegment("startPoint", index2));
      } else {
        if (isSiblingSelected === false) {
          mng.addCurvePoint(current.startPoint, index2, "startPoint", this.isSelectedSegment("startPoint", index2));
        } else {
          mng.addGuideLine(prevPoint.startPoint, prevPoint.endPoint).addCurvePoint(current.startPoint, index2, "startPoint", this.isSelectedSegment("startPoint", index2));
          if (Point.isEqual(prevPoint.startPoint, prevPoint.endPoint) === false) {
            mng.addCurvePoint(prevPoint.endPoint, prevPoint.index, "endPoint", this.isSelectedSegment("endPoint", prevPoint.index));
          }
        }
      }
    } else {
      if (prevPoint.curve === false) {
        if (isSiblingSelected === false) {
          if (Point.isEqual(current.reversePoint, current.startPoint)) {
            mng.addPoint({}, current.startPoint, index2, "startPoint", this.isSelectedSegment("startPoint", index2));
          } else {
            mng.addCurvePoint(current.startPoint, index2, "startPoint", this.isSelectedSegment("startPoint", index2));
          }
        } else {
          if (Point.isEqual(current.reversePoint, current.startPoint)) {
            mng.addPoint({}, current.startPoint, index2, "startPoint", this.isSelectedSegment("startPoint", index2));
          } else {
            mng.addGuideLine(current.startPoint, current.reversePoint).addCurvePoint(current.startPoint, index2, "startPoint", this.isSelectedSegment("startPoint", index2));
            if (Point.isEqual(current.startPoint, current.reversePoint) === false) {
              mng.addCurvePoint(current.reversePoint, index2, "reversePoint", this.isSelectedSegment("reversePoint", index2));
            }
          }
        }
      } else {
        if (current.connected) {
          if (isSiblingSelected === false)
            ;
          else {
            mng.addGuideLine(prevPoint.startPoint, prevPoint.endPoint).addGuideLine(current.startPoint, current.reversePoint);
            if (Point.isEqual(prevPoint.startPoint, prevPoint.endPoint) === false) {
              mng.addCurvePoint(prevPoint.endPoint, prevPoint.index, "endPoint", this.isSelectedSegment("endPoint", prevPoint.index));
            }
            if (Point.isEqual(current.startPoint, current.reversePoint) === false) {
              mng.addCurvePoint(current.reversePoint, index2, "reversePoint", this.isSelectedSegment("reversePoint", index2));
            }
          }
        } else {
          if (isSiblingSelected === false) {
            mng.addCurvePoint(current.startPoint, index2, "startPoint", this.isSelectedSegment("startPoint", index2));
          } else {
            mng.addGuideLine(prevPoint.startPoint, prevPoint.endPoint).addGuideLine(current.startPoint, current.reversePoint).addCurvePoint(current.startPoint, index2, "startPoint", this.isSelectedSegment("startPoint", index2));
            if (Point.isEqual(prevPoint.startPoint, prevPoint.endPoint) === false) {
              mng.addCurvePoint(prevPoint.endPoint, prevPoint.index, "endPoint", this.isSelectedSegment("endPoint", prevPoint.index));
            }
            if (Point.isEqual(current.startPoint, current.reversePoint) === false) {
              mng.addCurvePoint(current.reversePoint, index2, "reversePoint", this.isSelectedSegment("reversePoint", index2));
            }
          }
        }
      }
    }
  }
  checkInViewport(point2) {
    const vertext = this.pathEditor.$viewport.applyVertexInverse([
      point2.x,
      point2.y,
      0
    ]);
    return this.pathEditor.$viewport.checkInViewport(vertext);
  }
  makeMiddlePointGuideSplitLine(prevPoint, current, nextPoint, index2, isSiblingSelected) {
    const selected = isSiblingSelected ? "selected" : "";
    if (current.curve === false) {
      if (prevPoint.curve === false) {
        if ((this.checkInViewport(prevPoint.startPoint) || this.checkInViewport(current.startPoint)) === false) {
          return;
        }
        this.splitLines.push(new PathStringManager().M(prevPoint.startPoint).L(current.startPoint).toString(`split-path ${selected}`));
      } else {
        if ((this.checkInViewport(prevPoint.startPoint) || this.checkInViewport(prevPoint.endPoint) || this.checkInViewport(current.startPoint)) === false) {
          return;
        }
        this.splitLines.push(new PathStringManager().M(prevPoint.startPoint).Q(prevPoint.endPoint, current.startPoint).toString(`split-path ${selected}`));
      }
    } else {
      if (prevPoint.curve === false) {
        if (Point.isEqual(current.reversePoint, current.startPoint)) {
          if ((this.checkInViewport(prevPoint.startPoint) || this.checkInViewport(current.startPoint)) === false) {
            return;
          }
          this.splitLines.push(new PathStringManager().M(prevPoint.startPoint).L(current.startPoint).toString(`split-path ${selected}`));
        } else {
          if ((this.checkInViewport(prevPoint.startPoint) || this.checkInViewport(current.reversePoint) || this.checkInViewport(current.startPoint)) === false) {
            return;
          }
          this.splitLines.push(new PathStringManager().M(prevPoint.startPoint).Q(current.reversePoint, current.startPoint).toString(`split-path ${selected}`));
        }
      } else {
        if ((this.checkInViewport(prevPoint.startPoint) || this.checkInViewport(prevPoint.endPoint) || this.checkInViewport(current.reversePoint) || this.checkInViewport(current.startPoint)) === false) {
          return;
        }
        this.splitLines.push(new PathStringManager().M(prevPoint.startPoint).C(prevPoint.endPoint, current.reversePoint, current.startPoint).toString(`split-path ${selected}`));
      }
    }
  }
  makePointGuide(points) {
    for (var index2 = 0, len2 = points.length; index2 < len2; index2++) {
      var currentIndex = index2;
      var current = points[currentIndex];
      if (!current)
        continue;
      var nextPoint = Point.getNextPoint(points, index2);
      var prevPoint = Point.getPrevPoint(points, index2);
      if (prevPoint && prevPoint.command === "M") {
        if (current.startPoint) {
          current.startPoint.isSecond = true;
        }
      }
      if (current.startPoint) {
        if (nextPoint) {
          current.startPoint.isLast = nextPoint.command === "M";
        } else {
          current.startPoint.isLast = index2 === len2 - 1;
        }
      }
      current.selected = this.selectedIndex === index2;
      if (current.command === "M") {
        this.makeStartPointGuide(prevPoint, current, nextPoint, index2);
      } else {
        var isSiblingSelected = Boolean(this.isSelectedSegment("endPoint", prevPoint == null ? void 0 : prevPoint.index) || this.isSelectedSegment("startPoint", prevPoint == null ? void 0 : prevPoint.index) || this.isSelectedSegment("reversePoint", prevPoint == null ? void 0 : prevPoint.index) || this.isSelectedSegment("endPoint", nextPoint == null ? void 0 : nextPoint.index) || this.isSelectedSegment("startPoint", nextPoint == null ? void 0 : nextPoint.index) || this.isSelectedSegment("reversePoint", nextPoint == null ? void 0 : nextPoint.index) || this.isSelectedSegment("endPoint", current == null ? void 0 : current.index) || this.isSelectedSegment("startPoint", current == null ? void 0 : current.index) || this.isSelectedSegment("reversePoint", current == null ? void 0 : current.index));
        this.makeMiddlePointGuideSplitLine(prevPoint, current, nextPoint, index2, isSiblingSelected);
        this.makeMiddlePointGuideSegment(prevPoint, current, nextPoint, index2, isSiblingSelected);
      }
      if (current.close) {
        this.pathStringManager.Z();
      }
    }
  }
  makeMovePositionGuide() {
    var state = this.state;
    var {
      startPoint,
      moveXY,
      dragPoints,
      snapPointList,
      isGroupSegment
    } = state;
    var points = this.points;
    if (moveXY) {
      snapPointList = snapPointList || [];
      var { snapPointList: movePointSnapPointList, moveXY: newMoveXY } = calculateMovePointSnap(points, moveXY, 3);
      snapPointList.push.apply(snapPointList, movePointSnapPointList);
      state.moveXY = newMoveXY;
      moveXY = newMoveXY;
      this.snapPointList = snapPointList;
      var prev = points[points.length - 1];
      if (dragPoints && !isGroupSegment) {
        if (!prev) {
          var { x, y } = Point.getReversePoint(startPoint, moveXY);
          this.guideLineManager.M(moveXY).L(startPoint).L({ x, y });
          this.segmentManager.addCurvePoint(startPoint).addCurvePoint(moveXY).addCurvePoint({ x, y });
        } else if (prev.curve) {
          var { x, y } = Point.getReversePoint(startPoint, moveXY);
          this.guideLineManager.M(prev.startPoint).C(prev.endPoint, { x, y }, startPoint);
          this.segmentManager.addGuideLine(prev.startPoint, prev.endPoint).addGuideLine(startPoint, { x, y }).addGuideLine(startPoint, moveXY).addCurvePoint(prev.endPoint).addCurvePoint({ x, y }).addCurvePoint(moveXY).addPoint(false, startPoint);
        } else if (prev.curve === false) {
          var { x, y } = Point.getReversePoint(startPoint, moveXY);
          this.guideLineManager.M(prev.startPoint).Q({ x, y }, startPoint);
          this.segmentManager.addGuideLine(moveXY, { x, y }).addPoint(false, startPoint).addCurvePoint({ x, y }).addCurvePoint(moveXY);
        }
      } else {
        if (!prev)
          ;
        else if (prev.curve) {
          this.guideLineManager.M(prev.startPoint).Q(prev.endPoint, moveXY);
          this.segmentManager.addGuideLine(prev.endPoint, prev.startPoint).addCurvePoint(prev.endPoint);
        } else {
          if (!prev.close) {
            this.guideLineManager.M(prev.startPoint).L(moveXY);
            this.segmentManager.addPoint(false, prev.startPoint);
          }
        }
      }
    }
  }
  makeSnapLines() {
    var snapLines = [];
    if (this.snapPointList) {
      var snapPath = new PathStringManager();
      snapLines = this.snapPointList.map((snapPoint) => {
        snapPath.reset();
        return snapPath.M(snapPoint.startPoint).L(snapPoint.endPoint).X(snapPoint.startPoint).toString("snap-path");
      });
    }
    return snapLines.join("");
  }
  makePathArea() {
    const pathList = this.splitedGroupList.map(({ startPointIndex, points }, groupIndex) => {
      const d = PathGenerator.generatorPathString(points);
      const verties = toRectVerties(PathParser.fromSVGString(d).getBBox());
      return {
        points,
        startPointIndex,
        groupIndex,
        center: verties[4],
        d
      };
    });
    const pathCount = pathList.length;
    return `
            <g>
               ${pathList.map((it) => {
      const { center: center2 } = it;
      const [x, y] = center2;
      const selected = this.state.selectedGroupIndex === it.groupIndex;
      return `
                        <path class="path-area ${selected ? "selected" : ""}" 
                            d="${it.d}" 
                            data-point-index="${it.startPointIndex}" 
                            data-group-index="${it.groupIndex}" 
                        />

                        ${pathCount > 1 && `
                            <text class="path-area-text" x="${x}" y="${y}" >${it.groupIndex + 1}</text>
                        `}
                    `;
    }).join("")}
            </g>
        `;
  }
  toSVGString() {
    return `
        <svg width="100%" height="100%" class='svg-editor-canvas'>
            ${this.guideLineManager.toString("guide")}
            ${this.splitLines.join("")}
            ${this.makeSnapLines()}
            ${this.makePathArea()}
            ${this.segmentManager.toString()}
        </svg>
        `;
  }
}
function xy([x, y]) {
  return { x, y };
}
const SegmentConvertor = class extends EditorElement {
  convertToCurve(index2) {
    this.pathGenerator.convertToCurve(index2);
    this.renderPath();
    this.refreshPathLayer();
  }
  isEditableSegment() {
    return this.state.disableCurve === false;
  }
  [DOUBLECLICK("$view [data-segment]") + IF("isEditableSegment") + PREVENT](e) {
    var index2 = +e.$dt.attr("data-index");
    this.convertToCurve(index2);
  }
  [DOUBLETAB("$view [data-segment]") + PREVENT + DELAY(300)](e) {
    var index2 = +e.$dt.attr("data-index");
    this.convertToCurve(index2);
  }
};
const PathCutter = class extends SegmentConvertor {
  calculatePointOnLine(d, clickPosition) {
    var parser = new PathParser(d);
    return parser.getClosedPoint(clickPosition);
  }
  [POINTERSTART("$view .split-path") + MOVE() + END()](e) {
    this.initRect();
    var parser = new PathParser(e.$dt.attr("d"));
    var clickPosition = {
      x: e.xy.x - this.state.rect.x,
      y: e.xy.y - this.state.rect.y
    };
    var selectedSegmentIndex = -1;
    if (this.isMode("path")) {
      this.state.dragXY = clickPosition;
      this.state.startPoint = this.state.dragXY;
      this.pathGenerator.setLastPoint(this.state.startPoint);
      this.state.isSplitPath = true;
      this.renderPath();
      if (this.state.current) {
        this.refreshPathLayer();
      } else {
        this.addPathLayer();
        this.trigger("initPathEditorView");
      }
      return;
    } else {
      if (parser.segments[1].command === "C") {
        var points = [
          xy(parser.segments[0].values),
          xy(parser.segments[1].values.slice(0, 2)),
          xy(parser.segments[1].values.slice(2, 4)),
          xy(parser.segments[1].values.slice(4, 6))
        ];
        var curve = recoverBezier(...points, 20);
        var t = curve(clickPosition.x, clickPosition.y);
        selectedSegmentIndex = this.pathGenerator.setPoint(getBezierPoints(points, t));
      } else if (parser.segments[1].command === "Q") {
        var points = [
          xy(parser.segments[0].values),
          xy(parser.segments[1].values.slice(0, 2)),
          xy(parser.segments[1].values.slice(2, 4))
        ];
        var curve = recoverBezierQuard(...points, 20);
        var t = curve(clickPosition.x, clickPosition.y);
        selectedSegmentIndex = this.pathGenerator.setPointQuard(getBezierPointsQuard(points, t));
      } else if (parser.segments[1].command === "L") {
        var points = [
          xy(parser.segments[0].values),
          xy(parser.segments[1].values.slice(0, 2))
        ];
        var curve = recoverBezierLine(...points, 20);
        var t = curve(clickPosition.x, clickPosition.y);
        selectedSegmentIndex = this.pathGenerator.setPointLine(getBezierPointsLine(points, t));
        if (e.altKey) {
          this.pathGenerator.convertToCurve(selectedSegmentIndex);
        }
      }
      this.renderPath();
      this.refreshPathLayer();
      this.changeMode("segment-move");
      this.pathGenerator.setCachePoint(selectedSegmentIndex, "startPoint");
      this.pathGenerator.selectKeyIndex("startPoint", selectedSegmentIndex);
    }
  }
};
const PathTransformEditor = class extends PathCutter {
  [SUBSCRIBE("changePathTransform")](transformMoveType) {
    this.resetTransformZone();
    var { width: width2, height: height2 } = this.state.transformZoneRect;
    this.pathGenerator.initTransform(this.state.transformZoneRect);
    switch (transformMoveType) {
      case "flipX":
        this.pathGenerator.transform("flipX", width2, 0);
        break;
      case "flipY":
        this.pathGenerator.transform("flipY", 0, height2);
        break;
      case "flip":
        this.pathGenerator.transform("flip", width2, height2);
    }
    this.renderPath();
    this.refreshPathLayer();
  }
  [SUBSCRIBE("changePathUtil")](utilType) {
    if (utilType === "reverse") {
      const { d } = this.pathGenerator.toPath();
      const pathParser = new PathParser(d);
      pathParser.reverse(...this.pathGenerator.selectedGroupIndexList);
      pathParser.transformMat4(this.state.cachedMatrixInverse);
      this.refreshEditorView({ d: pathParser.d });
      this.updatePathLayer();
    }
  }
  [SUBSCRIBE("divideSegmentsByCount")](count) {
    const { d } = this.pathGenerator.toPath();
    const pathParser = new PathParser(d);
    const newPath = pathParser.divideSegmentByCount(count);
    newPath.transformMat4(this.state.cachedMatrixInverse);
    this.refreshEditorView({ d: newPath.d });
  }
};
const FIELDS = ["fill", "fill-opacity", "stroke", "stroke-width"];
class PathEditorView extends PathTransformEditor {
  initialize() {
    super.initialize();
    this.pathParser = new PathParser();
    this.pathGenerator = new PathGenerator(this);
  }
  initState() {
    return {
      changeEvent: "updatePathItem",
      isShow: false,
      isControl: false,
      disableCurve: false,
      points: [],
      mode: "path",
      clickCount: 0,
      isSegment: false,
      isFirstSegment: false,
      current: null
    };
  }
  get scale() {
    return this.$viewport.scale;
  }
  template() {
    return `
        <div class='elf--path-editor-view' tabIndex="-1">
            <style type="text/css" ref="$styleView"></style>
            <svg id='patternId' width='100%' height='100%' xmlns='http://www.w3.org/2000/svg'>
                <defs>
                    <pattern id='stripe' patternUnits='userSpaceOnUse' width='20' height='33' patternTransform='scale(1) rotate(135)'>
                        <path d='M0 8h20z'   stroke-width='1' stroke='#07A3FB' fill='none'/>
                        <path d='M0 16h20z'   stroke-width='1' stroke='#07A3FB' fill='none'/>
                        <path d='M0 24h20z'   stroke-width='1' stroke='#07A3FB' fill='none'/>
                        <path d='M0 32h20z'   stroke-width='1' stroke='#07A3FB' fill='none'/>
                    </pattern>
                </defs>    
            </svg>
            <div class='path-container' ref='$view'></div>
            <div class='path-container split-panel'>
                <svg width="100%" height="100%">
                    <circle ref='$splitCircle' class='split-circle' />
                </svg>
            </div>
            <div class='segment-box' ref='$segmentBox'></div>
        </div>`;
  }
  isShow() {
    return this.state.isShow;
  }
  initRect(isForce = false) {
    if (!this.state.rect || isForce) {
      this.state.rect = this.$el.rect();
    }
  }
  [SUBSCRIBE("PathEditorDone")]() {
    if (this.state.current) {
      this.refreshPathLayer();
      this.trigger("hidePathEditor");
    } else {
      this.addPathLayer();
    }
    if (!this.state.current && this.pathGenerator.length) {
      this.trigger("initPathEditorView");
    } else {
      this.trigger("hidePathEditor");
    }
  }
  [KEYUP("document") + IF("isShow") + ENTER]() {
    this.trigger("PathEditorDone");
  }
  [KEYUP("document") + IF("isShow") + ESCAPE]() {
    if (this.state.current) {
      this.refreshPathLayer();
    } else {
      this.addPathLayer();
    }
    this.trigger("hidePathEditor");
  }
  makePathLayer() {
    const pathString2 = this.pathGenerator.toPath().d;
    if (!pathString2) {
      return;
    }
    var layer;
    const newPath = new PathParser(pathString2);
    newPath.transformMat4(this.$viewport.matrixInverse);
    const bbox = newPath.getBBox();
    const newWidth = distance$1(bbox[1], bbox[0]);
    const newHeight = distance$1(bbox[3], bbox[0]);
    newPath.translate(-bbox[0][0], -bbox[0][1]);
    const pathItem = {
      itemType: "svg-path",
      x: bbox[0][0],
      y: bbox[0][1],
      width: newWidth,
      height: newHeight,
      d: newPath.d,
      fill: newPath.closed ? `#C4C4C4` : "transparent"
    };
    FIELDS.forEach((key) => {
      if (this.state[key]) {
        pathItem[key] = this.state[key];
      }
    });
    const containerItem = this.$context.selection.currentProject;
    layer = containerItem.appendChild(this.$editor.createModel(pathItem));
    this.$commands.executeCommand("moveLayerToTarget", "add path", layer, this.$context.selection.currentProject);
    return layer;
  }
  updatePathLayer() {
    var { d } = this.pathGenerator.toPath();
    var parser = new PathParser(d);
    parser.transformMat4(this.$viewport.matrixInverse);
    this.emit(this.state.changeEvent, {
      d: parser.d,
      matrix: this.state.matrix,
      box: this.state.box
    });
  }
  addPathLayer() {
    this.changeMode("modify");
    var layer = this.makePathLayer();
    if (layer) {
      this.$config.set("editing.mode.itemType", "select");
      this.$context.selection.select(layer);
      this.trigger("hidePathEditor");
    }
  }
  changeMode(mode, obj2) {
    this.setState(__spreadValues({
      mode,
      clickCount: 0,
      moveXY: null
    }, obj2), false);
    if (obj2 == null ? void 0 : obj2.points) {
      this.pathGenerator.setPoints(obj2.points || []);
    }
    this.emit("changePathManager", this.state.mode);
  }
  [SUBSCRIBE("changePathManager")](obj2) {
    this.setState(__spreadProps(__spreadValues({}, obj2), { clickCount: 0 }), false);
    this.renderPath();
  }
  isMode(mode) {
    return this.state.mode === mode;
  }
  afterRender() {
    this.$el.hide();
  }
  [SUBSCRIBE(UPDATE_VIEWPORT)]() {
    if (this.$el.isShow()) {
      const { d } = this.pathGenerator.toPath();
      const pathParser = new PathParser(d);
      pathParser.transformMat4(this.state.cachedMatrixInverse);
      this.refreshEditorView({ d: pathParser.d });
    }
  }
  refreshEditorView(obj2) {
    if (obj2 && obj2.d) {
      this.pathParser.reset(obj2.d);
      this.pathParser.transformMat4(this.$viewport.matrix);
      this.state.cachedMatrixInverse = this.$viewport.matrixInverse;
      this.pathGenerator.setPoints(this.pathParser.convertGenerator());
    }
    this.renderPath();
  }
  [SUBSCRIBE("showPathEditor")](mode = "path", obj2 = {}) {
    this.state.isShow = true;
    this.transformMode = mode;
    if (mode === "move") {
      obj2.current = null;
      obj2.points = [];
    }
    obj2.box = obj2.box || "canvas";
    this.changeMode(mode, obj2);
    this.refreshEditorView(obj2, true);
    this.$el.show();
    this.$el.focus();
    this.emit("showPathManager", { mode: this.state.mode });
    this.emit("hidePathDrawEditor");
    this.$context.commands.emit("push.mode.view", "PathEditorView");
  }
  [SUBSCRIBE("hidePathEditor")]() {
    if (this.$el.isShow()) {
      this.pathParser.reset("");
      this.pathGenerator.setPoints([]);
      this.setState(this.initState(), false);
      this.refs.$view.empty();
      this.$el.hide();
      this.emit("hidePathManager");
      this.$context.commands.emit("pop.mode.view", "PathEditorView");
      this.emit(REFRESH_SELECTION);
    }
  }
  [SUBSCRIBE("hideAddViewLayer")]() {
    this.state.isShow = false;
    this.state.isControl = false;
    this.pathParser.reset("");
    this.setState(this.initState(), false);
    this.refs.$view.empty();
    this.$el.hide();
    this.emit("hidePathManager");
  }
  [BIND("$view")]() {
    var _a;
    const path = this.state.isShow ? this.pathGenerator.makeSVGPath() : "";
    const strokeWidth = Length.parse((_a = this.state.current) == null ? void 0 : _a["stroke-width"]).value || 0;
    return {
      class: {
        path: this.state.mode === "path",
        modify: this.state.mode === "modify",
        transform: this.state.mode === "transform",
        box: this.state.box === "box",
        canvas: this.state.box === "canvas",
        "segment-move": this.state.mode === "segment-move",
        "is-control": this.state.isControl,
        "has-one-stroke-width": strokeWidth === 1
      },
      htmlDiff: path
    };
  }
  [BIND("$splitCircle")]() {
    if (this.state.splitXY) {
      return {
        cx: this.state.splitXY.x,
        cy: this.state.splitXY.y,
        r: 5
      };
    } else {
      return {
        r: 0
      };
    }
  }
  refreshPathLayer() {
    this.updatePathLayer();
  }
  renderPath() {
    this.bindData("$view");
  }
  getPathRect() {
    this.initRect(true);
    const { d } = this.pathGenerator.toPath();
    return vertiesToRectangle(PathParser.fromSVGString(d).getBBox());
  }
  resetTransformZone() {
    var rect2 = this.getPathRect();
    this.state.transformZoneRect = rect2;
  }
  [POINTERMOVE("$view") + PREVENT](e) {
    this.initRect();
    if (this.isMode("path") && this.state.rect) {
      this.state.moveXY = {
        x: e.xy.x - this.state.rect.x,
        y: e.xy.y - this.state.rect.y
      };
      this.state.altKey = e.altKey;
      this.renderPath();
    } else {
      var $target = Dom.create(e.target);
      var isSplitPath = $target.hasClass("split-path");
      if (isSplitPath) {
        this.state.splitXY = this.calculatePointOnLine($target.attr("d"), {
          x: e.xy.x - this.state.rect.x,
          y: e.xy.y - this.state.rect.y
        });
      } else {
        this.state.splitXY = null;
      }
      this.bindData("$splitCircle");
      this.state.altKey = false;
    }
  }
  [POINTERSTART("$view :not(.split-path)") + PREVENT + STOP + MOVE() + END()](e) {
    this.initRect();
    this.state.altKey = false;
    var isPathMode = this.isMode("path");
    this.$config.set("set.move.control.point", true);
    this.state.dragXY = {
      x: e.xy.x - this.state.rect.x,
      y: e.xy.y - this.state.rect.y
    };
    this.$config.set("set.drag.path.area", false);
    var $target = Dom.create(e.target);
    if ($target.hasClass("svg-editor-canvas") && !isPathMode) {
      this.$config.set("set.drag.path.area", true);
      this.state.isGroupSegment = false;
      this.state.selectedGroupIndex = -1;
      this.state.selectedPointIndex = -1;
    } else {
      this.pathGenerator.reselect();
      this.state.isSegment = $target.attr("data-segment") === "true";
      this.state.isFirstSegment = this.state.isSegment && $target.attr("data-is-first") === "true";
      this.state.isGroupSegment = $target.hasClass("path-area");
      if (this.state.isGroupSegment) {
        this.state.selectedGroupIndex = +$target.data("group-index");
        this.state.selectedPointIndex = +$target.data("point-index");
      } else {
        this.state.selectedGroupIndex = -1;
        this.state.selectedPointIndex = -1;
      }
    }
    if (isPathMode) {
      if (this.state.isFirstSegment) {
        var index2 = +$target.attr("data-index");
        this.state.startPoint = this.pathGenerator.points[index2].startPoint;
      } else {
        this.state.startPoint = this.state.dragXY;
      }
      this.state.dragPoints = false;
      this.state.endPoint = null;
    } else {
      if (this.state.isSegment) {
        this.changeMode("segment-move");
        var [index2, segmentKey] = $target.attrs("data-index", "data-segment-point");
        const localIndex = +index2;
        if (e.shiftKey) {
          this.pathGenerator.toggleSelect(segmentKey, localIndex);
        } else {
          this.pathGenerator.setCachePoint(localIndex, segmentKey);
          this.pathGenerator.selectKeyIndex(segmentKey, localIndex);
        }
        this.renderPath();
      } else if (this.state.isGroupSegment) {
        this.changeMode("segment-move");
        this.pathGenerator.selectGroup(this.state.selectedGroupIndex);
        this.renderPath();
      }
    }
  }
  move(dx, dy) {
    var e = this.$config.get("bodyEvent");
    if (this.$config.true("set.drag.path.area")) {
      this.renderSelectBox(this.state.dragXY, dx, dy);
    } else if (this.isMode("segment-move")) {
      this.pathGenerator.move(dx, dy, e);
      this.renderPath();
      this.updatePathLayer();
    } else if (this.isMode("path")) {
      const dist2 = getDist(dx, dy, 0, 0);
      if (dist2 >= 2) {
        this.state.dragPoints = e.altKey ? false : true;
      }
    }
  }
  renderSegment(callback) {
    if (this.pathGenerator.selectedLength) {
      this.pathGenerator.reselect();
      if (isFunction(callback))
        callback();
      this.renderPath();
      this.updatePathLayer();
    }
  }
  end(dx, dy) {
    var e = this.$config.get("bodyEvent");
    this.$config.set("set.move.control.point", false);
    if (this.state.isGroupSegment) {
      this.pathGenerator.select();
    }
    if (this.$config.true("set.drag.path.area")) {
      if (dx === 0 && dy === 0) {
        this.changeMode("modify");
        this.trigger("hidePathEditor");
      } else {
        this.changeMode("segment-move");
        this.pathGenerator.selectInBox(this.getSelectBox(), e.shiftKey);
        this.renderPath();
        this.hideSelectBox();
      }
    } else if (this.isMode("modify")) {
      this.pathGenerator.reselect();
    } else if (this.isMode("segment-move")) {
      this.changeMode("modify");
      this.pathGenerator.reselect();
      this.renderPath();
      this.updatePathLayer();
    } else if (this.isMode("path")) {
      if (this.state.isFirstSegment) {
        this.changeMode("modify");
        this.pathGenerator.setConnectedPoint(dx, dy);
        this.renderPath();
        if (this.state.current) {
          this.refreshPathLayer();
        } else {
          this.addPathLayer();
          this.trigger("initPathEditorView");
        }
      } else {
        if (this.state.isSplitPath)
          ;
        else {
          this.pathGenerator.moveEnd(dx, dy);
          this.state.clickCount++;
          this.renderPath();
          this.pathGenerator.reselect();
        }
      }
      this.state.isSplitPath = false;
    }
  }
  hideSelectBox() {
    this.refs.$segmentBox.css({
      left: -1e5
    });
  }
  renderSelectBox(startXY = null, dx = 0, dy = 0) {
    var obj2 = {
      left: startXY.x + (dx < 0 ? dx : 0),
      top: startXY.y + (dy < 0 ? dy : 0),
      width: Math.abs(dx),
      height: Math.abs(dy)
    };
    this.refs.$segmentBox.css(obj2);
  }
  getSelectBox() {
    var [x, y, width2, height2] = this.refs.$segmentBox.styles("left", "top", "width", "height").map((it) => Length.parse(it));
    var rect2 = {
      x,
      y,
      width: width2,
      height: height2
    };
    rect2.x2 = rect2.x.value + rect2.width;
    rect2.y2 = rect2.y.value + rect2.height;
    return rect2;
  }
  [SUBSCRIBE("deleteSegment")]() {
    this.pathGenerator.reselect();
    this.pathGenerator.removeSelectedSegment();
    this.renderPath();
    this.updatePathLayer();
  }
  [SUBSCRIBE("moveSegment")](dx, dy) {
    this.pathGenerator.reselect();
    this.pathGenerator.moveSelectedSegment(dx, dy);
    this.renderPath();
    this.updatePathLayer();
  }
  [SUBSCRIBE("initPathEditorView")]() {
    this.pathParser.reset("");
    this.setState(this.initState(), false);
    this.state.isShow = true;
    this.refs.$view.empty();
    this.$el.focus();
  }
}
var PathManager$1 = "";
const MODES = {
  "segment-move": "modify",
  modify: "modify",
  path: "path",
  transform: "transform",
  warp: "warp"
};
class PathManager extends EditorElement {
  initState() {
    return {
      mode: "move",
      fill: null,
      stroke: null,
      "fill-opacity": null,
      "stroke-width": null,
      msg: this.$i18n("path.manager.msg")
    };
  }
  template() {
    return `
      <div class='elf--path-manager'>
        <div class="tools left" ref="$left">
            <button type="button" class="primary" data-value='PathEditorDone' title='${this.$i18n("path.manager.mode.modify")}' >Done</button>
        </div>
        <div class='tools' ref='$mode' data-selected-value='${this.state.mode}'>
            <button type="button" data-value='modify' data-tooltip='${this.$i18n("path.manager.mode.modify")}' > ${iconUse("device_hub")}</button>
            <button type="button" data-value='path' data-tooltip='${this.$i18n("path.manager.mode.path")}' > ${iconUse("control_point")}</button>
            <button type="button" data-value='transform' data-tooltip='${this.$i18n("path.manager.mode.transform")}' > ${iconUse("transform")}</button>             
        </div>
        <div class="split"></div>        
        <div class='tools' ref='$util'>
            <button type="button" data-value='reverse' data-tooltip='${this.$i18n("path.manager.mode.reverse")}' >${iconUse("sync")}</button>
        </div>                        
        <div class='tools' ref='$flip'>
            <button type="button" data-value='flipX' data-tooltip='${this.$i18n("path.manager.mode.flipX")}'>${iconUse("flip")}</button>
            <button type="button" data-value='flipY' data-tooltip='${this.$i18n("path.manager.mode.flipY")}'>${iconUse("flip", "rotate(90 12 12)")}</button>
            <button type="button" data-value='flip' data-tooltip='${this.$i18n("path.manager.mode.flipOrigin")}'>${iconUse("flip", "rotate(45 12 12)")}</button>
            <div class="split"></div>            
            <button type="button" data-value='2x' data-tooltip="divide segment by 2 times">2x</button>
            <button type="button" data-value='3x' data-tooltip="divide segment by 3 times">3x</button>            
        </div>
        <div class="subpath" style="display:none">
          <button type="button" data-value="path" data-pathtype="rect">${iconUse("rect", "", { width: 24, height: 24 })}</button>
        </div>
      </div>    
    `;
  }
  [BIND("$mode")]() {
    return {
      "data-selected-value": MODES[this.state.mode]
    };
  }
  refresh() {
    this.bindData("$mode");
  }
  [CLICK("$flip button")](e) {
    var transformType = e.$dt.attr("data-value");
    if (transformType === "2x") {
      this.emit("divideSegmentsByCount", 2);
    } else if (transformType === "3x") {
      this.emit("divideSegmentsByCount", 3);
    } else {
      this.emit("changePathTransform", transformType);
    }
  }
  [CLICK("$util button")](e) {
    var utilType = e.$dt.attr("data-value");
    this.emit("changePathUtil", utilType);
  }
  [CLICK("$mode button")](e) {
    var mode = e.$dt.attr("data-value");
    this.updateData({
      mode
    });
    this.refresh();
  }
  [CLICK("$left button")](e) {
    var message = e.$dt.attr("data-value");
    this.emit(message);
  }
  updateData(obj2 = {}) {
    this.setState(obj2, false);
    this.emit(this.state.changeEvent, obj2);
  }
  [SUBSCRIBE("changePathManager")](mode) {
    this.setState({ mode });
  }
  [SUBSCRIBE("showPathManager")](obj2 = {}) {
    obj2.changeEvent = obj2.changeEvent || "changePathManager";
    this.setState(obj2);
    this.$el.show();
  }
  [SUBSCRIBE("hidePathManager")]() {
    this.$el.hide();
  }
}
function pathEditorView(editor) {
  editor.registerUI("canvas.view", {
    PathEditorView
  });
  editor.registerUI("page.subeditor.view", {
    PathManager
  });
}
var PathToolProperty$1 = "";
class PathToolProperty extends BaseProperty {
  components() {
    return {
      LeftAlign,
      CenterAlign,
      RightAlign,
      TopAlign,
      MiddleAlign,
      BottomAlign,
      SameWidth,
      SameHeight
    };
  }
  getTitle() {
    return this.$i18n("alignment.property.title");
  }
  isHideHeader() {
    return true;
  }
  getBody() {
    return `
      <div class="elf--boolean-item" ref="$buttons">
        <div>
          <button type="button" data-command="convert.path.operation" data-args="union">${iconUse("boolean_union", "", { width: 30, height: 30 })} Union</button>        
          <button type="button" data-command="convert.path.operation" data-args="intersection">${iconUse("boolean_intersection", "", { width: 30, height: 30 })} Intersection</button>        
        </div>
        <div>
          <button type="button" data-command="convert.path.operation" data-args="difference">${iconUse("boolean_difference", "", { width: 30, height: 30 })} Subtract</button>        
          <button type="button" data-command="convert.path.operation" data-args="xor">${iconUse("boolean_xor", "", { width: 30, height: 30 })} Exclude</button>        
        </div>
        <div class="divider"></div>
        <!--div>
          <button type="button" data-command="convert.no.transform.path">${iconUse("grid3x3", "", { width: 24, height: 24 })} No Transform</button>        
        </div-->
        <div>
          <button type="button" data-command="convert.simplify.path">${iconUse("grid3x3", "", { width: 24, height: 24 })} Self Intersection</button>        
          <button type="button" data-command="convert.flatten.path">${iconUse("flatten", "", { width: 24, height: 24 })} Flatten</button>                  
        </div>        
        <div>
          <!--<button type="button" data-command="convert.smooth.path">${iconUse("smooth", "", { width: 24, height: 24 })} Smooth Path</button>-->                
          <button type="button" data-command="switch.path">${iconUse("sync", "", { width: 30, height: 30 })} Switch path</button>                  
          <button type="button" data-command="convert.stroke.to.path">${iconUse("outline_shape", "", { width: 24, height: 24 })} Outline Path</button> 
        </div>        
        <!--div>
          <button type="button" data-command="convert.polygonal.path">${iconUse("highlight_at", "", { width: 24, height: 24 })} Polygonal</button>                
          <button type="button" data-command="convert.normalize.path">${iconUse("stroke_to_path", "", { width: 24, height: 24 })} Normalize</button> 
        </div-->                
      </div>
    `;
  }
  [CLICK("$buttons button")](e) {
    const command = e.$dt.data("command");
    const args2 = e.$dt.data("args");
    if (command === "convert.smooth.path") {
      this.$commands.emit(command);
    } else {
      this.$commands.emit(command, args2);
    }
  }
  [SUBSCRIBE(REFRESH_SELECTION)]() {
    this.refreshShow(() => {
      if (this.$context.selection.length === 1 && this.$context.selection.is("boolean-path"))
        return true;
      return this.$context.selection.is("svg-path", "polygon", "star");
    });
  }
}
function pathTool(editor) {
  editor.registerUI("inspector.tab.style", {
    PathToolProperty
  });
}
var PatternEditor$1 = "";
class PatternEditor extends EditorElement {
  initState() {
    return {
      hideLabel: this.props.hideLabel,
      value: this.props.value,
      patterns: this.parsePattern(this.props.value)
    };
  }
  parsePattern(str) {
    if (str === "undefined")
      return [];
    return Pattern.parseStyle(str);
  }
  setValue(value) {
    this.setState({
      value,
      patterns: this.parsePattern(value)
    });
  }
  template() {
    return `
            <div class='elf--pattern-editor' >
                <div class='pattern-list' ref='$patternList'></div>
            </div>
        `;
  }
  [LOAD("$patternList")]() {
    return this.state.patterns.map((it, index2) => {
      const selectedClass = it.selected ? "selected" : "";
      if (it.selected) {
        this.selectedIndex = index2;
      }
      return `
            <div class='pattern-item ${selectedClass}' data-index='${index2}' ref="fillIndex${index2}"  draggable='true'>
                ${createComponent("PatternSizeEditor", {
        key: "pattern-size",
        ref: `$bp${index2}`,
        type: it.type,
        x: it.x,
        y: it.y,
        width: it.width,
        height: it.height,
        index: index2,
        foreColor: it.foreColor,
        backColor: it.backColor,
        blendMode: it.blendMode,
        lineWidth: it.lineWidth,
        lineHeight: it.lineHeight,
        onchange: "changePatternSizeInfo"
      })}
                <div class='tools'>
                    <button type="button" class='remove' title='Remove a pattern' data-index='${index2}'>${iconUse("remove")}</button>
                </div>
            </div>
            `;
    });
  }
  modifyPattern() {
    var value = Pattern.join(this.state.patterns);
    this.parent.trigger(this.props.onchange, this.props.key, value);
  }
  [SUBSCRIBE("add")](type = "check") {
    var pattern = patterns.find((it) => it.key === type);
    if (pattern) {
      const data = Pattern.parseStyle(pattern.execute()[0].pattern);
      this.state.patterns.push.apply(this.state.patterns, data);
      this.refresh();
      this.modifyPattern();
    }
  }
  [CLICK("$add")]() {
    this.trigger("add");
  }
  [DRAGSTART("$patternList .pattern-item")](e) {
    this.startIndex = +e.$dt.attr("data-index");
  }
  [DRAGOVER("$patternList .pattern-item") + PREVENT]() {
  }
  sortItem(arr, startIndex, targetIndex) {
    arr.splice(targetIndex + (startIndex < targetIndex ? -1 : 0), 0, ...arr.splice(startIndex, 1));
  }
  sortPattern(startIndex, targetIndex) {
    this.sortItem(this.state.patterns, startIndex, targetIndex);
  }
  [DROP("$patternList .pattern-item") + PREVENT](e) {
    var targetIndex = +e.$dt.attr("data-index");
    this.selectItem(this.startIndex, true);
    this.sortPattern(this.startIndex, targetIndex);
    this.modifyPattern();
    this.refresh();
  }
  getCurrentPattern() {
    return this.state.patterns[this.selectedIndex];
  }
  [CLICK("$patternList .tools .remove")](e) {
    var removeIndex = +e.$dt.attr("data-index");
    this.state.patterns.splice(removeIndex, 1);
    this.modifyPattern();
    this.refresh();
  }
  selectItem(selectedIndex, isSelected = true) {
    if (isSelected) {
      this.refs[`fillIndex${selectedIndex}`].addClass("selected");
    } else {
      this.refs[`fillIndex${selectedIndex}`].removeClass("selected");
    }
    this.state.patterns.forEach((it, index2) => {
      it.selected = index2 === selectedIndex;
    });
  }
  [SUBSCRIBE("changePatternSizeInfo") + DEBOUNCE(10)](key, value, index2) {
    var pattern = this.state.patterns[index2];
    pattern.reset(value);
    this.modifyPattern();
    this.refresh();
  }
}
var PatternInfoPopup$1 = "";
class PatternInfoPopup extends BasePopup {
  getClassName() {
    return "pattern-info-popup";
  }
  getTitle() {
    return this.$i18n("pattern.info.popup.title");
  }
  initState() {
    return {
      type: this.props.type || "grid",
      x: this.props.x || 0,
      y: this.props.y || 0,
      width: this.props.width || 0,
      height: this.props.height || 0,
      lineWidth: this.props.lineWidth || 1,
      lineHeight: this.props.lineHeight || 1,
      foreColor: this.props.foreColor || "black",
      backColor: this.props.backColor || "transparent",
      blendMode: this.props.blendMode || "normal"
    };
  }
  updateData(opt = {}) {
    this.setState(opt, false);
    const {
      x,
      y,
      width: width2,
      height: height2,
      foreColor,
      backColor,
      blendMode,
      lineWidth,
      lineHeight
    } = this.state;
    this.state.instance.trigger(this.state.changeEvent, {
      x,
      y,
      width: width2,
      height: height2,
      foreColor,
      backColor,
      blendMode,
      lineWidth,
      lineHeight
    });
  }
  [SUBSCRIBE_SELF("changeRangeEditor")](key, value) {
    this.updateData({ [key]: value });
  }
  templateForX() {
    if (this.hasNotX())
      return "";
    let label = "X";
    let units = "";
    if (this.state.type === "diagonal-line") {
      label = this.$i18n("pattern.info.popup.rotate");
      units = ["deg"];
    }
    return createComponent("InputRangeEditor", {
      label,
      ref: "$x",
      key: "x",
      value: this.state.x,
      min: 0,
      max: 1e3,
      step: 1,
      units,
      onchange: "changeRangeEditor"
    });
  }
  templateForY() {
    if (this.hasNotY())
      return "<div></div>";
    return createComponent("InputRangeEditor", {
      label: "Y",
      ref: "$y",
      key: "y",
      value: this.state.y,
      min: 0,
      max: 1e3,
      step: 1,
      onchange: "changeRangeEditor"
    });
  }
  templateForLabel() {
    return `<label>${this.state.type}</label>`;
  }
  templateForWidth() {
    return createComponent("InputRangeEditor", {
      label: this.$i18n("pattern.info.popup.width"),
      ref: "$width",
      key: "width",
      value: this.state.width,
      min: 0,
      max: 500,
      step: 1,
      onchange: "changeRangeEditor"
    });
  }
  templateForHeight() {
    return createComponent("InputRangeEditor", {
      label: this.$i18n("pattern.info.popup.height"),
      ref: "$height",
      key: "height",
      value: this.state.height,
      min: 0,
      max: 500,
      step: 1,
      onchange: "changeRangeEditor"
    });
  }
  hasNotLineWidth() {
    return ["check"].includes(this.state.type);
  }
  hasNotLineHeight() {
    return [
      "cross-dot",
      "dot",
      "check",
      "diagonal-line",
      "horizontal-line"
    ].includes(this.state.type);
  }
  hasNotX() {
    return ["grid", "dot", "horizontal-line"].includes(this.state.type);
  }
  hasNotY() {
    return ["grid", "dot", "diagonal-line", "vertical-line"].includes(this.state.type);
  }
  templateForLineWidth() {
    if (this.hasNotLineWidth())
      return "<div></div>";
    return createComponent("InputRangeEditor", {
      label: this.$i18n("pattern.info.popup.lineWidth"),
      ref: "$lineWidth",
      key: "lineWidth",
      value: this.state.lineWidth,
      min: 0,
      max: 500,
      step: 1,
      onchange: "changeRangeEditor"
    });
  }
  templateForLineHeight() {
    if (this.hasNotLineHeight())
      return "<div></div>";
    return createComponent("InputRangeEditor", {
      label: this.$i18n("pattern.info.popup.lineHeight"),
      ref: "$lineHeight",
      key: "lineHeight",
      value: this.state.lineHeight,
      min: 0,
      max: 500,
      step: 1,
      onchange: "changeRangeEditor"
    });
  }
  templateForForeColor() {
    return createComponent("ColorViewEditor", {
      ref: "$foreColor",
      label: this.$i18n("pattern.info.popup.foreColor"),
      key: "foreColor",
      value: this.state.foreColor,
      onchange: "changeRangeEditor"
    });
  }
  templateForBackColor() {
    return createComponent("ColorViewEditor", {
      ref: "$backColor",
      label: this.$i18n("pattern.info.popup.backColor"),
      key: "backColor",
      value: this.state.backColor,
      onchange: "changeRangeEditor"
    });
  }
  templateForBlendMode() {
    return `
    <div class=''>
      ${createComponent("BlendSelectEditor", {
      ref: "$blend",
      key: "blendMode",
      label: this.$i18n("pattern.info.popup.blend"),
      value: this.state.blendMode,
      onchange: "changeRangeEditor"
    })}
    </div>
    `;
  }
  getBody() {
    return `
      <div class="background-image-position-picker" ref='$picker'></div>
    `;
  }
  [LOAD("$picker")]() {
    return `
      
      <div class='box'>
          <div>
            ${this.templateForLabel()}
          </div>
          <div>
            ${this.templateForWidth()}
            ${this.templateForHeight()}        
          </div>
          <div>
            ${this.templateForLineWidth()}
            ${this.templateForLineHeight()}                  
          </div>
          <div>
            ${this.templateForX()}
            ${this.templateForY()}
          </div>
          <div>
            ${this.templateForForeColor()}
            ${this.templateForBackColor()}
          </div>
          <div>
            ${this.templateForBlendMode()}
          </div>
      </div>
    `;
  }
  [SUBSCRIBE("showPatternInfoPopup")](data, rect2) {
    this.state.changeEvent = data.changeEvent || "changePatternInfoPopup";
    this.state.instance = data.instance;
    this.setState(data.data);
    this.showByRect(rect2);
  }
}
var PatternProperty$1 = "";
class PatternProperty extends BaseProperty {
  getTitle() {
    return this.$i18n("pattern.property.title");
  }
  getClassName() {
    return "el--pattern-property";
  }
  getTitleClassName() {
    return "pattern";
  }
  getBody() {
    return `<div class='pattern-property' ref='$body'></div>`;
  }
  getTools() {
    return `
      <div ref='$tools' class='add-tools'>
        <button type="button" data-pattern='check' data-tooltip="Check">${iconUse("pattern_check")}</button>
        <button type="button" data-pattern='grid' data-tooltip="Grid">${iconUse("pattern_grid")}</button>
        <button type="button" data-pattern='dot' data-tooltip="Dot">${iconUse("pattern_dot")}</button>
        <button type="button" data-pattern='cross-dot' data-tooltip="Cross Dot">${iconUse("pattern_cross_dot", "rotate(45 12 12)")}</button>
        <button type="button" data-pattern='diagonal-line' data-tooltip="Diagonal Line">${iconUse("texture")}</button>
        <button type="button" data-pattern='vertical-line' data-tooltip="Vertical Line" data-direction="bottom right">${iconUse("pattern_horizontal_line", "rotate(90 12 12)")}</button>
        <button type="button" data-pattern='horizontal-line' data-tooltip="Horizontal Line" data-direction="bottom right">${iconUse("pattern_horizontal_line")}</button>
      </div>
    `;
  }
  [CLICK("$tools button")](e) {
    var patternType = e.$dt.data("pattern");
    this.children.$patternEditor.trigger("add", patternType);
  }
  [LOAD("$body")]() {
    var current = this.$context.selection.current || {};
    var value = current.pattern;
    return createComponent("PatternEditor", {
      ref: "$patternEditor",
      value,
      "hide-label": true,
      onchange: "changePatternEditor"
    });
  }
  [SUBSCRIBE_SELF("changePatternEditor")](key, pattern) {
    this.$commands.executeCommand("setAttribute", "change pattern", this.$context.selection.packByValue({
      pattern
    }));
  }
  get editableProperty() {
    return "pattern";
  }
  [SUBSCRIBE(REFRESH_SELECTION) + IF("checkShow")]() {
    this.refresh();
  }
  [SUBSCRIBE("refreshSVGArea") + DEBOUNCE(1e3)]() {
    this.load("$patternSelect");
  }
}
var PatternSizeEditor$1 = "";
class PatternSizeEditor extends EditorElement {
  initState() {
    return {
      index: this.props.index,
      x: Length.parse(this.props.x),
      y: Length.parse(this.props.y),
      width: Length.parse(this.props.width),
      height: Length.parse(this.props.height),
      lineWidth: Length.parse(this.props.lineWidth),
      lineHeight: Length.parse(this.props.lineHeight),
      backColor: this.props.backColor,
      foreColor: this.props.foreColor,
      blendMode: this.props.blendMode,
      type: this.props.type
    };
  }
  updateData(opt = {}) {
    this.setState(opt, false);
    this.modifyValue(opt);
  }
  modifyValue(value) {
    this.parent.trigger(this.props.onchange, this.props.key, value, this.state.index);
  }
  setValue(obj2) {
    this.setState(__spreadValues({}, obj2));
  }
  [BIND("$miniView")]() {
    const {
      type,
      x,
      y,
      width: width2,
      height: height2,
      lineWidth,
      lineHeight,
      backColor,
      foreColor,
      blendMode
    } = this.state;
    let obj2 = {
      type,
      x,
      y,
      width: width2,
      height: height2,
      lineWidth,
      lineHeight,
      backColor,
      foreColor,
      blendMode
    };
    if (this.state.width > 80) {
      obj2.width = 80;
      obj2.x = obj2.x.value / this.state.width / 80;
    }
    if (this.state.height > 80) {
      obj2.height = 80;
      obj2.y = this.state.y.value / this.state.height / 80;
    }
    const pattern = Pattern.parse(obj2);
    return {
      cssText: pattern.toCSS()
    };
  }
  template() {
    return `
            <div class='elf--pattern-size-editor'>
                <div class='preview' ref='$preview'>
                    <div class='mini-view'>
                        <div class='color-view' style="background-color: ${this.state.color}" ref='$miniView'></div>
                    </div>
                </div>
            </div>
        `;
  }
  [CLICK("$preview")]() {
    this.viewBackgroundPositionPopup();
  }
  viewBackgroundPositionPopup() {
    const layoutElement = this.$config.get("editor.layout.elements");
    const bodyRect = layoutElement.$bodyPanel.rect();
    const rect2 = this.$el.rect();
    const newRect = {
      left: bodyRect.left + bodyRect.width - 240,
      top: rect2.top,
      width: 240,
      height: 300
    };
    this.emit("showPatternInfoPopup", {
      changeEvent: (pattern) => {
        this.updateData(__spreadValues({}, pattern));
      },
      data: this.state,
      instance: this
    }, newRect);
  }
}
function patternAsset(editor) {
  editor.registerElement({
    PatternEditor,
    PatternSizeEditor,
    PatternAssetsProperty
  });
  editor.registerUI("inspector.tab.style", {
    PatternProperty
  });
  editor.registerUI("popup", {
    PatternInfoPopup
  });
}
var PositionProperty$1 = "";
const DEFAULT_SIZE = 0;
class PositionProperty extends BaseProperty {
  getTitle() {
    return this.$i18n("position.property.title");
  }
  afterRender() {
    this.show();
  }
  [SUBSCRIBE(REFRESH_SELECTION)]() {
    this.refreshShowIsNot(["project"]);
  }
  checkChangedValue() {
    var current = this.$context.selection.current;
    if (!current)
      return false;
    return current.hasChangedField("x", "y", "right", "bottom", "width", "height", "angle", "transform", "opacity", "resizingVertical", "resizingHorizontal", "constraints-horizontal", "constriants-vertical");
  }
  [SUBSCRIBE(UPDATE_CANVAS) + IF("checkChangedValue") + THROTTLE(10)]() {
    var current = this.$context.selection.current;
    if (!current)
      return "";
    this.children.$x.setValue(round(current.offsetX || DEFAULT_SIZE, 100));
    this.children.$y.setValue(round(current.offsetY || DEFAULT_SIZE, 100));
    this.children.$width.setValue(round(current.width || DEFAULT_SIZE, 100));
    this.children.$height.setValue(round(current.height || DEFAULT_SIZE, 100));
    this.children.$opacity.setValue(current.opacity || "1");
    this.children.$rotate.setValue(Length.deg(current.angle).round(100));
  }
  isHideHeader() {
    return true;
  }
  getBodyClassName() {
    return "no-padding";
  }
  getBody() {
    return `
      <div class="position-item" ref="$positionItem">
        <div class="grid-layout">
          ${createComponent("NumberInputEditor", {
      ref: "$x",
      compact: true,
      label: "X",
      key: "x",
      min: -1e5,
      max: 1e5,
      trigger: "enter",
      onchange: "changRangeEditor"
    })}
          ${createComponent("NumberInputEditor", {
      ref: "$y",
      compact: true,
      trigger: "enter",
      label: "Y",
      key: "y",
      min: -1e4,
      max: 1e4,
      onchange: "changRangeEditor"
    })}
        </div>
        <div class="grid-layout">          
          ${createComponent("NumberInputEditor", {
      ref: "$width",
      compact: true,
      trigger: "enter",
      label: "W",
      key: "width",
      min: 0,
      max: 3e3,
      onchange: "changRangeEditor"
    })}
          ${createComponent("NumberInputEditor", {
      ref: "$height",
      compact: true,
      trigger: "enter",
      label: "H",
      key: "height",
      min: 0,
      max: 3e3,
      onchange: "changRangeEditor"
    })}
        </div> 
        <div class="grid-layout">
          ${createComponent("InputRangeEditor", {
      ref: "$rotate",
      key: "rotateZ",
      compact: true,
      label: "rotate_left",
      min: -360,
      max: 360,
      step: 1,
      units: ["deg"],
      onchange: "changeRotate"
    })}
          ${createComponent("NumberInputEditor", {
      ref: "$opacity",
      key: "opacity",
      compact: true,
      label: "opacity",
      min: 0,
      max: 1,
      step: 0.01,
      onchange: "changeSelect"
    })}
        </div>                
      </div>
    `;
  }
  refresh() {
    const current = this.$context.selection.current;
    if (current) {
      this.children.$x.setValue(round(current.offsetX || DEFAULT_SIZE, 100));
      this.children.$y.setValue(round(current.offsetY || DEFAULT_SIZE, 100));
      this.children.$width.setValue(round(current.width || DEFAULT_SIZE, 100));
      this.children.$height.setValue(round(current.height || DEFAULT_SIZE, 100));
      this.children.$opacity.setValue(current.opacity || "1");
      this.children.$rotate.setValue(Length.deg(current.angle));
    }
  }
  [CLICK("$positionItem button[data-command]")](e) {
    const command = e.$dt.data("command");
    console.log(command);
  }
  [SUBSCRIBE_SELF("changRangeEditor")](key, value) {
    this.$commands.executeCommand("setAttribute", "change position or size", this.$context.selection.packByValue({
      [key]: value
    }));
  }
  [SUBSCRIBE_SELF("changeRotate")](key, rotate2) {
    this.$commands.executeCommand("setAttribute", "change rotate", this.$context.selection.packByValue({
      angle: rotate2.value
    }));
  }
  [SUBSCRIBE_SELF("changeSelect")](key, value) {
    this.$commands.executeCommand("setAttribute", `change ${key}`, this.$context.selection.packByValue({
      [key]: value
    }));
  }
}
function position(editor) {
  editor.registerUI("inspector.tab.style", {
    PositionProperty
  });
}
var ProjectProperty$1 = "";
class ProjectProperty extends BaseProperty {
  getTitle() {
    return this.$i18n("project.property.title");
  }
  getClassName() {
    return "full";
  }
  getTools() {
    return `
      <button type='button' ref='$add' data-tooltip="Add a project" data-direction="bottom right">${obj$2.add}</button>
    `;
  }
  [CLICK("$add")]() {
    this.$commands.emit("addProject");
  }
  getBody() {
    return `
      <div class="elf--project-list scrollbar" ref="$projectList"></div>
    `;
  }
  [LOAD("$projectList") + DOMDIFF]() {
    var _a;
    var projects = ((_a = this.$model) == null ? void 0 : _a.projects) || [];
    return projects.map((projectId) => {
      var selected = projectId === this.$context.selection.currentProject.id ? "selected" : "";
      const project2 = this.$model.get(projectId);
      return `
        <div class='project-item ${selected}'>
          <div class='detail'>
            <label data-id='${projectId}'>${project2.name || "New Project"}</label>
            <div class="tools">
              <button type="button" class="remove" data-id="${projectId}" title='Remove'>${obj$2.remove2}</button>
            </div>
          </div>
        </div>
      `;
    });
  }
  [DOUBLECLICK("$projectList .project-item")](e) {
    this.startInputEditing(e.$dt.$("label"));
  }
  modifyDoneInputEditing(input2) {
    this.endInputEditing(input2, (index2, text2) => {
      var project2 = this.$editor.projects[index2];
      if (project2) {
        project2.reset({
          name: text2
        });
      }
    });
  }
  [KEYDOWN("$projectList .project-item label") + ENTER + PREVENT + STOP](e) {
    this.modifyDoneInputEditing(e.$dt);
    return false;
  }
  [FOCUSOUT("$projectList .project-item label") + PREVENT + STOP](e) {
    this.modifyDoneInputEditing(e.$dt);
  }
  [CLICK("$projectList .project-item label")](e) {
    var id = e.$dt.attr("data-id");
    this.commands.executeCommand("refreshSelectionPorject", "change project", id);
    this.nextTick(() => {
      this.refresh();
    });
  }
  [CLICK("$projectList .project-item .remove")](e) {
    var id = e.$dt.attr("data-id");
    this.$commands.executeCommand("removeProject", "remove project", id);
    this.nextTick(() => {
      this.refresh();
    });
  }
  [SUBSCRIBE("refreshProjectList", "refreshAll")]() {
    this.refresh();
  }
}
function project(editor) {
  editor.registerElement({
    ProjectProperty
  });
}
class JSONRenderer {
  constructor(editor) {
    this.editor = editor;
  }
  getDefaultRendererInstance() {
    return this.editor.getRendererInstance("json", "rect");
  }
  getRendererInstance(item) {
    return this.editor.getRendererInstance("json", item.itemType) || this.getDefaultRendererInstance() || item;
  }
  async render(item, renderer) {
    if (!item)
      return;
    const currentRenderer = this.getRendererInstance(item);
    if (currentRenderer) {
      return await currentRenderer.render(item, renderer || this);
    }
  }
  async renderAll(items, renderer) {
    return await Promise.all(items.map(async (it) => {
      return await this.render(it, renderer);
    }));
  }
  async getResourceDataURI() {
  }
}
class ItemRender$1 {
  async render(item, renderer) {
    return await this.toCloneObject(item, renderer);
  }
  async toCloneObject(item, renderer) {
    var json = item.attrs("itemType", "name", "elementType", "type", "visible", "lock", "selected");
    if (item.parent && item.parent.isNot("project")) {
      json.parentId = item.parentId;
    }
    json.referenceId = item.id;
    json.newTargetId = uuid();
    let layers2 = [];
    for (var i = 0, len2 = item.layers.length; i < len2; i++) {
      layers2.push(await renderer.render(item.layers[i], renderer));
    }
    json.layers = layers2;
    return json;
  }
}
class BaseAssetRender extends ItemRender$1 {
  async toCloneObject(item, renderer) {
    return __spreadValues(__spreadValues({}, await super.toCloneObject(item, renderer)), item.attrs("svgfilters", "keyframes"));
  }
}
class GroupRender extends BaseAssetRender {
  async toCloneObject(item, renderer) {
    return __spreadValues(__spreadValues({}, await super.toCloneObject(item, renderer)), item.attrs("layout", "constraintsHorizontal", "constraintsVertical", "resizingMode", "flexDirection", "flexWrap", "flexFlow", "justifyContent", "alignItems", "alignContent", "order", "flexBasis", "flexGrow", "flexShrink", "gap", "gridTemplateRows", "gridTemplateColumns", "gridTemplateAreas", "gridAutoRows", "gridAutoColumns", "gridAutoFlow", "gridColumnStart", "gridColumnEnd", "gridRowStart", "gridRowEnd", "gridColumnGap", "gridRowGap", "animation", "transition", "paddingTop", "paddingRight", "paddingLeft", "paddingBottom"));
  }
}
class MovableRender extends GroupRender {
  async toCloneObject(item, renderer) {
    return __spreadValues(__spreadValues({}, await super.toCloneObject(item, renderer)), item.attrs("x", "y", "right", "bottom", "width", "height", "angle", "transformOrigin"));
  }
}
class DomRender$1 extends MovableRender {
  async toCloneObject(item, renderer) {
    return __spreadProps(__spreadValues(__spreadValues({}, await super.toCloneObject(item, renderer)), item.attrs("position", "rootVariable", "variable", "filter", "backdropFilter", "backgroundColor", "backgroundImage", "textClip", "borderRadius", "border", "boxShadow", "textShadow", "clipPath", "color", "fontSize", "lineHeight", "textAlign", "textTransform", "textDecoration", "letterSpacing", "wordSpacing", "textIndent", "perspectiveOrigin", "transformStyle", "perspective", "mixBlendMode", "overflow", "opacity", "animation", "transition")), {
      selectors: item.selectors.map((selector2) => selector2.clone()),
      svg: item.svg.map((svg) => svg.clone())
    });
  }
}
class ArtBoardRender$2 extends DomRender$1 {
  async toCloneObject(item, renderer) {
    return __spreadValues(__spreadValues({}, await super.toCloneObject(item, renderer)), item.attrs("name"));
  }
}
class LayerRender$1 extends DomRender$1 {
  async toCloneObject(item, renderer) {
    return __spreadValues(__spreadValues({}, await super.toCloneObject(item, renderer)), item.attrs("tagName"));
  }
}
class SVGItemRender$2 extends LayerRender$1 {
  async toCloneObject(item, renderer) {
    return __spreadValues(__spreadValues({}, await super.toCloneObject(item, renderer)), item.attrs("overflow", "stroke", "stroke-width", "svgfilter", "fill", "fill-rule", "fill-opacity", "stroke-linecap", "stroke-linejoin", "stroke-dashoffset", "stroke-dasharray", "text-anchor"));
  }
}
class BooleanPathRender$2 extends SVGItemRender$2 {
  async toCloneObject(item, renderer) {
    return __spreadValues(__spreadValues({}, await super.toCloneObject(item, renderer)), item.attrs("d", "booleanOperation"));
  }
}
class CircleRender$2 extends LayerRender$1 {
}
class IFrameRender$1 extends LayerRender$1 {
  async toCloneObject(item, renderer) {
    return __spreadValues(__spreadValues({}, await super.toCloneObject(item, renderer)), item.attrs("src"));
  }
}
class ImageRender$2 extends LayerRender$1 {
  async toCloneObject(item, renderer) {
    const project2 = item.project;
    const image2 = project2.imageKeys[item.src];
    const src = image2.original;
    return __spreadProps(__spreadValues({}, await super.toCloneObject(item, renderer)), {
      src
    });
  }
}
class AssetRender extends ItemRender$1 {
  async toCloneObject(item, renderer) {
    return __spreadValues(__spreadValues({}, await super.toCloneObject(item, renderer)), item.attrs("colors", "gradients", "svgfilters", "svgimages", "images", "keyframes"));
  }
}
class TimelineRender extends AssetRender {
  async toCloneObject(item, renderer) {
    return __spreadValues(__spreadValues({}, await super.toCloneObject(item, renderer)), item.attrs("timeline"));
  }
}
class ProjectRender$2 extends TimelineRender {
  async toCloneObject(item, renderer) {
    return __spreadValues(__spreadValues({}, await super.toCloneObject(item, renderer)), item.attrs("name", "description", "rootVariable"));
  }
}
class RectRender$2 extends LayerRender$1 {
}
class SplineRender$2 extends SVGItemRender$2 {
  async toCloneObject(item, renderer) {
    return __spreadValues(__spreadValues({}, await super.toCloneObject(item, renderer)), item.attrs("points", "boundary"));
  }
}
class SVGPathRender$2 extends SVGItemRender$2 {
  async toCloneObject(item, renderer) {
    return __spreadValues(__spreadValues({}, await super.toCloneObject(item, renderer)), item.attrs("d"));
  }
}
class SVGPolygonRender$2 extends SVGItemRender$2 {
  async toCloneObject(item, renderer) {
    return __spreadValues(__spreadValues({}, await super.toCloneObject(item, renderer)), item.attrs("count"));
  }
}
class SVGStarRender$2 extends SVGItemRender$2 {
  async toCloneObject(item, renderer) {
    return __spreadValues(__spreadValues({}, await super.toCloneObject(item, renderer)), item.attrs("count", "radius"));
  }
}
class SVGTextPathRender$2 extends SVGItemRender$2 {
  async toCloneObject(item, renderer) {
    return __spreadValues(__spreadValues({}, await super.toCloneObject(item, renderer)), item.attrs("totalLength", "d", "text", "textLength", "lengthAdjust", "startOffset"));
  }
}
class SVGTextRender$2 extends SVGItemRender$2 {
  async toCloneObject(item, renderer) {
    return __spreadValues(__spreadValues({}, await super.toCloneObject(item, renderer)), item.attrs("totalLength", "text", "textLength", "lengthAdjust", "shape-inside"));
  }
}
class TemplateRender$2 extends LayerRender$1 {
  async toCloneObject(item, renderer) {
    return __spreadValues(__spreadValues({}, await super.toCloneObject(item, renderer)), item.attrs("engine", "template", "params"));
  }
}
class TextRender$2 extends LayerRender$1 {
  async toCloneObject(item, renderer) {
    return __spreadValues(__spreadValues({}, await super.toCloneObject(item, renderer)), item.attrs("content"));
  }
}
class VideoRender$2 extends LayerRender$1 {
  async toCloneObject(item, renderer) {
    return __spreadValues(__spreadValues({}, await super.toCloneObject(item, renderer)), item.attrs("src"));
  }
}
function rendererJson(editor) {
  editor.registerRendererType("json", new JSONRenderer(editor));
  editor.registerRenderer("json", "project", new ProjectRender$2());
  editor.registerRenderer("json", "artboard", new ArtBoardRender$2());
  editor.registerRenderer("json", "rect", new RectRender$2());
  editor.registerRenderer("json", "circle", new CircleRender$2());
  editor.registerRenderer("json", "image", new ImageRender$2());
  editor.registerRenderer("json", "template", new TemplateRender$2());
  editor.registerRenderer("json", "iframe", new IFrameRender$1());
  editor.registerRenderer("json", "text", new TextRender$2());
  editor.registerRenderer("json", "video", new VideoRender$2());
  editor.registerRenderer("json", "svg-path", new SVGPathRender$2());
  editor.registerRenderer("json", "boolean-path", new BooleanPathRender$2());
  editor.registerRenderer("json", "polygon", new SVGPolygonRender$2());
  editor.registerRenderer("json", "star", new SVGStarRender$2());
  editor.registerRenderer("json", "spline", new SplineRender$2());
  editor.registerRenderer("json", "svg-text", new SVGTextRender$2());
  editor.registerRenderer("json", "svg-textpath", new SVGTextPathRender$2());
}
class SampleLayer extends LayerModel {
  getDefaultObject(obj2 = {}) {
    return super.getDefaultObject(__spreadValues({
      itemType: "sample",
      name: "New Sample Layer",
      sampleText: "Sample Text 1",
      sampleNumber: 1
    }, obj2));
  }
  get sampleText() {
    return this.get("sampleText");
  }
  set sampleText(value) {
    this.set("sampleText", value);
  }
  get sampleNumber() {
    return this.get("sampleNumber");
  }
  set sampleNumber(value) {
    this.set("sampleNumber", value);
  }
  toCloneObject() {
    return __spreadValues(__spreadValues({}, super.toCloneObject()), this.attrs("sampleText", "sampleNumber"));
  }
  editable(editablePropertyName) {
    switch (editablePropertyName) {
      case "sample":
        return true;
    }
    return super.editable(editablePropertyName);
  }
  getDefaultTitle() {
    return "Sample Layer";
  }
}
class ItemRender {
  constructor(renderer) {
    this.renderer = renderer;
  }
  setRenderer(renderer) {
    this.renderer = renderer;
  }
  getInnerId(item, postfix = "") {
    return item.id + postfix;
  }
  uniqueId(item) {
    return this.renderer.id + "-" + item.id;
  }
}
const Primitive = "SourceGraphic,SourceAlpha,BackgroundImage,BackgroundAlpha,FillPaint,StrokePaint".split(",");
const DEFAULT_ATTRIBUTES = {
  xChannelSelector: true,
  yChannelSelector: true
};
class BaseSVGFilter extends PropertyItem {
  static parse(obj2) {
    var FilterClass = SVGFilterClassName[obj2.type];
    return new FilterClass(obj2);
  }
  hasLight() {
    return false;
  }
  isLight() {
    return false;
  }
  isSource() {
    return false;
  }
  getDefaultObject(obj2 = {}) {
    var id = uuidShort();
    return super.getDefaultObject(__spreadValues({
      itemType: "svgfilter",
      id,
      in: [],
      bound: { x: 100, y: 100, targetX: 0, targetY: 0 },
      connected: []
    }, obj2));
  }
  getInCount() {
    return 0;
  }
  setIn(index2, target) {
    this.json.in[index2] = { id: target.id, type: target.type };
  }
  setConnected(target) {
    var f = this.json.connected.filter((c2) => c2.id === target.id);
    if (f.length === 0) {
      this.json.connected.push({ id: target.id });
    }
  }
  convert(json) {
    if (typeof json.in === "string") {
      json.in = JSON.parse(json.in);
    }
    if (typeof json.bound === "string") {
      json.bound = JSON.parse(json.bound);
    }
    if (typeof json.connected === "string") {
      json.connected = JSON.parse(json.connected);
    }
    return json;
  }
  toCloneObject() {
    return __spreadValues(__spreadValues({}, super.toCloneObject()), this.attrs("id", "in", "bound", "connected"));
  }
  getDefaultAttribute() {
    var list2 = [];
    if (this.json.connected.length) {
      list2.push(`result="${this.json.id}result"`);
    }
    Object.keys(DEFAULT_ATTRIBUTES).filter((key) => {
      return !!this.json[key];
    }).forEach((key) => {
      list2.push(`${key}="${this.json[key]}"`);
    });
    return list2.join(" ") + " " + this.getSourceInAttribute();
  }
  hasInIndex() {
    return false;
  }
  getSourceInAttribute(inList) {
    return (inList || this.json.in).map((it, index2) => {
      if (!it)
        return "";
      var indexString = index2 === 0 ? "" : index2 + 1 + "";
      if (!this.hasInIndex()) {
        indexString = "";
      }
      if (Primitive.includes(it.type)) {
        return `in${indexString}="${it.type}"`;
      }
      return `in${indexString}="${it.id}result"`;
    }).join(" ");
  }
  toString() {
    var { type, value } = this.json;
    return `<fe${type} value="${value}" ${this.getDefaultAttribute()} />`;
  }
}
class SourceSVGFilter extends BaseSVGFilter {
  getDefaultObject(obj2 = {}) {
    return super.getDefaultObject(__spreadValues({
      type: "Source"
    }, obj2));
  }
  isSource() {
    return true;
  }
  toString() {
    return "";
  }
}
class BackgroundAlphaSVGFilter extends SourceSVGFilter {
  getDefaultObject() {
    return super.getDefaultObject({
      type: "BackgroundAlpha"
    });
  }
}
class BackgroundImageSVGFilter extends SourceSVGFilter {
  getDefaultObject() {
    return super.getDefaultObject({
      type: "BackgroundImage"
    });
  }
}
class BlendSVGFilter extends BaseSVGFilter {
  getDefaultObject() {
    return super.getDefaultObject({
      type: "Blend",
      mode: BlendSVGFilter.spec.mode.defaultValue
    });
  }
  getInCount() {
    return 2;
  }
  toString() {
    var { mode } = this.json;
    return `<feBlend ${OBJECT_TO_PROPERTY({
      mode
    })} ${this.getDefaultAttribute()} />`;
  }
  hasInIndex() {
    return true;
  }
}
BlendSVGFilter.spec = {
  mode: {
    title: "mode",
    inputType: "blend",
    defaultValue: "normal"
  }
};
class ColorMatrixSVGFilter extends BaseSVGFilter {
  getDefaultObject() {
    return super.getDefaultObject({
      type: "ColorMatrix",
      values: ColorMatrixSVGFilter.spec.values.defaultValue
    });
  }
  getInCount() {
    return 1;
  }
  toString() {
    var { values } = this.json;
    var valueString = values.join(" ");
    return `<feColorMatrix type="matrix" values="${valueString}"  ${this.getDefaultAttribute()} />`;
  }
}
ColorMatrixSVGFilter.spec = {
  values: {
    title: "values",
    inputType: "color-matrix",
    column: 5,
    defaultValue: [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0]
  }
};
class ComponentTransferSVGFilter extends BaseSVGFilter {
  getDefaultObject() {
    return super.getDefaultObject({
      type: "ComponentTransfer",
      r: ComponentTransferSVGFilter.spec.r.defaultValue,
      g: ComponentTransferSVGFilter.spec.g.defaultValue,
      b: ComponentTransferSVGFilter.spec.b.defaultValue,
      a: ComponentTransferSVGFilter.spec.a.defaultValue
    });
  }
  getInCount() {
    return 1;
  }
  parse(value) {
    var [type, ...values] = value.split(" ");
    if (type === "table" || type === "discrete") {
      return { type, tableValues: values.join(" ") };
    }
    if (type === "linear") {
      var [slop, intercept] = values;
      return { type, slop, intercept };
    } else if (type === "gamma") {
      var [amplitude, exponent, offset] = values;
      return { type, amplitude, exponent, offset };
    }
    return { type };
  }
  toString() {
    var { r, g, b, a } = this.json;
    r = this.parse(r);
    g = this.parse(g);
    b = this.parse(b);
    a = this.parse(a);
    return `<feComponentTransfer ${this.getDefaultAttribute()} >
      ${r && `<feFuncR ${OBJECT_TO_PROPERTY(r)} />`}
      ${g && `<feFuncG ${OBJECT_TO_PROPERTY(g)} />`}
      ${b && `<feFuncB ${OBJECT_TO_PROPERTY(b)} />`}
      ${a && `<feFuncA ${OBJECT_TO_PROPERTY(a)} />`}
    </feComponentTransfe>`;
  }
}
ComponentTransferSVGFilter.spec = {
  r: {
    title: "R",
    inputType: "FuncFilter",
    defaultValue: "identity"
  },
  g: {
    title: "G",
    inputType: "FuncFilter",
    defaultValue: "identity"
  },
  b: {
    title: "B",
    inputType: "FuncFilter",
    defaultValue: "identity"
  },
  a: {
    title: "A",
    inputType: "FuncFilter",
    defaultValue: "identity"
  }
};
class CompositeSVGFilter extends BaseSVGFilter {
  getDefaultObject() {
    return super.getDefaultObject({
      type: "Composite",
      operator: CompositeSVGFilter.spec.operator.defaultValue,
      k1: CompositeSVGFilter.spec.k1.defaultValue,
      k2: CompositeSVGFilter.spec.k2.defaultValue,
      k3: CompositeSVGFilter.spec.k3.defaultValue,
      k4: CompositeSVGFilter.spec.k4.defaultValue
    });
  }
  getInCount() {
    return 2;
  }
  toString() {
    var { operator, k1, k2, k3, k4 } = this.json;
    var kNumbers = "";
    if (operator === "arithmetic") {
      kNumbers = ` k1="${k1}" k2="${k2}" k3="${k3}" k4="${k4}" `;
    }
    return `<feComposite operator="${operator}" ${kNumbers}  ${this.getDefaultAttribute()} />`;
  }
  hasInIndex() {
    return true;
  }
}
CompositeSVGFilter.spec = {
  operator: {
    title: "operator",
    inputType: "select",
    options: "over,in,out,atop,xor,arithmetic",
    defaultValue: "over"
  },
  k1: {
    title: "k1",
    inputType: "number-range",
    min: 0,
    max: 1,
    step: 0.01,
    defaultValue: Length.number(0)
  },
  k2: {
    title: "k2",
    inputType: "number-range",
    min: 0,
    max: 1,
    step: 0.01,
    defaultValue: Length.number(0)
  },
  k3: {
    title: "k3",
    inputType: "number-range",
    min: 0,
    max: 1,
    step: 0.01,
    defaultValue: Length.number(0)
  },
  k4: {
    title: "k4",
    inputType: "number-range",
    min: 0,
    max: 1,
    step: 0.01,
    defaultValue: Length.number(0)
  }
};
class ConvolveMatrixSVGFilter extends BaseSVGFilter {
  getDefaultObject() {
    return super.getDefaultObject({
      type: "ConvolveMatrix",
      kernelMatrix: ConvolveMatrixSVGFilter.spec.kernelMatrix.defaultValue
    });
  }
  getInCount() {
    return 1;
  }
  toString() {
    var { kernelMatrix } = this.json;
    var valueString = kernelMatrix.join(" ");
    return `<feConvolveMatrix kernelMatrix="${valueString}"  ${this.getDefaultAttribute()} />`;
  }
}
ConvolveMatrixSVGFilter.spec = {
  kernelMatrix: {
    title: "kernelMatrix",
    inputType: "input-array",
    column: 3,
    defaultValue: [1, 0, 0, 0, 1, 0, 0, 0, 1]
  }
};
class DiffuseLightingSVGFilter extends BaseSVGFilter {
  getDefaultObject() {
    return super.getDefaultObject({
      type: "DiffuseLighting",
      surfaceScale: DiffuseLightingSVGFilter.spec.surfaceScale.defaultValue,
      lightingColor: DiffuseLightingSVGFilter.spec.lightingColor.defaultValue,
      diffuseConstant: DiffuseLightingSVGFilter.spec.diffuseConstant.defaultValue,
      lightInfo: ""
    });
  }
  toCloneObject() {
    return __spreadValues(__spreadValues({}, super.toCloneObject()), this.attrs("surfaceScale", "lightingColor", "diffuseConstant", "lightInfo"));
  }
  hasLight() {
    return true;
  }
  getInCount() {
    return 1;
  }
  toString() {
    var { surfaceScale, diffuseConstant, lightingColor } = this.json;
    return `<feDiffuseLighting ${OBJECT_TO_PROPERTY({
      surfaceScale,
      diffuseConstant,
      "lighting-color": lightingColor
    })}  ${this.getDefaultAttribute()} >
      ${this.json.lightInfo}
    </feDiffuseLighting>`;
  }
}
DiffuseLightingSVGFilter.spec = {
  surfaceScale: {
    title: "surfaceScale",
    inputType: "number-range",
    min: 0,
    max: 100,
    step: 1,
    defaultValue: Length.number(1)
  },
  diffuseConstant: {
    title: "diffuseConstant",
    inputType: "number-range",
    min: 0,
    max: 100,
    step: 1,
    defaultValue: Length.number(1)
  },
  lightingColor: {
    title: "Lighting Color",
    inputType: "color",
    defaultValue: "rgba(0, 0, 0, 1)"
  }
};
class DisplacementMapSVGFilter extends BaseSVGFilter {
  getDefaultObject() {
    return super.getDefaultObject({
      type: "DisplacementMap",
      scale: DisplacementMapSVGFilter.spec.scale.defaultValue
    });
  }
  getInCount() {
    return 2;
  }
  convert(obj2) {
    obj2.scale = Length.parse(obj2.scale);
    return obj2;
  }
  toString() {
    var { scale: scale2 } = this.json;
    var scaleOption = scale2.value ? `scale="${scale2}"` : "";
    return `<feDisplacementMap ${scaleOption}  ${this.getDefaultAttribute()} />`;
  }
  hasInIndex() {
    return true;
  }
}
DisplacementMapSVGFilter.spec = {
  scale: {
    title: "scale",
    inputType: "number-range",
    min: 0,
    max: 5e3,
    step: 1,
    defaultValue: Length.number(0)
  }
};
class DistantLightSVGFilter extends BaseSVGFilter {
  getDefaultObject() {
    return super.getDefaultObject({
      type: "DistantLight",
      azimuth: DistantLightSVGFilter.spec.azimuth.defaultValue,
      elevation: DistantLightSVGFilter.spec.elevation.defaultValue
    });
  }
  isLight() {
    return true;
  }
  toString() {
    return "";
  }
  toLightString() {
    var { azimuth, elevation } = this.json;
    return `<feDistantLight ${OBJECT_TO_PROPERTY({
      azimuth,
      elevation
    })} />`;
  }
}
DistantLightSVGFilter.spec = {
  azimuth: {
    title: "azimuth",
    inputType: "number-range",
    min: 0,
    max: 1e3,
    step: 1,
    defaultValue: Length.number(0)
  },
  elevation: {
    title: "elevation",
    inputType: "number-range",
    min: 0,
    max: 1e3,
    step: 1,
    defaultValue: Length.number(0)
  }
};
class DropShadowSVGFilter extends BaseSVGFilter {
  getDefaultObject() {
    return super.getDefaultObject({
      type: "DropShadow",
      dx: DropShadowSVGFilter.spec.dx.defaultValue,
      dy: DropShadowSVGFilter.spec.dy.defaultValue,
      stdDeviation: DropShadowSVGFilter.spec.stdDeviation.defaultValue,
      color: DropShadowSVGFilter.spec.color.defaultValue,
      opacity: DropShadowSVGFilter.spec.opacity.defaultValue
    });
  }
  getInCount() {
    return 1;
  }
  toString() {
    var { dx, dy, stdDeviation, color: color2, opacity: opacity2 } = this.json;
    return `<feDropShadow ${OBJECT_TO_PROPERTY({
      dx,
      dy,
      stdDeviation,
      "flood-color": color2,
      "flood-opacity": opacity2
    })}  ${this.getDefaultAttribute()} />`;
  }
}
DropShadowSVGFilter.spec = {
  dx: {
    title: "dx",
    inputType: "number-range",
    min: 0,
    max: 1e3,
    step: 1,
    defaultValue: Length.number(0)
  },
  dy: {
    title: "dy",
    inputType: "number-range",
    min: 0,
    max: 1e3,
    step: 1,
    defaultValue: Length.number(0)
  },
  stdDeviation: {
    title: "stdDeviation",
    inputType: "number-range",
    min: 0,
    max: 1e3,
    step: 0.1,
    defaultValue: Length.number(0)
  },
  opacity: {
    title: "opacity",
    inputType: "number-range",
    min: 0,
    max: 1,
    step: 0.01,
    defaultValue: Length.number(1)
  },
  color: {
    title: "color",
    inputType: "color",
    defaultValue: "rgba(0, 0, 0, 1)"
  }
};
class FillPaintSVGFilter extends SourceSVGFilter {
  getDefaultObject() {
    return super.getDefaultObject({
      type: "FillPaint"
    });
  }
}
class FloodSVGFilter extends BaseSVGFilter {
  getDefaultObject() {
    return super.getDefaultObject({
      type: "Flood",
      x: FloodSVGFilter.spec.x.defaultValue,
      y: FloodSVGFilter.spec.y.defaultValue,
      width: FloodSVGFilter.spec.width.defaultValue,
      height: FloodSVGFilter.spec.height.defaultValue,
      color: FloodSVGFilter.spec.color.defaultValue,
      opacity: FloodSVGFilter.spec.opacity.defaultValue
    });
  }
  convert(json) {
    json.x = Length.parse(json.x);
    json.y = Length.parse(json.y);
    json.width = Length.parse(json.width);
    json.height = Length.parse(json.height);
    return json;
  }
  toString() {
    const { opacity: opacity2, color: color2, x, y, width: width2, height: height2 } = this.json;
    return `<feFlood ${OBJECT_TO_PROPERTY({
      x,
      y,
      width: width2,
      height: height2
    })} flood-opacity="${opacity2}" flood-color="${color2}" ${this.getDefaultAttribute()} />`;
  }
}
FloodSVGFilter.spec = {
  x: {
    title: "X",
    inputType: "number-range",
    min: 0,
    max: 1e3,
    step: 1,
    defaultValue: Length.number(0)
  },
  y: {
    title: "Y",
    inputType: "number-range",
    min: 0,
    max: 1e3,
    step: 1,
    defaultValue: Length.number(0)
  },
  width: {
    title: "width",
    inputType: "number-range",
    min: 0,
    max: 1e3,
    step: 1,
    defaultValue: Length.number(0)
  },
  height: {
    title: "height",
    inputType: "number-range",
    min: 0,
    max: 1e3,
    step: 1,
    defaultValue: Length.number(0)
  },
  opacity: {
    title: "opacity",
    inputType: "number-range",
    min: 0,
    max: 1,
    step: 0.01,
    defaultValue: Length.number(0)
  },
  color: {
    title: "color",
    inputType: "color",
    defaultValue: "rgba(0, 0, 0, 1)"
  }
};
class GaussianBlurSVGFilter extends BaseSVGFilter {
  getDefaultObject() {
    return super.getDefaultObject({
      type: "GaussianBlur",
      stdDeviationX: GaussianBlurSVGFilter.spec.stdDeviationX.defaultValue,
      stdDeviationY: GaussianBlurSVGFilter.spec.stdDeviationY.defaultValue,
      edgeMode: GaussianBlurSVGFilter.spec.edgeMode.defaultValue
    });
  }
  getInCount() {
    return 1;
  }
  convert(obj2) {
    obj2.stdDeviationX = Length.parse(obj2.stdDeviationX);
    obj2.stdDeviationY = Length.parse(obj2.stdDeviationY);
    return obj2;
  }
  toString() {
    var { stdDeviationX, stdDeviationY, edgeMode } = this.json;
    var stdDeviation = `${stdDeviationX} ${stdDeviationY}`;
    if (stdDeviationX === stdDeviationY) {
      stdDeviation = stdDeviationX;
    }
    return `<feGaussianBlur  stdDeviation="${stdDeviation}" edgeMode="${edgeMode}"  ${this.getDefaultAttribute()} />`;
  }
}
GaussianBlurSVGFilter.spec = {
  stdDeviationX: {
    title: "X",
    inputType: "number-range",
    min: 0,
    max: 100,
    step: 1,
    defaultValue: Length.number(0)
  },
  stdDeviationY: {
    title: "Y",
    inputType: "number-range",
    min: 0,
    max: 100,
    step: 1,
    defaultValue: Length.number(0)
  },
  edgeMode: {
    title: "edge",
    inputType: "select",
    options: "none,duplicate,wrap",
    defaultValue: "none"
  }
};
class HueRotateSVGFilter extends BaseSVGFilter {
  getDefaultObject() {
    return super.getDefaultObject({
      type: "HueRotate",
      values: HueRotateSVGFilter.spec.values.defaultValue
    });
  }
  getInCount() {
    return 1;
  }
  toString() {
    var { values } = this.json;
    return `<feColorMatrix type="hueRotate" values="${values}"  ${this.getDefaultAttribute()} />`;
  }
}
HueRotateSVGFilter.spec = {
  values: {
    title: "values",
    inputType: "number-range",
    min: 0,
    max: 360,
    step: 0.1,
    defaultValue: Length.number(0)
  }
};
class ImageSVGFilter extends BaseSVGFilter {
  getDefaultObject() {
    return super.getDefaultObject({
      type: "Image",
      x: ImageSVGFilter.spec.x.defaultValue,
      y: ImageSVGFilter.spec.y.defaultValue,
      width: ImageSVGFilter.spec.width.defaultValue,
      height: ImageSVGFilter.spec.height.defaultValue,
      src: ImageSVGFilter.spec.src.defaultValue,
      alignment: ImageSVGFilter.spec.alignment.defaultValue,
      scaleing: ImageSVGFilter.spec.scaleing.defaultValue
    });
  }
  convert(json) {
    json.x = Length.parse(json.x);
    json.y = Length.parse(json.y);
    json.width = Length.parse(json.width);
    json.height = Length.parse(json.height);
    return json;
  }
  toString() {
    const { src, x, y, width: width2, height: height2, alignment: alignment2, scaleing } = this.json;
    return `<feImage ${OBJECT_TO_PROPERTY({
      x,
      y,
      width: width2,
      height: height2,
      "xlink:href": src,
      preserveAspectRatio: `${alignment2} ${scaleing}`
    })} ${this.getDefaultAttribute()} />`;
  }
}
ImageSVGFilter.spec = {
  x: {
    title: "X",
    inputType: "number-range",
    min: 0,
    max: 1e3,
    step: 1,
    defaultValue: Length.number(0)
  },
  y: {
    title: "Y",
    inputType: "number-range",
    min: 0,
    max: 1e3,
    step: 1,
    defaultValue: Length.number(0)
  },
  width: {
    title: "width",
    inputType: "number-range",
    min: 0,
    max: 1e3,
    step: 1,
    defaultValue: Length.number(0)
  },
  height: {
    title: "height",
    inputType: "number-range",
    min: 0,
    max: 1e3,
    step: 1,
    defaultValue: Length.number(0)
  },
  alignment: {
    title: "alignment",
    inputType: "select",
    options: "xMinYMin,xMidYMin,xMaxYMin,xMinYMid,xMidYMid,xMaxYMid,xMinYMax,xMidYMax,xMaxYMax",
    defaultValue: "xMidYMid"
  },
  scaleing: {
    title: "scaleing",
    inputType: "select",
    options: "meet,slice",
    defaultValue: "meet"
  },
  src: {
    title: "Image",
    inputType: "ImageSelectEditor",
    defaultValue: ""
  }
};
class LuminanceAlphaSVGFilter extends BaseSVGFilter {
  getDefaultObject() {
    return super.getDefaultObject({
      type: "LuminanceAlpha"
    });
  }
  getInCount() {
    return 1;
  }
  toString() {
    return `<feColorMatrix type="luminanceToAlpha" ${this.getDefaultAttribute()} />`;
  }
}
LuminanceAlphaSVGFilter.spec = {};
class MergeSVGFilter extends BaseSVGFilter {
  getDefaultObject() {
    return super.getDefaultObject({
      type: "Merge"
    });
  }
  getInCount() {
    return 3;
  }
  getDefaultAttribute() {
    var list2 = [];
    if (this.json.connected.length) {
      list2.push(`result="${this.json.id}result"`);
    }
    return list2.join(" ");
  }
  toString() {
    var { in: inList } = this.json;
    return `
    <feMerge  ${this.getDefaultAttribute()} >
      ${inList.map((it) => {
      return `<feMergeNode ${this.getSourceInAttribute([it])} />`;
    }).join("")}
    </feMerge>`;
  }
}
MergeSVGFilter.spec = {};
class MorphologySVGFilter extends BaseSVGFilter {
  getDefaultObject() {
    return super.getDefaultObject({
      type: "Morphology",
      operator: MorphologySVGFilter.spec.operator.defaultValue,
      radius: MorphologySVGFilter.spec.radius.defaultValue
    });
  }
  getInCount() {
    return 1;
  }
  toString() {
    var { operator, radius } = this.json;
    return `<feMorphology operator="${operator}" radius="${radius}"  ${this.getDefaultAttribute()} />`;
  }
}
MorphologySVGFilter.spec = {
  operator: {
    title: "Operator",
    inputType: "select",
    options: "erode,dilate",
    defaultValue: "erode"
  },
  radius: {
    title: "Radius",
    inputType: "number-range",
    min: 0,
    max: 100,
    step: 1,
    defaultValue: Length.number(0)
  }
};
class OffsetSVGFilter extends BaseSVGFilter {
  getDefaultObject() {
    return super.getDefaultObject({
      type: "Offset",
      dx: OffsetSVGFilter.spec.dx.defaultValue,
      dy: OffsetSVGFilter.spec.dy.defaultValue
    });
  }
  getInCount() {
    return 1;
  }
  toString() {
    var { dx, dy } = this.json;
    return `<feOffset 
      ${OBJECT_TO_PROPERTY({
      dx,
      dy
    })}  ${this.getDefaultAttribute()} />`;
  }
}
OffsetSVGFilter.spec = {
  dx: {
    title: "dx",
    inputType: "number-range",
    min: 0,
    max: 1e3,
    step: 1,
    defaultValue: Length.number(0)
  },
  dy: {
    title: "dy",
    inputType: "number-range",
    min: 0,
    max: 1e3,
    step: 1,
    defaultValue: Length.number(0)
  }
};
class PointLightSVGFilter extends BaseSVGFilter {
  getDefaultObject() {
    return super.getDefaultObject({
      type: "PointLight",
      x: PointLightSVGFilter.spec.x.defaultValue,
      y: PointLightSVGFilter.spec.y.defaultValue,
      z: PointLightSVGFilter.spec.z.defaultValue
    });
  }
  isLight() {
    return true;
  }
  toString() {
    return "";
  }
  toLightString() {
    var { x, y, z } = this.json;
    return `<fePointLight ${OBJECT_TO_PROPERTY({
      x,
      y,
      z
    })} />`;
  }
}
PointLightSVGFilter.spec = {
  x: {
    title: "x",
    inputType: "number-range",
    min: 0,
    max: 1e3,
    step: 1,
    defaultValue: Length.number(0)
  },
  y: {
    title: "y",
    inputType: "number-range",
    min: 0,
    max: 1e3,
    step: 1,
    defaultValue: Length.number(0)
  },
  z: {
    title: "z",
    inputType: "number-range",
    min: 0,
    max: 1e3,
    step: 1,
    defaultValue: Length.number(0)
  }
};
class RotaMatrixSVGFilter extends BaseSVGFilter {
  getDefaultObject() {
    return super.getDefaultObject({
      type: "RotaMatrix",
      hueRotate: RotaMatrixSVGFilter.spec.hueRotate.defaultValue
    });
  }
  convert(json) {
    json.hueRotate = Length.parse(json.hueRotate);
    return json;
  }
  toString() {
    var { id, hueRotate } = this.json;
    return `
      <feColorMatrix type="hueRotate" result="romatrix-${id}"  values="${hueRotate}"/>
      <feColorMatrix type="matrix" in="romatrix-${id}" in2="SourceGraphic"  ${this.getDefaultAttribute()} values="-1 2 -3 0 -.5 2 1 0 0 0 0 3 1 0 0 0 0 1 1 0"/>
    `;
  }
}
RotaMatrixSVGFilter.spec = {
  hueRotate: {
    title: "hue-rotate",
    inputType: "number-range",
    min: 0,
    max: 360,
    step: 1,
    defaultValue: Length.number(0)
  }
};
class SaturateSVGFilter extends BaseSVGFilter {
  getDefaultObject() {
    return super.getDefaultObject({
      type: "Saturate",
      values: SaturateSVGFilter.spec.values.defaultValue
    });
  }
  getInCount() {
    return 1;
  }
  toString() {
    var { values } = this.json;
    return `<feColorMatrix type="saturate" values="${values}"  ${this.getDefaultAttribute()} />`;
  }
}
SaturateSVGFilter.spec = {
  values: {
    title: "values",
    inputType: "number-range",
    min: -1,
    max: 1,
    step: 0.01,
    defaultValue: Length.number(0)
  }
};
class SourceAlphaSVGFilter extends SourceSVGFilter {
  getDefaultObject() {
    return super.getDefaultObject({
      type: "SourceAlpha"
    });
  }
}
class SourceGraphicSVGFilter extends SourceSVGFilter {
  getDefaultObject() {
    return super.getDefaultObject({
      type: "SourceGraphic"
    });
  }
}
class SpecularLightingSVGFilter extends BaseSVGFilter {
  getDefaultObject() {
    return super.getDefaultObject({
      type: "SpecularLighting",
      surfaceScale: SpecularLightingSVGFilter.spec.surfaceScale.defaultValue,
      lightingColor: SpecularLightingSVGFilter.spec.lightingColor.defaultValue,
      specularConstant: SpecularLightingSVGFilter.spec.specularConstant.defaultValue,
      specularExponent: SpecularLightingSVGFilter.spec.specularExponent.defaultValue,
      lightInfo: ""
    });
  }
  toCloneObject() {
    return __spreadValues(__spreadValues({}, super.toCloneObject()), this.attrs("surfaceScale", "lightingColor", "specularConstant", "specularExponent", "lightInfo"));
  }
  hasLight() {
    return true;
  }
  getInCount() {
    return 1;
  }
  toString() {
    var { surfaceScale, specularConstant, specularExponent, lightingColor } = this.json;
    return `<feSpecularLighting ${OBJECT_TO_PROPERTY({
      surfaceScale,
      specularConstant,
      specularExponent,
      "lighting-color": lightingColor
    })}  ${this.getDefaultAttribute()} >
      ${this.json.lightInfo}
    </feSpecularLighting>`;
  }
  getSourceInAttribute() {
    return "";
  }
}
SpecularLightingSVGFilter.spec = {
  surfaceScale: {
    title: "surfaceScale",
    inputType: "number-range",
    min: 0,
    max: 100,
    step: 1,
    defaultValue: Length.number(1)
  },
  specularConstant: {
    title: "Constant",
    inputType: "number-range",
    min: 0,
    max: 100,
    step: 1,
    defaultValue: Length.number(1)
  },
  specularExponent: {
    title: "Exponent",
    inputType: "number-range",
    min: 0,
    max: 100,
    step: 1,
    defaultValue: Length.number(1)
  },
  lightingColor: {
    title: "Lighting Color",
    inputType: "color",
    defaultValue: "rgba(0, 0, 0, 1)"
  }
};
class SpotLightSVGFilter extends BaseSVGFilter {
  getDefaultObject() {
    return super.getDefaultObject({
      type: "SpotLight",
      x: SpotLightSVGFilter.spec.x.defaultValue,
      y: SpotLightSVGFilter.spec.x.defaultValue,
      z: SpotLightSVGFilter.spec.x.defaultValue,
      pointsAtX: SpotLightSVGFilter.spec.pointsAtX.defaultValue,
      pointsAtY: SpotLightSVGFilter.spec.pointsAtY.defaultValue,
      pointsAtZ: SpotLightSVGFilter.spec.pointsAtZ.defaultValue,
      specularExponent: SpotLightSVGFilter.spec.specularExponent.defaultValue,
      limitingConeAngle: SpotLightSVGFilter.spec.limitingConeAngle.defaultValue
    });
  }
  isLight() {
    return true;
  }
  toString() {
  }
  toLightString() {
    var {
      x,
      y,
      z,
      pointsAtX,
      pointsAtY,
      pointsAtZ,
      specularExponent,
      limitingConeAngle
    } = this.json;
    return `<feSpotLight ${OBJECT_TO_PROPERTY({
      x,
      y,
      z,
      pointsAtX,
      pointsAtY,
      pointsAtZ,
      specularExponent,
      limitingConeAngle
    })} />`;
  }
}
SpotLightSVGFilter.spec = {
  x: {
    title: "x",
    inputType: "number-range",
    min: 0,
    max: 1e3,
    step: 1,
    defaultValue: Length.number(0)
  },
  y: {
    title: "y",
    inputType: "number-range",
    min: 0,
    max: 1e3,
    step: 1,
    defaultValue: Length.number(0)
  },
  z: {
    title: "z",
    inputType: "number-range",
    min: 0,
    max: 1e3,
    step: 1,
    defaultValue: Length.number(0)
  },
  pointsAtX: {
    title: "pointsAtX",
    inputType: "number-range",
    min: 0,
    max: 1e3,
    step: 1,
    defaultValue: Length.number(0)
  },
  pointsAtY: {
    title: "pointsAtY",
    inputType: "number-range",
    min: 0,
    max: 1e3,
    step: 1,
    defaultValue: Length.number(0)
  },
  pointsAtZ: {
    title: "pointsAtZ",
    inputType: "number-range",
    min: 0,
    max: 1e3,
    step: 1,
    defaultValue: Length.number(0)
  },
  specularExponent: {
    title: "specularExponent",
    inputType: "number-range",
    min: 0,
    max: 100,
    step: 1,
    defaultValue: Length.number(1)
  },
  limitingConeAngle: {
    title: "limitingConeAngle",
    inputType: "number-range",
    min: 0,
    max: 100,
    step: 1,
    defaultValue: Length.number(1)
  }
};
class StrokePaintSVGFilter extends SourceSVGFilter {
  getDefaultObject() {
    return super.getDefaultObject({
      type: "StrokePaint"
    });
  }
}
class TileSVGFilter extends BaseSVGFilter {
  getDefaultObject() {
    return super.getDefaultObject({
      type: "Tile",
      x: TileSVGFilter.spec.x.defaultValue,
      y: TileSVGFilter.spec.y.defaultValue,
      width: TileSVGFilter.spec.width.defaultValue,
      height: TileSVGFilter.spec.height.defaultValue
    });
  }
  getInCount() {
    return 1;
  }
  convert(json) {
    json.x = Length.parse(json.x);
    json.y = Length.parse(json.y);
    json.width = Length.parse(json.width);
    json.height = Length.parse(json.height);
    return json;
  }
  toString() {
    const { x, y, width: width2, height: height2 } = this.json;
    return `<feTile ${OBJECT_TO_PROPERTY({
      x,
      y,
      width: width2,
      height: height2
    })} ${this.getDefaultAttribute()} />`;
  }
}
TileSVGFilter.spec = {
  x: {
    title: "X",
    inputType: "number-range",
    min: 0,
    max: 1e3,
    step: 1,
    defaultValue: Length.number(0)
  },
  y: {
    title: "Y",
    inputType: "number-range",
    min: 0,
    max: 1e3,
    step: 1,
    defaultValue: Length.number(0)
  },
  width: {
    title: "width",
    inputType: "number-range",
    min: 0,
    max: 1e3,
    step: 1,
    defaultValue: Length.number(0)
  },
  height: {
    title: "height",
    inputType: "number-range",
    min: 0,
    max: 1e3,
    step: 1,
    defaultValue: Length.number(0)
  }
};
class TurbulenceSVGFilter extends BaseSVGFilter {
  getDefaultObject() {
    return super.getDefaultObject({
      type: "Turbulence",
      filterType: TurbulenceSVGFilter.spec.filterType.defaultValue,
      baseFrequency: TurbulenceSVGFilter.spec.baseFrequency.defaultValue,
      numOctaves: TurbulenceSVGFilter.spec.numOctaves.defaultValue,
      seed: TurbulenceSVGFilter.spec.seed.defaultValue
    });
  }
  convert(obj2) {
    obj2.baseFrequency = Length.parse(obj2.baseFrequency);
    obj2.numOctaves = Length.parse(obj2.numOctaves);
    obj2.seed = Length.parse(obj2.seed);
    return obj2;
  }
  toString() {
    var { filterType, baseFrequency, numOctaves, seed } = this.json;
    return `<feTurbulence ${OBJECT_TO_PROPERTY({
      type: filterType,
      baseFrequency,
      numOctaves,
      seed
    })}   ${this.getDefaultAttribute()} />`;
  }
}
TurbulenceSVGFilter.spec = {
  filterType: {
    title: "Type",
    inputType: "select",
    options: "fractalNoise,turbulence",
    defaultValue: "turbulence"
  },
  baseFrequency: {
    title: "Frequency",
    inputType: "number-range",
    min: 0,
    max: 1,
    step: 0.01,
    defaultValue: Length.number(0)
  },
  numOctaves: {
    title: "Octaves",
    inputType: "number-range",
    min: 1,
    max: 10,
    step: 1,
    defaultValue: Length.number(1)
  },
  seed: {
    title: "Seed",
    inputType: "number-range",
    min: 0,
    max: 1e4,
    step: 1,
    defaultValue: Length.number(0)
  }
};
const SVG_FILTER_COMMON_ATTRIBUTES = ["result"];
class SVGFilter extends PropertyItem {
  static parse(obj2) {
    var FilterClass = SVGFilterClassName[obj2.type];
    return new FilterClass(obj2);
  }
  getDefaultObject(obj2 = {}) {
    return super.getDefaultObject(__spreadValues({
      itemType: "svgfilter",
      result: ""
    }, obj2));
  }
  getDefaultAttribute() {
    return SVG_FILTER_COMMON_ATTRIBUTES.map((key) => {
      return `${key}="${this.json[key]}"`;
    }).join(" ");
  }
  toString() {
    var { type, value } = this.json;
    return `<fe${type} value="${value}" ${this.getDefaultAttribute()} />`;
  }
}
const SVGFilterClassName = {
  Image: ImageSVGFilter,
  Tile: TileSVGFilter,
  Saturate: SaturateSVGFilter,
  HueRotate: HueRotateSVGFilter,
  LuminanceAlpha: LuminanceAlphaSVGFilter,
  DropShadow: DropShadowSVGFilter,
  SourceGraphic: SourceGraphicSVGFilter,
  SourceAlpha: SourceAlphaSVGFilter,
  BackgroundImage: BackgroundImageSVGFilter,
  BackgroundAlpha: BackgroundAlphaSVGFilter,
  FillPaint: FillPaintSVGFilter,
  StrokePaint: StrokePaintSVGFilter,
  ComponentTransfer: ComponentTransferSVGFilter,
  DistantLight: DistantLightSVGFilter,
  PointLight: PointLightSVGFilter,
  SpotLight: SpotLightSVGFilter,
  DiffuseLighting: DiffuseLightingSVGFilter,
  SpecularLighting: SpecularLightingSVGFilter,
  Blend: BlendSVGFilter,
  Offset: OffsetSVGFilter,
  RotaMatrix: RotaMatrixSVGFilter,
  GaussianBlur: GaussianBlurSVGFilter,
  Flood: FloodSVGFilter,
  Merge: MergeSVGFilter,
  Composite: CompositeSVGFilter,
  Morphology: MorphologySVGFilter,
  Turbulence: TurbulenceSVGFilter,
  DisplacementMap: DisplacementMapSVGFilter,
  ColorMatrix: ColorMatrixSVGFilter,
  ConvolveMatrix: ConvolveMatrixSVGFilter
};
const SVGFilterSpecList = {
  Image: ImageSVGFilter.spec,
  Tile: TileSVGFilter.spec,
  DropShadow: DropShadowSVGFilter.spec,
  Saturate: SaturateSVGFilter.spec,
  HueRotate: HueRotateSVGFilter.spec,
  LuminanceAlpha: LuminanceAlphaSVGFilter.spec,
  Offset: OffsetSVGFilter.spec,
  ComponentTransfer: ComponentTransferSVGFilter.spec,
  SpecularLighting: SpecularLightingSVGFilter.spec,
  SpotLight: SpotLightSVGFilter.spec,
  PointLight: PointLightSVGFilter.spec,
  DistantLight: DistantLightSVGFilter.spec,
  DiffuseLighting: DiffuseLightingSVGFilter.spec,
  Blend: BlendSVGFilter.spec,
  RotaMatrix: RotaMatrixSVGFilter.spec,
  Merge: MergeSVGFilter.spec,
  GaussianBlur: GaussianBlurSVGFilter.spec,
  Flood: FloodSVGFilter.spec,
  Morphology: MorphologySVGFilter.spec,
  Composite: CompositeSVGFilter.spec,
  Turbulence: TurbulenceSVGFilter.spec,
  DisplacementMap: DisplacementMapSVGFilter.spec,
  ColorMatrix: ColorMatrixSVGFilter.spec,
  ConvolveMatrix: ConvolveMatrixSVGFilter.spec
};
const WEBKIT_ATTRIBUTE_FOR_CSS = [
  "text-fill-color",
  "text-stroke-color",
  "text-stroke-width",
  "background-clip"
];
function valueFilter(obj2) {
  const result = {};
  Object.keys(obj2).forEach((key) => {
    if (isNotUndefined(obj2[key])) {
      result[key] = obj2[key];
    }
  });
  return result;
}
class DomRender extends ItemRender {
  toStringPropertyCSS(item, field) {
    return STRING_TO_CSS(item.get(field));
  }
  toBackgroundImageCSS(item) {
    if (!item.cacheBackgroundImage) {
      item.setBackgroundImageCache();
    }
    return item.cacheBackgroundImage;
  }
  toLayoutCSS(item) {
    if (item.hasLayout()) {
      if (item.isLayout(Layout.FLEX)) {
        return this.toFlexLayoutCSS(item);
      } else if (item.isLayout(Layout.GRID)) {
        return this.toGridLayoutCSS(item);
      }
    }
    return {};
  }
  toLayoutItemCSS(item) {
    var _a, _b;
    var parentLayout = (_a = item.parent) == null ? void 0 : _a["layout"];
    var obj2 = {};
    if (parentLayout === Layout.FLEX) {
      obj2 = {
        position: "relative",
        left: "auto !important",
        top: "auto !important"
      };
    } else if (parentLayout === Layout.GRID) {
      obj2 = {
        position: "relative",
        left: "auto",
        top: "auto"
      };
    } else if (parentLayout === Layout.DEFAULT) {
      obj2 = this.toDefaultLayoutItemCSS(item);
    }
    if (parentLayout === Layout.FLEX) {
      obj2 = __spreadProps(__spreadValues({}, obj2), {
        "flex-basis": item.flexBasis,
        "flex-shrink": item.flexShrink
      });
      const parentLayoutDirection = (_b = item == null ? void 0 : item.parent) == null ? void 0 : _b.flexDirection;
      if (parentLayoutDirection === FlexDirection.ROW && item.resizingHorizontal === ResizingMode.FILL_CONTAINER) {
        obj2.width = "auto";
        obj2["flex-grow"] = item.flexGrow || 1;
      } else if (parentLayoutDirection === FlexDirection.COLUMN && item.resizingVertical === ResizingMode.FILL_CONTAINER) {
        obj2.height = "auto";
        obj2["flex-grow"] = item.flexGrow || 1;
      }
    } else if (parentLayout === Layout.GRID) {
      obj2 = __spreadProps(__spreadValues({}, obj2), {
        "grid-column-start": item.gridColumnStart,
        "grid-column-end": item.gridColumnEnd,
        "grid-row-start": item.gridRowStart,
        "grid-row-end": item.gridRowEnd
      });
      const columns = Grid.parseStyle(item.parent.gridTemplateColumns);
      const rows = Grid.parseStyle(item.parent.gridTemplateRows);
      obj2["grid-column-start"] = Math.max(1, Math.min(columns.length, obj2["grid-column-start"] || 1));
      obj2["grid-column-end"] = Math.min(columns.length + 1, obj2["grid-column-end"] || 2);
      obj2["grid-row-start"] = Math.max(1, Math.min(rows.length, obj2["grid-row-start"] || 1));
      obj2["grid-row-end"] = Math.min(rows.length + 1, obj2["grid-row-end"] || 2);
    }
    return obj2;
  }
  toDefaultLayoutItemCSS(item) {
    var _a;
    const obj2 = {};
    if ((_a = item.parent) == null ? void 0 : _a.is("project")) {
      return obj2;
    }
    const parentWidth = item.parent.screenWidth;
    switch (item[ConstraintsDirection.HORIZONTAL]) {
      case Constraints.MIN:
        obj2.left = Length.px(item.x);
        obj2.right = "auto !important";
        break;
      case Constraints.MAX:
        obj2.right = Length.px(parentWidth - item.offsetX - item.screenWidth);
        obj2.left = "auto !important";
        break;
      case Constraints.STRETCH:
        obj2.left = Length.px(item.x);
        obj2.right = Length.px(parentWidth - item.offsetX - item.screenWidth);
        obj2.width = "auto !important";
        break;
      case Constraints.CENTER:
        obj2.left = Length.px(item.x);
        break;
      case Constraints.SCALE:
        obj2.left = Length.px(item.x).toPercent(parentWidth);
        obj2.right = Length.px(parentWidth - item.offsetX - item.screenWidth).toPercent(parentWidth);
        obj2.width = "auto !important";
        break;
    }
    const parentHeight = item.parent.screenHeight;
    switch (item[ConstraintsDirection.VERTICAL]) {
      case Constraints.MIN:
        obj2.top = Length.px(item.y);
        obj2.bottom = "auto !important";
        break;
      case Constraints.MAX:
        obj2.top = "auto !important";
        obj2.bottom = Length.px(parentHeight - item.offsetY - item.screenHeight);
        break;
      case Constraints.STRETCH:
        obj2.top = Length.px(item.y);
        obj2.bottom = Length.px(parentHeight - item.offsetY - item.screenHeight);
        obj2.height = "auto !important";
        break;
      case Constraints.CENTER:
        obj2.top = Length.px(item.y);
        break;
      case Constraints.SCALE:
        obj2.top = Length.px(item.y).toPercent(parentHeight);
        obj2.bottom = Length.px(parentHeight - item.offsetY - item.screenHeight).toPercent(parentHeight);
        obj2.height = "auto !important";
        break;
    }
    return obj2;
  }
  toFlexLayoutCSS(item) {
    if (item.parent.isNot("project"))
      ;
    return {
      display: "flex",
      gap: Length.px(item.gap),
      "flex-direction": item.flexDirection,
      "flex-wrap": item.flexWrap,
      "justify-content": item.justifyContent,
      "align-items": item.alignItems,
      "align-content": item.alignContent
    };
  }
  toGridLayoutCSS(item) {
    return {
      display: "grid",
      "grid-template-columns": item.gridTemplateColumns,
      "grid-template-rows": item.gridTemplateRows,
      "grid-template-areas": item.gridTemplateAreas,
      "grid-auto-columns": item.gridAutoColumns,
      "grid-auto-rows": item.gridAutoRows,
      "grid-auto-flow": item.gridAutoFlow,
      "grid-column-gap": item.gridColumnGap,
      "grid-row-gap": item.gridRowGap
    };
  }
  toBoxShadowCSS(item) {
    const boxShadow2 = item.computed("boxShadow", (boxShadow3 = []) => {
      return boxShadow3.map((shadow2) => {
        const { inset, color: color2, offsetX, offsetY, blurRadius, spreadRadius } = shadow2;
        return ` ${inset === "inset" ? "inset" : ""} ${Length.px(offsetX)} ${Length.px(offsetY)} ${Length.px(blurRadius)} ${Length.px(spreadRadius)} ${color2}`;
      }).join(", ") || void 0;
    });
    return {
      "box-shadow": boxShadow2
    };
  }
  toTextShadowCSS(item) {
    const textShadow2 = item.computed("textShadow", (textShadow3 = []) => {
      return textShadow3.map((shadow2) => {
        const { color: color2, offsetX, offsetY, blurRadius } = shadow2;
        return ` ${Length.px(offsetX)} ${Length.px(offsetY)} ${Length.px(blurRadius)}  ${color2}`;
      }).join(", ") || void 0;
    });
    return {
      "text-shadow": textShadow2
    };
  }
  toFilterCSS(item) {
    const filter2 = item.computed("filter", (filter3 = []) => {
      return filter3.map((f) => {
        switch (f.type) {
          case "blur":
          case "grayscale":
          case "sepia":
          case "invert":
          case "opacity":
          case "saturate":
          case "hue-rotate":
          case "brightness":
          case "contrast":
            return `${f.type}(${f.value})`;
          case "drop-shadow":
            return `drop-shadow(${f.offsetX} ${f.offsetY} ${f.blurRadius} ${f.color})`;
        }
      }).join(" ") || void 0;
    });
    return {
      filter: filter2
    };
  }
  toBackdropFilterCSS(item) {
    const backdropFilter2 = item.computed("backdropFilter", (filter2 = []) => {
      filter2 = filter2 || [];
      return filter2.map((f) => {
        switch (f.type) {
          case "blur":
          case "grayscale":
          case "sepia":
          case "invert":
          case "opacity":
          case "saturate":
          case "hue-rotate":
          case "brightness":
          case "contrast":
            return `${f.type}(${f.value})`;
          case "drop-shadow":
            return `drop-shadow(${f.offsetX} ${f.offsetY} ${f.blurRadius} ${f.color})`;
        }
      }).join(" ") || void 0;
    });
    return {
      "backdrop-filter": backdropFilter2
    };
  }
  toBorderCSS(item) {
    const borderCSS = item.computed("border", (border2) => {
      const obj2 = __spreadValues({}, STRING_TO_CSS(border2));
      return obj2;
    });
    return borderCSS;
  }
  toBoxModelCSS(item) {
    let obj2 = {};
    if (item.marginTop)
      obj2["margin-top"] = Length.px(item.marginTop);
    if (item.marginBottom)
      obj2["margin-bottom"] = Length.px(item.marginBottom);
    if (item.marginLeft)
      obj2["margin-left"] = Length.px(item.marginLeft);
    if (item.marginRight)
      obj2["margin-right"] = Length.px(item.marginRight);
    if (item.paddingTop)
      obj2["padding-top"] = Length.px(item.paddingTop);
    if (item.paddingBottom)
      obj2["padding-bottom"] = Length.px(item.paddingBottom);
    if (item.paddingLeft)
      obj2["padding-left"] = Length.px(item.paddingLeft);
    if (item.paddingRight)
      obj2["padding-right"] = Length.px(item.paddingRight);
    return obj2;
  }
  toSizeCSS(item) {
    const obj2 = {};
    if (item.isLayout(Layout.FLEX)) {
      switch (item.resizingHorizontal) {
        case ResizingMode.FIXED:
          obj2.width = Length.px(item.screenWidth);
          break;
        case ResizingMode.HUG_CONTENT:
          obj2["min-width"] = Length.px(item.screenWidth);
          break;
      }
      switch (item.resizingVertical) {
        case ResizingMode.FIXED:
          obj2.height = Length.px(item.screenHeight);
          break;
        case ResizingMode.HUG_CONTENT:
          obj2["min-height"] = Length.px(item.screenHeight);
          break;
      }
    }
    if (item.isInDefault()) {
      obj2.width = Length.px(item.screenWidth);
      obj2.height = Length.px(item.screenHeight);
    }
    if (item.isInFlex()) {
      const direction2 = item.parent.flexDirection;
      if (direction2 === FlexDirection.ROW || direction2 === FlexDirection.ROW_REVERSE) {
        obj2.width = Length.px(item.screenWidth);
        obj2.height = Length.px(item.screenHeight);
        if (item.parent["align-items"] === AlignItems.STRETCH) {
          obj2.height = "auto";
        }
        if (item.resizingVertical === ResizingMode.FILL_CONTAINER) {
          obj2.height = "auto";
          obj2["align-self"] = AlignItems.STRETCH;
        }
      } else {
        obj2.width = Length.px(item.screenWidth);
        obj2.height = Length.px(item.screenHeight);
        if (item.parent["align-items"] === AlignItems.STRETCH) {
          obj2.width = "auto";
        }
        if (item.resizingHorizontal === ResizingMode.FILL_CONTAINER) {
          obj2.width = "auto";
          obj2["align-self"] = AlignItems.STRETCH;
        }
      }
    }
    if (item.isInGrid()) {
      obj2.width = "auto";
      obj2.height = "auto";
    }
    return obj2;
  }
  toDefaultCSS(item) {
    if (!item.hasCache("toDefaultCSS")) {
      item.addCache("toDefaultCSS", {
        "box-sizing": "border-box"
      });
    }
    let result = item.getCache("toDefaultCSS");
    if (item.isAbsolute) {
      result.left = Length.px(item.x);
      result.top = Length.px(item.y);
    }
    result["background-color"] = item.backgroundColor;
    result["color"] = item.color;
    result["font-size"] = item.fontSize;
    result["font-weight"] = item.fontWeight;
    result["font-style"] = item.fontStyle;
    result["font-family"] = item.fontFamily;
    result["text-align"] = item.textAlign;
    result["text-decoration"] = item.textDecoration;
    result["text-transform"] = item.textTransform;
    result["letter-spacing"] = item.letterSpacing;
    result["word-spacing"] = item.wordSpacing;
    result["line-height"] = item.lineHeight;
    result["text-indent"] = item.textIndent;
    result["text-overflow"] = item.textOverflow;
    result["text-wrap"] = item.textWrap;
    result["position"] = item.position;
    result["overflow"] = item.overflow;
    result["z-index"] = item.zIndex;
    result["opacity"] = item.opacity;
    result["mix-blend-mode"] = item.mixBlendMode;
    result["transform-origin"] = item.transformOrigin;
    result["border-radius"] = item.borderRadius;
    result["filter"] = item.filter;
    result["animation"] = item.animation;
    result["transition"] = item.transition;
    return result;
  }
  toVariableCSS(item) {
    const v = item.computed("variable", (v2) => {
      let obj2 = {};
      v2.split(";").filter((it) => it.trim()).forEach((it) => {
        const [key, value] = it.split(":");
        obj2[`--${key}`] = value;
      });
      return obj2;
    });
    return v;
  }
  toRootVariableCSS(item) {
    let obj2 = {};
    item.rootVariable.split(";").filter((it) => it.trim()).forEach((it) => {
      const [key, value] = it.split(":");
      obj2[`--${key}`] = value;
    });
    return obj2;
  }
  toRootVariableString(item) {
    return CSS_TO_STRING(this.toRootVariableCSS(item));
  }
  toWebkitCSS(item) {
    var results = {};
    WEBKIT_ATTRIBUTE_FOR_CSS.forEach((key) => {
      results[`-webkit-${key}`] = item.get(key);
    });
    return results;
  }
  toTextClipCSS(item) {
    let results = {};
    if (item.textClip === "text") {
      results["-webkit-background-clip"] = "text";
      results["-webkit-text-fill-color"] = "transparent";
      results["color"] = "transparent";
    }
    return results;
  }
  toTransformCSS(item) {
    const transform2 = item.computed("angle", (angle) => {
      return {
        transform: angle === 0 ? "" : `rotateZ(${angle}deg)`
      };
    });
    return transform2;
  }
  toDefInnerString(item) {
    return `
      ${this.toClipPath(item)}
      ${this.toSVGFilter(item)}
    `.trim();
  }
  toClipPath(item) {
    if (item.clipPath === "")
      return "";
    if (!item.cacheClipPathObject) {
      item.setClipPathCache();
    }
    var obj2 = item.cacheClipPathObject;
    var value = obj2.value;
    switch (obj2.type) {
      case "path":
        return `<clipPath id="${this.clipPathId(item)}"><path d="${item.clipPathString}" /></clipPath>`;
      case "svg":
        return `<clipPath id="${this.clipPathId(item)}">${value}</clipPath>`;
    }
    return ``;
  }
  toClipPathCSS(item) {
    let str = item.clipPath;
    if (Boolean(str) === false) {
      return null;
    }
    if (!item.cacheClipPathObject) {
      item.setClipPathCache();
    }
    var obj2 = item.cacheClipPathObject;
    switch (obj2.type) {
      case "path":
        if (obj2.value) {
          str = `url(#${this.clipPathId(item)})`;
        }
        break;
      case "svg":
        str = `url(#${this.clipPathId(item)})`;
        break;
    }
    return {
      "clip-path": str
    };
  }
  innerSVGId(item) {
    return item.id + "inner-svg";
  }
  booleanId(item) {
    return item.id + "boolean";
  }
  clipPathId(item) {
    return item.id + "clip-path";
  }
  toDefString(item) {
    var str = this.toDefInnerString(item).trim();
    return str ? `
    <svg class='inner-svg-element' style="display:block" data-id="${this.innerSVGId(item)}" width="0" height="0">
      <defs>
        ${str}
      </defs>
    </svg>
    ` : "";
  }
  toSelectorString(item, prefix = "") {
    var _a;
    return (_a = item.selectors) == null ? void 0 : _a.map((selector2) => selector2.toString(prefix)).join("\n\n");
  }
  generateView(item, prefix = "", appendCSS = "") {
    var cssString = `
  ${prefix} {  /* ${item.itemType} */
      ${CSS_TO_STRING(this.toCSS(item), "\n    ")}; 
      ${appendCSS}
  }
  ${this.toNestedCSS(item).map((it) => {
      return `${prefix} ${it.selector} { 
        ${it.cssText ? it.cssText : CSS_TO_STRING(it.css || {}, "\n		")}; 
    }`;
    }).join("\n")}
  ${this.toSelectorString(item, prefix)}
    `;
    return cssString;
  }
  toCSS(item) {
    return valueFilter(Object.assign({}, this.toVariableCSS(item), this.toDefaultCSS(item), this.toClipPathCSS(item), this.toWebkitCSS(item), this.toTextClipCSS(item), this.toBoxModelCSS(item), this.toBorderCSS(item), this.toBackgroundImageCSS(item), this.toBoxShadowCSS(item), this.toTextShadowCSS(item), this.toFilterCSS(item), this.toBackdropFilterCSS(item), this.toLayoutCSS(item), this.toSizeCSS(item), this.toTransformCSS(item), this.toLayoutItemCSS(item)));
  }
  toStyleCode(item) {
    const cssString = this.generateView(item, `[data-renderer-id='${this.renderer.id}'] .element-item[data-id='${item.id}']`);
    return cssString;
  }
  toStyle(item) {
    const cssString = this.generateView(item, `[data-renderer-id='${this.renderer.id}'] .element-item[data-id='${item.id}']`);
    return `
<style type='text/css' data-renderer-type="html" data-id='${item.id}'>
${cssString}
</style>
    ` + item.layers.map((it) => {
      return this.renderer.toStyle(it);
    }).join("");
  }
  toStyleData(item) {
    const cssString = this.generateView(item, `[data-renderer-id='${this.renderer.id}'] .element-item[data-id='${item.id}']`);
    return {
      styleTag: `<style type='text/css' data-renderer-type="html" data-id='${item.id}'>${cssString}</style>`,
      cssString
    };
  }
  toExportStyle(item) {
    const cssString = this.generateView(item, `.element-item[data-id='${item.id}']`);
    return `
<style type='text/css' data-renderer-type="html" data-id='${item.id}' data-timestamp='${item.timestamp}'>
${cssString}
</style>
    ` + item.layers.map((it) => {
      return this.renderer.toExportStyle(it);
    }).join("");
  }
  render(item) {
    var { elementType, id, name, itemType, isBooleanItem } = item;
    const tagName = elementType || "div";
    return `<${tagName} id="${this.uniqueId(item)}" class="element-item ${itemType}" data-is-boolean-item="${isBooleanItem}" data-id="${id}" data-title="${name}">${this.toDefString(item)}${item.layers.map((it) => {
      return this.renderer.render(it);
    }).join("")}</${tagName}>`;
  }
  toSVGFilter(item) {
    if (item.svgfilters.length === 0)
      return "";
    var filterString = item.computedValue("svgfilters");
    if (item.hasChangedField("svgfilters") || !filterString) {
      filterString = item.computed("svgfilters", (svgfilters) => {
        var filterString2 = svgfilters.map((svgfilter) => {
          return `
              <filter id='${svgfilter.id}'>
                ${svgfilter.filters.map((filter2) => SVGFilter.parse(filter2)).join("\n")}
              </filter>`;
        }).join("");
        return filterString2;
      }, true);
    }
    return filterString;
  }
  renderSVG() {
  }
  toNestedCSS() {
    const result = [];
    return result;
  }
  updateStyle(item) {
    if (item.hasCache("style")) {
      const styleText = this.toStyleData(item).cssString;
      if (item.hasCache("styleText")) {
        if (item.getCache("styleText") === styleText) {
          return;
        }
      }
      item.addCache("styleText", styleText);
      item.getCache("style").text(styleText);
    } else {
      const styleData = this.toStyleData(item);
      const style = Dom.createByHTML(styleData.styleTag);
      item.addCache("style", style);
      item.addCache("styleText", styleData.cssString);
      document.head.appendChild(style.el);
    }
  }
  update(item, currentElement) {
    if (!currentElement)
      return;
    this.updateStyle(item);
    let $svg = currentElement.el.$svg;
    if (!$svg) {
      currentElement.el.$svg = currentElement.$(`[data-id="${this.innerSVGId(item)}"]`);
      $svg = currentElement.el.$svg;
      currentElement.el.$booleanSvg = currentElement.$(`[data-id="${this.booleanId(item)}"]`);
    }
    if (currentElement.data("is-boolean-item") !== `${item.isBooleanItem}`) {
      currentElement.attr("data-is-boolean-item", item.isBooleanItem);
    }
    if ($svg) {
      const defString = this.toDefInnerString(item);
      if (defString) {
        var $defs = $svg.$("defs");
        $defs.updateSVGDiff(`<defs>${defString}</defs>`);
      }
    } else {
      const defString = this.toDefString(item);
      if (defString) {
        var a = Dom.createByHTML(defString);
        if (a) {
          currentElement.prepend(a);
        }
      }
    }
  }
}
class LayerRender extends DomRender {
}
class SampleRender extends LayerRender {
  update(item, currentElement) {
    const $sampleText = currentElement.$(".sample-text");
    if ($sampleText) {
      $sampleText.text(item.sampleText);
    }
    const $sampleNumber = currentElement.$(".sample-number");
    if ($sampleNumber) {
      $sampleNumber.text(item.sampleNumber);
    }
    const $sampleItems = currentElement.$(".sample-items");
    if ($sampleItems) {
      const template = [...Array(item.sampleNumber)].map((_, i) => `
            <div class="sample-item" style="background-color: yellow">${i}</div>
          `).join("\n");
      $sampleItems.html(template);
    }
    super.update(item, currentElement);
  }
  render(item) {
    var { id, sampleText, sampleNumber } = item;
    return `
      <div class='element-item sample' data-id="${id}">
        ${this.toDefString(item)}
        <div>
          <div class="sample-text">${sampleText}</div>
          <div class="sample-number">${sampleNumber}</div>
          <div class="sample-items" style="display: grid; grid-template-columns: 1fr 1fr 1fr; column-gap: 10px;"></div>
        </div>
      </div>`;
  }
}
function sample(editor) {
  editor.registerComponent("sample", SampleLayer);
  editor.registerRenderer("html", "sample", new SampleRender());
  editor.registerInspector("sample", (current) => {
    return [
      "Sample Text \uD3B8\uC9D1",
      {
        key: "sampleText",
        editor: "TextEditor",
        defaultValue: current.sampleText
      },
      "Sample Number \uD3B8\uC9D1",
      {
        key: "sampleNumber",
        editor: "NumberInputEditor",
        editorOptions: {
          min: 0,
          max: 10,
          step: 1,
          label: "SN"
        },
        defaultValue: current.sampleNumber
      },
      "\uC2A4\uD0C0\uC77C \uCE74\uD53C",
      {
        type: "column",
        size: [1, 1],
        gap: 10,
        columns: [
          {
            key: "copyCssJSON",
            editor: "Button",
            editorOptions: {
              text: "Copy CSS JSON",
              onClick: () => {
                console.log(JSON.stringify(editor.html.toCSS(current), null, 4));
              }
            }
          },
          {
            key: "copyCssString",
            editor: "Button",
            editorOptions: {
              text: "Copy CSS String",
              onClick: () => {
                console.log(CSS_TO_STRING(editor.html.toCSS(current)));
              }
            }
          },
          {
            key: "changeColor",
            editor: "Button",
            editorOptions: {
              text: "Change Text Random Color",
              onClick: () => {
                const textColor = random$1();
                const backgroundColor = random$1();
                editor.context.commands.emit("setAttribute", {
                  [current.id]: {
                    color: textColor,
                    "background-color": backgroundColor
                  }
                });
              }
            }
          }
        ]
      }
    ];
  });
}
var SelectionInfoView$1 = "";
class SelectionInfoView extends EditorElement {
  template() {
    return /* @__PURE__ */ createElementJsx("div", {
      class: "elf--selection-info-view"
    });
  }
  [POINTERSTART("$el [data-artboard-title-id]") + FIRSTMOVE("calculateFirstMovedElement") + MOVE("calculateMovedElement") + END("calculateEndedElement")](e) {
    this.startXY = e.xy;
    this.initMousePoint = this.$viewport.getWorldPosition(e);
    const id = e.$dt.attr("data-artboard-title-id");
    this.$context.selection.select(id);
    if (e.altKey) {
      this.$commands.emit("history.copyLayer", "copy");
    }
    this.initializeDragSelection();
  }
  initializeDragSelection() {
    this.$context.selection.reselect();
    this.$context.snapManager.clear();
  }
  moveTo(dist2) {
    const snap = this.$context.snapManager.check(this.$context.selection.cachedRectVerties.map((v) => {
      return add$1([], v, dist2);
    }), 3 / this.$viewport.scale);
    const localDist = add$1([], snap.dist, dist2);
    const result = {};
    this.$context.selection.cachedItemMatrices.forEach((it) => {
      const newVerties = it.verties.map((v) => {
        return add$1([], v, localDist);
      });
      const newDist = subtract([], transformMat4([], newVerties[0], it.parentMatrixInverse), transformMat4([], it.verties[0], it.parentMatrixInverse));
      result[it.id] = {
        x: Math.floor(it.x + newDist[0]),
        y: Math.floor(it.y + newDist[1])
      };
    });
    this.$context.selection.reset(result);
  }
  calculateFirstMovedElement() {
    this.$config.set("set.move.control.point", true);
    this.emit(REFRESH_SELECTION_TOOL);
  }
  calculateMovedElement() {
    const targetMousePoint = this.$viewport.getWorldPosition();
    const newDist = floor([], subtract([], targetMousePoint, this.initMousePoint));
    this.moveTo(newDist);
    this.$commands.emit("setAttribute", this.$context.selection.pack("x", "y"));
    this.refresh();
  }
  [SUBSCRIBE("refreshItemName")](id, title2) {
    var _a;
    this.$commands.emit("setAttribute", {
      [id]: { name: title2 }
    });
    (_a = this.$el.$(`[data-artboard-title-id='${id}']`)) == null ? void 0 : _a.text(title2);
  }
  calculateEndedElement() {
    this.$commands.executeCommand("setAttribute", "move item", this.$context.selection.pack("x", "y"));
    this.$config.set("set.move.control.point", false);
    this.emit(REFRESH_SELECTION_TOOL);
    this.$commands.emit("history.refreshSelection");
  }
  [SUBSCRIBE(UPDATE_VIEWPORT)]() {
    this.refresh();
  }
  [SUBSCRIBE(UPDATE_CANVAS)]() {
    if (this.$context.selection.current) {
      if (this.$context.selection.current.is("artboard")) {
        if (this.$context.selection.hasChangedField("x", "y", "width", "height", "angle", "transform", "transform-origin")) {
          this.refresh();
        }
      }
    }
  }
  [LOAD("$el") + DOMDIFF]() {
    var _a;
    return (_a = this.$context.selection.currentProject) == null ? void 0 : _a.artboards.map((it) => {
      return {
        item: it,
        title: it.name,
        id: it.id,
        layout: it.layout,
        pointers: this.$viewport.applyVerties(it.verties)
      };
    }).map((it) => this.makeArtboardTitleArea(it));
  }
  getIcon(item) {
    if (item.hasLayout() || item.hasChildren() || item.is("artboard")) {
      if (item.isLayout("flex")) {
        return iconUse("layout_flex", item.flexDirection === "column" ? "rotate(90 12 12)" : "");
      } else if (item.isLayout("grid")) {
        return iconUse("layout_grid");
      }
      return "";
    }
    return this.$icon.get(item.itemType, item);
  }
  createSize(pointers, artboardItem) {
    const newPointer = pointers[0];
    const diff = subtract([], pointers[0], pointers[3]);
    const angle = calculateAngle360(diff[0], diff[1]) - 90;
    return /* @__PURE__ */ createElementJsx("div", {
      class: "artboard-title is-not-drag-area",
      "data-artboard-title-id": artboardItem.id,
      "data-layout": artboardItem.layout,
      style: {
        "transform-origin": "0% 0%",
        transform: `translate3d( calc(${newPointer[0]}px), calc(${newPointer[1]}px), 0px) rotateZ(${angle}deg)`
      }
    }, /* @__PURE__ */ createElementJsx("div", {
      style: "transform: translateY(-100%);"
    }, this.getIcon(artboardItem.item), artboardItem.title));
  }
  makeArtboardTitleArea(it) {
    return this.createSize(it.pointers, it);
  }
  [SUBSCRIBE("refreshAll")]() {
    this.refresh();
  }
  [SUBSCRIBE("appendLayer")]() {
    this.refresh();
  }
}
function selectionInfoView(editor) {
  editor.registerUI("canvas.view", {
    SelectionInfoView
  });
}
var GhostToolView$1 = "";
const CHECK_RATE = 0.5;
class GhostToolView extends EditorElement {
  template() {
    return /* @__PURE__ */ createElementJsx("div", {
      class: "elf--ghost-tool-view"
    }, /* @__PURE__ */ createElementJsx("div", {
      ref: "$containerView"
    }), /* @__PURE__ */ createElementJsx("div", {
      ref: "$view"
    }));
  }
  [SUBSCRIBE("startGhostToolView")]() {
    const screenVerties = this.$context.selection.verties;
    this.isLayoutItem = this.$context.selection.isLayoutItem;
    this.verties = clone$1(screenVerties);
    this.ghostVerties = clone$1(screenVerties);
    this.ghostScreenVerties = this.$viewport.applyVerties(this.ghostVerties);
    this.initMousePoint = this.$viewport.getWorldPosition();
    this.filteredLayers = this.$context.selection.notSelectedLayers;
    this.containerList = this.filteredLayers.filter((it) => it.hasLayout() || it.is("artboard")).map((it) => it.originVerties);
    this.$config.set("set.move.control.point", true);
  }
  collectInformation() {
    var _a, _b;
    const targetMousePoint = this.$viewport.getWorldPosition();
    const newDist = this.getDist();
    this.ghostVerties = this.verties.map((v) => {
      return add$1([], v, newDist);
    });
    this.ghostScreenVerties = this.$viewport.applyVerties(this.ghostVerties);
    const filteredLayers = this.$context.selection.filteredLayers.filter((it) => this.$context.selection.check(it) === false);
    this.targetItem = filteredLayers[0];
    if (this.targetItem) {
      const currentParent = (_a = this.$context.selection.current) == null ? void 0 : _a.parent;
      if (currentParent.isNot("project") && (currentParent == null ? void 0 : currentParent.isLayout(Layout.GRID))) {
        this.targetItem = this.$context.selection.current.parent;
      } else {
        if (this.targetItem.hasLayout() && ((_b = this.targetItem) == null ? void 0 : _b.hasChildren())) {
          if (this.targetItem.isLayout(Layout.FLEX)) {
            this.targetItem = this.targetItem.layers[this.targetItem.layers.length - 1];
          } else if (this.targetItem.isLayout(Layout.GRID))
            ;
        }
      }
      this.$context.selection.updateDragTargetItem(this.targetItem);
      this.targetOriginPosition = this.$viewport.applyVerties(toRectVerties(this.targetItem.contentVerties));
      this.targetPoint = this.$viewport.applyVertex(targetMousePoint);
      this.targetRelativeMousePoint = {
        x: (this.targetPoint[0] - this.targetOriginPosition[0][0]) / (this.targetOriginPosition[1][0] - this.targetOriginPosition[0][0]),
        y: (this.targetPoint[1] - this.targetOriginPosition[0][1]) / (this.targetOriginPosition[3][1] - this.targetOriginPosition[0][1])
      };
      if (this.targetItem.isLayoutItem()) {
        this.targetParent = this.targetItem.parent;
        if (this.targetParent) {
          this.targetParentPosition = this.$viewport.applyVerties(this.targetParent.contentVerties);
        }
      } else {
        this.targetParent = null;
        this.targetParentPosition = null;
      }
    } else {
      this.targetPoint = null;
      this.targetRelativeMousePoint = null;
      this.targetParent = null;
      this.targetParentPosition = null;
    }
  }
  [SUBSCRIBE("moveFirstGhostToolView")]() {
    this.collectInformation();
    this.load("$containerView");
    this.load("$view");
  }
  [SUBSCRIBE("moveGhostToolView")]() {
    this.collectInformation();
    this.load("$view");
  }
  [LOAD("$containerView")]() {
    var _a;
    if (!this.ghostVerties) {
      return /* @__PURE__ */ createElementJsx("svg", null);
    }
    return /* @__PURE__ */ createElementJsx("svg", null, (_a = this.containerList) == null ? void 0 : _a.map((it) => {
      it = this.$viewport.applyVerties(it);
      return /* @__PURE__ */ createElementJsx("path", {
        class: "container",
        d: `
                    M ${it[0][0]} ${it[0][1]}
                    L ${it[1][0]} ${it[1][1]}
                    L ${it[2][0]} ${it[2][1]}
                    L ${it[3][0]} ${it[3][1]}
                    Z
                `
      });
    }));
  }
  renderPathForVerties(verties, className) {
    if (!verties) {
      return /* @__PURE__ */ createElementJsx("g", null);
    }
    const d = vertiesToPath(verties);
    return /* @__PURE__ */ createElementJsx("g", null, /* @__PURE__ */ createElementJsx("path", {
      class: className,
      d
    }));
  }
  renderPath(verties, className, data = className) {
    if (!verties)
      return "";
    verties = data === "ghost" ? verties : toRectVerties(verties);
    const textX = className === "flex-item" ? verties[0][0] : verties[0][0];
    const textY = className === "flex-item" ? verties[2][1] + 10 : verties[0][1] - 10;
    return /* @__PURE__ */ createElementJsx("g", null, /* @__PURE__ */ createElementJsx("text", {
      x: textX,
      y: textY,
      "font-size": 8
    }, data), this.renderPathForVerties(verties, className));
  }
  renderLayoutFlexRowArea() {
    if (this.targetRelativeMousePoint.x < CHECK_RATE) {
      return /* @__PURE__ */ createElementJsx(FragmentInstance, null, this.renderPathForVerties([this.targetOriginPosition[0], this.targetOriginPosition[3]], "flex-target"));
    } else {
      return /* @__PURE__ */ createElementJsx(FragmentInstance, null, this.renderPathForVerties([this.targetOriginPosition[1], this.targetOriginPosition[2]], "flex-target"));
    }
  }
  renderLayoutFlexForFirstItem(direction2) {
    const isColumn = direction2 === FlexDirection.COLUMN;
    const verticalField = isColumn ? "align-items" : "justify-content";
    const verticalConst = isColumn ? AlignItems : JustifyContent;
    const horizontalField = isColumn ? "justify-content" : "align-items";
    const horizontalConst = isColumn ? JustifyContent : AlignItems;
    const rect2 = vertiesToRectangle(this.targetOriginPosition);
    const center2 = this.ghostScreenVerties[4];
    const width2 = dist(this.ghostScreenVerties[0], this.ghostScreenVerties[1]);
    const height2 = dist(this.ghostScreenVerties[0], this.ghostScreenVerties[3]);
    let newCenterX = width2 / 2;
    let newCenterY = height2 / 2;
    switch (this.targetItem[verticalField]) {
      case verticalConst.FLEX_START:
        newCenterX = rect2.x + width2 / 2;
        break;
      case verticalConst.CENTER:
      case verticalConst.SPACE_BETWEEN:
      case verticalConst.SPACE_AROUND:
        newCenterX = rect2.x + rect2.width / 2;
        break;
      case verticalConst.FLEX_END:
        newCenterX = rect2.x + rect2.width - width2 / 2;
        break;
    }
    switch (this.targetItem[horizontalField]) {
      case horizontalConst.FLEX_START:
        newCenterY = rect2.y + height2 / 2;
        break;
      case horizontalConst.CENTER:
      case horizontalConst.SPACE_BETWEEN:
      case horizontalConst.SPACE_AROUND:
        newCenterY = rect2.y + rect2.height / 2;
        break;
      case horizontalConst.FLEX_END:
        newCenterY = rect2.y + rect2.height - height2 / 2;
        break;
    }
    const newDist = subtract([], [newCenterX, newCenterY, 0], center2);
    const renderVerties = this.ghostScreenVerties.map((it) => add$1([], it, newDist)).filter((it, index2) => index2 < 4);
    return this.renderPathForVerties(renderVerties, "flex-item", "ghost");
  }
  renderLayoutFlexColumnArea() {
    if (this.targetRelativeMousePoint.y < 0) {
      return "";
    }
    if (this.targetRelativeMousePoint.y < CHECK_RATE) {
      return this.renderPathForVerties([this.targetOriginPosition[0], this.targetOriginPosition[1]], "flex-target");
    } else {
      return this.renderPathForVerties([this.targetOriginPosition[2], this.targetOriginPosition[3]], "flex-target");
    }
  }
  renderLayoutItemInsertArea() {
    if (!this.targetParent) {
      return;
    }
    if (this.targetParent.hasLayout()) {
      if (this.targetParent.isLayout(Layout.FLEX)) {
        switch (this.targetParent.flexDirection) {
          case FlexDirection.ROW:
            return this.renderLayoutFlexRowArea();
          case FlexDirection.COLUMN:
            return this.renderLayoutFlexColumnArea();
        }
      } else if (this.targetParent.isLayout(Layout.GRID))
        ;
    }
    return /* @__PURE__ */ createElementJsx("path", {
      class: "insert-area",
      d: ``
    });
  }
  renderLayoutItemForFirst() {
    var _a;
    if (((_a = this.targetItem) == null ? void 0 : _a.hasChildren()) === false) {
      if (this.targetItem.isLayout(Layout.FLEX)) {
        return this.renderLayoutFlexForFirstItem(this.targetItem.flexDirection);
      } else if (this.targetItem.isLayout(Layout.GRID))
        ;
    }
    return /* @__PURE__ */ createElementJsx("path", {
      class: "insert-area",
      d: ``
    });
  }
  [LOAD("$view") + DOMDIFF]() {
    var _a;
    const current = this.$context.selection.current;
    if (!this.ghostVerties || !current) {
      return /* @__PURE__ */ createElementJsx("svg", null);
    }
    const hasTargetView = ((_a = this.targetItem) == null ? void 0 : _a.id) !== current.id;
    return /* @__PURE__ */ createElementJsx("svg", null, this.targetParent && this.renderPathForVerties(this.targetParentPosition, "target-parent"), hasTargetView && this.renderPathForVerties(this.targetOriginPosition, "target", ""), hasTargetView && this.renderPathForVerties(this.targetOriginPosition, "target-rect", ""), hasTargetView ? this.renderLayoutItemInsertArea() : "", hasTargetView ? this.renderLayoutItemForFirst() : "", this.isLayoutItem && this.renderPathForVerties(this.ghostScreenVerties.filter((_, index2) => index2 < 4), "ghost"));
  }
  initializeGhostView() {
    this.isLayoutItem = false;
    this.ghostVerties = void 0;
    this.ghostScreenVerties = void 0;
    this.targetOriginPosition = void 0;
    this.targetOriginPosition = void 0;
    this.targetRelativeMousePoint = void 0;
    this.targetItem = void 0;
    this.targetParent = void 0;
    this.targetParentPosition = void 0;
    this.$context.selection.updateDragTargetItem(this.targetItem);
  }
  getDist() {
    const targetMousePoint = this.$viewport.getWorldPosition();
    const newDist = floor([], subtract([], targetMousePoint, this.initMousePoint));
    return newDist;
  }
  insertToBackground() {
    const current = this.$context.selection.current;
    const newDist = this.getDist();
    if (current.isLayoutItem() === false)
      return;
    this.$commands.executeCommand("moveLayerToTarget", "change target with move", current, this.$context.selection.currentProject, newDist);
  }
  getTargetAction() {
    let targetAction = "";
    if (this.targetParent.hasLayout()) {
      if (this.targetParent.isLayout(Layout.FLEX)) {
        switch (this.targetParent.flexDirection) {
          case FlexDirection.ROW:
            if (this.targetRelativeMousePoint.x < CHECK_RATE) {
              targetAction = TargetActionType.INSERT_BEFORE;
            } else {
              targetAction = TargetActionType.INSERT_AFTER;
            }
            break;
          case FlexDirection.COLUMN:
            if (this.targetRelativeMousePoint.y < CHECK_RATE) {
              targetAction = TargetActionType.INSERT_BEFORE;
            } else {
              targetAction = TargetActionType.INSERT_AFTER;
            }
            break;
        }
      }
    }
    return targetAction;
  }
  insertToLayoutItem() {
    const current = this.$context.selection.current;
    const newDist = this.getDist();
    if (this.targetParent.hasLayout()) {
      let targetAction = this.getTargetAction();
      if (this.targetParent.isLayout(Layout.FLEX)) {
        if (targetAction) {
          this.$commands.executeCommand("moveLayerToTarget", "change target with move", current, this.targetItem, newDist, targetAction);
        }
      } else if (this.targetParent.isLayout(Layout.GRID)) {
        this.insertToGridItem();
      }
    }
  }
  insertToGridItem() {
    const current = this.$context.selection.current;
    const { info, items } = this.$context.selection.gridInformation || {
      items: []
    };
    const currentVerties = this.ghostVerties.filter((_, index2) => index2 < 4);
    const targetRect = vertiesToRectangle(currentVerties);
    const epsilon = IntersectEpsilonNumberType.RECT / this.$context.viewport.scale;
    const checkedItems = items == null ? void 0 : items.filter((it) => {
      return polyPoly(it.originVerties, currentVerties);
    }).filter((it) => {
      const intersect = intersectRectRect(it.originRect, targetRect);
      return Math.floor(intersect.width) > epsilon && Math.floor(intersect.height) > epsilon;
    });
    if (checkedItems == null ? void 0 : checkedItems.length) {
      const columnList = checkedItems.map((it) => it.column);
      const rowList = checkedItems.map((it) => it.row);
      const columnStart = Math.min(...columnList);
      const rowStart = Math.min(...rowList);
      const columnEnd = Math.max(...columnList) + 1;
      const rowEnd = Math.max(...rowList) + 1;
      this.$commands.executeCommand("setAttribute", "change grid item", this.$context.selection.packByValue({
        "grid-column-start": columnStart,
        "grid-column-end": columnEnd,
        "grid-row-start": rowStart,
        "grid-row-end": rowEnd
      }));
      if (info.current.hasChild(current.id) === false) {
        this.$commands.executeCommand("moveLayerToTarget", "change target with move", current, info.current, void 0);
      }
      return;
    } else {
      if (this.targetItem) {
        this.emit("refreshGridToolInfo", this.targetItem);
        this.$commands.executeCommand("moveLayerToTarget", "change target with move", current, this.targetItem, void 0);
      }
    }
  }
  updateLayer() {
    var _a;
    const current = this.$context.selection.current;
    if (!current)
      return;
    const newDist = this.getDist();
    if (newDist[0] === 0 && newDist[1] === 0) {
      return;
    }
    if (this.targetItem && this.targetItem.id === (current == null ? void 0 : current.id)) {
      return;
    }
    if (!this.targetItem) {
      this.insertToBackground();
      return;
    }
    if (this.targetItem.hasLayout()) {
      const isCtrl = this.$context.keyboardManager.isCtrl();
      if (((_a = this.targetItem) == null ? void 0 : _a.hasChildren()) === false && this.targetItem.isLayout(Layout.FLEX) && isCtrl === false) {
        this.$commands.executeCommand("moveLayerToTarget", "change target with move", current, this.targetItem, newDist);
        return;
      } else {
        if (isCtrl) {
          const { info } = this.$context.selection.gridInformation || {
            items: []
          };
          if (info == null ? void 0 : info.current) {
            this.insertToGridItem();
            return;
          }
        } else {
          if (this.targetItem.isLayout(Layout.GRID)) {
            this.insertToGridItem();
            return;
          }
        }
      }
    }
    if (this.targetParent) {
      this.insertToLayoutItem();
      return;
    }
    if (current.isLayoutItem() && current.parent.id !== this.targetItem.id) {
      this.$commands.executeCommand("moveLayerToTarget", "change target with move", current, this.targetItem, newDist);
    }
  }
  [SUBSCRIBE("endGhostToolView")](hasMoved = false) {
    if (hasMoved) {
      this.updateLayer();
    }
    this.initializeGhostView();
    this.load();
  }
}
var SelectionView = "";
var directionType$1 = {
  1: "to top left",
  2: "to top right",
  3: "to bottom right",
  4: "to bottom left",
  11: "to top",
  12: "to right",
  13: "to bottom",
  14: "to left"
};
const SelectionToolEvent$1 = class extends EditorElement {
  checkViewMode() {
    return this.$modeView.isCurrentMode(ViewModeType.CanvasView);
  }
  [SUBSCRIBE(REFRESH_SELECTION, REFRESH_SELECTION_TOOL) + IF("checkViewMode")]() {
    if (this.$context.selection.isMany) {
      this.initSelectionTool();
    } else {
      this.hide();
    }
  }
  [SUBSCRIBE(UPDATE_VIEWPORT) + IF("checkViewMode")]() {
    if (this.$context.selection.isMany) {
      this.initSelectionTool();
    }
  }
};
class GroupSelectionToolView extends SelectionToolEvent$1 {
  template() {
    return `
            <div class='elf--selection-view group-selection-view' ref='$selectionView'  style='display:none' >
                <div class='pointer-rect' ref='$pointerRect'></div>        
            </div>
        `;
  }
  toggleEditingPath(isEditingPath) {
    this.refs.$selectionView.toggleClass("editing-path", isEditingPath);
  }
  [POINTERSTART("$pointerRect .rotate-pointer") + MOVE("rotateVertex") + END("rotateEndVertex")](e) {
    this.state.moveType = "rotate";
    this.initMousePoint = this.$viewport.getWorldPosition(e);
    this.verties = this.groupItem.verties;
    this.rotateTargetNumber = +e.$dt.attr("data-number");
    this.refreshRotatePointerIcon();
    this.state.dragging = false;
    this.state.isRotate = true;
    this.$config.set("set.move.control.point", true);
  }
  rotateVertex() {
    const targetMousePoint = this.$viewport.getWorldPosition();
    const distVector = subtract([], targetMousePoint, this.initMousePoint);
    const targetRotatePointer = this.rotateTargetNumber === 4 ? getRotatePointer(this.verties, 34) : this.verties[this.rotateTargetNumber];
    var distAngle = Math.floor(calculateAngleForVec3(targetRotatePointer, this.verties[4], distVector));
    if (this.$config.get("bodyEvent").shiftKey) {
      distAngle = distAngle - distAngle % this.$config.get("fixed.angle");
    }
    this.localAngle = this.angle + distAngle;
    this.groupItem.reset({
      angle: this.localAngle
    });
    const selectionMatrix = calculateRotationOriginMat4(distAngle, this.verties[4]);
    let cachedItemMatrices = this.$context.selection.cachedItemMatrices;
    if (this.$context.selection.length === 1) {
      cachedItemMatrices = cachedItemMatrices.filter((it) => it.id === this.$context.selection.current.id);
    }
    cachedItemMatrices.forEach((item) => {
      const newVerties = vertiesMap(item.verties, multiply$1([], item.parentMatrixInverse, selectionMatrix));
      const rotatePointer = getRotatePointer(newVerties, 34);
      var lastAngle = calculateAngle(rotatePointer[0] - newVerties[4][0], rotatePointer[1] - newVerties[4][1]) - 270;
      const newTranslate = transformMat4([], newVerties[0], calculateRotationOriginMat4(-lastAngle, newVerties[4]));
      const instance = this.$model.get(item.id);
      if (instance) {
        instance.reset({
          x: newTranslate[0],
          y: newTranslate[1],
          angle: lastAngle
        });
      }
    });
    this.state.dragging = true;
    this.$commands.emit("setAttribute", this.$context.selection.pack("x", "y", "width", "height", "angle"));
    this.renderPointers();
  }
  rotateEndVertex() {
    this.state.dragging = false;
    this.state.isRotate = false;
    this.$commands.emit("recoverCursor");
    this.$config.set("set.move.control.point", false);
    this.$context.selection.reselect();
    this.initMatrix(true);
    this.nextTick(() => {
      this.$commands.executeCommand("setAttribute", "rotate selection pointer", this.$context.selection.pack("x", "y", "width", "height", "angle"));
    });
  }
  refreshRotatePointerIcon() {
    this.$commands.emit("refreshCursor", "rotate");
  }
  refreshPointerIcon(e) {
    const dataPointer = e.$dt.data("pointer");
    if (dataPointer) {
      const pointer = dataPointer.split(",").map((it) => Number(it));
      const diff = subtract([], pointer, this.state.renderPointerList[0][4]);
      const angle = calculateAngle360(diff[0], diff[1]);
      let iconAngle = Math.floor(angle);
      this.$commands.emit("refreshCursor", "direction", `rotate(${iconAngle} 8 8)`);
    } else {
      this.$commands.emit("recoverCursor");
    }
  }
  checkPointerIsNotMoved() {
    return Boolean(this.state.dragging) === false && this.$config.false("set.move.control.point");
  }
  [POINTEROVER("$pointerRect .rotate-pointer") + IF("checkPointerIsNotMoved") + PREVENT](e) {
    this.refreshRotatePointerIcon(e);
  }
  [POINTEROVER("$pointerRect .pointer") + IF("checkPointerIsNotMoved") + PREVENT](e) {
    this.refreshPointerIcon(e);
  }
  [POINTEROUT("$pointerRect .pointer,.rotate-pointer") + IF("checkPointerIsNotMoved") + PREVENT]() {
    this.$commands.emit("recoverCursor");
  }
  [POINTERSTART("$pointerRect .pointer") + PREVENT + MOVE("moveVertex") + END("moveEndVertex")](e) {
    this.refreshPointerIcon(e);
    this.state.dragging = true;
    const num = +e.$dt.attr("data-number");
    this.state.moveType = directionType$1[`${num}`];
    this.initMousePoint = this.$viewport.getWorldPosition(e);
    this.$context.selection.reselect();
    this.state.dragging = false;
    this.initMatrix(true);
    this.cachedGroupItem = this.groupItem.matrix;
    this.$config.set("set.move.control.point", true);
    this.$context.selection.startToCacheChildren();
  }
  calculateNewOffsetMatrixInverse(vertextOffset, width2, height2, origin, itemMatrix) {
    const center2 = add$1([], TransformOrigin.scale(origin, width2, height2), negate([], vertextOffset));
    return calculateMatrixInverse(fromTranslation([], vertextOffset), fromTranslation([], center2), itemMatrix, fromTranslation([], negate([], center2)));
  }
  calculateDistance(vertext, distVector, reverseMatrix) {
    const currentVertex = clone(vertext);
    const snap = this.$context.snapManager.check([add$1([], currentVertex, distVector)], 3 / this.$viewport.scale);
    const nextVertex = add$1([], currentVertex, add$1([], distVector, snap.dist));
    var currentResult = transformMat4([], currentVertex, reverseMatrix);
    var nextResult = transformMat4([], nextVertex, reverseMatrix);
    const realDist = round$2([], subtract([], nextResult, currentResult));
    return realDist;
  }
  calculateRealDist(item, vertextIndex, distVector) {
    return this.calculateDistance(item.verties[vertextIndex], distVector, item.absoluteMatrixInverse);
  }
  moveGroupItem(lastStartVertex, newWidth, newHeight) {
    this.groupItem.reset({
      x: lastStartVertex[0] + (newWidth < 0 ? newWidth : 0),
      y: lastStartVertex[1] + (newHeight < 0 ? newHeight : 0),
      width: Math.abs(newWidth),
      height: Math.abs(newHeight)
    });
  }
  moveItemForGroup(it, newVerties, realDx = 0, realDy = 0) {
    const transformViewInverse = calculateMatrixInverse(fromTranslation([], newVerties[4]), it.itemMatrix, fromTranslation([], negate([], newVerties[4])));
    const [newX, newY] = transformMat4([], newVerties[0], transformViewInverse);
    const newWidth = distance$1(newVerties[0], newVerties[1]);
    const newHeight = distance$1(newVerties[0], newVerties[3]);
    const instance = this.$model.get(it.id);
    if (instance) {
      instance.reset({
        x: newX + realDx,
        y: newY + realDy,
        width: Math.max(Math.abs(newWidth), 1),
        height: Math.max(Math.abs(newHeight), 1)
      });
    }
  }
  recoverItemForGroup(groupItem, scaleX, scaleY, realDx = 0, realDy = 0) {
    const absoluteMatrix = groupItem.absoluteMatrix;
    const absoluteMatrixInverse = groupItem.absoluteMatrixInverse;
    this.$context.selection.cachedItemMatrices.forEach((it) => {
      const localView = calculateMatrix(it.parentMatrixInverse, absoluteMatrix, fromTranslation([], [realDx, realDy, 0]), fromScaling([], [scaleX, scaleY, 1]), absoluteMatrixInverse);
      const newVerties = vertiesMap(it.verties, localView);
      this.moveItemForGroup(it, newVerties);
    });
  }
  moveBottomRightVertex(distVector) {
    const groupItem = this.cachedGroupItem;
    let [realDx, realDy] = this.calculateRealDist(groupItem, 2, distVector);
    if (this.$config.get("bodyEvent").shiftKey) {
      realDy = realDx * groupItem.height / groupItem.width;
    }
    const newWidth = groupItem.width + realDx;
    const newHeight = groupItem.height + realDy;
    this.moveDirectionVertex(groupItem, 0, 0, newWidth, newHeight, "to top left", [0, 0, 0]);
  }
  moveTopRightVertex(distVector) {
    const groupItem = this.cachedGroupItem;
    let [realDx, realDy] = this.calculateRealDist(groupItem, 1, distVector);
    if (this.$config.get("bodyEvent").shiftKey) {
      realDy = -(realDx * groupItem.height / groupItem.width);
    }
    const newWidth = groupItem.width + realDx;
    const newHeight = groupItem.height - realDy;
    this.moveDirectionVertex(groupItem, 0, realDy, newWidth, newHeight, "to bottom left", [0, newHeight, 0]);
  }
  moveDirectionVertex(groupItem, realDx, realDy, newWidth, newHeight, direction2, directionNewVector) {
    const scaleX = newWidth / groupItem.width;
    const scaleY = newHeight / groupItem.height;
    if (scaleX >= 0 && scaleY >= 0) {
      const view = calculateMatrix(groupItem.directionMatrix[direction2], this.calculateNewOffsetMatrixInverse(directionNewVector, newWidth, newHeight, groupItem.originalTransformOrigin, groupItem.itemMatrix));
      const lastStartVertex = getTranslation([], view);
      this.moveGroupItem(lastStartVertex, newWidth, newHeight);
      this.recoverItemForGroup(groupItem, scaleX, scaleY, realDx, realDy);
    }
  }
  moveTopVertex(distVector) {
    const groupItem = this.cachedGroupItem;
    const [, realDy] = this.calculateRealDist(groupItem, 0, distVector);
    const newWidth = groupItem.width;
    const newHeight = groupItem.height - realDy;
    this.moveDirectionVertex(groupItem, 0, realDy, newWidth, newHeight, "to bottom", [newWidth / 2, newHeight, 0]);
  }
  moveBottomVertex(distVector) {
    const groupItem = this.cachedGroupItem;
    const [, realDy] = this.calculateRealDist(groupItem, 2, distVector);
    const newWidth = groupItem.width;
    const newHeight = groupItem.height + realDy;
    this.moveDirectionVertex(groupItem, 0, 0, newWidth, newHeight, "to top", [
      newWidth / 2,
      0,
      0
    ]);
  }
  moveTopLeftVertex(distVector) {
    const groupItem = this.cachedGroupItem;
    let [realDx, realDy] = this.calculateRealDist(groupItem, 0, distVector);
    if (this.$config.get("bodyEvent").shiftKey) {
      realDy = realDx * groupItem.height / groupItem.width;
    }
    const newWidth = groupItem.width - realDx;
    const newHeight = groupItem.height - realDy;
    this.moveDirectionVertex(groupItem, realDx, realDy, newWidth, newHeight, "to bottom right", [newWidth, newHeight, 0]);
  }
  moveLeftVertex(distVector) {
    const groupItem = this.cachedGroupItem;
    const [realDx] = this.calculateRealDist(groupItem, 0, distVector);
    const newWidth = groupItem.width - realDx;
    const newHeight = groupItem.height;
    this.moveDirectionVertex(groupItem, realDx, 0, newWidth, newHeight, "to right", [newWidth, newHeight / 2, 0]);
  }
  moveRightVertex(distVector) {
    const groupItem = this.cachedGroupItem;
    const [realDx] = this.calculateRealDist(groupItem, 2, distVector);
    const newWidth = groupItem.width + realDx;
    const newHeight = groupItem.height;
    this.moveDirectionVertex(groupItem, 0, 0, newWidth, newHeight, "to left", [
      0,
      newHeight / 2,
      0
    ]);
  }
  moveBottomLeftVertex(distVector) {
    const groupItem = this.cachedGroupItem;
    let [realDx, realDy] = this.calculateRealDist(groupItem, 3, distVector);
    if (this.$config.get("bodyEvent").shiftKey) {
      realDy = -(realDx * groupItem.height / groupItem.width);
    }
    const newWidth = groupItem.width - realDx;
    const newHeight = groupItem.height + realDy;
    this.moveDirectionVertex(groupItem, realDx, 0, newWidth, newHeight, "to top right", [newWidth, 0, 0]);
  }
  moveVertex() {
    const targetMousePoint = this.$viewport.getWorldPosition();
    const distVector = floor([], subtract([], targetMousePoint, this.initMousePoint));
    if (this.state.moveType === "to bottom right") {
      this.moveBottomRightVertex(distVector);
    } else if (this.state.moveType === "to top right") {
      this.moveTopRightVertex(distVector);
    } else if (this.state.moveType === "to top left") {
      this.moveTopLeftVertex(distVector);
    } else if (this.state.moveType === "to bottom left") {
      this.moveBottomLeftVertex(distVector);
    } else if (this.state.moveType === "to top") {
      this.moveTopVertex(distVector);
    } else if (this.state.moveType === "to left") {
      this.moveLeftVertex(distVector);
    } else if (this.state.moveType === "to right") {
      this.moveRightVertex(distVector);
    } else if (this.state.moveType === "to bottom") {
      this.moveBottomVertex(distVector);
    }
    this.$commands.emit("setAttribute", this.$context.selection.pack("x", "y", "width", "height"));
    this.renderPointers();
    this.state.dragging = true;
  }
  moveEndVertex() {
    this.state.dragging = false;
    this.$commands.emit("recoverCursor");
    this.$config.set("set.move.control.point", false);
    this.$context.selection.reselect();
    this.initMatrix(true);
    this.nextTick(() => {
      this.$context.selection.recoverChildren();
      this.$commands.executeCommand("setAttribute", "move selection pointer", this.$context.selection.pack("x", "y", "width", "height"));
      this.$commands.emit("recoverBooleanPath");
    });
  }
  show() {
    this.$el.show();
    this.state.show = true;
  }
  hide() {
    if (this.state.show) {
      this.$el.hide();
      this.state.show = false;
    }
  }
  initSelectionTool() {
    if (this.$el.isHide() && this.$context.selection.isMany) {
      this.show();
    } else {
      if (this.$el.isShow() && this.$context.selection.isMany === false)
        this.hide();
    }
    this.initMatrix();
    this.makeSelectionTool();
  }
  get item() {
    const verties = this.verties || rectToVerties(0, 0, 0, 0);
    if (!this.state.groupSelectionView) {
      this.state.groupSelectionView = this.$editor.createModel({ itemType: "artboard" }, false);
    }
    this.state.groupSelectionView.reset({
      parentId: this.$context.selection.currentProject.id,
      x: verties[0][0],
      y: verties[0][1],
      width: dist(verties[0], verties[1]),
      height: dist(verties[0], verties[3])
    });
    return this.state.groupSelectionView;
  }
  initMatrix() {
    if (this.$context.selection.isMany && this.state.dragging === false) {
      this.verties = clone$1(this.$context.selection.verties);
      this.angle = 0;
      this.localAngle = this.angle;
      this.groupItem = this.item;
      this.cachedGroupItem = this.item.matrix;
    }
  }
  makeSelectionTool() {
    this.renderPointers();
  }
  renderPointers() {
    if (this.$context.selection.isEmpty) {
      this.refs.$pointerRect.empty();
      return;
    }
    this.state.renderPointerList = [
      this.$viewport.applyVerties(this.$context.selection.verties)
    ];
    const { line: line2, point: point2, size: size2, elementLine } = this.createRenderPointers(this.state.renderPointerList[0]);
    this.refs.$pointerRect.updateDiff(line2 + elementLine + point2 + size2);
  }
  createPointer(pointer, number, rotate2) {
    return `
        <div    
            class='pointer' 
            data-number="${number}" 
            data-pointer="${pointer}" 
            style="transform: translate3d( calc(${pointer[0]}px - 50%), calc(${pointer[1]}px - 50%), 0px) rotateZ(${rotate2 || "0deg"})" 
        ></div>
        `;
  }
  createPointerSide(pointer, number, rotate2, width2, height2) {
    return `
        <div class='pointer' data-number="${number}" data-pointer="${pointer}" style="width: ${width2}px; height: ${height2}px;transform: translate3d( calc(${pointer[0]}px - 50%), calc(${pointer[1]}px - 50%), 0px) rotateZ(${rotate2 || "0deg"})" ></div>
        `;
  }
  createRotatePointer(pointer, number) {
    if (pointer.length === 0)
      return "";
    if (number < 4) {
      return `
            <div class='rotate-pointer no-fill' data-number="${number}" style="transform: translate3d( calc(${pointer[0]}px - 50%), calc(${pointer[1]}px - 50%), 0px) scale(1.8);" ></div>
            `;
    }
    return `
        <div class='rotate-pointer' data-number="${number}" style="transform: translate3d( calc(${pointer[0]}px - 50%), calc(${pointer[1]}px - 50%), 0px)" ></div>
        `;
  }
  createPointerRect(pointers, rotatePointer) {
    if (pointers.length === 0)
      return "";
    const centerPointer = lerp([], pointers[0], pointers[1], 0.5);
    const line2 = `
            M ${centerPointer[0]},${centerPointer[1]} 
            L ${rotatePointer[0]}, ${rotatePointer[1]} 
        `;
    return `
        <svg class='line' overflow="visible">
            <path 
                d="
                    M ${pointers[0][0]}, ${pointers[0][1]} 
                    L ${pointers[1][0]}, ${pointers[1][1]} 
                    L ${pointers[2][0]}, ${pointers[2][1]} 
                    L ${pointers[3][0]}, ${pointers[3][1]} 
                    L ${pointers[0][0]}, ${pointers[0][1]}
                    ${line2}
                    Z
                " />
        </svg>`;
  }
  createLine(pointers) {
    return `
            M ${pointers[0][0]}, ${pointers[0][1]} 
            L ${pointers[1][0]}, ${pointers[1][1]} 
            L ${pointers[2][0]}, ${pointers[2][1]} 
            L ${pointers[3][0]}, ${pointers[3][1]} 
            L ${pointers[0][0]}, ${pointers[0][1]}
            Z
        `;
  }
  createSize(pointers) {
    const top2 = lerp([], pointers[0], pointers[1], 0.5);
    const right2 = lerp([], pointers[1], pointers[2], 0.5);
    const bottom2 = lerp([], pointers[2], pointers[3], 0.5);
    const left2 = lerp([], pointers[3], pointers[0], 0.5);
    const worldPosition = this.$viewport.applyVertiesInverse(pointers);
    const width2 = dist(worldPosition[0], worldPosition[1]);
    const height2 = dist(worldPosition[0], worldPosition[3]);
    const list2 = [
      { start: top2, end: bottom2 },
      { start: right2, end: left2 },
      { start: bottom2, end: top2 },
      { start: left2, end: right2 }
    ].map((it, index2) => {
      return { index: index2, data: it };
    });
    list2.sort((a, b) => {
      return a.data.start[1] > b.data.start[1] ? -1 : 1;
    });
    const item = list2[0];
    const newPointer = lerp([], item.data.end, item.data.start, 1 + 16 / dist(item.data.start, item.data.end));
    const diff = subtract([], item.data.start, item.data.end);
    const angle = calculateAngle360(diff[0], diff[1]) + 90;
    let text2 = `${round(width2, 100)} x ${round(height2, 100)}`;
    if (this.state.isRotate) {
      const rotateZ2 = this.groupItem.angle;
      if (rotateZ2) {
        text2 = `${rotateZ2}\xB0`;
      }
    }
    return `<div class='size-pointer' style="transform: translate3d( calc(${newPointer[0]}px - 50%), calc(${newPointer[1]}px - 50%), 0px) rotateZ(${angle}deg)" >${text2}</div>`;
  }
  createRenderPointers(pointers) {
    const diff = subtract([], lerp([], pointers[0], pointers[1], 0.5), lerp([], pointers[0], pointers[2], 0.5));
    const rotate2 = Length.deg(calculateAngle360(diff[0], diff[1]) - 90).round(1e3);
    const rotatePointer = getRotatePointer(pointers, 30);
    const dist$1 = dist(pointers[0], pointers[2]);
    const width2 = dist(pointers[0], pointers[1]);
    const height2 = dist(pointers[0], pointers[3]);
    return {
      line: this.createPointerRect(pointers, rotatePointer),
      elementLine: `
                <svg class='line' overflow="visible">
                    <path 
                        d="${this.$context.selection.items.map((it) => {
        return this.createLine(this.$viewport.applyVerties(it.originVerties));
      }).join("")}
                        " />
                </svg>
            `,
      size: this.createSize(pointers),
      point: [
        this.createRotatePointer(rotatePointer, 4, "center center"),
        dist$1 < 20 ? void 0 : this.createPointerSide(lerp([], pointers[0], pointers[1], 0.5), 11, rotate2, width2, 5),
        dist$1 < 20 ? void 0 : this.createPointerSide(lerp([], pointers[1], pointers[2], 0.5), 12, rotate2, 5, height2),
        dist$1 < 20 ? void 0 : this.createPointerSide(lerp([], pointers[2], pointers[3], 0.5), 13, rotate2, width2, 5),
        dist$1 < 20 ? void 0 : this.createPointerSide(lerp([], pointers[3], pointers[0], 0.5), 14, rotate2, 5, height2),
        this.createPointer(pointers[0], 1, rotate2),
        this.createPointer(pointers[1], 2, rotate2),
        this.createPointer(pointers[2], 3, rotate2),
        this.createPointer(pointers[3], 4, rotate2)
      ].join("")
    };
  }
  checkShow() {
    if (this.state.show && this.$context.selection.isMany) {
      return true;
    }
    return false;
  }
  [SUBSCRIBE("hideSelectionToolView")]() {
    this.hide();
  }
}
var directionType = {
  1: "to top left",
  2: "to top right",
  3: "to bottom right",
  4: "to bottom left",
  11: "to top",
  12: "to right",
  13: "to bottom",
  14: "to left"
};
const SelectionToolEvent = class extends EditorElement {
  checkViewMode() {
    return this.$modeView.isCurrentMode(ViewModeType.CanvasView);
  }
  [SUBSCRIBE(REFRESH_SELECTION, REFRESH_SELECTION_TOOL) + IF("checkViewMode")]() {
    this.initSelectionTool();
  }
  [SUBSCRIBE(UPDATE_VIEWPORT) + IF("checkViewMode")]() {
    if (this.$context.selection.isOne) {
      this.initSelectionTool();
    } else {
      this.hide();
    }
  }
  [SUBSCRIBE("updateModeView")]() {
    if (this.checkViewMode()) {
      this.initSelectionTool();
    } else {
      this.hide();
    }
  }
};
class SelectionToolView extends SelectionToolEvent {
  template() {
    return `
            <div class='elf--selection-view one-selection-view' ref='$selectionView' style='display:none' >
                <div class='pointer-rect' ref='$pointerRect'></div>
            </div>
        `;
  }
  toggleEditingPath(isEditingPath) {
    this.$el.toggleClass("editing-path", isEditingPath);
  }
  [POINTERSTART("$pointerRect .rotate-pointer") + MOVE("rotateVertex") + END("rotateEndVertex")](e) {
    this.state.moveType = "rotate";
    this.initMousePoint = this.$viewport.getWorldPosition(e);
    this.$context.selection.reselect();
    this.verties = clone$1(this.$context.selection.verties);
    this.$context.snapManager.clear();
    this.rotateTargetNumber = +e.$dt.attr("data-number");
    this.refreshRotatePointerIcon();
    this.state.dragging = true;
    this.state.isRotate = true;
    this.initAngle = this.$context.selection.current.angle;
  }
  rotateVertex() {
    const targetMousePoint = this.$viewport.getWorldPosition();
    const distVector = subtract([], targetMousePoint, this.initMousePoint);
    const targetRotatePointer = this.rotateTargetNumber === 4 ? getRotatePointer(this.verties, 34) : this.verties[this.rotateTargetNumber];
    var distAngle = Math.floor(calculateAngleForVec3(targetRotatePointer, this.verties[4], distVector));
    const instance = this.$context.selection.current;
    let newAngle = this.initAngle + distAngle;
    if (instance) {
      if (this.$config.get("bodyEvent").shiftKey) {
        newAngle -= newAngle % this.$config.get("fixed.angle");
      }
      instance.angle = round(newAngle % 360, 100);
    }
    this.state.dragging = true;
    this.$commands.emit("setAttribute", this.$context.selection.pack("angle"));
    this.makeSelectionTool();
  }
  rotateEndVertex() {
    this.state.dragging = false;
    this.state.isRotate = false;
    this.$commands.emit("recoverCursor");
    this.verties = null;
    this.$commands.executeCommand("setAttribute", "change rotate", this.$context.selection.pack("angle"));
  }
  refreshRotatePointerIcon() {
    this.$commands.emit("refreshCursor", "rotate");
  }
  refreshPointerIcon(e) {
    const dataPointer = e.$dt.data("pointer");
    if (dataPointer) {
      const pointer = dataPointer.split(",").map((it) => Number(it));
      const diff = subtract([], pointer, this.state.renderPointerList[0][4]);
      const angle = calculateAngle360(diff[0], diff[1]);
      let iconAngle = Math.floor(angle);
      this.$commands.emit("refreshCursor", "direction", `rotate(${iconAngle} 8 8)`);
    } else {
      this.$commands.emit("recoverCursor");
    }
  }
  checkPointerIsNotMoved() {
    return Boolean(this.state.dragging) === false && this.$config.false("set.move.control.point");
  }
  [POINTEROVER("$pointerRect .rotate-pointer") + IF("checkPointerIsNotMoved")](e) {
    this.refreshRotatePointerIcon(e);
  }
  [POINTEROVER("$pointerRect .pointer") + IF("checkPointerIsNotMoved")](e) {
    this.refreshPointerIcon(e);
  }
  [POINTEROUT("$pointerRect .pointer,.rotate-pointer") + IF("checkPointerIsNotMoved")]() {
    this.$commands.emit("recoverCursor");
  }
  [POINTERSTART("$pointerRect .pointer") + MOVE("moveVertex") + END("moveEndVertex")](e) {
    this.refreshPointerIcon(e);
    this.state.dragging = true;
    const num = +e.$dt.attr("data-number");
    const direction2 = directionType[`${num}`];
    this.initMousePoint = this.$viewport.getWorldPosition(e);
    this.state.moveType = direction2;
    this.state.moveTarget = num;
    this.$context.snapManager.clear();
    this.verties = this.$context.selection.verties;
    this.hasRotate = this.$context.selection.current.angle !== 0;
    this.cachedCurrentItemMatrix = this.$context.selection.current.matrix;
    this.$context.selection.startToCacheChildren();
  }
  calculateDistance(vertex, distVector, reverseMatrix) {
    const currentVertex = clone(vertex);
    const moveVertex = add$1([], currentVertex, distVector);
    const snap = this.$context.snapManager.check([moveVertex], 5 / this.$viewport.scale);
    const nextVertex = add$1([], moveVertex, snap.dist);
    const [currentResult, nextResult] = vertiesMap([currentVertex, nextVertex], reverseMatrix);
    const realDist = subtract([], nextResult, currentResult);
    return realDist;
  }
  calculateRealDist(item, vertexIndex, distVector) {
    return this.calculateDistance(item.verties[vertexIndex], distVector, item.absoluteMatrixInverse);
  }
  moveItem(instance, lastStartVertex, newWidth, newHeight, options2 = {}) {
    if (instance) {
      let data = {
        x: lastStartVertex[0] + (newWidth < 0 ? newWidth : 0),
        y: lastStartVertex[1] + (newHeight < 0 ? newHeight : 0),
        width: Math.max(Math.abs(newWidth), 1),
        height: Math.max(Math.abs(newHeight), 1)
      };
      if (instance.isInFlex()) {
        delete data.x;
        delete data.y;
      } else if (instance.isInGrid())
        ;
      if (this.hasRotate)
        ;
      else {
        data = objectFloor(data);
        data.width = Math.max(data.width, 1);
        data.height = Math.max(data.height, 1);
      }
      instance.reset(__spreadValues(__spreadValues({}, data), options2));
    }
  }
  moveDirectionVertex(item, newWidth, newHeight, direction2, directionNewVector, options2 = {}) {
    const center2 = subtract([], TransformOrigin.scale(item.originalTransformOrigin, newWidth, newHeight), directionNewVector);
    const newOffsetInverse = calculateMatrixInverse(fromTranslation([], directionNewVector), fromTranslation([], center2), item.itemMatrix, fromTranslation([], negate([], center2)));
    const view = calculateMatrix(item.directionMatrix[direction2], newOffsetInverse);
    const lastStartVertex = getTranslation([], view);
    this.moveItem(this.$model.get(item.id), lastStartVertex, newWidth, newHeight, options2);
  }
  moveBottomRightVertex(distVector) {
    const { shiftKey, altKey, metaKey } = this.$config.get("bodyEvent");
    const item = this.cachedCurrentItemMatrix;
    if (item) {
      let [realDx, realDy] = this.calculateRealDist(item, 2, distVector);
      let directionNewVector = fromValues(0, 0, 0);
      if (altKey) {
        realDx = realDx * 2;
        realDy = realDy * 2;
      }
      if (shiftKey) {
        realDy = realDx * item.height / item.width;
      }
      const newWidth = item.width + realDx;
      const newHeight = metaKey ? newWidth : item.height + realDy;
      if (altKey) {
        directionNewVector = fromValues(realDx / 2, realDy / 2, 0);
      }
      this.moveDirectionVertex(item, newWidth, newHeight, "to top left", directionNewVector, {
        resizingVertical: ResizingMode.FIXED,
        resizingHorizontal: ResizingMode.FIXED
      });
      this.updateGridArea(item);
    }
  }
  moveTopRightVertex(distVector) {
    const { shiftKey, altKey, metaKey } = this.$config.get("bodyEvent");
    const item = this.cachedCurrentItemMatrix;
    if (item) {
      let [realDx, realDy] = this.calculateRealDist(item, 1, distVector);
      if (altKey) {
        realDx = realDx * 2;
        realDy = realDy * 2;
      }
      if (shiftKey) {
        realDy = -(realDx * item.height / item.width);
      }
      const newWidth = item.width + realDx;
      const newHeight = metaKey ? newWidth : item.height - realDy;
      let directionNewVector = fromValues(0, newHeight, 0);
      if (altKey) {
        directionNewVector = fromValues(realDx / 2, newHeight + realDy / 2, 0);
      }
      this.moveDirectionVertex(item, newWidth, newHeight, "to bottom left", directionNewVector, {
        resizingVertical: ResizingMode.FIXED,
        resizingHorizontal: ResizingMode.FIXED
      });
      this.updateGridArea(item);
    }
  }
  moveTopLeftVertex(distVector) {
    const { shiftKey, altKey, metaKey } = this.$config.get("bodyEvent");
    const item = this.cachedCurrentItemMatrix;
    if (item) {
      let [realDx, realDy] = this.calculateRealDist(item, 0, distVector);
      if (altKey) {
        realDx = realDx * 2;
        realDy = realDy * 2;
      }
      if (shiftKey) {
        realDy = realDx * item.height / item.width;
      }
      const newWidth = item.width - realDx;
      const newHeight = metaKey ? newWidth : item.height - realDy;
      let directionNewVector = fromValues(newWidth, newHeight, 0);
      if (altKey) {
        directionNewVector = fromValues(newWidth + realDx / 2, newHeight + realDy / 2, 0);
      }
      this.moveDirectionVertex(item, newWidth, newHeight, "to bottom right", directionNewVector, {
        resizingHorizontal: ResizingMode.FIXED,
        resizingVertical: ResizingMode.FIXED
      });
      this.updateGridArea(item);
    }
  }
  moveTopVertex(distVector) {
    const { altKey } = this.$config.get("bodyEvent");
    const item = this.cachedCurrentItemMatrix;
    if (item) {
      let [, realDy] = this.calculateRealDist(item, 0, distVector);
      if (altKey) {
        realDy = realDy * 2;
      }
      const newWidth = item.width;
      const newHeight = item.height - realDy;
      let directionNewVector = fromValues(newWidth / 2, newHeight, 0);
      if (altKey) {
        directionNewVector = fromValues(newWidth / 2, newHeight + realDy / 2, 0);
      }
      this.moveDirectionVertex(item, newWidth, newHeight, "to bottom", directionNewVector, {
        resizingVertical: ResizingMode.FIXED
      });
      this.updateGridArea(item);
    }
  }
  moveBottomVertex(distVector) {
    const { altKey } = this.$config.get("bodyEvent");
    const item = this.cachedCurrentItemMatrix;
    if (item) {
      let [, realDy] = this.calculateRealDist(item, 3, distVector);
      if (altKey) {
        realDy = realDy * 2;
      }
      const newWidth = item.width;
      const newHeight = item.height + realDy;
      let directionNewVector = fromValues(newWidth / 2, 0, 0);
      if (altKey) {
        directionNewVector = fromValues(newWidth / 2, realDy / 2, 0);
      }
      this.moveDirectionVertex(item, newWidth, newHeight, "to top", directionNewVector, {
        resizingVertical: ResizingMode.FIXED
      });
      this.updateGridArea(item);
    }
  }
  moveRightVertex(distVector) {
    const { shiftKey, altKey, metaKey } = this.$config.get("bodyEvent");
    const item = this.cachedCurrentItemMatrix;
    if (item) {
      let [realDx] = this.calculateRealDist(item, 1, distVector);
      if (altKey) {
        realDx = realDx * 2;
      }
      const newWidth = item.width + realDx;
      let newHeight = item.height;
      if (metaKey) {
        newHeight = newWidth;
      } else if (shiftKey) {
        newHeight = item.height * (1 + realDx / item.width);
      }
      let directionNewVector = fromValues(0, newHeight / 2, 0);
      if (altKey) {
        directionNewVector = fromValues(realDx / 2, newHeight / 2, 0);
      }
      this.moveDirectionVertex(item, newWidth, newHeight, "to left", directionNewVector, {
        resizingHorizontal: ResizingMode.FIXED
      });
      this.updateGridArea(item);
    }
  }
  moveLeftVertex(distVector) {
    const { shiftKey, altKey, metaKey } = this.$config.get("bodyEvent");
    const item = this.cachedCurrentItemMatrix;
    if (item) {
      let [realDx] = this.calculateRealDist(item, 0, distVector);
      if (altKey) {
        realDx = realDx * 2;
      }
      const newWidth = item.width - realDx;
      let newHeight = item.height;
      if (metaKey) {
        newHeight = newWidth;
      } else if (shiftKey) {
        newHeight = item.height * (1 - realDx / item.width);
      }
      let directionNewVector = fromValues(newWidth, newHeight / 2, 0);
      if (altKey) {
        directionNewVector = fromValues(newWidth + realDx / 2, newHeight / 2, 0);
      }
      this.moveDirectionVertex(item, newWidth, newHeight, "to right", directionNewVector, {
        resizingHorizontal: ResizingMode.FIXED
      });
      this.updateGridArea(item);
    }
  }
  moveBottomLeftVertex(distVector) {
    const { shiftKey, altKey, metaKey } = this.$config.get("bodyEvent");
    const item = this.cachedCurrentItemMatrix;
    if (item) {
      let [realDx, realDy] = this.calculateRealDist(item, 3, distVector);
      if (altKey) {
        realDx = realDx * 2;
        realDy = realDy * 2;
      }
      if (shiftKey) {
        realDy = -(realDx * item.height / item.width);
      }
      const newWidth = item.width - realDx;
      const newHeight = metaKey ? newWidth : item.height + realDy;
      let directionNewVector = fromValues(newWidth, 0, 0);
      if (altKey) {
        directionNewVector = fromValues(newWidth + realDx / 2, realDy / 2, 0);
      }
      this.moveDirectionVertex(item, newWidth, newHeight, "to top right", directionNewVector, {
        resizingVertical: ResizingMode.FIXED,
        resizingHorizontal: ResizingMode.FIXED
      });
      this.updateGridArea(item);
    }
  }
  moveVertex() {
    const targetMousePoint = this.$viewport.getWorldPosition();
    const distVector = floor([], subtract([], targetMousePoint, this.initMousePoint));
    if (this.state.moveType === "to top left") {
      this.moveTopLeftVertex(distVector);
    } else if (this.state.moveType === "to top") {
      this.moveTopVertex(distVector);
    } else if (this.state.moveType === "to right") {
      this.moveRightVertex(distVector);
    } else if (this.state.moveType === "to bottom") {
      this.moveBottomVertex(distVector);
    } else if (this.state.moveType === "to left") {
      this.moveLeftVertex(distVector);
    } else if (this.state.moveType === "to top right") {
      this.moveTopRightVertex(distVector);
    } else if (this.state.moveType === "to bottom right") {
      this.moveBottomRightVertex(distVector);
    } else if (this.state.moveType === "to bottom left") {
      this.moveBottomLeftVertex(distVector);
    }
    this.$context.selection.recoverChildren();
    const current = this.$context.selection.current;
    if (current.isInGrid()) {
      this.$commands.emit("setAttribute", this.$context.selection.pack("x", "y", "angle", "width", "height", "resizingHorizontal", "resizingVertical", "grid-column-start", "grid-column-end", "grid-row-start", "grid-row-end"));
    } else {
      this.$commands.emit("setAttribute", this.$context.selection.pack("x", "y", "angle", "width", "height", "resizingHorizontal", "resizingVertical"));
    }
    this.state.dragging = true;
    this.makeSelectionTool();
  }
  updateGridArea() {
    return GridLayoutEngine.updateGridArea(this.$context.selection.current, this.$context.selection.gridInformation, this.$context.viewport.scale);
  }
  moveEndVertex() {
    this.state.dragging = false;
    this.$commands.emit("recoverCursor");
    this.$context.selection.reselect();
    this.nextTick(() => {
      this.$context.selection.recoverChildren();
      if (this.$context.selection.current.isInGrid()) {
        this.$commands.executeCommand("setAttribute", "move selection pointer", this.$context.selection.pack("x", "y", "angle", "width", "height", "resizingHorizontal", "resizingVertical", "grid-column-start", "grid-column-end", "grid-row-start", "grid-row-end"));
      } else {
        this.$commands.executeCommand("setAttribute", "move selection pointer", this.$context.selection.pack("x", "y", "angle", "width", "height", "resizingHorizontal", "resizingVertical"));
      }
      this.$commands.emit("recoverBooleanPath");
    });
  }
  show() {
    this.$el.show();
    this.state.show = true;
  }
  hide() {
    this.$el.hide();
    this.state.show = false;
  }
  initSelectionTool() {
    if (this.$el.isShow() && this.$context.selection.isOne === false) {
      this.hide();
    } else if (this.$el.isHide() && this.$context.selection.isOne) {
      this.show();
    }
    this.makeSelectionTool();
  }
  makeSelectionTool() {
    this.renderPointers();
  }
  getRateDistance(startVetex, endVertex, dist$1 = 0) {
    return lerp([], startVetex, endVertex, (dist(startVetex, endVertex) + dist$1) / dist(startVetex, endVertex));
  }
  renderPointers() {
    if (this.$context.selection.isEmpty || this.$config.true("set.move.control.point")) {
      this.refs.$pointerRect.empty();
      return;
    }
    const verties = this.$context.selection.verties;
    if (dist(verties[0], verties[1]) === 0) {
      return;
    }
    const screenVerties = this.$viewport.applyVerties(verties).map((it) => {
      return round$2([], it);
    });
    this.state.renderPointerList = [
      screenVerties,
      [
        this.getRateDistance(screenVerties[4], screenVerties[0], 20),
        this.getRateDistance(screenVerties[4], screenVerties[1], 20),
        this.getRateDistance(screenVerties[4], screenVerties[2], 20),
        this.getRateDistance(screenVerties[4], screenVerties[3], 20)
      ]
    ];
    const pointers = this.createRenderPointers(...this.state.renderPointerList);
    if (pointers) {
      const { line: line2, parentRect, point: point2, size: size2, visiblePath } = pointers;
      this.refs.$pointerRect.updateDiff(line2 + parentRect + point2 + size2 + visiblePath);
    }
  }
  createPointer(pointer, number, rotate2) {
    return `<div class='pointer' data-number="${number}" data-pointer="${pointer}" style="transform: translate3d( calc(${pointer[0]}px - 50%), calc(${pointer[1]}px - 50%), 0px) rotateZ(${rotate2 || "0deg"})" ></div>`;
  }
  createPointerSide(pointer, number, rotate2, width2, height2) {
    return `<div class='pointer' data-number="${number}" data-pointer="${pointer}" style="width: ${width2}px; height: ${height2}px;transform: translate3d( calc(${pointer[0]}px - 50%), calc(${pointer[1]}px - 50%), 0px) rotateZ(${rotate2 || "0deg"})" ></div>`;
  }
  createRotatePointer(pointer, number) {
    if (pointer.length === 0)
      return "";
    if (number < 4) {
      return `<div class='rotate-pointer no-fill' data-number="${number}" style="transform: translate3d( calc(${pointer[0]}px - 50%), calc(${pointer[1]}px - 50%), 0px) scale(1.8);" ></div>`;
    }
    return `<div class='rotate-pointer' data-number="${number}" style="transform: translate3d( calc(${pointer[0]}px - 50%), calc(${pointer[1]}px - 50%), 0px)" ></div>`;
  }
  createPointerRect(pointers, rotatePointer = void 0) {
    if (pointers.length === 0)
      return "";
    const current = this.$context.selection.current;
    const isArtBoard = current && current.is("artboard");
    let line2 = "";
    if (!isArtBoard && rotatePointer) {
      const centerPointer = lerp([], pointers[0], pointers[1], 0.5);
      line2 += `
                M ${centerPointer[0]},${centerPointer[1]} 
                L ${rotatePointer[0]},${rotatePointer[1]} 
            `;
    }
    return `<svg class='line' overflow="visible"> <path  d=" M ${pointers[0][0]}, ${pointers[0][1]} L ${pointers[1][0]}, ${pointers[1][1]} L ${pointers[2][0]}, ${pointers[2][1]} L ${pointers[3][0]}, ${pointers[3][1]} L ${pointers[0][0]}, ${pointers[0][1]} ${line2} Z" />
        </svg>`;
  }
  createParentRect(pointers = []) {
    if (pointers.length === 0)
      return "";
    return `
        <svg class='line' overflow="visible">
            <path 
                d="
                    M ${pointers[0][0]}, ${pointers[0][1]} 
                    L ${pointers[1][0]}, ${pointers[1][1]} 
                    L ${pointers[2][0]}, ${pointers[2][1]} 
                    L ${pointers[3][0]}, ${pointers[3][1]} 
                    L ${pointers[0][0]}, ${pointers[0][1]}
                    Z
                " 
                stroke="red"
                />
        </svg>`;
  }
  createSize(pointers) {
    const top2 = lerp([], pointers[0], pointers[1], 0.5);
    const right2 = lerp([], pointers[1], pointers[2], 0.5);
    const bottom2 = lerp([], pointers[2], pointers[3], 0.5);
    const left2 = lerp([], pointers[3], pointers[0], 0.5);
    const list2 = [
      { start: top2, end: bottom2 },
      { start: right2, end: left2 },
      { start: bottom2, end: top2 },
      { start: left2, end: right2 }
    ].map((it, index2) => {
      return { index: index2, data: it };
    });
    list2.sort((a, b) => {
      return a.data.start[1] > b.data.start[1] ? -1 : 1;
    });
    const item = list2[0];
    const newPointer = lerp([], item.data.end, item.data.start, 1 + 16 / dist(item.data.start, item.data.end));
    const width2 = this.$context.selection.current.width;
    const height2 = this.$context.selection.current.height;
    const diff = subtract([], item.data.start, item.data.end);
    const angle = calculateAngle360(diff[0], diff[1]) + 90;
    const widthPx = round(width2, 100);
    const heightPx = round(height2, 100);
    let text2 = widthPx === heightPx ? `WH: ${widthPx}` : `${round(width2, 100)} x ${round(height2, 100)}`;
    if (this.state.isRotate) {
      text2 = `${round(this.$context.selection.current.angle, 100)}\xB0`;
    }
    return `<div data-layout="${this.$context.selection.current.layout}" class='size-pointer' style="transform: translate3d( calc(${newPointer[0]}px - 50%), calc(${newPointer[1]}px - 50%), 0px) rotateZ(${angle}deg)" >${text2}</div>`;
  }
  createVisiblePath() {
    const current = this.$context.selection.current;
    if (!current)
      return "";
    if (!current.isBooleanItem) {
      return "";
    }
    const newPath = current.absolutePath();
    newPath.transformMat4(this.$viewport.matrix);
    return `
        <svg class='line' overflow="visible">
            <path
                d="${newPath.d}"
                stroke="red"
                stroke-width="2"
                fill="none"
                />
        </svg>
        `;
  }
  removeNaN(value) {
    return value.replace(/NaN/g, "0");
  }
  createRenderPointers(pointers, selectionPointers) {
    const current = this.$context.selection.current;
    if (current && current.is("text")) {
      if (current.width === 0 && current.height === 0) {
        return;
      }
    }
    const rotate2 = Length.deg(current.nestedAngle).round(1e3);
    const dist$1 = dist(pointers[0], pointers[2]);
    const width2 = dist(pointers[0], pointers[1]);
    const height2 = dist(pointers[0], pointers[3]);
    return {
      line: this.createPointerRect(pointers),
      size: this.createSize(pointers),
      parentRect: "",
      visiblePath: this.createVisiblePath(),
      point: [
        this.createRotatePointer(selectionPointers[0], 0),
        this.createRotatePointer(selectionPointers[1], 1),
        this.createRotatePointer(selectionPointers[2], 2),
        this.createRotatePointer(selectionPointers[3], 3),
        dist$1 < 20 ? void 0 : this.createPointerSide(lerp([], pointers[0], pointers[1], 0.5), 11, rotate2, width2, 5),
        dist$1 < 20 ? void 0 : this.createPointerSide(lerp([], pointers[1], pointers[2], 0.5), 12, rotate2, 5, height2),
        dist$1 < 20 ? void 0 : this.createPointerSide(lerp([], pointers[2], pointers[3], 0.5), 13, rotate2, width2, 5),
        dist$1 < 20 ? void 0 : this.createPointerSide(lerp([], pointers[3], pointers[0], 0.5), 14, rotate2, 5, height2),
        this.createPointer(pointers[0], 1, rotate2),
        this.createPointer(pointers[1], 2, rotate2),
        this.createPointer(pointers[2], 3, rotate2),
        this.createPointer(pointers[3], 4, rotate2),
        this.createPointer(pointers[4], 5, rotate2)
      ].join("")
    };
  }
  checkShow() {
    if (this.$modeView.isCurrentMode(ViewModeType.CanvasView) === false) {
      return false;
    }
    if (this.state.show && this.$context.selection.isOne) {
      return true;
    }
    return false;
  }
  [SUBSCRIBE("hideSelectionToolView")]() {
    this.hide();
  }
}
async function selectionToolView(editor) {
  editor.registerUI("canvas.view", {
    GhostToolView,
    SelectionToolView,
    GroupSelectionToolView
  }, CanvasViewToolLevel.SELECTION_TOOL);
}
var SelectorPopup$1 = "";
class SelectorPopup extends BasePopup {
  getTitle() {
    return this.$i18n("selector.popup.title");
  }
  initState() {
    return {
      selector: "",
      properties: []
    };
  }
  updateData(opt) {
    this.setState(opt, false);
    this.emit("changeSelectorPopup", this.state);
  }
  getBody() {
    return `
    <div class='elf--selector-popup' ref='$popup'>
      <div class="box">
        ${this.templateForSelector()}
        ${this.templateForProperty()}        
      </div>
    </div>`;
  }
  templateForProperty() {
    return createComponent("CSSPropertyEditor", {
      ref: "$propertyEditor",
      onchange: "changePropertyEditor"
    });
  }
  templateForSelector() {
    return `
      <div class='name'>
        <label>${this.$i18n("selector.popup.selector")}</label>
        <div class='input grid-1'>
          <input type='text' value='${this.state.selector}' ref='$selector'/>
        </div>
      </div>
    `;
  }
  [INPUT("$selector")](e) {
    if (this.refs.$selector.value.match(/^[a-zA-Z0-9:_\-.\b]+$/)) {
      this.updateData({ selector: this.refs.$selector.value });
    } else {
      e.preventDefault();
      e.stopPropagation();
      return false;
    }
  }
  refresh() {
    super.refresh();
    this.refs.$selector.val(this.state.selector);
    this.children.$propertyEditor.trigger("showCSSPropertyEditor", this.state.properties);
  }
  [SUBSCRIBE("changePropertyEditor")](properties) {
    this.updateData({
      properties
    });
  }
  [SUBSCRIBE("showSelectorPopup")](data) {
    this.setState(data);
    this.refresh();
    this.show(250);
  }
}
var SelectorProperty$1 = "";
const selectorList = [
  "",
  ":hover",
  ":active",
  ":before",
  ":after",
  ":first-child",
  ":last-child",
  ":link",
  ":active",
  ":focus"
].map((value) => ({ value }));
class SelectorProperty extends BaseProperty {
  getTitle() {
    return this.$i18n("selector.property.title");
  }
  getBody() {
    return `<div class='elf--selector-list' ref='$selectorList'></div>`;
  }
  getTools() {
    return `
      <div style='display:inline-block;'>
        ${createComponent("SelectEditor", {
      ref: "$select",
      key: "selector",
      "none-value": "selector",
      options: selectorList
    })}
      </div>
      <button type="button" ref="$add" title="add Selector">${obj$2.add}</button>
    `;
  }
  makeSelectorTemplate(selector2, index2) {
    index2 = index2.toString();
    return `
      <div class='selector-item' draggable='true' ref='$selectorIndex${index2}' data-index='${index2}'>
        <div class='title'>
          <div class='name'>
            <span>${selector2.selector || `&lt;${this.$i18n("selector.property.none")}&gt;`}</span>
          </div>
          <div class='tools'>
              <button type="button" class="del" data-index="${index2}">${obj$2.remove2}</button>
          </div>
        </div>
      </div>
    `;
  }
  [CLICK("$selectorList .selector-item .name")](e) {
    var index2 = +e.$dt.closest("selector-item").attr("data-index");
    var current = this.$context.selection.current;
    if (!current)
      return;
    this.viewSelectorPicker(index2);
  }
  [CLICK("$selectorList .selector-item .del") + PREVENT + STOP](e) {
    var removeIndex = e.$dt.attr("data-index");
    var current = this.$context.selection.current;
    if (!current)
      return;
    current.removeSelector(removeIndex);
    this.$commands.executeCommand("setAttribute", "change selectors", this.$context.selection.pack("selectors"));
    this.refresh();
  }
  [SUBSCRIBE(REFRESH_SELECTION) + DEBOUNCE(100)]() {
    this.refreshShowIsNot([
      "project",
      "svg-path",
      "svg-brush",
      "svg-textpath",
      "svg-text"
    ]);
  }
  [LOAD("$selectorList")]() {
    var current = this.$context.selection.current;
    if (!current)
      return "";
    var selectors = current.selector ? Selector.parseStyle(current) : current.selectors;
    return (selectors || []).map((selector2, index2) => {
      return this.makeSelectorTemplate(selector2, index2);
    });
  }
  [DRAGSTART("$selectorList .selector-item .title")](e) {
    this.startIndex = +e.$dt.attr("data-index");
  }
  [DRAGOVER("$selectorList .selector-item") + PREVENT]() {
  }
  [DROP("$selectorList .selector-item") + PREVENT](e) {
    var targetIndex = +e.$dt.attr("data-index");
    var current = this.$context.selection.current;
    if (!current)
      return;
    current.sortSelector(this.startIndex, targetIndex);
    this.$commands.executeCommand("setAttribute", "change selectors", this.$context.selection.pack("selectors"));
    this.refresh();
  }
  [CLICK("$add")]() {
    var current = this.$context.selection.current;
    if (current) {
      current.createSelector({
        selector: this.children.$select.getValue()
      });
      this.$commands.executeCommand("setAttribute", "change selectors", this.$context.selection.pack("selectors"));
    }
    this.refresh();
  }
  viewSelectorPicker(index2) {
    if (typeof this.selectedIndex === "number") {
      this.selectItem(this.selectedIndex, false);
    }
    this.selectedIndex = +index2;
    this.selectItem(this.selectedIndex, true);
    this.current = this.$context.selection.current;
    if (!this.current)
      return;
    this.currentSelector = this.current.selectors[this.selectedIndex];
    this.viewSelectorPropertyPopup();
  }
  selectItem(selectedIndex, isSelected = true) {
    if (isSelected) {
      this.getRef("$selectorIndex", selectedIndex).addClass("selected");
    } else {
      this.getRef("$selectorIndex", selectedIndex).removeClass("selected");
    }
    if (this.current) {
      this.current.selectors.forEach((it, index2) => {
        it.selected = index2 === selectedIndex;
      });
    }
  }
  viewSelectorPropertyPopup(position2) {
    this.current = this.$context.selection.current;
    if (!this.current)
      return;
    this.currentSelector = this.current.selectors[this.selectedIndex];
    const back = this.currentSelector;
    const selector2 = back.selector;
    const properties = back.properties;
    this.emit("showSelectorPopup", {
      position: position2,
      selector: selector2,
      properties
    });
  }
  [SUBSCRIBE("changeSelectorPopup")](data) {
    this.current = this.$context.selection.current;
    if (!this.current)
      return;
    this.currentselector = this.current.selectors[this.selectedIndex];
    if (this.currentSelector) {
      this.currentSelector.reset(data);
    }
    this.refresh();
    this.$commands.executeCommand("setAttribute", "change selectors", this.$context.selection.pack("selectors"));
  }
}
function selector(editor) {
  editor.registerUI("inspector.tab.transition", {
    SelectorProperty
  });
  editor.registerUI("popup", {
    SelectorPopup
  });
}
var SVGFilterAssetsProperty$1 = "";
class SVGFilterAssetsProperty extends BaseProperty {
  getTitle() {
    return this.$i18n("svgfilter.asset.property.title");
  }
  initState() {
    return {
      mode: "grid"
    };
  }
  getClassName() {
    return "elf--svgfilter-assets-property";
  }
  [SUBSCRIBE(REFRESH_SELECTION) + DEBOUNCE(100)]() {
    this.show();
  }
  getBody() {
    return `
      <div class='property-item svgfilter-assets'>
        <div class='svgfilter-list' ref='$svgfilterList' data-view-mode='${this.state.mode}'></div>
      </div>
    `;
  }
  [LOAD("$svgfilterList")]() {
    var current = this.$context.selection.currentProject || { svgfilters: [] };
    var svgfilters = current.svgfilters;
    var results = svgfilters.map((svgfilter, index2) => {
      var filters = svgfilter.filters.map((filter2) => {
        return SVGFilter.parse(filter2);
      });
      return `
        <div class='svgfilter-item' data-index="${index2}">
          <div class='preview' data-index="${index2}">
            <svg width="0" height="0">
              <filter id="svgfilter-${index2}">
                ${filters.join("")} 
              </filter>
            </svg>
            <div class='svgfilter-view' style='filter: url(#svgfilter-${index2});'></div>
          </div>
          <div class='title'>
            <div>
              <input type='text' class='id' data-key='id' value='${svgfilter.id}' placeholder="id" />
            </div>
          </div>
          <div class='tools'>
            <button type="button" class='copy'>${obj$2.copy}</button>          
            <button type="button" class='remove'>${obj$2.remove}</button>
          </div>
        </div>
      `;
    });
    results.push(`<div class='add-svgfilter-item'><button type="button">${obj$2.add}</button></div>`);
    return results;
  }
  executeSVGFilter(callback, isRefresh = true, isEmit = true) {
    var project2 = this.$context.selection.currentProject;
    if (project2) {
      callback && callback(project2);
      if (isRefresh)
        this.refresh();
      if (isEmit)
        this.emit("refreshSVGFilterAssets");
    } else {
      window.alert("Please select a project.");
    }
  }
  [CLICK("$svgfilterList .add-svgfilter-item")]() {
    this.executeSVGFilter((project2) => {
      project2.createSVGFilter({
        id: uuidShort(),
        filters: []
      });
    });
  }
  [CLICK("$svgfilterList .remove")](e) {
    var $item = e.$dt.closest("svgfilter-item");
    var index2 = +$item.attr("data-index");
    this.executeSVGFilter((project2) => {
      project2.removeSVGFilter(index2);
    });
  }
  [CLICK("$svgfilterList .copy")](e) {
    var $item = e.$dt.closest("svgfilter-item");
    var index2 = +$item.attr("data-index");
    this.executeSVGFilter((project2) => {
      project2.copySVGFilter(index2);
    });
  }
  [INPUT("$svgfilterList input")](e) {
    var $item = e.$dt.closest("svgfilter-item");
    var index2 = +$item.attr("data-index");
    var obj2 = e.$dt.attrKeyValue("data-key");
    this.executeSVGFilter((project2) => {
      project2.setSVGFilterValue(index2, obj2);
      this.emit("refreshSVGArea");
    }, false);
  }
  [CLICK("$svgfilterList .preview")](e) {
    var $item = e.$dt.closest("svgfilter-item");
    var index2 = +$item.attr("data-index");
    this.state.$item = $item;
    this.state.$el = e.$dt.$(".svgfilter-view");
    var currentProject = this.$context.selection.currentProject || {
      svgfilters: []
    };
    var svgfilter = currentProject.svgfilters[index2];
    this.emit("showSVGFilterPopup", {
      changeEvent: "changeSVGFilterAssets",
      id: this.id,
      index: index2,
      filters: svgfilter.filters
    });
  }
  [SUBSCRIBE("updateSVGFilterAssets")](params) {
    this.executeSVGFilter((project2) => {
      project2.setSVGFilterValue(params.index, {
        filters: params.filters
      });
      this.state.$item.$("filter").html(params.filters.join("\n"));
      this.emit("refreshSVGArea");
    }, false);
  }
  [SUBSCRIBE("changeSVGFilterAssets")](params) {
    if (params.id === this.id) {
      this.trigger("updateSVGFilterAssets", params);
    }
  }
  [SUBSCRIBE("refreshSVGFilterAssets")]() {
    this.refresh();
  }
}
function svgFilterAsset(editor) {
  editor.registerElement({
    SVGFilterAssetsProperty
  });
}
var alpha = `
1   0   0   0   0
0   1   0   0   0
0   0   1   0   0
0   0   0   .5  0 
`;
var blue = `
0   0   0   0   0
0   0   0   0   0
0   0   1   0   0
0   0   0   1   0 
`;
var BlueMagenta2 = `
1   0   0   0   0
0   0   0   0   0
0   0   1  .5   0
0   0   0   1   0 
`;
var BlueShadowMagentHightlight = `
1   0   0   0   0
0   0   0   0   0
0   0   1   1   0
0   0   0   1   0 
`;
var cyan = `
0   0   0   0   0
0   1   0   0   0
0   0   1   0   0
0   0   0   1   0 
`;
var darken = `
.5   0   0   0   0
0  .5   0   0   0
0   0  .5   0   0
0   0   0   1   0 
`;
var ElimBlue = `
1   0   0   0   0
0   1   0   0   0
0   0   1   0   0
0   0   -2   1   0 
`;
var GrayOnDark = `
0   0   1   0   0
0   0   1   0   0
0   0   1   0   0
0   0   0   1   0  
`;
var GrayOnLight = `
1   0   0   0   0
1   0   0   0   0
1   0   0   0   0
0   0   0   1   0 
`;
var GrayOnMid = `
0   1   0   0   0
0   1   0   0   0
0   1   0   0   0
0   0   0   1   0 
`;
var green = `
0   0   0   0   0
0   1   0   0   0
0   0   0   0   0
0   0   0   1   0 
`;
var HardGreen = `
1   0   0   0   0
0   1   0   1   0
0   0   1   0   0
0   0   0   1   0 
`;
var HardYellow = `
1   0   0   1   0
0   1   0   1   0
0   0   1   0   0
0   0   0   1   0 
`;
var IdenticalRedOverlay = `
1   0   0   0   0
0   0   0   0   0
0   0   0   0   0
0   0   0   1   0 
`;
var lighten = `
1.5   0   0   0   0
0   1.5   0   0   0
0   0   1.5   0   0
0   0   0   1   0 
`;
var lime = `
1   0   0   0   0
0   2   0   0   0
0   0   0  .5   0
0   0   0   1   0 
`;
var magenta = `
1   0   0   0   0
0   0   0   0   0
0   0   1   0   0
0   0   0   1   0 
`;
var NoGreenMagenta = `
1   1   0   0   0
0   0   0   0   0
0   1   1   0   0
0   0   0   1   0 
`;
var NoGreenRed = `
1   1   0   0   0
0   0   0   0   0
0   0   1   0   0
0   0   0   1   0 
`;
var peachy = `
1   0   0   0   0
0  .5   0   0   0
0   0   0  .5   0
0   0   0   1   0 
`;
var red = `
1   0   0   0   0
0   0   0   0   0
0   0   0   0   0
0   0   0   1   0
`;
var RedOverlay = `
1   0   0   0   0
0   0   0   0   0
0   0   1  -1   0
0   0   0   1   0 
`;
var yellow = `
1   0   0   0   0
0   1   0   0   0
0   0   0   0   0
0   0   0   1   0 
`;
var YesGreenColorizedMagenta = `
1   1   0   0   0
0   1   0   0   0
0   1   1   0   0
0   0   0   1   0 
`;
var colormatrix = {
  red,
  green,
  blue,
  yellow,
  magenta,
  cyan,
  alpha,
  BlueMagenta2,
  BlueShadowMagentHightlight,
  darken,
  ElimBlue,
  GrayOnDark,
  GrayOnLight,
  GrayOnMid,
  HardGreen,
  HardYellow,
  IdenticalRedOverlay,
  lighten,
  lime,
  NoGreenMagenta,
  NoGreenRed,
  peachy,
  RedOverlay,
  YesGreenColorizedMagenta
};
var ColorMatrixEditor$1 = "";
const COLUMN = 6;
const sampleList = Object.keys(colormatrix).map((it) => {
  return { title: it, values: colormatrix[it] };
});
class ColorMatrixEditor extends EditorElement {
  initState() {
    return {
      values: normalize(this.props.values)
    };
  }
  template() {
    return `
            <div class='elf--color-matrix-editor' >
                <div ref='$body'></div>
                <div class='title'> Mix Color Template </div>
                <div class='color-matrix-template' ref='$sample'></div>
            </div>
        `;
  }
  [BIND("$body")]() {
    return {
      cssText: `
                display: grid;
                grid-template-columns: repeat(${COLUMN}, 1fr);
                grid-column-gap: 2px;
                grid-row-gap: 2px;
                text-align: left; 
            `
    };
  }
  [LOAD("$sample")]() {
    return sampleList.map((it, index2) => {
      return `<div class='sample-item' title='${it.title}' data-index="${index2}">${it.title}</div>`;
    });
  }
  [CLICK("$sample .sample-item")](e) {
    var index2 = +e.$dt.attr("data-index");
    var sample2 = sampleList[index2];
    this.updateData({
      values: normalize(sample2.values)
    });
    this.load("$body");
  }
  [LOAD("$body")]() {
    var { values } = this.state;
    var text2 = ["R", "G", "B", "A"];
    var a = values.map((value, index2) => {
      var h = "";
      if (index2 % (COLUMN - 1) === 0) {
        h = `<div>${text2[Math.floor(index2 / (COLUMN - 1))]}</div>`;
      }
      var result = `
                ${h}
                <div class='number-editor'>
                    <input type="number" value="${value}" step="0.01" data-index="${index2}" />
                </div>
            `;
      return result;
    });
    var header = `
            <div></div>
            <div>R</div>
            <div>G</div>
            <div>B</div>
            <div>A</div>
            <div>M</div>
        `;
    return header + a;
  }
  updateData(data) {
    this.setState(data, false);
    this.parent.trigger(this.props.onchange, this.props.key, this.state.values, this.props.params);
  }
  [INPUT("$body input")](e) {
    var $el = e.$dt;
    var index2 = +$el.attr("data-index");
    var value = +$el.value;
    this.state.values[index2] = value;
    this.updateData();
  }
}
var FuncFilterEditor$1 = "";
class FuncFilterEditor extends EditorElement {
  initState() {
    return __spreadValues({
      label: this.props.label || ""
    }, this.parse(this.props.value));
  }
  parse(value) {
    var [type, ...values] = value.split(" ");
    if (type === "linear") {
      var [slop, intercept] = values;
    } else if (type === "gamma") {
      var [amplitude, exponent, offset] = values;
    }
    return {
      type,
      values,
      slop,
      intercept,
      amplitude,
      exponent,
      offset
    };
  }
  template() {
    return `<div class='small-editor func-filter' ref='$body'></div>`;
  }
  [LOAD("$body")]() {
    var { type, label } = this.state;
    var hasLabel = label ? "has-label" : "";
    return `
            ${createComponent("SelectEditor", {
      label,
      ref: "$type",
      key: "type",
      value: this.state.type,
      options: ["identity", "table", "discrete", "linear", "gamma"],
      onchange: "changeType"
    })}
        <div class='elf--func-filter-editor ${hasLabel}' ref='$container' data-selected-type='${type}'>
            ${label ? `<label></label>` : ""}
            <div data-type='identity'>
            </div>
            <div data-type='table'>
                ${createComponent("TextEditor", {
      label: "tableValues",
      ref: "$values",
      key: "values",
      value: this.state.values.join(" "),
      onchange: (key, value) => {
        this.updateData({
          [key]: value.split(" ")
        });
      }
    })}
            </div>
            <div data-type='linear'>
                ${["slop", "intercept"].map((it) => {
      return `
                        <div>
                            ${createComponent("NumberRangeEditor", {
        label: it,
        ref: `$${it}`,
        key: it,
        value: this.state[it],
        onchange: (key, value) => {
          this.updateData({
            [key]: value
          });
        }
      })}
                        </div>                    
                    `;
    }).join("")}
            </div>
            <div data-type='gamma'>
                ${["amplitude", "exponent", "offset"].map((it) => {
      return `
                        <div>
                            ${createComponent("NumberRangeEditor", {
        label: it,
        ref: `$${it}`,
        key: it,
        value: this.state[it],
        onchange: (key, value) => {
          this.updateData({
            [key]: value
          });
        }
      })}
                        </div>                    
                    `;
    }).join("")}            
            </div>                                                
        </div>
    `;
  }
  [SUBSCRIBE("changeType")](key, type) {
    this.updateData({ type });
    this.refresh();
  }
  getValue() {
    switch (this.state.type) {
      case "table":
      case "discrete":
        return [this.state.type, ...this.state.values].join(" ");
      case "linear":
        return [this.state.type, this.state.slop, this.state.intercept].join(" ");
      case "gamma":
        return [
          this.state.type,
          this.state.amplitude,
          this.state.exponent,
          this.state.offset
        ].join(" ");
    }
    return "identity";
  }
  setValue(value) {
    this.setState(__spreadValues({}, this.parse(value)));
  }
  updateData(data) {
    this.setState(data, false);
    this.parent.trigger(this.props.onchange, this.props.key, this.getValue(), this.props.params);
  }
}
var dancingStroke = [
  {
    type: "SourceAlpha",
    id: "strokeSource",
    bound: { x: 100, y: 100 },
    connected: [
      {
        id: "morphology"
      }
    ]
  },
  {
    type: "Morphology",
    id: "morphology",
    operator: "dilate",
    radius: "3 3",
    bound: { x: 100, y: 200 },
    in: [{ id: "strokeSource" }],
    connected: [{ id: "composite" }]
  },
  {
    type: "Flood",
    id: "flood",
    bound: { x: 100, y: 200 },
    color: "#30597E",
    opacity: 1,
    connected: [{ id: "composite" }]
  },
  {
    type: "Composite",
    id: "composite",
    bound: { x: 400, y: 150 },
    in: [{ id: "flood" }, { id: "morphology" }],
    operator: "in",
    connected: [
      {
        id: "composite2"
      }
    ]
  },
  {
    type: "SourceAlpha",
    id: "strokeSourceAlpha2",
    bound: { x: 400, y: 200 },
    connected: [
      {
        id: "composite2"
      }
    ]
  },
  {
    type: "Composite",
    id: "composite2",
    bound: { x: 400, y: 150 },
    in: [{ id: "composite" }, { id: "strokeSourceAlpha2" }],
    operator: "out",
    connected: [
      {
        id: "displacementMap"
      }
    ]
  },
  {
    type: "Turbulence",
    id: "turbulence",
    filterType: "fractalNoise",
    baseFrequency: "0.01 0.02",
    numOctaves: 1,
    seed: 0,
    stitchTiles: "stitch",
    bound: { x: 400, y: 200 },
    connected: [
      {
        id: "displacementMap"
      }
    ]
  },
  {
    type: "DisplacementMap",
    id: "displacementMap",
    scale: 17,
    xChannelSelector: "A",
    yChannelSelector: "A",
    bound: { x: 400, y: 200 },
    in: [{ id: "composite2" }, { id: "turbulence" }],
    connected: [
      {
        id: "merge"
      }
    ]
  },
  {
    type: "SourceGraphic",
    id: "strokeSourceGraphic",
    bound: { x: 400, y: 200 },
    connected: [
      {
        id: "merge"
      }
    ]
  },
  {
    type: "Merge",
    id: "merge",
    bound: { x: 500, y: 150 },
    in: [{ id: "strokeSourceGraphic" }, { id: "displacementMap" }]
  }
];
var grayscale = [
  {
    type: "Saturate",
    values: "0"
  }
];
var innerShadow = [
  {
    type: "Flood",
    id: "flood",
    bound: { x: 100, y: 200 },
    color: "black",
    opacity: 1,
    connected: [{ id: "composite1" }]
  },
  {
    type: "SourceAlpha",
    id: "shadowSource",
    bound: { x: 100, y: 100 },
    connected: [
      {
        id: "composite1"
      }
    ]
  },
  {
    type: "Composite",
    id: "composite1",
    bound: { x: 200, y: 150 },
    in: [{ id: "flood" }, { id: "shadowSource" }],
    operator: "out",
    connected: [
      {
        id: "offset"
      }
    ]
  },
  {
    type: "Offset",
    id: "offset",
    bound: { x: 300, y: 150 },
    dx: 4,
    dy: 4,
    in: [{ id: "composite1" }],
    connected: [{ id: "blur" }]
  },
  {
    type: "GaussianBlur",
    id: "blur",
    bound: { x: 400, y: 150 },
    stdDeviationX: 4,
    stdDeviationY: 4,
    edge: "none",
    in: [{ id: "offset" }],
    connected: [
      {
        id: "composite2"
      }
    ]
  },
  {
    type: "SourceAlpha",
    id: "shadowSource2",
    bound: { x: 400, y: 250 },
    connected: [
      {
        id: "composite2"
      }
    ]
  },
  {
    type: "Composite",
    id: "composite2",
    bound: { x: 500, y: 150 },
    in: [{ id: "blur" }, { id: "shadowSource2" }],
    operator: "out",
    connected: [
      {
        id: "merge"
      }
    ]
  },
  {
    type: "SourceGraphic",
    id: "shadowSource3",
    bound: { x: 500, y: 250 },
    connected: [
      {
        id: "merge"
      }
    ]
  },
  {
    type: "Merge",
    id: "merge",
    bound: { x: 600, y: 150 },
    in: [{ id: "composite2" }, { id: "shadowSource3" }]
  }
];
var shadow = [
  {
    type: "SourceAlpha",
    id: "shadowSource",
    bound: { x: 100, y: 100 },
    connected: [
      {
        id: "offset"
      }
    ]
  },
  {
    type: "Offset",
    id: "offset",
    bound: { x: 200, y: 100 },
    dx: 10,
    dy: 10,
    in: [{ id: "shadowSource" }],
    connected: [{ id: "blur" }]
  },
  {
    type: "GaussianBlur",
    id: "blur",
    bound: { x: 300, y: 100 },
    stdDeviationX: 5,
    stdDeviationY: 5,
    in: [{ id: "offset" }],
    connected: [
      {
        id: "composite"
      }
    ]
  },
  {
    type: "Flood",
    id: "flood",
    bound: { x: 100, y: 200 },
    color: "black",
    opacity: 0.7,
    connected: [{ id: "composite" }]
  },
  {
    type: "Composite",
    id: "composite",
    bound: { x: 400, y: 150 },
    in: [{ id: "flood" }, { id: "blur" }],
    operator: "in",
    connected: [
      {
        id: "merge"
      }
    ]
  },
  {
    type: "SourceAlpha",
    id: "shadowSource2",
    bound: { x: 400, y: 200 },
    connected: [
      {
        id: "merge"
      }
    ]
  },
  {
    type: "Merge",
    id: "merge",
    bound: { x: 500, y: 150 },
    in: [{ id: "composite" }, { id: "shadowSource2" }]
  }
];
var stroke = [
  {
    type: "SourceAlpha",
    id: "strokeSource",
    bound: { x: 100, y: 100 },
    connected: [
      {
        id: "morphology"
      }
    ]
  },
  {
    type: "Morphology",
    id: "morphology",
    operator: "dilate",
    radius: "3 3",
    bound: { x: 100, y: 200 },
    in: [{ id: "strokeSource" }],
    connected: [{ id: "composite" }]
  },
  {
    type: "Flood",
    id: "flood",
    bound: { x: 100, y: 200 },
    color: "#30597E",
    opacity: 1,
    connected: [{ id: "composite" }]
  },
  {
    type: "Composite",
    id: "composite",
    bound: { x: 400, y: 150 },
    in: [{ id: "flood" }, { id: "morphology" }],
    operator: "in",
    connected: [
      {
        id: "merge"
      }
    ]
  },
  {
    type: "SourceGraphic",
    id: "strokeSourceGraphic",
    bound: { x: 400, y: 200 },
    connected: [
      {
        id: "merge"
      }
    ]
  },
  {
    type: "Merge",
    id: "merge",
    bound: { x: 500, y: 150 },
    in: [{ id: "composite" }, { id: "strokeSourceGraphic" }]
  }
];
var svgFilterPreset = {
  dancingStroke,
  stroke,
  grayscale,
  shadow,
  innerShadow
};
var SVGFilterEditor$1 = "";
const filterTypes = [
  {
    label: "GRAPHIC REFERENCES",
    items: [
      { label: "Source Graphic", value: "SourceGraphic" },
      { label: "Source Alpha", value: "SourceAlpha" },
      { label: "Background Image", value: "BackgroundImage" },
      { label: "Background Alpha", value: "BackgroundAlpha" },
      { label: "Fill Paint", value: "FillPaint" },
      { label: "Stroke Paint", value: "StrokePaint" }
    ]
  },
  {
    label: "SOURCES",
    items: [
      { label: "Flood", value: "Flood" },
      { label: "Turbulence", value: "Turbulence" },
      { label: "Image", value: "Image" }
    ]
  },
  {
    label: "MODIFIER",
    items: [
      { label: "Color Matrix", value: "ColorMatrix" },
      { label: "Saturate", value: "Saturate" },
      { label: "HueRotate", value: "HueRotate" },
      { label: "LuminanceToAlpha", value: "LuminanceAlpha" },
      { label: "Drop Shadow", value: "DropShadow" },
      { label: "Morphology", value: "Morphology" },
      { label: "Convolve Matrix", value: "ConvolveMatrix" },
      { label: "Offset", value: "Offset" },
      { label: "Gaussian Blur", value: "GaussianBlur" },
      { label: "Tile", value: "Tile" }
    ]
  },
  {
    label: "LIGHTING",
    items: [
      { label: "Specular Lighting", value: "SpecularLighting" },
      { label: "Diffuse Lighting", value: "DiffuseLighting" },
      { label: "Point Light", value: "PointLight" },
      { label: "Spot Light", value: "SpotLight" },
      { label: "Distant Light", value: "DistantLight" }
    ]
  },
  {
    label: "COMBINERS",
    items: [
      { label: "Blend", value: "Blend" },
      { label: "Composite", value: "Composite" },
      { label: "Merge", value: "Merge" },
      { label: "DisplacementMap", value: "DisplacementMap" }
    ]
  }
];
const SVGFilterTemplateList = [
  {
    label: "Template",
    items: [
      { label: "Grayscale", value: "grayscale" },
      { label: "Shadow", value: "shadow" },
      { label: "Inner Shadow", value: "innerShadow" },
      { label: "Stroke", value: "stroke" },
      { label: "Dancing Stroke", value: "dancingStroke" }
    ]
  }
];
function getIcon(type) {
  switch (type) {
    case "SpecularLighting":
      return iconUse("specular");
    case "DiffuseLighting":
      return iconUse("diffuse");
    case "SourceGraphic":
    case "SourceAlpha":
      return iconUse("image");
    case "BackgroundImage":
    case "BackgroundAlpha":
      return iconUse("outline_image");
    case "Flood":
      return iconUse("palette");
    case "Image":
      return iconUse("landscape");
    case "GaussianBlur":
      return iconUse("blur");
    case "ColorMatrix":
      return iconUse("blur_linear");
    case "Turbulence":
      return iconUse("waves");
    case "Saturate":
      return iconUse("vintage");
    case "HueRotate":
      return iconUse("looks");
    case "LuminanceAlpha":
      return iconUse("opacity");
    case "DropShadow":
      return iconUse("shadow");
    case "Morphology":
      return iconUse("broken_image");
    case "ConvolveMatrix":
      return iconUse("camera_roll");
    case "Offset":
      return iconUse("transform");
    case "Tile":
      return iconUse("view_comfy");
    case "Blend":
      return iconUse("gradient");
    case "Composite":
      return iconUse("merge");
    case "Merge":
      return iconUse("settings_input_component");
    case "DisplacementMap":
      return iconUse("texture");
  }
  return "";
}
function getSourceTypeString(type) {
  switch (type) {
    case "SourceGraphic":
    case "SourceAlpha":
    case "BackgroundImage":
    case "BackgroundAlpha":
    case "FillPaint":
    case "StrokePaint":
      return "graphic";
    case "Flood":
    case "Turbulence":
    case "Image":
      return "source";
    case "GaussianBlur":
    case "ColorMatrix":
    case "Saturate":
    case "HueRotate":
    case "LuminanceAlpha":
    case "DropShadow":
    case "Morphology":
    case "ConvolveMatrix":
    case "Offset":
    case "Tile":
      return "modifier";
    case "SpecularLighting":
    case "DiffuseLighting":
    case "SpotLight":
    case "PointLight":
    case "DistantLight":
      return "lighting";
    case "Blend":
    case "Composite":
    case "Merge":
    case "DisplacementMap":
      return "combiner";
  }
  return "";
}
const width = 40;
const half_height = 20;
const connectedXAxis = {
  1: [width + 5]
};
const connectedYAxis = {
  1: [half_height]
};
const inXAxis = {
  1: [-7],
  2: [-7],
  3: [-7],
  4: [-7],
  5: [-7]
};
let inYAxis = {
  1: [0],
  2: [-7, 7],
  3: [-14, 0, 14],
  4: [-21, -7, 7, 21],
  5: [-28, -14, 0, 14, 28]
};
Object.keys(inYAxis).forEach((len2) => {
  inYAxis[len2] = inYAxis[len2].map((it) => it + half_height);
});
class SVGFilterEditor extends EditorElement {
  makeFilterSelect() {
    return `
  
    <div class='filter-item-list' ref="$filterSelect">
  
      ${mapjoin(filterTypes, (f) => {
      return `
          <div class='group' label="${this.$i18n(f.label)}">
            ${mapjoin(f.items, (i) => {
        return `
                <div class='item' draggable="true" value="${i.value}">
                  <span class='icon'>${getIcon(i.value)}</span>
                  ${this.$i18n(i.label)}
                </div>
                `;
      })}
          </div>
        `;
    })}
    </div>
    `;
  }
  makeFilterTemplateSelect() {
    return `
  
    <div class='filter-item-list' ref="$filterTemplateSelect">
  
      ${mapjoin(SVGFilterTemplateList, (f) => {
      return `
          <div class='group' label="${this.$i18n(f.label)}">
            ${mapjoin(f.items, (i) => {
        return ` <div class='item' draggable="true" value="${i.value}">${this.$i18n(i.label)}</div>`;
      })}
          </div>
        `;
    })}
    </div>
    `;
  }
  initState() {
    var filters = this.parseFilter(this.props.value || []);
    return {
      filters,
      selectedTabIndex: 1,
      selectedIndex: -1,
      selectedFilter: null
    };
  }
  template() {
    return `
      <div class='elf--svg-filter-editor filter-list'>
        <div class='left'>
          <div class="tab number-tab" ref="$tab">
            <div class="tab-header full" ref="$header">
              <div class="tab-item selected" data-value="1" title='Item'>
                <label class='icon'>${this.$i18n("svg.filter.editor.tab.filter")}</label>
              </div>
              <div class="tab-item" data-value="2" title="Preset">
                <label class='icon'>${this.$i18n("svg.filter.editor.tab.preset")}</label>
              </div>
              <div class="tab-item" data-value="3" title="Asset">
                <label class='icon'>${this.$i18n("svg.filter.editor.tab.asset")}</label>
              </div>
            </div>
            <div class="tab-body">
              <div class="tab-content scrollbar selected" data-value="1">
                ${this.makeFilterSelect()}
              </div>
              <div class="tab-content  scrollbar" data-value="2">
                ${this.makeFilterTemplateSelect()}
              </div>
                     
            </div>
          </div>
        </div>
        <div  class='center'>
          <div class='graph'>
            <div class='drag-line-panel' ref='$dragLinePanel'></div>          
            <div class='connected-line-panel' ref='$connectedLinePanel'></div>
            <div class='graph-panel' ref='$graphPanel' droppable="true"></div>
          </div>
        </div>
        <div class='right'>
          <div class='filter-list' ref='$filterList'></div>
        </div>
      </div>`;
  }
  [CLICK("$header .tab-item:not(.empty-item)")](e) {
    var selectedTabIndex = +e.$dt.attr("data-value");
    if (this.state.selectedTabIndex === selectedTabIndex) {
      return;
    }
    this.$el.$$(`[data-value="${this.state.selectedTabIndex}"]`).forEach((it) => it.removeClass("selected"));
    this.$el.$$(`[data-value="${selectedTabIndex}"]`).forEach((it) => it.addClass("selected"));
    this.setState({ selectedTabIndex }, false);
  }
  [DRAGSTART("$filterSelect .item")](e) {
    var filter2 = e.$dt.attr("value");
    e.dataTransfer.setData("filter/type", filter2);
  }
  [DRAGOVER("$connectedLinePanel") + PREVENT]() {
  }
  [DROP("$connectedLinePanel") + PREVENT](e) {
    var offset = { x: e.offsetX, y: e.offsetY };
    var filterType = e.dataTransfer.getData("filter/type");
    this.makeFilterNode(filterType, { bound: offset });
  }
  makeFilterNode(filterType, opt = {}) {
    this.state.filters.push(this.makeFilter(filterType, opt));
    this.state.selectedIndex = this.state.filters.length - 1;
    this.state.selectedFilter = this.state.filters[this.state.selectedIndex];
    this.refresh();
    this.modifyFilter();
  }
  applyTemplate(templateType) {
    var template = svgFilterPreset[templateType];
    if (template) {
      this.setState({
        selectedIndex: -1,
        selectedFilter: null,
        filters: this.parseFilter(template)
      }, false);
      this.refresh();
      this.modifyFilter();
    }
  }
  getSpec(filterType) {
    return SVGFilterSpecList[filterType];
  }
  makeFilterEditorTemplate(s, filter2, key) {
    var objectId = `${filter2.type}${key}${this.state.selectedIndex}${Date.now()}`;
    if (s.inputType === "color-matrix") {
      return createComponent("ColorMatrixEditor", {
        ref: `$colorMatrix${objectId}`,
        label: s.title,
        key,
        column: s.column,
        values: filter2[key].join(" "),
        onchange: "changeRangeEditor"
      });
    } else if (s.inputType === "input-array") {
      return createComponent("InputArrayEditor", {
        ref: `$inputArray${objectId}`,
        label: s.title,
        key,
        "column-label": "R,G,B,A,M",
        "row-label": "R,G,B,A",
        column: s.column,
        values: filter2[key].join(" "),
        onchange: "changeRangeEditor"
      });
    } else if (s.inputType === "blend") {
      return createComponent("BlendSelectEditor", {
        ref: `$blend${objectId}`,
        label: s.title,
        key,
        value: filter2[key].toString(),
        onchange: "changeRangeEditor"
      });
    } else if (s.inputType === "select") {
      var options2 = s.options;
      if (isFunction(s.options)) {
        options2 = s.options(this.state.filters);
      }
      return createComponent("SelectEditor", {
        ref: `$select${objectId}`,
        label: s.title,
        options: options2,
        key,
        value: filter2[key].toString(),
        onchange: "changeRangeEditor"
      });
    } else if (s.inputType === "text") {
      return createComponent("TextEditor", {
        ref: `$text${objectId}`,
        label: s.title,
        key,
        value: filter2[key].toString(),
        onchange: "changeTextEditor"
      });
    } else if (s.inputType === "number-range") {
      return createComponent("NumberRangeEditor", {
        ref: `$numberrange${objectId}`,
        label: s.title,
        layout: "block",
        min: s.min,
        max: s.max,
        step: s.step,
        key,
        value: filter2[key].toString(),
        onchange: "changeRangeEditor"
      });
    } else if (s.inputType === "color") {
      return createComponent("ColorViewEditor", {
        ref: `$colorview${objectId}`,
        label: s.title,
        key,
        value: filter2[key].toString(),
        onchange: "changeRangeEditor"
      });
    } else if (s.inputType === "FuncFilter") {
      return createComponent("FuncFilterEditor", {
        ref: `$funcFilter${objectId}`,
        label: s.title,
        key,
        value: filter2[key].toString(),
        onchange: "changeFuncFilterEditor"
      });
    } else if (s.inputType === "ImageSelectEditor") {
      return createComponent("ImageSelectEditor", {
        ref: `$imageSelect${objectId}`,
        label: s.title,
        key,
        value: filter2[key].toString(),
        onchange: "changeRangeEditor"
      });
    }
    return createComponent("RangeEditor", {
      ref: `$range${objectId}`,
      layout: "block",
      label: s.title,
      min: s.min,
      max: s.max,
      step: s.step,
      key,
      value: filter2[key].toString(),
      units: s.units,
      onchange: "changeRangeEditor"
    });
  }
  makeOneFilterTemplate(spec, filter2) {
    return `
    <div class="filter-item">
      <div class="title">
        <label>${filter2.type}</label>
        <div class="filter-menu">
          <button type="button" class="del">${iconUse("remove")}</button>
        </div>
      </div>
      <div class="filter-ui">
        ${keyMapJoin(spec, (key, value) => {
      return this.makeFilterEditorTemplate(value, filter2, key);
    })}

      </div>
    </div>
  `;
  }
  makeFilterTemplate(filter2) {
    return this.makeOneFilterTemplate(this.getSpec(filter2.type), filter2);
  }
  [LOAD("$filterList")]() {
    if (this.state.selectedFilter && this.state.selectedFilter.isSource() === false) {
      return this.makeFilterTemplate(this.state.selectedFilter);
    }
    return "";
  }
  modifyFilter() {
    this.state.filters.forEach((f) => {
      if (f.isLight() && f.connected.length) {
        f.connected.forEach((c2) => {
          this.state.filters.filter((s) => s.id === c2.id).forEach((lightManager) => {
            lightManager.reset({
              lightInfo: f.toLightString()
            });
          });
        });
      }
    });
    this.parent.trigger(this.props.onchange, this.props.key, this.state.filters);
  }
  parseFilter(list2 = []) {
    return list2.map((it) => SVGFilter.parse(it));
  }
  makeFilter(type, opt = {}) {
    return SVGFilter.parse(__spreadProps(__spreadValues({}, opt), { type }));
  }
  [CLICK("$filterSelect .item[value]")](e) {
    var filterType = e.$dt.attr("value");
    this.makeFilterNode(filterType);
  }
  [CLICK("$filterTemplateSelect .item[value]")](e) {
    var templateType = e.$dt.attr("value");
    this.applyTemplate(templateType);
  }
  [CLICK("$filterList .filter-menu .del")]() {
    this.removeFilter(this.state.selectedFilter.id);
  }
  [LOAD("$graphPanel")]() {
    return this.makeGraphPanel();
  }
  selectFilter(index2) {
    this.setState({
      selectedIndex: index2,
      selectedFilter: this.state.filters[index2]
    }, false);
    this.load("$filterList");
  }
  [POINTERSTART("$graphPanel .filter-node") + MOVE() + END()](e) {
    this.$target = e.$dt;
    this.$point = null;
    this.pointType = "object";
    this.pointIndex = 0;
    var rect2 = this.refs.$graphPanel.rect();
    this.rect = rect2;
    var index2 = +this.$target.attr("data-index");
    this.selectFilter(index2);
    this.$target.onlyOneClass("selected");
    var pointer = Dom.create(e.target);
    if (pointer.hasClass("out")) {
      this.$point = pointer;
      this.pointType = "out";
      this.pointIndex = 0;
    } else if (pointer.hasClass("in")) {
      this.$point = pointer;
      this.pointType = "in";
      this.pointIndex = +pointer.attr("data-index");
    } else {
      var filter2 = this.state.selectedFilter;
      this.startXY = clone$1(filter2.bound);
    }
    if (this.pointType === "in" || this.pointType === "out") {
      var inRect = pointer.rect();
      var x = inRect.x - rect2.x;
      var y = inRect.y - rect2.y;
      var centerX = x + inRect.width / 2;
      var centerY = y + inRect.height / 2;
      this.startXY = { x: centerX, y: centerY };
    }
    this.startXY.dx = 0;
    this.startXY.dy = 0;
    this.load("$dragLinePanel");
  }
  [LOAD("$dragLinePanel")]() {
    if (this.pointType === "in" || this.pointType === "out") {
      var { x, y, dx, dy } = this.startXY;
      return `
      <svg>
        <path 
          class="drag-line"
          fill="transparent"
          stroke-width="1"
          d="
            M${x},${y}
            L${x + dx},${y + dy} 
            Z
          "
        />
      </svg>
      `;
    } else {
      return "";
    }
  }
  makeConnectedPath(points) {
    var manager = new PathStringManager();
    var first = points[0];
    var last = points[points.length - 1];
    if (!first)
      return "";
    if (!last)
      return "";
    var dist2 = Math.abs(first.x - last.x) / 2;
    manager.M(first).C({ x: first.x + dist2, y: first.y }, { x: last.x - dist2, y: last.y }, last);
    return manager.d;
  }
  createPath(sourceItem, connectedInfo) {
    if (connectedInfo.path) {
      return connectedInfo.path;
    }
    var sourceX = sourceItem.bound.x + connectedXAxis["1"][0];
    var sourceY = sourceItem.bound.y + connectedYAxis["1"][0];
    var target = this.state.filters.map((it, index3) => {
      return { it, index: index3 };
    }).find((it) => {
      if (!it)
        return false;
      if (!it.it)
        return false;
      return it && it.it.id === connectedInfo.id;
    });
    var len2 = `${target.it.getInCount()}`;
    var source2 = target.it.in.map((it, index3) => {
      return { it, index: index3 };
    }).find((it) => {
      if (!it)
        return false;
      if (!it.it)
        return false;
      return it.it.id === sourceItem.id;
    });
    if (!source2) {
      return [];
    }
    var index2 = source2.index;
    var targetX = target.it.bound.x + inXAxis[len2][0];
    var targetY = target.it.bound.y + inYAxis[len2][index2];
    return [
      { x: sourceX, y: sourceY },
      { x: targetX, y: targetY }
    ];
  }
  [LOAD("$connectedLinePanel")]() {
    return `
      <svg>
        ${this.state.filters.map((it) => {
      return it.connected.map((connectedItem) => {
        var path = this.createPath(it, connectedItem);
        var sourceType = getSourceTypeString(it.type);
        return `
              <path 
                class="connected-line"
                data-source-type="${sourceType}"
                d="${this.makeConnectedPath(path)}"
              />

              ${path.length && `
                <circle 
                  data-source-type="${sourceType}"
                  data-target-id="${connectedItem.id}"
                  data-source-id="${it.id}"
                  class="connected-remove-circle"
                  cx="${(path[0].x + path[1].x) / 2}"
                  cy="${(path[0].y + path[1].y) / 2}"
                />
              `}
              
            `;
      }).join("");
    }).join("")}
      </svg>
    `;
  }
  [CLICK("$connectedLinePanel .connected-remove-circle")](e) {
    var [tid, sid] = e.$dt.attrs("data-target-id", "data-source-id");
    var filters = this.state.filters;
    filters.filter((it) => it.id === sid).forEach((it) => {
      it.connected = it.connected.filter((c2) => c2.id != tid);
    });
    filters.filter((it) => it.id === tid).forEach((it) => {
      it.in = it.in.map((inObject) => {
        if (inObject && inObject.id == sid) {
          return null;
        }
        return inObject;
      });
    });
    this.refresh();
    this.modifyFilter();
  }
  getCenterXY($target) {
    var inRect = $target.rect();
    var x = inRect.x - this.rect.x;
    var y = inRect.y - this.rect.y;
    var centerX = x + inRect.width / 2;
    var centerY = y + inRect.height / 2;
    return { x: centerX, y: centerY };
  }
  end(dx, dy) {
    if (this.pointType === "in" || this.pointType === "out") {
      this.startXY.dx = dx;
      this.startXY.dy = dy;
      var filter2 = this.state.selectedFilter;
      var e = this.$config.get("bodyEvent");
      var $target = Dom.create(e.target);
      var $targetNode = $target.closest("filter-node");
      if (this.pointType === "out") {
        if ($target.hasClass("in")) {
          var targetFilter = this.state.filters[+$targetNode.attr("data-index")];
          if (targetFilter) {
            if (!targetFilter.hasLight() && filter2.isLight())
              ;
            else {
              var targetIndex = +$target.attr("data-index");
              if (!targetFilter.in[targetIndex]) {
                targetFilter.setIn(targetIndex, filter2);
                filter2.setConnected(targetFilter);
              }
            }
          }
        }
      } else if (this.pointType === "in") {
        if ($target.hasClass("out")) {
          var targetFilter = this.state.filters[+$targetNode.attr("data-index")];
          if (targetFilter) {
            if (filter2.hasLight() && !targetFilter.isLight())
              ;
            else {
              if (!filter2.in[this.pointIndex]) {
                filter2.setIn(this.pointIndex, targetFilter);
                targetFilter.setConnected(filter2);
              }
            }
          }
        }
      }
      this.pointType = "";
    }
    this.load("$dragLinePanel");
    this.load("$connectedLinePanel");
    this.modifyFilter();
  }
  move(dx, dy) {
    var filter2 = this.state.selectedFilter;
    if (filter2) {
      this.startXY.dx = dx;
      this.startXY.dy = dy;
      if (this.pointType === "in") {
        this.load("$dragLinePanel");
      } else if (this.pointType === "out") {
        this.load("$dragLinePanel");
      } else {
        filter2.reset({
          bound: { x: this.startXY.x + dx, y: this.startXY.y + dy }
        });
        this.$target.css({
          left: filter2.bound.x,
          top: filter2.bound.y
        });
        this.load("$connectedLinePanel");
      }
    }
  }
  makeGraphPanel() {
    return this.state.filters.map((it, index2) => {
      const selectedClass = index2 === this.state.selectedIndex ? "selected" : "";
      return `
        <div class='filter-node ${selectedClass}' data-type="${it.type}" data-index="${index2}" data-filter-id="${it.id}" style='left: ${it.bound.x}px;top: ${it.bound.y}px;'>
          <div class='label'>${this.$i18n(it.type)}</div>
          <div class='remove'>${iconUse("close")}</div>
          <div class='preview' data-source-type="${getSourceTypeString(it.type)}" data-filter-type='${it.type}'>${getIcon(it.type)}</div>
          <div class='in-list'>
            ${repeat(it.getInCount()).map((itIn, inIndex) => {
        return `<div class='in' data-index='${inIndex}'></div>`;
      }).join("")}
          </div>
          
          <div class='out' data-index="0">${iconUse("chevron_right")}</div>
          ${it.hasLight() ? `<div class='light'  data-index="0"></div>` : ""}
        </div>
      `;
    });
  }
  [SUBSCRIBE_SELF("changeFuncFilterEditor")](key, value) {
    var filter2 = this.state.selectedFilter;
    if (filter2) {
      filter2.reset({
        [key]: value
      });
    }
    this.modifyFilter();
  }
  [SUBSCRIBE_SELF("changeRangeEditor")](key, value) {
    var filter2 = this.state.selectedFilter;
    if (filter2) {
      filter2.reset({
        [key]: value
      });
    }
    this.modifyFilter();
  }
  [SUBSCRIBE_SELF("changeTextEditor")](key, value) {
    var filter2 = this.state.selectedFilter;
    if (filter2) {
      filter2.reset({
        [key]: value
      });
    }
    this.modifyFilter();
  }
  removeFilter(id) {
    var filters = this.state.filters.filter((it) => it.id != id);
    filters.forEach((it) => {
      it.connected = it.connected.filter((c2) => c2.id != id);
      it.in = it.in.filter((c2) => c2.id != id);
    });
    if (this.state.selectedFilter.id === id) {
      this.state.selectedFilter = null;
      this.state.selectedIndex = -1;
    }
    this.setState({
      filters
    });
    this.modifyFilter();
  }
  [CLICK("$graphPanel .filter-node .remove")](e) {
    var $target = e.$dt.closest("filter-node");
    var index2 = +$target.attr("data-index");
    var f = this.state.filters[index2];
    this.removeFilter(f.id);
  }
}
var SVGFilterPopup$1 = "";
class SVGFilterPopup extends BasePopup {
  getTitle() {
    return this.$i18n("svgfilter.popup.title");
  }
  getClassName() {
    return "transparent";
  }
  initState() {
    return {
      changeEvent: "changeSVGFilterPopup",
      id: "",
      preview: true,
      filters: []
    };
  }
  updateData(opt) {
    this.setState(opt, false);
    this.emit(this.state.changeEvent, this.state);
  }
  getBody() {
    return `
    <div class='elf--svg-filter-popup' ref='$popup'>
      <div class="box">
        <div class='editor' ref='$editor'></div>
      </div>
    </div>`;
  }
  [LOAD("$editor")]() {
    return createComponent("SVGFilterEditor", {
      ref: "$filter",
      title: "Filter Type",
      key: "filter",
      value: this.state.filters,
      onchange: (key, filters) => {
        this.updateData({
          filters
        });
      }
    });
  }
  [SUBSCRIBE("showSVGFilterPopup")](data) {
    data.filters = data.filters.map((it) => {
      return SVGFilter.parse(it);
    });
    data.preview = isNotUndefined(data.preview) ? data.preview : true;
    this.setState(data);
    this.show(1e3);
  }
  [SUBSCRIBE("hideSVGFilterPopup")]() {
    this.$el.hide();
  }
}
var SVGFilterSelectEditor$1 = "";
class SVGFilterSelectEditor extends EditorElement {
  initState() {
    var value = this.props.value;
    return {
      options: [],
      label: this.props.label || "",
      value
    };
  }
  template() {
    var { label } = this.state;
    var hasLabel = label ? "has-label" : "";
    return `
            <div class='elf--svg-filter-select-editor ${hasLabel}'>
                ${label ? `<label>${label}</label>` : ""}
                <select ref='$options'></select>
                <button type='button' class='open thin' ref='$open' title='Open SVG Filter Editor'>${obj$2.fullscreen}</button>
                <button type='button' class='remove thin' ref='$remove' title='Remove'>${obj$2.remove}</button>
            </div>
        `;
  }
  [CLICK("$remove")]() {
    this.updateData({
      value: ""
    });
  }
  [CLICK("$open")]() {
    var value = this.state.value;
    if (value.includes("id")) {
      var currentProject = this.$context.selection.currentProject;
      var index2 = currentProject.getSVGFilterIndex(value);
      if (index2 > -1) {
        this.trigger("openSVGFilterPopup", index2);
      }
    }
  }
  getValue() {
    return this.state.value;
  }
  setValue(value) {
    this.setState({ value });
  }
  [BIND("$options")]() {
    return {
      "data-count": this.state.options.length.toString()
    };
  }
  [LOAD("$options")]() {
    var current = this.$context.selection.currentProject;
    var options2 = "";
    if (current) {
      options2 = current.svgfilters.map((it) => it.id);
      options2 = options2.length ? "," + options2.join(",") : "";
    }
    options2 += ",-,new";
    options2 = options2.split(",");
    var arr = options2.map((it) => {
      var value = it;
      var label = it;
      if (value.includes(":")) {
        var [value, label] = value.split(":");
      }
      if (label === "") {
        label = this.props["none-value"] ? this.props["none-value"] : "";
      } else if (label === "-") {
        label = "----------";
        value = "";
      }
      var selected = value === this.state.value ? "selected" : "";
      return `<option ${selected} value="${value}">${label}</option>`;
    });
    return arr;
  }
  setOptions(options2 = "") {
    this.setState({
      options: options2.split(this.state.splitChar).map((it) => it.trim())
    });
  }
  [CHANGE("$options")]() {
    var value = this.refs.$options.value;
    if (value == "new") {
      this.$commands.emit("addSVGFilterAssetItem", (index2, id) => {
        this.updateData({ value: id });
        this.refresh();
        this.trigger("openSVGFilterPopup", index2);
      });
    } else if (value === "-")
      ;
    else {
      this.updateData({ value });
    }
  }
  updateData(data) {
    this.setState(data, false);
    this.parent.trigger(this.props.onchange, this.props.key, this.state.value, this.props.params);
  }
  [SUBSCRIBE("refreshSVGArea") + DEBOUNCE(1e3)]() {
    this.load("$options");
  }
  [SUBSCRIBE("openSVGFilterPopup")](index2) {
    this.emit("refreshSVGFilterAssets");
    this.emit("refreshSVGArea");
    var currentProject = this.$context.selection.currentProject || {
      svgfilters: []
    };
    var svgfilter = currentProject.svgfilters[index2];
    this.emit("showSVGFilterPopup", {
      changeEvent: "changeSVGFilterEditorRealUpdate",
      preview: false,
      index: index2,
      filters: svgfilter.filters
    });
  }
  [SUBSCRIBE("changeSVGFilterEditorRealUpdate")](params) {
    var project2 = this.$context.selection.currentProject;
    if (project2) {
      project2.setSVGFilterValue(params.index, {
        filters: params.filters
      });
      this.emit("refreshSVGFilterAssets");
      this.emit("refreshSVGArea");
    }
  }
}
function svgItem(editor) {
  editor.registerElement({
    ColorMatrixEditor,
    FuncFilterEditor,
    SVGFilterSelectEditor,
    SVGFilterEditor
  });
  editor.registerUI("inspector.tab.style", {
    SVGItemProperty: ObjectProperty.create({
      title: editor.$i18n("svg.item.property.title"),
      editableProperty: "svg-item",
      preventUpdate: true
    })
  });
  editor.registerUI("popup", {
    SVGFilterPopup
  });
  editor.registerInspector("svg-item", (current) => {
    return [
      {
        key: "edit",
        editor: "Button",
        editorOptions: {
          text: "Edit",
          action: ["open.editor", current]
        }
      },
      {
        type: "column",
        size: [2, 1],
        columns: [
          { type: "label", label: editor.$i18n("svg.item.property.fill") },
          {
            key: "fillRule",
            editor: "ToggleCheckBox",
            editorOptions: {
              toggleLabels: [iconUse("join_full"), iconUse("join_right")],
              toggleValues: ["nonzero", "evenodd"]
            },
            defaultValue: current.fillRule || "nonzero"
          }
        ]
      },
      {
        type: "column",
        size: [2, 1],
        columns: [
          {
            key: "fill",
            editor: "FillSingleEditor",
            editorOptions: {
              wide: true
            },
            defaultValue: current.fill
          },
          {
            key: "fillOpacity",
            editor: "number-input",
            editorOptions: {
              compact: true,
              label: "opacity",
              min: 0,
              max: 1,
              step: 0.01
            },
            defaultValue: current.fillOpacity
          }
        ]
      },
      {
        type: "column",
        size: [2, 1],
        columns: [
          { type: "label", label: editor.$i18n("svg.item.property.stroke") }
        ]
      },
      {
        type: "column",
        size: [2, 1],
        columns: [
          {
            key: "stroke",
            editor: "fill-single",
            editorOptions: {
              wide: true
            },
            defaultValue: current.stroke
          },
          {
            key: "strokeWidth",
            editor: "number-input",
            editorOptions: {
              compact: true,
              label: "line_weight"
            },
            defaultValue: current.strokeWidth
          }
        ]
      },
      {
        type: "column",
        size: [2, 1],
        columns: [
          {
            key: "strokeDasharray",
            editor: "StrokeDashArrayEditor",
            editorOptions: {
              label: editor.$i18n("svg.item.property.dashArray")
            },
            defaultValue: current.strokeDasharray || ""
          },
          {
            key: "strokeDashoffset",
            editor: "number-input",
            editorOptions: {
              compact: true,
              label: "power_input",
              min: -1e3,
              max: 1e3,
              step: 1
            },
            defaultValue: current.strokeDashoffset
          }
        ]
      },
      {
        key: "strokeLinecap",
        editor: "ToggleCheckBox",
        editorOptions: {
          label: editor.$i18n("svg.item.property.lineCap"),
          toggleLabels: [
            iconUse("line_cap_butt"),
            iconUse("line_cap_round"),
            iconUse("line_cap_square")
          ],
          toggleValues: [
            StrokeLineCap.BUTT,
            StrokeLineJoin.ROUND,
            StrokeLineCap.SQUARE
          ]
        },
        defaultValue: current.strokeLinecap || StrokeLineCap.BUTT
      },
      {
        key: "strokeLinejoin",
        editor: "ToggleCheckBox",
        editorOptions: {
          label: editor.$i18n("svg.item.property.lineJoin"),
          toggleLabels: [
            iconUse("line_join_miter"),
            iconUse("line_join_round"),
            iconUse("line_join_bevel")
          ],
          toggleValues: [
            StrokeLineJoin.MITER,
            StrokeLineJoin.ROUND,
            StrokeLineJoin.BEVEL
          ]
        },
        defaultValue: current.strokeLinejoin || StrokeLineJoin.MITER
      },
      {
        key: "mixBlendMode",
        editor: "BlendSelectEditor",
        editorOptions: {
          label: editor.$i18n("svg.item.property.blend")
        },
        defaultValue: current.mixBlendMode
      }
    ];
  });
  editor.registerInspector("polygon", (item) => {
    return [
      {
        key: "count",
        editor: "NumberInputEditor",
        editorOptions: {
          label: "Count",
          min: 3,
          max: 100,
          step: 1
        },
        defaultValue: item.count
      },
      {
        key: "button",
        editor: "Button",
        editorOptions: {
          label: "Copy ",
          text: "as path",
          command: "copy.path"
        }
      },
      {
        key: "button2",
        editor: "Button",
        editorOptions: {
          label: "Test Popup",
          action: [
            "showComponentPopup",
            {
              title: "Sample Test Popup",
              width: 400,
              inspector: [
                {
                  key: "test",
                  editor: "Button",
                  editorOptions: {
                    label: "Test",
                    text: "text",
                    onClick: () => {
                      window.alert("yellow");
                    }
                  }
                }
              ]
            }
          ]
        }
      }
    ];
  });
  editor.registerInspector("spline", () => {
    return [
      {
        key: "boundary",
        editor: "SelectIconEditor",
        editorOptions: {
          label: "Boundary",
          options: ["clamped", "open", "closed"]
        }
      },
      {
        key: "button",
        editor: "Button",
        editorOptions: {
          label: "Copy ",
          text: "as path",
          action: "copy.path"
        }
      }
    ];
  });
  editor.registerInspector("star", (item) => {
    return [
      {
        key: "isCurve",
        editor: "ToggleCheckBox",
        editorOptions: {
          label: "Curve",
          defaultValue: item.isCurve
        }
      },
      {
        key: "count",
        editor: "NumberInputEditor",
        editorOptions: {
          label: "Count",
          min: 3,
          max: 100,
          step: 1,
          wide: "true"
        }
      },
      {
        key: "radius",
        editor: "NumberInputEditor",
        editorOptions: {
          label: "Inner Radius",
          min: -1,
          max: 1,
          step: 0.01,
          wide: "true"
        }
      },
      {
        key: "tension",
        editor: "NumberInputEditor",
        editorOptions: {
          label: "Tension",
          min: 0,
          max: 1,
          step: 0.01,
          wide: "true"
        }
      },
      {
        key: "button",
        editor: "Button",
        editorOptions: {
          label: "Copy ",
          text: "as path",
          action: "copy.path"
        }
      }
    ];
  });
}
class SVGTextProperty extends BaseProperty {
  getTitle() {
    return this.$i18n("svg.text.property.title");
  }
  [SUBSCRIBE(REFRESH_SELECTION)]() {
    this.refreshShow(["svg-textpath", "svg-text", "svg-tspan"]);
  }
  refresh() {
    var current = this.$context.selection.current;
    if (current) {
      this.setAllValue([
        "lengthAdjust",
        "textLength",
        "startOffset",
        "text-anchor",
        "text"
      ]);
    }
  }
  setAllValue(list2 = []) {
    var current = this.$context.selection.current;
    if (!current)
      return;
    list2.forEach((key) => {
      this.children[`$${key}`].setValue(current[key]);
    });
  }
  getBody() {
    return `
      <div class='property-item '>
        ${createComponent("TextAreaEditor", {
      ref: "$text",
      label: this.$i18n("svg.text.property.textarea"),
      key: "text",
      onchange: "changeTextValue"
    })}
      </div>        
      <div class='property-item'>
        ${createComponent("SelectIconEditor", {
      ref: "$text-anchor",
      label: this.$i18n("svg.text.property.anchor"),
      key: "textAnchor",
      options: ["start", "middle", "end"],
      onchange: "changeTextValue"
    })}
          
      </div>            
      <div class='property-item '>
        ${createComponent("SelectEditor", {
      ref: "$lengthAdjust",
      label: this.$i18n("svg.text.property.length.adjust"),
      key: "lengthAdjust",
      value: "spacing",
      options: ["spacing", "spacingAndGlyphs"],
      onchange: "changeTextValue"
    })}
          
      </div>        
      <div class='property-item '>
        ${createComponent("RangeEditor", {
      ref: "$textLength",
      label: this.$i18n("svg.text.property.text.length"),
      key: "textLength",
      min: 0,
      max: 1e3,
      step: 0.1,
      onchange: "changeTextValue"
    })}
          
      </div>        
      <div class='property-item '>
        ${createComponent("RangeEditor", {
      ref: "$startOffset",
      label: this.$i18n("svg.text.property.start.offset"),
      key: "startOffset",
      min: 0,
      max: 1e3,
      step: 0.1,
      onchange: "changeTextValue"
    })}
          
      </div>                    
    `;
  }
  [SUBSCRIBE_SELF("changeTextValue")](key, value) {
    this.$commands.executeCommand("setAttribute", `change svg text property: ${key}`, this.$context.selection.packByValue({
      [key]: value
    }));
  }
}
function svgText(editor) {
  editor.registerUI("inspector.tab.style", {
    SVGTextProperty
  });
}
function text(editor) {
  editor.registerUI("inspector.tab.style", {
    TextProperty: ObjectProperty.create({
      title: editor.$i18n("text.property.title"),
      editableProperty: "text-style",
      preventUpdate: true
    })
  });
  editor.registerInspector("text-style", (current) => {
    return [
      {
        type: "column",
        size: [2, 1, 1],
        columns: [
          {
            key: "textAlign",
            editor: "SelectIconEditor",
            editorOptions: {
              compact: true,
              options: ["left", "center", "right", "justify"],
              icons: [
                "align_left",
                "align_center",
                "align_right",
                "align_justify"
              ]
            },
            defaultValue: current.textAlign || TextAlign.LEFT
          },
          "-",
          {
            key: "textTransform",
            editor: "SelectIconEditor",
            editorOptions: {
              options: [
                { value: TextTransform.CAPITALIZE, text: "Ag" },
                { value: TextTransform.UPPERCASE, text: "AG" },
                { value: TextTransform.LOWERCASE, text: "ag" }
              ],
              compact: true,
              icons: ["horizontal_rule"]
            },
            defaultValue: current.textTransform
          }
        ]
      },
      {
        type: "column",
        size: [3, 2, 1],
        gap: 20,
        columns: [
          {
            key: "textDecoration",
            editor: "SelectIconEditor",
            editorOptions: {
              options: [
                { value: TextDecoration.NONE, text: "None" },
                { value: TextDecoration.UNDERLINE, text: "Underline" },
                { value: TextDecoration.LINE_THROUGH, text: "LineThrough" }
              ],
              icons: ["horizontal_rule", "underline", "strikethrough"],
              onchange: "changeTextValue"
            },
            defaultValue: current.textDecoration
          },
          {
            key: "fontStyle",
            editor: "SelectIconEditor",
            editorOptions: {
              compact: true,
              options: ["normal", "italic"],
              icons: ["title", "italic"]
            },
            defaultValue: current.fontStyle
          },
          {
            key: "textClip",
            editor: "ToggleButton",
            editorOptions: {
              checkedValue: TextClip.TEXT,
              toggleLabels: [iconUse("vignette"), iconUse("vignette")],
              toggleTitles: ["", "Text Clip"],
              toggleValues: [TextClip.NONE, TextClip.TEXT]
            },
            defaultValue: current.textClip || TextClip.NONE
          }
        ]
      }
    ];
  });
}
var textShadow$1 = [
  {
    name: "Mystic",
    shadows: [
      {
        offsetX: 20,
        offsetY: 0,
        blurRadius: 10,
        color: "rgb(0,0,0)"
      }
    ]
  }
];
var TextShadowProperty$1 = "";
class TextShadowProperty extends BaseProperty {
  getTitle() {
    return this.$i18n("text.shadow.property.title");
  }
  getBody() {
    return `
      <div class="full text-shadow-item" ref="$shadowList"></div>
    `;
  }
  getTools() {
    return `
      <select class='text-shadow-samples' ref="$select">
      ${textShadow$1.map((item, index2) => {
      return `
          <option value="${index2}">${item.name}</option>
        `;
    }).join("")}
      </select>
      <button type="button" ref='$add'>${obj$2.add}</button>
    `;
  }
  [CLICK("$add")]() {
    const index2 = +this.refs.$select.value;
    this.children.$textshadow.trigger("add", textShadow$1[index2].shadows);
  }
  [LOAD("$shadowList")]() {
    var current = this.$context.selection.current || {};
    return createComponent("TextShadowEditor", {
      ref: "$textshadow",
      key: "textShadow",
      value: clone$1(current.textShadow),
      onchange: (key, value) => {
        this.$commands.executeCommand("setAttribute", "change text shadow", this.$context.selection.packByValue({
          [key]: clone$1(value)
        }));
      }
    });
  }
  get editableProperty() {
    return "textShadow";
  }
  [SUBSCRIBE(REFRESH_SELECTION) + IF("checkShow") + DEBOUNCE(100)]() {
    this.refresh();
  }
}
function textShadow(editor) {
  editor.registerUI("inspector.tab.style", {
    TextShadowProperty
  });
}
var TransitionProperty$1 = "";
const TRANSITION_TIMING_REG = /((cubic-bezier|steps)\(([^)]*)\))/gi;
class Transition extends PropertyItem {
  static parse(obj2) {
    return new Transition(obj2);
  }
  getDefaultObject() {
    return {
      name: "all",
      duration: Length.second(0),
      timingFunction: "linear",
      delay: Length.second(0)
    };
  }
  toCloneObject() {
    return {
      name: this.json.name,
      duration: this.json.duration + "",
      timingFunction: this.json.timingFunction,
      delay: this.json.delay + ""
    };
  }
  toCSS() {
    return {
      transition: this.toString()
    };
  }
  toString() {
    var json = this.json;
    return [json.name, json.duration, json.timingFunction, json.delay].join(" ");
  }
  static join(list2) {
    return list2.map((it) => new Transition(it).toString()).join(",");
  }
  static add(transition2, item = {}) {
    const list2 = Transition.parseStyle(transition2);
    list2.push(Transition.parse(item));
    return Transition.join(list2);
  }
  static remove(transition2, removeIndex) {
    return Transition.filter(transition2, (it, index2) => {
      return removeIndex != index2;
    });
  }
  static filter(transition2, filterFunction) {
    return Transition.join(Transition.parseStyle(transition2).filter((it) => filterFunction(it)));
  }
  static replace(transition2, replaceIndex, valueObject) {
    var list2 = Transition.parseStyle(transition2);
    if (list2[replaceIndex]) {
      list2[replaceIndex] = valueObject;
    } else {
      list2.push(valueObject);
    }
    return Transition.join(list2);
  }
  static get(transition2, index2) {
    var arr = Transition.parseStyle(transition2);
    return arr[index2];
  }
  static parseStyle(transition2) {
    var list2 = [];
    if (!transition2)
      return list2;
    const result = customParseConvertMatches(transition2, TRANSITION_TIMING_REG);
    list2 = result.str.split(",").map((it) => {
      const fields2 = it.split(" ").filter(Boolean);
      if (fields2.length >= 4) {
        return {
          name: fields2[0],
          duration: Length.parse(fields2[1]),
          timingFunction: customParseReverseMatches(fields2[2], result.matches),
          delay: Length.parse(fields2[3])
        };
      } else if (fields2.length >= 3) {
        return {
          name: fields2[0],
          duration: Length.parse(fields2[1]),
          delay: Length.parse(fields2[2])
        };
      } else if (fields2.length >= 1) {
        return {
          name: fields2[0],
          duration: Length.parse(fields2[1])
        };
      } else {
        return {};
      }
    });
    return list2.map((it) => Transition.parse(it));
  }
}
class TransitionProperty extends BaseProperty {
  getTitle() {
    return this.$i18n("transition.property.title");
  }
  getBody() {
    return `<div class='elf--transition-list' ref='$transitionList'></div>`;
  }
  getTools() {
    return `
        <button type="button" ref="$add" title="add Transition">${iconUse("add")}</button>
    `;
  }
  isFirstShow() {
    return true;
  }
  [LOAD("$transitionList") + DOMDIFF]() {
    var current = this.$context.selection.current;
    if (!current)
      return "";
    return Transition.parseStyle(current.transition).map((it, index2) => {
      const selectedClass = this.state.selectedIndex === index2 ? "selected" : "";
      const path = curveToPath(it.timingFunction, 30, 30);
      return `
      <div class='transition-group-item'>
        <div class='transition-item ${selectedClass}' data-index='${index2}' ref="transitionIndex${index2}">
            <div class='timing preview' data-index='${index2}' ref='$preview${index2}'>
              <svg class='item-canvas' width="30" height="30" viewBox="0 0 30 30">
                <path d="${path}" stroke="white" stroke-width="1" fill='none' />
              </svg>
            </div>
            <div class='name'>
              <div class='labels'>
                <span class='property-name' title='Property'>${it.name}</span>
                <span class='duration' title='Duration'><small>Duration: ${it.duration}</small></span>
                <span class='delay' title='Delay'><small>Delay: ${it.delay}</small></span>
              </div>
            </div>
            <div class='tools'>
                <button type="button" class="del" data-index="${index2}">
                  ${iconUse("remove2")}
                </button>
            </div>
        </div>
      </div>        
      `;
    });
  }
  [SUBSCRIBE(REFRESH_SELECTION)]() {
    this.refreshShowIsNot([]);
  }
  [CLICK("$add")]() {
    var current = this.$context.selection.current;
    if (current) {
      this.$commands.executeCommand("setAttribute", "add transition", this.$context.selection.packByValue({
        transition: (item) => Transition.add(item.transition)
      }));
      this.nextTick(() => {
        window.setTimeout(() => {
          this.refresh();
        }, 100);
      });
    } else {
      window.alert("Select a layer");
    }
  }
  getCurrentTransition() {
    return this.current.transitions[this.selectedIndex];
  }
  [CLICK("$transitionList .tools .del")](e) {
    var removeIndex = e.$dt.attr("data-index");
    var current = this.$context.selection.current;
    if (!current)
      return;
    current.reset({
      transition: Transition.remove(current.transition, removeIndex)
    });
    this.emit("refreshElement", current);
    this.refresh();
  }
  selectItem(selectedIndex, isSelected = true) {
    if (isSelected) {
      this.refs[`transitionIndex${selectedIndex}`].addClass("selected");
    } else {
      this.refs[`transitionIndex${selectedIndex}`].removeClass("selected");
    }
  }
  viewTransitionPicker($preview) {
    if (typeof this.selectedIndex === "number") {
      this.selectItem(this.selectedIndex, false);
    }
    this.selectedIndex = +$preview.attr("data-index");
    this.current = this.$context.selection.current;
    if (!this.current)
      return;
    this.currentTransition = Transition.get(this.current.transition, this.selectedIndex);
    this.viewTransitionPropertyPopup();
  }
  viewTransitionPropertyPopup() {
    if (!this.currentTransition)
      return;
    const transition2 = this.currentTransition;
    this.emit("showTransitionPropertyPopup", {
      changeEvent: "changeTransitionPropertyPopup",
      data: transition2.toCloneObject(),
      instance: this
    });
  }
  [CLICK("$transitionList .preview")](e) {
    this.viewTransitionPicker(e.$dt);
  }
  getRef(...args2) {
    return this.refs[args2.join("")];
  }
  [SUBSCRIBE("changeTransitionPropertyPopup")](data) {
    if (this.currentTransition) {
      this.currentTransition.reset(__spreadValues({}, data));
      if (this.current) {
        this.current.reset({
          transition: Transition.replace(this.current.transition, this.selectedIndex, this.currentTransition)
        });
        this.emit("refreshElement", this.current);
        this.refresh();
      }
    }
  }
}
var TransitionPropertyPopup$1 = "";
const property_list = [
  "none",
  "all",
  "background-color",
  "background-position",
  "background-size",
  "border",
  "border-color",
  "border-width",
  "border-bottom",
  "border-bottom-color",
  "border-bottom-left-radius",
  "border-bottom-right-radius",
  "border-bottom-width",
  "border-left",
  "border-left-color",
  "border-left-width",
  "border-radius",
  "border-right",
  "border-right-color",
  "border-right-width",
  "border-spacing",
  "border-top",
  "border-top-color",
  "border-top-left-radius",
  "border-top-right-radius",
  "border-top-width",
  "bottom",
  "box-shadow",
  "color",
  "filter",
  "font-size",
  "font-size-adjust",
  "font-weight",
  "height",
  "left",
  "letter-spacing",
  "line-height",
  "margin",
  "margin-bottom",
  "margin-left",
  "margin-right",
  "margin-top",
  "max-height",
  "max-width",
  "min-height",
  "min-width",
  "opacity",
  "padding",
  "padding-bottom",
  "padding-left",
  "padding-right",
  "padding-top",
  "perspective",
  "perspective-origin",
  "right",
  "text-decoration",
  "text-decoration-color",
  "text-indent",
  "text-shadow",
  "top",
  "transform",
  "vertical-align",
  "visibility",
  "width",
  "word-spacing",
  "z-index"
].map((it) => ({
  value: it,
  text: it
}));
class TransitionPropertyPopup extends BasePopup {
  getTitle() {
    return "Transition";
  }
  initState() {
    return {
      changeEvent: "",
      instance: {},
      data: {
        timingFunction: "linear",
        duration: "0s",
        delay: "0s",
        name: "all"
      }
    };
  }
  updateData(opt) {
    this.state.data = __spreadValues(__spreadValues({}, this.state.data), opt);
    if (this.state.instance) {
      this.state.instance.trigger(this.state.changeEvent, this.state.data);
    }
  }
  getBody() {
    return `<div class='elf--transition-property-popup' ref='$popup'></div>`;
  }
  [LOAD("$popup")]() {
    return `
      <div class="box">
        ${this.templateForProperty()}
        ${this.templateForTimingFunction()}
        ${this.templateForDelay()}
        ${this.templateForDuration()}
      </div>
    `;
  }
  templateForTimingFunction() {
    return `
    <div class='timing-function'>
      <label>Timing function</label>
      ${createComponent("CubicBezierEditor", {
      ref: "$cubicBezierEditor",
      key: "timingFunction",
      value: this.state.data.timingFunction || "linear",
      onChange: "changeCubicBezier"
    })}
    </div>
    `;
  }
  [SUBSCRIBE_SELF("changeTransition")](key, value) {
    this.updateData({
      [key]: value
    });
  }
  templateForProperty() {
    return `
      <div class='name'>
        ${createComponent("SelectEditor", {
      ref: "$property",
      icon: true,
      label: "Property",
      key: "name",
      value: this.state.data.name,
      options: property_list,
      onChange: "changeTransition"
    })}
      </div>
    `;
  }
  templateForDelay() {
    return `
    <div class='delay'>
      ${createComponent("RangeEditor", {
      ref: "$delay",
      label: "Delay",
      key: "delay",
      value: this.state.data.delay,
      units: ["s", "ms"],
      onChange: "changeRangeEditor"
    })}
    </div>
    `;
  }
  templateForDuration() {
    return `
    <div class='duration'>
      ${createComponent("RangeEditor", {
      ref: "$duration",
      label: "Duration",
      key: "duration",
      value: this.state.data.duration,
      units: ["s", "ms"],
      onChange: "changeRangeEditor"
    })}
    </div>
    `;
  }
  [SUBSCRIBE_SELF("changeRangeEditor")](key, value) {
    this.updateData({ [key]: value });
  }
  [SUBSCRIBE_SELF("changeCubicBezier")](key, value) {
    this.updateData({ [key]: value });
  }
  [SUBSCRIBE("showTransitionPropertyPopup")](data) {
    this.setState(data);
    this.show(250);
    this.children.$cubicBezierEditor.trigger("showCubicBezierEditor", data.data.timingFunction);
  }
  [SUBSCRIBE("hideTransitionPropertyPopup")]() {
    this.$el.hide();
  }
}
function transition(editor) {
  editor.registerUI("inspector.tab.transition", {
    TransitionProperty
  });
  editor.registerUI("popup", {
    TransitionPropertyPopup
  });
}
var VideoProperty$1 = "";
class VideoProperty extends BaseProperty {
  getClassName() {
    return "item elf--video-property";
  }
  getTitle() {
    return this.$i18n("video.property.title");
  }
  initState() {
    return {
      $video: { el: {} },
      status: "play",
      volume: 1
    };
  }
  getBody() {
    return `<div ref='$body' style='padding-top: 3px;'></div>`;
  }
  get video() {
    return this.state.$video.el;
  }
  get volumeStatus() {
    if (this.state.volume === 0)
      return "muted";
    if (this.state.volume > 0.5)
      return "up";
    return "down";
  }
  play() {
    if (this.video)
      this.video.play();
  }
  pause() {
    if (this.video)
      this.video.pause();
  }
  [LOAD("$body")]() {
    var current = this.$context.selection.current || { playTime: "0:1:1" };
    var currentTime = current.currentTime || 0;
    var duration = (current.playTime || "0:1:1").split(":").pop();
    return `
        <div ref='$tools' class='play-control' data-selected-value="${this.state.status}">
          <button type="button" data-value="play" >${obj$2.play} ${this.$i18n("video.property.play")}</button>
          <button type="button" data-value="pause">${obj$2.pause}  ${this.$i18n("video.property.pause")}</button>      
          <div>
            ${createComponent("NumberRangeEditor", {
      ref: "$currentTime",
      min: 0,
      max: duration,
      value: currentTime,
      step: 1e-3,
      onchange: "changeCurrentTime"
    })}
          </div>
        </div>    
        <div class='property-item animation-property-item has-label'>        
          <div class='group'>
            <span class='add-timeline-property' data-property='volume'></span>
            ${this.$i18n("video.property.volume")}
          </div>
          <div ref='$volume_control' class='volume-control' data-selected-value='${this.volumeStatus}'>
            <span data-value='muted'>${obj$2.volume_off}</span>
            <span data-value='down'>${obj$2.volume_down}</span>
            <span data-value='up'>${obj$2.volume_up}</span>
            <input type="range" ref='$volume' min="0" max="1" step="0.001" value="${this.state.volume}" />
          </div>          
        </div>
        <div class='property-item animation-property-item has-label'>        
          <div class='group'>
            <span class='add-timeline-property' data-property='playbackRate'></span>
            ${this.$i18n("video.property.playbackRate")}
          </div>
          <div>
            ${createComponent("NumberRangeEditor", {
      ref: "$playbackRate",
      min: 0.1,
      max: 10,
      clamp: true,
      value: this.state.playbackRate,
      step: 1e-3,
      onchange: "changePlaybackRate"
    })}
          </div>
        </div>        
        <div class='property-item animation-property-item full'>
          <div class='group'>
            <span class='add-timeline-property' data-property='playTime'></span>
            ${this.$i18n("video.property.playTime")}
          </div>
          ${createComponent("MediaProgressEditor", {
      ref: "$progress",
      key: "playTime",
      value: current.playTime,
      onchange: "changeSelect"
    })}
        </div>
      `;
  }
  [SUBSCRIBE("changeCurrentTime")](key, currentTime) {
    this.setState({ currentTime }, false);
    this.$commands.executeCommand("setAttribute", "change video property", this.$context.selection.packByValue({ currentTime }));
  }
  [SUBSCRIBE("changePlaybackRate")](key, playbackRate) {
    this.setState({ playbackRate }, false);
    this.$commands.executeCommand("setAttribute", "change video property", this.$context.selection.packByValue({ playbackRate }));
  }
  [CHANGEINPUT("$volume")]() {
    const volume = Number(this.refs.$volume.value);
    this.setState({ volume }, false);
    this.bindData("$volume_control");
    this.$commands.executeCommand("setAttribute", "change video property", this.$context.selection.packByValue({ volume }));
  }
  [BIND("$volume_control")]() {
    return {
      "data-selected-value": this.volumeStatus
    };
  }
  [BIND("$tools")]() {
    return {
      "data-selected-value": this.state.status
    };
  }
  [CLICK("$tools button")](e) {
    var playType = e.$dt.attr("data-value");
    switch (playType) {
      case "play":
        this.setState({ status: "pause" }, false);
        this.play();
        break;
      case "pause":
        this.setState({ status: "play" }, false);
        this.pause();
        break;
    }
    this.bindData("$tools");
  }
  [SUBSCRIBE_SELF("changeValue") + DEBOUNCE(100)](key, value) {
    if (!this.state.$video)
      return;
    this.$commands.executeCommand("setAttribute", "change video property", this.$context.selection.packByValue({ [key]: value }));
  }
  [SUBSCRIBE_SELF("changeSelect")](key, value) {
    this.$commands.executeCommand("setAttribute", "change video property", this.$context.selection.packByValue({ [key]: value }));
  }
  [SUBSCRIBE_SELF("updateVideoEvent")]() {
    if (this.video.paused) {
      this.setState({
        status: "play",
        currentTime: this.video.currentTime
      }, false);
      this.bindData("$tools");
    }
    this.children.$currentTime.setValue(this.video.currentTime);
  }
  [SUBSCRIBE(REFRESH_SELECTION) + DEBOUNCE(100)]() {
    const current = this.$context.selection.current;
    this.refreshShow(["video"]);
    if (current && current.is("video")) {
      this.emit("refElement", current.id, ($el) => {
        const $video = $el.$("video");
        this.state.$video = $video;
        this.setState({
          volume: current.volume,
          currentTime: current.currentTime,
          playbackRate: current.playbackRate
        }, false);
        this.video.ontimeupdate = (e) => {
          this.trigger("updateVideoEvent", e);
        };
        this.video.onprogress = (e) => {
          this.trigger("updateVideoEvent", e);
        };
        this.load("$body");
      });
    }
  }
}
function video(editor) {
  editor.registerUI("inspector.tab.style", {
    VideoProperty
  });
}
class ColorInformation extends EditorElement {
  template() {
    return `
        <div class="information hex">
            <div ref="$informationChange" class="information-change">
                <button ref="$formatChangeButton" type="button" class="format-change-button">
                    ${iconUse("unfold")}
                </button>
            </div>
            <div class="information-item hex">
                <div class="input-field hex">
                    <input ref="$hexCode" class="input" type="text" />
                    <div class="title">HEX</div>
                </div>
            </div>
            <div class="information-item rgb">
                <div class="input-field rgb-r">
                    <input ref="$rgb_r" class="input" type="number" step="1" min="0" max="255" />
                    <div class="title">R</div>
                </div>
                <div class="input-field rgb-g">
                    <input ref="$rgb_g" class="input" type="number" step="1" min="0" max="255" />
                    <div class="title">G</div>
                </div>
                <div class="input-field rgb-b">
                    <input ref="$rgb_b" class="input" type="number" step="1" min="0" max="255" />
                    <div class="title">B</div>
                </div>          
                <div class="input-field rgb-a">
                    <input ref="$rgb_a" class="input" type="number" step="0.01" min="0" max="1" />
                    <div class="title">A</div>
                </div>                                                            
            </div>
            <div class="information-item hsl">
                <div class="input-field hsl-h">
                    <input ref="$hsl_h" class="input" type="number" step="1" min="0" max="360" />
                    <div class="title">H</div>
                </div>
                <div class="input-field hsl-s">
                    <input ref="$hsl_s" class="input" type="number" step="1" min="0" max="100" />
                    <div class="postfix">%</div>
                    <div class="title">S</div>
                </div>
                <div class="input-field hsl-l">
                    <input ref="$hsl_l" class="input" type="number" step="1" min="0" max="100" />
                    <div class="postfix">%</div>                        
                    <div class="title">L</div>
                </div>
                <div class="input-field hsl-a">
                    <input ref="$hsl_a" class="input" type="number" step="0.01" min="0" max="1" />
                    <div class="title">A</div>
                </div>
            </div>
        </div>
        `;
  }
  get manager() {
    return this.parent.manager;
  }
  setCurrentFormat(format2) {
    this.format = format2;
    this.initFormat();
  }
  initFormat() {
    var current_format = this.format || "hex";
    ["hex", "rgb", "hsl"].filter((it) => it !== current_format).forEach((formatString) => {
      this.$el.removeClass(formatString);
    });
    this.$el.addClass(current_format);
  }
  nextFormat() {
    var current_format = this.format || "hex";
    var next_format = "hex";
    if (current_format == "hex") {
      next_format = "rgb";
    } else if (current_format == "rgb") {
      next_format = "hsl";
    } else if (current_format == "hsl") {
      if (this.parent.alpha == 1) {
        next_format = "hex";
      } else {
        next_format = "rgb";
      }
    }
    this.format = next_format;
    this.initFormat();
    this.parent.changeFormat(this.format);
  }
  goToFormat(to_format) {
    this.format = to_format;
    if (to_format === "rgb" || to_format === "hsl") {
      this.initFormat();
    }
    this.parent.changeFormat(this.format);
  }
  getFormat() {
    return this.format || "hex";
  }
  changeRgbColor() {
    this.parent.lastUpdateColor({
      type: "rgb",
      r: this.refs.$rgb_r.int(),
      g: this.refs.$rgb_g.int(),
      b: this.refs.$rgb_b.int(),
      a: this.refs.$rgb_a.float()
    });
  }
  changeHslColor() {
    this.parent.lastUpdateColor({
      type: "hsl",
      h: this.refs.$hsl_h.int(),
      s: this.refs.$hsl_s.int(),
      l: this.refs.$hsl_l.int(),
      a: this.refs.$hsl_a.float()
    });
  }
  hasValue(e) {
    if (e.target.value === "") {
      return false;
    }
    return true;
  }
  [INPUT("$rgb_r") + IF("hasValue")]() {
    this.changeRgbColor();
  }
  [INPUT("$rgb_g") + IF("hasValue")]() {
    this.changeRgbColor();
  }
  [INPUT("$rgb_b") + IF("hasValue")]() {
    this.changeRgbColor();
  }
  [INPUT("$rgb_a") + IF("hasValue")]() {
    this.changeRgbColor();
  }
  [INPUT("$hsl_h") + IF("hasValue")]() {
    this.changeHslColor();
  }
  [INPUT("$hsl_s") + IF("hasValue")]() {
    this.changeHslColor();
  }
  [INPUT("$hsl_l") + IF("hasValue")]() {
    this.changeHslColor();
  }
  [INPUT("$hsl_a") + IF("hasValue")]() {
    this.changeHslColor();
  }
  [KEYUP("$hexCode") + IF("hasValue")]() {
    var code2 = this.refs.$hexCode.val();
    if (code2.charAt(0) == "#" && (code2.length == 7 || code2.length === 9)) {
      this.parent.lastUpdateColor(code2);
    }
  }
  [PASTE("$hexCode") + IF("hasValue")]() {
    var code2 = this.refs.$hexCode.val();
    if (code2.charAt(0) == "#" && (code2.length == 7 || code2.length === 9)) {
      this.parent.lastUpdateColor(code2);
    }
  }
  [CLICK("$formatChangeButton")]() {
    this.nextFormat();
  }
  [CLICK("$el .information-item.hex .input-field .title")]() {
    this.goToFormat("hex");
  }
  [CLICK("$el .information-item.rgb .input-field .title")]() {
    this.goToFormat("hsl");
  }
  [CLICK("$el .information-item.hsl .input-field .title")]() {
    this.goToFormat("rgb");
  }
  setRGBInput() {
    this.refs.$rgb_r.val(this.manager.rgb.r);
    this.refs.$rgb_g.val(this.manager.rgb.g);
    this.refs.$rgb_b.val(this.manager.rgb.b);
    this.refs.$rgb_a.val(this.manager.alpha);
  }
  setHSLInput() {
    this.refs.$hsl_h.val(this.manager.hsl.h);
    this.refs.$hsl_s.val(this.manager.hsl.s);
    this.refs.$hsl_l.val(this.manager.hsl.l);
    this.refs.$hsl_a.val(this.manager.alpha);
  }
  setHexInput() {
    this.refs.$hexCode.val(this.manager.toString("hex"));
  }
  setValue() {
    this.refresh();
  }
  refresh() {
    this.setCurrentFormat(this.manager.format);
    this.setRGBInput();
    this.setHSLInput();
    this.setHexInput();
  }
}
class ColorPalette extends EditorElement {
  initState() {
    return {
      hueColor: "rgba(0, 0, 0, 1)",
      s: 0,
      v: 0
    };
  }
  template() {
    return `
        <div class="color-panel">
            <div ref="$saturation" class="saturation">
                <div ref="$value" class="value">
                    <div ref="$drag_pointer" class="drag-pointer"></div>
                </div>
            </div>        
        </div>        
        `;
  }
  afterRender() {
    this.rect = this.$el.rect();
  }
  [BIND("$el")]() {
    return {
      style: {
        "background-color": this.state.hueColor
      }
    };
  }
  [BIND("$drag_pointer")]() {
    if (!this.rect || this.rect.width === 0) {
      this.rect = this.$el.rect();
    }
    const x = this.rect.width * this.state.s;
    const y = this.rect.height * (1 - this.state.v);
    return {
      style: {
        left: x,
        top: y
      }
    };
  }
  [POINTERSTART("$el") + MOVE("movePointer") + END("moveEndPointer")]() {
    this.rect = this.$el.rect();
    this.refreshColorUI();
  }
  movePointer() {
    this.refreshColorUI();
  }
  moveEndPointer() {
    this.parent.changeEndColor();
  }
  refreshColorUI() {
    const e = this.$config.get("bodyEvent");
    const minX = this.rect.left;
    const maxX = this.rect.right;
    const minY = this.rect.top;
    const maxY = this.rect.bottom;
    const currentX = Math.min(maxX, Math.max(minX, e.clientX));
    const currentY = Math.min(maxY, Math.max(minY, e.clientY));
    const width2 = maxX - minX;
    const height2 = maxY - minY;
    var s = (currentX - minX) / width2;
    var v = (height2 - (currentY - minY)) / height2;
    this.parent.changeColor({
      type: "hsv",
      s,
      v
    });
  }
  setValue(s, v, hueColor) {
    this.setState({
      s,
      v,
      hueColor
    });
  }
}
class ColorView extends EditorElement {
  initState() {
    return {
      value: "rgba(0, 0, 0, 1)"
    };
  }
  template() {
    return `<div class='color'></div>`;
  }
  [BIND("$el")]() {
    return {
      style: {
        "background-color": this.state.value
      }
    };
  }
  setValue(value) {
    this.setState({
      value
    });
  }
}
class Hue extends EditorElement {
  initState() {
    return {
      hue: 0,
      minValue: 0,
      maxValue: 360
    };
  }
  template() {
    return `
            <div class="hue">
                <div ref="$container" class="hue-container">
                    <div ref="$bar" class="drag-bar"></div>
                </div>
            </div>
        `;
  }
  [BIND("$bar")]() {
    const hue = this.state.hue;
    return {
      style: {
        left: Length.makePercent(hue, 360)
      },
      class: [
        "drag-bar",
        {
          first: hue <= this.state.minValue,
          last: hue >= this.state.maxValue
        }
      ]
    };
  }
  [POINTERSTART("$container") + MOVE("movePointer") + END("moveEndPointer")]() {
    this.rect = this.refs.$container.rect();
    this.refreshColorUI();
  }
  movePointer() {
    this.refreshColorUI();
  }
  refreshColorUI() {
    const minX = this.rect.left;
    const maxX = this.rect.right;
    const currentX = Math.max(Math.min(maxX, this.$config.get("bodyEvent").clientX), minX);
    const rate = (currentX - minX) / (maxX - minX);
    this.parent.changeColor({
      h: rate * this.state.maxValue,
      type: "hsv"
    });
  }
  setValue(hue) {
    this.setState({
      hue
    });
  }
}
class Opacity extends EditorElement {
  initState() {
    return {
      colorbar: parse("rgba(0, 0, 0, 1)"),
      opacity: 0,
      minValue: 0,
      maxValue: 100
    };
  }
  template() {
    return `
        <div class="opacity">
            <div ref="$container" class="opacity-container">
                <div ref="$colorbar" class="color-bar"></div>
                <div ref="$bar" class="drag-bar2"></div>
            </div>
        </div>
        `;
  }
  [BIND("$colorbar")]() {
    const rgb2 = clone$1(this.state.colorbar);
    rgb2.a = 0;
    const start2 = format(rgb2, "rgb");
    rgb2.a = 1;
    const end2 = format(rgb2, "rgb");
    return {
      style: {
        background: `linear-gradient(to right, ${start2}, ${end2})`
      }
    };
  }
  [BIND("$bar")]() {
    const opacity2 = this.state.opacity * 100;
    return {
      style: {
        left: Length.percent(opacity2)
      },
      class: [
        "drag-bar2",
        {
          first: opacity2 <= this.state.minValue,
          last: opacity2 >= this.state.maxValue
        }
      ]
    };
  }
  [POINTERSTART("$container") + MOVE("movePointer") + END("moveEndPointer")]() {
    this.rect = this.refs.$container.rect();
    this.refreshColorUI();
  }
  movePointer() {
    this.refreshColorUI();
  }
  refreshColorUI() {
    const minX = this.rect.left;
    const maxX = this.rect.right;
    const currentX = Math.max(Math.min(maxX, this.$config.get("bodyEvent").clientX), minX);
    const rate = (currentX - minX) / (maxX - minX);
    this.parent.changeColor({
      a: rate.toFixed(2)
    });
  }
  setValue(colorbar, opacity2) {
    this.setState({
      opacity: opacity2,
      colorbar
    });
  }
}
class ColorManagerV2 {
  constructor() {
    this.initialize();
  }
  initialize() {
    this.state = {
      rgb: {},
      hsl: {},
      hsv: {},
      alpha: 1,
      format: "hex"
    };
  }
  get hsv() {
    return this.state.hsv;
  }
  get rgb() {
    return this.state.rgb;
  }
  get hsl() {
    return this.state.hsl;
  }
  get hex() {
    return this.state.hex;
  }
  get alpha() {
    if (typeof this.state.alpha === "undefined")
      return 1;
    return this.state.alpha;
  }
  get format() {
    return this.state.format;
  }
  changeFormat(format2) {
    this.state.format = format2;
  }
  initColor(colorObj) {
    this.changeColor(colorObj);
  }
  changeColor(colorObj) {
    colorObj = colorObj || "#FF0000";
    if (typeof colorObj === "string") {
      colorObj = parse(colorObj);
    }
    this.state.alpha = typeof colorObj.a !== "undefined" ? colorObj.a : this.state.alpha;
    this.state.format = colorObj.type != "hsv" ? colorObj.type || this.state.format : this.state.format;
    if (colorObj.type == "hsl") {
      this.state.hsl = __spreadValues(__spreadValues({}, this.state.hsl), colorObj);
      this.state.rgb = HSLtoRGB(this.state.hsl);
      this.state.hsv = HSLtoHSV(colorObj);
    } else if (colorObj.type == "hex") {
      this.state.rgb = __spreadValues(__spreadValues({}, this.state.rgb), colorObj);
      this.state.hsl = RGBtoHSL(this.state.rgb);
      this.state.hsv = RGBtoHSV(colorObj);
    } else if (colorObj.type == "rgb") {
      this.state.rgb = __spreadValues(__spreadValues({}, this.state.rgb), colorObj);
      this.state.hsl = RGBtoHSL(this.state.rgb);
      this.state.hsv = RGBtoHSV(colorObj);
    } else if (colorObj.type == "hsv") {
      this.state.hsv = __spreadValues(__spreadValues({}, this.state.hsv), colorObj);
      this.state.rgb = HSVtoRGB(this.state.hsv);
      this.state.hsl = HSVtoHSL(this.state.hsv);
    }
  }
  getHueColor() {
    return checkHueColor(this.state.hsv.h / 360);
  }
  toString(type) {
    type = type || this.state.format;
    var colorObj = this.state[type] || this.state.rgb;
    return format(__spreadProps(__spreadValues({}, colorObj), { a: this.state.alpha }), type);
  }
  toColor(type) {
    type = (type || this.state.format).toLowerCase();
    return this.toString(type);
  }
}
class ColorPickerEditor extends EditorElement {
  created() {
    this.manager = new ColorManagerV2();
  }
  initState() {
    const value = this.props.value || "rgba(0, 0, 0, 1)";
    this.manager.initColor(value);
    return {
      key: this.props.key,
      value: this.manager.toString()
    };
  }
  updateData(opt = {}) {
    this.setState(opt, false);
    this.modifyColorPicker();
  }
  modifyColorPicker() {
    this.parent.trigger(this.props.onchange, this.props.key, this.state.value, this.props.params);
  }
  initColor(newColor, format2) {
    this.manager.changeColor(newColor, format2);
    this.refresh();
  }
  changeColor(newColor, format2) {
    this.manager.changeColor(newColor, format2);
    this.refresh();
    this.updateData({
      value: this.manager.toColor()
    });
  }
  [SUBSCRIBE_SELF("selectColorAssets")](key, color2) {
    this.lastUpdateColor(color2);
  }
  changeFormat(format2) {
    this.manager.changeFormat(format2);
    this.setState({
      value: this.manager.toColor()
    }, false);
    this.modifyColorPicker();
    this.changeEndColor();
  }
  lastUpdateColor(newColor, format2) {
    this.manager.changeColor(newColor, format2);
    this.refresh();
    this.setState({
      value: this.manager.toColor()
    }, false);
    this.modifyColorPicker();
    this.changeEndColor();
  }
  changeEndColor() {
    this.parent.trigger(this.props.onchangeend, this.props.key, this.state.value, this.props.params);
  }
  refresh() {
    const color2 = this.manager.toColor();
    this.children.$palette.setValue(this.manager.hsv.s, this.manager.hsv.v, this.manager.getHueColor());
    this.children.$opacity.setValue(this.manager.rgb, this.manager.alpha);
    this.children.$hue.setValue(this.manager.hsv.h);
    this.children.$colorview.setValue(color2);
    this.children.$information.setValue();
  }
  components() {
    return {
      Hue,
      Opacity,
      ColorView,
      Palette: ColorPalette,
      ColorInformation
    };
  }
  template() {
    return `
        <div class='colorpicker sketch inline'>
            <div class='colorpicker-body'>
                ${createComponent("Palette", { ref: "$palette" })}
                <div class="control">
                    ${createComponent("Hue", { ref: "$hue" })}
                    ${createComponent("Opacity", { ref: "$opacity" })}
                    <div class="empty"></div>
                    ${createComponent("ColorView", {
      ref: "$colorview"
    })}                    
                </div>
                ${createComponent("ColorInformation", {
      ref: "$information"
    })}                
                ${this.$context.injectManager.generate("colorpicker")}
                ${createComponent("ColorAssetsEditor", {
      ref: "$colorAsset",
      key: "colorAssets",
      onchange: "selectColorAssets"
    })}
            </div>
        </div>
      `;
  }
}
var ColorPickerPopup$1 = "";
class ColorPickerPopup extends BasePopup {
  getTitle() {
    return this.$i18n("colorpicker.popup.title");
  }
  getClassName() {
    return "compact elf--colorpicker-popup";
  }
  initState() {
    return {
      color: "rgba(0, 0, 0, 1)"
    };
  }
  updateData(opt = {}) {
    this.setState(opt, false);
    if (this.state.target) {
      this.state.target.trigger(this.state.changeEvent, this.state.color, this.params);
    }
  }
  updateEndData(opt = {}) {
    this.setState(opt, false);
    if (this.state.target) {
      this.state.target.trigger(this.state.changeEndEvent, this.state.color, this.params);
    }
  }
  getBody() {
    return `
    <div>
      <div class='box'>
        ${createComponent("EmbedColorPicker", {
      ref: "$color",
      value: this.state.color,
      onchange: (color2) => this.updateData({ color: color2 }),
      onchangeend: (color2) => this.updateEndData({ color: color2 })
    })}
    </div>
  `;
  }
  [LOAD("$projectColors")]() {
    var project2 = this.$context.selection.currentProject || { colors: [] };
    var colors2 = project2.colors;
    return colors2.map((color2) => {
      return `
      <div class='color-item' title='${color2.name}'>
        <div class='color-view' data-color='${color2.color}' style='background-color: ${color2.color}'></div>
      </div>`;
    });
  }
  [CLICK("$projectColors .color-view")](e) {
    this.updateData({
      color: e.$dt.attr("data-color")
    });
    this.children.$color.setValue(this.state.color);
  }
  [SUBSCRIBE("showColorPickerPopup")](data, params, rect2) {
    data.changeEvent = data.changeEvent || "changeFillPopup";
    if (!(data.target instanceof UIElement)) {
      throw new Error("ColorPicker needs data.target");
    }
    this.params = params;
    this.setState(data, false);
    this.children.$color.setValue(this.state.color);
    this.showByRect(this.makeRect(245, 500, rect2));
  }
  [SUBSCRIBE("hideColorPickerPopup")]() {
    this.hide();
  }
}
class EmbedColorPicker extends EditorElement {
  initState() {
    return {
      value: this.props.value || "rgba(0, 0, 0, 1)"
    };
  }
  template() {
    return `
        <div class='embed-color-picker'>
          ${createComponent("ColorPickerEditor", {
      ref: "$colorpicker",
      key: "colorpicker",
      value: this.state.value,
      onchange: "localChangeColor",
      onchangeend: "localLastUpdate"
    })}
        </div>
      `;
  }
  [SUBSCRIBE_SELF("localChangeColor")](key, color2) {
    this.parent.trigger(this.props.onchange, color2);
  }
  [SUBSCRIBE_SELF("localLastUpdate")](key, color2) {
    this.parent.trigger(this.props.onchangeend, color2);
  }
  setValue(color2) {
    this.state.value = color2;
    this.children.$colorpicker.initColor(color2);
  }
  refresh() {
    this.children.$colorpicker.initColor(this.props.value);
  }
}
function color(editor) {
  editor.registerElement({
    ColorPickerEditor,
    EmbedColorPicker
  });
  editor.registerUI("popup", {
    ColorPickerPopup
  });
}
var ComponentPopup$1 = "";
class ComponentPopup extends BasePopup {
  getClassName() {
    return "component-property w(800)";
  }
  getTitle() {
    return "Component";
  }
  initState() {
    return {
      title: "",
      inspector: []
    };
  }
  refresh() {
    this.setTitle(this.state.title || this.getTitle());
    this.load();
  }
  getBody() {
    return `
      <div ref='$body'></div>
    `;
  }
  [BIND("$body")]() {
    return {
      style: {
        width: this.state.width || 250
      }
    };
  }
  [LOAD("$body")]() {
    const inspector2 = this.state.inspector;
    return createComponent("ComponentEditor", {
      inspector: inspector2,
      onchange: "changeComponent"
    });
  }
  [SUBSCRIBE_SELF("changeComponent")](key, value) {
    if (isFunction(this.state.changeEvent)) {
      this.emit(this.state.changeEvent, key, value);
    }
  }
  [SUBSCRIBE(SHOW_COMPONENT_POPUP)](data) {
    this.setState(data, false);
    this.refresh();
    this.show(data.width);
  }
}
var ComponentProperty$1 = "";
class ComponentProperty extends BaseProperty {
  getClassName() {
    return "component-property";
  }
  getTitle() {
    return "Component";
  }
  isShow() {
    var _a;
    var current = (_a = this.$context.selection) == null ? void 0 : _a.current;
    const inspector2 = this.$context.components.createInspector(current);
    if (current && (current.is("component") || inspector2.length > 0)) {
      return true;
    }
    return false;
  }
  [SUBSCRIBE(REFRESH_SELECTION) + DEBOUNCE(100)]() {
    this.refreshShow(() => {
      const current = this.$context.selection.current;
      const inspector2 = this.$context.components.createInspector(current);
      return inspector2.length > 0;
    });
  }
  refresh() {
    var current = this.$context.selection.current;
    if (current) {
      this.setTitle(current.getDefaultTitle() || current.itemType || current.name);
      this.load();
    }
  }
  getBody() {
    return `
      <div ref='$body'></div>
    `;
  }
  [LOAD("$body")]() {
    var _a;
    var current = (_a = this.$context.selection) == null ? void 0 : _a.current;
    if (!current)
      return "";
    const inspector2 = this.$context.components.createInspector(current);
    inspector2.forEach((it) => {
      if (isString(it)) {
        return;
      }
      let defaultValue2 = current[it.key] || it.defaultValue;
      if (isFunction(it.convertDefaultValue)) {
        defaultValue2 = it.convertDefaultValue(current, it.key);
      }
      it.defaultValue = defaultValue2;
    });
    return createComponent("ComponentEditor", {
      ref: "$comp",
      inspector: inspector2,
      onchange: "changeComponentProperty"
    });
  }
  [SUBSCRIBE_SELF("changeComponentProperty")](key, value) {
    this.$commands.executeCommand("setAttribute", "change component : " + key, this.$context.selection.packByValue({
      [key]: value
    }));
  }
}
function component(editor) {
  editor.registerUI("inspector.tab.style", {
    ComponentProperty
  });
  editor.registerUI("popup", {
    ComponentPopup
  });
}
var ContentProperty$1 = "";
class ContentProperty extends BaseProperty {
  getTitle() {
    return "Content";
  }
  [SUBSCRIBE(REFRESH_SELECTION, REFRESH_CONTENT) + DEBOUNCE(100)]() {
    this.refreshShow(["text"]);
  }
  getBody() {
    return `
      <div class="property-item elf--content-item">
        <textarea ref="$contentItem"></textarea>
      </div>
    `;
  }
  [BIND("$contentItem")]() {
    var current = this.$context.selection.current;
    if (!current)
      return "";
    return {
      value: current.content || ""
    };
  }
  [INPUT("$contentItem")]() {
    this.setContent();
  }
  setContent() {
    var current = this.$context.selection.current;
    if (current) {
      var data = {
        content: this.refs.$contentItem.value
      };
      current.reset(data);
      this.emit(UPDATE_CANVAS, current);
    }
  }
}
function content(editor) {
  editor.registerElement({
    ContentProperty
  });
}
var designEditorPlugins = [
  configs,
  commands,
  menus,
  defaultConfigs,
  defaultIcons,
  defaultMessages,
  defaultItems,
  defaultPatterns,
  rendererJson,
  baseEditor,
  propertyEditor,
  color,
  gradient,
  layertab,
  inspector,
  depth,
  alignment,
  position,
  layout,
  boxModel,
  pathTool,
  artboard,
  svgText,
  font,
  text,
  textShadow,
  content,
  appearance,
  component,
  backgroundImage,
  patternAsset,
  border,
  borderRadius,
  video,
  image,
  svgFilterAsset,
  svgItem,
  layerTree,
  backgroundClip,
  borderImage,
  filter,
  backdropFilter,
  boxShadow,
  clipPath,
  exportResource,
  transition,
  keyframe,
  animation,
  selector,
  codeview,
  history,
  project,
  selectionInfoView,
  selectionToolView,
  guideLineView,
  layerAppendView,
  lineView,
  hoverView,
  pathDrawView,
  pathEditorView,
  gradientEditorView,
  fillEditorView,
  ClippathEditorView,
  imageAsset,
  sample,
  function(editor) {
    editor.registerMenu("context.menu.layer2", [
      {
        type: "button",
        title: "Layer"
      }
    ]);
    editor.registerMenu("context.menu.layer", [
      {
        type: "button",
        title: "Sample"
      },
      {
        type: "button",
        title: "Sample"
      },
      {
        type: "button",
        title: "Sample",
        action: (editor2) => {
          console.log(editor2);
        }
      },
      {
        type: "button",
        title: "Sample"
      },
      {
        type: "dropdown",
        title: "dropdown",
        items: [
          {
            title: "menu.item.fullscreen.title",
            command: "toggle.fullscreen",
            shortcut: "ALT+/",
            closable: true
          }
        ]
      }
    ]);
    editor.registerUI("context.menu", {
      ContextMenuView
    });
  }
];
var CanvasView$1 = "";
var DragAreaView$1 = "";
class DragAreaRectView extends EditorElement {
  initState() {
    return {
      mode: "selection",
      x: 0,
      y: 0,
      width: 1e4,
      height: 1e4,
      cachedCurrentElement: {},
      html: ""
    };
  }
  template() {
    return `
            <div class="elf--drag-area-view" ref="$dragAreaView" style="pointer-events:none;">
                <div class='drag-area-rect' ref='$dragAreaRect'></div>
            </div>            
        `;
  }
  [SUBSCRIBE("drawAreaView")](style) {
    this.refs.$dragAreaRect.css(style);
  }
  [SUBSCRIBE("initDrawAreaView")]() {
    this.trigger("drawAreaView", {
      left: Length.px(-1e4),
      top: Length.px(0),
      width: Length.px(0),
      height: Length.px(0)
    });
  }
  [SUBSCRIBE("startDragAreaView")]() {
    this.initMousePoint = this.$viewport.getWorldPosition();
    this.dragRect = {
      left: Length.px(this.initMousePoint[0]),
      top: Length.px(this.initMousePoint[1]),
      width: Length.px(0),
      height: Length.px(0)
    };
    this.trigger("drawAreaView", this.dragRect);
  }
  getSelectedItems(rect2, areaVerties) {
    var project2 = this.$context.selection.currentProject;
    let items = [];
    let selectedArtboard = [];
    if (project2) {
      if (rect2.width === 0 && rect2.height === 0) {
        items = [];
      } else {
        project2.layers.forEach((layer) => {
          if (layer.is("artboard") && layer.isIncludeByArea(areaVerties)) {
            selectedArtboard.push(layer);
          } else if (layer.is("artboard") && layer.checkInArea(areaVerties) && layer.hasChildren() === false) {
            items.push(layer);
          } else {
            items.push.apply(items, layer.checkInAreaForAll(areaVerties));
          }
        });
        items = items.filter((it) => {
          return it.isDragSelectable;
        });
        if (items.length > 1) {
          items = items.filter((it) => {
            return it.is("artboard") === false;
          });
        }
      }
    }
    const selectedItems = selectedArtboard.length ? selectedArtboard : items;
    return selectedItems;
  }
  [SUBSCRIBE("moveDragAreaView")]() {
    const e = this.$config.get("bodyEvent");
    const targetMousePoint = this.$viewport.getWorldPosition();
    const newDist = floor([], subtract([], targetMousePoint, this.initMousePoint));
    if (e.shiftKey) {
      newDist[1] = newDist[0];
    }
    const startVertex = floor([], this.initMousePoint);
    const endVertex = floor([], add$1([], this.initMousePoint, newDist));
    const start2 = this.$viewport.applyVertex(startVertex);
    const end2 = this.$viewport.applyVertex(endVertex);
    const locaRect = toRectVerties([start2, end2]);
    this.dragRect = {
      left: locaRect[0][0],
      top: locaRect[0][1],
      width: Math.abs(locaRect[1][0] - locaRect[0][0]),
      height: Math.abs(locaRect[3][1] - locaRect[0][1])
    };
    this.trigger("drawAreaView", {
      left: Length.px(this.dragRect.left),
      top: Length.px(this.dragRect.top),
      width: Length.px(this.dragRect.width),
      height: Length.px(this.dragRect.height)
    });
    var { left: x, top: y, width: width2, height: height2 } = this.dragRect;
    var rect2 = {
      x,
      y,
      width: width2,
      height: height2
    };
    const selectedItems = this.getSelectedItems(rect2, toRectVertiesWithoutTransformOrigin([startVertex, endVertex]));
    this.$context.selection.selectByGroup(...selectedItems);
  }
  [SUBSCRIBE("endDragAreaView")]() {
    const targetMousePoint = this.$viewport.getWorldPosition();
    const newDist = floor([], subtract([], targetMousePoint, this.initMousePoint));
    this.$config.init("set.move.control.point", false);
    if (newDist[0] === 0 && newDist[1] === 0) {
      this.$context.selection.empty();
    }
    this.trigger("initDrawAreaView");
    this.$context.selection.reselect();
    this.$commands.emit("history.refreshSelection");
  }
}
class DragAreaView extends EditorElement {
  initState() {
    return {
      mode: "selection",
      x: 0,
      y: 0,
      width: 1e4,
      height: 1e4,
      cachedCurrentElement: {},
      html: ""
    };
  }
  template() {
    return `
            <div class="elf--drag-area-view" ref="$dragAreaView"></div>            
        `;
  }
  checkSelectionArea(e) {
    const mousePoint = this.$viewport.getWorldPosition(e);
    if (this.$context.selection.hasPoint(mousePoint)) {
      return true;
    }
  }
  checkEditMode(e) {
    if (this.$config.is("editing.mode", EditingMode.HAND)) {
      return false;
    }
    const code2 = this.$context.shortcuts.getGeneratedKeyCode(KEY_CODE.space);
    if (this.$context.keyboardManager.check(code2)) {
      return false;
    }
    const mousePoint = this.$viewport.getWorldPosition(e);
    this.inSelection = false;
    if (this.$context.selection.hasPoint(mousePoint)) {
      this.inSelection = true;
      if (this.$context.selection.current.is("artboard")) {
        if (this.$context.selection.current.hasChildren()) {
          this.$config.init("set.dragarea.mode", true);
          this.$config.init("set.move.mode", false);
          return true;
        } else {
          this.$config.init("set.dragarea.mode", false);
          this.$config.init("set.move.mode", true);
          return true;
        }
      } else {
        this.$config.init("set.dragarea.mode", false);
        this.$config.init("set.move.mode", true);
        return true;
      }
    }
    this.mouseOverItem = this.$context.selection.filteredLayers[0];
    if (this.mouseOverItem) {
      this.$config.init("set.dragarea.mode", false);
      this.$config.init("set.move.mode", true);
    } else {
      this.$config.init("set.dragarea.mode", true);
      this.$config.init("set.move.mode", false);
    }
    return true;
  }
  [POINTERSTART("$dragAreaView") + IF("checkEditMode") + MOVE("movePointer") + END("moveEndPointer")]() {
    if (this.$config.get("set.dragarea.mode")) {
      this.emit("startDragAreaView");
    }
    this.$config.set("editing.mode.itemType", "select");
  }
  initializeDragSelection() {
    this.$context.selection.reselect();
    this.$context.snapManager.clear();
  }
  movePointer() {
    if (this.$config.get("set.dragarea.mode")) {
      this.emit("moveDragAreaView");
    }
  }
  moveEndPointer() {
    if (this.$config.get("set.dragarea.mode")) {
      this.emit("endDragAreaView");
    }
    this.$config.init("set.dragarea.mode", false);
    this.$config.init("set.move.mode", false);
  }
}
var PageTools$1 = "";
class PageTools extends EditorElement {
  template() {
    return `     
      <div class='elf--page-tools'>
        <button type='button' ref='$minus'>${iconUse("remove2")}</button>
        <div class='select'>
          ${createComponent("NumberInputEditor", {
      ref: "$scaleInput",
      min: 10,
      max: 240,
      step: 1,
      key: "scale",
      value: this.$viewport.scale * 100,
      onchange: this.subscribe((key, scale2) => {
        this.$viewport.setScale(scale2 / 100);
        this.emit(UPDATE_VIEWPORT);
        this.trigger(UPDATE_VIEWPORT);
      }, 1e3)
    })}
        </div>
        <label>%</label>
        <button type='button' ref='$plus'>${iconUse("add")}</button>        
        <button type='button' ref='$center' data-tooltip="Move to Center" data-direction="top">${iconUse("gps_fixed")}</button>    
        <button type='button' ref='$ruler' data-tooltip="Toggle Ruler" data-direction="top">${iconUse("straighten")}</button>    
        <button type='button' ref='$fullscreen' data-tooltip="FullScreen Canvas" data-direction="top">${iconUse("fullscreen")}</button>                        
        ${this.$injectManager.generate("page.tools")}                             
      </div>

    `;
  }
  [SUBSCRIBE(UPDATE_VIEWPORT)]() {
    const scale2 = Math.floor(this.$viewport.scale * 100);
    if (this.children.$scaleInput) {
      this.children.$scaleInput.setValue(scale2);
    }
  }
  [CLICK("$plus")]() {
    const oldScale = this.$viewport.scale;
    this.$viewport.setScale(oldScale + 0.01);
    this.emit(UPDATE_VIEWPORT);
    this.trigger(UPDATE_VIEWPORT);
  }
  [CLICK("$minus")]() {
    const oldScale = this.$viewport.scale;
    this.$viewport.setScale(oldScale - 0.01);
    this.emit(UPDATE_VIEWPORT);
    this.trigger(UPDATE_VIEWPORT);
  }
  [CLICK("$center")]() {
    this.$commands.emit("moveSelectionToCenter");
  }
  [CLICK("$ruler")]() {
    this.$config.toggle("show.ruler");
  }
  [CLICK("$fullscreen")]() {
    this.emit("bodypanel.toggle.fullscreen");
  }
  [CLICK("$buttons button")](e) {
    const itemId = e.$dt.data("item-id");
    const pathIndex = e.$dt.data("path-index");
    const current = this.$editor.get(itemId);
    if (current.editablePath) {
      this.$commands.emit("open.editor", current);
    } else {
      const pathList = PathParser.fromSVGString(current.absolutePath().d).toPathList();
      this.emit("showPathEditor", "modify", {
        box: "canvas",
        current,
        matrix: current.matrix,
        d: pathList[pathIndex].d,
        changeEvent: (data) => {
          pathList[pathIndex].reset(data.d);
          const newPathD = current.invertPath(PathParser.joinPathList(pathList).d).d;
          this.$commands.executeCommand("setAttribute", "modify sub path", {
            [itemId]: current.updatePath(newPathD)
          });
        }
      });
    }
    this.emit("hideSelectionToolView");
  }
}
const char_list = [/\(/gi, /\)/gi];
const function_list = "grayscale,matrix,rotateZ,blur,sepia,linear-gradient,radial-gradient,conic-gradient,circle,inset,polygon,rgb".split(",").map((it) => {
  return new RegExp(it, "gi");
});
const keyword_list = "butt,miter,start,at,black,repeat,lighten,multiply,solid,border-box,visible,absolute,relative,auto".split(",").map((it) => {
  return new RegExp(it, "gi");
});
function replaceKeyword(str) {
  keyword_list.forEach((ke) => {
    str = str.replace(ke, (str2) => {
      return `<span class="keyword">${str2}</span>`;
    });
  });
  function_list.forEach((ke) => {
    str = str.replace(ke, (str2) => {
      return `<span class="function">${str2}</span>`;
    });
  });
  char_list.forEach((ke) => {
    str = str.replace(ke, (str2) => {
      return `<span class="char">${str2}</span>`;
    });
  });
  return str;
}
function filterKeyName(str) {
  return str.split(";").filter((it) => it.trim()).map((it) => {
    it = it.trim();
    var [key, value] = it.split(":").map((it2) => it2.trim());
    if (value === "") {
      return "";
    }
    return `<div class="block"><strong>${key}</strong><span>:&nbsp;</span><span class="value">${replaceKeyword(value)}</span><span>;</span></div>`;
  }).join("").trim();
}
function modifyNewLine(str) {
  return str.replace(/;/gi, ";\n").trim();
}
class HTMLRenderer {
  constructor(editor) {
    __privateAdd(this, _id, void 0);
    __privateAdd(this, _renderers, {});
    this.editor = editor;
    __privateSet(this, _id, uuid());
  }
  setRendererType(itemType, renderInstance) {
    renderInstance.setRenderer(this);
    __privateGet(this, _renderers)[itemType] = renderInstance;
  }
  get id() {
    return __privateGet(this, _id);
  }
  getDefaultRendererInstance() {
    return __privateGet(this, _renderers)["rect"];
  }
  getRendererInstance(item) {
    const currentRenderer = __privateGet(this, _renderers)[item.itemType] || this.editor.getRendererInstance("html", item.itemType) || this.getDefaultRendererInstance() || item;
    currentRenderer.setRenderer(this);
    return currentRenderer;
  }
  render(item) {
    if (!item)
      return;
    const currentRenderer = this.getRendererInstance(item);
    if (currentRenderer) {
      return currentRenderer.render(item);
    }
  }
  renderSVG(item) {
    const currentRenderer = this.getRendererInstance(item);
    if (isFunction(currentRenderer.renderSVG)) {
      return currentRenderer.renderSVG(item);
    }
    return this.getDefaultRendererInstance().renderSVG(item);
  }
  to(type, item) {
    const currentRenderer = this.getRendererInstance(item);
    if (isFunction(currentRenderer[type])) {
      return currentRenderer[type].call(currentRenderer, item);
    }
    const defaultInstance = this.getDefaultRendererInstance();
    if (isFunction(defaultInstance[type])) {
      return defaultInstance[type].call(defaultInstance, item);
    }
  }
  toCSS(item, omit = {}) {
    const css = this.to("toCSS", item);
    Object.keys(omit).forEach((key) => {
      delete css[key];
    });
    return css;
  }
  toNestedCSS(item) {
    return this.to("toNestedCSS", item);
  }
  toTransformCSS(item) {
    return this.to("toTransformCSS", item);
  }
  toGridLayoutCSS(item) {
    return this.to("toGridLayoutCSS", item);
  }
  toLayoutItemCSS(item) {
    return this.to("toLayoutItemCSS", item);
  }
  toLayoutBaseModelCSS(item) {
    return this.to("toLayoutBaseModelCSS", item);
  }
  toStyle(item) {
    const currentRenderer = this.getRendererInstance(item);
    if (isFunction(currentRenderer.toStyle)) {
      return currentRenderer.toStyle(item);
    }
    return this.getDefaultRendererInstance().toStyle(item);
  }
  toStyleData(item) {
    const currentRenderer = this.getRendererInstance(item);
    if (isFunction(currentRenderer.toStyleData)) {
      return currentRenderer.toStyleData(item);
    }
    return this.getDefaultRendererInstance().toStyleData(item);
  }
  toExportStyle(item) {
    const currentRenderer = this.getRendererInstance(item);
    if (isFunction(currentRenderer.toExportStyle)) {
      return currentRenderer.toExportStyle(item);
    }
    return this.getDefaultRendererInstance().toExportStyle(item);
  }
  update(item, currentElement, editor) {
    const currentRenderer = this.getRendererInstance(item);
    if (isFunction(currentRenderer.update)) {
      return currentRenderer.update(item, currentElement, editor);
    }
    return this.getDefaultRendererInstance().update(item, currentElement, editor);
  }
  codeview(item) {
    if (!item) {
      return "";
    }
    const currentProject = item.project;
    let keyframeCode = modifyNewLine(filterKeyName(currentProject ? currentProject.toKeyframeString() : ""));
    let rootVariable = currentProject ? CSS_TO_STRING(currentProject.toRootVariableCSS()) : "";
    const current = item;
    const cssCode = filterKeyName(current ? TAG_TO_STRING(CSS_TO_STRING(this.toCSS(current))) : "");
    const nestedCssCode = current ? this.toNestedCSS(current).map((it) => {
      var cssText = it.cssText ? it.cssText : CSS_TO_STRING(it.css);
      return `${it.selector} { 
    ${filterKeyName(TAG_TO_STRING(cssText))}
    }`;
    }) : [];
    const selectorCode = current ? current.selectors : [];
    return `
<div >

${cssCode && `<div><pre title='CSS'>${cssCode}</pre></div>`}

${nestedCssCode.map((it) => {
      return `<div><pre title='CSS'>${it}</pre></div>`;
    }).join("")}

${(selectorCode || []).length ? `<div>
    ${selectorCode.map((selector2) => {
      return `<pre title='${selector2.selector}'>${selector2.toPropertyString()}</pre>`;
    }).join("")}
    
    </div>` : ""}

${keyframeCode && `<div><pre title='Keyframe'>${keyframeCode}</pre></div>`}

${rootVariable ? `<div>
    <label>:root</label>
    <pre>${rootVariable}</pre>
    </div>` : ""}

</div>
        `;
  }
}
_id = new WeakMap();
_renderers = new WeakMap();
class ArtBoardRender$1 extends DomRender {
  render(item) {
    var { id } = item;
    return `<div class="element-item artboard" data-id="${id}">${this.toDefString(item)}${item.layers.map((it) => {
      return this.renderer.render(it);
    }).join("")}</div>`;
  }
  toBorderCSS() {
    return {};
  }
}
class SVGItemRender$1 extends LayerRender {
  update(item, currentElement) {
    this.updateElementCache(item, currentElement);
    super.update(item, currentElement);
  }
  updateElementCache(item, currentElement) {
    if (item.getCache("element") !== currentElement) {
      item.addCache("element", currentElement);
      const $path = currentElement.$("path");
      item.addCache("svgElement", $path.parent().el);
      item.addCache("pathElement", $path.el);
    }
  }
  updateDefString(item, currentElement) {
    var $defs = currentElement.$("defs");
    if ($defs) {
      $defs.updateSVGDiff(`<defs>${this.toDefInnerString(item)}</defs>`);
    } else {
      var str = this.toDefString(item).trim();
      currentElement.prepend(Dom.createByHTML(str));
    }
  }
  toDefInnerString(item) {
    return `
            ${this.toFillSVG(item)}
            ${this.toStrokeSVG(item)}
        `;
  }
  fillId(item) {
    return this.getInnerId(item, "fill");
  }
  strokeId(item) {
    return this.getInnerId(item, "stroke");
  }
  cachedStroke(item) {
    return item.computed("stroke", (value) => {
      if (item.isBooleanItem) {
        return SVGFill.parseImage("transparent");
      } else {
        return SVGFill.parseImage(value || "black");
      }
    });
  }
  cachedFill(item) {
    return item.computed("fill", (value) => {
      if (item.isBooleanItem) {
        return SVGFill.parseImage("transparent");
      } else {
        return SVGFill.parseImage(value || "black");
      }
    });
  }
  toFillSVG(item) {
    var _a;
    const fillValue = this.cachedFill(item);
    return (_a = fillValue == null ? void 0 : fillValue.toSVGString) == null ? void 0 : _a.call(fillValue, this.fillId(item), item.contentBox);
  }
  toStrokeSVG(item) {
    var _a;
    const strokeValue = this.cachedStroke(item);
    return (_a = strokeValue == null ? void 0 : strokeValue.toSVGString) == null ? void 0 : _a.call(strokeValue, this.strokeId(item), item.contentBox);
  }
  toFillValue(item) {
    var _a;
    const fillValue = this.cachedFill(item);
    return (_a = fillValue == null ? void 0 : fillValue.toFillValue) == null ? void 0 : _a.call(fillValue, this.fillId(item));
  }
  toFillOpacityValue(item) {
    return parse(item.fill || "transparent").a;
  }
  toStrokeValue(item) {
    var _a;
    const strokeValue = this.cachedStroke(item);
    return (_a = strokeValue == null ? void 0 : strokeValue.toFillValue) == null ? void 0 : _a.call(strokeValue, this.strokeId(item));
  }
  toFilterValue(item) {
    if (!item.svgfilter) {
      return "";
    }
    return `url(#${item.svgfilter})`;
  }
  toLayoutCSS() {
    return {};
  }
  toDefaultCSS(item) {
    var _a;
    return Object.assign({}, super.toDefaultCSS(item), {
      "stroke-width": item.strokeWidth,
      "stroke-linecap": item.strokeLinecap,
      "stroke-linejoin": item.strokeLinejoin,
      "stroke-dashoffset": item.strokeDashoffset,
      "fill-opacity": item.fillOpacity,
      "fill-rule": item.fillRule,
      "text-anchor": item.textAnchor,
      "stroke-dasharray": (_a = item.strokeDasharray) == null ? void 0 : _a.join(" ")
    });
  }
  toSVGAttribute(item) {
    return this.toDefaultCSS(item);
  }
}
class BooleanPathRender$1 extends SVGItemRender$1 {
  toFillSVG(item) {
    const layers2 = item.layers;
    const op = item.booleanOperation;
    switch (op) {
      case BooleanOperation.DIFFERENCE:
        return SVGFill.parseImage(layers2[1].fill || "transparent").toSVGString(this.fillId(item));
    }
    return SVGFill.parseImage(layers2[0].fill || "transparent").toSVGString(this.fillId(item));
  }
  toStrokeSVG(item) {
    const layers2 = item.layers;
    const op = item.booleanOperation;
    switch (op) {
      case BooleanOperation.DIFFERENCE:
        return SVGFill.parseImage(layers2[1].stroke || "transparent").toSVGString(this.strokeId(item));
    }
    return SVGFill.parseImage(layers2[0].stroke || "black").toSVGString(this.strokeId(item));
  }
  toFillValue(item) {
    var _a, _b;
    const layers2 = item.layers;
    const op = item.booleanOperation;
    switch (op) {
      case BooleanOperation.DIFFERENCE:
        return SVGFill.parseImage(layers2[1].fill || "transparent").toSVGString(this.fillId(item));
    }
    return (_b = (_a = SVGFill.parseImage(layers2[0].fill || "transparent")).toFillValue) == null ? void 0 : _b.call(_a, this.fillId(item));
  }
  toFillOpacityValue(item) {
    return parse(item.fill || "transparent").a;
  }
  toStrokeValue(item) {
    var _a, _b, _c, _d;
    const layers2 = item.layers;
    const op = item.booleanOperation;
    switch (op) {
      case BooleanOperation.DIFFERENCE:
        return (_b = (_a = SVGFill.parseImage(layers2[1].stroke || "transparent")).toFillValue) == null ? void 0 : _b.call(_a, this.strokeId(item));
    }
    return (_d = (_c = SVGFill.parseImage(layers2[0].stroke || "black")).toFillValue) == null ? void 0 : _d.call(_c, this.strokeId(item));
  }
  update(item, currentElement) {
    if (!currentElement)
      return;
    const $path = currentElement.$(`[data-boolean-path-id="${item.id}"]`);
    if ($path) {
      if (item.hasChangedField("changedChildren", "d", "boolean-operation", "width", "height")) {
        $path.setAttrNS({
          d: item.d
        });
      }
      if (item.hasChangedField("fill")) {
        $path.setAttrNS({
          fill: this.toFillValue(item)
        });
      }
      if (item.hasChangedField("stroke")) {
        $path.setAttrNS({
          stroke: this.toStrokeValue(item)
        });
      }
      if (item.hasChangedField("filter")) {
        $path.setAttrNS({
          filter: this.toFilterValue(item)
        });
      }
      if (item.hasChangedField("fill-rule")) {
        $path.setAttrNS({
          "fill-rule": item.fillRule || "nonezero"
        });
      }
      if (item.hasChangedField("stroke-linejoin")) {
        $path.setAttrNS({
          "stroke-linejoin": item.strokeLinejoin
        });
      }
      if (item.hasChangedField("stroke-linecap")) {
        $path.setAttrNS({
          "stroke-linecap": item.strokeLinecap
        });
      }
    }
    super.update(item, currentElement);
  }
  updateElementCache(item, currentElement) {
    if (item.getCache("element") !== currentElement) {
      item.addCache("element", currentElement);
      const $path = currentElement.$(`[data-boolean-path-id="${item.id}"]`);
      item.addCache("svgElement", $path.parent().el);
      item.addCache("pathElement", $path.el);
    }
  }
  render(item) {
    var { id, name, itemType } = item;
    return `    
<div class="element-item ${itemType}" data-id="${id}" data-title="${name}">
  ${this.toDefString(item)}
  ${item.layers.map((it) => {
      return this.renderer.render(it);
    }).join("")}
  <svg xmlns="http://www.w3.org/2000/svg" class="boolean-path-item" width="100%" height="100%" overflow="visible">
    <path 
      class="svg-path-item"
      d="${item.d}"
      data-boolean-path-id="${id}" 
      fill-rule="${item.fillRule}"
      filter="${this.toFilterValue(item)}"
      fill="${this.toFillValue(item)}"
      stroke="${this.toStrokeValue(item)}"
      stroke-linejoin="${item.strokeLinejoin}"
      stroke-linecap="${item.strokeLinecap}"
    />
  </svg>
</div>
    `;
  }
}
class CircleRender$1 extends LayerRender {
}
class ImageRender$1 extends LayerRender {
  toNestedCSS() {
    return [
      {
        selector: "img",
        cssText: `
                width: 100%;
                height: 100%;
                pointer-events: none;
                `.trim()
      }
    ];
  }
  getUrl(item) {
    var { src } = item;
    var project2 = item.project;
    return project2.getImageValueById(src) || src;
  }
  render(item) {
    var { id } = item;
    return `
          <div class='element-item image' data-id="${id}">
            ${this.toDefString(item)}
            <img src='${this.getUrl(item)}' />
          </div>`;
  }
  update(item, currentElement) {
    const $image = currentElement == null ? void 0 : currentElement.$("img");
    if ($image) {
      $image.attr("src", this.getUrl(item));
    }
    super.update(item, currentElement);
  }
}
class ProjectRender$1 extends DomRender {
  toRootVariableCSS(item) {
    let obj2 = {};
    item.rootVariable.split(";").filter((it) => it.trim()).forEach((it) => {
      var [key, value] = it.split(":");
      obj2[`--${key}`] = value;
    });
    return obj2;
  }
  toCSS(item) {
    return Object.assign({}, this.toRootVariableCSS(item));
  }
  toStyle(item) {
    const keyframeString = item.toKeyframeString();
    const rootVariable = this.toRootVariableCSS(item);
    return `
<style type='text/css' data-renderer-type="html" data-id='${item.id}'>
    :root {
        ${CSS_TO_STRING(rootVariable)}
    }
    /* keyframe */
    ${keyframeString}
</style>
        `;
  }
  toExportStyle(item) {
    const keyframeString = item.toKeyframeString();
    const rootVariable = this.toRootVariableCSS(item);
    return `
<style type='text/css' data-renderer-type="html" data-id='${item.id}'>
    :root {
        ${CSS_TO_STRING(rootVariable)}
    }
    /* keyframe */
    ${keyframeString}
</style>
        `;
  }
  render(item) {
    return item.layers.map((it) => {
      return this.renderer.render(it);
    }).join("");
  }
  renderSVG() {
    return "";
  }
}
class RectRender$1 extends LayerRender {
}
class SVGPathRender$1 extends SVGItemRender$1 {
  update(item, currentElement) {
    if (!currentElement)
      return;
    const $path = currentElement.$("path");
    if ($path) {
      if (item.hasChangedField("width", "height", "d")) {
        $path.setAttrNS({
          d: item.d
        });
      }
      if (item.hasChangedField("fill")) {
        $path.setAttrNS({
          fill: this.toFillValue(item)
        });
      }
      if (item.hasChangedField("stroke")) {
        $path.setAttrNS({
          stroke: this.toStrokeValue(item)
        });
      }
      if (item.hasChangedField("filter")) {
        $path.setAttrNS({
          filter: this.toFilterValue(item)
        });
      }
      if (item.hasChangedField("fill-rule")) {
        $path.setAttrNS({
          "fill-rule": item.fillRule || "nonezero"
        });
      }
      if (item.hasChangedField("stroke-linejoin")) {
        $path.setAttrNS({
          "stroke-linejoin": item.strokeLinejoin
        });
      }
      if (item.hasChangedField("stroke-linecap")) {
        $path.setAttrNS({
          "stroke-linecap": item.strokeLinecap
        });
      }
      if (item.hasChangedField("stroke-dasharray")) {
        $path.setAttrNS({
          "stroke-dasharray": item.strokeDasharray.join(" ")
        });
      }
    }
    super.update(item, currentElement);
  }
  render(item) {
    var { id, name, itemType } = item;
    return `    
<div class="element-item ${itemType}" data-id="${id}" data-title="${name}">
  ${this.toDefString(item)}
  <svg xmlns="http://www.w3.org/2000/svg" class="view-path-item" width="100%" height="100%" overflow="visible">
    <path 
      class="svg-path-item"
      d="${item.d}"
      fill-rule="${item.fillRule}"
      filter="${this.toFilterValue(item)}"
      fill="${this.toFillValue(item)}"
      stroke="${this.toStrokeValue(item)}"
      stroke-linejoin="${item.strokeLinejoin}"
      stroke-linecap="${item.strokeLinecap}"
      stroke-dasharray="${item.strokeDasharray.join(" ")}"
    />
  </svg>
</div>
    `;
  }
}
class SplineRender$1 extends SVGPathRender$1 {
  update(item, currentElement) {
    if (!currentElement)
      return;
    var $path = currentElement.$("path");
    if ($path) {
      if (item.hasChangedField("points", "boundary")) {
        $path.setAttrNS({
          d: item.d
        });
      }
    }
    super.update(item, currentElement);
  }
}
class SVGPolygonRender$1 extends SVGItemRender$1 {
  update(item, currentElement) {
    if (!currentElement)
      return;
    var $path = currentElement.$("path");
    if ($path) {
      if (item.hasChangedField("width", "height", "count")) {
        $path.setAttrNS({
          d: item.d
        });
      }
      if (item.hasChangedField("fill")) {
        $path.setAttrNS({
          fill: this.toFillValue(item)
        });
      }
      if (item.hasChangedField("stroke")) {
        $path.setAttrNS({
          stroke: this.toStrokeValue(item)
        });
      }
      if (item.hasChangedField("filter")) {
        $path.setAttrNS({
          filter: this.toFilterValue(item)
        });
      }
      if (item.hasChangedField("fill-rule")) {
        $path.setAttrNS({
          "fill-rule": item.fillRule || "nonezero"
        });
      }
      if (item.hasChangedField("stroke-linejoin")) {
        $path.setAttrNS({
          "stroke-linejoin": item.strokeLinejoin
        });
      }
      if (item.hasChangedField("stroke-linecap")) {
        $path.setAttrNS({
          "stroke-linecap": item.strokeLinecap
        });
      }
    }
    super.update(item, currentElement);
  }
  render(item) {
    var { id, name, itemType } = item;
    return `    
<div class="element-item ${itemType}" data-id="${id}" data-title="${name}">
  ${this.toDefString(item)}
  <svg xmlns="http://www.w3.org/2000/svg" class="view-path-item" width="100%" height="100%" overflow="visible">
    <path 
      class="svg-path-item"
      d="${item.d}"
      fill-rule="${item.fillRule}"
      filter="${this.toFilterValue(item)}"
      fill="${this.toFillValue(item)}"
      stroke="${this.toStrokeValue(item)}"
      stroke-linejoin="${item.strokeLinejoin}"
      stroke-linecap="${item.strokeLinecap}"
    />
  </svg>
</div>
    `;
  }
}
class SVGStarRender$1 extends SVGItemRender$1 {
  update(item, currentElement) {
    if (!currentElement)
      return;
    var $path = currentElement.$("path");
    if ($path) {
      if (item.hasChangedField("width", "height", "count", "radius", "isCurve", "tension")) {
        $path.setAttrNS({
          d: item.d
        });
      }
      if (item.hasChangedField("fill")) {
        $path.setAttrNS({
          fill: this.toFillValue(item)
        });
      }
      if (item.hasChangedField("stroke")) {
        $path.setAttrNS({
          stroke: this.toStrokeValue(item)
        });
      }
      if (item.hasChangedField("filter")) {
        $path.setAttrNS({
          filter: this.toFilterValue(item)
        });
      }
      if (item.hasChangedField("fill-rule")) {
        $path.setAttrNS({
          "fill-rule": item.fillRule || "nonezero"
        });
      }
      if (item.hasChangedField("stroke-linejoin")) {
        $path.setAttrNS({
          "stroke-linejoin": item.strokeLinejoin
        });
      }
      if (item.hasChangedField("stroke-linecap")) {
        $path.setAttrNS({
          "stroke-linecap": item.strokeLinecap
        });
      }
    }
    super.update(item, currentElement);
  }
  render(item) {
    var { id, name, itemType } = item;
    return `    
<div class="element-item ${itemType}" data-id="${id}" data-title="${name}">
  ${this.toDefString(item)}
  <svg xmlns="http://www.w3.org/2000/svg" class="view-path-item" width="100%" height="100%" overflow="visible">
    <path 
      class="svg-path-item"
      d="${item.d}"
      fill-rule="${item.fillRule}"
      filter="${this.toFilterValue(item)}"
      fill="${this.toFillValue(item)}"
      stroke="${this.toStrokeValue(item)}"
      stroke-linejoin="${item.strokeLinejoin}"
      stroke-linecap="${item.strokeLinecap}"
    />
  </svg>
</div>
    `;
  }
}
class SVGTextPathRender$1 extends SVGItemRender$1 {
  update(item, currentElement) {
    var $path = currentElement.$("path.svg-path-item");
    if ($path) {
      if (item.hasChangedField("width", "height", "d")) {
        $path.attr("d", item.d);
      }
    }
    var $guidePath = currentElement.$("path.guide");
    if ($guidePath) {
      if (item.hasChangedField("width", "height", "d")) {
        $guidePath.attr("d", item.d);
      }
    }
    var $textPath = currentElement.$("textPath");
    if ($textPath) {
      if (item.hasChangedField("text")) {
        $textPath.text(item.text);
      }
      if (item.hasChangedField("textLength", "lengthAdjust", "startOffset")) {
        $textPath.setAttrNS({
          textLength: item.textLength,
          lengthAdjust: item.lengthAdjust,
          startOffset: item.startOffset
        });
      }
      if (item.hasChangedField("fill")) {
        $textPath.setAttrNS({
          fill: this.toFillValue(item)
        });
      }
      if (item.hasChangedField("stroke")) {
        $textPath.setAttrNS({
          stroke: this.toStrokeValue(item)
        });
      }
      if (item.hasChangedField("filter")) {
        $textPath.setAttrNS({
          filter: this.toFilterValue(item)
        });
      }
    }
    super.update(item, currentElement);
    item.totalLength = $path.totalLength;
  }
  toDefInnerString(item) {
    return `
        ${this.toPathSVG(item)}
        ${this.toFillSVG(item)}
        ${this.toStrokeSVG(item)}
    `;
  }
  toPathId(item) {
    return this.getInnerId(item, "path");
  }
  toPathSVG(item) {
    return `
    <path class="svg-path-item" id="${this.toPathId(item)}" d="${item.d}" fill="none" />
    `;
  }
  render(item) {
    var { id, textLength, lengthAdjust, startOffset } = item;
    const pathId = `#${this.toPathId(item)}`;
    return `
      <svg class='element-item textpath' data-id="${id}">
        ${this.toDefString(item)}
        <text class="svg-textpath-item">
          <textPath 
            xlink:href="${pathId}"
            textLength="${textLength}"
            lengthAdjust="${lengthAdjust}"
            startOffset="${startOffset}"
          >${item.text}</textPath>
          <use href="${pathId}" stroke-width="1" stroke="black" />
        </text>
        <path class="guide" d="${item.d}" stroke="rgba(0, 0, 0, 0.5)" fill="none"/>
      </svg>
    `;
  }
}
class SVGTextRender$1 extends SVGItemRender$1 {
  update(item, currentElement) {
    var $text = currentElement.$("text");
    if ($text) {
      if (item.hasChangedField("text")) {
        $text.text(item.text);
      }
      if (item.hasChangedField("textLength", "lengthAdjust", "startOffset")) {
        $text.setAttrNS({
          textLength: item.textLength,
          lengthAdjust: item.lengthAdjust,
          startOffset: item.startOffset
        });
      }
      if (item.hasChangedField("fill")) {
        $text.setAttrNS({
          fill: this.toFillValue(item)
        });
      }
      if (item.hasChangedField("stroke")) {
        $text.setAttrNS({
          stroke: this.toStrokeValue(item)
        });
      }
      if (item.hasChangedField("filter")) {
        $text.setAttrNS({
          filter: this.toFilterValue(item)
        });
      }
    }
    super.update(item, currentElement);
  }
  shapeInsideId(item) {
    return this.getInnerId(item, "shape-inside");
  }
  render(item) {
    var { id, textLength, lengthAdjust } = item;
    return `
  <svg class='element-item textpath' data-id="${id}">
    ${this.toDefString(item)}
      <text class="svg-text-item" textLength="${textLength}" lengthAdjust="${lengthAdjust}">${item.text}</text>
  </svg>`;
  }
}
class DomTemplateEngine {
  static compile(template, params = []) {
    return template;
  }
}
const EngineList = {
  dom: DomTemplateEngine
};
class TemplateEngine {
  static compile(engine, template, params = []) {
    const currentEngine = EngineList[engine] || EngineList["dom"];
    return currentEngine.compile(template, params);
  }
}
class TemplateRender$1 extends LayerRender {
  update(item, currentElement) {
    if (item.hasChangedField("x", "y", "width", "height") === false) {
      const compiledTemplate = this.compile(item);
      let $innerHTML = currentElement.$(".inner-html");
      if ($innerHTML) {
        $innerHTML.updateDiff(compiledTemplate);
      }
    }
    super.update(item, currentElement);
  }
  compile(item) {
    return TemplateEngine.compile("dom", item.template, item.params);
  }
  render(item) {
    var { id } = item;
    const compiledTemplate = this.compile(item);
    return `
      <div class='element-item template' data-id="${id}">
        ${this.toDefString(item)}
        <style id="style-${id}">
          [data-id="${id}"] .inner-html {
            width: 100%; 
            height: 100%;
            position:relative;
            display:block;
            pointer-events: none; 
          }

          [data-id="${id}"] .inner-html > * {
            width: 100%; 
            height: 100%;
          }          
        </style>
        <div class="inner-html" data-domdiff-pass="true">
          ${compiledTemplate}
        </div>
      </div>`;
  }
}
class TextRender$1 extends LayerRender {
  toCSS(item) {
    let css = super.toCSS(item);
    css.margin = css.margin || "0px";
    if (item.overflow !== Overflow.SCROLL) {
      if (item.content.length > 0) {
        css.height = "auto";
      }
    }
    return css;
  }
  update(item, currentElement) {
    const $textElement = currentElement == null ? void 0 : currentElement.$(`.text-content`);
    if ($textElement) {
      var { content: content2 } = item;
      $textElement.updateDiff(content2);
    }
    super.update(item, currentElement);
  }
  render(item) {
    var { id, content: content2 } = item;
    return `
            <div class='element-item text' data-id="${id}">
                ${this.toDefString(item)}
                <div class="text-content" tabIndex="-1" data-id="${id}">${content2}</div>
            </div>
        `;
  }
}
class VideoRender$1 extends LayerRender {
  toNestedCSS() {
    return [
      {
        selector: "video",
        cssText: `
                width: 100%;
                height: 100%;
                pointer-events: none;
                `.trim()
      }
    ];
  }
  getUrl(item) {
    var { src } = item;
    var project2 = item.project;
    return project2.getVideoValueById(src);
  }
  render(item) {
    var { id, controls, muted, poster, loop, crossorigin, autoplay } = item;
    return `
        <div class='element-item video' data-id="${id}">
            ${this.toDefString(item)}
            <video 
                controls="${controls}"
                src="${this.getUrl(item)}
                muted="${muted}"
                poster="${poster}"
                loop="${loop}"
                crossorigin="${crossorigin}"
                autoplay="${autoplay}"
            >
                Sorry, your browser doesn't support embedded videos.
            </video>
        </div>`;
  }
  update(item, currentElement) {
    const { currentTime, playbackRate, volume } = item;
    const $video = currentElement.$("video");
    if ($video) {
      $video.setProp({
        currentTime,
        playbackRate,
        volume
      });
    }
    super.update(item, currentElement);
  }
}
function rendererHtml(editor) {
  const renderer = new HTMLRenderer(editor);
  renderer.setRendererType("project", new ProjectRender$1());
  renderer.setRendererType("artboard", new ArtBoardRender$1());
  renderer.setRendererType("rect", new RectRender$1());
  renderer.setRendererType("circle", new CircleRender$1());
  renderer.setRendererType("image", new ImageRender$1());
  renderer.setRendererType("text", new TextRender$1());
  renderer.setRendererType("video", new VideoRender$1());
  renderer.setRendererType("boolean-path", new BooleanPathRender$1());
  renderer.setRendererType("svg-path", new SVGPathRender$1());
  renderer.setRendererType("polygon", new SVGPolygonRender$1());
  renderer.setRendererType("star", new SVGStarRender$1());
  renderer.setRendererType("spline", new SplineRender$1());
  renderer.setRendererType("svg-text", new SVGTextRender$1());
  renderer.setRendererType("svg-textpath", new SVGTextPathRender$1());
  renderer.setRendererType("template", new TemplateRender$1());
  editor.registerRendererType("html", renderer);
}
class SVGRenderer {
  constructor(editor) {
    this.editor = editor;
  }
  getDefaultRendererInstance() {
    return this.editor.getRendererInstance("svg", "rect");
  }
  getRendererInstance(item) {
    return this.editor.getRendererInstance("svg", item.itemType) || this.getDefaultRendererInstance() || item;
  }
  render(item, renderer) {
    if (!item)
      return "";
    const currentRenderer = this.getRendererInstance(item);
    if (currentRenderer) {
      return currentRenderer.render(item, renderer || this);
    }
  }
  toCSS(item) {
    const currentRenderer = this.getRendererInstance(item);
    if (currentRenderer) {
      return currentRenderer.toCSS(item);
    }
  }
  toTransformCSS(item) {
    const currentRenderer = this.getRendererInstance(item);
    if (currentRenderer) {
      return currentRenderer.toTransformCSS(item);
    }
  }
  toStyle(item, renderer) {
    const currentRenderer = this.getRendererInstance(item);
    if (currentRenderer) {
      return currentRenderer.toStyle(item, renderer || this);
    }
  }
  update(item, currentElement) {
    const currentRenderer = this.getRendererInstance(item);
    if (currentRenderer) {
      return currentRenderer.update(item, currentElement);
    }
  }
  codeview(item) {
    if (!item) {
      return "";
    }
    let svgCode = this.render(item);
    svgCode = svgCode.replace(/</g, "&lt;").replace(/>/g, "&gt;");
    return `
<div class='svg-code'>
${svgCode && `<div><pre title='SVG'>${svgCode}</pre></div>`}
</div>
        `;
  }
}
class SVGRender extends DomRender {
  toDefaultCSS(item) {
    return {
      overflow: "visible",
      "background-color": item.backgroundColor,
      color: item.color,
      "font-size": item.fontSize,
      "font-weight": item.fontWeight,
      "font-style": item.fontStyle,
      "font-family": item.fontFamily,
      "text-align": item.textAlign,
      "text-decoration": item.textDecoration,
      "text-transform": item.textTransform,
      "letter-spacing": item.letterSpacing,
      "word-spacing": item.wordSpacing,
      "line-height": item.lineHeight,
      "text-indent": item.textIndent,
      "text-overflow": item.textOverflow,
      "text-wrap": item.textWrap,
      "z-index": item.zIndex,
      opacity: item.opacity,
      "mix-blend-mode": item.mixBlendMode,
      "transform-origin": item.transformOrigin,
      "border-radius": item.borderRadius,
      animation: item.animation,
      transition: item.transition
    };
  }
  toCSS(item) {
    const css = Object.assign({}, this.toVariableCSS(item), this.toDefaultCSS(item), this.toClipPathCSS(item), this.toWebkitCSS(item), this.toTextClipCSS(item), this.toTransformCSS(item), this.toLayoutItemCSS(item), this.toBorderCSS(item), this.toBackgroundImageCSS(item), this.toTextShadowCSS(item), this.toBoxShadowCSS(item), this.toFilterCSS(item), this.toBackdropFilterCSS(item), this.toLayoutCSS(item));
    delete css.left;
    delete css.top;
    delete css.width;
    delete css.height;
    delete css.position;
    return css;
  }
  toSVGAttribute(item) {
    var _a;
    return __spreadProps(__spreadValues({}, this.toDefaultCSS(item)), {
      strokeWidth: item.strokeWidth,
      "fill-opacity": item.fillOpacity,
      "fill-rule": item.fillRule,
      "stroke-linecap": item.strokeLinecap,
      "stroke-linejoin": item.strokeLinejoin,
      "text-anchor": item.textAnchor,
      "stroke-dasharray": (_a = item.strokeDasharray) == null ? void 0 : _a.join(" ")
    });
  }
  wrappedRender(item, callback) {
    const { id, x, y, width: width2, height: height2, itemType } = item;
    return `

<svg class='svg-element-item ${itemType}'
    xmlns="http://www.w3.org/2000/svg"
    data-id="${id}"
    x="${x}"
    y="${y}"
    width="${width2}"
    height="${height2}"
    viewBox="0 0 ${width2} ${height2}"
    overflow="visible"
>
    ${this.toDefString(item)}
    ${isFunction(callback) && callback()}
</svg>
        `;
  }
  render(item, renderer) {
    const { width: width2, height: height2, elementType } = item;
    const tagName = elementType || "div";
    let css = this.toCSS(item);
    return this.wrappedRender(item, () => {
      return `
<foreignObject 
    width="${width2}"
    height="${height2}"
    overflow="visible"
>
    <${tagName} xmlns="http://www.w3.org/1999/xhtml" style="${CSS_TO_STRING(css)};width:100%;height:100%;"></${tagName}>
</foreignObject>    
${item.layers.map((it) => {
        return renderer.render(it, renderer);
      }).join("")}
            `;
    });
  }
}
class ArtBoardRender extends SVGRender {
  toCSS(item) {
    const css = Object.assign({}, this.toDefaultCSS(item), this.toClipPathCSS(item), this.toWebkitCSS(item), this.toTextClipCSS(item), this.toBackgroundImageCSS(item));
    delete css.left;
    delete css.top;
    delete css.width;
    delete css.height;
    delete css.position;
    return css;
  }
  render(item, renderer, encoding = true) {
    const { width: width2, height: height2 } = item;
    let css = this.toCSS(item);
    return `
${encoding ? `<?xml version="1.0"?>` : ""}
<svg 
    xmlns="http://www.w3.org/2000/svg"
    width="${width2}"
    height="${height2}"
    viewBox="0 0 ${width2} ${height2}"
    style="${CSS_TO_STRING(css)}"
>
    ${this.toDefString(item)}
    ${item.layers.map((it) => {
      return renderer.render(it, renderer);
    }).join("")}
</svg>      
        `;
  }
}
class SVGLayerRender extends SVGRender {
}
class SVGItemRender extends SVGLayerRender {
  updateDefString(item, currentElement) {
    var $defs = currentElement.$("defs");
    if ($defs) {
      $defs.html(this.toDefInnerString(item));
    } else {
      var str = this.toDefString(item).trim();
      currentElement.prepend(Dom.createByHTML(str));
    }
  }
  toDefInnerString(item) {
    return `
            ${this.toFillSVG(item)}
            ${this.toStrokeSVG(item)}
        `;
  }
  toDefString(item) {
    const str = this.toDefInnerString(item).trim();
    return `
            <defs>
            ${str}
            </defs>
        `;
  }
  fillId(item) {
    return this.getInnerId(item, "fill");
  }
  strokeId(item) {
    return this.getInnerId(item, "stroke");
  }
  toFillSVG(item) {
    return SVGFill.parseImage(item.fill || "transparent").toSVGString(this.fillId(item));
  }
  toStrokeSVG(item) {
    return SVGFill.parseImage(item.stroke || "black").toSVGString(this.strokeId(item));
  }
  toFillValue(item) {
    return SVGFill.parseImage(item.fill || "transparent").toFillValue(this.fillId(item));
  }
  toFillOpacityValue(item) {
    return parse(item.fill || "transparent").a;
  }
  toStrokeValue(item) {
    return SVGFill.parseImage(item.stroke || "black").toFillValue(this.strokeId(item));
  }
  toFilterValue(item) {
    if (!item.svgfilter) {
      return "";
    }
    return `url(#${item.svgfilter})`;
  }
  toLayoutCSS() {
    return {};
  }
}
class BooleanPathRender extends SVGItemRender {
  update(item, currentElement) {
    if (!currentElement)
      return;
    const $path = currentElement.$(`[data-boolean-path-id="${item.id}"]`);
    if ($path) {
      $path.setAttr({
        d: item.d,
        filter: this.toFilterValue(item),
        fill: this.toFillValue(item),
        stroke: this.toStrokeValue(item)
      });
      item.totalLength = $path.totalLength;
    }
    this.updateDefString(item, currentElement);
  }
  render(item) {
    var { d } = item;
    return this.wrappedRender(item, () => {
      return `
<path ${OBJECT_TO_PROPERTY(__spreadProps(__spreadValues({
        class: "boolean-path-item",
        "data-boolean-path-id": item.id,
        d,
        filter: this.toFilterValue(item),
        fill: this.toFillValue(item),
        stroke: this.toStrokeValue(item)
      }, this.toSVGAttribute(item)), {
        style: CSS_TO_STRING(this.toCSS(item))
      }))} />
    `;
    });
  }
}
class CircleRender extends SVGLayerRender {
}
class IFrameRender extends SVGLayerRender {
  update(item, currentElement) {
    let $iframe = currentElement.$("iframe");
    if ($iframe) {
      $iframe.attr("src", item.url || "about:blank");
    }
    super.update(item, currentElement);
  }
  render(item) {
    const { width: width2, height: height2, url = "about:blank" } = item;
    let css = this.toCSS(item);
    return this.wrappedRender(item, () => {
      return `
  <foreignObject
      width="${width2}"
      height="${height2}"
  >
      <iframe 
          xmlns="http://www.w3.org/1999/xhtml"
          width="100%" 
          height="100%" 
          style="border:0px;width:100%;height:100%;pointer-events:none; ${CSS_TO_STRING(css)}" 
          src="${url}"
      ></iframe>
  </foreignObject>              
          `;
    });
  }
}
class ImageRender extends SVGLayerRender {
  getUrl(item) {
    var { src } = item;
    var project2 = item.project;
    return project2.getImageValueById(src);
  }
  render(item) {
    const { width: width2, height: height2 } = item;
    let css = this.toCSS(item);
    return this.wrappedRender(item, () => {
      return `
            <foreignObject
                width="${width2}"
                height="${height2}"
            >
                <div xmlns="http://www.w3.org/1999/xhtml">
                    <img src='${this.getUrl(item)}' style="width:100%;height:100%; ${CSS_TO_STRING(css)}"  />
                </div>
            </foreignObject>              
          `;
    });
  }
  update(item, currentElement) {
    const $image = currentElement.$("img");
    if ($image) {
      $image.attr("src", this.getUrl(item));
    }
    super.update(item, currentElement);
  }
}
class ProjectRender extends SVGRender {
  render(item, renderer) {
    return item.artboards.map((it) => {
      return renderer.render(it, renderer);
    });
  }
}
class RectRender extends SVGLayerRender {
}
class SplineRender extends SVGItemRender {
  update(item, currentElement) {
    if (!currentElement)
      return;
    var $path = currentElement.$("path");
    if ($path) {
      $path.setAttr({
        d: item.d,
        filter: this.toFilterValue(item),
        fill: this.toFillValue(item),
        stroke: this.toStrokeValue(item)
      });
    }
    this.updateDefString(item, currentElement);
  }
  render(item) {
    var { d } = item;
    return this.wrappedRender(item, () => {
      return `
<path ${OBJECT_TO_PROPERTY(__spreadProps(__spreadValues({
        class: "spline-item",
        d,
        filter: this.toFilterValue(item),
        fill: this.toFillValue(item),
        stroke: this.toStrokeValue(item)
      }, this.toSVGAttribute(item)), {
        style: CSS_TO_STRING(this.toCSS(item))
      }))} />
    `;
    });
  }
}
class SVGPathRender extends SVGItemRender {
  update(item, currentElement) {
    if (!currentElement)
      return;
    var $path = currentElement.$("path");
    if ($path) {
      $path.setAttr({
        d: item.d,
        filter: this.toFilterValue(item),
        fill: this.toFillValue(item),
        stroke: this.toStrokeValue(item)
      });
      item.totalLength = $path.totalLength;
    }
    this.updateDefString(item, currentElement);
  }
  render(item) {
    var { d } = item;
    return this.wrappedRender(item, () => {
      return `
<path ${OBJECT_TO_PROPERTY(__spreadProps(__spreadValues({
        class: "svg-path-item",
        d,
        filter: this.toFilterValue(item),
        fill: this.toFillValue(item),
        stroke: this.toStrokeValue(item)
      }, this.toSVGAttribute(item)), {
        style: CSS_TO_STRING(this.toCSS(item))
      }))} />
    `;
    });
  }
}
class SVGPolygonRender extends SVGItemRender {
  update(item, currentElement) {
    if (!currentElement)
      return;
    var $path = currentElement.$("path");
    if ($path) {
      $path.setAttr({
        d: item.d,
        filter: this.toFilterValue(item),
        fill: this.toFillValue(item),
        stroke: this.toStrokeValue(item)
      });
    }
    this.updateDefString(item, currentElement);
  }
  render(item) {
    var { d } = item;
    return this.wrappedRender(item, () => {
      return `
<path ${OBJECT_TO_PROPERTY(__spreadProps(__spreadValues({
        class: "polygon-item",
        d,
        filter: this.toFilterValue(item),
        fill: this.toFillValue(item),
        stroke: this.toStrokeValue(item)
      }, this.toSVGAttribute(item)), {
        style: CSS_TO_STRING(this.toCSS(item))
      }))} />
    `;
    });
  }
}
class SVGStarRender extends SVGItemRender {
  update(item, currentElement) {
    if (!currentElement)
      return;
    var $path = currentElement.$("path");
    if ($path) {
      $path.setAttr({
        d: item.d,
        filter: this.toFilterValue(item),
        fill: this.toFillValue(item),
        stroke: this.toStrokeValue(item)
      });
    }
    this.updateDefString(item, currentElement);
  }
  render(item) {
    var { d } = item;
    return this.wrappedRender(item, () => {
      return `
<path ${OBJECT_TO_PROPERTY(__spreadProps(__spreadValues({
        class: "star-item",
        d,
        filter: this.toFilterValue(item),
        fill: this.toFillValue(item),
        stroke: this.toStrokeValue(item)
      }, this.toSVGAttribute(item)), {
        style: CSS_TO_STRING(this.toCSS(item))
      }))} />
    `;
    });
  }
}
class SVGTextPathRender extends SVGItemRender {
  update(item, currentElement) {
    var $path = currentElement.$("path");
    if ($path) {
      $path.attr("d", item.d);
    }
    var $textPath = currentElement.$("textPath");
    if ($textPath) {
      $textPath.text(item.text);
      $textPath.setAttr({
        filter: this.toFilterValue(item),
        fill: this.toFillValue(item),
        stroke: this.toStrokeValue(item),
        textLength: item.textLength,
        lengthAdjust: item.lengthAdjust,
        startOffset: item.startOffset
      });
    }
    this.updateDefString(item, currentElement);
    item.totalLength = $path.totalLength;
  }
  toDefInnerString(item) {
    return `
      ${this.toPathSVG(item)}
      ${this.toFillSVG(item)}
      ${this.toStrokeSVG(item)}
    `;
  }
  toPathId(item) {
    return this.getInnerId(item, "path");
  }
  toPathSVG(item) {
    return `
      <path 
        class="svg-path-item"
        id="${this.toPathId(item)}"
        d="${item.d}"
        fill="none"
      />
    `;
  }
  render(item) {
    return this.wrappedRender(item, () => {
      const { textLength, lengthAdjust, startOffset } = item;
      return `
        <textPath ${OBJECT_TO_PROPERTY(__spreadProps(__spreadValues({
        "xlink:href": `#${this.toPathId(item)}`,
        textLength,
        lengthAdjust,
        startOffset,
        filter: this.toFilterValue(item),
        fill: this.toFillValue(item),
        stroke: this.toStrokeValue(item)
      }, this.toSVGAttribute(item)), {
        style: CSS_TO_STRING(this.toCSS(item))
      }))} >${item.text}</textPath>
      `;
    });
  }
}
class SVGTextRender extends SVGItemRender {
  update(item, currentElement) {
    var $text = currentElement.$("text");
    if ($text) {
      $text.text(item.text);
      $text.setAttr({
        filter: this.toFilterValue(item),
        fill: this.toFillValue(item),
        stroke: this.toStrokeValue(item),
        textLength: item.textLength,
        lengthAdjust: item.lengthAdjust
      });
    }
    this.updateDefString(item, currentElement);
  }
  shapeInsideId(item) {
    return this.getInnerId(item, "shape-inside");
  }
  render(item) {
    var { textLength, lengthAdjust } = item;
    return this.wrappedRender(item, () => {
      return `
        <text ${OBJECT_TO_PROPERTY(__spreadProps(__spreadValues({
        class: "svg-text-item",
        textLength,
        lengthAdjust,
        filter: this.toFilterValue(item),
        fill: this.toFillValue(item),
        stroke: this.toStrokeValue(item)
      }, this.toSVGAttribute(item)), {
        style: CSS_TO_STRING(this.toCSS(item))
      }))} >${item.text}</text>
      `;
    });
  }
}
class TemplateRender extends SVGLayerRender {
  update(item, currentElement) {
    const compiledTemplate = this.compile(item);
    let $innerHTML = currentElement.$(".inner-html");
    if ($innerHTML) {
      $innerHTML.updateDiff(compiledTemplate);
    }
    super.update(item, currentElement);
  }
  compile(item) {
    return TemplateEngine.compile("dom", item.template, item.params);
  }
  render(item) {
    const { id, width: width2, height: height2 } = item;
    const compiledTemplate = this.compile(item);
    return this.wrappedRender(item, () => {
      return `
            <foreignObject
                width="${width2}"
                height="${height2}"
            >
                <div  xmlns="http://www.w3.org/1999/xhtml" style="width: 100%;height:100%;">
                    <style id="style-${id}">
                    [data-id="${id}"] .inner-html {
                        width: 100%; 
                        height: 100%;
                        position:relative;
                        display:block;
                        pointer-events: none; 
                    }

                    [data-id="${id}"] .inner-html > * {
                        width: 100%; 
                        height: 100%;
                    }          
                    </style>
                    <div class="inner-html">
                    ${compiledTemplate}
                    </div>
                </div>
            </foreignObject>              
          `;
    });
  }
}
class TextRender extends SVGLayerRender {
  toCSS(item) {
    let css = super.toCSS(item);
    css.margin = css.margin || "0px";
    css.height = "auto";
    return css;
  }
  render(item) {
    const { content: content2, width: width2, height: height2 } = item;
    let css = this.toCSS(item);
    return this.wrappedRender(item, () => {
      return `
            <foreignObject width="${width2}" height="${height2}">
                <p xmlns="http://www.w3.org/1999/xhtml" style="${CSS_TO_STRING(css)}">${content2}</p>
            </foreignObject>              
          `;
    });
  }
  update(item, currentElement) {
    var { content: content2 } = item;
    currentElement.updateDiff(content2);
  }
}
class VideoRender extends SVGLayerRender {
  getUrl(item) {
    var { src } = item;
    var project2 = item.project;
    return project2.getVideoValueById(src);
  }
  render(item) {
    var {
      width: width2,
      height: height2,
      controls,
      muted,
      poster,
      loop,
      crossorigin,
      autoplay
    } = item;
    let css = this.toCSS(item);
    return this.wrappedRender(item, () => {
      return `
            <foreignObject 
                width="${width2}"
                height="${height2}"
                overflow="visible"
            >
                <video 
                    xmlns="http://www.w3.org/1999/xhtml"
                    controls="${controls}"
                    src="${this.getUrl(item)}"
                    muted="${muted}"
                    poster="${poster}"
                    loop="${loop}"
                    crossorigin="${crossorigin}"
                    autoplay="${autoplay}"
                    style="${CSS_TO_STRING(css)};width:100%;height:100%;"></video>
            </foreignObject>    
            `;
    });
  }
}
function rendererSvg(editor) {
  editor.registerRendererType("svg", new SVGRenderer(editor));
  editor.registerRenderer("svg", "project", new ProjectRender());
  editor.registerRenderer("svg", "artboard", new ArtBoardRender());
  editor.registerRenderer("svg", "rect", new RectRender());
  editor.registerRenderer("svg", "circle", new CircleRender());
  editor.registerRenderer("svg", "image", new ImageRender());
  editor.registerRenderer("svg", "template", new TemplateRender());
  editor.registerRenderer("svg", "iframe", new IFrameRender());
  editor.registerRenderer("svg", "video", new VideoRender());
  editor.registerRenderer("svg", "text", new TextRender());
  editor.registerRenderer("svg", "boolean-path", new BooleanPathRender());
  editor.registerRenderer("svg", "svg-path", new SVGPathRender());
  editor.registerRenderer("svg", "polygon", new SVGPolygonRender());
  editor.registerRenderer("svg", "star", new SVGStarRender());
  editor.registerRenderer("svg", "spline", new SplineRender());
  editor.registerRenderer("svg", "svg-text", new SVGTextRender());
  editor.registerRenderer("svg", "svg-textpath", new SVGTextPathRender());
}
var HTMLRenderView$1 = "";
class HTMLRenderView extends EditorElement {
  initialize() {
    super.initialize();
    rendererHtml(this.$editor);
    rendererSvg(this.$editor);
    this.renderer = this.$editor.renderer("html");
  }
  initState() {
    return {
      mode: "selection",
      x: 0,
      y: 0,
      width: 1e4,
      height: 1e4,
      cachedCurrentElement: {},
      doubleClickTime: 0
    };
  }
  template() {
    return `<div class='elf--element-view' ref='$body'>
      <div class='canvas-view' 
        data-renderer-id='${this.renderer.id}' 
        ref='$view' 
        data-outline="${this.$config.get("show.outline")}"
      ></div>
      ${this.$injectManager.generate("render.view")}
    </div>`;
  }
  [BIND("$view")]() {
    const { translate: translate2, transformOrigin: origin, scale: scale2 } = this.$viewport;
    const transform2 = `translate(${translate2[0]}px, ${translate2[1]}px) scale(${scale2 || 1})`;
    const transformOrigin = `${origin[0]}px ${origin[1]}px`;
    return {
      style: {
        "transform-origin": transformOrigin,
        transform: transform2
      }
    };
  }
  [CONFIG("show.outline")]() {
    this.refs.$view.attr("data-outline", this.$config.get("show.outline"));
  }
  [CONFIG("bodyEvent")]() {
    const e = this.$config.get("bodyEvent");
    if (e.buttons === 0) {
      if (Dom.create(e.target).hasClass("elf--drag-area-view")) {
        this.$commands.emit("recoverCursor");
      }
    }
  }
  [SUBSCRIBE("refElement")](id, callback) {
    isFunction(callback) && callback(this.getElement(id));
  }
  [SUBSCRIBE(UPDATE_CANVAS)](obj2) {
    this.refreshSelectionStyleView(obj2);
  }
  [SUBSCRIBE(UPDATE_VIEWPORT)]() {
    this.bindData("$view");
  }
  [SUBSCRIBE("refreshAllElementBoundSize")]() {
    this.refreshAllElementBoundSize();
  }
  [SUBSCRIBE("refreshElementBoundSize")](parentObj) {
    this.refreshElementBoundSize(parentObj);
  }
  [SUBSCRIBE("updateAllCanvas")](parentLayer) {
    this.updateAllCanvas(parentLayer);
  }
  [SUBSCRIBE("refreshAllCanvas")]() {
    this.refreshAllCanvas();
  }
  [SUBSCRIBE("playTimeline", "moveTimeline")]() {
    const project2 = this.$context.selection.currentProject;
    var timeline = project2.getSelectedTimeline();
    if (timeline) {
      timeline.animations.map((it) => this.$model.get(it.id)).forEach((current) => {
        this.updateTimelineElement(current, true, false);
      });
    }
  }
  clearElementAll() {
    this.state.cachedCurrentElement = {};
  }
  clearElement(id) {
    this.state.cachedCurrentElement[id] = void 0;
  }
  getElement(id) {
    if (!this.state.cachedCurrentElement[id]) {
      this.state.cachedCurrentElement[id] = this.refs.$view.$(`[data-id="${id}"]`);
    }
    return this.state.cachedCurrentElement[id];
  }
  [FOCUSOUT("$view .element-item.text .text-content")](e) {
    e.$dt.removeAttr("contenteditable");
    e.$dt.removeClass("focused");
    this.$context.commands.emit("pop.mode.view", "TextEditorView");
    this.$context.commands.emit("recoverCursor");
  }
  [KEYUP("$view .element-item.text .text-content")](e) {
    var content2 = e.$dt.html();
    var text2 = e.$dt.text().trim();
    var id = e.$dt.parent().attr("data-id");
    var arr = [];
    this.$context.selection.items.filter((it) => it.id === id).forEach((item) => {
      item.reset({
        content: content2,
        text: text2
      });
      arr.push({ id: item.id, content: content2, text: text2 });
      this.$commands.emit("setAttribute", {
        [item.id]: {
          content: content2,
          text: text2
        }
      });
    });
    this.emit("refreshContent", arr);
  }
  checkEditMode(e) {
    this.state.hasDoubleClick = false;
    if (window.performance.now() - this.state.doubleClickTime < this.$config.get("event.doubleclick.timing")) {
      this.state.hasDoubleClick = true;
      return false;
    }
    if (this.$config.is("editing.mode", EditingMode.HAND)) {
      return false;
    }
    const code2 = this.$context.shortcuts.getGeneratedKeyCode(KEY_CODE.space);
    if (this.$context.keyboardManager.check(code2)) {
      return false;
    }
    const $target = Dom.create(e.target);
    if ($target.hasClass("canvas-view")) {
      return false;
    }
    if (!e.shiftKey) {
      const mousePoint = this.$viewport.getWorldPosition(e);
      if (this.$context.selection.hasPoint(mousePoint)) {
        if (this.$context.selection.hasHoverItem()) {
          if (this.$context.selection.hasParent(this.$context.selection.hoverId) === false) {
            this.$context.selection.selectHoverItem();
          }
        }
        return true;
      }
      if (this.$context.selection.hasHoverItem()) {
        this.$context.selection.selectHoverItem();
        return true;
      }
    }
    const $element = $target.closest("element-item");
    if ($element) {
      if ($element.hasClass("focused")) {
        return false;
      }
      var id = $element.attr("data-id");
      if (e.altKey === false) {
        const item = this.$model.get(id);
        if (item.is("artboard") && item.hasChildren()) {
          this.$config.init("set.dragarea.mode", true);
          return true;
        }
      }
    } else {
      return false;
    }
    return true;
  }
  [DOUBLECLICK("$view")](e) {
    this.state.doubleClickTime = window.performance.now();
    const $item = Dom.create(e.target).closest("element-item");
    if ($item) {
      const id = $item.attr("data-id");
      const item = this.$model.get(id);
      if (item.is("text")) {
        const $content = $item.$(".text-content");
        $content.addClass("focused");
        $content.attr("contenteditable", "true");
        $content.focus();
        $content.select();
        this.$context.commands.emit("push.mode.view", "TextEditorView");
      } else {
        this.$context.commands.emit("doubleclick.item", e, id);
      }
    }
  }
  [CONTEXTMENU("$view") + PREVENT](e) {
    const $target = Dom.create(e.target);
    const $element = $target.closest("element-item");
    var id = $element && $element.attr("data-id");
    this.$context.selection.select(id);
    this.emit(OPEN_CONTEXT_MENU, {
      target: "context.menu.layer",
      items: [
        "-",
        {
          type: "button",
          checked: true,
          title: "yellow",
          action: () => {
            console.log("console.log", "yellow");
          }
        }
      ],
      x: e.clientX,
      y: e.clientY,
      id
    });
  }
  [POINTERSTART("$view") + IF("checkEditMode") + MOVE("calculateMovedElement") + FIRSTMOVE("calculateFirstMovedElement") + END("calculateEndedElement")](e) {
    this.initMousePoint = this.$viewport.getWorldPosition(e);
    this.$config.init("set.move.control.point", true);
    this.$config.set("editing.mode.itemType", "select");
    if (this.$config.get("set.dragarea.mode")) {
      this.emit("startDragAreaView");
      return;
    }
    let isInSelectedArea = this.$context.selection.hasPoint(this.initMousePoint);
    const $target = Dom.create(e.target);
    if ($target.hasClass("canvas-view")) {
      this.$context.selection.select();
      this.initializeDragSelection();
      return false;
    }
    const $element = $target.closest("element-item");
    var id = $element && $element.attr("data-id");
    if (e.altKey) {
      if (isInSelectedArea)
        ;
      else {
        if (this.$context.selection.check({ id }) === false) {
          this.$context.selection.selectByGroup(id);
        }
      }
      if (this.$context.selection.isEmpty === false) {
        this.$commands.emit("history.copyLayer", "copy");
        this.emit("refreshLayerTreeView");
        this.initializeDragSelection();
      }
    } else {
      if (isInSelectedArea)
        ;
      else {
        if (e.shiftKey) {
          this.$context.selection.toggleById(id);
        } else {
          if (this.$context.selection.check({ id }) === false) {
            const current = this.$model.get(id);
            if (current && current.is("artboard") && current.hasChildren())
              ;
            else if (current.hasChildren()) {
              this.$context.selection.selectByGroup(id);
            } else {
              this.$context.selection.selectByGroup(id);
            }
          }
        }
      }
      this.initializeDragSelection();
    }
  }
  initializeDragSelection() {
    this.$context.selection.reselect();
    this.$context.snapManager.clear();
    this.emit("startGhostToolView");
  }
  calculateFirstMovedElement() {
    this.emit("hideSelectionToolView");
    this.emit("moveFirstGhostToolView");
  }
  calculateMovedElement() {
    if (this.$config.get("set.dragarea.mode")) {
      this.emit("moveDragAreaView");
      return;
    }
    const targetMousePoint = this.$viewport.getWorldPosition();
    this.emit("moveGhostToolView");
    if (this.$context.selection.isLayoutItem) {
      return;
    }
    const newDist = floor([], subtract([], targetMousePoint, this.initMousePoint));
    this.moveTo(newDist);
    if (this.$context.selection.changeInLayoutArea(this.$viewport.applyVertexInverse(targetMousePoint))) {
      this.initMousePoint = targetMousePoint;
      this.$context.selection.reselect();
      this.$context.snapManager.clear();
      this.refreshAllCanvas();
      this.emit("refreshLayerTreeView");
    }
    this.$commands.emit("setAttribute", this.$context.selection.pack("x", "y"));
  }
  moveTo(dist2) {
    const snap = this.$context.snapManager.check(this.$context.selection.cachedRectVerties.map((v) => {
      return add$1([], v, dist2);
    }), 3 / this.$viewport.scale);
    const localDist = add$1([], snap.dist, dist2);
    const result = {};
    this.$context.selection.cachedItemMatrices.forEach((it) => {
      const oldVertex = it.verties[4];
      const newVertex = add$1([], oldVertex, localDist);
      const newDist = subtract([], transformMat4([], newVertex, it.parentMatrixInverse), transformMat4([], oldVertex, it.parentMatrixInverse));
      if (this.$context.selection.isOne) {
        result[it.id] = {
          x: Math.round(it.x + newDist[0]),
          y: Math.round(it.y + newDist[1])
        };
      } else {
        result[it.id] = {
          x: it.x + newDist[0],
          y: it.y + newDist[1]
        };
      }
    });
    this.$context.selection.reset(result);
  }
  calculateEndedElement(dx, dy) {
    if (this.state.hasDoubleClick) {
      this.state.doubleClickTime = window.performance.now();
      return;
    }
    const targetMousePoint = this.$viewport.getWorldPosition();
    const newDist = dist(targetMousePoint, this.initMousePoint);
    this.$config.init("set.move.control.point", false);
    const hasMoved = Math.abs(dx) > 0.5 || Math.abs(dy) > 0.5;
    this.emit("endGhostToolView", hasMoved);
    if (this.$config.get("set.dragarea.mode")) {
      this.emit("endDragAreaView");
      this.$config.init("set.dragarea.mode", false);
      return;
    }
    if (newDist < 1)
      ;
    else {
      this.$context.selection.reselect();
      this.$context.snapManager.clear();
      this.$commands.executeCommand("setAttribute", "move item", this.$context.selection.pack("x", "y"));
      this.nextTick(() => {
        this.$commands.emit("recoverBooleanPath");
      });
    }
    this.$config.set("editing.mode.itemType", "select");
    this.$commands.emit("history.refreshSelection");
    this.emit(REFRESH_SELECTION_TOOL);
  }
  refreshSelectionStyleView(obj2) {
    let target = [];
    if (obj2) {
      if (isArray(obj2)) {
        target = obj2;
      } else {
        target = [obj2];
      }
    } else {
      target = this.$context.selection.items;
    }
    target.forEach((current) => {
      this.updateElement(current);
    });
  }
  updateElement(item) {
    if (item) {
      this.renderer.update(item, this.getElement(item.id), this.$editor);
    }
  }
  updateTimelineElement(item) {
    if (item) {
      this.renderer.update(item, this.getElement(item.id), this.$editor);
    }
  }
  refreshAllCanvas() {
    this.clearElementAll();
    const project2 = this.$context.selection.currentProject;
    const html = this.renderer.render(project2, null, this.$editor) || "";
    this.refs.$view.updateDiff(html, void 0, {
      checkPassed: (oldEl, newEl) => {
        const isPassed = oldEl.getAttribute("data-id") === newEl.getAttribute("data-id");
        return isPassed;
      }
    });
    this.updateAllCanvas(project2);
  }
  updateAllCanvas(parentLayer) {
    parentLayer == null ? void 0 : parentLayer.layers.forEach((item) => {
      this.updateElement(item, this.getElement(item.id));
      this.updateAllCanvas(item);
    });
  }
  refreshAllElementBoundSize() {
    var selectionList = this.$context.selection.items.map((it) => {
      if (it.is("artboard")) {
        return it;
      }
      return it.parent;
    });
    var list2 = [...new Set(selectionList)];
    if (list2.length) {
      list2.forEach((it) => {
        this.refreshElementBoundSize(it);
      });
    } else {
      this.$context.selection.currentProject.artboards.forEach((it) => {
        this.refreshElementBoundSize(it);
      });
    }
  }
  refreshElementRect(item) {
    var $el = this.getElement(item.id);
    if (!$el)
      return;
    let offset = $el.offsetRect();
    if (offset.width === 0 || offset.height === 0) {
      return;
    }
    item.reset(offset);
    this.refreshSelectionStyleView(item);
    if (this.$context.selection.check(item)) {
      this.emit(REFRESH_SELECTION_TOOL);
    }
  }
  refreshElementBoundSize(it) {
    if (it) {
      this.refreshElementRect(it);
      it.layers.forEach((child) => {
        this.refreshElementBoundSize(child);
      });
    }
  }
}
class CanvasView extends EditorElement {
  components() {
    return {
      PageTools,
      DragAreaRectView,
      HTMLRenderView,
      DragAreaView
    };
  }
  initState() {
    return {
      cursor: "auto",
      cursorArgs: []
    };
  }
  afterRender() {
    this.nextTick(() => {
      this.refreshCanvasSize();
      this.$commands.emit("moveSelectionToCenter", true);
      this.refreshCursor();
    });
  }
  template() {
    return /* @__PURE__ */ createElementJsx("div", {
      class: "elf--page-container",
      tabIndex: "-1",
      ref: "$container"
    }, /* @__PURE__ */ createElementJsx("div", {
      class: "page-view",
      ref: "$pageView"
    }, /* @__PURE__ */ createElementJsx("div", {
      class: "page-lock scrollbar",
      ref: "$lock"
    }, /* @__PURE__ */ createElementJsx(DragAreaView, {
      ref: "$dragArea"
    }), /* @__PURE__ */ createElementJsx(HTMLRenderView, {
      ref: "$htmlRenderView"
    }), /* @__PURE__ */ createElementJsx(DragAreaRectView, {
      ref: "$dragAreaRectView"
    }), this.$injectManager.generate("canvas.view", true))), "$", createComponent("PageTools", { ref: "pageTools" }));
  }
  [BIND("$pageView")]() {
    return {
      style: {
        "--elf--canvas-background-color": this.$config.get("style.canvas.background.color")
      }
    };
  }
  checkSpace() {
    if (this.$config.is("editing.mode", EditingMode.HAND)) {
      return true;
    }
    return this.$context.keyboardManager.check(this.$context.shortcuts.getGeneratedKeyCode(KEY_CODE.space));
  }
  [POINTERSTART("$lock") + IF("checkSpace") + MOVE("movePan") + END("moveEndPan")]() {
    this.startMovePan();
  }
  [CONFIG("editing.mode")]() {
    if (this.$config.is("editing.mode", EditingMode.HAND)) {
      this.startMovePan();
      this.$commands.emit("refreshCursor", "grab");
    } else {
      this.$commands.emit("recoverCursor", "auto");
    }
  }
  startMovePan() {
    this.lastDist = create$3();
  }
  movePan(dx, dy) {
    this.$commands.emit("refreshCursor", "grabbing");
    const currentDist = fromValues(dx, dy, 0);
    this.$viewport.pan(...transformMat4([], subtract([], this.lastDist, currentDist), this.$viewport.scaleMatrixInverse));
    this.lastDist = currentDist;
  }
  refreshCursor() {
    if (this.$config.is("editing.mode", EditingMode.HAND)) {
      this.$commands.emit("refreshCursor", "grab");
    } else {
      this.$commands.emit("refreshCursor", "auto");
    }
  }
  moveEndPan() {
    this.refreshCursor();
  }
  [DRAGOVER("$lock") + PREVENT]() {
  }
  [DROP("$lock") + PREVENT](e) {
    const newCenter = this.$viewport.getWorldPosition(e);
    if (e.dataTransfer.getData("text/asset")) {
      this.$commands.emit("drop.asset", {
        asset: { id: e.dataTransfer.getData("text/asset"), center: newCenter }
      });
    } else {
      const id = Dom.create(e.target).attr("data-id");
      if (id) {
        this.$commands.emit("drop.asset", {
          gradient: e.dataTransfer.getData("text/gradient"),
          pattern: e.dataTransfer.getData("text/pattern"),
          color: e.dataTransfer.getData("text/color"),
          imageUrl: e.dataTransfer.getData("image/info")
        }, id);
      } else {
        const imageUrl = e.dataTransfer.getData("image/info");
        this.$commands.emit("dropImageUrl", imageUrl);
      }
    }
  }
  [WHEEL("$lock") + PREVENT](e) {
    const [dx, dy] = normalizeWheelEvent(e);
    if (!this.state.gesture) {
      if (e.ctrlKey) {
        this.$viewport.setMousePoint(e.clientX, e.clientY);
      }
      this.emit("startGesture");
      this.state.gesture = true;
    } else {
      if (e.ctrlKey) {
        const zoomFactor = 1 - 2.5 * dy / 100;
        this.$viewport.zoom(zoomFactor);
      } else {
        const newDx = -2.5 * dx;
        const newDy = -2.5 * dy;
        this.$viewport.pan(-newDx / this.$viewport.scale, -newDy / this.$viewport.scale, 0);
      }
    }
    window.clearTimeout(this.state.timer);
    this.state.timer = window.setTimeout(() => {
      this.state.gesture = void 0;
      this.emit("endGesture");
    }, 200);
  }
  refreshCanvasSize() {
    this.$viewport.refreshCanvasSize(this.refs.$lock.rect());
  }
  [SUBSCRIBE(RESIZE_WINDOW, RESIZE_CANVAS)]() {
    this.refreshCanvasSize();
  }
  [SUBSCRIBE(UPDATE_VIEWPORT)]() {
    this.$commands.emit("refreshCursor", "auto");
  }
}
var HorizontalRuler$1 = "";
let pathString$1 = [];
class HorizontalRuler extends EditorElement {
  template() {
    return `
            <div class="elf--horizontal-ruler">
                <div class='horizontal-ruler-container' ref='$layerRuler'>
                    <svg class="lines" width="100%" width="100%" overflow="hidden">
                        <path ref="$rulerLines" d="" />
                    </svg>
                </div>                            
                <div class='horizontal-ruler-container' ref='$ruler'></div>
                <div class='horizontal-ruler-container' ref='$lines'></div>
                <div class='horizontal-ruler-container'>
                    <div class="cursor" ref="$cursor"></div>
                </div>
            </div>
        `;
  }
  afterRender() {
    this.refreshCanvasSize();
  }
  refreshCanvasSize() {
    this.state.rect = this.$el.rect();
  }
  initializeRect() {
    if (!this.state.rect || this.state.rect.width == 0) {
      this.state.rect = this.$el.rect();
    }
  }
  makeLine(pathString2, baseNumber, minX, maxX, realWidth, width2, epsilon = 3, lineWidth = 30, expect = 10) {
    let startX = minX - minX % baseNumber;
    let endX = maxX + maxX % baseNumber;
    const firstX = (startX - minX) / realWidth * width2;
    const secondX = (startX + baseNumber - minX) / realWidth * width2;
    if (Math.abs(secondX - firstX) < epsilon)
      return;
    for (var i = startX; i < endX; i += baseNumber) {
      if (i != 0 && i % expect === 0)
        continue;
      const x = Math.floor((i - minX) / realWidth * width2);
      pathString2[pathString2.length] = `M ${x} ${30 - lineWidth} L ${x} 30 `;
    }
  }
  makeLineText(baseNumber, minX, maxX, realWidth, width2, epsilon = 3) {
    const text2 = [];
    let startX = minX - minX % baseNumber;
    let endX = maxX + maxX % baseNumber;
    const firstX = (startX - minX) / realWidth * width2;
    const secondX = (startX + baseNumber - minX) / realWidth * width2;
    if (Math.abs(secondX - firstX) < epsilon)
      return;
    for (var i = startX; i < endX; i += baseNumber) {
      const x = Math.floor((i - minX) / realWidth * width2);
      text2[text2.length] = `<text x="${x}" y="${0}" dx="0" dy="6" text-anchor="middle" alignment-baseline="bottom" >${i}</text>`;
    }
    return text2.join("");
  }
  makeRulerForCurrentArtboard() {
    const current = this.$context.selection.current;
    if (!current)
      return "";
    const currentArtboard = current.artboard;
    if (!currentArtboard)
      return "";
    const verties = currentArtboard.verties;
    const { minX, width: realWidth } = this.$viewport;
    const width2 = this.state.rect.width;
    const firstX = (verties[0][0] - minX) / realWidth * width2;
    const secondX = (verties[2][0] - minX) / realWidth * width2;
    return `
            M ${firstX} 20 
            L ${firstX} 30 
            L ${secondX} 30 
            L ${secondX} 20 
            Z
        `;
  }
  makeRulerForCurrent() {
    const current = this.$context.selection.current;
    if (!current)
      return "";
    const verties = this.$context.selection.verties;
    const xList = verties.map((it) => it[0]);
    const currentMinX = Math.min.apply(Math, xList);
    const currentMaxX = Math.max.apply(Math, xList);
    const { minX, width: realWidth } = this.$viewport;
    const width2 = this.state.rect.width;
    const firstX = (currentMinX - minX) / realWidth * width2;
    const secondX = (currentMaxX - minX) / realWidth * width2;
    return `
            M ${firstX} 0 
            L ${firstX} 20 
            L ${secondX} 20 
            L ${secondX} 0 
            Z
        `;
  }
  makeRuler() {
    const { minX, maxX, width: realWidth } = this.$viewport;
    const width2 = this.state.rect.width;
    pathString$1 = [];
    this.makeLine(pathString$1, 1e3, minX, maxX, realWidth, width2, 10, 24, 1e4);
    this.makeLine(pathString$1, 200, minX, maxX, realWidth, width2, 10, 20, 5e3);
    this.makeLine(pathString$1, 100, minX, maxX, realWidth, width2, 10, 20, 200);
    this.makeLine(pathString$1, 50, minX, maxX, realWidth, width2, 10, 20, 100);
    this.makeLine(pathString$1, 10, minX, maxX, realWidth, width2, 10, 18, 50);
    this.makeLine(pathString$1, 5, minX, maxX, realWidth, width2, 10, 15, 10);
    this.makeLine(pathString$1, 1, minX, maxX, realWidth, width2, 10, 13, 10);
    return pathString$1.join("");
  }
  makeRulerText() {
    const { minX, maxX, width: realWidth } = this.$viewport;
    const width2 = this.state.rect.width;
    const dist2 = Math.abs(maxX - minX);
    return [
      dist2 > 3e3 ? this.makeLineText(3e3, minX, maxX, realWidth, width2, 24) : "",
      2e3 < dist2 && dist2 < 3e3 ? this.makeLineText(500, minX, maxX, realWidth, width2, 22) : "",
      1e3 < dist2 && dist2 < 2e3 ? this.makeLineText(100, minX, maxX, realWidth, width2, 20) : "",
      800 < dist2 && dist2 < 1e3 ? this.makeLineText(100, minX, maxX, realWidth, width2, 20) : "",
      500 < dist2 && dist2 < 800 ? this.makeLineText(100, minX, maxX, realWidth, width2, 20) : "",
      500 < dist2 && dist2 < 800 ? this.makeLineText(50, minX, maxX, realWidth, width2, 20) : "",
      200 < dist2 && dist2 < 500 ? this.makeLineText(50, minX, maxX, realWidth, width2, 20) : "",
      50 < dist2 && dist2 < 200 ? this.makeLineText(10, minX, maxX, realWidth, width2, 20) : "",
      15 < dist2 && dist2 < 50 ? this.makeLineText(5, minX, maxX, realWidth, width2, 20) : "",
      0 < dist2 && dist2 < 15 ? this.makeLineText(1, minX, maxX, realWidth, width2, 20) : ""
    ].join("");
  }
  [LOAD("$ruler") + DOMDIFF]() {
    this.initializeRect();
    return `<svg width="100%" width="100%" overflow="hidden"><path d="${this.makeRuler()}" fill="transparent" stroke-width="0.5" stroke="white" transform="translate(0.5, -3)" />${this.makeRulerText()}</svg>`;
  }
  [LOAD("$lines") + DOMDIFF]() {
    this.initializeRect();
    const lines = this.$config.get("horizontal.line").map((it) => {
      const pos = this.$viewport.applyVertex([it, 0, 0]);
      return `<path d="M ${pos[0]} 0 L ${pos[0]} 30"  transform="translate(0.5, 0)" />`;
    }).join("");
    return `<svg width="100%" height="100%" class="horizontal-line" overflow="hidden">${lines}</svg>`;
  }
  [BIND("$rulerLines")]() {
    return {
      d: this.makeRulerForCurrent()
    };
  }
  makeRulerCursor() {
    const targetMousePoint = this.$viewport.getWorldPosition();
    const { minX, width: realWidth } = this.$viewport;
    this.initializeRect();
    const width2 = this.state.rect.width;
    const distX = targetMousePoint[0] - minX;
    const x = distX === 0 ? 0 : distX / realWidth * width2;
    return `M ${x - 0.5} 0 L ${x - 0.5} 20`;
  }
  [BIND("$cursor")]() {
    const targetMousePoint = this.$viewport.getWorldPosition();
    const { minX, width: realWidth } = this.$viewport;
    this.initializeRect();
    const width2 = this.state.rect.width;
    const distX = targetMousePoint[0] - minX;
    const x = distX === 0 ? 0 : distX / realWidth * width2;
    return {
      cssText: `
                --elf--horizontal-cursor-position: ${x}px;
            `
    };
  }
  [MOUSEOVER()]() {
    this.$commands.emit("refreshCursor", "ns-resize");
  }
  [POINTERSTART() + MOVE() + END()]() {
    const pos = round$2([], this.$viewport.getWorldPosition());
    this.startIndex = this.$config.push("vertical.line", pos[1]);
    this.$config.init("vertical.line.selected.index", this.startIndex);
    this.$context.snapManager.clear();
  }
  move() {
    const newPos = this.$context.snapManager.getWorldPosition();
    if (this.$viewport.minY < newPos[1] && newPos[1] < this.$viewport.maxY) {
      this.$config.setIndexValue("vertical.line", this.startIndex, newPos[1]);
    }
  }
  end() {
    const pos = round$2([], this.$viewport.getWorldPosition());
    if (this.$viewport.minY < pos[1] && pos[1] < this.$viewport.maxY)
      ;
    else {
      this.$config.removeIndex("vertical.line", this.startIndex);
    }
    this.startIndex = null;
    this.$commands.emit("recoverCursor");
  }
  refresh() {
    if (this.$config.get("show.ruler")) {
      this.load();
    }
  }
  [SUBSCRIBE(UPDATE_VIEWPORT, REFRESH_SELECTION)]() {
    this.refresh();
  }
  [SUBSCRIBE(UPDATE_CANVAS) + THROTTLE(10)]() {
    if (this.$context.selection.current) {
      const current = this.$context.selection.current;
      if (current.changedRect) {
        this.refresh();
      }
    }
  }
  [SUBSCRIBE(RESIZE_WINDOW, RESIZE_CANVAS)]() {
    this.refreshCanvasSize();
  }
  [CONFIG("onMouseMovepageContainer")]() {
    this.bindData("$cursor");
    this.bindData("$rulerLines");
  }
  [CONFIG("horizontal.line")]() {
    this.load("$lines");
  }
}
var VerticalRuler$1 = "";
let pathString = [];
class VerticalRuler extends EditorElement {
  template() {
    return `
          <div class="elf--vertical-ruler">
            <div class='vertical-ruler-container' ref='$layerRuler'>
                <svg class="lines" width="100%" height="100%" overflow="hidden">
                    <path ref="$rulerLines" d=""/>
                </svg>
            </div>                                        
            <div class='vertical-ruler-container' ref='$body'></div>
            <div class='vertical-ruler-container' ref='$lines'></div>            
            <div class='vertical-ruler-container'>
                <div class="cursor" ref="$cursor"></div>
            </div>                
          </div>
        `;
  }
  afterRender() {
    this.refreshCanvasSize();
  }
  refreshCanvasSize() {
    this.state.rect = this.$el.rect();
  }
  initializeRect() {
    if (!this.state.rect || this.state.rect.width == 0) {
      this.state.rect = this.$el.rect();
    }
  }
  [MOUSEOVER()]() {
    this.$commands.emit("refreshCursor", "ew-resize");
  }
  [MOUSELEAVE()]() {
    this.$commands.emit("recoverCursor");
  }
  [POINTERSTART() + MOVE() + END()]() {
    const pos = round$2([], this.$viewport.getWorldPosition());
    this.startIndex = this.$config.push("horizontal.line", pos[0]);
    this.$config.init("horizontal.line.selected.index", this.startIndex);
    this.$context.snapManager.clear();
  }
  move() {
    const newPos = this.$context.snapManager.getWorldPosition();
    if (this.$viewport.minX < newPos[0] && newPos[0] < this.$viewport.maxX) {
      this.$config.setIndexValue("horizontal.line", this.startIndex, newPos[0]);
    }
  }
  end() {
    const pos = round$2([], this.$viewport.getWorldPosition());
    if (this.$viewport.minX < pos[0] && pos[0] < this.$viewport.maxX)
      ;
    else {
      this.$config.removeIndex("horizontal.line", this.startIndex);
    }
    this.startIndex = null;
    this.$commands.emit("recoverCursor");
  }
  makeLine(pathString2, baseNumber, minY, maxY, realHeight, height2, epsilon = 3, lineWidth = 30, expect = 10) {
    let startY = minY - minY % baseNumber;
    let endY = maxY + maxY % baseNumber;
    const firstY = (startY - minY) / realHeight * height2;
    const secondY = (startY + baseNumber - minY) / realHeight * height2;
    if (Math.abs(secondY - firstY) < epsilon)
      return;
    for (var i = startY; i < endY; i += baseNumber) {
      if (i != 0 && i % expect === 0)
        continue;
      const y = Math.floor((i - minY) / realHeight * height2);
      pathString2[pathString2.length] = `M ${30 - lineWidth} ${y} L 30 ${y}`;
    }
  }
  makeLineText(baseNumber, minY, maxY, realHeight, height2, epsilon = 3) {
    const text2 = [];
    let startY = minY - minY % baseNumber;
    let endY = maxY + maxY % baseNumber;
    const firstY = (startY - minY) / realHeight * height2;
    const secondY = (startY + baseNumber - minY) / realHeight * height2;
    if (Math.abs(secondY - firstY) < epsilon)
      return;
    for (var i = startY; i < endY; i += baseNumber) {
      const y = Math.floor((i - minY) / realHeight * height2);
      text2[text2.length] = `<text x="${0}" y="${y}" dy="4" dominant-baseline="central" transform="rotate(-90, 1, ${y})">${i}</text>`;
    }
    return text2.join("");
  }
  makeRulerForCurrentArtboard() {
    const current = this.$context.selection.current;
    if (!current)
      return "";
    const currentArtboard = current.artboard;
    if (!currentArtboard)
      return "";
    const verties = currentArtboard.verties;
    const { minY, height: realHeight } = this.$viewport;
    const height2 = this.state.rect.height;
    const firstY = (verties[0][1] - minY) / realHeight * height2;
    const secondY = (verties[2][1] - minY) / realHeight * height2;
    return `
            M 20 ${firstY}
            L 30 ${firstY}
            L 30 ${secondY}
            L 20 ${secondY}
            Z
        `;
  }
  makeRulerForCurrent() {
    const current = this.$context.selection.current;
    if (!current)
      return "";
    const { minY, height: realHeight } = this.$viewport;
    const height2 = this.state.rect.height;
    const verties = this.$context.selection.verties;
    const yList = verties.map((it) => it[1]);
    const currentMinY = Math.min.apply(Math, yList);
    const currentMaxY = Math.max.apply(Math, yList);
    const firstY = (currentMinY - minY) / realHeight * height2;
    const secondY = (currentMaxY - minY) / realHeight * height2;
    return `
            M 0 ${firstY}
            L 20 ${firstY}
            L 20 ${secondY}
            L 0 ${secondY}
            Z
        `;
  }
  makeRuler() {
    const { minY, maxY, height: realHeight } = this.$viewport;
    const height2 = this.state.rect.height;
    pathString = [];
    this.makeLine(pathString, 1e3, minY, maxY, realHeight, height2, 10, 20, 1e4);
    this.makeLine(pathString, 200, minY, maxY, realHeight, height2, 10, 16, 5e3);
    this.makeLine(pathString, 100, minY, maxY, realHeight, height2, 10, 18, 200);
    this.makeLine(pathString, 50, minY, maxY, realHeight, height2, 10, 18, 100);
    this.makeLine(pathString, 10, minY, maxY, realHeight, height2, 10, 18, 50);
    this.makeLine(pathString, 5, minY, maxY, realHeight, height2, 10, 15, 10);
    this.makeLine(pathString, 1, minY, maxY, realHeight, height2, 10, 14, 5);
    return pathString.join("");
  }
  makeRulerText() {
    const { minY, maxY, height: realHeight } = this.$viewport;
    const height2 = this.state.rect.height;
    const dist2 = Math.abs(maxY - minY);
    return [
      dist2 > 3e3 ? this.makeLineText(3e3, minY, maxY, realHeight, height2, 24) : "",
      2e3 < dist2 && dist2 < 3e3 ? this.makeLineText(500, minY, maxY, realHeight, height2, 22) : "",
      1e3 < dist2 && dist2 < 2e3 ? this.makeLineText(100, minY, maxY, realHeight, height2, 20) : "",
      800 < dist2 && dist2 < 1e3 ? this.makeLineText(100, minY, maxY, realHeight, height2, 20) : "",
      500 < dist2 && dist2 < 800 ? this.makeLineText(100, minY, maxY, realHeight, height2, 20) : "",
      500 < dist2 && dist2 < 800 ? this.makeLineText(50, minY, maxY, realHeight, height2, 20) : "",
      200 < dist2 && dist2 < 500 ? this.makeLineText(50, minY, maxY, realHeight, height2, 20) : "",
      50 < dist2 && dist2 < 200 ? this.makeLineText(10, minY, maxY, realHeight, height2, 20) : "",
      15 < dist2 && dist2 < 50 ? this.makeLineText(5, minY, maxY, realHeight, height2, 20) : "",
      0 < dist2 && dist2 < 15 ? this.makeLineText(1, minY, maxY, realHeight, height2, 20) : ""
    ].join("");
  }
  [LOAD("$body") + DOMDIFF]() {
    if (!this.state.rect || this.state.rect.width == 0) {
      this.state.rect = this.$el.rect();
    }
    return `<svg width="100%" height="100%" overflow="hidden"><path d="${this.makeRuler()}" fill="transparent" stroke-width="0.5" stroke="white" transform="translate(0, 0.5)" />${this.makeRulerText()}</svg>`;
  }
  [LOAD("$lines") + DOMDIFF]() {
    this.initializeRect();
    const lines = this.$config.get("vertical.line").map((it) => {
      const pos = this.$viewport.applyVertex([0, it, 0]);
      return `<path d="M 0 ${pos[1]} L 30 ${pos[1]}"  transform="translate(0, 0.5)" />`;
    }).join("");
    return `
            <svg width="100%" height="100%" class="vertical-line" overflow="hidden">${lines}</svg>
        `;
  }
  [BIND("$rulerLines")]() {
    return {
      d: this.makeRulerForCurrent()
    };
  }
  [BIND("$cursor")]() {
    const targetMousePoint = this.$viewport.getWorldPosition();
    const { minY, height: realHeight } = this.$viewport;
    this.initializeRect();
    const height2 = this.state.rect.height;
    const distY = targetMousePoint[1] - minY;
    const y = distY === 0 ? 0 : distY / realHeight * height2;
    return {
      cssText: `
                --elf--vertical-cursor-position: ${y}px;
            `
    };
  }
  refresh() {
    if (this.$config.get("show.ruler")) {
      this.load();
    }
  }
  [SUBSCRIBE(UPDATE_CANVAS) + THROTTLE(10)]() {
    const current = this.$context.selection.current;
    if (current && current.changedRect) {
      this.refresh();
    }
  }
  [SUBSCRIBE(UPDATE_VIEWPORT, REFRESH_SELECTION)]() {
    this.refresh();
  }
  [SUBSCRIBE(RESIZE_WINDOW, RESIZE_CANVAS)]() {
    this.refreshCanvasSize();
  }
  [CONFIG("onMouseMovepageContainer")]() {
    this.bindData("$cursor");
    this.bindData("$rulerLines");
  }
  [CONFIG("vertical.line")]() {
    this.load("$lines");
  }
}
var BodyPanel$1 = "";
class BodyPanel extends EditorElement {
  components() {
    return {
      CanvasView,
      VerticalRuler,
      HorizontalRuler,
      PageSubEditor
    };
  }
  template() {
    return `
      <div class="elf--body-panel">
        <div class="submenu-area">
          ${createComponent("PageSubEditor", { ref: "subeditor" })}
        </div>
        <div class='editing-area' ref="$area">
          ${createComponent("HorizontalRuler", { ref: "hruler" })}
          ${createComponent("VerticalRuler", { ref: "vruler" })}
          <div class="canvas-layout">
            ${createComponent("CanvasView", { ref: "canvas" })}
          </div>

        </div>
      </div>
    `;
  }
  [BIND("$el")]() {
    return {
      class: `elf--body-panel ${this.$config.get("show.ruler") ? "ruler" : ""}`
    };
  }
  [CONFIG("show.ruler")]() {
    this.refresh();
  }
  [SUBSCRIBE("bodypanel.toggle.fullscreen")]() {
    this.refs.$el.toggleFullscreen();
  }
  [CONFIG("editor.cursor")]() {
    this.state.cursor = this.$config.get("editor.cursor");
    this.state.cursorArgs = this.$config.get("editor.cursor.args");
    this.bindData("$container");
  }
  [CONFIG("editor.cursor.args")]() {
    this.state.cursor = this.$config.get("editor.cursor");
    this.state.cursorArgs = this.$config.get("editor.cursor.args");
    this.bindData("$area");
  }
  async [BIND("$area")]() {
    const cursor = await this.$context.cursorManager.load(this.state.cursor, ...this.state.cursorArgs || []);
    return {
      style: {
        cursor
      }
    };
  }
}
class DesignEditor extends BlankEditor {
  initialize() {
    super.initialize();
    this.$context.pathkit.load();
  }
  afterRender() {
    super.afterRender();
    this.$commands.emit("load.json", this.opt.data);
    this.$config.init("editor.layout.elements", this.children.$layout.getLayoutElements());
  }
  getManagers() {
    return {
      snapManager: SnapManager,
      selection: SelectionManager,
      segmentSelection: SegmentSelectionManager,
      timeline: TimelineSelectionManager,
      history: HistoryManager,
      modelManager: ModelManager,
      lockManager: LockManager,
      visibleManager: VisibleManager,
      clipboard: ClipboardManager,
      pathkit: PathKitManager
    };
  }
  getPlugins() {
    return designEditorPlugins;
  }
  getBodyPanel() {
    return /* @__PURE__ */ createElementJsx(DefaultLayoutItem, {
      type: "body"
    }, /* @__PURE__ */ createElementJsx(BodyPanel, {
      ref: "$bodyPanelView"
    }));
  }
}
function createDesignEditor(opts) {
  return start$1(DesignEditor, opts);
}
function createBlankEditor(opts) {
  return start$1(BlankEditor, opts);
}
export { ADD_BODY_FIRST_MOUSEMOVE, ADD_BODY_MOUSEMOVE, ADD_BODY_MOUSEUP, AFTER, ALL_TRIGGER, ALT, ANIMATIONEND, ANIMATIONITERATION, ANIMATIONSTART, ARROW_DOWN, ARROW_LEFT, ARROW_RIGHT, ARROW_UP, AlignContent, AlignItems, AssetParser, BACKSPACE, BEFORE, BIND, BIND_CHECK_DEFAULT_FUNCTION, BIND_CHECK_FUNCTION, BLUR, BRACKET_LEFT, BRACKET_RIGHT, BaseProperty, BaseStore, BlankEditor, BlendMode, BooleanOperation, BorderStyle, BoxShadowStyle, CALLBACK, CAPTURE, CHANGE, CHANGEINPUT, CHECKER, CLICK, CMYKtoRGB, COMMAND, CONFIG, CONTEXTMENU, CONTROL, CUSTOM, CanvasViewToolLevel, ClipPathType, ClipboardActionType, ClipboardType, Component, Constraints, ConstraintsDirection, D1000, DEBOUNCE, DELAY, DELETE, DOMDIFF, DOUBLECLICK, DOUBLETAB, DRAG, DRAGEND, DRAGENTER, DRAGEXIT, DRAGLEAVE, DRAGOUT, DRAGOVER, DRAGSTART, DROP, DesignEditor, DesignMode, DirectionNumberType, DirectionType, Dom, DomDiff, END, END_GUESTURE, ENTER, EQUAL, ESCAPE, EVENT, EditingMode, Editor, EditorElement, FIRSTMOVE, FIT, FOCUS, FOCUSIN, FOCUSOUT, FRAME, FUNC_END_CHARACTER, FUNC_REGEXP, FUNC_START_CHARACTER, FlexDirection, FlexWrap, FragmentInstance, FuncType, GradientType, HSLtoHSV, HSLtoRGB, HSVtoHSL, HSVtoRGB, HUEtoRGB, IF, INPUT, IntersectEpsilonNumberType, JustifyContent, KEY, KEYDOWN, KEYMAP_KEYDOWN, KEYMAP_KEYUP, KEYPRESS, KEYUP, KEY_CODE, KeyStringMaker, LABtoRGB, LABtoXYZ, LEFT_BUTTON, LOAD, Language, Layout, Length, MAGIC_METHOD, MAGIC_METHOD_REG, META, MINUS, MOUSE, MOUSEDOWN, MOUSEENTER, MOUSELEAVE, MOUSEMOVE, MOUSEOUT, MOUSEOVER, MOUSEUP, MOVE, MagicMethod, MenuItemType, NAME_SAPARATOR, NotifyType, OBSERVER, ON, OPEN_CONTEXT_MENU, ObjectProperty, Overflow, PARAMS, PASSIVE, PASTE, PEN, PIPE, POINTEREND, POINTERENTER, POINTERMOVE, POINTEROUT, POINTEROVER, POINTERSTART, POP_MODE_VIEW, PREVENT, PUSH_MODE_VIEW, PathGenerator, PathParser, PathSegmentType, PathStringManager, PivotRGB, PivotXyz, Point, PolygonParser, Position, RAF, REFRESH_CONTENT, REFRESH_SELECTION, REFRESH_SELECTION_TOOL, RESIZE, RESIZE_CANVAS, RESIZE_WINDOW, RGBtoCMYK, RGBtoGray, RGBtoHSL, RGBtoHSV, RGBtoLAB, RGBtoSimpleGray, RGBtoXYZ, RGBtoYCrCb, RIGHT_BUTTON, RadialGradientSizeType, RadialGradientType, ResizingMode, ReverseRGB, ReverseXyz, SAPARATOR, SCROLL, SELF, SELF_TRIGGER, SET_LOCALE, SHIFT, SHOW_COMPONENT_POPUP, SHOW_NOTIFY, SPACE, SPLITTER, START_GUESTURE, STOP, SUBMIT, SUBSCRIBE, SUBSCRIBE_ALL, SUBSCRIBE_SELF, SegmentManager, SpreadMethodType, StrokeLineCap, StrokeLineJoin, THROTTLE, TOGGLE_FULLSCREEN, TOUCH, TOUCHEND, TOUCHMOVE, TOUCHSTART, TRANSITIONCANCEL, TRANSITIONEND, TRANSITIONRUN, TRANSITIONSTART, TargetActionType, TextAlign, TextClip, TextDecoration, TextTransform, TimingFunction, TransformValue, UIElement, UPDATE_CANVAS, UPDATE_VIEWPORT, VARIABLE_SAPARATOR, ViewModeType, VisibilityType, WHEEL, XYZtoLAB, XYZtoRGB, YCrCbtoRGB, blend, brightness, c, checkHueColor, classnames, clone$1 as clone, collectProps, combineKeyArray, contrast, contrastColor, convertMatches, convertMatchesArray, createBlankEditor, createComponent, createComponentList, createDesignEditor, createElement, createElementJsx, createHandlerInstance, debounce, defaultValue, format, formatWithoutAlpha, get, getColorIndexString, getRef, getRootElementInstanceList, getVariable, gradient$1 as gradient, gray, hasVariable, hex, hsl, hue_color, ifCheck, initializeGroupVariables, interpolateRGB, interpolateRGBObject, isArray, isBoolean, isColor, isFunction, isNotString, isNotUndefined, isNotZero, isNumber, isObject, isString, isUndefined, isZero, keyEach, keyMap, keyMapJoin, makeEventChecker, makeRequestAnimationFrame, matches, mix, normalizeWheelEvent, parse, parseGradient, random$1 as random, randomByCount, randomNumber, randomRGBA, recoverVariable, registAlias, registElement, registHandler, registRootElementInstance, renderRootElementInstance, renderToString, replaceElement, retriveAlias, retriveElement, retriveHandler, reverseMatches, rgb, scale, scaleH, scaleHSV, scaleS, scaleV, spreadVariable, start$1 as start, throttle, trim, uuid$1 as uuid, uuidShort$1 as uuidShort, variable$4 as variable };
